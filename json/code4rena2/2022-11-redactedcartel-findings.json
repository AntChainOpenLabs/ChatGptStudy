[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Pausable} from \"openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PxERC20} from \"src/PxERC20.sol\";\nimport {PirexFees} from \"src/PirexFees.sol\";\nimport {DelegateRegistry} from \"src/external/DelegateRegistry.sol\";\nimport {IRewardRouterV2} from \"src/interfaces/IRewardRouterV2.sol\";\nimport {RewardTracker} from \"src/external/RewardTracker.sol\";\nimport {IStakedGlp} from \"src/interfaces/IStakedGlp.sol\";\nimport {IVault} from \"src/interfaces/IVault.sol\";\nimport {IRewardDistributor} from \"src/interfaces/IRewardDistributor.sol\";\nimport {IPirexRewards} from \"src/interfaces/IPirexRewards.sol\";\nimport {IGlpManager} from \"src/interfaces/IGlpManager.sol\";\n\ncontract PirexGmx is ReentrancyGuard, Owned, Pausable {\n    using SafeTransferLib for ERC20;\n\n    // Configurable fees\n    enum Fees {\n        Deposit,\n        Redemption,\n        Reward\n    }\n\n    // Configurable external contracts\n    enum Contracts {\n        PirexFees,\n        RewardRouterV2,\n        RewardTrackerGmx,\n        RewardTrackerGlp,\n        FeeStakedGlp,\n        StakedGmx,\n        StakedGlp,\n        GmxVault,\n        GlpManager\n    }\n\n    // Fee denominator\n    uint256 public constant FEE_DENOMINATOR = 1_000_000;\n\n    // Fee maximum (i.e. 20%)\n    uint256 public constant FEE_MAX = 200_000;\n\n    // External token contracts\n    ERC20 public immutable gmxBaseReward; // e.g. WETH (Ethereum)\n    ERC20 public immutable gmx;\n    ERC20 public immutable esGmx;\n\n    // Pirex token contract(s) which are unlikely to change\n    PxERC20 public immutable pxGmx;\n    PxERC20 public immutable pxGlp;\n\n    // Pirex fee repository and distribution contract\n    PirexFees public pirexFees;\n\n    // Pirex reward module contract\n    address public immutable pirexRewards;\n\n    // Snapshot vote delegation contract\n    DelegateRegistry public immutable delegateRegistry;\n\n    // GMX contracts\n    IRewardRouterV2 public gmxRewardRouterV2;\n    RewardTracker public rewardTrackerGmx;\n    RewardTracker public rewardTrackerGlp;\n    RewardTracker public feeStakedGlp;\n    RewardTracker public stakedGmx;\n    IStakedGlp public stakedGlp;\n    address public glpManager;\n    IVault public gmxVault;\n\n    // Migration related address\n    address public migratedTo;\n\n    // Snapshot space\n    bytes32 public delegationSpace = bytes32(\"gmx.eth\");\n\n    // Fees (e.g. 5000 / 1000000 = 0.5%)\n    mapping(Fees => uint256) public fees;\n\n    event ConfigureGmxState(\n        address indexed caller,\n        RewardTracker rewardTrackerGmx,\n        RewardTracker rewardTrackerGlp,\n        RewardTracker feeStakedGlp,\n        RewardTracker stakedGmx,\n        address glpManager,\n        IVault gmxVault\n    );\n    event SetFee(Fees indexed f, uint256 fee);\n    event SetContract(Contracts indexed c, address contractAddress);\n    event DepositGmx(\n        address indexed caller,\n        address indexed receiver,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event DepositGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event RedeemGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 minOut,\n        uint256 redemption,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event ClaimRewards(\n        uint256 baseRewards,\n        uint256 esGmxRewards,\n        uint256 gmxBaseRewards,\n        uint256 glpBaseRewards,\n        uint256 gmxEsGmxRewards,\n        uint256 glpEsGmxRewards\n    );\n    event ClaimUserReward(\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 rewardAmount,\n        uint256 feeAmount\n    );\n    event InitiateMigration(address newContract);\n    event CompleteMigration(address oldContract);\n    event SetDelegationSpace(string delegationSpace, bool shouldClear);\n    event SetVoteDelegate(address voteDelegate);\n    event ClearVoteDelegate();\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidToken(address token);\n    error NotPirexRewards();\n    error InvalidFee();\n    error EmptyString();\n    error NotMigratedTo();\n    error PendingMigration();\n\n    /**\n        @param  _pxGmx              address  PxGmx contract address\n        @param  _pxGlp              address  PxGlp contract address\n        @param  _pirexFees          address  PirexFees contract address\n        @param  _pirexRewards       address  PirexRewards contract address\n        @param  _delegateRegistry   address  Delegation registry contract address\n        @param  _gmxBaseReward      address  GMX base reward token contract address\n        @param  _gmx                address  GMX token contract address\n        @param  _esGmx              address  esGMX token contract address\n        @param  _gmxRewardRouterV2  address  GMX Reward Router contract address\n        @param  _stakedGlp          address  Staked GLP token contract address\n    */\n    constructor(\n        address _pxGmx,\n        address _pxGlp,\n        address _pirexFees,\n        address _pirexRewards,\n        address _delegateRegistry,\n        address _gmxBaseReward,\n        address _gmx,\n        address _esGmx,\n        address _gmxRewardRouterV2,\n        address _stakedGlp\n    ) Owned(msg.sender) {\n        // Start the contract paused, to ensure contract set is properly configured\n        _pause();\n\n        if (_pxGmx == address(0)) revert ZeroAddress();\n        if (_pxGlp == address(0)) revert ZeroAddress();\n        if (_pirexFees == address(0)) revert ZeroAddress();\n        if (_pirexRewards == address(0)) revert ZeroAddress();\n        if (_delegateRegistry == address(0)) revert ZeroAddress();\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_esGmx == address(0)) revert ZeroAddress();\n        if (_gmxRewardRouterV2 == address(0)) revert ZeroAddress();\n        if (_stakedGlp == address(0)) revert ZeroAddress();\n\n        pxGmx = PxERC20(_pxGmx);\n        pxGlp = PxERC20(_pxGlp);\n        pirexFees = PirexFees(_pirexFees);\n        pirexRewards = _pirexRewards;\n        delegateRegistry = DelegateRegistry(_delegateRegistry);\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        esGmx = ERC20(_esGmx);\n        gmxRewardRouterV2 = IRewardRouterV2(_gmxRewardRouterV2);\n        stakedGlp = IStakedGlp(_stakedGlp);\n    }\n\n    modifier onlyPirexRewards() {\n        if (msg.sender != pirexRewards) revert NotPirexRewards();\n        _;\n    }\n\n    /**\n        @notice Compute post-fee asset and fee amounts from a fee type and total assets\n        @param  f              enum     Fee\n        @param  assets         uint256  GMX/GLP/WETH asset amount\n        @return postFeeAmount  uint256  Post-fee asset amount (for mint/burn/claim/etc.)\n        @return feeAmount      uint256  Fee amount\n     */\n    function _computeAssetAmounts(Fees f, uint256 assets)\n        internal\n        view\n        returns (uint256 postFeeAmount, uint256 feeAmount)\n    {\n        feeAmount = (assets * fees[f]) / FEE_DENOMINATOR;\n        postFeeAmount = assets - feeAmount;\n\n        assert(feeAmount + postFeeAmount == assets);\n    }\n\n    /**\n        @notice Calculate the base (e.g. WETH) or esGMX rewards for either GMX or GLP\n        @param  isBaseReward  bool     Whether to calculate base or esGMX rewards\n        @param  useGmx        bool     Whether the calculation should be for GMX\n        @return               uint256  Amount of WETH/esGMX rewards\n     */\n    function _calculateRewards(bool isBaseReward, bool useGmx)\n        internal\n        view\n        returns (uint256)\n    {\n        RewardTracker r;\n\n        if (isBaseReward) {\n            r = useGmx ? rewardTrackerGmx : rewardTrackerGlp;\n        } else {\n            r = useGmx ? stakedGmx : feeStakedGlp;\n        }\n\n        address distributor = r.distributor();\n        uint256 pendingRewards = IRewardDistributor(distributor)\n            .pendingRewards();\n        uint256 distributorBalance = (isBaseReward ? gmxBaseReward : esGmx)\n            .balanceOf(distributor);\n        uint256 blockReward = pendingRewards > distributorBalance\n            ? distributorBalance\n            : pendingRewards;\n        uint256 precision = r.PRECISION();\n        uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() +\n            ((blockReward * precision) / r.totalSupply());\n\n        if (cumulativeRewardPerToken == 0) return 0;\n\n        return\n            r.claimableReward(address(this)) +\n            ((r.stakedAmounts(address(this)) *\n                (cumulativeRewardPerToken -\n                    r.previousCumulatedRewardPerToken(address(this)))) /\n                precision);\n    }\n\n    /**\n        @notice Configure GMX contract state\n     */\n    function configureGmxState() external onlyOwner whenPaused {\n        // Variables which can be assigned by reading previously-set GMX contracts\n        rewardTrackerGmx = RewardTracker(gmxRewardRouterV2.feeGmxTracker());\n        rewardTrackerGlp = RewardTracker(gmxRewardRouterV2.feeGlpTracker());\n        feeStakedGlp = RewardTracker(gmxRewardRouterV2.stakedGlpTracker());\n        stakedGmx = RewardTracker(gmxRewardRouterV2.stakedGmxTracker());\n        glpManager = gmxRewardRouterV2.glpManager();\n        gmxVault = IVault(IGlpManager(glpManager).vault());\n\n        emit ConfigureGmxState(\n            msg.sender,\n            rewardTrackerGmx,\n            rewardTrackerGlp,\n            feeStakedGlp,\n            stakedGmx,\n            glpManager,\n            gmxVault\n        );\n\n        // Approve GMX to enable staking\n        gmx.safeApprove(address(stakedGmx), type(uint256).max);\n    }\n\n    /**\n        @notice Set fee\n        @param  f    enum     Fee\n        @param  fee  uint256  Fee amount\n     */\n    function setFee(Fees f, uint256 fee) external onlyOwner {\n        if (fee > FEE_MAX) revert InvalidFee();\n\n        fees[f] = fee;\n\n        emit SetFee(f, fee);\n    }\n\n    /**\n        @notice Set a contract address\n        @param  c                enum     Contracts\n        @param  contractAddress  address  Contract address\n     */\n    function setContract(Contracts c, address contractAddress)\n        external\n        onlyOwner\n    {\n        if (contractAddress == address(0)) revert ZeroAddress();\n\n        emit SetContract(c, contractAddress);\n\n        if (c == Contracts.PirexFees) {\n            pirexFees = PirexFees(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardRouterV2) {\n            gmxRewardRouterV2 = IRewardRouterV2(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGmx) {\n            rewardTrackerGmx = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGlp) {\n            rewardTrackerGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.FeeStakedGlp) {\n            feeStakedGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.StakedGmx) {\n            // Set the current stakedGmx (pending change) approval amount to 0\n            gmx.safeApprove(address(stakedGmx), 0);\n\n            stakedGmx = RewardTracker(contractAddress);\n\n            // Approve the new stakedGmx contract address allowance to the max\n            gmx.safeApprove(contractAddress, type(uint256).max);\n            return;\n        }\n\n        if (c == Contracts.StakedGlp) {\n            stakedGlp = IStakedGlp(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.GmxVault) {\n            gmxVault = IVault(contractAddress);\n            return;\n        }\n\n        glpManager = contractAddress;\n    }\n\n    /**\n        @notice Deposit GMX for pxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  pxGMX receiver\n        @return           uint256  GMX deposited\n        @return           uint256  pxGMX minted for the receiver\n        @return           uint256  pxGMX distributed as fees\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's GMX to this contract and stake it for rewards\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n        gmxRewardRouterV2.stakeGmx(amount);\n\n        // Get the pxGMX amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGMX for the receiver (excludes fees)\n        pxGmx.mint(receiver, postFeeAmount);\n\n        // Mint pxGMX for fee distribution contract\n        if (feeAmount != 0) {\n            pxGmx.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGmx(msg.sender, receiver, amount, postFeeAmount, feeAmount);\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit fsGLP for pxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  pxGLP receiver\n        @return           uint256  fsGLP deposited\n        @return           uint256  pxGLP minted for the receiver\n        @return           uint256  pxGLP distributed as fees\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's fsGLP (unstaked for the user, staked for this contract)\n        stakedGlp.transferFrom(msg.sender, address(this), amount);\n\n        // Get the pxGLP amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGLP for the receiver (excludes fees)\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            address(stakedGlp),\n            0,\n            0,\n            0,\n            amount,\n            postFeeAmount,\n            feeAmount\n        );\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit GLP for pxGLP\n        @param  token          address  GMX-whitelisted token for minting GLP (optional)\n        @param  tokenAmount    uint256  Token amount\n        @param  minUsdg        uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp         uint256  Minimum GLP amount minted from tokens\n        @param  receiver       address  pxGLP receiver\n        @return deposited      uint256  GLP deposited\n        @return postFeeAmount  uint256  pxGLP minted for the receiver\n        @return feeAmount      uint256  pxGLP distributed as fees\n     */\n    function _depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        internal\n        returns (\n            uint256 deposited,\n            uint256 postFeeAmount,\n            uint256 feeAmount\n        )\n    {\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (token == address(0)) {\n            // Mint and stake GLP using ETH\n            deposited = gmxRewardRouterV2.mintAndStakeGlpETH{\n                value: tokenAmount\n            }(minUsdg, minGlp);\n        } else {\n            ERC20 t = ERC20(token);\n\n            // Intake user ERC20 tokens and approve GLP Manager contract for amount\n            t.safeTransferFrom(msg.sender, address(this), tokenAmount);\n            t.safeApprove(glpManager, tokenAmount);\n\n            // Mint and stake GLP using ERC20 tokens\n            deposited = gmxRewardRouterV2.mintAndStakeGlp(\n                token,\n                tokenAmount,\n                minUsdg,\n                minGlp\n            );\n        }\n\n        // Calculate the post-fee and fee amounts based on the fee type and total deposited\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            deposited\n        );\n\n        // Mint pxGLP for the receiver\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            deposited,\n            postFeeAmount,\n            feeAmount\n        );\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for pxGLP\n        @param  minUsdg    uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp     uint256  Minimum GLP amount minted from ETH\n        @param  receiver   address  pxGLP receiver\n        @return deposited  uint256  GLP deposited\n        @return            uint256  pxGLP minted for the receiver\n        @return            uint256  pxGLP distributed as fees\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _depositGlp(address(0), msg.value, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for pxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  pxGLP receiver\n        @return              uint256  GLP deposited\n        @return              uint256  pxGLP minted for the receiver\n        @return              uint256  pxGLP distributed as fees\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (token == address(0)) revert ZeroAddress();\n        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);\n\n        return _depositGlp(token, tokenAmount, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Redeem pxGLP\n        @param  token          address  GMX-whitelisted token to be redeemed (optional)\n        @param  amount         uint256  pxGLP amount\n        @param  minOut         uint256  Minimum token output from GLP redemption\n        @param  receiver       address  Output token recipient\n        @return redeemed       uint256  Output tokens from redeeming GLP\n        @return postFeeAmount  uint256  pxGLP burned from the msg.sender\n        @return feeAmount      uint256  pxGLP distributed as fees\n     */\n    function _redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        internal\n        returns (\n            uint256 redeemed,\n            uint256 postFeeAmount,\n            uint256 feeAmount\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (minOut == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Calculate the post-fee and fee amounts based on the fee type and total amount\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\n            Fees.Redemption,\n            amount\n        );\n\n        // Burn pxGLP before redeeming the underlying GLP\n        pxGlp.burn(msg.sender, postFeeAmount);\n\n        // Transfer pxGLP from caller to the fee distribution contract\n        if (feeAmount != 0) {\n            ERC20(pxGlp).safeTransferFrom(\n                msg.sender,\n                address(pirexFees),\n                feeAmount\n            );\n        }\n\n        // Unstake and redeem the underlying GLP for ERC20 tokens\n        redeemed = token == address(0)\n            ? gmxRewardRouterV2.unstakeAndRedeemGlpETH(\n                postFeeAmount,\n                minOut,\n                receiver\n            )\n            : gmxRewardRouterV2.unstakeAndRedeemGlp(\n                token,\n                postFeeAmount,\n                minOut,\n                receiver\n            );\n\n        emit RedeemGlp(\n            msg.sender,\n            receiver,\n            token,\n            amount,\n            minOut,\n            redeemed,\n            postFeeAmount,\n            feeAmount\n        );\n    }\n\n    /**\n        @notice Redeem pxGLP for ETH from redeeming GLP\n        @param  amount    uint256  pxGLP amount\n        @param  minOut    uint256  Minimum ETH output from GLP redemption\n        @param  receiver  address  ETH recipient\n        @return           uint256  ETH redeemed from GLP\n        @return           uint256  pxGLP burned from the msg.sender\n        @return           uint256  pxGLP distributed as fees\n     */\n    function redeemPxGlpETH(\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _redeemPxGlp(address(0), amount, minOut, receiver);\n    }\n\n    /**\n        @notice Redeem pxGLP for ERC20 tokens from redeeming GLP\n        @param  token     address  GMX-whitelisted token to be redeemed\n        @param  amount    uint256  pxGLP amount\n        @param  minOut    uint256  Minimum ERC20 output from GLP redemption\n        @param  receiver  address  ERC20 token recipient\n        @return           uint256  ERC20 tokens from redeeming GLP\n        @return           uint256  pxGLP burned from the msg.sender\n        @return           uint256  pxGLP distributed as fees\n     */\n    function redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (token == address(0)) revert ZeroAddress();\n        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);\n\n        return _redeemPxGlp(token, amount, minOut, receiver);\n    }\n\n    /**\n        @notice Claim WETH/esGMX rewards + multiplier points (MP)\n        @return producerTokens  ERC20[]    Producer tokens (pxGLP and pxGMX)\n        @return rewardTokens    ERC20[]    Reward token contract instances\n        @return rewardAmounts   uint256[]  Reward amounts from each producerToken\n     */\n    function claimRewards()\n        external\n        onlyPirexRewards\n        returns (\n            ERC20[] memory producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        // Assign return values used by the PirexRewards contract\n        producerTokens = new ERC20[](4);\n        rewardTokens = new ERC20[](4);\n        rewardAmounts = new uint256[](4);\n        producerTokens[0] = pxGmx;\n        producerTokens[1] = pxGlp;\n        producerTokens[2] = pxGmx;\n        producerTokens[3] = pxGlp;\n        rewardTokens[0] = gmxBaseReward;\n        rewardTokens[1] = gmxBaseReward;\n        rewardTokens[2] = ERC20(pxGmx); // esGMX rewards distributed as pxGMX\n        rewardTokens[3] = ERC20(pxGmx);\n\n        // Get pre-reward claim reward token balances to calculate actual amount received\n        uint256 baseRewardBeforeClaim = gmxBaseReward.balanceOf(address(this));\n        uint256 esGmxBeforeClaim = stakedGmx.depositBalances(\n            address(this),\n            address(esGmx)\n        );\n\n        // Calculate the unclaimed reward token amounts produced for each token type\n        uint256 gmxBaseRewards = _calculateRewards(true, true);\n        uint256 glpBaseRewards = _calculateRewards(true, false);\n        uint256 gmxEsGmxRewards = _calculateRewards(false, true);\n        uint256 glpEsGmxRewards = _calculateRewards(false, false);\n\n        // Claim and stake esGMX + MP, and claim WETH\n        gmxRewardRouterV2.handleRewards(\n            false,\n            false,\n            true,\n            true,\n            true,\n            true,\n            false\n        );\n\n        uint256 baseRewards = gmxBaseReward.balanceOf(address(this)) -\n            baseRewardBeforeClaim;\n        uint256 esGmxRewards = stakedGmx.depositBalances(\n            address(this),\n            address(esGmx)\n        ) - esGmxBeforeClaim;\n\n        if (baseRewards != 0) {\n            // This may not be necessary and is more of a hedge against a discrepancy between\n            // the actual rewards and the calculated amounts. Needs further consideration\n            rewardAmounts[0] =\n                (gmxBaseRewards * baseRewards) /\n                (gmxBaseRewards + glpBaseRewards);\n            rewardAmounts[1] = baseRewards - rewardAmounts[0];\n        }\n\n        if (esGmxRewards != 0) {\n            rewardAmounts[2] =\n                (gmxEsGmxRewards * esGmxRewards) /\n                (gmxEsGmxRewards + glpEsGmxRewards);\n            rewardAmounts[3] = esGmxRewards - rewardAmounts[2];\n        }\n\n        emit ClaimRewards(\n            baseRewards,\n            esGmxRewards,\n            gmxBaseRewards,\n            glpBaseRewards,\n            gmxEsGmxRewards,\n            glpEsGmxRewards\n        );\n    }\n\n    /**\n        @notice Mint/transfer the specified reward token to the receiver\n        @param  token     address  Reward token address\n        @param  amount    uint256  Reward amount\n        @param  receiver  address  Reward receiver\n     */\n    function claimUserReward(\n        address token,\n        uint256 amount,\n        address receiver\n    ) external onlyPirexRewards {\n        if (token == address(0)) revert ZeroAddress();\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Reward,\n            amount\n        );\n\n        if (token == address(pxGmx)) {\n            // Mint pxGMX for the user - the analog for esGMX rewards\n            pxGmx.mint(receiver, postFeeAmount);\n\n            if (feeAmount != 0) pxGmx.mint(address(pirexFees), feeAmount);\n        } else if (token == address(gmxBaseReward)) {\n            gmxBaseReward.safeTransfer(receiver, postFeeAmount);\n\n            if (feeAmount != 0)\n                gmxBaseReward.safeTransfer(address(pirexFees), feeAmount);\n        }\n\n        emit ClaimUserReward(receiver, token, amount, postFeeAmount, feeAmount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        VOTE DELEGATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Set delegationSpace\n        @param  _delegationSpace  string  Snapshot delegation space\n        @param  shouldClear       bool    Whether to clear the vote delegate for the current space\n     */\n    function setDelegationSpace(\n        string memory _delegationSpace,\n        bool shouldClear\n    ) external onlyOwner {\n        if (shouldClear) {\n            // Clear the delegation for the current delegation space\n            clearVoteDelegate();\n        }\n\n        bytes memory d = bytes(_delegationSpace);\n\n        if (d.length == 0) revert EmptyString();\n\n        delegationSpace = bytes32(d);\n\n        emit SetDelegationSpace(_delegationSpace, shouldClear);\n    }\n\n    /**\n        @notice Set vote delegate\n        @param  voteDelegate  address  Account to delegate votes to\n     */\n    function setVoteDelegate(address voteDelegate) external onlyOwner {\n        if (voteDelegate == address(0)) revert ZeroAddress();\n\n        emit SetVoteDelegate(voteDelegate);\n\n        delegateRegistry.setDelegate(delegationSpace, voteDelegate);\n    }\n\n    /**\n        @notice Clear vote delegate\n     */\n    function clearVoteDelegate() public onlyOwner {\n        emit ClearVoteDelegate();\n\n        delegateRegistry.clearDelegate(delegationSpace);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        EMERGENCY/MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Set the contract's pause state\n        @param state  bool  Pause state\n    */\n    function setPauseState(bool state) external onlyOwner {\n        if (state) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**\n        @notice Initiate contract migration (called by the old contract)\n        @param  newContract  address  Address of the new contract\n    */\n    function initiateMigration(address newContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (newContract == address(0)) revert ZeroAddress();\n\n        // Notify the reward router that the current/old contract is going to perform\n        // full account transfer to the specified new contract\n        gmxRewardRouterV2.signalTransfer(newContract);\n\n        migratedTo = newContract;\n\n        emit InitiateMigration(newContract);\n    }\n\n    /**\n        @notice Migrate remaining (base) reward to the new contract after completing migration\n    */\n    function migrateReward() external whenPaused {\n        if (msg.sender != migratedTo) revert NotMigratedTo();\n        if (gmxRewardRouterV2.pendingReceivers(address(this)) != address(0))\n            revert PendingMigration();\n\n        // Transfer out any remaining base reward (ie. WETH) to the new contract\n        gmxBaseReward.safeTransfer(\n            migratedTo,\n            gmxBaseReward.balanceOf(address(this))\n        );\n    }\n\n    /**\n        @notice Complete contract migration (called by the new contract)\n        @param  oldContract  address  Address of the old contract\n    */\n    function completeMigration(address oldContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (oldContract == address(0)) revert ZeroAddress();\n\n        // Trigger harvest to claim remaining rewards before the account transfer\n        IPirexRewards(pirexRewards).harvest();\n\n        // Complete the full account transfer process\n        gmxRewardRouterV2.acceptTransfer(oldContract);\n\n        // Perform reward token transfer from the old contract to the new one\n        PirexGmx(oldContract).migrateReward();\n\n        emit CompleteMigration(oldContract);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {IRewardDistributor} from \"src/interfaces/IRewardDistributor.sol\";\nimport {IWETH} from \"src/interfaces/IWETH.sol\";\nimport {DelegateRegistry} from \"src/external/DelegateRegistry.sol\";\nimport {RewardTracker} from \"src/external/RewardTracker.sol\";\nimport {IGlpManager} from \"src/interfaces/IGlpManager.sol\";\nimport {IVault} from \"src/interfaces/IVault.sol\";\nimport {Helper} from \"./Helper.sol\";\n\ncontract PirexGmxTest is Test, Helper {\n    bytes internal constant PAUSED_ERROR = \"Pausable: paused\";\n    bytes internal constant NOT_PAUSED_ERROR = \"Pausable: not paused\";\n    bytes internal constant INSUFFICIENT_OUTPUT_ERROR =\n        \"GlpManager: insufficient output\";\n    bytes internal constant INSUFFICIENT_GLP_OUTPUT_ERROR =\n        \"GlpManager: insufficient GLP output\";\n\n    /**\n        @notice Get an address that is unauthorized (i.e. not owner)\n        @return unauthorizedCaller  address  Unauthorized caller\n     */\n    function _getUnauthorizedCaller()\n        internal\n        returns (address unauthorizedCaller)\n    {\n        unauthorizedCaller = testAccounts[0];\n\n        assertTrue(unauthorizedCaller != pirexGmx.owner());\n    }\n\n    /**\n        @notice Pause and verify pause state for contract\n     */\n    function _pauseContract() internal {\n        pirexGmx.setPauseState(true);\n\n        assertEq(true, pirexGmx.paused());\n    }\n\n    /**\n        @notice Set fee, verify event emission, and validate new state\n        @param  f    enum     Fee type\n        @param  fee  uint256  Fee\n     */\n    function _setFee(PirexGmx.Fees f, uint256 fee) internal {\n        vm.expectEmit(true, false, false, true, address(pirexGmx));\n\n        emit SetFee(f, fee);\n\n        pirexGmx.setFee(f, fee);\n\n        assertEq(fee, pirexGmx.fees(f));\n    }\n\n    /**\n        @notice Set contract, verify event emission, and validate new state\n        @param  c                enum     Contract type\n        @param  contractAddress  address  Contract address\n     */\n    function _setContract(PirexGmx.Contracts c, address contractAddress)\n        internal\n    {\n        vm.expectEmit(true, false, false, true, address(pirexGmx));\n\n        emit SetContract(c, contractAddress);\n\n        pirexGmx.setContract(c, contractAddress);\n\n        address newContractAddress;\n\n        // Use a conditional statement to set newContractAddress since no getter\n        if (c == PirexGmx.Contracts.PirexFees)\n            newContractAddress = address(pirexGmx.pirexFees());\n        if (c == PirexGmx.Contracts.RewardRouterV2)\n            newContractAddress = address(pirexGmx.gmxRewardRouterV2());\n        if (c == PirexGmx.Contracts.RewardTrackerGmx)\n            newContractAddress = address(pirexGmx.rewardTrackerGmx());\n        if (c == PirexGmx.Contracts.RewardTrackerGlp)\n            newContractAddress = address(pirexGmx.rewardTrackerGlp());\n        if (c == PirexGmx.Contracts.FeeStakedGlp)\n            newContractAddress = address(pirexGmx.feeStakedGlp());\n        if (c == PirexGmx.Contracts.StakedGmx)\n            newContractAddress = address(pirexGmx.stakedGmx());\n        if (c == PirexGmx.Contracts.StakedGlp)\n            newContractAddress = address(pirexGmx.stakedGlp());\n        if (c == PirexGmx.Contracts.GmxVault)\n            newContractAddress = address(pirexGmx.gmxVault());\n        if (c == PirexGmx.Contracts.GlpManager)\n            newContractAddress = address(pirexGmx.glpManager());\n\n        assertEq(contractAddress, newContractAddress);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            configureGmxState TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotConfigureGmxStateUnauthorized() external {\n        address unauthorizedCaller = _getUnauthorizedCaller();\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.configureGmxState();\n    }\n\n    /**\n        @notice Test tx reversion: contract is not paused\n     */\n    function testCannotConfigureGmxStateNotPaused() external {\n        assertEq(false, pirexGmx.paused());\n\n        vm.expectRevert(NOT_PAUSED_ERROR);\n\n        pirexGmx.configureGmxState();\n    }\n\n    /**\n        @notice Test tx success: configure GMX state\n     */\n    function testConfigureGmxState() external {\n        PirexGmx freshPirexGmx = new PirexGmx(\n            address(pxGmx),\n            address(pxGlp),\n            address(pirexFees),\n            address(pirexRewards),\n            address(delegateRegistry),\n            // The `weth` variable is used on both Ethereum and Avalanche for the base rewards\n            REWARD_ROUTER_V2.weth(),\n            REWARD_ROUTER_V2.gmx(),\n            REWARD_ROUTER_V2.esGmx(),\n            address(REWARD_ROUTER_V2),\n            address(STAKED_GLP)\n        );\n\n        assertEq(address(this), freshPirexGmx.owner());\n        assertEq(true, freshPirexGmx.paused());\n        assertEq(address(0), address(freshPirexGmx.rewardTrackerGmx()));\n        assertEq(address(0), address(freshPirexGmx.rewardTrackerGlp()));\n        assertEq(address(0), address(freshPirexGmx.feeStakedGlp()));\n        assertEq(address(0), address(freshPirexGmx.stakedGmx()));\n        assertEq(address(0), address(freshPirexGmx.glpManager()));\n        assertEq(address(0), address(freshPirexGmx.gmxVault()));\n        assertEq(0, gmx.allowance(address(freshPirexGmx), address(stakedGmx)));\n\n        IVault gmxVault = IVault(IGlpManager(glpManager).vault());\n\n        vm.expectEmit(true, false, false, true, address(freshPirexGmx));\n\n        emit ConfigureGmxState(\n            address(this),\n            rewardTrackerGmx,\n            rewardTrackerGlp,\n            feeStakedGlp,\n            stakedGmx,\n            address(glpManager),\n            gmxVault\n        );\n\n        freshPirexGmx.configureGmxState();\n\n        assertEq(\n            address(rewardTrackerGmx),\n            address(freshPirexGmx.rewardTrackerGmx())\n        );\n        assertEq(\n            address(rewardTrackerGlp),\n            address(freshPirexGmx.rewardTrackerGlp())\n        );\n        assertEq(address(feeStakedGlp), address(freshPirexGmx.feeStakedGlp()));\n        assertEq(address(stakedGmx), address(freshPirexGmx.stakedGmx()));\n        assertEq(address(glpManager), address(freshPirexGmx.glpManager()));\n        assertEq(address(gmxVault), address(freshPirexGmx.gmxVault()));\n        assertEq(type(uint256).max, gmx.allowance(address(freshPirexGmx), address(stakedGmx)));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            setFee TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetFeeUnauthorized() external {\n        address unauthorizedCaller = _getUnauthorizedCaller();\n        uint256 fee = 1;\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.setFee(PirexGmx.Fees.Deposit, fee);\n    }\n\n    /**\n        @notice Test tx reversion: fee is invalid\n     */\n    function testCannotSetFeeInvalidFee() external {\n        uint256 invalidFee = feeMax + 1;\n\n        for (uint256 i; i < feeTypes.length; ++i) {\n            vm.expectRevert(PirexGmx.InvalidFee.selector);\n\n            pirexGmx.setFee(feeTypes[i], invalidFee);\n        }\n    }\n\n    /**\n        @notice Test tx success: set fees for each type\n        @param  depositFee     uint24  Deposit fee\n        @param  redemptionFee  uint24  Redemption fee\n        @param  rewardFee      uint24  Reward fee\n     */\n    function testSetFee(\n        uint24 depositFee,\n        uint24 redemptionFee,\n        uint24 rewardFee\n    ) external {\n        vm.assume(depositFee != 0);\n        vm.assume(depositFee <= feeMax);\n        vm.assume(redemptionFee != 0);\n        vm.assume(redemptionFee < feeMax);\n        vm.assume(rewardFee != 0);\n        vm.assume(rewardFee < feeMax);\n\n        PirexGmx.Fees depositFeeType = feeTypes[0];\n        PirexGmx.Fees redemptionFeeType = feeTypes[1];\n        PirexGmx.Fees rewardFeeType = feeTypes[2];\n\n        assertEq(0, pirexGmx.fees(depositFeeType));\n        assertEq(0, pirexGmx.fees(redemptionFeeType));\n        assertEq(0, pirexGmx.fees(rewardFeeType));\n\n        // Set and validate the different fee types\n        _setFee(depositFeeType, depositFee);\n        _setFee(redemptionFeeType, redemptionFee);\n        _setFee(rewardFeeType, rewardFee);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setContract TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetContractNotAuthorized() external {\n        address unauthorizedCaller = _getUnauthorizedCaller();\n        address contractAddress = address(this);\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.setContract(\n            PirexGmx.Contracts.RewardRouterV2,\n            contractAddress\n        );\n    }\n\n    /**\n        @notice Test tx reversion: contractAddress is the zero address\n     */\n    function testCannotSetContractZeroAddress() external {\n        address invalidContractAddress = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.setContract(\n            PirexGmx.Contracts.RewardRouterV2,\n            invalidContractAddress\n        );\n    }\n\n    /**\n        @notice Test tx success: set pirexFees to a new contract address\n     */\n    function testSetContractPirexFees() external {\n        address currentContractAddress = address(pirexGmx.pirexFees());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.PirexFees, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set gmxRewardRouterV2 to a new contract address\n     */\n    function testSetContractRewardRouterV2() external {\n        address currentContractAddress = address(pirexGmx.gmxRewardRouterV2());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.RewardRouterV2, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set rewardTrackerGmx to a new contract address\n     */\n    function testSetContractRewardTrackerGmx() external {\n        address currentContractAddress = address(pirexGmx.rewardTrackerGmx());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.RewardTrackerGmx, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set rewardTrackerGlp to a new contract address\n     */\n    function testSetContractRewardTrackerGlp() external {\n        address currentContractAddress = address(pirexGmx.rewardTrackerGlp());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.RewardTrackerGlp, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set feeStakedGlp to a new contract address\n     */\n    function testSetContractFeeStakedGlp() external {\n        address currentContractAddress = address(pirexGmx.feeStakedGlp());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.FeeStakedGlp, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set stakedGmx to a new contract address\n     */\n    function testSetContractStakedGmx() external {\n        address currentContractAddress = address(pirexGmx.stakedGmx());\n        uint256 currentContractAddressAllowance = type(uint256).max;\n        address contractAddress = address(this);\n\n        assertFalse(contractAddress == currentContractAddress);\n        assertEq(\n            currentContractAddressAllowance,\n            gmx.allowance(address(pirexGmx), currentContractAddress)\n        );\n\n        uint256 expectedCurrentContractAllowance = 0;\n        uint256 expectedContractAddressAllowance = type(uint256).max;\n\n        assertFalse(\n            currentContractAddressAllowance == expectedCurrentContractAllowance\n        );\n\n        _setContract(PirexGmx.Contracts.StakedGmx, contractAddress);\n\n        assertEq(\n            expectedCurrentContractAllowance,\n            gmx.allowance(address(pirexGmx), currentContractAddress)\n        );\n        assertEq(\n            expectedContractAddressAllowance,\n            gmx.allowance(address(pirexGmx), contractAddress)\n        );\n    }\n\n    /**\n        @notice Test tx success: set feeStakedGlp to a new contract address\n     */\n    function testSetContractStakedGlp() external {\n        address currentContractAddress = address(pirexGmx.stakedGlp());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.StakedGlp, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set gmxVault to a new contract address\n     */\n    function testSetContractGmxVault() external {\n        address currentContractAddress = address(pirexGmx.gmxVault());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.GmxVault, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set glpManager to a new contract address\n     */\n    function testSetContractGlpManager() external {\n        address currentContractAddress = address(pirexGmx.glpManager());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.GlpManager, contractAddress);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGmx TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotDepositGmxPaused() external {\n        _pauseContract();\n\n        uint256 assets = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.depositGmx(assets, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: assets is zero\n     */\n    function testCannotDepositGmxAssetsZeroAmount() external {\n        uint256 invalidAssets = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGmx(invalidAssets, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotDepositGmxReceiverZeroAddress() external {\n        uint256 assets = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.depositGmx(assets, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx reversion: insufficient GMX balance\n        @param  assets      uint80  GMX amount\n        @param  mintAmount  uint80  GMX mint amount\n     */\n    function testCannotDepositGmxInsufficientBalance(\n        uint80 assets,\n        uint80 mintAmount\n    ) external {\n        vm.assume(assets != 0);\n        vm.assume(mintAmount < assets);\n\n        address receiver = address(this);\n\n        _mintApproveGmx(\n            mintAmount,\n            address(this),\n            address(pirexGmx),\n            mintAmount\n        );\n\n        vm.expectRevert(\"TRANSFER_FROM_FAILED\");\n\n        pirexGmx.depositGmx(assets, receiver);\n    }\n\n    /**\n        @notice Test tx success: deposit GMX for pxGMX\n        @param  depositFee      uint24  Deposit fee\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  separateCaller  bool    Whether to separate method caller and receiver\n     */\n    function testDepositGmx(\n        uint24 depositFee,\n        uint8 multiplier,\n        bool separateCaller\n    ) external {\n        vm.assume(depositFee <= feeMax);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        _setFee(PirexGmx.Fees.Deposit, depositFee);\n\n        uint256 expectedPreDepositGmxBalancePirexGmx = 0;\n        uint256 expectedPreDepositPxGmxSupply = 0;\n\n        assertEq(\n            expectedPreDepositGmxBalancePirexGmx,\n            rewardTrackerGmx.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPreDepositPxGmxSupply, pxGmx.totalSupply());\n\n        // Deposits GMX, verifies event emission, and validates depositGmx return values\n        uint256[] memory depositAmounts = _depositGmxForTestAccounts(\n            separateCaller,\n            address(this),\n            multiplier\n        );\n\n        // Assign the initial post-deposit values to their pre-deposit counterparts\n        uint256 expectedPostDepositGmxBalancePirexGmx = expectedPreDepositGmxBalancePirexGmx;\n        uint256 expectedPostDepositPxGmxSupply = expectedPreDepositPxGmxSupply;\n        uint256 tLen = testAccounts.length;\n\n        for (uint256 i; i < tLen; ++i) {\n            uint256 depositAmount = depositAmounts[i];\n\n            expectedPostDepositGmxBalancePirexGmx += depositAmount;\n            expectedPostDepositPxGmxSupply += depositAmount;\n\n            (uint256 postFeeAmount, ) = _computeAssetAmounts(\n                PirexGmx.Fees.Deposit,\n                depositAmount\n            );\n\n            // Check test account balances against post-fee pxGMX mint amount\n            assertEq(postFeeAmount, pxGmx.balanceOf(testAccounts[i]));\n        }\n\n        assertEq(\n            expectedPostDepositGmxBalancePirexGmx,\n            rewardTrackerGmx.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPostDepositPxGmxSupply, pxGmx.totalSupply());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositFsGlp TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotDepositFsGlpPaused() external {\n        _pauseContract();\n\n        uint256 assets = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.depositFsGlp(assets, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: assets is zero\n     */\n    function testCannotDepositFsGlpAssetsZeroAmount() external {\n        uint256 invalidAssets = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositFsGlp(invalidAssets, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotDepositFsGlpReceiverZeroAddress() external {\n        uint256 assets = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.depositFsGlp(assets, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx reversion: insufficient fsGLP balance\n        @param  ethAmount  uint72  ETH amount\n     */\n    function testCannotDepositFsGlpInsufficientBalance(uint72 ethAmount)\n        external\n    {\n        vm.assume(ethAmount > 0.001 ether);\n        vm.assume(ethAmount < 1000 ether);\n\n        uint256 invalidAssets = _mintAndApproveFsGlp(ethAmount, address(this)) +\n            1;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(\"StakedGlp: transfer amount exceeds allowance\");\n\n        pirexGmx.depositFsGlp(invalidAssets, receiver);\n    }\n\n    /**\n        @notice Test tx success: deposit fsGLP for pxGLP\n        @param  depositFee      uint24  Deposit fee\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  separateCaller  bool    Whether to separate method caller and receiver\n     */\n    function testDepositFsGlp(\n        uint24 depositFee,\n        uint8 multiplier,\n        bool separateCaller\n    ) external {\n        vm.assume(depositFee <= feeMax);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        _setFee(PirexGmx.Fees.Deposit, depositFee);\n\n        uint256 tLen = testAccounts.length;\n        uint256 expectedPreDepositGlpBalancePirexGmx = 0;\n        uint256 expectedPreDepositPxGlpSupply = 0;\n\n        assertEq(\n            expectedPreDepositGlpBalancePirexGmx,\n            feeStakedGlp.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPreDepositPxGlpSupply, pxGlp.totalSupply());\n\n        uint256 expectedPostDepositGlpBalancePirexGmx = expectedPreDepositGlpBalancePirexGmx;\n        uint256 expectedPostDepositPxGlpSupply = expectedPreDepositPxGlpSupply;\n\n        for (uint256 i; i < tLen; ++i) {\n            address testAccount = testAccounts[i];\n            address caller = separateCaller ? address(this) : testAccount;\n            uint256 assets = _mintAndApproveFsGlp(1 ether * multiplier, caller);\n            address receiver = testAccount;\n\n            vm.prank(caller);\n            vm.expectEmit(true, true, true, false, address(pirexGmx));\n\n            emit DepositGlp(\n                caller,\n                receiver,\n                address(STAKED_GLP),\n                0,\n                0,\n                0,\n                0,\n                0,\n                0\n            );\n\n            (uint256 deposited, uint256 postFeeAmount, ) = pirexGmx\n                .depositFsGlp(assets, receiver);\n            uint256 receiverPxGlpBalance = pxGlp.balanceOf(receiver);\n\n            expectedPostDepositGlpBalancePirexGmx += deposited;\n            expectedPostDepositPxGlpSupply += deposited;\n\n            assertLt(0, receiverPxGlpBalance);\n            assertEq(postFeeAmount, receiverPxGlpBalance);\n        }\n\n        assertEq(\n            expectedPostDepositGlpBalancePirexGmx,\n            feeStakedGlp.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPostDepositPxGlpSupply, pxGlp.totalSupply());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGlpETH TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotDepositGlpETHPaused() external {\n        _pauseContract();\n\n        uint256 etherAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.deal(address(this), etherAmount);\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.depositGlpETH{value: etherAmount}(minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: msg.value is zero\n     */\n    function testCannotDepositGlpETHMsgValueZeroAmount() external {\n        uint256 invalidEtherAmount = 0;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGlpETH{value: invalidEtherAmount}(\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minUsdg is zero\n     */\n    function testCannotDepositGlpETHMinUsdgZeroAmount() external {\n        uint256 etherAmount = 1 ether;\n        uint256 invalidMinUsdg = 0;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.deal(address(this), etherAmount);\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGlpETH{value: etherAmount}(\n            invalidMinUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is zero\n     */\n    function testCannotDepositGlpETHMinGlpZeroAmount() external {\n        uint256 etherAmount = 1 ether;\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlp = 0;\n        address receiver = address(this);\n\n        vm.deal(address(this), etherAmount);\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGlpETH{value: etherAmount}(\n            minUsdg,\n            invalidMinGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotDepositGlpETHReceiverZeroAddress() external {\n        uint256 etherAmount = 1 ether;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address invalidReceiver = address(0);\n\n        vm.deal(address(this), etherAmount);\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.depositGlpETH{value: etherAmount}(\n            minUsdg,\n            minGlp,\n            invalidReceiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is greater than output\n     */\n    function testCannotDepositGlpETHMinGlpInsufficientGlp() external {\n        uint256 etherAmount = 1 ether;\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlp = _calculateMinGlpAmount(\n            address(0),\n            etherAmount,\n            18\n        ) * 2;\n        address receiver = address(this);\n\n        vm.deal(address(this), etherAmount);\n        vm.expectRevert(INSUFFICIENT_GLP_OUTPUT_ERROR);\n\n        pirexGmx.depositGlpETH{value: etherAmount}(\n            minUsdg,\n            invalidMinGlp,\n            receiver\n        );\n    }\n\n    // /**\n    //     @notice Test tx success: testDepositGlp fuzz test covers both methods\n    //  */\n    // function testDepositGlpETH() external {}\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGlp TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotDepositGlpPaused() external {\n        _pauseContract();\n\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.depositGlp(token, tokenAmount, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: token is zero address\n     */\n    function testCannotDepositGlpTokenZeroAddress() external {\n        address invalidToken = address(0);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.depositGlp(\n            invalidToken,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: token is not whitelisted by GMX\n     */\n    function testCannotDepositGlpInvalidToken() external {\n        address invalidToken = address(this);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(PirexGmx.InvalidToken.selector, invalidToken)\n        );\n\n        pirexGmx.depositGlp(\n            invalidToken,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: token amount is zero\n     */\n    function testCannotDepositGlpTokenAmountZeroAmount() external {\n        address token = address(weth);\n        uint256 invalidTokenAmount = 0;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGlp(\n            token,\n            invalidTokenAmount,\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minUsdg is zero\n     */\n    function testCannotDepositGlpMinUsdgZeroAmount() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 invalidMinUsdg = 0;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGlp(\n            token,\n            tokenAmount,\n            invalidMinUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is zero\n     */\n    function testCannotDepositGlpMinGlpZeroAmount() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlp = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            invalidMinGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotDepositGlpReceiverZeroAddress() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            invalidReceiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is greater than output\n     */\n    function testCannotDepositGlpMinGlpInsufficientGlpOutput() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1e8;\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlp = _calculateMinGlpAmount(token, tokenAmount, 8) *\n            2;\n        address receiver = address(this);\n\n        _mintWrappedToken(tokenAmount, address(this));\n        weth.approve(address(pirexGmx), tokenAmount);\n\n        vm.expectRevert(INSUFFICIENT_GLP_OUTPUT_ERROR);\n\n        pirexGmx.depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            invalidMinGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx success: deposit for pxGLP\n        @param  depositFee      uint24  Deposit fee\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  separateCaller  bool    Whether to separate method caller and receiver\n        @param  useETH          bool     Whether or not to use ETH as the source asset for minting GLP\n     */\n    function testDepositGlp(\n        uint24 depositFee,\n        uint8 multiplier,\n        bool separateCaller,\n        bool useETH\n    ) external {\n        vm.assume(depositFee <= feeMax);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        _setFee(PirexGmx.Fees.Deposit, depositFee);\n\n        uint256 expectedPreDepositGlpBalancePirexGmx = 0;\n        uint256 expectedPreDepositPxGlpSupply = 0;\n\n        assertEq(\n            expectedPreDepositGlpBalancePirexGmx,\n            feeStakedGlp.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPreDepositPxGlpSupply, pxGlp.totalSupply());\n\n        // Deposits GLP, verifies event emission, and validates depositGmx return values\n        uint256[] memory depositAmounts = _depositGlpForTestAccounts(\n            separateCaller,\n            address(this),\n            multiplier,\n            useETH\n        );\n\n        // Assign the initial post-deposit values to their pre-deposit counterparts\n        uint256 expectedPostDepositGlpBalancePirexGmx = expectedPreDepositGlpBalancePirexGmx;\n        uint256 expectedPostDepositPxGlpSupply = expectedPreDepositPxGlpSupply;\n        uint256 tLen = testAccounts.length;\n\n        for (uint256 i; i < tLen; ++i) {\n            uint256 depositAmount = depositAmounts[i];\n\n            expectedPostDepositGlpBalancePirexGmx += depositAmount;\n            expectedPostDepositPxGlpSupply += depositAmount;\n\n            (uint256 postFeeAmount, ) = _computeAssetAmounts(\n                PirexGmx.Fees.Deposit,\n                depositAmount\n            );\n\n            // Check test account balances against post-fee pxGMX mint amount\n            assertEq(postFeeAmount, pxGlp.balanceOf(testAccounts[i]));\n        }\n\n        assertEq(\n            expectedPostDepositGlpBalancePirexGmx,\n            feeStakedGlp.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPostDepositPxGlpSupply, pxGlp.totalSupply());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        redeemPxGlpETH TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotRedeemPxGlpETHPaused() external {\n        (uint256 postFeeAmount, uint256 feeAmount) = _depositGlpETH(\n            1 ether,\n            address(this)\n        );\n        uint256 assets = postFeeAmount + feeAmount;\n        uint256 minOut = _calculateMinOutAmount(address(weth), assets);\n        address receiver = testAccounts[0];\n\n        // Pause after deposit\n        _pauseContract();\n\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.redeemPxGlpETH(assets, minOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: assets is zero\n     */\n    function testCannotRedeemPxGlpETHAssetsZeroAmount() external {\n        uint256 invalidAssets = 0;\n        uint256 minOut = 1;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.redeemPxGlpETH(invalidAssets, minOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: minOut is zero\n     */\n    function testCannotRedeemPxGlpETHMinOutZeroAmount() external {\n        uint256 assets = 1;\n        uint256 invalidMinOut = 0;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.redeemPxGlpETH(assets, invalidMinOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotRedeemPxGlpETHReceiverZeroAddress() external {\n        uint256 assets = 1;\n        uint256 minOut = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.redeemPxGlpETH(assets, minOut, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx reversion: minOut is greater than output\n     */\n    function testCannotRedeemPxGlpETHMinOutInsufficientOutput() external {\n        (uint256 postFeeAmount, uint256 feeAmount) = _depositGlpETH(\n            1 ether,\n            address(this)\n        );\n        uint256 assets = postFeeAmount + feeAmount;\n        uint256 invalidMinOut = _calculateMinOutAmount(address(weth), assets) *\n            2;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(INSUFFICIENT_OUTPUT_ERROR);\n\n        pirexGmx.redeemPxGlpETH(assets, invalidMinOut, receiver);\n    }\n\n    // /**\n    //     @notice Test tx success: testRedeemPxGlp fuzz test covers both methods\n    //  */\n    // function testRedeemPxGlpETH() external {}\n\n    /*//////////////////////////////////////////////////////////////\n                        redeemPxGlp TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotRedeemPxGlpPaused() external {\n        uint256 etherAmount = 1 ether;\n        address token = address(weth);\n        (uint256 postFeeAmount, uint256 feeAmount) = _depositGlpETH(\n            etherAmount,\n            address(this)\n        );\n        uint256 assets = postFeeAmount + feeAmount;\n        uint256 minOut = _calculateMinOutAmount(token, assets);\n        address receiver = testAccounts[0];\n\n        // Pause after deposit\n        _pauseContract();\n\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.redeemPxGlp(token, assets, minOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: token is zero address\n     */\n    function testCannotRedeemPxGlpTokenZeroAddress() external {\n        address invalidToken = address(0);\n        uint256 assets = 1;\n        uint256 minOut = 1;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.redeemPxGlp(invalidToken, assets, minOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: token is not whitelisted by GMX\n     */\n    function testCannotRedeemPxGlpInvalidToken() external {\n        address invalidToken = address(this);\n        uint256 assets = 1;\n        uint256 minOut = 1;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(\n            abi.encodeWithSelector(PirexGmx.InvalidToken.selector, invalidToken)\n        );\n\n        pirexGmx.redeemPxGlp(invalidToken, assets, minOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: assets is zero\n     */\n    function testCannotRedeemPxGlpAssetsZeroAmount() external {\n        address token = address(weth);\n        uint256 invalidAssets = 0;\n        uint256 minOut = 1;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.redeemPxGlp(token, invalidAssets, minOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: minOut is zero\n     */\n    function testCannotRedeemPxGlpMinOutZeroAmount() external {\n        address token = address(weth);\n        uint256 assets = 1;\n        uint256 invalidMinOut = 0;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.redeemPxGlp(token, assets, invalidMinOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotRedeemPxGlpReceiverZeroAddress() external {\n        address token = address(weth);\n        uint256 assets = 1;\n        uint256 minOut = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.redeemPxGlp(token, assets, minOut, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx reversion: minOut is greater than output amount\n     */\n    function testCannotRedeemPxGlpMinOutInsufficientOutput() external {\n        address token = address(weth);\n        (uint256 deposited, , ) = _depositGlp(1e8, address(this));\n        uint256 invalidMinOut = _calculateMinOutAmount(token, deposited) * 2;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(INSUFFICIENT_OUTPUT_ERROR);\n\n        pirexGmx.redeemPxGlp(token, deposited, invalidMinOut, receiver);\n    }\n\n    /**\n        @notice Test tx success: redeem pxGLP\n        @param  redemptionFee   uint24  Redemption fee\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  useETH          bool    Whether or not to use ETH as the source asset for minting GLP\n     */\n    function testRedeemPxGlp(\n        uint24 redemptionFee,\n        uint8 multiplier,\n        bool useETH\n    ) external {\n        vm.assume(redemptionFee <= feeMax);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        _setFee(PirexGmx.Fees.Redemption, redemptionFee);\n\n        uint256[] memory depositAmounts = _depositGlpForTestAccounts(\n            false,\n            address(this),\n            multiplier,\n            useETH\n        );\n\n        vm.warp(block.timestamp + 1 days);\n\n        uint256 tLen = testAccounts.length;\n        uint256 totalDeposits;\n\n        for (uint256 i; i < tLen; ++i) {\n            totalDeposits += depositAmounts[i];\n        }\n\n        uint256 expectedPreRedeemGlpBalancePirexGmx = totalDeposits;\n        uint256 expectedPreRedeemPxGlpSupply = totalDeposits;\n\n        assertEq(\n            expectedPreRedeemGlpBalancePirexGmx,\n            feeStakedGlp.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPreRedeemGlpBalancePirexGmx, pxGlp.totalSupply());\n\n        uint256 expectedPostRedeemGlpBalancePirexGmx = expectedPreRedeemGlpBalancePirexGmx;\n        uint256 expectedPostRedeemPxGlpSupply = expectedPreRedeemPxGlpSupply;\n\n        for (uint256 i; i < tLen; ++i) {\n            address testAccount = testAccounts[i];\n            uint256 depositAmount = depositAmounts[i];\n            (uint256 postFeeAmount, ) = _computeAssetAmounts(\n                PirexGmx.Fees.Redemption,\n                depositAmount\n            );\n            address token = address(weth);\n\n            vm.startPrank(testAccount);\n\n            pxGlp.approve(address(pirexGmx), depositAmount);\n\n            vm.expectEmit(true, true, true, false, address(pirexGmx));\n\n            emit RedeemGlp(\n                testAccount,\n                testAccount,\n                useETH ? address(0) : token,\n                0,\n                _calculateMinOutAmount(token, postFeeAmount),\n                0,\n                0,\n                0\n            );\n\n            (, uint256 returnedPostFeeAmount, ) = useETH\n                ? pirexGmx.redeemPxGlpETH(\n                    depositAmount,\n                    _calculateMinOutAmount(token, postFeeAmount),\n                    testAccount\n                )\n                : pirexGmx.redeemPxGlp(\n                    token,\n                    depositAmount,\n                    _calculateMinOutAmount(token, postFeeAmount),\n                    testAccount\n                );\n\n            vm.stopPrank();\n\n            expectedPostRedeemGlpBalancePirexGmx -= returnedPostFeeAmount;\n            expectedPostRedeemPxGlpSupply -= returnedPostFeeAmount;\n        }\n\n        assertEq(\n            expectedPostRedeemGlpBalancePirexGmx,\n            feeStakedGlp.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPostRedeemPxGlpSupply, pxGlp.totalSupply());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        claimRewards TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is not pirexRewards\n     */\n    function testCannotClaimRewardsNotPirexRewards() external {\n        assertTrue(address(this) != pirexGmx.pirexRewards());\n\n        vm.expectRevert(PirexGmx.NotPirexRewards.selector);\n\n        pirexGmx.claimRewards();\n    }\n\n    /**\n        @notice Test tx success: claim WETH, esGMX, and bnGMX/MP rewards\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n        @param  tokenAmount     uint72  Amount of wrapped token used for minting GLP\n        @param  gmxAmount       uint80  Amount of GMX to mint and deposit\n     */\n    function testClaimRewards(\n        uint32 secondsElapsed,\n        uint72 tokenAmount,\n        uint80 gmxAmount\n    ) external {\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n        vm.assume(tokenAmount > 0.001 ether);\n        vm.assume(tokenAmount < 1000 ether);\n        vm.assume(gmxAmount > 1e15);\n        vm.assume(gmxAmount < 1000000e18);\n\n        _depositGlp(tokenAmount, address(this));\n        _depositGmx(gmxAmount, address(this));\n\n        vm.warp(block.timestamp + secondsElapsed);\n\n        // Commented out due to \"Stack too deep...\" error\n        // uint256 expectedWethBalanceBeforeClaim = 0;\n        // uint256 expectedEsGmxBalanceBeforeClaim = 0;\n\n        assertEq(0, weth.balanceOf(address(pirexGmx)));\n        assertEq(0, stakedGmx.depositBalances(address(pirexGmx), esGmx));\n\n        uint256 previousStakedGmxBalance = rewardTrackerGmx.balanceOf(\n            address(pirexGmx)\n        );\n        uint256 expectedWETHRewardsGmx = _calculateRewards(\n            address(pirexGmx),\n            true,\n            true\n        );\n        uint256 expectedWETHRewardsGlp = _calculateRewards(\n            address(pirexGmx),\n            true,\n            false\n        );\n        uint256 expectedEsGmxRewardsGmx = _calculateRewards(\n            address(pirexGmx),\n            false,\n            true\n        );\n        uint256 expectedEsGmxRewardsGlp = _calculateRewards(\n            address(pirexGmx),\n            false,\n            false\n        );\n        uint256 expectedBnGmxRewards = calculateBnGmxRewards(address(pirexGmx));\n        uint256 expectedWETHRewards = expectedWETHRewardsGmx +\n            expectedWETHRewardsGlp;\n        uint256 expectedEsGmxRewards = expectedEsGmxRewardsGmx +\n            expectedEsGmxRewardsGlp;\n\n        vm.expectEmit(false, false, false, true, address(pirexGmx));\n\n        // Limited variable counts due to stack-too-deep issue\n        emit ClaimRewards(\n            expectedWETHRewards,\n            expectedEsGmxRewards,\n            expectedWETHRewardsGmx,\n            expectedWETHRewardsGlp,\n            expectedEsGmxRewardsGmx,\n            expectedEsGmxRewardsGlp\n        );\n\n        // Impersonate pirexRewards and claim WETH rewards\n        vm.prank(address(pirexRewards));\n\n        (\n            ERC20[] memory producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        ) = pirexGmx.claimRewards();\n\n        assertEq(address(pxGmx), address(producerTokens[0]));\n        assertEq(address(pxGlp), address(producerTokens[1]));\n        assertEq(address(pxGmx), address(producerTokens[2]));\n        assertEq(address(pxGlp), address(producerTokens[3]));\n        assertEq(address(weth), address(rewardTokens[0]));\n        assertEq(address(weth), address(rewardTokens[1]));\n        assertEq(address(pxGmx), address(rewardTokens[2]));\n        assertEq(address(pxGmx), address(rewardTokens[3]));\n        assertEq(expectedWETHRewardsGmx, rewardAmounts[0]);\n        assertEq(expectedWETHRewardsGlp, rewardAmounts[1]);\n        assertEq(expectedEsGmxRewardsGmx, rewardAmounts[2]);\n        assertEq(expectedEsGmxRewardsGlp, rewardAmounts[3]);\n\n        // Commented out due to \"Stack too deep...\" error\n        // uint256 expectedWethBalanceAfterClaim = expectedWETHRewards;\n        // uint256 expectedEsGmxBalanceAfterClaim = expectedEsGmxRewards;\n\n        assertEq(expectedWETHRewards, weth.balanceOf(address(pirexGmx)));\n        assertEq(\n            expectedEsGmxRewards,\n            stakedGmx.depositBalances(address(pirexGmx), esGmx)\n        );\n\n        // Claimable reward amounts should all be zero post-claim\n        assertEq(0, _calculateRewards(address(pirexGmx), true, true));\n        assertEq(0, _calculateRewards(address(pirexGmx), true, false));\n        assertEq(0, _calculateRewards(address(pirexGmx), false, true));\n        assertEq(0, _calculateRewards(address(pirexGmx), false, false));\n        assertEq(0, calculateBnGmxRewards(address(pirexGmx)));\n\n        // Claimed esGMX rewards + MP should also be staked immediately\n        assertEq(\n            previousStakedGmxBalance +\n                expectedEsGmxRewards +\n                expectedBnGmxRewards,\n            rewardTrackerGmx.balanceOf(address(pirexGmx))\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        claimUserReward TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is not pirexRewards\n     */\n    function testCannotClaimUserRewardNotPirexRewards() external {\n        address token = address(weth);\n        uint256 amount = 1;\n        address receiver = address(this);\n\n        assertTrue(address(this) != pirexGmx.pirexRewards());\n\n        vm.expectRevert(PirexGmx.NotPirexRewards.selector);\n\n        pirexGmx.claimUserReward(token, amount, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: token is zero address\n     */\n    function testCannotClaimUserRewardTokenZeroAddress() external {\n        address invalidToken = address(0);\n        uint256 amount = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n        vm.prank(address(pirexRewards));\n\n        pirexGmx.claimUserReward(invalidToken, amount, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: amount is zero\n     */\n    function testCannotClaimUserRewardAmountZeroAmount() external {\n        address token = address(weth);\n        uint256 invalidAmount = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n        vm.prank(address(pirexRewards));\n\n        pirexGmx.claimUserReward(token, invalidAmount, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotClaimUserRewardRecipientZeroAddress() external {\n        address token = address(weth);\n        uint256 amount = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n        vm.prank(address(pirexRewards));\n\n        pirexGmx.claimUserReward(token, amount, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx success: claim user reward\n        @param  wethAmount   uint72  Amount of claimable WETH\n        @param  pxGmxAmount  uint80  Amount of claimable pxGMX\n     */\n    function testClaimUserReward(uint72 wethAmount, uint80 pxGmxAmount)\n        external\n    {\n        vm.assume(wethAmount > 0.001 ether);\n        vm.assume(wethAmount < 1000 ether);\n        vm.assume(pxGmxAmount != 0);\n        vm.assume(pxGmxAmount < 1000000e18);\n\n        address tokenWeth = address(weth);\n        address tokenPxGmx = address(pxGmx);\n        address receiver = address(this);\n\n        assertEq(0, weth.balanceOf(receiver));\n        assertEq(0, pxGmx.balanceOf(receiver));\n\n        // Mint and transfers tokens for user claim tests\n        vm.deal(address(this), wethAmount);\n\n        _mintWrappedToken(wethAmount, address(pirexGmx));\n\n        vm.prank(address(pirexGmx));\n\n        pxGmx.mint(address(pirexGmx), pxGmxAmount);\n\n        // Test claim via PirexRewards contract\n        vm.startPrank(address(pirexRewards));\n\n        pirexGmx.claimUserReward(tokenWeth, wethAmount, receiver);\n        pirexGmx.claimUserReward(tokenPxGmx, pxGmxAmount, receiver);\n\n        vm.stopPrank();\n\n        assertEq(weth.balanceOf(receiver), wethAmount);\n        assertEq(pxGmx.balanceOf(receiver), pxGmxAmount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setDelegationSpace TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetDelegationSpaceUnauthorized() external {\n        string memory space = \"test.eth\";\n        bool clear = false;\n        address unauthorizedCaller = _getUnauthorizedCaller();\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.setDelegationSpace(space, clear);\n    }\n\n    /**\n        @notice Test tx reversion: space is empty string\n     */\n    function testCannotSetDelegationSpaceEmptyString() external {\n        string memory invalidSpace = \"\";\n        bool clear = false;\n\n        vm.expectRevert(PirexGmx.EmptyString.selector);\n\n        pirexGmx.setDelegationSpace(invalidSpace, clear);\n    }\n\n    /**\n        @notice Test tx success: set delegation space\n        @param  clear  bool  Whether to clear the vote delegate\n     */\n    function testSetDelegationSpace(bool clear) external {\n        DelegateRegistry d = DelegateRegistry(pirexGmx.delegateRegistry());\n        address voteDelegate = address(this);\n\n        // Set the vote delegate before clearing it when setting new delegation space\n        pirexGmx.setVoteDelegate(voteDelegate);\n\n        assertEq(delegationSpace, pirexGmx.delegationSpace());\n        assertEq(\n            voteDelegate,\n            d.delegation(address(pirexGmx), delegationSpace)\n        );\n\n        string memory space = \"new.eth\";\n        bytes32 expectedDelegationSpace = bytes32(bytes(space));\n        address expectedVoteDelegate = clear ? address(0) : voteDelegate;\n\n        assertFalse(expectedDelegationSpace == delegationSpace);\n\n        vm.expectEmit(false, false, false, true, address(pirexGmx));\n\n        emit SetDelegationSpace(space, clear);\n\n        pirexGmx.setDelegationSpace(space, clear);\n\n        assertEq(expectedDelegationSpace, pirexGmx.delegationSpace());\n        assertEq(\n            expectedVoteDelegate,\n            d.delegation(address(pirexGmx), delegationSpace)\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setVoteDelegate TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetVoteDelegateUnauthorized() external {\n        address unauthorizedCaller = _getUnauthorizedCaller();\n        address delegate = address(this);\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.setVoteDelegate(delegate);\n    }\n\n    /**\n        @notice Test tx reversion: delegate is zero address\n     */\n    function testCannotSetVoteDelegateDelegateZeroAddress() external {\n        address invalidDelegate = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.setVoteDelegate(invalidDelegate);\n    }\n\n    /**\n        @notice Test tx success: set vote delegate\n     */\n    function testSetVoteDelegate() external {\n        address oldDelegate = delegateRegistry.delegation(\n            address(pirexGmx),\n            pirexGmx.delegationSpace()\n        );\n        address newDelegate = address(this);\n\n        assertTrue(oldDelegate != newDelegate);\n\n        vm.expectEmit(false, false, false, true, address(pirexGmx));\n\n        emit SetVoteDelegate(newDelegate);\n\n        pirexGmx.setVoteDelegate(newDelegate);\n\n        address delegate = delegateRegistry.delegation(\n            address(pirexGmx),\n            pirexGmx.delegationSpace()\n        );\n\n        assertEq(delegate, newDelegate);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        clearVoteDelegate TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotClearVoteDelegateUnauthorized() external {\n        address unauthorizedCaller = _getUnauthorizedCaller();\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.clearVoteDelegate();\n    }\n\n    /**\n        @notice Test tx reversion: clear with no delegate set\n     */\n    function testCannotClearVoteDelegateNoDelegate() external {\n        assertEq(\n            address(0),\n            delegateRegistry.delegation(\n                address(pirexGmx),\n                pirexGmx.delegationSpace()\n            )\n        );\n\n        vm.expectRevert(\"No delegate set\");\n\n        pirexGmx.clearVoteDelegate();\n    }\n\n    /**\n        @notice Test tx success: clear vote delegate\n     */\n    function testClearVoteDelegate() external {\n        pirexGmx.setDelegationSpace(\"test.eth\", false);\n\n        address voteDelegate = address(this);\n\n        // Set the vote delegate before clearing it when setting new delegation space\n        pirexGmx.setVoteDelegate(voteDelegate);\n\n        assertEq(\n            voteDelegate,\n            delegateRegistry.delegation(\n                address(pirexGmx),\n                pirexGmx.delegationSpace()\n            )\n        );\n\n        vm.expectEmit(false, false, false, true, address(pirexGmx));\n\n        emit ClearVoteDelegate();\n\n        pirexGmx.clearVoteDelegate();\n\n        assertEq(\n            address(0),\n            delegateRegistry.delegation(\n                address(pirexGmx),\n                pirexGmx.delegationSpace()\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPauseState TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPauseStateUnauthorized() external {\n        address unauthorizedCaller = _getUnauthorizedCaller();\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.setPauseState(true);\n    }\n\n    /**\n        @notice Test tx reversion: contract is not paused\n     */\n    function testCannotSetPauseStateNotPaused() external {\n        assertEq(false, pirexGmx.paused());\n\n        vm.expectRevert(NOT_PAUSED_ERROR);\n\n        pirexGmx.setPauseState(false);\n    }\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotSetPauseStatePaused() external {\n        _pauseContract();\n\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.setPauseState(true);\n    }\n\n    /**\n        @notice Test tx success: set pause state\n     */\n    function testSetPauseState() external {\n        assertEq(false, pirexGmx.paused());\n\n        _pauseContract();\n\n        pirexGmx.setPauseState(false);\n\n        assertEq(false, pirexGmx.paused());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        initiateMigration TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is not paused\n     */\n    function testCannotInitiateMigrationNotPaused() external {\n        assertEq(false, pirexGmx.paused());\n\n        address newContract = address(this);\n\n        vm.expectRevert(NOT_PAUSED_ERROR);\n\n        pirexGmx.initiateMigration(newContract);\n    }\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotInitiateMigrationUnauthorized() external {\n        _pauseContract();\n\n        address unauthorizedCaller = _getUnauthorizedCaller();\n        address newContract = address(this);\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.initiateMigration(newContract);\n    }\n\n    /**\n        @notice Test tx reversion: newContract is zero address\n     */\n    function testCannotInitiateMigrationNewContractZeroAddress() external {\n        _pauseContract();\n\n        address invalidNewContract = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.initiateMigration(invalidNewContract);\n    }\n\n    /**\n        @notice Test tx success: initiate migration\n     */\n    function testInitiateMigration() external {\n        _pauseContract();\n\n        address oldContract = address(pirexGmx);\n        address newContract = address(this);\n        address expectedPendingReceiverBeforeInitation = address(0);\n\n        assertEq(\n            expectedPendingReceiverBeforeInitation,\n            REWARD_ROUTER_V2.pendingReceivers(oldContract)\n        );\n\n        vm.expectEmit(false, false, false, true, address(pirexGmx));\n\n        emit InitiateMigration(newContract);\n\n        pirexGmx.initiateMigration(newContract);\n\n        address expectedPendingReceiverAfterInitation = newContract;\n\n        // Should properly set the pendingReceivers state\n        assertEq(\n            expectedPendingReceiverAfterInitation,\n            REWARD_ROUTER_V2.pendingReceivers(oldContract)\n        );\n\n        // Should also set the migratedTo state variable\n        assertEq(expectedPendingReceiverAfterInitation, pirexGmx.migratedTo());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        migrateReward TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is not paused\n     */\n    function testCannotMigrateRewardNotPaused() external {\n        assertEq(false, pirexGmx.paused());\n\n        vm.expectRevert(NOT_PAUSED_ERROR);\n\n        pirexGmx.migrateReward();\n    }\n\n    /**\n        @notice Test tx reversion: caller is not the migration target\n     */\n    function testCannotMigrateRewardNotMigratedTo() external {\n        _pauseContract();\n\n        vm.expectRevert(PirexGmx.NotMigratedTo.selector);\n\n        pirexGmx.migrateReward();\n    }\n\n    /**\n        @notice Test tx reversion: pending migration exists\n     */\n    function testCannotMigrateRewardPendingMigration() external {\n        _pauseContract();\n\n        uint96 rewardAmount = 1 ether;\n        address oldContract = address(pirexGmx);\n        address newContract = address(this);\n\n        // Test with WETH as the base reward token\n        _mintWrappedToken(rewardAmount, oldContract);\n\n        pirexGmx.initiateMigration(newContract);\n\n        vm.expectRevert(PirexGmx.PendingMigration.selector);\n\n        vm.prank(newContract);\n\n        // Should revert since the method should only be done after full migration\n        pirexGmx.migrateReward();\n    }\n\n    /**\n        @notice Test tx success: migrate base reward\n        @param  rewardAmount  uint96  Reward amount\n     */\n    function testMigrateReward(uint96 rewardAmount) external {\n        vm.assume(rewardAmount != 0);\n        vm.assume(rewardAmount < 1000 ether);\n\n        _pauseContract();\n\n        address oldContract = address(pirexGmx);\n        address newContract = address(this);\n\n        // Test with WETH as the base reward token\n        _mintWrappedToken(rewardAmount, oldContract);\n\n        pirexGmx.initiateMigration(newContract);\n\n        // Simulate full migration without triggering migrateReward\n        // so we can test it separately\n        vm.startPrank(newContract);\n\n        pirexRewards.harvest();\n\n        REWARD_ROUTER_V2.acceptTransfer(oldContract);\n\n        pirexGmx.migrateReward();\n\n        vm.stopPrank();\n\n        // Confirm the base reward balances for both contracts\n        assertEq(0, weth.balanceOf(oldContract));\n        assertEq(rewardAmount, weth.balanceOf(newContract));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        completeMigration TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is not paused\n     */\n    function testCannotCompleteMigrationNotPaused() external {\n        assertEq(false, pirexGmx.paused());\n\n        address oldContract = address(this);\n\n        vm.expectRevert(NOT_PAUSED_ERROR);\n\n        pirexGmx.completeMigration(oldContract);\n    }\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotCompleteMigrationUnauthorized() external {\n        _pauseContract();\n\n        address unauthorizedCaller = _getUnauthorizedCaller();\n        address oldContract = address(pirexGmx);\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.completeMigration(oldContract);\n    }\n\n    /**\n        @notice Test tx reversion: oldContract is zero address\n     */\n    function testCannotCompleteMigrationZeroAddress() external {\n        _pauseContract();\n\n        address invalidOldContract = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.completeMigration(invalidOldContract);\n    }\n\n    /**\n        @notice Test tx reversion due to the caller not being the assigned new contract\n     */\n    function testCannotCompleteMigrationInvalidNewContract() external {\n        _pauseContract();\n\n        address oldContract = address(pirexGmx);\n        address newContract = address(this);\n\n        pirexGmx.initiateMigration(newContract);\n\n        assertEq(newContract, REWARD_ROUTER_V2.pendingReceivers(oldContract));\n\n        // Deploy a test contract but not assign it as the migration target\n        PirexGmx newPirexGmx = new PirexGmx(\n            address(pxGmx),\n            address(pxGlp),\n            address(pirexFees),\n            address(pirexRewards),\n            address(delegateRegistry),\n            REWARD_ROUTER_V2.weth(),\n            REWARD_ROUTER_V2.gmx(),\n            REWARD_ROUTER_V2.esGmx(),\n            address(REWARD_ROUTER_V2),\n            address(STAKED_GLP)\n        );\n\n        vm.expectRevert(\"RewardRouter: transfer not signalled\");\n\n        newPirexGmx.completeMigration(oldContract);\n    }\n\n    /**\n        @notice Test tx success: completing migration\n     */\n    function testCompleteMigration() external {\n        // Perform GMX deposit for balance tests after migration\n        uint256 assets = 1e18;\n        address receiver = address(this);\n        address oldContract = address(pirexGmx);\n\n        _mintApproveGmx(assets, address(this), oldContract, assets);\n        pirexGmx.depositGmx(assets, receiver);\n\n        // Perform GLP deposit for balance tests after migration\n        uint256 etherAmount = 1 ether;\n\n        vm.deal(address(this), etherAmount);\n\n        pirexGmx.depositGlpETH{value: etherAmount}(1, 1, receiver);\n\n        // Time skip to bypass the cooldown duration\n        vm.warp(block.timestamp + 1 days);\n\n        // Store the staked balances and rewards for later validations\n        uint256 oldStakedGmxBalance = rewardTrackerGmx.balanceOf(oldContract);\n        uint256 oldStakedGlpBalance = feeStakedGlp.balanceOf(oldContract);\n        uint256 oldEsGmxClaimable = _calculateRewards(\n            oldContract,\n            false,\n            true\n        ) + _calculateRewards(oldContract, false, false);\n        uint256 oldMpBalance = rewardTrackerMp.claimable(oldContract);\n        uint256 oldBaseRewardClaimable = _calculateRewards(\n            oldContract,\n            true,\n            true\n        ) + _calculateRewards(oldContract, true, false);\n\n        // Pause the contract before proceeding\n        _pauseContract();\n\n        // Deploy the new contract for migration tests\n        PirexGmx newPirexGmx = new PirexGmx(\n            address(pxGmx),\n            address(pxGlp),\n            address(pirexFees),\n            address(pirexRewards),\n            address(delegateRegistry),\n            REWARD_ROUTER_V2.weth(),\n            REWARD_ROUTER_V2.gmx(),\n            REWARD_ROUTER_V2.esGmx(),\n            address(REWARD_ROUTER_V2),\n            address(STAKED_GLP)\n        );\n\n        address newContract = address(newPirexGmx);\n\n        assertEq(REWARD_ROUTER_V2.pendingReceivers(oldContract), address(0));\n\n        pirexGmx.initiateMigration(newContract);\n\n        // Should properly set the pendingReceivers state\n        assertEq(REWARD_ROUTER_V2.pendingReceivers(oldContract), newContract);\n\n        vm.expectEmit(false, false, false, true, address(newPirexGmx));\n\n        emit CompleteMigration(oldContract);\n\n        // Complete the migration using the new contract\n        newPirexGmx.completeMigration(oldContract);\n\n        // Should properly clear the pendingReceivers state\n        assertEq(REWARD_ROUTER_V2.pendingReceivers(oldContract), address(0));\n\n        // Confirm that the token balances and claimables for old contract are correct\n        assertEq(0, rewardTrackerGmx.balanceOf(oldContract));\n        assertEq(0, feeStakedGlp.balanceOf(oldContract));\n        assertEq(0, stakedGmx.claimable(oldContract));\n        assertEq(0, feeStakedGlp.claimable(oldContract));\n        assertEq(0, rewardTrackerMp.claimable(oldContract));\n\n        // Confirm that the staked token balances for new contract are correct\n        // For Staked GMX balance, due to compounding in the migration,\n        // all pending claimable esGMX and MP are automatically staked\n        assertEq(\n            oldStakedGmxBalance + oldEsGmxClaimable + oldMpBalance,\n            rewardTrackerGmx.balanceOf(newContract)\n        );\n        assertEq(oldStakedGlpBalance, feeStakedGlp.balanceOf(newContract));\n\n        // Confirm that the remaining base reward has also been migrated\n        assertEq(0, pirexGmx.gmxBaseReward().balanceOf(oldContract));\n        assertEq(\n            oldBaseRewardClaimable,\n            pirexGmx.gmxBaseReward().balanceOf(newContract)\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {PxGmxReward} from \"src/vaults/PxGmxReward.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\n\ncontract AutoPxGlp is PirexERC4626, PxGmxReward, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n    uint256 public constant EXPANDED_DECIMALS = 1e30;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    // GMX protocol base reward (e.g. WETH)\n    ERC20 public immutable gmxBaseReward;\n\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint256 minGlp,\n        uint256 gmxBaseRewardAmount,\n        uint256 pxGmxAmountOut,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 totalPxGmxFee,\n        uint256 pxGlpIncentive,\n        uint256 pxGmxIncentive\n    );\n\n    error ZeroAmount();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _asset          address  Asset address (vault asset, e.g. pxGLP)\n        @param  _pxGmx          address  pxGMX address (as secondary reward)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGLP)\n        @param  _symbol         string   Asset symbol (e.g. apxGLP)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _asset,\n        address _pxGmx,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) PxGmxReward(_pxGmx) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(_platform), type(uint256).max);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGLP custodied by the AutoPxGlp contract\n        @return uint256  Amount of pxGLP custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares   uint256  Shares amount\n        @return          uint256  Assets amount\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets   uint256  Assets amount\n        @return          uint256  Shares amount\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGLP (and additionally pxGMX) rewards\n        @param  minUsdg                uint256  Minimum USDG amount used when minting GLP\n        @param  minGlp                 uint256  Minimum GLP amount received from the WETH deposit\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  WETH inbound amount\n        @return pxGmxAmountOut         uint256  pxGMX outbound amount\n        @return pxGlpAmountOut         uint256  pxGLP outbound amount\n        @return totalPxGlpFee          uint256  Total platform fee for pxGLP\n        @return totalPxGmxFee          uint256  Total platform fee for pxGMX\n        @return pxGlpIncentive         uint256  Compound incentive for pxGLP\n        @return pxGmxIncentive         uint256  Compound incentive for pxGMX\n     */\n    function compound(\n        uint256 minUsdg,\n        uint256 minGlp,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        )\n    {\n        if (minUsdg == 0) revert InvalidParam();\n        if (minGlp == 0) revert InvalidParam();\n\n        uint256 preClaimTotalAssets = asset.balanceOf(address(this));\n        uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n        PirexRewards(rewardsModule).claim(pxGmx, address(this));\n\n        // Track the amount of rewards received\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            // Deposit received rewards for pxGLP\n            (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(\n                address(gmxBaseReward),\n                gmxBaseRewardAmountIn,\n                minUsdg,\n                minGlp,\n                address(this)\n            );\n        }\n\n        // Distribute fees if the amount of vault assets increased\n        uint256 newAssets = totalAssets() - preClaimTotalAssets;\n        if (newAssets != 0) {\n            totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;\n            pxGlpIncentive = optOutIncentive\n                ? 0\n                : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGlpIncentive != 0)\n                asset.safeTransfer(msg.sender, pxGlpIncentive);\n\n            asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);\n        }\n\n        // Track the amount of pxGMX received\n        pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;\n\n        if (pxGmxAmountOut != 0) {\n            // Calculate and distribute pxGMX fees if the amount of pxGMX increased\n            totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;\n            pxGmxIncentive = optOutIncentive\n                ? 0\n                : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGmxIncentive != 0)\n                pxGmx.safeTransfer(msg.sender, pxGmxIncentive);\n\n            pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);\n\n            // Update the pxGmx reward accrual\n            _harvest(pxGmxAmountOut - totalPxGmxFee);\n        } else {\n            // Required to keep the globalState up-to-date\n            _globalAccrue();\n        }\n\n        emit Compounded(\n            msg.sender,\n            minGlp,\n            gmxBaseRewardAmountIn,\n            pxGmxAmountOut,\n            pxGlpAmountOut,\n            totalPxGlpFee,\n            totalPxGmxFee,\n            pxGlpIncentive,\n            pxGmxIncentive\n        );\n    }\n\n    /**\n        @notice Internal deposit handler\n        @param  assets    uint256  pxGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return shares    uint256  Vault shares (i.e. apxGLP)\n     */\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    /**\n        @notice Deposit fsGLP for apxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        ERC20 stakedGlp = ERC20(address(PirexGmx(platform).stakedGlp()));\n\n        // Transfer fsGLP from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        stakedGlp.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve as needed here since the stakedGlp address is mutable in PirexGmx\n        stakedGlp.safeApprove(platform, amount);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositFsGlp(\n            amount,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for apxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  apxGLP receiver\n        @return              uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external nonReentrant returns (uint256) {\n        if (token == address(0)) revert ZeroAddress();\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // PirexGmx will do the check whether the token is whitelisted or not\n        ERC20 erc20Token = ERC20(token);\n\n        // Transfer token from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        erc20Token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Approve as needed here since it can be a new whitelisted token (unless it's the baseReward)\n        if (erc20Token != gmxBaseReward) {\n            erc20Token.safeApprove(platform, tokenAmount);\n        }\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for apxGLP\n        @param  minUsdg   uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp    uint256  Minimum GLP amount minted from ETH\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external payable nonReentrant returns (uint256) {\n        if (msg.value == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlpETH{\n            value: msg.value\n        }(minUsdg, minGlp, address(this));\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Override the withdrawal method to make sure compound is called before withdrawing\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        compound(1, 1, true);\n\n        shares = PirexERC4626.withdraw(assets, receiver, owner);\n    }\n\n    /**\n        @notice Override the redemption method to make sure compound is called before redeeming\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        compound(1, 1, true);\n\n        assets = PirexERC4626.redeem(shares, receiver, owner);\n    }\n\n    /**\n        @notice Compound and internally update pxGMX reward accrual before deposit\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(1, 1, true);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after deposit\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterDeposit(\n        address receiver,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(receiver);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after withdrawal\n        @param  owner  address  Owner of the vault shares\n     */\n    function afterWithdraw(\n        address owner,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(owner);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual for both sender and receiver after transfer\n        @param  owner     address  Owner of the vault shares\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256\n    ) internal override {\n        _userAccrue(owner);\n        _userAccrue(receiver);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {AutoPxGlp} from \"src/vaults/AutoPxGlp.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PxGmxReward} from \"src/vaults/PxGmxReward.sol\";\nimport {Helper} from \"./Helper.sol\";\n\ncontract AutoPxGlpTest is Helper {\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n    event Compounded(\n        address indexed caller,\n        uint256 minGlp,\n        uint256 wethAmount,\n        uint256 pxGmxAmountOut,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 totalPxGmxFee,\n        uint256 pxGlpIncentive,\n        uint256 pxGmxIncentive\n    );\n    event PxGmxClaimed(\n        address indexed account,\n        address receiver,\n        uint256 amount\n    );\n\n    /**\n        @notice Calculate the global rewards accrued since the last update\n        @return uint256  Global rewards\n    */\n    function _calculateGlobalRewards() internal view returns (uint256) {\n        (uint256 lastUpdate, uint256 lastSupply, uint256 rewards) = autoPxGlp\n            .globalState();\n\n        return rewards + (block.timestamp - lastUpdate) * lastSupply;\n    }\n\n    /**\n        @notice Calculate a user's rewards since the last update\n        @param  user  address  User\n        @return       uint256  User rewards\n    */\n    function _calculateUserRewards(address user)\n        internal\n        view\n        returns (uint256)\n    {\n        (uint256 lastUpdate, uint256 lastBalance, uint256 rewards) = autoPxGlp\n            .userRewardStates(user);\n\n        return rewards + lastBalance * (block.timestamp - lastUpdate);\n    }\n\n    /**\n        @notice Perform assertions for global state\n        @param  expectedLastUpdate  uint256  Expected last update timestamp\n        @param  expectedLastSupply  uint256  Expected last supply\n        @param  expectedRewards     uint256  Expected rewards\n    */\n    function _assertGlobalState(\n        uint256 expectedLastUpdate,\n        uint256 expectedLastSupply,\n        uint256 expectedRewards\n    ) internal {\n        (uint256 lastUpdate, uint256 lastSupply, uint256 rewards) = autoPxGlp\n            .globalState();\n\n        assertEq(expectedLastUpdate, lastUpdate);\n        assertEq(expectedLastSupply, lastSupply);\n        assertEq(expectedRewards, rewards);\n    }\n\n    /**\n        @notice Perform assertions for user reward state\n        @param  user                 address  User address\n        @param  expectedLastUpdate   uint256  Expected last update timestamp\n        @param  expectedLastBalance  uint256  Expected last user balance\n        @param  expectedRewards      uint256  Expected rewards\n    */\n    function _assertUserRewardState(\n        address user,\n        uint256 expectedLastUpdate,\n        uint256 expectedLastBalance,\n        uint256 expectedRewards\n    ) internal {\n        (uint256 lastUpdate, uint256 lastBalance, uint256 rewards) = autoPxGlp\n            .userRewardStates(user);\n\n        assertEq(expectedLastUpdate, lastUpdate);\n        assertEq(expectedLastBalance, lastBalance);\n        assertEq(expectedRewards, rewards);\n    }\n\n    /**\n        @notice Validate common parameters used for deposits in the tests\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function _validateTestArgs(uint8 multiplier, uint32 secondsElapsed)\n        internal\n    {\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n    }\n\n    /**\n        @notice Perform common setup for reward accrual and test accounts for vault tests\n        @param  multiplier  uint8  Multiplied with fixed token amounts for randomness\n     */\n    function _setupRewardsAndTestAccounts(uint8 multiplier) internal {\n        pirexRewards.addRewardToken(pxGmx, weth);\n        pirexRewards.addRewardToken(pxGmx, pxGmx);\n        pirexRewards.addRewardToken(pxGlp, weth);\n        pirexRewards.addRewardToken(pxGlp, pxGmx);\n\n        // Some tests require different deposit setup, only process those with non-zero multiplier\n        if (multiplier > 0) {\n            _depositGlpForTestAccounts(true, address(this), multiplier, true);\n        }\n    }\n\n    /**\n        @notice Perform deposit to the vault\n        @param  user  address  User address\n        @return       uint256  Amount of shares\n     */\n    function _depositToVault(address user) internal returns (uint256) {\n        vm.startPrank(user);\n\n        pxGlp.approve(address(autoPxGlp), pxGlp.balanceOf(user));\n\n        uint256 shares = autoPxGlp.deposit(pxGlp.balanceOf(user), user);\n\n        vm.stopPrank();\n\n        return shares;\n    }\n\n    /**\n        @notice Calculate amount of accrued rewards by the vault\n        @param  rewardState  uint256  Reward state\n        @param  vaultState   uint256  Vault state\n        @param  globalState  uint256  Global state\n        @return              uint256  Amount of rewards\n     */\n    function _calculateVaultReward(\n        uint256 rewardState,\n        uint256 vaultState,\n        uint256 globalState\n    ) internal pure returns (uint256) {\n        if (globalState != 0) {\n            return (rewardState * vaultState) / globalState;\n        }\n\n        return 0;\n    }\n\n    /**\n        @notice Provision reward state to test compounding of rewards\n        @param  secondsElapsed    uint256  Seconds to forward timestamp\n        @return wethRewardState   uint256  WETH reward state\n        @return pxGmxRewardState  uint256  pxGMX reward state\n     */\n    function _provisionRewardState(uint256 secondsElapsed)\n        internal\n        returns (uint256 wethRewardState, uint256 pxGmxRewardState)\n    {\n        // Time skip to accrue rewards then return the latest reward states\n        vm.warp(block.timestamp + secondsElapsed);\n\n        pirexRewards.harvest();\n\n        // Take into account rewards from both pxGMX and pxGLP based on the vault's current shares\n        uint256 pxGmxGlobalRewards = _calculateGlobalRewards(pxGmx);\n        uint256 pxGlpGlobalRewards = _calculateGlobalRewards(pxGlp);\n        uint256 pxGmxVaultRewards = _calculateUserRewards(\n            pxGmx,\n            address(autoPxGlp)\n        );\n        uint256 pxGlpVaultRewards = _calculateUserRewards(\n            pxGlp,\n            address(autoPxGlp)\n        );\n\n        wethRewardState =\n            _calculateVaultReward(\n                pirexRewards.getRewardState(pxGmx, weth),\n                pxGmxVaultRewards,\n                pxGmxGlobalRewards\n            ) +\n            _calculateVaultReward(\n                pirexRewards.getRewardState(pxGlp, weth),\n                pxGlpVaultRewards,\n                pxGlpGlobalRewards\n            );\n        pxGmxRewardState =\n            _calculateVaultReward(\n                pirexRewards.getRewardState(pxGmx, pxGmx),\n                pxGmxVaultRewards,\n                pxGmxGlobalRewards\n            ) +\n            _calculateVaultReward(\n                pirexRewards.getRewardState(pxGlp, pxGmx),\n                pxGlpVaultRewards,\n                pxGlpGlobalRewards\n            );\n    }\n\n    /**\n        @notice Compound and perform assertions partially\n        @return wethAmount      uint256  WETH amount\n        @return pxGmxAmount     uint256  pxGMX amount\n        @return pxGlpAmount     uint256  pxGLP amount\n        @return pxGlpFee        uint256  pxGLP fee\n        @return pxGlpInc        uint256  pxGLP incentive\n        @return pxGmxFee        uint256  pxGMX fee\n    */\n    function _compoundAndAssert()\n        internal\n        returns (\n            uint256 wethAmount,\n            uint256 pxGmxAmount,\n            uint256 pxGlpAmount,\n            uint256 pxGlpFee,\n            uint256 pxGlpInc,\n            uint256 pxGmxFee\n        )\n    {\n        uint256 preCompoundOwnerBalance = pxGmx.balanceOf(autoPxGlp.owner());\n        uint256 preCompoundCompounderBalance = pxGmx.balanceOf(testAccounts[0]);\n\n        vm.expectEmit(true, false, false, false, address(autoPxGlp));\n\n        emit Compounded(testAccounts[0], 0, 0, 0, 0, 0, 0, 0, 0);\n\n        // Call as testAccounts[0] to test compound incentive transfer\n        vm.prank(testAccounts[0]);\n\n        (\n            uint256 wethAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        ) = autoPxGlp.compound(1, 1, false);\n\n        // Assert updated states separately (stack-too-deep issue)\n        _assertPostCompoundPxGmxRewardStates(\n            preCompoundOwnerBalance,\n            preCompoundCompounderBalance,\n            pxGmxAmountOut,\n            totalPxGmxFee,\n            pxGmxIncentive\n        );\n\n        wethAmount = wethAmountIn;\n        pxGmxAmount = pxGmxAmountOut;\n        pxGlpAmount = pxGlpAmountOut;\n        pxGlpFee = totalPxGlpFee;\n        pxGlpInc = pxGlpIncentive;\n        pxGmxFee = totalPxGmxFee;\n    }\n\n    /**\n        @notice Assert main vault states after performing compound\n        @param  user                       address  Test user address\n        @param  pxGlpAmountOut             uint256  pxGLP rewards before fees\n        @param  totalPxGlpFee              uint256  Total fees for pxGLP\n        @param  pxGlpIncentive             uint256  Incentive for pxGLP\n        @param  totalAssetsBeforeCompound  uint256  Total assets before compound\n     */\n    function _assertPostCompoundVaultStates(\n        address user,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 pxGlpIncentive,\n        uint256 totalAssetsBeforeCompound\n    ) internal {\n        uint256 userShareBalance = autoPxGlp.balanceOf(user);\n        uint256 expectedTotalPxGlpFee = (pxGlpAmountOut *\n            autoPxGlp.platformFee()) / autoPxGlp.FEE_DENOMINATOR();\n        uint256 expectedCompoundIncentive = (totalPxGlpFee *\n            autoPxGlp.compoundIncentive()) / autoPxGlp.FEE_DENOMINATOR();\n        uint256 expectedTotalAssets = totalAssetsBeforeCompound +\n            pxGlpAmountOut -\n            totalPxGlpFee;\n\n        assertGt(expectedTotalAssets, totalAssetsBeforeCompound);\n        assertEq(expectedTotalAssets, autoPxGlp.totalAssets());\n        assertEq(expectedTotalAssets, pxGlp.balanceOf(address(autoPxGlp)));\n        assertEq(expectedTotalPxGlpFee, totalPxGlpFee);\n        assertEq(expectedCompoundIncentive, pxGlpIncentive);\n        assertEq(\n            expectedTotalPxGlpFee -\n                expectedCompoundIncentive +\n                expectedCompoundIncentive,\n            totalPxGlpFee\n        );\n        assertEq(userShareBalance, autoPxGlp.balanceOf(user));\n    }\n\n    /**\n        @notice Assert pxGMX reward states after performing compound\n        @param  preCompoundOwnerBalance       uint256  Pre-compound owner pxGmx balance\n        @param  preCompoundCompounderBalance  uint256  Pre-compound compounder pxGmx balance\n        @param  pxGmxAmountOut                uint256  pxGMX rewards before fees\n        @param  totalPxGmxFee                 uint256  Total fees for pxGMX\n        @param  pxGmxIncentive                uint256  Incentive for pxGMX\n     */\n    function _assertPostCompoundPxGmxRewardStates(\n        uint256 preCompoundOwnerBalance,\n        uint256 preCompoundCompounderBalance,\n        uint256 pxGmxAmountOut,\n        uint256 totalPxGmxFee,\n        uint256 pxGmxIncentive\n    ) internal {\n        uint256 expectedTotalPxGmxFee = (pxGmxAmountOut *\n            autoPxGlp.platformFee()) / autoPxGlp.FEE_DENOMINATOR();\n        uint256 expectedCompoundPxGmxIncentive = (totalPxGmxFee *\n            autoPxGlp.compoundIncentive()) / autoPxGlp.FEE_DENOMINATOR();\n        assertEq(expectedTotalPxGmxFee, totalPxGmxFee);\n        assertEq(expectedCompoundPxGmxIncentive, pxGmxIncentive);\n\n        // Check for pxGMX reward balances of the fee receivers\n        assertEq(\n            preCompoundOwnerBalance +\n                expectedTotalPxGmxFee -\n                expectedCompoundPxGmxIncentive,\n            pxGmx.balanceOf(autoPxGlp.owner())\n        );\n        assertEq(\n            preCompoundCompounderBalance + expectedCompoundPxGmxIncentive,\n            pxGmx.balanceOf(testAccounts[0])\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setWithdrawalPenalty TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetWithdrawalPenaltyUnauthorized() external {\n        // Define function arguments\n        uint256 penalty = 1;\n\n        // Define post-transition/upcoming state or effects\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        // Execute state transition\n        vm.prank(testAccounts[0]);\n\n        autoPxGlp.setWithdrawalPenalty(penalty);\n    }\n\n    /**\n        @notice Test tx reversion: penalty exceeds max\n     */\n    function testCannotSetWithdrawalPenaltyExceedsMax() external {\n        uint256 invalidPenalty = autoPxGlp.MAX_WITHDRAWAL_PENALTY() + 1;\n\n        vm.expectRevert(AutoPxGlp.ExceedsMax.selector);\n\n        autoPxGlp.setWithdrawalPenalty(invalidPenalty);\n    }\n\n    /**\n        @notice Test tx success: set withdrawal penalty\n     */\n    function testSetWithdrawalPenalty() external {\n        uint256 initialWithdrawalPenalty = autoPxGlp.withdrawalPenalty();\n        uint256 penalty = 1;\n        uint256 expectedWithdrawalPenalty = penalty;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGlp));\n\n        emit WithdrawalPenaltyUpdated(expectedWithdrawalPenalty);\n\n        autoPxGlp.setWithdrawalPenalty(penalty);\n\n        assertEq(expectedWithdrawalPenalty, autoPxGlp.withdrawalPenalty());\n        assertTrue(expectedWithdrawalPenalty != initialWithdrawalPenalty);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPlatformFee TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPlatformFeeUnauthorized() external {\n        uint256 fee = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGlp.setPlatformFee(fee);\n    }\n\n    /**\n        @notice Test tx reversion: fee exceeds max\n     */\n    function testCannotSetPlatformFeeExceedsMax() external {\n        uint256 invalidFee = autoPxGlp.MAX_PLATFORM_FEE() + 1;\n\n        vm.expectRevert(AutoPxGlp.ExceedsMax.selector);\n\n        autoPxGlp.setPlatformFee(invalidFee);\n    }\n\n    /**\n        @notice Test tx success: set platform fee\n     */\n    function testSetPlatformFee() external {\n        uint256 initialPlatformFee = autoPxGlp.platformFee();\n        uint256 fee = 1;\n        uint256 expectedPlatformFee = fee;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGlp));\n\n        emit PlatformFeeUpdated(expectedPlatformFee);\n\n        autoPxGlp.setPlatformFee(fee);\n\n        assertEq(expectedPlatformFee, autoPxGlp.platformFee());\n        assertTrue(expectedPlatformFee != initialPlatformFee);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setCompoundIncentive TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetCompoundIncentiveUnauthorized() external {\n        uint256 incentive = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGlp.setCompoundIncentive(incentive);\n    }\n\n    /**\n        @notice Test tx reversion: incentive exceeds max\n     */\n    function testCannotSetCompoundIncentiveExceedsMax() external {\n        uint256 invalidIncentive = autoPxGlp.MAX_COMPOUND_INCENTIVE() + 1;\n\n        vm.expectRevert(AutoPxGlp.ExceedsMax.selector);\n\n        autoPxGlp.setCompoundIncentive(invalidIncentive);\n    }\n\n    /**\n        @notice Test tx success: set compound incentive percent\n     */\n    function testSetCompoundIncentive() external {\n        uint256 initialCompoundIncentive = autoPxGlp.compoundIncentive();\n        uint256 incentive = 1;\n        uint256 expectedCompoundIncentive = incentive;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGlp));\n\n        emit CompoundIncentiveUpdated(expectedCompoundIncentive);\n\n        autoPxGlp.setCompoundIncentive(incentive);\n\n        assertEq(expectedCompoundIncentive, autoPxGlp.compoundIncentive());\n        assertTrue(expectedCompoundIncentive != initialCompoundIncentive);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPlatform TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPlatformUnauthorized() external {\n        address platform = address(this);\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGlp.setPlatform(platform);\n    }\n\n    /**\n        @notice Test tx reversion: platform is zero address\n     */\n    function testCannotSetPlatformZeroAddress() external {\n        address invalidPlatform = address(0);\n\n        vm.expectRevert(PxGmxReward.ZeroAddress.selector);\n\n        autoPxGlp.setPlatform(invalidPlatform);\n    }\n\n    /**\n        @notice Test tx success: set platform\n     */\n    function testSetPlatform() external {\n        address initialPlatform = autoPxGlp.platform();\n        address platform = address(this);\n        address expectedPlatform = platform;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGlp));\n\n        emit PlatformUpdated(expectedPlatform);\n\n        autoPxGlp.setPlatform(platform);\n\n        assertEq(expectedPlatform, autoPxGlp.platform());\n        assertTrue(expectedPlatform != initialPlatform);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        totalAssets TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: return the total assets\n        @param  multiplier  uint8  Multiplied with fixed token amounts for randomness\n    */\n    function testTotalAssets(uint8 multiplier) external {\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        uint256 initialTotalAssets = autoPxGlp.totalAssets();\n\n        uint256 totalDeposit;\n        uint256[] memory depositAmounts = _depositGlpForTestAccounts(\n            false,\n            address(this),\n            multiplier,\n            true\n        );\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address testAccount = testAccounts[i];\n\n            vm.startPrank(testAccount);\n\n            pxGlp.approve(address(autoPxGlp), pxGlp.balanceOf(testAccount));\n            autoPxGlp.deposit(pxGlp.balanceOf(testAccount), testAccount);\n\n            vm.stopPrank();\n\n            totalDeposit += depositAmounts[i];\n        }\n\n        uint256 assets = pxGlp.balanceOf(address(autoPxGlp));\n\n        assertEq(assets, autoPxGlp.totalAssets());\n        assertTrue(assets != initialTotalAssets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        compound TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: minUsdg is invalid (zero)\n     */\n    function testCannotCompoundMinUsdgInvalidParam() external {\n        uint256 invalidMinUsdg = 0;\n        uint256 minGlp = 1;\n        bool optOutIncentive = true;\n\n        vm.expectRevert(AutoPxGlp.InvalidParam.selector);\n\n        autoPxGlp.compound(invalidMinUsdg, minGlp, optOutIncentive);\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is invalid (zero)\n     */\n    function testCannotCompoundMinGlpInvalidParam() external {\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlpAmount = 0;\n        bool optOutIncentive = true;\n\n        vm.expectRevert(AutoPxGlp.InvalidParam.selector);\n\n        autoPxGlp.compound(minUsdg, invalidMinGlpAmount, optOutIncentive);\n    }\n\n    /**\n        @notice Test tx success: compound pxGLP rewards into more pxGLP and track pxGMX reward states\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testCompound(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            _depositToVault(testAccounts[i]);\n\n            (\n                uint256 wethRewardState,\n                uint256 pxGmxRewardState\n            ) = _provisionRewardState(secondsElapsed);\n\n            uint256 totalAssetsBeforeCompound = autoPxGlp.totalAssets();\n            uint256 pxGmxBalanceBeforeCompound = pxGmx.balanceOf(\n                address(autoPxGlp)\n            );\n            uint256 pxGlpOwnerBalanceBeforeCompound = pxGlp.balanceOf(\n                autoPxGlp.owner()\n            );\n            // Commented out due to Stack-too-deep\n            // uint256 pxGlpCompounderBalanceBeforeCompound = pxGlp.balanceOf(\n            //     testAccounts[0]\n            // );\n            uint256 expectedGlobalLastSupply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n\n            assertGt(wethRewardState, 0);\n\n            // Perform compound and assertions partially (stack-too-deep)\n            (\n                uint256 wethAmountIn,\n                uint256 pxGmxAmountOut,\n                uint256 pxGlpAmountOut,\n                uint256 totalPxGlpFee,\n                uint256 pxGlpIncentive,\n                uint256 totalPxGmxFee\n            ) = _compoundAndAssert();\n\n            // Perform the rest of the assertions (stack-too-deep)\n            assertEq(wethRewardState, wethAmountIn);\n            assertEq(pxGmxRewardState, pxGmxAmountOut);\n\n            _assertGlobalState(\n                block.timestamp,\n                expectedGlobalLastSupply,\n                expectedGlobalRewards\n            );\n\n            _assertPostCompoundVaultStates(\n                testAccounts[i],\n                pxGlpAmountOut,\n                totalPxGlpFee,\n                pxGlpIncentive,\n                totalAssetsBeforeCompound\n            );\n\n            assertEq(\n                (pxGmxAmountOut - totalPxGmxFee),\n                pxGmx.balanceOf(address(autoPxGlp)) - pxGmxBalanceBeforeCompound\n            );\n\n            // Check for vault asset balances of the fee receivers\n            assertEq(\n                pxGlpOwnerBalanceBeforeCompound +\n                    totalPxGlpFee -\n                    pxGlpIncentive,\n                pxGlp.balanceOf(autoPxGlp.owner())\n            );\n            // Commented out due to Stack-too-deep\n            // assertEq(\n            //     pxGlpCompounderBalanceBeforeCompound + pxGlpIncentive,\n            //     pxGlp.balanceOf(testAccounts[0])\n            // );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        deposit TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: deposit to vault and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testDeposit(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            _depositToVault(testAccounts[i]);\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedLastUpdate = block.timestamp;\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 pxGmxRewardAfterFees = pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n\n            // Perform another deposit and assert the updated pxGMX reward states\n            _depositGlpETHWithTimeSkip(\n                (1 ether * (i + 1) * multiplier),\n                testAccounts[i],\n                0\n            );\n\n            uint256 newShares = _depositToVault(testAccounts[i]);\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                expectedLastUpdate,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                expectedLastUpdate,\n                initialBalance + newShares,\n                expectedUserRewardState\n            );\n            assertEq(\n                initialRewardState + pxGmxRewardAfterFees,\n                autoPxGlp.rewardState()\n            );\n\n            // Deposit should still increment the totalSupply and user shares\n            assertEq(supply + newShares, autoPxGlp.totalSupply());\n            assertEq(\n                initialBalance + newShares,\n                autoPxGlp.balanceOf(testAccounts[i])\n            );\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance + pxGmxRewardAfterFees,\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositFsGlp TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: fsGLP amount is zero\n     */\n    function testCannotDepositFsGlpZeroAmount() external {\n        uint256 invalidAmount = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositFsGlp(invalidAmount, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: fsGLP amount is zero\n     */\n    function testCannotDepositFsGlpZeroAddress() external {\n        uint256 amount = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PxGmxReward.ZeroAddress.selector);\n\n        autoPxGlp.depositFsGlp(amount, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx success: deposit using fsGLP to vault and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testDepositFsGlp(uint8 multiplier, uint32 secondsElapsed)\n        external\n    {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(0);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            // Mint fsGLP for the testAccount then deposit to the vault\n            uint256 fsGlpBalance = _mintAndApproveFsGlp(\n                multiplier * 1 ether,\n                testAccounts[i]\n            );\n\n            vm.startPrank(testAccounts[i]);\n\n            STAKED_GLP.approve(address(autoPxGlp), fsGlpBalance);\n\n            vm.expectEmit(true, true, false, false, address(autoPxGlp));\n\n            emit Deposit(testAccounts[i], testAccounts[i], 0, 0);\n\n            autoPxGlp.depositFsGlp(fsGlpBalance, testAccounts[i]);\n\n            vm.stopPrank();\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n\n            // Make sure that the actual minted shares is correct\n            assertEq(\n                initialBalance,\n                autoPxGlp.previewDeposit(\n                    fsGlpBalance -\n                        (fsGlpBalance * pirexGmx.fees(PirexGmx.Fees.Deposit)) /\n                        pirexGmx.FEE_DENOMINATOR()\n                )\n            );\n\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 pxGmxRewardAfterFees = pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n\n            // Perform another deposit and assert the updated pxGMX reward states\n            _depositGlpETHWithTimeSkip(\n                (1 ether * (i + 1) * multiplier),\n                testAccounts[i],\n                0\n            );\n\n            uint256 newShares = _depositToVault(testAccounts[i]);\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                block.timestamp,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                block.timestamp,\n                initialBalance + newShares,\n                expectedUserRewardState\n            );\n            assertEq(\n                initialRewardState + pxGmxRewardAfterFees,\n                autoPxGlp.rewardState()\n            );\n\n            // Deposit should still increment the totalSupply and user shares\n            assertEq(supply + newShares, autoPxGlp.totalSupply());\n            assertEq(\n                initialBalance + newShares,\n                autoPxGlp.balanceOf(testAccounts[i])\n            );\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance + pxGmxRewardAfterFees,\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGlp TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: token address is the zero address\n     */\n    function testCannotDepositGlpTokenZeroAddress() external {\n        address invalidToken = address(0);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PxGmxReward.ZeroAddress.selector);\n\n        autoPxGlp.depositGlp(\n            invalidToken,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: token amount is zero\n     */\n    function testCannotDepositGlpTokenZeroAmount() external {\n        address token = address(weth);\n        uint256 invalidTokenAmount = 0;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositGlp(\n            token,\n            invalidTokenAmount,\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minUsdg is zero\n     */\n    function testCannotDepositGlpMinUsdgZeroAmount() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 invalidMinUsdg = 0;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositGlp(\n            token,\n            tokenAmount,\n            invalidMinUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is zero\n     */\n    function testCannotDepositGlpMinGlpZeroAmount() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlp = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            invalidMinGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: receiver is the zero address\n     */\n    function testCannotDepositGlpReceiverZeroAddress() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PxGmxReward.ZeroAddress.selector);\n\n        autoPxGlp.depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            invalidReceiver\n        );\n    }\n\n    /**\n        @notice Test tx success: deposit using whitelisted token to vault and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testDepositGlp(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(0);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            // Mint WETH for the testAccount then deposit to the vault\n            vm.deal(address(this), multiplier * 1 ether);\n\n            _mintWrappedToken(multiplier * 1 ether, testAccounts[i]);\n\n            vm.startPrank(testAccounts[i]);\n\n            weth.approve(address(autoPxGlp), weth.balanceOf(testAccounts[i]));\n\n            vm.expectEmit(true, true, false, false, address(autoPxGlp));\n\n            emit Deposit(testAccounts[i], testAccounts[i], 0, 0);\n\n            autoPxGlp.depositGlp(\n                address(weth),\n                weth.balanceOf(testAccounts[i]),\n                1,\n                1,\n                testAccounts[i]\n            );\n\n            vm.stopPrank();\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 pxGmxRewardAfterFees = pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n\n            // Perform another deposit and assert the updated pxGMX reward states\n            _depositGlpETHWithTimeSkip(\n                (1 ether * (i + 1) * multiplier),\n                testAccounts[i],\n                0\n            );\n\n            uint256 newShares = _depositToVault(testAccounts[i]);\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                block.timestamp,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                block.timestamp,\n                initialBalance + newShares,\n                expectedUserRewardState\n            );\n            assertEq(\n                initialRewardState + pxGmxRewardAfterFees,\n                autoPxGlp.rewardState()\n            );\n\n            // Deposit should still increment the totalSupply and user shares\n            assertEq(supply + newShares, autoPxGlp.totalSupply());\n            assertEq(\n                initialBalance + newShares,\n                autoPxGlp.balanceOf(testAccounts[i])\n            );\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance + pxGmxRewardAfterFees,\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGlpETH TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: msg.value is zero\n     */\n    function testCannotDepositGlpETHValueZeroAmount() external {\n        uint256 invalidAmount = 0;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositGlpETH{value: invalidAmount}(\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minUsdg is zero\n     */\n    function testCannotDepositGlpETHMinUsdgZeroAmount() external {\n        uint256 amount = 1;\n        uint256 invalidMinUsdg = 0;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositGlpETH{value: amount}(\n            invalidMinUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is zero\n     */\n    function testCannotDepositGlpETHMinGlpZeroAmount() external {\n        uint256 amount = 1;\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlp = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositGlpETH{value: amount}(\n            minUsdg,\n            invalidMinGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: receiver is the zero address\n     */\n    function testCannotDepositGlpETHReceiverZeroAddress() external {\n        uint256 amount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PxGmxReward.ZeroAddress.selector);\n\n        autoPxGlp.depositGlpETH{value: amount}(\n            minUsdg,\n            minGlp,\n            invalidReceiver\n        );\n    }\n\n    /**\n        @notice Test tx success: deposit using ETH to vault and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testDepositGlpETH(uint8 multiplier, uint32 secondsElapsed)\n        external\n    {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(0);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            // Deal ETH for the testAccount then deposit to the vault\n            uint256 ethAmount = multiplier * 1 ether;\n\n            vm.deal(testAccounts[i], ethAmount);\n\n            vm.startPrank(testAccounts[i]);\n\n            vm.expectEmit(true, true, false, false, address(autoPxGlp));\n\n            emit Deposit(testAccounts[i], testAccounts[i], 0, 0);\n\n            autoPxGlp.depositGlpETH{value: ethAmount}(1, 1, testAccounts[i]);\n\n            vm.stopPrank();\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 pxGmxRewardAfterFees = pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n\n            // Perform another deposit and assert the updated pxGMX reward states\n            _depositGlpETHWithTimeSkip(\n                (1 ether * (i + 1) * multiplier),\n                testAccounts[i],\n                0\n            );\n\n            uint256 newShares = _depositToVault(testAccounts[i]);\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                block.timestamp,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                block.timestamp,\n                initialBalance + newShares,\n                expectedUserRewardState\n            );\n            assertEq(\n                initialRewardState + pxGmxRewardAfterFees,\n                autoPxGlp.rewardState()\n            );\n\n            // Deposit should still increment the totalSupply and user shares\n            assertEq(supply + newShares, autoPxGlp.totalSupply());\n            assertEq(\n                initialBalance + newShares,\n                autoPxGlp.balanceOf(testAccounts[i])\n            );\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance + pxGmxRewardAfterFees,\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        mint TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: mint vault shares and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testMint(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            _depositToVault(testAccounts[i]);\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 pxGmxRewardAfterFees = pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n\n            // Perform mint instead of deposit and assert the updated pxGMX reward states\n            _depositGlpETHWithTimeSkip(\n                (1 ether * (i + 1) * multiplier),\n                testAccounts[i],\n                0\n            );\n\n            vm.startPrank(testAccounts[i]);\n\n            pxGlp.approve(address(autoPxGlp), pxGlp.balanceOf(testAccounts[i]));\n\n            uint256 newShares = autoPxGlp.previewDeposit(\n                pxGlp.balanceOf(testAccounts[i])\n            ) / 2;\n\n            autoPxGlp.mint(newShares, testAccounts[i]);\n\n            vm.stopPrank();\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                block.timestamp,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                block.timestamp,\n                initialBalance + newShares,\n                expectedUserRewardState\n            );\n            assertEq(\n                autoPxGlp.rewardState(),\n                initialRewardState + pxGmxRewardAfterFees\n            );\n\n            // Mint should still increment the totalSupply and user shares\n            assertEq(supply + newShares, autoPxGlp.totalSupply());\n            assertEq(\n                initialBalance + newShares,\n                autoPxGlp.balanceOf(testAccounts[i])\n            );\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance + pxGmxRewardAfterFees,\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        withdraw TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: withdraw from vault and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testWithdraw(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            _depositToVault(testAccounts[i]);\n\n            (\n                uint256 wethRewardState,\n                uint256 pxGmxRewardState\n            ) = _provisionRewardState(secondsElapsed);\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n            uint256 expectedAdditionalGlp = _calculateMinGlpAmount(\n                address(weth),\n                wethRewardState,\n                18\n            );\n            // Take into account fees\n            expectedAdditionalGlp -=\n                (expectedAdditionalGlp * pirexGmx.fees(PirexGmx.Fees.Deposit)) /\n                pirexGmx.FEE_DENOMINATOR();\n            expectedAdditionalGlp -=\n                (expectedAdditionalGlp * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n\n            // Withdraw from the vault and assert the updated pxGMX reward states\n            vm.startPrank(testAccounts[i]);\n\n            // Take into account additional glp from compound and withdraw all\n            uint256 shares = autoPxGlp.withdraw(\n                autoPxGlp.previewRedeem(initialBalance) + expectedAdditionalGlp,\n                testAccounts[i],\n                testAccounts[i]\n            );\n\n            vm.stopPrank();\n\n            // Since we withdraw the entire balance of the user, post-withdrawal should leave it with 0 share\n            assertEq(0, autoPxGlp.balanceOf(testAccounts[i]));\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                block.timestamp,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                block.timestamp,\n                initialBalance - shares,\n                expectedUserRewardState\n            );\n            assertEq(\n                initialRewardState +\n                    (pxGmxRewardState -\n                        (pxGmxRewardState * autoPxGlp.platformFee()) /\n                        autoPxGlp.FEE_DENOMINATOR()),\n                autoPxGlp.rewardState()\n            );\n\n            // Withdrawal should still decrement the totalSupply and user shares\n            assertEq(supply - shares, autoPxGlp.totalSupply());\n            assertEq(\n                initialBalance - shares,\n                autoPxGlp.balanceOf(testAccounts[i])\n            );\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance +\n                    (pxGmxRewardState -\n                        (pxGmxRewardState * autoPxGlp.platformFee()) /\n                        autoPxGlp.FEE_DENOMINATOR()),\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        redeem TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: redeem from vault and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testRedeem(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            _depositToVault(testAccounts[i]);\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 pxGmxRewardAfterFees = pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n\n            // Redeem from the vault and assert the updated pxGMX reward states\n            vm.prank(testAccounts[i]);\n\n            autoPxGlp.redeem(initialBalance, testAccounts[i], testAccounts[i]);\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                block.timestamp,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                block.timestamp,\n                0,\n                expectedUserRewardState\n            );\n            assertEq(\n                initialRewardState + pxGmxRewardAfterFees,\n                autoPxGlp.rewardState()\n            );\n\n            // Redemption should still decrement the totalSupply and user shares\n            assertEq(supply - initialBalance, autoPxGlp.totalSupply());\n            assertEq(0, autoPxGlp.balanceOf(testAccounts[i]));\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance + pxGmxRewardAfterFees,\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        claim TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotClaimZeroAddress() external {\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PxGmxReward.ZeroAddress.selector);\n\n        autoPxGlp.claim(invalidReceiver);\n    }\n\n    /**\n        @notice Test tx success: claim pxGMX rewards and assert the reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testClaim(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        uint256 totalClaimable;\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address account = testAccounts[i];\n            address receiver = testAccounts[i];\n\n            _depositToVault(account);\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 pxGmxBalanceBeforeClaim = pxGmx.balanceOf(receiver);\n            uint256 expectedLastBalance = autoPxGlp.balanceOf(account);\n            uint256 expectedGlobalLastUpdate = block.timestamp;\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n\n            totalClaimable +=\n                pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 expectedUserRewardState = _calculateUserRewards(account);\n            uint256 expectedClaimableReward = (totalClaimable *\n                expectedUserRewardState) / expectedGlobalRewards;\n\n            // Event is only logged when rewards exists (ie. non-zero esGMX yields)\n            if (expectedClaimableReward != 0) {\n                vm.expectEmit(true, false, false, false, address(autoPxGlp));\n\n                emit PxGmxClaimed(account, receiver, 0);\n            }\n\n            // Claim pxGMX reward from the vault and transfer it to the receiver directly\n            vm.prank(account);\n\n            autoPxGlp.claim(receiver);\n\n            // Claiming should also update the pxGMX balance for the receiver and the reward state\n            assertEq(\n                expectedClaimableReward + pxGmxBalanceBeforeClaim,\n                pxGmx.balanceOf(receiver)\n            );\n            _assertGlobalState(\n                expectedGlobalLastUpdate,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards - expectedUserRewardState\n            );\n            _assertUserRewardState(\n                account,\n                block.timestamp,\n                expectedLastBalance,\n                0\n            );\n\n            // Properly update the total tally of claimable pxGMX\n            totalClaimable -= expectedClaimableReward;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        transfer TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: transfer (or transferFrom) to another account and assert the pxGMX reward states\n        @param  multiplier          uint8   Multiplied with fixed token amounts for randomness\n        @param  transferPercentage  uint8   Percentage of sender balance to be transferred\n        @param  secondsElapsed      uint32  Seconds to forward timestamp\n        @param  useTransferFrom     bool    Whether to use transferFrom\n     */\n    function testTransfer(\n        uint8 multiplier,\n        uint8 transferPercentage,\n        uint32 secondsElapsed,\n        bool useTransferFrom\n    ) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        vm.assume(transferPercentage != 0);\n        vm.assume(transferPercentage <= 100);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address account = testAccounts[i];\n            address receiver = testAccounts[\n                (i < testAccounts.length - 1 ? i + 1 : 0)\n            ];\n\n            _depositToVault(account);\n\n            _provisionRewardState(secondsElapsed);\n\n            uint256 initialSenderBalance = autoPxGlp.balanceOf(account);\n            uint256 initialReceiverBalance = autoPxGlp.balanceOf(receiver);\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedLastUpdate = block.timestamp;\n            uint256 expectedSenderRewardState = _calculateUserRewards(account);\n            uint256 expectedReceiverRewardState = _calculateUserRewards(\n                receiver\n            );\n\n            // Transfer certain percentages of the apxGLP holding to the other account\n            uint256 transferAmount = (initialSenderBalance *\n                transferPercentage) / 100;\n            uint256 expectedSenderBalance = initialSenderBalance -\n                transferAmount;\n            uint256 expectedReceiverBalance = initialReceiverBalance +\n                transferAmount;\n\n            // If transferFrom is used, make sure to properly approve the caller\n            if (useTransferFrom) {\n                vm.prank(account);\n\n                autoPxGlp.approve(address(this), transferAmount);\n\n                autoPxGlp.transferFrom(account, receiver, transferAmount);\n            } else {\n                vm.prank(account);\n\n                autoPxGlp.transfer(receiver, transferAmount);\n            }\n\n            // Assert pxGMX reward states for both sender and receiver\n            _assertUserRewardState(\n                account,\n                expectedLastUpdate,\n                expectedSenderBalance,\n                expectedSenderRewardState\n            );\n            _assertUserRewardState(\n                receiver,\n                expectedLastUpdate,\n                expectedReceiverBalance,\n                expectedReceiverRewardState\n            );\n\n            // Transfer should still update the balances and maintain totalSupply\n            assertEq(supply, autoPxGlp.totalSupply());\n            assertEq(expectedSenderBalance, autoPxGlp.balanceOf(account));\n            assertEq(expectedReceiverBalance, autoPxGlp.balanceOf(receiver));\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "PirexGmx.sol",
            "PirexGmx.t.sol",
            "AutoPxGlp.sol",
            "AutoPxGlp.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "depositGlp() function in PirexGmx and AutoPxGlp contracts",
                "Type": "Token deposit logic vulnerability",
                "Description": "If a token with transfer fees is deposited, the logic will break and calls to depositGlp() with such token will fail. This vulnerability is of medium severity as it can be triggered by any token with fees, which is a common occurrence.",
                "Repair": "Check the balance of the deposited token before transferring it to the contract and use the actual transferred amount for further operations"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function compound(poolFee, 1, 0, true);",
                "Type": "Arbitrary State Change",
                "Description": "An attacker can prevent any user from calling the functions 'withdraw', 'redeem', or 'depositGmx' in contract 'AutoPxGmx' by manipulating the balance of token 'gmxBaseReward', so that during the function 'compound' the swap will be reverted.",
                "Repair": "Set the parameter 'amountOutMinimum' to zero when calling the function 'compound'"
            },
            {
                "Location": "AutoPxGlp::compound function",
                "Type": "Loss of assets",
                "Description": "Compounded assets may be lost because AutoPxGlp::compound can be called by anyone and minimum amount of GLP and USDG are under caller's control. The only check concerning minValues is that they are not zero (1 will work, however from the perspective of real tokens e.g. 1e6, or 1e18 it's virtually zero).",
                "Repair": "Use GMX oracle to get current price and check it against some other price feed (e.g. ChainLink). Don't depend on user passing minimum amounts of USDG and GLP tokens."
            },
            {
                "Location": "PirexGmx#migrateReward() function",
                "Type": "Loss of reward",
                "Description": "PirexGmx#migrateReward() may cause users to lose Reward before PirexRewards.sol set new PirexGmx.",
                "Repair": "In #migrateReward(), set the old PirexGmx's 'pirexRewards' to address(0), so that you can't use the old PirexGmx to get rewards"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {OwnableUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IProducer} from \"src/interfaces/IProducer.sol\";\nimport {GlobalState, UserState} from \"src/Common.sol\";\n\n/**\n    Originally inspired by Flywheel V2 (thank you Tribe team):\n    https://github.com/fei-protocol/flywheel-v2/blob/dbe3cb8/src/FlywheelCore.sol\n*/\ncontract PirexRewards is OwnableUpgradeable {\n    using SafeTransferLib for ERC20;\n    using SafeCastLib for uint256;\n\n    struct ProducerToken {\n        ERC20[] rewardTokens;\n        GlobalState globalState;\n        mapping(address => UserState) userStates;\n        mapping(ERC20 => uint256) rewardStates;\n        mapping(address => mapping(ERC20 => address)) rewardRecipients;\n    }\n\n    // Pirex contract which produces rewards\n    IProducer public producer;\n\n    // Producer tokens mapped to their data\n    mapping(ERC20 => ProducerToken) public producerTokens;\n\n    event SetProducer(address producer);\n    event SetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipient(\n        address indexed user,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event AddRewardToken(\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n    event RemoveRewardToken(ERC20 indexed producerToken, uint256 removalIndex);\n    event GlobalAccrue(\n        ERC20 indexed producerToken,\n        uint256 lastUpdate,\n        uint256 lastSupply,\n        uint256 rewards\n    );\n    event UserAccrue(\n        ERC20 indexed producerToken,\n        address indexed user,\n        uint256 lastUpdate,\n        uint256 lastBalance,\n        uint256 rewards\n    );\n    event Harvest(\n        ERC20[] producerTokens,\n        ERC20[] rewardTokens,\n        uint256[] rewardAmounts\n    );\n    event Claim(ERC20 indexed producerToken, address indexed user);\n    event SetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken,\n        address recipient\n    );\n    event UnsetRewardRecipientPrivileged(\n        address indexed lpContract,\n        ERC20 indexed producerToken,\n        ERC20 indexed rewardToken\n    );\n\n    error ZeroAddress();\n    error NotContract();\n    error TokenAlreadyAdded();\n\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    /**\n        @notice Set producer\n        @param  _producer  address  Producer contract address\n     */\n    function setProducer(address _producer) external onlyOwner {\n        if (_producer == address(0)) revert ZeroAddress();\n\n        producer = IProducer(_producer);\n\n        emit SetProducer(_producer);\n    }\n\n    /**\n        @notice Set reward recipient for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipient(\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipient(\n            msg.sender,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Unset reward recipient for a reward token\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function unsetRewardRecipient(ERC20 producerToken, ERC20 rewardToken)\n        external\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[msg.sender][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipient(msg.sender, producerToken, rewardToken);\n    }\n\n    /**\n        @notice Add a reward token to a producer token's rewardTokens array\n        @param  producerToken  ERC20  Producer token contract\n        @param  rewardToken    ERC20  Reward token contract\n    */\n    function addRewardToken(ERC20 producerToken, ERC20 rewardToken)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        // Check if the token has been added previously for the specified producer\n        ProducerToken storage p = producerTokens[producerToken];\n        ERC20[] memory rewardTokens = p.rewardTokens;\n        uint256 len = rewardTokens.length;\n\n        for (uint256 i; i < len; ++i) {\n            if (address(rewardTokens[i]) == address(rewardToken)) {\n                revert TokenAlreadyAdded();\n            }\n        }\n\n        p.rewardTokens.push(rewardToken);\n\n        emit AddRewardToken(producerToken, rewardToken);\n    }\n\n    /**\n        @notice Remove a reward token from a producer token's rewardTokens array\n        @param  producerToken  ERC20    Producer token contract\n        @param  removalIndex   uint256  Index of the element to be removed\n    */\n    function removeRewardToken(ERC20 producerToken, uint256 removalIndex)\n        external\n        onlyOwner\n    {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        ERC20[] storage rewardTokens = producerTokens[producerToken]\n            .rewardTokens;\n        uint256 lastIndex = rewardTokens.length - 1;\n\n        if (removalIndex != lastIndex) {\n            // Set the element at removalIndex to the last element\n            rewardTokens[removalIndex] = rewardTokens[lastIndex];\n        }\n\n        rewardTokens.pop();\n\n        emit RemoveRewardToken(producerToken, removalIndex);\n    }\n\n    /**\n        @notice Getter for a producer token's UserState struct member values\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n        @return lastUpdate     uint256  Last update\n        @return lastBalance    uint256  Last balance\n        @return rewards        uint256  Rewards\n    */\n    function getUserState(ERC20 producerToken, address user)\n        external\n        view\n        returns (\n            uint256 lastUpdate,\n            uint256 lastBalance,\n            uint256 rewards\n        )\n    {\n        UserState memory userState = producerTokens[producerToken].userStates[\n            user\n        ];\n\n        return (userState.lastUpdate, userState.lastBalance, userState.rewards);\n    }\n\n    /**\n        @notice Getter for a producer token's accrued amount for a reward token\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                uint256  Reward state\n    */\n    function getRewardState(ERC20 producerToken, ERC20 rewardToken)\n        external\n        view\n        returns (uint256)\n    {\n        return producerTokens[producerToken].rewardStates[rewardToken];\n    }\n\n    /**\n        @notice Getter for a producer token's reward tokens\n        @param  producerToken  ERC20    Producer token contract\n        @return                ERC20[]  Reward token contracts\n    */\n    function getRewardTokens(ERC20 producerToken)\n        external\n        view\n        returns (ERC20[] memory)\n    {\n        return producerTokens[producerToken].rewardTokens;\n    }\n\n    /**\n        @notice Get the reward recipient for a user by producer and reward token\n        @param  user           address  User\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @return                address  Reward recipient\n    */\n    function getRewardRecipient(\n        address user,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external view returns (address) {\n        return\n            producerTokens[producerToken].rewardRecipients[user][rewardToken];\n    }\n\n    /**\n        @notice Update global rewards accrual state\n        @param  producerToken  ERC20  Rewards-producing token\n    */\n    function globalAccrue(ERC20 producerToken) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n\n        _globalAccrue(producerTokens[producerToken].globalState, producerToken);\n    }\n\n    /**\n        @notice Update user rewards accrual state\n        @param  producerToken  ERC20    Rewards-producing token\n        @param  user           address  User address\n    */\n    function userAccrue(ERC20 producerToken, address user) public {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        UserState storage u = producerTokens[producerToken].userStates[user];\n        uint256 balance = producerToken.balanceOf(user);\n\n        // Calculate the amount of rewards accrued by the user up to this call\n        uint256 rewards = u.rewards +\n            u.lastBalance *\n            (block.timestamp - u.lastUpdate);\n\n        u.lastUpdate = block.timestamp.safeCastTo32();\n        u.lastBalance = balance.safeCastTo224();\n        u.rewards = rewards;\n\n        emit UserAccrue(producerToken, user, block.timestamp, balance, rewards);\n    }\n\n    /**\n        @notice Update global accrual state\n        @param  globalState    GlobalState  Global state of the producer token\n        @param  producerToken  ERC20        Producer token contract\n    */\n    function _globalAccrue(GlobalState storage globalState, ERC20 producerToken)\n        internal\n    {\n        uint256 totalSupply = producerToken.totalSupply();\n        uint256 lastUpdate = globalState.lastUpdate;\n        uint256 lastSupply = globalState.lastSupply;\n\n        // Calculate rewards, the product of seconds elapsed and last supply\n        // Only calculate and update states when needed\n        if (block.timestamp != lastUpdate || totalSupply != lastSupply) {\n            uint256 rewards = globalState.rewards +\n                (block.timestamp - lastUpdate) *\n                lastSupply;\n\n            globalState.lastUpdate = block.timestamp.safeCastTo32();\n            globalState.lastSupply = totalSupply.safeCastTo224();\n            globalState.rewards = rewards;\n\n            emit GlobalAccrue(\n                producerToken,\n                block.timestamp,\n                totalSupply,\n                rewards\n            );\n        }\n    }\n\n    /**\n        @notice Harvest rewards\n        @return _producerTokens  ERC20[]  Producer token contracts\n        @return rewardTokens     ERC20[]  Reward token contracts\n        @return rewardAmounts    ERC20[]  Reward token amounts\n    */\n    function harvest()\n        public\n        returns (\n            ERC20[] memory _producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        (_producerTokens, rewardTokens, rewardAmounts) = producer\n            .claimRewards();\n        uint256 pLen = _producerTokens.length;\n\n        // Iterate over the producer tokens and update reward state\n        for (uint256 i; i < pLen; ++i) {\n            ERC20 p = _producerTokens[i];\n            uint256 r = rewardAmounts[i];\n\n            // Update global reward accrual state and associate with the update of reward state\n            ProducerToken storage producerState = producerTokens[p];\n\n            _globalAccrue(producerState.globalState, p);\n\n            if (r != 0) {\n                producerState.rewardStates[rewardTokens[i]] += r;\n            }\n        }\n\n        emit Harvest(_producerTokens, rewardTokens, rewardAmounts);\n    }\n\n    /**\n        @notice Claim rewards\n        @param  producerToken  ERC20    Producer token contract\n        @param  user           address  User\n    */\n    function claim(ERC20 producerToken, address user) external {\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (user == address(0)) revert ZeroAddress();\n\n        harvest();\n        userAccrue(producerToken, user);\n\n        ProducerToken storage p = producerTokens[producerToken];\n        uint256 globalRewards = p.globalState.rewards;\n        uint256 userRewards = p.userStates[user].rewards;\n\n        // Claim should be skipped and not reverted on zero global/user reward\n        if (globalRewards != 0 && userRewards != 0) {\n            ERC20[] memory rewardTokens = p.rewardTokens;\n            uint256 rLen = rewardTokens.length;\n\n            // Update global and user reward states to reflect the claim\n            p.globalState.rewards = globalRewards - userRewards;\n            p.userStates[user].rewards = 0;\n\n            emit Claim(producerToken, user);\n\n            // Transfer the proportionate reward token amounts to the recipient\n            for (uint256 i; i < rLen; ++i) {\n                ERC20 rewardToken = rewardTokens[i];\n                address rewardRecipient = p.rewardRecipients[user][rewardToken];\n                address recipient = rewardRecipient != address(0)\n                    ? rewardRecipient\n                    : user;\n                uint256 rewardState = p.rewardStates[rewardToken];\n                uint256 amount = (rewardState * userRewards) / globalRewards;\n\n                if (amount != 0) {\n                    // Update reward state (i.e. amount) to reflect reward tokens transferred out\n                    p.rewardStates[rewardToken] = rewardState - amount;\n\n                    producer.claimUserReward(\n                        address(rewardToken),\n                        amount,\n                        recipient\n                    );\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    \u26a0\ufe0f NOTABLE PRIVILEGED METHODS \u26a0\ufe0f\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Privileged method for setting the reward recipient of a contract\n        @notice This should ONLY be used to forward rewards for Pirex-GMX LP contracts\n        @notice In production, we will have a 2nd multisig which reduces risk of abuse\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n        @param  recipient      address  Rewards recipient\n    */\n    function setRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken,\n        address recipient\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n\n        producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ] = recipient;\n\n        emit SetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Privileged method for unsetting the reward recipient of a contract\n        @param  lpContract     address  Pirex-GMX LP contract\n        @param  producerToken  ERC20    Producer token contract\n        @param  rewardToken    ERC20    Reward token contract\n    */\n    function unsetRewardRecipientPrivileged(\n        address lpContract,\n        ERC20 producerToken,\n        ERC20 rewardToken\n    ) external onlyOwner {\n        if (lpContract.code.length == 0) revert NotContract();\n        if (address(producerToken) == address(0)) revert ZeroAddress();\n        if (address(rewardToken) == address(0)) revert ZeroAddress();\n\n        delete producerTokens[producerToken].rewardRecipients[lpContract][\n            rewardToken\n        ];\n\n        emit UnsetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {TransparentUpgradeableProxy} from \"openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\nimport {PirexRewardsMock} from \"src/mocks/PirexRewardsMock.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {Helper} from \"./Helper.sol\";\n\ncontract PirexRewardsTest is Helper {\n    /**\n        @notice Perform assertions for global state\n    */\n    function _assertGlobalState(\n        ERC20 producerToken,\n        uint256 expectedLastUpdate,\n        uint256 expectedLastSupply,\n        uint256 expectedRewards\n    ) internal {\n        (\n            uint256 lastUpdate,\n            uint256 lastSupply,\n            uint256 rewards\n        ) = _getGlobalState(producerToken);\n\n        assertEq(expectedLastUpdate, lastUpdate);\n        assertEq(expectedLastSupply, lastSupply);\n        assertEq(expectedRewards, rewards);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setProducer TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is not authorized\n     */\n    function testCannotSetProducerNotAuthorized() external {\n        assertEq(address(pirexGmx), address(pirexRewards.producer()));\n\n        address _producer = address(this);\n\n        vm.prank(testAccounts[0]);\n        vm.expectRevert(NOT_OWNER_ERROR);\n\n        pirexRewards.setProducer(_producer);\n    }\n\n    /**\n        @notice Test tx reversion: _producer is zero address\n     */\n    function testCannotSetProducerZeroAddress() external {\n        assertEq(address(pirexGmx), address(pirexRewards.producer()));\n\n        address invalidProducer = address(0);\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.setProducer(invalidProducer);\n    }\n\n    /**\n        @notice Test tx success: set producer\n     */\n    function testSetProducer() external {\n        assertEq(address(pirexGmx), address(pirexRewards.producer()));\n\n        address producerBefore = address(pirexRewards.producer());\n        address _producer = address(this);\n\n        assertTrue(producerBefore != _producer);\n\n        vm.expectEmit(false, false, false, true, address(pirexRewards));\n\n        emit SetProducer(_producer);\n\n        pirexRewards.setProducer(_producer);\n\n        assertEq(_producer, address(pirexRewards.producer()));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        globalAccrue TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: producerToken is zero address\n     */\n    function testCannotGlobalAccrueProducerTokenZeroAddress() external {\n        ERC20 invalidProducerToken = ERC20(address(0));\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.globalAccrue(invalidProducerToken);\n    }\n\n    /**\n        @notice Test tx success: global rewards accrual for minting\n        @param  secondsElapsed  uint32  Seconds to forward timestamp (affects rewards accrued)\n        @param  mintAmount      uint96  Amount of pxGMX or pxGLP to mint\n        @param  useGmx          bool    Whether to use pxGMX\n     */\n    function testGlobalAccrueMint(\n        uint32 secondsElapsed,\n        uint96 mintAmount,\n        bool useGmx\n    ) external {\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n        vm.assume(mintAmount != 0);\n        vm.assume(mintAmount < 100000e18);\n\n        ERC20 producerToken = useGmx\n            ? ERC20(address(pxGmx))\n            : ERC20(address(pxGlp));\n        (\n            uint256 lastUpdateBeforeMint,\n            uint256 lastSupplyBeforeMint,\n            uint256 rewardsBeforeMint\n        ) = _getGlobalState(producerToken);\n\n        assertEq(0, lastUpdateBeforeMint);\n        assertEq(0, lastSupplyBeforeMint);\n        assertEq(0, rewardsBeforeMint);\n\n        // Kick off global rewards accrual by minting first tokens\n        _mintPx(address(this), mintAmount, useGmx);\n\n        (\n            uint256 lastUpdateAfterMint,\n            uint256 lastSupplyAfterMint,\n            uint256 rewardsAfterMint\n        ) = _getGlobalState(producerToken);\n\n        // Ensure that the update timestamp and supply are tracked\n        assertEq(lastUpdateAfterMint, block.timestamp);\n        assertEq(lastSupplyAfterMint, producerToken.totalSupply());\n\n        // No rewards should have accrued since time has not elapsed\n        assertEq(0, rewardsAfterMint);\n\n        uint256 expectedTotalRewards = rewardsAfterMint;\n        uint256 expectedLastUpdate = lastUpdateAfterMint;\n        uint256 expectedTotalSupply = producerToken.totalSupply();\n\n        // Perform minting to all test accounts and assert the updated global rewards accrual\n        for (uint256 i; i < testAccounts.length; ++i) {\n            // Forward timestamp to accrue rewards for each test accounts\n            vm.warp(block.timestamp + secondsElapsed);\n\n            // Total rewards should be what has been accrued based on the supply up to the last mint\n            expectedTotalRewards += expectedTotalSupply * secondsElapsed;\n\n            // Mint to call global reward accrual hook\n            _mintPx(testAccounts[i], mintAmount, useGmx);\n\n            expectedTotalSupply = producerToken.totalSupply();\n            expectedLastUpdate += secondsElapsed;\n\n            _assertGlobalState(\n                producerToken,\n                expectedLastUpdate,\n                expectedTotalSupply,\n                expectedTotalRewards\n            );\n        }\n    }\n\n    /**\n        @notice Test tx success: global rewards accrual for burning\n        @param  secondsElapsed  uint32  Seconds to forward timestamp (affects rewards accrued)\n        @param  mintAmount      uint96  Amount of pxGLP to mint\n        @param  burnPercent     uint8   Percent of pxGLP balance to burn\n     */\n    function testGlobalAccrueBurn(\n        uint32 secondsElapsed,\n        uint96 mintAmount,\n        uint8 burnPercent\n    ) external {\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n        vm.assume(mintAmount > 1e18);\n        vm.assume(mintAmount < 100000e18);\n        vm.assume(burnPercent != 0);\n        vm.assume(burnPercent <= 100);\n\n        ERC20 producerToken = pxGlp;\n\n        // Perform minting+burning to all test accounts and assert the updated global rewards accrual\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address testAccount = testAccounts[i];\n\n            _mintPx(testAccount, mintAmount, false);\n\n            // Forward time in order to accrue rewards globally\n            vm.warp(block.timestamp + secondsElapsed);\n\n            uint256 preBurnSupply = pxGlp.totalSupply();\n            uint256 burnAmount = (pxGlp.balanceOf(testAccount) * burnPercent) /\n                100;\n\n            // Global rewards accrued up to the last token burn\n            uint256 expectedRewards = _calculateGlobalRewards(producerToken);\n\n            _burnPxGlp(testAccount, burnAmount);\n\n            (\n                uint256 lastUpdate,\n                uint256 lastSupply,\n                uint256 rewards\n            ) = _getGlobalState(producerToken);\n            uint256 postBurnSupply = pxGlp.totalSupply();\n\n            // Verify conditions for \"less reward accrual\" post-burn\n            assertTrue(postBurnSupply < preBurnSupply);\n\n            // Assert global rewards accrual post burn\n            assertEq(expectedRewards, rewards);\n            assertEq(block.timestamp, lastUpdate);\n            assertEq(postBurnSupply, lastSupply);\n\n            // Forward time in order to accrue rewards globally\n            vm.warp(block.timestamp + secondsElapsed);\n\n            // Global rewards accrued after the token burn\n            uint256 expectedRewardsAfterBurn = _calculateGlobalRewards(\n                producerToken\n            );\n\n            // Rewards accrued had supply not been reduced by burning\n            uint256 noBurnRewards = rewards + preBurnSupply * secondsElapsed;\n\n            // Delta of expected/actual rewards accrued and no-burn rewards accrued\n            uint256 expectedAndNoBurnRewardDelta = (preBurnSupply -\n                postBurnSupply) * secondsElapsed;\n\n            vm.expectEmit(true, true, false, true, address(pirexRewards));\n\n            emit GlobalAccrue(\n                producerToken,\n                block.timestamp,\n                postBurnSupply,\n                expectedRewardsAfterBurn\n            );\n\n            pirexRewards.globalAccrue(producerToken);\n\n            (, , uint256 rewardsAfterBurn) = _getGlobalState(producerToken);\n\n            assertEq(expectedRewardsAfterBurn, rewardsAfterBurn);\n            assertEq(\n                expectedRewardsAfterBurn,\n                noBurnRewards - expectedAndNoBurnRewardDelta\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        userAccrue TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: producerToken is zero address\n     */\n    function testCannotUserAccrueProducerTokenZeroAddress() external {\n        ERC20 invalidProducerToken = ERC20(address(0));\n        address user = address(this);\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.userAccrue(invalidProducerToken, user);\n    }\n\n    /**\n        @notice Test tx reversion: user is zero address\n     */\n    function testCannotUserAccrueUserZeroAddress() external {\n        ERC20 producerToken = pxGlp;\n        address invalidUser = address(0);\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.userAccrue(producerToken, invalidUser);\n    }\n\n    /**\n        @notice Test tx success: user rewards accrual\n        @param  secondsElapsed    uint32  Seconds to forward timestamp (equivalent to total rewards accrued)\n        @param  multiplier        uint8   Multiplied with fixed token amounts for randomness\n        @param  useETH            bool    Whether or not to use ETH as the source asset for minting GLP\n        @param  testAccountIndex  uint8   Index of test account\n        @param  useGmx            bool    Whether to use pxGMX\n     */\n    function testUserAccrue(\n        uint32 secondsElapsed,\n        uint8 multiplier,\n        bool useETH,\n        uint8 testAccountIndex,\n        bool useGmx\n    ) external {\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n        vm.assume(testAccountIndex < 3);\n\n        ERC20 producerToken = useGmx\n            ? ERC20(address(pxGmx))\n            : ERC20(address(pxGlp));\n\n        _depositForTestAccounts(useGmx, multiplier, useETH);\n\n        address user = testAccounts[testAccountIndex];\n        uint256 pxBalance = producerToken.balanceOf(user);\n        (\n            uint256 lastUpdateBefore,\n            uint256 lastBalanceBefore,\n            uint256 rewardsBefore\n        ) = pirexRewards.getUserState(producerToken, user);\n        uint256 warpTimestamp = block.timestamp + secondsElapsed;\n\n        // GMX minting warps timestamp (timelock) so we will test for a non-zero value\n        assertTrue(lastUpdateBefore != 0);\n\n        // The recently minted balance amount should be what is stored in state\n        assertEq(lastBalanceBefore, pxBalance);\n\n        // User should not accrue rewards until time has passed\n        assertEq(0, rewardsBefore);\n\n        vm.warp(warpTimestamp);\n\n        uint256 expectedUserRewards = _calculateUserRewards(\n            producerToken,\n            user\n        );\n\n        vm.expectEmit(true, true, false, true, address(pirexRewards));\n\n        emit UserAccrue(\n            producerToken,\n            user,\n            block.timestamp,\n            pxBalance,\n            expectedUserRewards\n        );\n\n        pirexRewards.userAccrue(producerToken, user);\n\n        (\n            uint256 lastUpdateAfter,\n            uint256 lastBalanceAfter,\n            uint256 rewardsAfter\n        ) = pirexRewards.getUserState(producerToken, user);\n\n        assertEq(warpTimestamp, lastUpdateAfter);\n        assertEq(pxBalance, lastBalanceAfter);\n        assertEq(expectedUserRewards, rewardsAfter);\n        assertTrue(rewardsAfter != 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                globalAccrue/userAccrue integration TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: minting px token and reward point accrual for multiple users\n        @param  secondsElapsed  uint32  Seconds to forward timestamp (equivalent to total rewards accrued)\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  useETH          bool    Whether or not to use ETH as the source asset for minting GLP\n        @param  accrueGlobal    bool    Whether or not to update global reward accrual state\n        @param  useGmx          bool    Whether to use pxGMX\n     */\n    function testAccrue(\n        uint32 secondsElapsed,\n        uint8 multiplier,\n        bool useETH,\n        bool accrueGlobal,\n        bool useGmx\n    ) external {\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        ERC20 producerToken = useGmx\n            ? ERC20(address(pxGmx))\n            : ERC20(address(pxGlp));\n\n        _depositForTestAccounts(useGmx, multiplier, useETH);\n\n        // Forward timestamp by X seconds which will determine the total amount of rewards accrued\n        vm.warp(block.timestamp + secondsElapsed);\n\n        uint256 timestampBeforeAccrue = block.timestamp;\n        uint256 expectedGlobalRewards = _calculateGlobalRewards(producerToken);\n\n        if (accrueGlobal) {\n            uint256 totalSupplyBeforeAccrue = producerToken.totalSupply();\n\n            vm.expectEmit(true, true, false, true, address(pirexRewards));\n\n            emit GlobalAccrue(\n                producerToken,\n                timestampBeforeAccrue,\n                totalSupplyBeforeAccrue,\n                expectedGlobalRewards\n            );\n\n            pirexRewards.globalAccrue(producerToken);\n\n            (\n                uint256 lastUpdate,\n                uint256 lastSupply,\n                uint256 rewards\n            ) = _getGlobalState(producerToken);\n\n            assertEq(lastUpdate, timestampBeforeAccrue);\n            assertEq(lastSupply, totalSupplyBeforeAccrue);\n            assertEq(rewards, expectedGlobalRewards);\n        }\n\n        // The sum of all user rewards accrued for comparison against the expected global amount\n        uint256 totalRewards;\n\n        // Iterate over test accounts and check that reward accrual amount is correct for each one\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address testAccount = testAccounts[i];\n            uint256 balanceBeforeAccrue = producerToken.balanceOf(testAccount);\n            uint256 expectedRewards = _calculateUserRewards(\n                producerToken,\n                testAccount\n            );\n\n            assertGt(expectedRewards, 0);\n\n            vm.expectEmit(true, true, false, true, address(pirexRewards));\n\n            emit UserAccrue(\n                producerToken,\n                testAccount,\n                block.timestamp,\n                balanceBeforeAccrue,\n                expectedRewards\n            );\n\n            pirexRewards.userAccrue(producerToken, testAccount);\n\n            (\n                uint256 lastUpdate,\n                uint256 lastBalance,\n                uint256 rewards\n            ) = pirexRewards.getUserState(producerToken, testAccount);\n\n            // Total rewards accrued by all users should add up to the global rewards\n            totalRewards += rewards;\n\n            assertEq(timestampBeforeAccrue, lastUpdate);\n            assertEq(balanceBeforeAccrue, lastBalance);\n            assertEq(expectedRewards, rewards);\n        }\n\n        assertEq(expectedGlobalRewards, totalRewards);\n    }\n\n    /**\n        @notice Test tx success: minting px tokens and reward point accrual for multiple users with one who accrues asynchronously\n        @param  secondsElapsed       uint32  Seconds to forward timestamp (equivalent to total rewards accrued)\n        @param  rounds               uint8   Number of rounds to fast forward time and accrue rewards\n        @param  multiplier           uint8   Multiplied with fixed token amounts for randomness\n        @param  useETH               bool    Whether or not to use ETH as the source asset for minting GLP\n        @param  delayedAccountIndex  uint8   Test account index that will delay reward accrual until the end\n        @param  useGmx               bool    Whether to use pxGMX\n     */\n    function testAccrueAsync(\n        uint32 secondsElapsed,\n        uint8 rounds,\n        uint8 multiplier,\n        bool useETH,\n        uint8 delayedAccountIndex,\n        bool useGmx\n    ) external {\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n        vm.assume(rounds != 0);\n        vm.assume(rounds < 10);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n        vm.assume(delayedAccountIndex < 3);\n\n        ERC20 producerToken = useGmx\n            ? ERC20(address(pxGmx))\n            : ERC20(address(pxGlp));\n\n        _depositForTestAccounts(useGmx, multiplier, useETH);\n\n        // Sum up the rewards accrued - after all rounds - for accounts where accrual is not delayed\n        uint256 nonDelayedTotalRewards;\n\n        uint256 tLen = testAccounts.length;\n\n        // Iterate over a number of rounds and accrue for non-delayed accounts\n        for (uint256 i; i < rounds; ++i) {\n            uint256 timestampBeforeAccrue = block.timestamp;\n\n            // Forward timestamp by X seconds which will determine the total amount of rewards accrued\n            vm.warp(timestampBeforeAccrue + secondsElapsed);\n\n            for (uint256 j; j < tLen; ++j) {\n                if (j != delayedAccountIndex) {\n                    (, , uint256 rewardsBefore) = pirexRewards.getUserState(\n                        producerToken,\n                        testAccounts[j]\n                    );\n                    uint256 expectedUserRewards = _calculateUserRewards(\n                        producerToken,\n                        testAccounts[j]\n                    );\n\n                    vm.expectEmit(\n                        true,\n                        true,\n                        false,\n                        true,\n                        address(pirexRewards)\n                    );\n\n                    emit UserAccrue(\n                        producerToken,\n                        testAccounts[j],\n                        block.timestamp,\n                        producerToken.balanceOf(testAccounts[j]),\n                        expectedUserRewards\n                    );\n\n                    pirexRewards.userAccrue(producerToken, testAccounts[j]);\n\n                    (, , uint256 rewardsAfter) = pirexRewards.getUserState(\n                        producerToken,\n                        testAccounts[j]\n                    );\n\n                    nonDelayedTotalRewards += rewardsAfter - rewardsBefore;\n\n                    assertEq(expectedUserRewards, rewardsAfter);\n                }\n            }\n        }\n\n        // Calculate the rewards which should be accrued by the delayed account\n        address delayedAccount = testAccounts[delayedAccountIndex];\n        uint256 expectedDelayedRewards = _calculateUserRewards(\n            producerToken,\n            delayedAccount\n        );\n        uint256 expectedGlobalRewards = _calculateGlobalRewards(producerToken);\n\n        vm.expectEmit(true, true, false, true, address(pirexRewards));\n\n        emit UserAccrue(\n            producerToken,\n            delayedAccount,\n            block.timestamp,\n            producerToken.balanceOf(delayedAccount),\n            expectedDelayedRewards\n        );\n\n        // Accrue rewards and check that the actual amount matches the expected\n        pirexRewards.userAccrue(producerToken, delayedAccount);\n\n        (, , uint256 rewardsAfterAccrue) = pirexRewards.getUserState(\n            producerToken,\n            delayedAccount\n        );\n\n        assertEq(expectedDelayedRewards, rewardsAfterAccrue);\n        assertEq(\n            expectedGlobalRewards,\n            nonDelayedTotalRewards + rewardsAfterAccrue\n        );\n    }\n\n    /**\n        @notice Test tx success: assert correctness of reward accruals in the case of px token transfers\n        @param  secondsElapsed   uint32  Seconds to forward timestamp (equivalent to total rewards accrued)\n        @param  multiplier       uint8   Multiplied with fixed token amounts for randomness\n        @param  transferPercent  uint8   Percent for testing partial balance transfers\n        @param  useTransfer      bool    Whether or not to use the transfer method\n        @param  useETH           bool    Whether or not to use ETH as the source asset for minting GLP\n        @param  useGmx           bool    Whether to use pxGMX\n     */\n    function testAccrueTransfer(\n        uint32 secondsElapsed,\n        uint8 multiplier,\n        uint8 transferPercent,\n        bool useTransfer,\n        bool useETH,\n        bool useGmx\n    ) external {\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n        vm.assume(transferPercent != 0);\n        vm.assume(transferPercent <= 100);\n\n        ERC20 producerToken = useGmx\n            ? ERC20(address(pxGmx))\n            : ERC20(address(pxGlp));\n\n        _depositForTestAccounts(useGmx, multiplier, useETH);\n\n        // Perform consecutive transfers in-between test accounts\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address sender = testAccounts[i];\n            // Transfer to next account, while last account would transfer to first account\n            address receiver = testAccounts[(i + 1) % testAccounts.length];\n\n            // Forward time in order to accrue rewards for sender\n            vm.warp(block.timestamp + secondsElapsed);\n\n            // Test sender reward accrual before transfer\n            uint256 transferAmount = (producerToken.balanceOf(sender) *\n                transferPercent) / 100;\n            uint256 expectedSenderRewardsAfterTransfer = _calculateUserRewards(\n                producerToken,\n                sender\n            );\n\n            // Test both of the ERC20 transfer methods for correctness of reward accrual\n            if (useTransfer) {\n                vm.prank(sender);\n\n                producerToken.transfer(receiver, transferAmount);\n            } else {\n                vm.prank(sender);\n\n                // Need to increase allowance of the caller if using transferFrom\n                producerToken.approve(address(this), transferAmount);\n\n                producerToken.transferFrom(sender, receiver, transferAmount);\n            }\n\n            (, , uint256 senderRewardsAfterTransfer) = pirexRewards\n                .getUserState(producerToken, sender);\n\n            assertEq(\n                expectedSenderRewardsAfterTransfer,\n                senderRewardsAfterTransfer\n            );\n\n            // Forward time in order to accrue rewards for receiver\n            vm.warp(block.timestamp + secondsElapsed);\n\n            // Get expected sender and receiver reward accrual states\n            uint256 expectedReceiverRewards = _calculateUserRewards(\n                producerToken,\n                receiver\n            );\n            uint256 expectedSenderRewardsAfterTransferAndWarp = _calculateUserRewards(\n                    producerToken,\n                    sender\n                );\n\n            // Accrue rewards for sender and receiver\n            vm.expectEmit(true, true, false, true, address(pirexRewards));\n\n            emit UserAccrue(\n                producerToken,\n                sender,\n                block.timestamp,\n                producerToken.balanceOf(sender),\n                expectedSenderRewardsAfterTransferAndWarp\n            );\n\n            pirexRewards.userAccrue(producerToken, sender);\n\n            vm.expectEmit(true, true, false, true, address(pirexRewards));\n\n            emit UserAccrue(\n                producerToken,\n                receiver,\n                block.timestamp,\n                producerToken.balanceOf(receiver),\n                expectedReceiverRewards\n            );\n\n            pirexRewards.userAccrue(producerToken, receiver);\n\n            // Retrieve actual user reward accrual states\n            (, , uint256 receiverRewards) = pirexRewards.getUserState(\n                producerToken,\n                receiver\n            );\n            (, , uint256 senderRewardsAfterTransferAndWarp) = pirexRewards\n                .getUserState(producerToken, sender);\n\n            assertEq(\n                expectedSenderRewardsAfterTransferAndWarp,\n                senderRewardsAfterTransferAndWarp\n            );\n            assertEq(expectedReceiverRewards, receiverRewards);\n        }\n    }\n\n    /**\n        @notice Test tx success: assert correctness of reward accruals in the case of pxGLP burns\n        @param  secondsElapsed   uint32  Seconds to forward timestamp (equivalent to total rewards accrued)\n        @param  multiplier       uint8   Multiplied with fixed token amounts for randomness\n        @param  burnPercent      uint8   Percent for testing partial balance burns\n        @param  useETH           bool    Whether or not to use ETH as the source asset for minting GLP\n     */\n    function testAccrueBurn(\n        uint32 secondsElapsed,\n        uint8 multiplier,\n        uint8 burnPercent,\n        bool useETH\n    ) external {\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n        vm.assume(burnPercent != 0);\n        vm.assume(burnPercent <= 100);\n\n        // Always deposit for pxGLP for burn tests\n        _depositForTestAccounts(false, multiplier, useETH);\n\n        // Perform burn for all test accounts and assert global rewards accrual\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address testAccount = testAccounts[i];\n\n            // Forward time in order to accrue rewards for user\n            vm.warp(block.timestamp + secondsElapsed);\n\n            uint256 preBurnBalance = pxGlp.balanceOf(testAccount);\n            uint256 burnAmount = (preBurnBalance * burnPercent) / 100;\n            uint256 expectedRewardsAfterBurn = _calculateUserRewards(\n                pxGlp,\n                testAccount\n            );\n\n            vm.prank(address(pirexGmx));\n\n            pxGlp.burn(testAccount, burnAmount);\n\n            (\n                uint256 updateAfterBurn,\n                uint256 balanceAfterBurn,\n                uint256 rewardsAfterBurn\n            ) = pirexRewards.getUserState(pxGlp, testAccount);\n            uint256 postBurnBalance = pxGlp.balanceOf(testAccount);\n\n            // Verify conditions for \"less reward accrual\" post-burn\n            assertTrue(postBurnBalance < preBurnBalance);\n\n            // User should have accrued rewards based on their balance up to the burn\n            // while still have the lastBalance state properly updated\n            assertEq(expectedRewardsAfterBurn, rewardsAfterBurn);\n            assertEq(postBurnBalance, balanceAfterBurn);\n            assertEq(block.timestamp, updateAfterBurn);\n\n            // Forward timestamp to check that user is accruing less rewards\n            vm.warp(block.timestamp + secondsElapsed);\n\n            uint256 expectedRewards = _calculateUserRewards(pxGlp, testAccount);\n\n            // Rewards accrued if user were to not burn tokens\n            uint256 noBurnRewards = rewardsAfterBurn +\n                preBurnBalance *\n                secondsElapsed;\n\n            // Delta of expected/actual rewards accrued and no-burn rewards accrued\n            uint256 expectedAndNoBurnRewardDelta = (preBurnBalance -\n                postBurnBalance) * secondsElapsed;\n\n            vm.expectEmit(true, true, false, true, address(pirexRewards));\n\n            emit UserAccrue(\n                pxGlp,\n                testAccount,\n                block.timestamp,\n                postBurnBalance,\n                expectedRewards\n            );\n\n            pirexRewards.userAccrue(pxGlp, testAccount);\n\n            (, , uint256 rewards) = pirexRewards.getUserState(\n                pxGlp,\n                testAccount\n            );\n\n            assertEq(expectedRewards, rewards);\n            assertEq(noBurnRewards - expectedAndNoBurnRewardDelta, rewards);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            harvest TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: harvest WETH and esGMX rewards produced by pxGMX and pxGLP\n        @param  secondsElapsed     uint32  Seconds to forward timestamp\n        @param  rounds             uint8   Number of rounds to fast forward time and accrue rewards\n        @param  multiplier         uint8   Multiplied with fixed token amounts for randomness\n        @param  useETH             bool    Whether or not to use ETH as the source asset for minting GLP\n        @param  additionalDeposit  uint8   Round index when another wave of deposit should be performed\n     */\n    function testHarvest(\n        uint32 secondsElapsed,\n        uint8 rounds,\n        uint8 multiplier,\n        bool useETH,\n        uint8 additionalDeposit\n    ) external {\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n        vm.assume(rounds != 0);\n        vm.assume(rounds < 10);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n        vm.assume(additionalDeposit < rounds);\n\n        // Perform initial pxGMX+pxGLP deposits for all test accounts before calling harvest\n        _depositGmxForTestAccounts(true, address(this), multiplier);\n        _depositGlpForTestAccounts(true, address(this), multiplier, useETH);\n\n        ERC20[] memory expectedProducerTokens = new ERC20[](4);\n        ERC20[] memory expectedRewardTokens = new ERC20[](4);\n        uint256[] memory expectedRewardAmounts = new uint256[](4);\n        uint256[] memory totalExpectedRewardAmounts = new uint256[](4);\n        expectedProducerTokens[0] = pxGmx;\n        expectedProducerTokens[1] = pxGlp;\n        expectedProducerTokens[2] = pxGmx;\n        expectedProducerTokens[3] = pxGlp;\n        expectedRewardTokens[0] = weth;\n        expectedRewardTokens[1] = weth;\n        expectedRewardTokens[2] = ERC20(pxGmx); // esGMX rewards are distributed as pxGMX\n        expectedRewardTokens[3] = ERC20(pxGmx);\n\n        // Perform harvest for the specified amount of rounds (with delay) then asserts\n        for (uint256 i; i < rounds; ++i) {\n            // Perform additional deposits before the next harvest at randomly chosen index\n            if (i == additionalDeposit) {\n                _depositGmxForTestAccounts(true, address(this), multiplier);\n                _depositGlpForTestAccounts(\n                    true,\n                    address(this),\n                    multiplier,\n                    useETH\n                );\n            }\n\n            // Time skip to accrue rewards for each round\n            vm.warp(block.timestamp + secondsElapsed);\n\n            uint256 expectedLastUpdate = block.timestamp;\n            uint256 expectedGlpGlobalLastSupply = pxGlp.totalSupply();\n            uint256 expectedGlpGlobalRewards = _calculateGlobalRewards(pxGlp);\n            uint256 expectedGmxGlobalLastSupply = pxGmx.totalSupply();\n            uint256 expectedGmxGlobalRewards = _calculateGlobalRewards(pxGmx);\n            expectedRewardAmounts[0] = _calculateRewards(\n                address(pirexGmx),\n                true,\n                true\n            );\n            expectedRewardAmounts[1] = _calculateRewards(\n                address(pirexGmx),\n                true,\n                false\n            );\n            expectedRewardAmounts[2] = _calculateRewards(\n                address(pirexGmx),\n                false,\n                true\n            );\n            expectedRewardAmounts[3] = _calculateRewards(\n                address(pirexGmx),\n                false,\n                false\n            );\n\n            vm.expectEmit(true, true, true, true, address(pirexRewards));\n\n            emit Harvest(\n                expectedProducerTokens,\n                expectedRewardTokens,\n                expectedRewardAmounts\n            );\n\n            (\n                ERC20[] memory producerTokens,\n                ERC20[] memory rewardTokens,\n                uint256[] memory rewardAmounts\n            ) = pirexRewards.harvest();\n\n            // Asserts separately to avoid stack issues\n            _assertGlobalState(\n                pxGlp,\n                expectedLastUpdate,\n                expectedGlpGlobalLastSupply,\n                expectedGlpGlobalRewards\n            );\n            _assertGlobalState(\n                pxGmx,\n                expectedLastUpdate,\n                expectedGmxGlobalLastSupply,\n                expectedGmxGlobalRewards\n            );\n\n            uint256 pLen = producerTokens.length;\n\n            for (uint256 j; j < pLen; ++j) {\n                ERC20 p = producerTokens[j];\n                totalExpectedRewardAmounts[j] += rewardAmounts[j];\n\n                assertEq(\n                    totalExpectedRewardAmounts[j],\n                    pirexRewards.getRewardState(p, rewardTokens[j])\n                );\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setRewardRecipient TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: producerToken is zero address\n     */\n    function testCannotSetRewardRecipientProducerTokenZeroAddress() external {\n        ERC20 invalidProducerToken = ERC20(address(0));\n        ERC20 rewardToken = weth;\n        address recipient = address(this);\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.setRewardRecipient(\n            invalidProducerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Test tx reversion: rewardToken is zero address\n     */\n    function testCannotSetRewardRecipientRewardTokenZeroAddress() external {\n        ERC20 producerToken = pxGlp;\n        ERC20 invalidRewardToken = ERC20(address(0));\n        address recipient = address(this);\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.setRewardRecipient(\n            producerToken,\n            invalidRewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Test tx reversion: recipient is zero address\n     */\n    function testCannotSetRewardRecipientRecipientZeroAddress() external {\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n        address invalidRecipient = address(0);\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.setRewardRecipient(\n            producerToken,\n            rewardToken,\n            invalidRecipient\n        );\n    }\n\n    /**\n        @notice Test tx success: set reward recipient\n     */\n    function testSetRewardRecipient() external {\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n        address recipient = address(this);\n        address oldRecipient = pirexRewards.getRewardRecipient(\n            address(this),\n            producerToken,\n            rewardToken\n        );\n\n        assertEq(address(0), oldRecipient);\n        assertTrue(recipient != oldRecipient);\n\n        vm.expectEmit(true, true, true, true, address(pirexRewards));\n\n        emit SetRewardRecipient(\n            address(this),\n            producerToken,\n            rewardToken,\n            recipient\n        );\n\n        pirexRewards.setRewardRecipient(producerToken, rewardToken, recipient);\n\n        assertEq(\n            recipient,\n            pirexRewards.getRewardRecipient(\n                address(this),\n                producerToken,\n                rewardToken\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        unsetRewardRecipient TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: producerToken is zero address\n     */\n    function testCannotUnsetRewardRecipientProducerTokenZeroAddress() external {\n        ERC20 invalidProducerToken = ERC20(address(0));\n        ERC20 rewardToken = weth;\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.unsetRewardRecipient(invalidProducerToken, rewardToken);\n    }\n\n    /**\n        @notice Test tx reversion: rewardToken is zero address\n     */\n    function testCannotUnsetRewardRecipientRewardTokenZeroAddress() external {\n        ERC20 producerToken = pxGlp;\n        ERC20 invalidRewardToken = ERC20(address(0));\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.unsetRewardRecipient(producerToken, invalidRewardToken);\n    }\n\n    /**\n        @notice Test tx success: unset reward recipient\n     */\n    function testUnsetRewardRecipient() external {\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n        address recipient = address(this);\n\n        assertEq(\n            address(0),\n            pirexRewards.getRewardRecipient(\n                address(this),\n                producerToken,\n                rewardToken\n            )\n        );\n\n        // Set reward recipient in order to unset\n        pirexRewards.setRewardRecipient(pxGlp, rewardToken, recipient);\n\n        assertEq(\n            recipient,\n            pirexRewards.getRewardRecipient(\n                address(this),\n                producerToken,\n                rewardToken\n            )\n        );\n\n        vm.expectEmit(true, true, true, true, address(pirexRewards));\n\n        emit UnsetRewardRecipient(address(this), producerToken, rewardToken);\n\n        pirexRewards.unsetRewardRecipient(producerToken, rewardToken);\n\n        assertEq(\n            address(0),\n            pirexRewards.getRewardRecipient(\n                address(this),\n                producerToken,\n                rewardToken\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        addRewardToken TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is not authorized\n     */\n    function testCannotAddRewardTokenNotAuthorized() external {\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n\n        vm.expectRevert(NOT_OWNER_ERROR);\n\n        vm.prank(testAccounts[0]);\n\n        pirexRewards.addRewardToken(producerToken, rewardToken);\n    }\n\n    /**\n        @notice Test tx reversion: producerToken is zero address\n     */\n    function testCannotAddRewardTokenProducerTokenZeroAddress() external {\n        ERC20 invalidProducerToken = ERC20(address(0));\n        ERC20 rewardToken = ERC20(address(0));\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.addRewardToken(invalidProducerToken, rewardToken);\n    }\n\n    /**\n        @notice Test tx reversion: rewardToken is zero address\n     */\n    function testCannotAddRewardTokenRewardTokenZeroAddress() external {\n        ERC20 producerToken = pxGlp;\n        ERC20 invalidRewardToken = ERC20(address(0));\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.addRewardToken(producerToken, invalidRewardToken);\n    }\n\n    /**\n        @notice Test tx reversion: rewardToken is already added before\n     */\n    function testCannotAddRewardTokenAlreadyAdded() external {\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n\n        // Add a record before attempting to add the same token again\n        pirexRewards.addRewardToken(producerToken, rewardToken);\n\n        ERC20[] memory rewardTokensBeforePush = pirexRewards.getRewardTokens(\n            producerToken\n        );\n        uint256 len = rewardTokensBeforePush.length;\n\n        assertEq(1, len);\n\n        // Attempt to add the same token\n        vm.expectRevert(PirexRewards.TokenAlreadyAdded.selector);\n\n        pirexRewards.addRewardToken(producerToken, rewardToken);\n    }\n\n    /**\n        @notice Test tx success: add reward token\n     */\n    function testAddRewardToken() external {\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n        ERC20[] memory rewardTokensBeforePush = pirexRewards.getRewardTokens(\n            producerToken\n        );\n\n        assertEq(0, rewardTokensBeforePush.length);\n\n        vm.expectEmit(true, true, false, true, address(pirexRewards));\n\n        emit AddRewardToken(producerToken, rewardToken);\n\n        pirexRewards.addRewardToken(producerToken, rewardToken);\n\n        ERC20[] memory rewardTokensAfterPush = pirexRewards.getRewardTokens(\n            producerToken\n        );\n\n        assertEq(1, rewardTokensAfterPush.length);\n        assertEq(address(rewardToken), address(rewardTokensAfterPush[0]));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        removeRewardToken TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is not authorized\n     */\n    function testCannotRemoveRewardTokenNotAuthorized() external {\n        ERC20 producerToken = pxGlp;\n        uint256 removalIndex = 0;\n\n        vm.expectRevert(NOT_OWNER_ERROR);\n\n        vm.prank(testAccounts[0]);\n\n        pirexRewards.removeRewardToken(producerToken, removalIndex);\n    }\n\n    /**\n        @notice Test tx reversion: producerToken is zero address\n     */\n    function testCannotRemoveRewardTokenProducerTokenZeroAddress() external {\n        ERC20 invalidProducerToken = ERC20(address(0));\n        uint256 removalIndex = 0;\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.removeRewardToken(invalidProducerToken, removalIndex);\n    }\n\n    /**\n        @notice Test tx reversion: invalid index (empty list)\n     */\n    function testCannotRemoveRewardTokenArithmeticError() external {\n        ERC20 producerToken = pxGlp;\n        uint256 invalidRemovalIndex = 1;\n\n        ERC20[] memory rewardTokensBeforePush = pirexRewards.getRewardTokens(\n            producerToken\n        );\n        uint256 len = rewardTokensBeforePush.length;\n\n        assertEq(0, len);\n        assertTrue(invalidRemovalIndex > len);\n\n        vm.expectRevert(stdError.arithmeticError);\n\n        pirexRewards.removeRewardToken(producerToken, invalidRemovalIndex);\n    }\n\n    /**\n        @notice Test tx reversion: invalid index (index out of bounds on non empty list)\n     */\n    function testCannotRemoveRewardTokenIndexOutOfBounds() external {\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n        uint256 invalidRemovalIndex = 2;\n\n        // Add a record then attempt to remove using larger index\n        pirexRewards.addRewardToken(producerToken, rewardToken);\n\n        ERC20[] memory rewardTokensBeforePush = pirexRewards.getRewardTokens(\n            producerToken\n        );\n        uint256 len = rewardTokensBeforePush.length;\n\n        assertEq(1, len);\n        assertTrue(invalidRemovalIndex > len);\n\n        // Attemp to remove with invalid index (>= array size)\n        vm.expectRevert(stdError.indexOOBError);\n\n        pirexRewards.removeRewardToken(producerToken, invalidRemovalIndex);\n    }\n\n    /**\n        @notice Test tx success: remove reward token at a random index\n        @param  removalIndex  uint8  Index of the element to be removed\n     */\n    function testRemoveRewardToken(uint8 removalIndex) external {\n        vm.assume(removalIndex < 2);\n\n        ERC20 producerToken = pxGlp;\n        address rewardToken1 = address(weth);\n        address rewardToken2 = address(this);\n\n        ERC20[] memory rewardTokensBeforePush = pirexRewards.getRewardTokens(\n            producerToken\n        );\n\n        assertEq(0, rewardTokensBeforePush.length);\n\n        // Add rewardTokens to array to test proper removal\n        pirexRewards.addRewardToken(producerToken, ERC20(rewardToken1));\n        pirexRewards.addRewardToken(producerToken, ERC20(rewardToken2));\n\n        ERC20[] memory rewardTokensBeforeRemoval = pirexRewards.getRewardTokens(\n            producerToken\n        );\n\n        assertEq(2, rewardTokensBeforeRemoval.length);\n        assertEq(rewardToken1, address(rewardTokensBeforeRemoval[0]));\n        assertEq(rewardToken2, address(rewardTokensBeforeRemoval[1]));\n\n        vm.expectEmit(true, false, false, true, address(pirexRewards));\n\n        emit RemoveRewardToken(producerToken, removalIndex);\n\n        pirexRewards.removeRewardToken(producerToken, removalIndex);\n\n        ERC20[] memory rewardTokensAfterRemoval = pirexRewards.getRewardTokens(\n            producerToken\n        );\n        address remainingToken = removalIndex == 0\n            ? rewardToken2\n            : rewardToken1;\n\n        assertEq(1, rewardTokensAfterRemoval.length);\n        assertEq(remainingToken, address(rewardTokensAfterRemoval[0]));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            claim TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: producerToken is zero address\n     */\n    function testCannotClaimProducerTokenZeroAddress() external {\n        ERC20 invalidProducerToken = ERC20(address(0));\n        address user = address(this);\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.claim(invalidProducerToken, user);\n    }\n\n    /**\n        @notice Test tx reversion: user is zero address\n     */\n    function testCannotClaimUserZeroAddress() external {\n        ERC20 producerToken = pxGlp;\n        address invalidUser = address(0);\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.claim(producerToken, invalidUser);\n    }\n\n    /**\n        @notice Test tx success: claim\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  useETH          bool    Whether to use ETH when minting\n        @param  forwardRewards  bool    Whether to forward rewards\n     */\n    function testClaim(\n        uint32 secondsElapsed,\n        uint8 multiplier,\n        bool useETH,\n        bool forwardRewards\n    ) external {\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        _depositGmxForTestAccounts(true, address(this), multiplier);\n        _depositGlpForTestAccounts(true, address(this), multiplier, useETH);\n\n        vm.warp(block.timestamp + secondsElapsed);\n\n        // Add reward token and harvest rewards from Pirex contract\n        pirexRewards.addRewardToken(pxGmx, weth);\n        pirexRewards.addRewardToken(pxGlp, weth);\n        pirexRewards.harvest();\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address recipient = forwardRewards\n                ? address(this)\n                : testAccounts[i];\n\n            if (forwardRewards) {\n                vm.startPrank(testAccounts[i]);\n\n                pirexRewards.setRewardRecipient(pxGmx, weth, address(this));\n                pirexRewards.setRewardRecipient(pxGlp, weth, address(this));\n\n                vm.stopPrank();\n            } else {\n                assertEq(0, weth.balanceOf(testAccounts[i]));\n            }\n\n            pirexRewards.userAccrue(pxGmx, testAccounts[i]);\n            pirexRewards.userAccrue(pxGlp, testAccounts[i]);\n\n            (, , uint256 globalRewardsBeforeClaimPxGmx) = _getGlobalState(\n                pxGmx\n            );\n            (, , uint256 globalRewardsBeforeClaimPxGlp) = _getGlobalState(\n                pxGlp\n            );\n            (, , uint256 userRewardsBeforeClaimPxGmx) = pirexRewards\n                .getUserState(pxGmx, testAccounts[i]);\n            (, , uint256 userRewardsBeforeClaimPxGlp) = pirexRewards\n                .getUserState(pxGlp, testAccounts[i]);\n\n            // Sum of reward amounts that the user/recipient is entitled to\n            uint256 expectedClaimAmount = ((pirexRewards.getRewardState(\n                pxGmx,\n                weth\n            ) * _calculateUserRewards(pxGmx, testAccounts[i])) /\n                _calculateGlobalRewards(pxGmx)) +\n                ((pirexRewards.getRewardState(pxGlp, weth) *\n                    _calculateUserRewards(pxGlp, testAccounts[i])) /\n                    _calculateGlobalRewards(pxGlp));\n\n            // Deduct previous balance if rewards are forwarded\n            uint256 recipientBalanceDeduction = forwardRewards\n                ? weth.balanceOf(recipient)\n                : 0;\n\n            vm.expectEmit(true, true, false, true, address(pirexRewards));\n\n            emit Claim(pxGmx, testAccounts[i]);\n\n            pirexRewards.claim(pxGmx, testAccounts[i]);\n\n            vm.expectEmit(true, true, false, true, address(pirexRewards));\n\n            emit Claim(pxGlp, testAccounts[i]);\n\n            pirexRewards.claim(pxGlp, testAccounts[i]);\n\n            (, , uint256 globalRewardsAfterClaimPxGmx) = _getGlobalState(pxGmx);\n            (, , uint256 globalRewardsAfterClaimPxGlp) = _getGlobalState(pxGlp);\n            (, , uint256 userRewardsAfterClaimPxGmx) = pirexRewards\n                .getUserState(pxGmx, testAccounts[i]);\n            (, , uint256 userRewardsAfterClaimPxGlp) = pirexRewards\n                .getUserState(pxGlp, testAccounts[i]);\n\n            assertEq(\n                globalRewardsBeforeClaimPxGmx - userRewardsBeforeClaimPxGmx,\n                globalRewardsAfterClaimPxGmx\n            );\n            assertEq(\n                globalRewardsBeforeClaimPxGlp - userRewardsBeforeClaimPxGlp,\n                globalRewardsAfterClaimPxGlp\n            );\n            assertEq(0, userRewardsAfterClaimPxGmx);\n            assertEq(0, userRewardsAfterClaimPxGlp);\n            assertEq(\n                expectedClaimAmount,\n                weth.balanceOf(recipient) - recipientBalanceDeduction\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    setRewardRecipientPrivileged TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is not authorized\n     */\n    function testCannotSetRewardRecipientPrivilegedNotAuthorized() external {\n        address lpContract = address(this);\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n        address recipient = address(this);\n\n        vm.expectRevert(NOT_OWNER_ERROR);\n\n        vm.prank(testAccounts[0]);\n\n        pirexRewards.setRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Test tx reversion: lpContract is not a contract\n     */\n    function testCannotSetRewardRecipientPrivilegedLpContractNotContract()\n        external\n    {\n        // Any address w/o code works (even non-EOA, contract addresses not on Arbi)\n        address invalidLpContract = testAccounts[0];\n\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n        address recipient = address(this);\n\n        vm.expectRevert(PirexRewards.NotContract.selector);\n\n        pirexRewards.setRewardRecipientPrivileged(\n            invalidLpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n\n        // Covers zero addresses\n        invalidLpContract = address(0);\n\n        vm.expectRevert(PirexRewards.NotContract.selector);\n\n        pirexRewards.setRewardRecipientPrivileged(\n            invalidLpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Test tx reversion: producerToken is zero address\n     */\n    function testCannotSetRewardRecipientPrivilegedProducerTokenZeroAddress()\n        external\n    {\n        address lpContract = address(this);\n        ERC20 invalidProducerToken = ERC20(address(0));\n        ERC20 rewardToken = weth;\n        address recipient = address(this);\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.setRewardRecipientPrivileged(\n            lpContract,\n            invalidProducerToken,\n            rewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Test tx reversion: rewardToken is zero address\n     */\n    function testCannotSetRewardRecipientPrivilegedRewardTokenZeroAddress()\n        external\n    {\n        address lpContract = address(this);\n        ERC20 producerToken = pxGlp;\n        ERC20 invalidRewardToken = ERC20(address(0));\n        address recipient = address(this);\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.setRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            invalidRewardToken,\n            recipient\n        );\n    }\n\n    /**\n        @notice Test tx reversion: recipient is zero address\n     */\n    function testCannotSetRewardRecipientPrivilegedRecipientZeroAddress()\n        external\n    {\n        address lpContract = address(this);\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n        address invalidRecipient = address(0);\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.setRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken,\n            invalidRecipient\n        );\n    }\n\n    /**\n        @notice Test tx success: set the reward recipient as the contract owner\n     */\n    function testSetRewardRecipientPrivileged() external {\n        address lpContract = address(this);\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n        address recipient = address(this);\n\n        assertEq(\n            address(0),\n            pirexRewards.getRewardRecipient(\n                lpContract,\n                producerToken,\n                rewardToken\n            )\n        );\n\n        vm.expectEmit(true, true, true, true, address(pirexRewards));\n\n        emit SetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n\n        pirexRewards.setRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n\n        assertEq(\n            recipient,\n            pirexRewards.getRewardRecipient(\n                lpContract,\n                producerToken,\n                rewardToken\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    unsetRewardRecipientPrivileged TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is not authorized\n     */\n    function testCannotUnsetRewardRecipientPrivilegedNotAuthorized() external {\n        address lpContract = address(this);\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n\n        vm.expectRevert(NOT_OWNER_ERROR);\n\n        vm.prank(testAccounts[0]);\n\n        pirexRewards.unsetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken\n        );\n    }\n\n    /**\n        @notice Test tx reversion: lpContract is not a contract\n     */\n    function testCannotUnsetRewardRecipientPrivilegedLpContractNotContract()\n        external\n    {\n        address invalidLpContract = testAccounts[0];\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n\n        vm.expectRevert(PirexRewards.NotContract.selector);\n\n        pirexRewards.unsetRewardRecipientPrivileged(\n            invalidLpContract,\n            producerToken,\n            rewardToken\n        );\n\n        invalidLpContract = address(0);\n\n        vm.expectRevert(PirexRewards.NotContract.selector);\n\n        pirexRewards.unsetRewardRecipientPrivileged(\n            invalidLpContract,\n            producerToken,\n            rewardToken\n        );\n    }\n\n    /**\n        @notice Test tx reversion: producerToken is zero address\n     */\n    function testCannotUnsetRewardRecipientPrivilegedProducerTokenZeroAddress()\n        external\n    {\n        address lpContract = address(this);\n        ERC20 invalidProducerToken = ERC20(address(0));\n        ERC20 rewardToken = weth;\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.unsetRewardRecipientPrivileged(\n            lpContract,\n            invalidProducerToken,\n            rewardToken\n        );\n    }\n\n    /**\n        @notice Test tx reversion: rewardToken is zero address\n     */\n    function testCannotUnsetRewardRecipientPrivilegedRewardTokenZeroAddress()\n        external\n    {\n        address lpContract = address(this);\n        ERC20 producerToken = pxGlp;\n        ERC20 invalidRewardToken = ERC20(address(0));\n\n        vm.expectRevert(PirexRewards.ZeroAddress.selector);\n\n        pirexRewards.unsetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            invalidRewardToken\n        );\n    }\n\n    /**\n        @notice Test tx success: unset a reward recipient as the contract owner\n     */\n    function testUnsetRewardRecipientPrivileged() external {\n        address lpContract = address(this);\n        ERC20 producerToken = pxGlp;\n        ERC20 rewardToken = weth;\n\n        // Assert initial recipient\n        assertEq(\n            address(0),\n            pirexRewards.getRewardRecipient(\n                lpContract,\n                producerToken,\n                rewardToken\n            )\n        );\n\n        // Set reward recipient in order to unset\n        address recipient = address(this);\n\n        pirexRewards.setRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken,\n            recipient\n        );\n\n        assertEq(\n            recipient,\n            pirexRewards.getRewardRecipient(\n                lpContract,\n                producerToken,\n                rewardToken\n            )\n        );\n\n        vm.expectEmit(true, true, false, true, address(pirexRewards));\n\n        emit UnsetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken\n        );\n\n        pirexRewards.unsetRewardRecipientPrivileged(\n            lpContract,\n            producerToken,\n            rewardToken\n        );\n\n        assertEq(\n            address(0),\n            pirexRewards.getRewardRecipient(\n                lpContract,\n                producerToken,\n                rewardToken\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        upgrade TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: upgrade the PirexRewards contract\n     */\n    function testUpgrade() external {\n        // Must be a payable-address due to the existence of fallback method on the base proxy\n        address payable proxyAddress = payable(address(pirexRewards));\n        TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(\n            proxyAddress\n        );\n\n        vm.prank(PROXY_ADMIN);\n\n        // Store the old (pre-upgrade) implementation address before upgrading\n        address oldImplementation = proxy.implementation();\n\n        assertEq(proxyAddress, pirexGmx.pirexRewards());\n\n        // Simulate deposit to accrue rewards in which the reward data\n        // will be used later to test upgraded implementation\n        address receiver = address(this);\n        uint256 gmxAmount = 100e18;\n\n        _mintApproveGmx(gmxAmount, address(this), address(pirexGmx), gmxAmount);\n        pirexGmx.depositGmx(gmxAmount, receiver);\n\n        vm.warp(block.timestamp + 1 days);\n\n        pirexRewards.setProducer(address(pirexGmx));\n        pirexRewards.harvest();\n\n        uint256 oldMethodResult = pirexRewards.getRewardState(\n            ERC20(address(pxGmx)),\n            weth\n        );\n\n        assertGt(oldMethodResult, 0);\n\n        // Deploy and set a new implementation to the proxy as the admin\n        PirexRewardsMock newImplementation = new PirexRewardsMock();\n\n        vm.startPrank(PROXY_ADMIN);\n\n        proxy.upgradeTo(address(newImplementation));\n\n        assertEq(address(newImplementation), proxy.implementation());\n        assertTrue(oldImplementation != proxy.implementation());\n\n        vm.stopPrank();\n\n        // Confirm that the proxy implementation has been updated\n        // by attempting to call a new method only available in the new instance\n        // and also assert the returned value\n        assertEq(\n            oldMethodResult * 2,\n            PirexRewardsMock(proxyAddress).getRewardStateMock(\n                ERC20(address(pxGmx)),\n                weth\n            )\n        );\n\n        // Confirm that the address of the proxy doesn't change, only the implementation\n        assertEq(proxyAddress, pirexGmx.pirexRewards());\n    }\n}\n\n\n",
        "CodeNames": [
            "PirexRewards.sol",
            "PirexRewards.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PirexRewards.sol",
                "Type": "Reward tokens mismanagement",
                "Description": "The owner of the PirexRewards contract can mistakenly remove one of the reward tokens hard coded in the PirexGmx contract or add reward tokens that are not supported by the PirexGmx contract, causing users to lose rewards. This can happen because the reward state of a user is updated before their rewards are claimed, and it's the reward token addresses set by the owner of the PirexRewards contract that are used to transfer rewards.",
                "Repair": "Expose hard coded reward tokens in PirexGmx contract and update global and user reward states only after ensuring that at least one reward token was distributed"
            },
            {
                "Location": "PirexRewards.claim function",
                "Type": "Loss of Accrued Rewards",
                "Description": "If the user deposits too little GMX compared to other users (or total supply of pxGMX), the user will not be able to receive rewards after calling the PirexRewards.claim function. Subsequently, their accrued rewards will be cleared out (set to zero), and they will lose their rewards.",
                "Repair": "Avoid calculating the rewards that the users are entitled based on the ratio of userRewards and globalRewards. Instead, consider implementing the RewardPerToken for users and global. If the amount is zero, revert the transaction. Alternatively, if the amount is zero, do not clear out the user's accrued reward state variable since the user did not receive anything yet."
            },
            {
                "Location": "PirexRewards.sol",
                "Type": "Incorrect reward calculation",
                "Description": "The existing reward distribution design in the PirexRewards contract will cause some users to receive fewer reward tokens than they are entitled to and cause some users to receive more rewards than they are entitled to due to the miscalculation within the existing reward distribution design.",
                "Repair": "Implement the RewardPerToken for users and global"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\n/**\n    @notice Pirex modifications\n            - Add beforeDeposit method\n            - Call beforeDeposit in deposit and mint methods\n            - Add afterWithdraw method\n            - Call afterWithdraw in redeem and withdraw methods\n            - Add afterTransfer method\n            - Call afterTransfer in transfer and transferFrom methods\n */\nabstract contract PirexERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        returns (uint256 shares)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        returns (uint256 assets)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /**\n        @notice Override transfer method to allow for pre-transfer internal hook\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transfer(address to, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        bool status = ERC20.transfer(to, amount);\n\n        afterTransfer(msg.sender, to, amount);\n\n        return status;\n    }\n\n    /**\n        @notice Override transferFrom method to allow for pre-transfer internal hook\n        @param  from    address  Account sending apxGLP\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        bool status = ERC20.transferFrom(from, to, amount);\n\n        afterTransfer(from, to, amount);\n\n        return status;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function beforeDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\n",
        "CodeNames": [
            "PirexERC4626.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PirexERC4626.sol",
                "Type": "Share price manipulation",
                "Description": "pxGMX and pxGLP tokens can be stolen from depositors in AutoPxGmx and AutoPxGlp vaults by manipulating the price of a share.",
                "Repair": "1. Require a reasonably high minimal amount of assets during first deposit. 2. Mint a fixed and high amount of shares on the first deposit. 3. Seed the pools during deployment. 4. Send first 1000 wei of shares to the zero address."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {AutoPxGmx} from \"src/vaults/AutoPxGmx.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {Helper} from \"./Helper.sol\";\n\ncontract AutoPxGmxTest is Helper {\n    event PoolFeeUpdated(uint24 _poolFee);\n    event Compounded(\n        address indexed caller,\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint256 wethAmountIn,\n        uint256 gmxAmountOut,\n        uint256 pxGmxMintAmount,\n        uint256 totalFee,\n        uint256 incentive\n    );\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n        @notice Provision reward state to test compounding of rewards\n        @param  assets            uint256    GMX/pxGMX amount to deposit in the vault\n        @param  receivers         address[]  Receivers of the apxGMX tokens\n        @param  secondsElapsed    uint256    Seconds to forward timestamp\n        @return wethRewardState   uint256    WETH reward state\n        @return pxGmxRewardState  uint256    pxGMX reward state\n        @return shareBalances     uint256[]  Receivers' apxGMX balances\n     */\n    function _provisionRewardState(\n        uint256 assets,\n        address[] memory receivers,\n        uint256 secondsElapsed\n    )\n        internal\n        returns (\n            uint256 wethRewardState,\n            uint256 pxGmxRewardState,\n            uint256[] memory shareBalances\n        )\n    {\n        uint256 rLen = receivers.length;\n        shareBalances = new uint256[](rLen);\n\n        for (uint256 i; i < rLen; ++i) {\n            address receiver = receivers[i];\n\n            _depositGmx(assets, receiver);\n\n            vm.startPrank(receiver);\n\n            pxGmx.approve(address(autoPxGmx), assets);\n\n            shareBalances[i] = autoPxGmx.deposit(assets, receiver);\n\n            vm.stopPrank();\n        }\n\n        vm.warp(block.timestamp + secondsElapsed);\n\n        pirexRewards.addRewardToken(pxGmx, weth);\n        pirexRewards.addRewardToken(pxGmx, pxGmx);\n        pirexRewards.harvest();\n\n        wethRewardState = pirexRewards.getRewardState(pxGmx, weth);\n        pxGmxRewardState = pirexRewards.getRewardState(pxGmx, pxGmx);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPoolFee TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPoolFeeUnauthorized() external {\n        uint24 fee = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setPoolFee(fee);\n    }\n\n    /**\n        @notice Test tx reversion: pool fee is zero\n     */\n    function testCannotSetPoolFeeZeroAmount() external {\n        uint24 invalidFee = 0;\n\n        vm.expectRevert(AutoPxGmx.ZeroAmount.selector);\n\n        autoPxGmx.setPoolFee(invalidFee);\n    }\n\n    /**\n        @notice Test tx success: set pool fee\n     */\n    function testSetPoolFee() external {\n        uint24 initialPoolFee = autoPxGmx.poolFee();\n        uint24 fee = 10000;\n        uint24 expectedPoolFee = fee;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit PoolFeeUpdated(expectedPoolFee);\n\n        autoPxGmx.setPoolFee(fee);\n\n        assertEq(expectedPoolFee, autoPxGmx.poolFee());\n        assertTrue(expectedPoolFee != initialPoolFee);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setWithdrawalPenalty TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetWithdrawalPenaltyUnauthorized() external {\n        // Define function arguments\n        uint256 penalty = 1;\n\n        // Define post-transition/upcoming state or effects\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        // Execute state transition\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setWithdrawalPenalty(penalty);\n    }\n\n    /**\n        @notice Test tx reversion: penalty exceeds max\n     */\n    function testCannotSetWithdrawalPenaltyExceedsMax() external {\n        uint256 invalidPenalty = autoPxGmx.MAX_WITHDRAWAL_PENALTY() + 1;\n\n        vm.expectRevert(AutoPxGmx.ExceedsMax.selector);\n\n        autoPxGmx.setWithdrawalPenalty(invalidPenalty);\n    }\n\n    /**\n        @notice Test tx success: set withdrawal penalty\n     */\n    function testSetWithdrawalPenalty() external {\n        uint256 initialWithdrawalPenalty = autoPxGmx.withdrawalPenalty();\n        uint256 penalty = 1;\n        uint256 expectedWithdrawalPenalty = penalty;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit WithdrawalPenaltyUpdated(expectedWithdrawalPenalty);\n\n        autoPxGmx.setWithdrawalPenalty(penalty);\n\n        assertEq(expectedWithdrawalPenalty, autoPxGmx.withdrawalPenalty());\n        assertTrue(expectedWithdrawalPenalty != initialWithdrawalPenalty);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPlatformFee TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPlatformFeeUnauthorized() external {\n        uint256 fee = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setPlatformFee(fee);\n    }\n\n    /**\n        @notice Test tx reversion: fee exceeds max\n     */\n    function testCannotSetPlatformFeeExceedsMax() external {\n        uint256 invalidFee = autoPxGmx.MAX_PLATFORM_FEE() + 1;\n\n        vm.expectRevert(AutoPxGmx.ExceedsMax.selector);\n\n        autoPxGmx.setPlatformFee(invalidFee);\n    }\n\n    /**\n        @notice Test tx success: set platform fee\n     */\n    function testSetPlatformFee() external {\n        uint256 initialPlatformFee = autoPxGmx.platformFee();\n        uint256 fee = 1;\n        uint256 expectedPlatformFee = fee;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit PlatformFeeUpdated(expectedPlatformFee);\n\n        autoPxGmx.setPlatformFee(fee);\n\n        assertEq(expectedPlatformFee, autoPxGmx.platformFee());\n        assertTrue(expectedPlatformFee != initialPlatformFee);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setCompoundIncentive TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetCompoundIncentiveUnauthorized() external {\n        uint256 incentive = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setCompoundIncentive(incentive);\n    }\n\n    /**\n        @notice Test tx reversion: incentive exceeds max\n     */\n    function testCannotSetCompoundIncentiveExceedsMax() external {\n        uint256 invalidIncentive = autoPxGmx.MAX_COMPOUND_INCENTIVE() + 1;\n\n        vm.expectRevert(AutoPxGmx.ExceedsMax.selector);\n\n        autoPxGmx.setCompoundIncentive(invalidIncentive);\n    }\n\n    /**\n        @notice Test tx success: set compound incentive percent\n     */\n    function testSetCompoundIncentive() external {\n        uint256 initialCompoundIncentive = autoPxGmx.compoundIncentive();\n        uint256 incentive = 1;\n        uint256 expectedCompoundIncentive = incentive;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit CompoundIncentiveUpdated(expectedCompoundIncentive);\n\n        autoPxGmx.setCompoundIncentive(incentive);\n\n        assertEq(expectedCompoundIncentive, autoPxGmx.compoundIncentive());\n        assertTrue(expectedCompoundIncentive != initialCompoundIncentive);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPlatform TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPlatformUnauthorized() external {\n        address platform = address(this);\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setPlatform(platform);\n    }\n\n    /**\n        @notice Test tx reversion: platform is zero address\n     */\n    function testCannotSetPlatformZeroAddress() external {\n        address invalidPlatform = address(0);\n\n        vm.expectRevert(AutoPxGmx.ZeroAddress.selector);\n\n        autoPxGmx.setPlatform(invalidPlatform);\n    }\n\n    /**\n        @notice Test tx success: set platform\n     */\n    function testSetPlatform() external {\n        address initialPlatform = autoPxGmx.platform();\n        address platform = address(this);\n        address expectedPlatform = platform;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit PlatformUpdated(expectedPlatform);\n\n        autoPxGmx.setPlatform(platform);\n\n        assertEq(expectedPlatform, autoPxGmx.platform());\n        assertTrue(expectedPlatform != initialPlatform);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        totalAssets TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice  Test tx success: return the total assets\n    */\n    function testTotalAssets() external {\n        uint256 initialTotalAssets = autoPxGmx.totalAssets();\n        uint256 assets = 1;\n        address receiver = address(this);\n        uint256 expectedTotalAssets = assets;\n\n        _depositGmx(assets, receiver);\n        pxGmx.approve(address(autoPxGmx), assets);\n        autoPxGmx.deposit(assets, receiver);\n\n        assertEq(expectedTotalAssets, autoPxGmx.totalAssets());\n        assertTrue(expectedTotalAssets != initialTotalAssets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        compound TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: fee is invalid param\n     */\n    function testCannotCompoundFeeInvalidParam() external {\n        uint24 invalidFee = 0;\n        uint256 amountOutMinimum = 1;\n        uint160 sqrtPriceLimitX96 = 1;\n        bool optOutIncentive = true;\n\n        vm.expectRevert(AutoPxGmx.InvalidParam.selector);\n\n        autoPxGmx.compound(\n            invalidFee,\n            amountOutMinimum,\n            sqrtPriceLimitX96,\n            optOutIncentive\n        );\n    }\n\n    /**\n        @notice Test tx reversion: amountOutMinimum is invalid param\n     */\n    function testCannotCompoundAmountOutMinimumInvalidParam() external {\n        uint24 fee = 3000;\n        uint256 invalidAmountOutMinimum = 0;\n        uint160 sqrtPriceLimitX96 = 1;\n        bool optOutIncentive = true;\n\n        vm.expectRevert(AutoPxGmx.InvalidParam.selector);\n\n        autoPxGmx.compound(\n            fee,\n            invalidAmountOutMinimum,\n            sqrtPriceLimitX96,\n            optOutIncentive\n        );\n    }\n\n    /**\n        @notice Test tx success: compound pxGMX rewards into more pxGMX\n        @param  gmxAmount       uint96  Amount of pxGMX to get from the deposit\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testCompound(uint96 gmxAmount, uint32 secondsElapsed) external {\n        vm.assume(gmxAmount > 5e17);\n        vm.assume(gmxAmount < 100000e18);\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n\n        address[] memory receivers = new address[](1);\n        receivers[0] = address(this);\n        (\n            uint256 wethRewardState,\n            uint256 pxGmxRewardState,\n\n        ) = _provisionRewardState(gmxAmount, receivers, secondsElapsed);\n        uint256 totalAssetsBeforeCompound = autoPxGmx.totalAssets();\n        uint256 shareToAssetAmountBeforeCompound = autoPxGmx.convertToAssets(\n            autoPxGmx.balanceOf(address(this))\n        );\n\n        // Confirm current state prior to primary state mutating action\n        assertEq(gmxAmount, autoPxGmx.balanceOf(address(this)));\n        assertEq(gmxAmount, totalAssetsBeforeCompound);\n        assertGt(wethRewardState, 0);\n        assertGt(pxGmxRewardState, 0);\n        assertEq(0, pxGmx.balanceOf(autoPxGmx.owner()));\n\n        vm.expectEmit(true, false, false, false, address(autoPxGmx));\n\n        emit Compounded(testAccounts[0], 3000, 1, 0, 0, 0, 0, 0, 0);\n\n        // Call as testAccounts[0] to test compound incentive transfer\n        vm.prank(testAccounts[0]);\n\n        // Input literal argument values due to callstack depth error\n        (\n            uint256 wethAmountIn,\n            uint256 gmxAmountOut,\n            uint256 pxGmxMintAmount,\n            uint256 totalFee,\n            uint256 incentive\n        ) = autoPxGmx.compound(3000, 1, 0, false);\n\n        uint256 expectedTotalFee = ((pxGmxMintAmount + pxGmxRewardState) *\n            autoPxGmx.platformFee()) / autoPxGmx.FEE_DENOMINATOR();\n        uint256 expectedCompoundIncentive = (totalFee *\n            autoPxGmx.compoundIncentive()) / autoPxGmx.FEE_DENOMINATOR();\n        uint256 expectedPlatformFee = expectedTotalFee -\n            expectedCompoundIncentive;\n        uint256 expectedTotalAssets = totalAssetsBeforeCompound +\n            pxGmxMintAmount +\n            pxGmxRewardState -\n            expectedTotalFee;\n        uint256 expectedShareToAssetAmountDifference = ((autoPxGmx.balanceOf(\n            address(this)\n        ) * expectedTotalAssets) / autoPxGmx.totalSupply()) -\n            shareToAssetAmountBeforeCompound;\n\n        assertEq(wethRewardState, wethAmountIn);\n\n        // // This will not always be the case in production (external party transfers GMX to vault)\n        // // But for this test, this assertion should hold true\n        assertEq(gmxAmountOut, pxGmxMintAmount);\n\n        assertEq(\n            gmxAmountOut + pxGmxRewardState - expectedTotalFee,\n            autoPxGmx.totalAssets() - totalAssetsBeforeCompound\n        );\n        assertEq(\n            pxGmxMintAmount + pxGmxRewardState - expectedTotalFee,\n            autoPxGmx.totalAssets() - totalAssetsBeforeCompound\n        );\n        assertGt(expectedTotalAssets, totalAssetsBeforeCompound);\n        assertEq(expectedTotalAssets, autoPxGmx.totalAssets());\n        assertEq(\n            expectedShareToAssetAmountDifference,\n            autoPxGmx.convertToAssets(autoPxGmx.balanceOf(address(this))) -\n                shareToAssetAmountBeforeCompound\n        );\n        assertEq(expectedTotalFee, totalFee);\n        assertEq(expectedCompoundIncentive, incentive);\n        assertEq(expectedPlatformFee + expectedCompoundIncentive, totalFee);\n        assertEq(expectedPlatformFee, pxGmx.balanceOf(autoPxGmx.owner()));\n        assertEq(expectedCompoundIncentive, pxGmx.balanceOf(testAccounts[0]));\n        assertLt(\n            shareToAssetAmountBeforeCompound,\n            autoPxGmx.convertToAssets(autoPxGmx.balanceOf(address(this)))\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        withdraw TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: withdraw from vault and assert the withdrawn assets\n        @param  gmxAmount       uint96  Amount of pxGMX to get from the deposit\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testWithdraw(uint96 gmxAmount, uint32 secondsElapsed) external {\n        vm.assume(gmxAmount > 5e17);\n        vm.assume(gmxAmount < 100000e18);\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n\n        address[] memory receivers = new address[](testAccounts.length);\n        uint256[] memory assetBalances = new uint256[](testAccounts.length);\n        for (uint256 i; i < testAccounts.length; ++i) {\n            receivers[i] = testAccounts[i];\n        }\n\n        (, , uint256[] memory shareBalances) = _provisionRewardState(\n            gmxAmount,\n            receivers,\n            secondsElapsed\n        );\n\n        // Store current redemption values before the first compound trigger\n        for (uint256 i; i < testAccounts.length; ++i) {\n            assetBalances[i] = autoPxGmx.previewRedeem(shareBalances[i]);\n        }\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            uint256 initialShare = autoPxGmx.balanceOf(testAccounts[i]);\n\n            assertEq(shareBalances[i], initialShare);\n\n            uint256 initialSupply = autoPxGmx.totalSupply();\n\n            // Withdraw from the vault and assert the updated assets\n            vm.prank(testAccounts[i]);\n\n            // Attempt to withdraw using previous asset snapshot before compound,\n            // which means the user might still have some leftover of the share due to the compound call\n            autoPxGmx.withdraw(\n                assetBalances[i],\n                testAccounts[i],\n                testAccounts[i]\n            );\n\n            // Withdrawal should still decrement the totalSupply and user shares\n            // Using approximation since we can't get exact amount of new GMX from the compound trigger\n            // before triggering it via the withdraw call\n            assertLe(initialSupply - initialShare, autoPxGmx.totalSupply());\n            assertGe(autoPxGmx.balanceOf(testAccounts[i]), 0);\n\n            // Since we use withdraw, the actual received pxGmx should be equal to the\n            // previously stored redeem preview balance\n            assertEq(pxGmx.balanceOf(testAccounts[i]), assetBalances[i]);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        redeem TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: redeem from vault and assert the redeemed assets\n        @param  gmxAmount       uint96  Amount of pxGMX to get from the deposit\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testRedeem(uint96 gmxAmount, uint32 secondsElapsed) external {\n        vm.assume(gmxAmount > 5e17);\n        vm.assume(gmxAmount < 100000e18);\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n\n        address[] memory receivers = new address[](testAccounts.length);\n        uint256[] memory assetBalances = new uint256[](testAccounts.length);\n        for (uint256 i; i < testAccounts.length; ++i) {\n            receivers[i] = testAccounts[i];\n        }\n\n        (, , uint256[] memory shareBalances) = _provisionRewardState(\n            gmxAmount,\n            receivers,\n            secondsElapsed\n        );\n\n        // Store current redemption values before the first compound trigger\n        for (uint256 i; i < testAccounts.length; ++i) {\n            assetBalances[i] = autoPxGmx.previewRedeem(shareBalances[i]);\n        }\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            uint256 initialShare = autoPxGmx.balanceOf(testAccounts[i]);\n\n            assertEq(shareBalances[i], initialShare);\n\n            uint256 initialSupply = autoPxGmx.totalSupply();\n\n            // Redeem from the vault and assert the updated assets\n            vm.prank(testAccounts[i]);\n\n            autoPxGmx.redeem(initialShare, testAccounts[i], testAccounts[i]);\n\n            // Redemption should still decrement the totalSupply and user shares\n            assertEq(initialSupply - initialShare, autoPxGmx.totalSupply());\n            assertEq(0, autoPxGmx.balanceOf(testAccounts[i]));\n\n            // Also check the actual redeemed pxGMX amount compared to the preview before the first compound\n            assertGt(pxGmx.balanceOf(testAccounts[i]), assetBalances[i]);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGmx TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: amount is zero\n     */\n    function testCannotDepositGmxAmountZeroAmount() external {\n        uint256 invalidAmount = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGmx.ZeroAmount.selector);\n\n        autoPxGmx.depositGmx(invalidAmount, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is the zero address\n     */\n    function testCannotDepositGmxReceiverZeroAddress() external {\n        uint256 amount = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(AutoPxGmx.ZeroAddress.selector);\n\n        autoPxGmx.depositGmx(amount, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx success: deposit GMX for apxGMX\n     */\n    function testDepositGmx() external {\n        uint256 amount = 1e18;\n        address receiver = address(this);\n        uint256 depositFee = 10000;\n\n        pirexGmx.setFee(PirexGmx.Fees.Deposit, depositFee);\n\n        (uint256 expectedAssets, ) = _computeAssetAmounts(\n            PirexGmx.Fees.Deposit,\n            amount\n        );\n        uint256 expectedShares = autoPxGmx.previewDeposit(expectedAssets);\n\n        _mintApproveGmx(amount, address(this), address(autoPxGmx), amount);\n\n        assertTrue(amount == gmx.balanceOf(address(this)));\n        assertTrue(0 == autoPxGmx.totalAssets());\n        assertTrue(0 == autoPxGmx.totalSupply());\n\n        vm.expectEmit(true, true, false, false, address(autoPxGmx));\n\n        emit Deposit(receiver, receiver, expectedAssets, expectedShares);\n\n        autoPxGmx.depositGmx(amount, receiver);\n\n        assertTrue(0 == gmx.balanceOf(address(this)));\n        assertTrue(expectedAssets == autoPxGmx.totalAssets());\n        assertTrue(expectedShares == autoPxGmx.totalSupply());\n    }\n\n    /**\n        @notice Test tx success: deposit GMX for apxGMX (fuzz)\n     */\n    function testDepositGmxFuzz(\n        uint80 amount,\n        uint24 depositFee,\n        bool separateCaller,\n        uint8 multiplier\n    ) external {\n        vm.assume(amount > 1e15);\n        vm.assume(amount < 10000e18);\n        vm.assume(depositFee != 0);\n        vm.assume(depositFee <= feeMax);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        pirexGmx.setFee(PirexGmx.Fees.Deposit, depositFee);\n\n        uint256 expectedTotalAssets;\n        uint256 expectedTotalSupply;\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address receiver = testAccounts[i];\n            address caller = separateCaller ? address(this) : receiver;\n            uint256 amountWithMultiplier = uint256(amount) *\n                uint256(multiplier);\n            (uint256 expectedAssets, ) = _computeAssetAmounts(\n                PirexGmx.Fees.Deposit,\n                amountWithMultiplier\n            );\n            uint256 expectedShares = autoPxGmx.previewDeposit(expectedAssets);\n\n            expectedTotalAssets += expectedAssets;\n            expectedTotalSupply += expectedShares;\n\n            _mintApproveGmx(\n                amountWithMultiplier,\n                caller,\n                address(autoPxGmx),\n                amountWithMultiplier\n            );\n\n            vm.prank(caller);\n            vm.expectEmit(true, true, false, false, address(autoPxGmx));\n\n            emit Deposit(caller, receiver, expectedAssets, expectedShares);\n\n            autoPxGmx.depositGmx(amountWithMultiplier, receiver);\n\n            assertTrue(expectedShares == autoPxGmx.balanceOf(receiver));\n            assertTrue(expectedTotalAssets == autoPxGmx.totalAssets());\n            assertTrue(expectedTotalSupply == autoPxGmx.totalSupply());\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\nimport {IV3SwapRouter} from \"src/interfaces/IV3SwapRouter.sol\";\n\ncontract AutoPxGmx is ReentrancyGuard, Owned, PirexERC4626 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    IV3SwapRouter public constant SWAP_ROUTER =\n        IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n\n    // Uniswap pool fee\n    uint24 public poolFee = 3000;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    ERC20 public immutable gmxBaseReward;\n    ERC20 public immutable gmx;\n\n    event PoolFeeUpdated(uint24 _poolFee);\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint256 gmxBaseRewardAmountIn,\n        uint256 gmxAmountOut,\n        uint256 pxGmxMintAmount,\n        uint256 totalFee,\n        uint256 incentive\n    );\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error AlreadySet();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _gmx            address  GMX token contract address\n        @param  _asset          address  Asset address (e.g. pxGMX)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGMX)\n        @param  _symbol         string   Asset symbol (e.g. apxGMX)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _gmx,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) Owned(msg.sender) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(SWAP_ROUTER), type(uint256).max);\n        gmx.safeApprove(_platform, type(uint256).max);\n    }\n\n    /**\n        @notice Set the Uniswap pool fee\n        @param  _poolFee  uint24  Uniswap pool fee\n     */\n    function setPoolFee(uint24 _poolFee) external onlyOwner {\n        if (_poolFee == 0) revert ZeroAmount();\n\n        poolFee = _poolFee;\n\n        emit PoolFeeUpdated(_poolFee);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGMX custodied by the AutoPxGmx contract\n        @return uint256  Amount of pxGMX custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares  uint256  Shares\n        @return uint256  Assets\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets  uint256  Assets\n        @return uint256  Shares\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGMX rewards before depositing\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(poolFee, 1, 0, true);\n    }\n\n    /**\n        @notice Compound pxGMX rewards\n        @param  fee                    uint24   Uniswap pool tier fee\n        @param  amountOutMinimum       uint256  Outbound token swap amount\n        @param  sqrtPriceLimitX96      uint160  Swap price impact limit (optional)\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  GMX base reward inbound swap amount\n        @return gmxAmountOut           uint256  GMX outbound swap amount\n        @return pxGmxMintAmount        uint256  pxGMX minted when depositing GMX\n        @return totalFee               uint256  Total platform fee\n        @return incentive              uint256  Compound incentive\n     */\n    function compound(\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 gmxAmountOut,\n            uint256 pxGmxMintAmount,\n            uint256 totalFee,\n            uint256 incentive\n        )\n    {\n        if (fee == 0) revert InvalidParam();\n        if (amountOutMinimum == 0) revert InvalidParam();\n\n        uint256 assetsBeforeClaim = asset.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n\n        // Swap entire reward balance for GMX\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            gmxAmountOut = SWAP_ROUTER.exactInputSingle(\n                IV3SwapRouter.ExactInputSingleParams({\n                    tokenIn: address(gmxBaseReward),\n                    tokenOut: address(gmx),\n                    fee: fee,\n                    recipient: address(this),\n                    amountIn: gmxBaseRewardAmountIn,\n                    amountOutMinimum: amountOutMinimum,\n                    sqrtPriceLimitX96: sqrtPriceLimitX96\n                })\n            );\n\n            // Deposit entire GMX balance for pxGMX, increasing the asset/share amount\n            (, pxGmxMintAmount, ) = PirexGmx(platform).depositGmx(\n                gmx.balanceOf(address(this)),\n                address(this)\n            );\n        }\n\n        // Only distribute fees if the amount of vault assets increased\n        if ((totalAssets() - assetsBeforeClaim) != 0) {\n            totalFee =\n                ((asset.balanceOf(address(this)) - assetsBeforeClaim) *\n                    platformFee) /\n                FEE_DENOMINATOR;\n            incentive = optOutIncentive\n                ? 0\n                : (totalFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (incentive != 0) asset.safeTransfer(msg.sender, incentive);\n\n            asset.safeTransfer(owner, totalFee - incentive);\n        }\n\n        emit Compounded(\n            msg.sender,\n            fee,\n            amountOutMinimum,\n            sqrtPriceLimitX96,\n            gmxBaseRewardAmountIn,\n            gmxAmountOut,\n            pxGmxMintAmount,\n            totalFee,\n            incentive\n        );\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        // Compound rewards and ensure they are properly accounted for prior to withdrawal calculation\n        compound(poolFee, 1, 0, true);\n\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        // Compound rewards and ensure they are properly accounted for prior to redemption calculation\n        compound(poolFee, 1, 0, true);\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /**\n        @notice Deposit GMX for apxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  apxGMX receiver\n        @return shares    uint256  Vault shares (i.e. apxGMX)\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256 shares)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Handle compounding of rewards before deposit (arguments are not used by `beforeDeposit` hook)\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // Intake sender GMX\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Convert sender GMX into pxGMX and get the post-fee amount (i.e. assets)\n        (, uint256 assets, ) = PirexGmx(platform).depositGmx(\n            amount,\n            address(this)\n        );\n\n        // NOTE: Modified `convertToShares` logic to consider assets already being in the vault\n        // and handle it by deducting the recently-deposited assets from the total\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n}\n\n\n",
        "CodeNames": [
            "AutoPxGmx.t.sol",
            "AutoPxGmx.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AutoPxGmx.sol constructor and setPlatform function",
                "Type": "Missing Approval",
                "Description": "During initialization, the AutoPxGMX vault will grant max allowance to the platform (PirexGMX) to spend its GMX tokens. However, when the owner calls the AutoPxGmx.setPlatform function to update the platform to a new address, it does not grant any allowance to the new platform address. As a result, the new platform (PirexGMX) will not be able to pull the GMX tokens from the vault. Thus, the deposit feature of the vault will break, and no one will be able to deposit.",
                "Repair": "Set the old platform approval amount to zero and approve the new platform contract address allowance to the max"
            },
            {
                "Location": "AutoPxGmx.compound function",
                "Type": "Sandwich Attack",
                "Description": "AutoPxGmx.compound allows anyone to call to compound the reward and get the incentive. However, AutoPxGmx.compound calls SWAP_ROUTER.exactInputSingle with some of the parameters provided by the caller, which allows the user to perform a sandwich attack for profit.",
                "Repair": "Consider using poolFee as the fee and using an onchain price oracle to calculate the amountOutMinimum."
            },
            {
                "Location": "AutoPxGmx.sol",
                "Type": "Hardcoded address",
                "Description": "The SWAP_ROUTER address is hardcoded in AutoPxGmx.sol, which is not compatible with Avalanche. This causes the contract to revert when calling the exactInputSingle method on the EOA address in Avalanche.",
                "Repair": "Pass the SWAP_ROUTER parameter in the constructor instead of hardcoding it"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\n/**\n    @notice Pirex modifications\n            - Add beforeDeposit method\n            - Call beforeDeposit in deposit and mint methods\n            - Add afterWithdraw method\n            - Call afterWithdraw in redeem and withdraw methods\n            - Add afterTransfer method\n            - Call afterTransfer in transfer and transferFrom methods\n */\nabstract contract PirexERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        returns (uint256 shares)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        returns (uint256 assets)\n    {\n        if (totalAssets() != 0) beforeDeposit(receiver, assets, shares);\n\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(owner, assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(owner, assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /**\n        @notice Override transfer method to allow for pre-transfer internal hook\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transfer(address to, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        bool status = ERC20.transfer(to, amount);\n\n        afterTransfer(msg.sender, to, amount);\n\n        return status;\n    }\n\n    /**\n        @notice Override transferFrom method to allow for pre-transfer internal hook\n        @param  from    address  Account sending apxGLP\n        @param  to      address  Account receiving apxGLP\n        @param  amount  uint256  Amount of apxGLP\n    */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        bool status = ERC20.transferFrom(from, to, amount);\n\n        afterTransfer(from, to, amount);\n\n        return status;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function beforeDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterWithdraw(\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterDeposit(\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {}\n\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\nimport {IV3SwapRouter} from \"src/interfaces/IV3SwapRouter.sol\";\n\ncontract AutoPxGmx is ReentrancyGuard, Owned, PirexERC4626 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    IV3SwapRouter public constant SWAP_ROUTER =\n        IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n\n    // Uniswap pool fee\n    uint24 public poolFee = 3000;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    ERC20 public immutable gmxBaseReward;\n    ERC20 public immutable gmx;\n\n    event PoolFeeUpdated(uint24 _poolFee);\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint256 gmxBaseRewardAmountIn,\n        uint256 gmxAmountOut,\n        uint256 pxGmxMintAmount,\n        uint256 totalFee,\n        uint256 incentive\n    );\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error AlreadySet();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _gmx            address  GMX token contract address\n        @param  _asset          address  Asset address (e.g. pxGMX)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGMX)\n        @param  _symbol         string   Asset symbol (e.g. apxGMX)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _gmx,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) Owned(msg.sender) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(SWAP_ROUTER), type(uint256).max);\n        gmx.safeApprove(_platform, type(uint256).max);\n    }\n\n    /**\n        @notice Set the Uniswap pool fee\n        @param  _poolFee  uint24  Uniswap pool fee\n     */\n    function setPoolFee(uint24 _poolFee) external onlyOwner {\n        if (_poolFee == 0) revert ZeroAmount();\n\n        poolFee = _poolFee;\n\n        emit PoolFeeUpdated(_poolFee);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGMX custodied by the AutoPxGmx contract\n        @return uint256  Amount of pxGMX custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares  uint256  Shares\n        @return uint256  Assets\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets  uint256  Assets\n        @return uint256  Shares\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGMX rewards before depositing\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(poolFee, 1, 0, true);\n    }\n\n    /**\n        @notice Compound pxGMX rewards\n        @param  fee                    uint24   Uniswap pool tier fee\n        @param  amountOutMinimum       uint256  Outbound token swap amount\n        @param  sqrtPriceLimitX96      uint160  Swap price impact limit (optional)\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  GMX base reward inbound swap amount\n        @return gmxAmountOut           uint256  GMX outbound swap amount\n        @return pxGmxMintAmount        uint256  pxGMX minted when depositing GMX\n        @return totalFee               uint256  Total platform fee\n        @return incentive              uint256  Compound incentive\n     */\n    function compound(\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 gmxAmountOut,\n            uint256 pxGmxMintAmount,\n            uint256 totalFee,\n            uint256 incentive\n        )\n    {\n        if (fee == 0) revert InvalidParam();\n        if (amountOutMinimum == 0) revert InvalidParam();\n\n        uint256 assetsBeforeClaim = asset.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n\n        // Swap entire reward balance for GMX\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            gmxAmountOut = SWAP_ROUTER.exactInputSingle(\n                IV3SwapRouter.ExactInputSingleParams({\n                    tokenIn: address(gmxBaseReward),\n                    tokenOut: address(gmx),\n                    fee: fee,\n                    recipient: address(this),\n                    amountIn: gmxBaseRewardAmountIn,\n                    amountOutMinimum: amountOutMinimum,\n                    sqrtPriceLimitX96: sqrtPriceLimitX96\n                })\n            );\n\n            // Deposit entire GMX balance for pxGMX, increasing the asset/share amount\n            (, pxGmxMintAmount, ) = PirexGmx(platform).depositGmx(\n                gmx.balanceOf(address(this)),\n                address(this)\n            );\n        }\n\n        // Only distribute fees if the amount of vault assets increased\n        if ((totalAssets() - assetsBeforeClaim) != 0) {\n            totalFee =\n                ((asset.balanceOf(address(this)) - assetsBeforeClaim) *\n                    platformFee) /\n                FEE_DENOMINATOR;\n            incentive = optOutIncentive\n                ? 0\n                : (totalFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (incentive != 0) asset.safeTransfer(msg.sender, incentive);\n\n            asset.safeTransfer(owner, totalFee - incentive);\n        }\n\n        emit Compounded(\n            msg.sender,\n            fee,\n            amountOutMinimum,\n            sqrtPriceLimitX96,\n            gmxBaseRewardAmountIn,\n            gmxAmountOut,\n            pxGmxMintAmount,\n            totalFee,\n            incentive\n        );\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        // Compound rewards and ensure they are properly accounted for prior to withdrawal calculation\n        compound(poolFee, 1, 0, true);\n\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        // Compound rewards and ensure they are properly accounted for prior to redemption calculation\n        compound(poolFee, 1, 0, true);\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /**\n        @notice Deposit GMX for apxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  apxGMX receiver\n        @return shares    uint256  Vault shares (i.e. apxGMX)\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256 shares)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Handle compounding of rewards before deposit (arguments are not used by `beforeDeposit` hook)\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // Intake sender GMX\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Convert sender GMX into pxGMX and get the post-fee amount (i.e. assets)\n        (, uint256 assets, ) = PirexGmx(platform).depositGmx(\n            amount,\n            address(this)\n        );\n\n        // NOTE: Modified `convertToShares` logic to consider assets already being in the vault\n        // and handle it by deducting the recently-deposited assets from the total\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {AutoPxGmx} from \"src/vaults/AutoPxGmx.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {Helper} from \"./Helper.sol\";\n\ncontract AutoPxGmxTest is Helper {\n    event PoolFeeUpdated(uint24 _poolFee);\n    event Compounded(\n        address indexed caller,\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint256 wethAmountIn,\n        uint256 gmxAmountOut,\n        uint256 pxGmxMintAmount,\n        uint256 totalFee,\n        uint256 incentive\n    );\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n        @notice Provision reward state to test compounding of rewards\n        @param  assets            uint256    GMX/pxGMX amount to deposit in the vault\n        @param  receivers         address[]  Receivers of the apxGMX tokens\n        @param  secondsElapsed    uint256    Seconds to forward timestamp\n        @return wethRewardState   uint256    WETH reward state\n        @return pxGmxRewardState  uint256    pxGMX reward state\n        @return shareBalances     uint256[]  Receivers' apxGMX balances\n     */\n    function _provisionRewardState(\n        uint256 assets,\n        address[] memory receivers,\n        uint256 secondsElapsed\n    )\n        internal\n        returns (\n            uint256 wethRewardState,\n            uint256 pxGmxRewardState,\n            uint256[] memory shareBalances\n        )\n    {\n        uint256 rLen = receivers.length;\n        shareBalances = new uint256[](rLen);\n\n        for (uint256 i; i < rLen; ++i) {\n            address receiver = receivers[i];\n\n            _depositGmx(assets, receiver);\n\n            vm.startPrank(receiver);\n\n            pxGmx.approve(address(autoPxGmx), assets);\n\n            shareBalances[i] = autoPxGmx.deposit(assets, receiver);\n\n            vm.stopPrank();\n        }\n\n        vm.warp(block.timestamp + secondsElapsed);\n\n        pirexRewards.addRewardToken(pxGmx, weth);\n        pirexRewards.addRewardToken(pxGmx, pxGmx);\n        pirexRewards.harvest();\n\n        wethRewardState = pirexRewards.getRewardState(pxGmx, weth);\n        pxGmxRewardState = pirexRewards.getRewardState(pxGmx, pxGmx);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPoolFee TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPoolFeeUnauthorized() external {\n        uint24 fee = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setPoolFee(fee);\n    }\n\n    /**\n        @notice Test tx reversion: pool fee is zero\n     */\n    function testCannotSetPoolFeeZeroAmount() external {\n        uint24 invalidFee = 0;\n\n        vm.expectRevert(AutoPxGmx.ZeroAmount.selector);\n\n        autoPxGmx.setPoolFee(invalidFee);\n    }\n\n    /**\n        @notice Test tx success: set pool fee\n     */\n    function testSetPoolFee() external {\n        uint24 initialPoolFee = autoPxGmx.poolFee();\n        uint24 fee = 10000;\n        uint24 expectedPoolFee = fee;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit PoolFeeUpdated(expectedPoolFee);\n\n        autoPxGmx.setPoolFee(fee);\n\n        assertEq(expectedPoolFee, autoPxGmx.poolFee());\n        assertTrue(expectedPoolFee != initialPoolFee);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setWithdrawalPenalty TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetWithdrawalPenaltyUnauthorized() external {\n        // Define function arguments\n        uint256 penalty = 1;\n\n        // Define post-transition/upcoming state or effects\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        // Execute state transition\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setWithdrawalPenalty(penalty);\n    }\n\n    /**\n        @notice Test tx reversion: penalty exceeds max\n     */\n    function testCannotSetWithdrawalPenaltyExceedsMax() external {\n        uint256 invalidPenalty = autoPxGmx.MAX_WITHDRAWAL_PENALTY() + 1;\n\n        vm.expectRevert(AutoPxGmx.ExceedsMax.selector);\n\n        autoPxGmx.setWithdrawalPenalty(invalidPenalty);\n    }\n\n    /**\n        @notice Test tx success: set withdrawal penalty\n     */\n    function testSetWithdrawalPenalty() external {\n        uint256 initialWithdrawalPenalty = autoPxGmx.withdrawalPenalty();\n        uint256 penalty = 1;\n        uint256 expectedWithdrawalPenalty = penalty;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit WithdrawalPenaltyUpdated(expectedWithdrawalPenalty);\n\n        autoPxGmx.setWithdrawalPenalty(penalty);\n\n        assertEq(expectedWithdrawalPenalty, autoPxGmx.withdrawalPenalty());\n        assertTrue(expectedWithdrawalPenalty != initialWithdrawalPenalty);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPlatformFee TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPlatformFeeUnauthorized() external {\n        uint256 fee = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setPlatformFee(fee);\n    }\n\n    /**\n        @notice Test tx reversion: fee exceeds max\n     */\n    function testCannotSetPlatformFeeExceedsMax() external {\n        uint256 invalidFee = autoPxGmx.MAX_PLATFORM_FEE() + 1;\n\n        vm.expectRevert(AutoPxGmx.ExceedsMax.selector);\n\n        autoPxGmx.setPlatformFee(invalidFee);\n    }\n\n    /**\n        @notice Test tx success: set platform fee\n     */\n    function testSetPlatformFee() external {\n        uint256 initialPlatformFee = autoPxGmx.platformFee();\n        uint256 fee = 1;\n        uint256 expectedPlatformFee = fee;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit PlatformFeeUpdated(expectedPlatformFee);\n\n        autoPxGmx.setPlatformFee(fee);\n\n        assertEq(expectedPlatformFee, autoPxGmx.platformFee());\n        assertTrue(expectedPlatformFee != initialPlatformFee);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setCompoundIncentive TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetCompoundIncentiveUnauthorized() external {\n        uint256 incentive = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setCompoundIncentive(incentive);\n    }\n\n    /**\n        @notice Test tx reversion: incentive exceeds max\n     */\n    function testCannotSetCompoundIncentiveExceedsMax() external {\n        uint256 invalidIncentive = autoPxGmx.MAX_COMPOUND_INCENTIVE() + 1;\n\n        vm.expectRevert(AutoPxGmx.ExceedsMax.selector);\n\n        autoPxGmx.setCompoundIncentive(invalidIncentive);\n    }\n\n    /**\n        @notice Test tx success: set compound incentive percent\n     */\n    function testSetCompoundIncentive() external {\n        uint256 initialCompoundIncentive = autoPxGmx.compoundIncentive();\n        uint256 incentive = 1;\n        uint256 expectedCompoundIncentive = incentive;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit CompoundIncentiveUpdated(expectedCompoundIncentive);\n\n        autoPxGmx.setCompoundIncentive(incentive);\n\n        assertEq(expectedCompoundIncentive, autoPxGmx.compoundIncentive());\n        assertTrue(expectedCompoundIncentive != initialCompoundIncentive);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPlatform TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPlatformUnauthorized() external {\n        address platform = address(this);\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setPlatform(platform);\n    }\n\n    /**\n        @notice Test tx reversion: platform is zero address\n     */\n    function testCannotSetPlatformZeroAddress() external {\n        address invalidPlatform = address(0);\n\n        vm.expectRevert(AutoPxGmx.ZeroAddress.selector);\n\n        autoPxGmx.setPlatform(invalidPlatform);\n    }\n\n    /**\n        @notice Test tx success: set platform\n     */\n    function testSetPlatform() external {\n        address initialPlatform = autoPxGmx.platform();\n        address platform = address(this);\n        address expectedPlatform = platform;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit PlatformUpdated(expectedPlatform);\n\n        autoPxGmx.setPlatform(platform);\n\n        assertEq(expectedPlatform, autoPxGmx.platform());\n        assertTrue(expectedPlatform != initialPlatform);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        totalAssets TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice  Test tx success: return the total assets\n    */\n    function testTotalAssets() external {\n        uint256 initialTotalAssets = autoPxGmx.totalAssets();\n        uint256 assets = 1;\n        address receiver = address(this);\n        uint256 expectedTotalAssets = assets;\n\n        _depositGmx(assets, receiver);\n        pxGmx.approve(address(autoPxGmx), assets);\n        autoPxGmx.deposit(assets, receiver);\n\n        assertEq(expectedTotalAssets, autoPxGmx.totalAssets());\n        assertTrue(expectedTotalAssets != initialTotalAssets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        compound TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: fee is invalid param\n     */\n    function testCannotCompoundFeeInvalidParam() external {\n        uint24 invalidFee = 0;\n        uint256 amountOutMinimum = 1;\n        uint160 sqrtPriceLimitX96 = 1;\n        bool optOutIncentive = true;\n\n        vm.expectRevert(AutoPxGmx.InvalidParam.selector);\n\n        autoPxGmx.compound(\n            invalidFee,\n            amountOutMinimum,\n            sqrtPriceLimitX96,\n            optOutIncentive\n        );\n    }\n\n    /**\n        @notice Test tx reversion: amountOutMinimum is invalid param\n     */\n    function testCannotCompoundAmountOutMinimumInvalidParam() external {\n        uint24 fee = 3000;\n        uint256 invalidAmountOutMinimum = 0;\n        uint160 sqrtPriceLimitX96 = 1;\n        bool optOutIncentive = true;\n\n        vm.expectRevert(AutoPxGmx.InvalidParam.selector);\n\n        autoPxGmx.compound(\n            fee,\n            invalidAmountOutMinimum,\n            sqrtPriceLimitX96,\n            optOutIncentive\n        );\n    }\n\n    /**\n        @notice Test tx success: compound pxGMX rewards into more pxGMX\n        @param  gmxAmount       uint96  Amount of pxGMX to get from the deposit\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testCompound(uint96 gmxAmount, uint32 secondsElapsed) external {\n        vm.assume(gmxAmount > 5e17);\n        vm.assume(gmxAmount < 100000e18);\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n\n        address[] memory receivers = new address[](1);\n        receivers[0] = address(this);\n        (\n            uint256 wethRewardState,\n            uint256 pxGmxRewardState,\n\n        ) = _provisionRewardState(gmxAmount, receivers, secondsElapsed);\n        uint256 totalAssetsBeforeCompound = autoPxGmx.totalAssets();\n        uint256 shareToAssetAmountBeforeCompound = autoPxGmx.convertToAssets(\n            autoPxGmx.balanceOf(address(this))\n        );\n\n        // Confirm current state prior to primary state mutating action\n        assertEq(gmxAmount, autoPxGmx.balanceOf(address(this)));\n        assertEq(gmxAmount, totalAssetsBeforeCompound);\n        assertGt(wethRewardState, 0);\n        assertGt(pxGmxRewardState, 0);\n        assertEq(0, pxGmx.balanceOf(autoPxGmx.owner()));\n\n        vm.expectEmit(true, false, false, false, address(autoPxGmx));\n\n        emit Compounded(testAccounts[0], 3000, 1, 0, 0, 0, 0, 0, 0);\n\n        // Call as testAccounts[0] to test compound incentive transfer\n        vm.prank(testAccounts[0]);\n\n        // Input literal argument values due to callstack depth error\n        (\n            uint256 wethAmountIn,\n            uint256 gmxAmountOut,\n            uint256 pxGmxMintAmount,\n            uint256 totalFee,\n            uint256 incentive\n        ) = autoPxGmx.compound(3000, 1, 0, false);\n\n        uint256 expectedTotalFee = ((pxGmxMintAmount + pxGmxRewardState) *\n            autoPxGmx.platformFee()) / autoPxGmx.FEE_DENOMINATOR();\n        uint256 expectedCompoundIncentive = (totalFee *\n            autoPxGmx.compoundIncentive()) / autoPxGmx.FEE_DENOMINATOR();\n        uint256 expectedPlatformFee = expectedTotalFee -\n            expectedCompoundIncentive;\n        uint256 expectedTotalAssets = totalAssetsBeforeCompound +\n            pxGmxMintAmount +\n            pxGmxRewardState -\n            expectedTotalFee;\n        uint256 expectedShareToAssetAmountDifference = ((autoPxGmx.balanceOf(\n            address(this)\n        ) * expectedTotalAssets) / autoPxGmx.totalSupply()) -\n            shareToAssetAmountBeforeCompound;\n\n        assertEq(wethRewardState, wethAmountIn);\n\n        // // This will not always be the case in production (external party transfers GMX to vault)\n        // // But for this test, this assertion should hold true\n        assertEq(gmxAmountOut, pxGmxMintAmount);\n\n        assertEq(\n            gmxAmountOut + pxGmxRewardState - expectedTotalFee,\n            autoPxGmx.totalAssets() - totalAssetsBeforeCompound\n        );\n        assertEq(\n            pxGmxMintAmount + pxGmxRewardState - expectedTotalFee,\n            autoPxGmx.totalAssets() - totalAssetsBeforeCompound\n        );\n        assertGt(expectedTotalAssets, totalAssetsBeforeCompound);\n        assertEq(expectedTotalAssets, autoPxGmx.totalAssets());\n        assertEq(\n            expectedShareToAssetAmountDifference,\n            autoPxGmx.convertToAssets(autoPxGmx.balanceOf(address(this))) -\n                shareToAssetAmountBeforeCompound\n        );\n        assertEq(expectedTotalFee, totalFee);\n        assertEq(expectedCompoundIncentive, incentive);\n        assertEq(expectedPlatformFee + expectedCompoundIncentive, totalFee);\n        assertEq(expectedPlatformFee, pxGmx.balanceOf(autoPxGmx.owner()));\n        assertEq(expectedCompoundIncentive, pxGmx.balanceOf(testAccounts[0]));\n        assertLt(\n            shareToAssetAmountBeforeCompound,\n            autoPxGmx.convertToAssets(autoPxGmx.balanceOf(address(this)))\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        withdraw TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: withdraw from vault and assert the withdrawn assets\n        @param  gmxAmount       uint96  Amount of pxGMX to get from the deposit\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testWithdraw(uint96 gmxAmount, uint32 secondsElapsed) external {\n        vm.assume(gmxAmount > 5e17);\n        vm.assume(gmxAmount < 100000e18);\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n\n        address[] memory receivers = new address[](testAccounts.length);\n        uint256[] memory assetBalances = new uint256[](testAccounts.length);\n        for (uint256 i; i < testAccounts.length; ++i) {\n            receivers[i] = testAccounts[i];\n        }\n\n        (, , uint256[] memory shareBalances) = _provisionRewardState(\n            gmxAmount,\n            receivers,\n            secondsElapsed\n        );\n\n        // Store current redemption values before the first compound trigger\n        for (uint256 i; i < testAccounts.length; ++i) {\n            assetBalances[i] = autoPxGmx.previewRedeem(shareBalances[i]);\n        }\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            uint256 initialShare = autoPxGmx.balanceOf(testAccounts[i]);\n\n            assertEq(shareBalances[i], initialShare);\n\n            uint256 initialSupply = autoPxGmx.totalSupply();\n\n            // Withdraw from the vault and assert the updated assets\n            vm.prank(testAccounts[i]);\n\n            // Attempt to withdraw using previous asset snapshot before compound,\n            // which means the user might still have some leftover of the share due to the compound call\n            autoPxGmx.withdraw(\n                assetBalances[i],\n                testAccounts[i],\n                testAccounts[i]\n            );\n\n            // Withdrawal should still decrement the totalSupply and user shares\n            // Using approximation since we can't get exact amount of new GMX from the compound trigger\n            // before triggering it via the withdraw call\n            assertLe(initialSupply - initialShare, autoPxGmx.totalSupply());\n            assertGe(autoPxGmx.balanceOf(testAccounts[i]), 0);\n\n            // Since we use withdraw, the actual received pxGmx should be equal to the\n            // previously stored redeem preview balance\n            assertEq(pxGmx.balanceOf(testAccounts[i]), assetBalances[i]);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        redeem TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: redeem from vault and assert the redeemed assets\n        @param  gmxAmount       uint96  Amount of pxGMX to get from the deposit\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testRedeem(uint96 gmxAmount, uint32 secondsElapsed) external {\n        vm.assume(gmxAmount > 5e17);\n        vm.assume(gmxAmount < 100000e18);\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n\n        address[] memory receivers = new address[](testAccounts.length);\n        uint256[] memory assetBalances = new uint256[](testAccounts.length);\n        for (uint256 i; i < testAccounts.length; ++i) {\n            receivers[i] = testAccounts[i];\n        }\n\n        (, , uint256[] memory shareBalances) = _provisionRewardState(\n            gmxAmount,\n            receivers,\n            secondsElapsed\n        );\n\n        // Store current redemption values before the first compound trigger\n        for (uint256 i; i < testAccounts.length; ++i) {\n            assetBalances[i] = autoPxGmx.previewRedeem(shareBalances[i]);\n        }\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            uint256 initialShare = autoPxGmx.balanceOf(testAccounts[i]);\n\n            assertEq(shareBalances[i], initialShare);\n\n            uint256 initialSupply = autoPxGmx.totalSupply();\n\n            // Redeem from the vault and assert the updated assets\n            vm.prank(testAccounts[i]);\n\n            autoPxGmx.redeem(initialShare, testAccounts[i], testAccounts[i]);\n\n            // Redemption should still decrement the totalSupply and user shares\n            assertEq(initialSupply - initialShare, autoPxGmx.totalSupply());\n            assertEq(0, autoPxGmx.balanceOf(testAccounts[i]));\n\n            // Also check the actual redeemed pxGMX amount compared to the preview before the first compound\n            assertGt(pxGmx.balanceOf(testAccounts[i]), assetBalances[i]);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGmx TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: amount is zero\n     */\n    function testCannotDepositGmxAmountZeroAmount() external {\n        uint256 invalidAmount = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGmx.ZeroAmount.selector);\n\n        autoPxGmx.depositGmx(invalidAmount, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is the zero address\n     */\n    function testCannotDepositGmxReceiverZeroAddress() external {\n        uint256 amount = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(AutoPxGmx.ZeroAddress.selector);\n\n        autoPxGmx.depositGmx(amount, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx success: deposit GMX for apxGMX\n     */\n    function testDepositGmx() external {\n        uint256 amount = 1e18;\n        address receiver = address(this);\n        uint256 depositFee = 10000;\n\n        pirexGmx.setFee(PirexGmx.Fees.Deposit, depositFee);\n\n        (uint256 expectedAssets, ) = _computeAssetAmounts(\n            PirexGmx.Fees.Deposit,\n            amount\n        );\n        uint256 expectedShares = autoPxGmx.previewDeposit(expectedAssets);\n\n        _mintApproveGmx(amount, address(this), address(autoPxGmx), amount);\n\n        assertTrue(amount == gmx.balanceOf(address(this)));\n        assertTrue(0 == autoPxGmx.totalAssets());\n        assertTrue(0 == autoPxGmx.totalSupply());\n\n        vm.expectEmit(true, true, false, false, address(autoPxGmx));\n\n        emit Deposit(receiver, receiver, expectedAssets, expectedShares);\n\n        autoPxGmx.depositGmx(amount, receiver);\n\n        assertTrue(0 == gmx.balanceOf(address(this)));\n        assertTrue(expectedAssets == autoPxGmx.totalAssets());\n        assertTrue(expectedShares == autoPxGmx.totalSupply());\n    }\n\n    /**\n        @notice Test tx success: deposit GMX for apxGMX (fuzz)\n     */\n    function testDepositGmxFuzz(\n        uint80 amount,\n        uint24 depositFee,\n        bool separateCaller,\n        uint8 multiplier\n    ) external {\n        vm.assume(amount > 1e15);\n        vm.assume(amount < 10000e18);\n        vm.assume(depositFee != 0);\n        vm.assume(depositFee <= feeMax);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        pirexGmx.setFee(PirexGmx.Fees.Deposit, depositFee);\n\n        uint256 expectedTotalAssets;\n        uint256 expectedTotalSupply;\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address receiver = testAccounts[i];\n            address caller = separateCaller ? address(this) : receiver;\n            uint256 amountWithMultiplier = uint256(amount) *\n                uint256(multiplier);\n            (uint256 expectedAssets, ) = _computeAssetAmounts(\n                PirexGmx.Fees.Deposit,\n                amountWithMultiplier\n            );\n            uint256 expectedShares = autoPxGmx.previewDeposit(expectedAssets);\n\n            expectedTotalAssets += expectedAssets;\n            expectedTotalSupply += expectedShares;\n\n            _mintApproveGmx(\n                amountWithMultiplier,\n                caller,\n                address(autoPxGmx),\n                amountWithMultiplier\n            );\n\n            vm.prank(caller);\n            vm.expectEmit(true, true, false, false, address(autoPxGmx));\n\n            emit Deposit(caller, receiver, expectedAssets, expectedShares);\n\n            autoPxGmx.depositGmx(amountWithMultiplier, receiver);\n\n            assertTrue(expectedShares == autoPxGmx.balanceOf(receiver));\n            assertTrue(expectedTotalAssets == autoPxGmx.totalAssets());\n            assertTrue(expectedTotalSupply == autoPxGmx.totalSupply());\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "PirexERC4626.sol",
            "AutoPxGmx.sol",
            "AutoPxGmx.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PirexERC4626.convertToShares and AutoPxGmx.previewWithdraw functions",
                "Type": "Arithmetic",
                "Description": "Malicious users can withdraw the assets from the vault for free, effectively allowing them to drain the assets of the vault. Ensure that at least 1 share is burned when the users withdraw their assets.",
                "Repair": "Update the previewWithdraw function to round up instead of round down when computing the number of shares to be burned."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Pausable} from \"openzeppelin-contracts/contracts/security/Pausable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PxERC20} from \"src/PxERC20.sol\";\nimport {PirexFees} from \"src/PirexFees.sol\";\nimport {DelegateRegistry} from \"src/external/DelegateRegistry.sol\";\nimport {IRewardRouterV2} from \"src/interfaces/IRewardRouterV2.sol\";\nimport {RewardTracker} from \"src/external/RewardTracker.sol\";\nimport {IStakedGlp} from \"src/interfaces/IStakedGlp.sol\";\nimport {IVault} from \"src/interfaces/IVault.sol\";\nimport {IRewardDistributor} from \"src/interfaces/IRewardDistributor.sol\";\nimport {IPirexRewards} from \"src/interfaces/IPirexRewards.sol\";\nimport {IGlpManager} from \"src/interfaces/IGlpManager.sol\";\n\ncontract PirexGmx is ReentrancyGuard, Owned, Pausable {\n    using SafeTransferLib for ERC20;\n\n    // Configurable fees\n    enum Fees {\n        Deposit,\n        Redemption,\n        Reward\n    }\n\n    // Configurable external contracts\n    enum Contracts {\n        PirexFees,\n        RewardRouterV2,\n        RewardTrackerGmx,\n        RewardTrackerGlp,\n        FeeStakedGlp,\n        StakedGmx,\n        StakedGlp,\n        GmxVault,\n        GlpManager\n    }\n\n    // Fee denominator\n    uint256 public constant FEE_DENOMINATOR = 1_000_000;\n\n    // Fee maximum (i.e. 20%)\n    uint256 public constant FEE_MAX = 200_000;\n\n    // External token contracts\n    ERC20 public immutable gmxBaseReward; // e.g. WETH (Ethereum)\n    ERC20 public immutable gmx;\n    ERC20 public immutable esGmx;\n\n    // Pirex token contract(s) which are unlikely to change\n    PxERC20 public immutable pxGmx;\n    PxERC20 public immutable pxGlp;\n\n    // Pirex fee repository and distribution contract\n    PirexFees public pirexFees;\n\n    // Pirex reward module contract\n    address public immutable pirexRewards;\n\n    // Snapshot vote delegation contract\n    DelegateRegistry public immutable delegateRegistry;\n\n    // GMX contracts\n    IRewardRouterV2 public gmxRewardRouterV2;\n    RewardTracker public rewardTrackerGmx;\n    RewardTracker public rewardTrackerGlp;\n    RewardTracker public feeStakedGlp;\n    RewardTracker public stakedGmx;\n    IStakedGlp public stakedGlp;\n    address public glpManager;\n    IVault public gmxVault;\n\n    // Migration related address\n    address public migratedTo;\n\n    // Snapshot space\n    bytes32 public delegationSpace = bytes32(\"gmx.eth\");\n\n    // Fees (e.g. 5000 / 1000000 = 0.5%)\n    mapping(Fees => uint256) public fees;\n\n    event ConfigureGmxState(\n        address indexed caller,\n        RewardTracker rewardTrackerGmx,\n        RewardTracker rewardTrackerGlp,\n        RewardTracker feeStakedGlp,\n        RewardTracker stakedGmx,\n        address glpManager,\n        IVault gmxVault\n    );\n    event SetFee(Fees indexed f, uint256 fee);\n    event SetContract(Contracts indexed c, address contractAddress);\n    event DepositGmx(\n        address indexed caller,\n        address indexed receiver,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event DepositGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        uint256 deposited,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event RedeemGlp(\n        address indexed caller,\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 minOut,\n        uint256 redemption,\n        uint256 postFeeAmount,\n        uint256 feeAmount\n    );\n    event ClaimRewards(\n        uint256 baseRewards,\n        uint256 esGmxRewards,\n        uint256 gmxBaseRewards,\n        uint256 glpBaseRewards,\n        uint256 gmxEsGmxRewards,\n        uint256 glpEsGmxRewards\n    );\n    event ClaimUserReward(\n        address indexed receiver,\n        address indexed token,\n        uint256 amount,\n        uint256 rewardAmount,\n        uint256 feeAmount\n    );\n    event InitiateMigration(address newContract);\n    event CompleteMigration(address oldContract);\n    event SetDelegationSpace(string delegationSpace, bool shouldClear);\n    event SetVoteDelegate(address voteDelegate);\n    event ClearVoteDelegate();\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidToken(address token);\n    error NotPirexRewards();\n    error InvalidFee();\n    error EmptyString();\n    error NotMigratedTo();\n    error PendingMigration();\n\n    /**\n        @param  _pxGmx              address  PxGmx contract address\n        @param  _pxGlp              address  PxGlp contract address\n        @param  _pirexFees          address  PirexFees contract address\n        @param  _pirexRewards       address  PirexRewards contract address\n        @param  _delegateRegistry   address  Delegation registry contract address\n        @param  _gmxBaseReward      address  GMX base reward token contract address\n        @param  _gmx                address  GMX token contract address\n        @param  _esGmx              address  esGMX token contract address\n        @param  _gmxRewardRouterV2  address  GMX Reward Router contract address\n        @param  _stakedGlp          address  Staked GLP token contract address\n    */\n    constructor(\n        address _pxGmx,\n        address _pxGlp,\n        address _pirexFees,\n        address _pirexRewards,\n        address _delegateRegistry,\n        address _gmxBaseReward,\n        address _gmx,\n        address _esGmx,\n        address _gmxRewardRouterV2,\n        address _stakedGlp\n    ) Owned(msg.sender) {\n        // Start the contract paused, to ensure contract set is properly configured\n        _pause();\n\n        if (_pxGmx == address(0)) revert ZeroAddress();\n        if (_pxGlp == address(0)) revert ZeroAddress();\n        if (_pirexFees == address(0)) revert ZeroAddress();\n        if (_pirexRewards == address(0)) revert ZeroAddress();\n        if (_delegateRegistry == address(0)) revert ZeroAddress();\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_esGmx == address(0)) revert ZeroAddress();\n        if (_gmxRewardRouterV2 == address(0)) revert ZeroAddress();\n        if (_stakedGlp == address(0)) revert ZeroAddress();\n\n        pxGmx = PxERC20(_pxGmx);\n        pxGlp = PxERC20(_pxGlp);\n        pirexFees = PirexFees(_pirexFees);\n        pirexRewards = _pirexRewards;\n        delegateRegistry = DelegateRegistry(_delegateRegistry);\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        esGmx = ERC20(_esGmx);\n        gmxRewardRouterV2 = IRewardRouterV2(_gmxRewardRouterV2);\n        stakedGlp = IStakedGlp(_stakedGlp);\n    }\n\n    modifier onlyPirexRewards() {\n        if (msg.sender != pirexRewards) revert NotPirexRewards();\n        _;\n    }\n\n    /**\n        @notice Compute post-fee asset and fee amounts from a fee type and total assets\n        @param  f              enum     Fee\n        @param  assets         uint256  GMX/GLP/WETH asset amount\n        @return postFeeAmount  uint256  Post-fee asset amount (for mint/burn/claim/etc.)\n        @return feeAmount      uint256  Fee amount\n     */\n    function _computeAssetAmounts(Fees f, uint256 assets)\n        internal\n        view\n        returns (uint256 postFeeAmount, uint256 feeAmount)\n    {\n        feeAmount = (assets * fees[f]) / FEE_DENOMINATOR;\n        postFeeAmount = assets - feeAmount;\n\n        assert(feeAmount + postFeeAmount == assets);\n    }\n\n    /**\n        @notice Calculate the base (e.g. WETH) or esGMX rewards for either GMX or GLP\n        @param  isBaseReward  bool     Whether to calculate base or esGMX rewards\n        @param  useGmx        bool     Whether the calculation should be for GMX\n        @return               uint256  Amount of WETH/esGMX rewards\n     */\n    function _calculateRewards(bool isBaseReward, bool useGmx)\n        internal\n        view\n        returns (uint256)\n    {\n        RewardTracker r;\n\n        if (isBaseReward) {\n            r = useGmx ? rewardTrackerGmx : rewardTrackerGlp;\n        } else {\n            r = useGmx ? stakedGmx : feeStakedGlp;\n        }\n\n        address distributor = r.distributor();\n        uint256 pendingRewards = IRewardDistributor(distributor)\n            .pendingRewards();\n        uint256 distributorBalance = (isBaseReward ? gmxBaseReward : esGmx)\n            .balanceOf(distributor);\n        uint256 blockReward = pendingRewards > distributorBalance\n            ? distributorBalance\n            : pendingRewards;\n        uint256 precision = r.PRECISION();\n        uint256 cumulativeRewardPerToken = r.cumulativeRewardPerToken() +\n            ((blockReward * precision) / r.totalSupply());\n\n        if (cumulativeRewardPerToken == 0) return 0;\n\n        return\n            r.claimableReward(address(this)) +\n            ((r.stakedAmounts(address(this)) *\n                (cumulativeRewardPerToken -\n                    r.previousCumulatedRewardPerToken(address(this)))) /\n                precision);\n    }\n\n    /**\n        @notice Configure GMX contract state\n     */\n    function configureGmxState() external onlyOwner whenPaused {\n        // Variables which can be assigned by reading previously-set GMX contracts\n        rewardTrackerGmx = RewardTracker(gmxRewardRouterV2.feeGmxTracker());\n        rewardTrackerGlp = RewardTracker(gmxRewardRouterV2.feeGlpTracker());\n        feeStakedGlp = RewardTracker(gmxRewardRouterV2.stakedGlpTracker());\n        stakedGmx = RewardTracker(gmxRewardRouterV2.stakedGmxTracker());\n        glpManager = gmxRewardRouterV2.glpManager();\n        gmxVault = IVault(IGlpManager(glpManager).vault());\n\n        emit ConfigureGmxState(\n            msg.sender,\n            rewardTrackerGmx,\n            rewardTrackerGlp,\n            feeStakedGlp,\n            stakedGmx,\n            glpManager,\n            gmxVault\n        );\n\n        // Approve GMX to enable staking\n        gmx.safeApprove(address(stakedGmx), type(uint256).max);\n    }\n\n    /**\n        @notice Set fee\n        @param  f    enum     Fee\n        @param  fee  uint256  Fee amount\n     */\n    function setFee(Fees f, uint256 fee) external onlyOwner {\n        if (fee > FEE_MAX) revert InvalidFee();\n\n        fees[f] = fee;\n\n        emit SetFee(f, fee);\n    }\n\n    /**\n        @notice Set a contract address\n        @param  c                enum     Contracts\n        @param  contractAddress  address  Contract address\n     */\n    function setContract(Contracts c, address contractAddress)\n        external\n        onlyOwner\n    {\n        if (contractAddress == address(0)) revert ZeroAddress();\n\n        emit SetContract(c, contractAddress);\n\n        if (c == Contracts.PirexFees) {\n            pirexFees = PirexFees(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardRouterV2) {\n            gmxRewardRouterV2 = IRewardRouterV2(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGmx) {\n            rewardTrackerGmx = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.RewardTrackerGlp) {\n            rewardTrackerGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.FeeStakedGlp) {\n            feeStakedGlp = RewardTracker(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.StakedGmx) {\n            // Set the current stakedGmx (pending change) approval amount to 0\n            gmx.safeApprove(address(stakedGmx), 0);\n\n            stakedGmx = RewardTracker(contractAddress);\n\n            // Approve the new stakedGmx contract address allowance to the max\n            gmx.safeApprove(contractAddress, type(uint256).max);\n            return;\n        }\n\n        if (c == Contracts.StakedGlp) {\n            stakedGlp = IStakedGlp(contractAddress);\n            return;\n        }\n\n        if (c == Contracts.GmxVault) {\n            gmxVault = IVault(contractAddress);\n            return;\n        }\n\n        glpManager = contractAddress;\n    }\n\n    /**\n        @notice Deposit GMX for pxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  pxGMX receiver\n        @return           uint256  GMX deposited\n        @return           uint256  pxGMX minted for the receiver\n        @return           uint256  pxGMX distributed as fees\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's GMX to this contract and stake it for rewards\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n        gmxRewardRouterV2.stakeGmx(amount);\n\n        // Get the pxGMX amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGMX for the receiver (excludes fees)\n        pxGmx.mint(receiver, postFeeAmount);\n\n        // Mint pxGMX for fee distribution contract\n        if (feeAmount != 0) {\n            pxGmx.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGmx(msg.sender, receiver, amount, postFeeAmount, feeAmount);\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit fsGLP for pxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  pxGLP receiver\n        @return           uint256  fsGLP deposited\n        @return           uint256  pxGLP minted for the receiver\n        @return           uint256  pxGLP distributed as fees\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Transfer the caller's fsGLP (unstaked for the user, staked for this contract)\n        stakedGlp.transferFrom(msg.sender, address(this), amount);\n\n        // Get the pxGLP amounts for the receiver and the protocol (fees)\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            amount\n        );\n\n        // Mint pxGLP for the receiver (excludes fees)\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            address(stakedGlp),\n            0,\n            0,\n            0,\n            amount,\n            postFeeAmount,\n            feeAmount\n        );\n\n        return (amount, postFeeAmount, feeAmount);\n    }\n\n    /**\n        @notice Deposit GLP for pxGLP\n        @param  token          address  GMX-whitelisted token for minting GLP (optional)\n        @param  tokenAmount    uint256  Token amount\n        @param  minUsdg        uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp         uint256  Minimum GLP amount minted from tokens\n        @param  receiver       address  pxGLP receiver\n        @return deposited      uint256  GLP deposited\n        @return postFeeAmount  uint256  pxGLP minted for the receiver\n        @return feeAmount      uint256  pxGLP distributed as fees\n     */\n    function _depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        internal\n        returns (\n            uint256 deposited,\n            uint256 postFeeAmount,\n            uint256 feeAmount\n        )\n    {\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (token == address(0)) {\n            // Mint and stake GLP using ETH\n            deposited = gmxRewardRouterV2.mintAndStakeGlpETH{\n                value: tokenAmount\n            }(minUsdg, minGlp);\n        } else {\n            ERC20 t = ERC20(token);\n\n            // Intake user ERC20 tokens and approve GLP Manager contract for amount\n            t.safeTransferFrom(msg.sender, address(this), tokenAmount);\n            t.safeApprove(glpManager, tokenAmount);\n\n            // Mint and stake GLP using ERC20 tokens\n            deposited = gmxRewardRouterV2.mintAndStakeGlp(\n                token,\n                tokenAmount,\n                minUsdg,\n                minGlp\n            );\n        }\n\n        // Calculate the post-fee and fee amounts based on the fee type and total deposited\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\n            Fees.Deposit,\n            deposited\n        );\n\n        // Mint pxGLP for the receiver\n        pxGlp.mint(receiver, postFeeAmount);\n\n        // Mint pxGLP for fee distribution contract\n        if (feeAmount != 0) {\n            pxGlp.mint(address(pirexFees), feeAmount);\n        }\n\n        emit DepositGlp(\n            msg.sender,\n            receiver,\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            deposited,\n            postFeeAmount,\n            feeAmount\n        );\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for pxGLP\n        @param  minUsdg    uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp     uint256  Minimum GLP amount minted from ETH\n        @param  receiver   address  pxGLP receiver\n        @return deposited  uint256  GLP deposited\n        @return            uint256  pxGLP minted for the receiver\n        @return            uint256  pxGLP distributed as fees\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _depositGlp(address(0), msg.value, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for pxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  pxGLP receiver\n        @return              uint256  GLP deposited\n        @return              uint256  pxGLP minted for the receiver\n        @return              uint256  pxGLP distributed as fees\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (token == address(0)) revert ZeroAddress();\n        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);\n\n        return _depositGlp(token, tokenAmount, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Redeem pxGLP\n        @param  token          address  GMX-whitelisted token to be redeemed (optional)\n        @param  amount         uint256  pxGLP amount\n        @param  minOut         uint256  Minimum token output from GLP redemption\n        @param  receiver       address  Output token recipient\n        @return redeemed       uint256  Output tokens from redeeming GLP\n        @return postFeeAmount  uint256  pxGLP burned from the msg.sender\n        @return feeAmount      uint256  pxGLP distributed as fees\n     */\n    function _redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        internal\n        returns (\n            uint256 redeemed,\n            uint256 postFeeAmount,\n            uint256 feeAmount\n        )\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (minOut == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Calculate the post-fee and fee amounts based on the fee type and total amount\n        (postFeeAmount, feeAmount) = _computeAssetAmounts(\n            Fees.Redemption,\n            amount\n        );\n\n        // Burn pxGLP before redeeming the underlying GLP\n        pxGlp.burn(msg.sender, postFeeAmount);\n\n        // Transfer pxGLP from caller to the fee distribution contract\n        if (feeAmount != 0) {\n            ERC20(pxGlp).safeTransferFrom(\n                msg.sender,\n                address(pirexFees),\n                feeAmount\n            );\n        }\n\n        // Unstake and redeem the underlying GLP for ERC20 tokens\n        redeemed = token == address(0)\n            ? gmxRewardRouterV2.unstakeAndRedeemGlpETH(\n                postFeeAmount,\n                minOut,\n                receiver\n            )\n            : gmxRewardRouterV2.unstakeAndRedeemGlp(\n                token,\n                postFeeAmount,\n                minOut,\n                receiver\n            );\n\n        emit RedeemGlp(\n            msg.sender,\n            receiver,\n            token,\n            amount,\n            minOut,\n            redeemed,\n            postFeeAmount,\n            feeAmount\n        );\n    }\n\n    /**\n        @notice Redeem pxGLP for ETH from redeeming GLP\n        @param  amount    uint256  pxGLP amount\n        @param  minOut    uint256  Minimum ETH output from GLP redemption\n        @param  receiver  address  ETH recipient\n        @return           uint256  ETH redeemed from GLP\n        @return           uint256  pxGLP burned from the msg.sender\n        @return           uint256  pxGLP distributed as fees\n     */\n    function redeemPxGlpETH(\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _redeemPxGlp(address(0), amount, minOut, receiver);\n    }\n\n    /**\n        @notice Redeem pxGLP for ERC20 tokens from redeeming GLP\n        @param  token     address  GMX-whitelisted token to be redeemed\n        @param  amount    uint256  pxGLP amount\n        @param  minOut    uint256  Minimum ERC20 output from GLP redemption\n        @param  receiver  address  ERC20 token recipient\n        @return           uint256  ERC20 tokens from redeeming GLP\n        @return           uint256  pxGLP burned from the msg.sender\n        @return           uint256  pxGLP distributed as fees\n     */\n    function redeemPxGlp(\n        address token,\n        uint256 amount,\n        uint256 minOut,\n        address receiver\n    )\n        external\n        whenNotPaused\n        nonReentrant\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        if (token == address(0)) revert ZeroAddress();\n        if (!gmxVault.whitelistedTokens(token)) revert InvalidToken(token);\n\n        return _redeemPxGlp(token, amount, minOut, receiver);\n    }\n\n    /**\n        @notice Claim WETH/esGMX rewards + multiplier points (MP)\n        @return producerTokens  ERC20[]    Producer tokens (pxGLP and pxGMX)\n        @return rewardTokens    ERC20[]    Reward token contract instances\n        @return rewardAmounts   uint256[]  Reward amounts from each producerToken\n     */\n    function claimRewards()\n        external\n        onlyPirexRewards\n        returns (\n            ERC20[] memory producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        )\n    {\n        // Assign return values used by the PirexRewards contract\n        producerTokens = new ERC20[](4);\n        rewardTokens = new ERC20[](4);\n        rewardAmounts = new uint256[](4);\n        producerTokens[0] = pxGmx;\n        producerTokens[1] = pxGlp;\n        producerTokens[2] = pxGmx;\n        producerTokens[3] = pxGlp;\n        rewardTokens[0] = gmxBaseReward;\n        rewardTokens[1] = gmxBaseReward;\n        rewardTokens[2] = ERC20(pxGmx); // esGMX rewards distributed as pxGMX\n        rewardTokens[3] = ERC20(pxGmx);\n\n        // Get pre-reward claim reward token balances to calculate actual amount received\n        uint256 baseRewardBeforeClaim = gmxBaseReward.balanceOf(address(this));\n        uint256 esGmxBeforeClaim = stakedGmx.depositBalances(\n            address(this),\n            address(esGmx)\n        );\n\n        // Calculate the unclaimed reward token amounts produced for each token type\n        uint256 gmxBaseRewards = _calculateRewards(true, true);\n        uint256 glpBaseRewards = _calculateRewards(true, false);\n        uint256 gmxEsGmxRewards = _calculateRewards(false, true);\n        uint256 glpEsGmxRewards = _calculateRewards(false, false);\n\n        // Claim and stake esGMX + MP, and claim WETH\n        gmxRewardRouterV2.handleRewards(\n            false,\n            false,\n            true,\n            true,\n            true,\n            true,\n            false\n        );\n\n        uint256 baseRewards = gmxBaseReward.balanceOf(address(this)) -\n            baseRewardBeforeClaim;\n        uint256 esGmxRewards = stakedGmx.depositBalances(\n            address(this),\n            address(esGmx)\n        ) - esGmxBeforeClaim;\n\n        if (baseRewards != 0) {\n            // This may not be necessary and is more of a hedge against a discrepancy between\n            // the actual rewards and the calculated amounts. Needs further consideration\n            rewardAmounts[0] =\n                (gmxBaseRewards * baseRewards) /\n                (gmxBaseRewards + glpBaseRewards);\n            rewardAmounts[1] = baseRewards - rewardAmounts[0];\n        }\n\n        if (esGmxRewards != 0) {\n            rewardAmounts[2] =\n                (gmxEsGmxRewards * esGmxRewards) /\n                (gmxEsGmxRewards + glpEsGmxRewards);\n            rewardAmounts[3] = esGmxRewards - rewardAmounts[2];\n        }\n\n        emit ClaimRewards(\n            baseRewards,\n            esGmxRewards,\n            gmxBaseRewards,\n            glpBaseRewards,\n            gmxEsGmxRewards,\n            glpEsGmxRewards\n        );\n    }\n\n    /**\n        @notice Mint/transfer the specified reward token to the receiver\n        @param  token     address  Reward token address\n        @param  amount    uint256  Reward amount\n        @param  receiver  address  Reward receiver\n     */\n    function claimUserReward(\n        address token,\n        uint256 amount,\n        address receiver\n    ) external onlyPirexRewards {\n        if (token == address(0)) revert ZeroAddress();\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        (uint256 postFeeAmount, uint256 feeAmount) = _computeAssetAmounts(\n            Fees.Reward,\n            amount\n        );\n\n        if (token == address(pxGmx)) {\n            // Mint pxGMX for the user - the analog for esGMX rewards\n            pxGmx.mint(receiver, postFeeAmount);\n\n            if (feeAmount != 0) pxGmx.mint(address(pirexFees), feeAmount);\n        } else if (token == address(gmxBaseReward)) {\n            gmxBaseReward.safeTransfer(receiver, postFeeAmount);\n\n            if (feeAmount != 0)\n                gmxBaseReward.safeTransfer(address(pirexFees), feeAmount);\n        }\n\n        emit ClaimUserReward(receiver, token, amount, postFeeAmount, feeAmount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        VOTE DELEGATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Set delegationSpace\n        @param  _delegationSpace  string  Snapshot delegation space\n        @param  shouldClear       bool    Whether to clear the vote delegate for the current space\n     */\n    function setDelegationSpace(\n        string memory _delegationSpace,\n        bool shouldClear\n    ) external onlyOwner {\n        if (shouldClear) {\n            // Clear the delegation for the current delegation space\n            clearVoteDelegate();\n        }\n\n        bytes memory d = bytes(_delegationSpace);\n\n        if (d.length == 0) revert EmptyString();\n\n        delegationSpace = bytes32(d);\n\n        emit SetDelegationSpace(_delegationSpace, shouldClear);\n    }\n\n    /**\n        @notice Set vote delegate\n        @param  voteDelegate  address  Account to delegate votes to\n     */\n    function setVoteDelegate(address voteDelegate) external onlyOwner {\n        if (voteDelegate == address(0)) revert ZeroAddress();\n\n        emit SetVoteDelegate(voteDelegate);\n\n        delegateRegistry.setDelegate(delegationSpace, voteDelegate);\n    }\n\n    /**\n        @notice Clear vote delegate\n     */\n    function clearVoteDelegate() public onlyOwner {\n        emit ClearVoteDelegate();\n\n        delegateRegistry.clearDelegate(delegationSpace);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        EMERGENCY/MIGRATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Set the contract's pause state\n        @param state  bool  Pause state\n    */\n    function setPauseState(bool state) external onlyOwner {\n        if (state) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**\n        @notice Initiate contract migration (called by the old contract)\n        @param  newContract  address  Address of the new contract\n    */\n    function initiateMigration(address newContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (newContract == address(0)) revert ZeroAddress();\n\n        // Notify the reward router that the current/old contract is going to perform\n        // full account transfer to the specified new contract\n        gmxRewardRouterV2.signalTransfer(newContract);\n\n        migratedTo = newContract;\n\n        emit InitiateMigration(newContract);\n    }\n\n    /**\n        @notice Migrate remaining (base) reward to the new contract after completing migration\n    */\n    function migrateReward() external whenPaused {\n        if (msg.sender != migratedTo) revert NotMigratedTo();\n        if (gmxRewardRouterV2.pendingReceivers(address(this)) != address(0))\n            revert PendingMigration();\n\n        // Transfer out any remaining base reward (ie. WETH) to the new contract\n        gmxBaseReward.safeTransfer(\n            migratedTo,\n            gmxBaseReward.balanceOf(address(this))\n        );\n    }\n\n    /**\n        @notice Complete contract migration (called by the new contract)\n        @param  oldContract  address  Address of the old contract\n    */\n    function completeMigration(address oldContract)\n        external\n        whenPaused\n        onlyOwner\n    {\n        if (oldContract == address(0)) revert ZeroAddress();\n\n        // Trigger harvest to claim remaining rewards before the account transfer\n        IPirexRewards(pirexRewards).harvest();\n\n        // Complete the full account transfer process\n        gmxRewardRouterV2.acceptTransfer(oldContract);\n\n        // Perform reward token transfer from the old contract to the new one\n        PirexGmx(oldContract).migrateReward();\n\n        emit CompleteMigration(oldContract);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {IRewardDistributor} from \"src/interfaces/IRewardDistributor.sol\";\nimport {IWETH} from \"src/interfaces/IWETH.sol\";\nimport {DelegateRegistry} from \"src/external/DelegateRegistry.sol\";\nimport {RewardTracker} from \"src/external/RewardTracker.sol\";\nimport {IGlpManager} from \"src/interfaces/IGlpManager.sol\";\nimport {IVault} from \"src/interfaces/IVault.sol\";\nimport {Helper} from \"./Helper.sol\";\n\ncontract PirexGmxTest is Test, Helper {\n    bytes internal constant PAUSED_ERROR = \"Pausable: paused\";\n    bytes internal constant NOT_PAUSED_ERROR = \"Pausable: not paused\";\n    bytes internal constant INSUFFICIENT_OUTPUT_ERROR =\n        \"GlpManager: insufficient output\";\n    bytes internal constant INSUFFICIENT_GLP_OUTPUT_ERROR =\n        \"GlpManager: insufficient GLP output\";\n\n    /**\n        @notice Get an address that is unauthorized (i.e. not owner)\n        @return unauthorizedCaller  address  Unauthorized caller\n     */\n    function _getUnauthorizedCaller()\n        internal\n        returns (address unauthorizedCaller)\n    {\n        unauthorizedCaller = testAccounts[0];\n\n        assertTrue(unauthorizedCaller != pirexGmx.owner());\n    }\n\n    /**\n        @notice Pause and verify pause state for contract\n     */\n    function _pauseContract() internal {\n        pirexGmx.setPauseState(true);\n\n        assertEq(true, pirexGmx.paused());\n    }\n\n    /**\n        @notice Set fee, verify event emission, and validate new state\n        @param  f    enum     Fee type\n        @param  fee  uint256  Fee\n     */\n    function _setFee(PirexGmx.Fees f, uint256 fee) internal {\n        vm.expectEmit(true, false, false, true, address(pirexGmx));\n\n        emit SetFee(f, fee);\n\n        pirexGmx.setFee(f, fee);\n\n        assertEq(fee, pirexGmx.fees(f));\n    }\n\n    /**\n        @notice Set contract, verify event emission, and validate new state\n        @param  c                enum     Contract type\n        @param  contractAddress  address  Contract address\n     */\n    function _setContract(PirexGmx.Contracts c, address contractAddress)\n        internal\n    {\n        vm.expectEmit(true, false, false, true, address(pirexGmx));\n\n        emit SetContract(c, contractAddress);\n\n        pirexGmx.setContract(c, contractAddress);\n\n        address newContractAddress;\n\n        // Use a conditional statement to set newContractAddress since no getter\n        if (c == PirexGmx.Contracts.PirexFees)\n            newContractAddress = address(pirexGmx.pirexFees());\n        if (c == PirexGmx.Contracts.RewardRouterV2)\n            newContractAddress = address(pirexGmx.gmxRewardRouterV2());\n        if (c == PirexGmx.Contracts.RewardTrackerGmx)\n            newContractAddress = address(pirexGmx.rewardTrackerGmx());\n        if (c == PirexGmx.Contracts.RewardTrackerGlp)\n            newContractAddress = address(pirexGmx.rewardTrackerGlp());\n        if (c == PirexGmx.Contracts.FeeStakedGlp)\n            newContractAddress = address(pirexGmx.feeStakedGlp());\n        if (c == PirexGmx.Contracts.StakedGmx)\n            newContractAddress = address(pirexGmx.stakedGmx());\n        if (c == PirexGmx.Contracts.StakedGlp)\n            newContractAddress = address(pirexGmx.stakedGlp());\n        if (c == PirexGmx.Contracts.GmxVault)\n            newContractAddress = address(pirexGmx.gmxVault());\n        if (c == PirexGmx.Contracts.GlpManager)\n            newContractAddress = address(pirexGmx.glpManager());\n\n        assertEq(contractAddress, newContractAddress);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            configureGmxState TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotConfigureGmxStateUnauthorized() external {\n        address unauthorizedCaller = _getUnauthorizedCaller();\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.configureGmxState();\n    }\n\n    /**\n        @notice Test tx reversion: contract is not paused\n     */\n    function testCannotConfigureGmxStateNotPaused() external {\n        assertEq(false, pirexGmx.paused());\n\n        vm.expectRevert(NOT_PAUSED_ERROR);\n\n        pirexGmx.configureGmxState();\n    }\n\n    /**\n        @notice Test tx success: configure GMX state\n     */\n    function testConfigureGmxState() external {\n        PirexGmx freshPirexGmx = new PirexGmx(\n            address(pxGmx),\n            address(pxGlp),\n            address(pirexFees),\n            address(pirexRewards),\n            address(delegateRegistry),\n            // The `weth` variable is used on both Ethereum and Avalanche for the base rewards\n            REWARD_ROUTER_V2.weth(),\n            REWARD_ROUTER_V2.gmx(),\n            REWARD_ROUTER_V2.esGmx(),\n            address(REWARD_ROUTER_V2),\n            address(STAKED_GLP)\n        );\n\n        assertEq(address(this), freshPirexGmx.owner());\n        assertEq(true, freshPirexGmx.paused());\n        assertEq(address(0), address(freshPirexGmx.rewardTrackerGmx()));\n        assertEq(address(0), address(freshPirexGmx.rewardTrackerGlp()));\n        assertEq(address(0), address(freshPirexGmx.feeStakedGlp()));\n        assertEq(address(0), address(freshPirexGmx.stakedGmx()));\n        assertEq(address(0), address(freshPirexGmx.glpManager()));\n        assertEq(address(0), address(freshPirexGmx.gmxVault()));\n        assertEq(0, gmx.allowance(address(freshPirexGmx), address(stakedGmx)));\n\n        IVault gmxVault = IVault(IGlpManager(glpManager).vault());\n\n        vm.expectEmit(true, false, false, true, address(freshPirexGmx));\n\n        emit ConfigureGmxState(\n            address(this),\n            rewardTrackerGmx,\n            rewardTrackerGlp,\n            feeStakedGlp,\n            stakedGmx,\n            address(glpManager),\n            gmxVault\n        );\n\n        freshPirexGmx.configureGmxState();\n\n        assertEq(\n            address(rewardTrackerGmx),\n            address(freshPirexGmx.rewardTrackerGmx())\n        );\n        assertEq(\n            address(rewardTrackerGlp),\n            address(freshPirexGmx.rewardTrackerGlp())\n        );\n        assertEq(address(feeStakedGlp), address(freshPirexGmx.feeStakedGlp()));\n        assertEq(address(stakedGmx), address(freshPirexGmx.stakedGmx()));\n        assertEq(address(glpManager), address(freshPirexGmx.glpManager()));\n        assertEq(address(gmxVault), address(freshPirexGmx.gmxVault()));\n        assertEq(type(uint256).max, gmx.allowance(address(freshPirexGmx), address(stakedGmx)));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            setFee TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetFeeUnauthorized() external {\n        address unauthorizedCaller = _getUnauthorizedCaller();\n        uint256 fee = 1;\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.setFee(PirexGmx.Fees.Deposit, fee);\n    }\n\n    /**\n        @notice Test tx reversion: fee is invalid\n     */\n    function testCannotSetFeeInvalidFee() external {\n        uint256 invalidFee = feeMax + 1;\n\n        for (uint256 i; i < feeTypes.length; ++i) {\n            vm.expectRevert(PirexGmx.InvalidFee.selector);\n\n            pirexGmx.setFee(feeTypes[i], invalidFee);\n        }\n    }\n\n    /**\n        @notice Test tx success: set fees for each type\n        @param  depositFee     uint24  Deposit fee\n        @param  redemptionFee  uint24  Redemption fee\n        @param  rewardFee      uint24  Reward fee\n     */\n    function testSetFee(\n        uint24 depositFee,\n        uint24 redemptionFee,\n        uint24 rewardFee\n    ) external {\n        vm.assume(depositFee != 0);\n        vm.assume(depositFee <= feeMax);\n        vm.assume(redemptionFee != 0);\n        vm.assume(redemptionFee < feeMax);\n        vm.assume(rewardFee != 0);\n        vm.assume(rewardFee < feeMax);\n\n        PirexGmx.Fees depositFeeType = feeTypes[0];\n        PirexGmx.Fees redemptionFeeType = feeTypes[1];\n        PirexGmx.Fees rewardFeeType = feeTypes[2];\n\n        assertEq(0, pirexGmx.fees(depositFeeType));\n        assertEq(0, pirexGmx.fees(redemptionFeeType));\n        assertEq(0, pirexGmx.fees(rewardFeeType));\n\n        // Set and validate the different fee types\n        _setFee(depositFeeType, depositFee);\n        _setFee(redemptionFeeType, redemptionFee);\n        _setFee(rewardFeeType, rewardFee);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setContract TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetContractNotAuthorized() external {\n        address unauthorizedCaller = _getUnauthorizedCaller();\n        address contractAddress = address(this);\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.setContract(\n            PirexGmx.Contracts.RewardRouterV2,\n            contractAddress\n        );\n    }\n\n    /**\n        @notice Test tx reversion: contractAddress is the zero address\n     */\n    function testCannotSetContractZeroAddress() external {\n        address invalidContractAddress = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.setContract(\n            PirexGmx.Contracts.RewardRouterV2,\n            invalidContractAddress\n        );\n    }\n\n    /**\n        @notice Test tx success: set pirexFees to a new contract address\n     */\n    function testSetContractPirexFees() external {\n        address currentContractAddress = address(pirexGmx.pirexFees());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.PirexFees, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set gmxRewardRouterV2 to a new contract address\n     */\n    function testSetContractRewardRouterV2() external {\n        address currentContractAddress = address(pirexGmx.gmxRewardRouterV2());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.RewardRouterV2, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set rewardTrackerGmx to a new contract address\n     */\n    function testSetContractRewardTrackerGmx() external {\n        address currentContractAddress = address(pirexGmx.rewardTrackerGmx());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.RewardTrackerGmx, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set rewardTrackerGlp to a new contract address\n     */\n    function testSetContractRewardTrackerGlp() external {\n        address currentContractAddress = address(pirexGmx.rewardTrackerGlp());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.RewardTrackerGlp, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set feeStakedGlp to a new contract address\n     */\n    function testSetContractFeeStakedGlp() external {\n        address currentContractAddress = address(pirexGmx.feeStakedGlp());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.FeeStakedGlp, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set stakedGmx to a new contract address\n     */\n    function testSetContractStakedGmx() external {\n        address currentContractAddress = address(pirexGmx.stakedGmx());\n        uint256 currentContractAddressAllowance = type(uint256).max;\n        address contractAddress = address(this);\n\n        assertFalse(contractAddress == currentContractAddress);\n        assertEq(\n            currentContractAddressAllowance,\n            gmx.allowance(address(pirexGmx), currentContractAddress)\n        );\n\n        uint256 expectedCurrentContractAllowance = 0;\n        uint256 expectedContractAddressAllowance = type(uint256).max;\n\n        assertFalse(\n            currentContractAddressAllowance == expectedCurrentContractAllowance\n        );\n\n        _setContract(PirexGmx.Contracts.StakedGmx, contractAddress);\n\n        assertEq(\n            expectedCurrentContractAllowance,\n            gmx.allowance(address(pirexGmx), currentContractAddress)\n        );\n        assertEq(\n            expectedContractAddressAllowance,\n            gmx.allowance(address(pirexGmx), contractAddress)\n        );\n    }\n\n    /**\n        @notice Test tx success: set feeStakedGlp to a new contract address\n     */\n    function testSetContractStakedGlp() external {\n        address currentContractAddress = address(pirexGmx.stakedGlp());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.StakedGlp, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set gmxVault to a new contract address\n     */\n    function testSetContractGmxVault() external {\n        address currentContractAddress = address(pirexGmx.gmxVault());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.GmxVault, contractAddress);\n    }\n\n    /**\n        @notice Test tx success: set glpManager to a new contract address\n     */\n    function testSetContractGlpManager() external {\n        address currentContractAddress = address(pirexGmx.glpManager());\n        address contractAddress = address(this);\n\n        assertFalse(currentContractAddress == contractAddress);\n\n        _setContract(PirexGmx.Contracts.GlpManager, contractAddress);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGmx TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotDepositGmxPaused() external {\n        _pauseContract();\n\n        uint256 assets = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.depositGmx(assets, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: assets is zero\n     */\n    function testCannotDepositGmxAssetsZeroAmount() external {\n        uint256 invalidAssets = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGmx(invalidAssets, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotDepositGmxReceiverZeroAddress() external {\n        uint256 assets = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.depositGmx(assets, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx reversion: insufficient GMX balance\n        @param  assets      uint80  GMX amount\n        @param  mintAmount  uint80  GMX mint amount\n     */\n    function testCannotDepositGmxInsufficientBalance(\n        uint80 assets,\n        uint80 mintAmount\n    ) external {\n        vm.assume(assets != 0);\n        vm.assume(mintAmount < assets);\n\n        address receiver = address(this);\n\n        _mintApproveGmx(\n            mintAmount,\n            address(this),\n            address(pirexGmx),\n            mintAmount\n        );\n\n        vm.expectRevert(\"TRANSFER_FROM_FAILED\");\n\n        pirexGmx.depositGmx(assets, receiver);\n    }\n\n    /**\n        @notice Test tx success: deposit GMX for pxGMX\n        @param  depositFee      uint24  Deposit fee\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  separateCaller  bool    Whether to separate method caller and receiver\n     */\n    function testDepositGmx(\n        uint24 depositFee,\n        uint8 multiplier,\n        bool separateCaller\n    ) external {\n        vm.assume(depositFee <= feeMax);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        _setFee(PirexGmx.Fees.Deposit, depositFee);\n\n        uint256 expectedPreDepositGmxBalancePirexGmx = 0;\n        uint256 expectedPreDepositPxGmxSupply = 0;\n\n        assertEq(\n            expectedPreDepositGmxBalancePirexGmx,\n            rewardTrackerGmx.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPreDepositPxGmxSupply, pxGmx.totalSupply());\n\n        // Deposits GMX, verifies event emission, and validates depositGmx return values\n        uint256[] memory depositAmounts = _depositGmxForTestAccounts(\n            separateCaller,\n            address(this),\n            multiplier\n        );\n\n        // Assign the initial post-deposit values to their pre-deposit counterparts\n        uint256 expectedPostDepositGmxBalancePirexGmx = expectedPreDepositGmxBalancePirexGmx;\n        uint256 expectedPostDepositPxGmxSupply = expectedPreDepositPxGmxSupply;\n        uint256 tLen = testAccounts.length;\n\n        for (uint256 i; i < tLen; ++i) {\n            uint256 depositAmount = depositAmounts[i];\n\n            expectedPostDepositGmxBalancePirexGmx += depositAmount;\n            expectedPostDepositPxGmxSupply += depositAmount;\n\n            (uint256 postFeeAmount, ) = _computeAssetAmounts(\n                PirexGmx.Fees.Deposit,\n                depositAmount\n            );\n\n            // Check test account balances against post-fee pxGMX mint amount\n            assertEq(postFeeAmount, pxGmx.balanceOf(testAccounts[i]));\n        }\n\n        assertEq(\n            expectedPostDepositGmxBalancePirexGmx,\n            rewardTrackerGmx.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPostDepositPxGmxSupply, pxGmx.totalSupply());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositFsGlp TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotDepositFsGlpPaused() external {\n        _pauseContract();\n\n        uint256 assets = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.depositFsGlp(assets, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: assets is zero\n     */\n    function testCannotDepositFsGlpAssetsZeroAmount() external {\n        uint256 invalidAssets = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositFsGlp(invalidAssets, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotDepositFsGlpReceiverZeroAddress() external {\n        uint256 assets = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.depositFsGlp(assets, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx reversion: insufficient fsGLP balance\n        @param  ethAmount  uint72  ETH amount\n     */\n    function testCannotDepositFsGlpInsufficientBalance(uint72 ethAmount)\n        external\n    {\n        vm.assume(ethAmount > 0.001 ether);\n        vm.assume(ethAmount < 1000 ether);\n\n        uint256 invalidAssets = _mintAndApproveFsGlp(ethAmount, address(this)) +\n            1;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(\"StakedGlp: transfer amount exceeds allowance\");\n\n        pirexGmx.depositFsGlp(invalidAssets, receiver);\n    }\n\n    /**\n        @notice Test tx success: deposit fsGLP for pxGLP\n        @param  depositFee      uint24  Deposit fee\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  separateCaller  bool    Whether to separate method caller and receiver\n     */\n    function testDepositFsGlp(\n        uint24 depositFee,\n        uint8 multiplier,\n        bool separateCaller\n    ) external {\n        vm.assume(depositFee <= feeMax);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        _setFee(PirexGmx.Fees.Deposit, depositFee);\n\n        uint256 tLen = testAccounts.length;\n        uint256 expectedPreDepositGlpBalancePirexGmx = 0;\n        uint256 expectedPreDepositPxGlpSupply = 0;\n\n        assertEq(\n            expectedPreDepositGlpBalancePirexGmx,\n            feeStakedGlp.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPreDepositPxGlpSupply, pxGlp.totalSupply());\n\n        uint256 expectedPostDepositGlpBalancePirexGmx = expectedPreDepositGlpBalancePirexGmx;\n        uint256 expectedPostDepositPxGlpSupply = expectedPreDepositPxGlpSupply;\n\n        for (uint256 i; i < tLen; ++i) {\n            address testAccount = testAccounts[i];\n            address caller = separateCaller ? address(this) : testAccount;\n            uint256 assets = _mintAndApproveFsGlp(1 ether * multiplier, caller);\n            address receiver = testAccount;\n\n            vm.prank(caller);\n            vm.expectEmit(true, true, true, false, address(pirexGmx));\n\n            emit DepositGlp(\n                caller,\n                receiver,\n                address(STAKED_GLP),\n                0,\n                0,\n                0,\n                0,\n                0,\n                0\n            );\n\n            (uint256 deposited, uint256 postFeeAmount, ) = pirexGmx\n                .depositFsGlp(assets, receiver);\n            uint256 receiverPxGlpBalance = pxGlp.balanceOf(receiver);\n\n            expectedPostDepositGlpBalancePirexGmx += deposited;\n            expectedPostDepositPxGlpSupply += deposited;\n\n            assertLt(0, receiverPxGlpBalance);\n            assertEq(postFeeAmount, receiverPxGlpBalance);\n        }\n\n        assertEq(\n            expectedPostDepositGlpBalancePirexGmx,\n            feeStakedGlp.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPostDepositPxGlpSupply, pxGlp.totalSupply());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGlpETH TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotDepositGlpETHPaused() external {\n        _pauseContract();\n\n        uint256 etherAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.deal(address(this), etherAmount);\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.depositGlpETH{value: etherAmount}(minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: msg.value is zero\n     */\n    function testCannotDepositGlpETHMsgValueZeroAmount() external {\n        uint256 invalidEtherAmount = 0;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGlpETH{value: invalidEtherAmount}(\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minUsdg is zero\n     */\n    function testCannotDepositGlpETHMinUsdgZeroAmount() external {\n        uint256 etherAmount = 1 ether;\n        uint256 invalidMinUsdg = 0;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.deal(address(this), etherAmount);\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGlpETH{value: etherAmount}(\n            invalidMinUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is zero\n     */\n    function testCannotDepositGlpETHMinGlpZeroAmount() external {\n        uint256 etherAmount = 1 ether;\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlp = 0;\n        address receiver = address(this);\n\n        vm.deal(address(this), etherAmount);\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGlpETH{value: etherAmount}(\n            minUsdg,\n            invalidMinGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotDepositGlpETHReceiverZeroAddress() external {\n        uint256 etherAmount = 1 ether;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address invalidReceiver = address(0);\n\n        vm.deal(address(this), etherAmount);\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.depositGlpETH{value: etherAmount}(\n            minUsdg,\n            minGlp,\n            invalidReceiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is greater than output\n     */\n    function testCannotDepositGlpETHMinGlpInsufficientGlp() external {\n        uint256 etherAmount = 1 ether;\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlp = _calculateMinGlpAmount(\n            address(0),\n            etherAmount,\n            18\n        ) * 2;\n        address receiver = address(this);\n\n        vm.deal(address(this), etherAmount);\n        vm.expectRevert(INSUFFICIENT_GLP_OUTPUT_ERROR);\n\n        pirexGmx.depositGlpETH{value: etherAmount}(\n            minUsdg,\n            invalidMinGlp,\n            receiver\n        );\n    }\n\n    // /**\n    //     @notice Test tx success: testDepositGlp fuzz test covers both methods\n    //  */\n    // function testDepositGlpETH() external {}\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGlp TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotDepositGlpPaused() external {\n        _pauseContract();\n\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.depositGlp(token, tokenAmount, minUsdg, minGlp, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: token is zero address\n     */\n    function testCannotDepositGlpTokenZeroAddress() external {\n        address invalidToken = address(0);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.depositGlp(\n            invalidToken,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: token is not whitelisted by GMX\n     */\n    function testCannotDepositGlpInvalidToken() external {\n        address invalidToken = address(this);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(PirexGmx.InvalidToken.selector, invalidToken)\n        );\n\n        pirexGmx.depositGlp(\n            invalidToken,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: token amount is zero\n     */\n    function testCannotDepositGlpTokenAmountZeroAmount() external {\n        address token = address(weth);\n        uint256 invalidTokenAmount = 0;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGlp(\n            token,\n            invalidTokenAmount,\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minUsdg is zero\n     */\n    function testCannotDepositGlpMinUsdgZeroAmount() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 invalidMinUsdg = 0;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGlp(\n            token,\n            tokenAmount,\n            invalidMinUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is zero\n     */\n    function testCannotDepositGlpMinGlpZeroAmount() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlp = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            invalidMinGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotDepositGlpReceiverZeroAddress() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            invalidReceiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is greater than output\n     */\n    function testCannotDepositGlpMinGlpInsufficientGlpOutput() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1e8;\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlp = _calculateMinGlpAmount(token, tokenAmount, 8) *\n            2;\n        address receiver = address(this);\n\n        _mintWrappedToken(tokenAmount, address(this));\n        weth.approve(address(pirexGmx), tokenAmount);\n\n        vm.expectRevert(INSUFFICIENT_GLP_OUTPUT_ERROR);\n\n        pirexGmx.depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            invalidMinGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx success: deposit for pxGLP\n        @param  depositFee      uint24  Deposit fee\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  separateCaller  bool    Whether to separate method caller and receiver\n        @param  useETH          bool     Whether or not to use ETH as the source asset for minting GLP\n     */\n    function testDepositGlp(\n        uint24 depositFee,\n        uint8 multiplier,\n        bool separateCaller,\n        bool useETH\n    ) external {\n        vm.assume(depositFee <= feeMax);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        _setFee(PirexGmx.Fees.Deposit, depositFee);\n\n        uint256 expectedPreDepositGlpBalancePirexGmx = 0;\n        uint256 expectedPreDepositPxGlpSupply = 0;\n\n        assertEq(\n            expectedPreDepositGlpBalancePirexGmx,\n            feeStakedGlp.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPreDepositPxGlpSupply, pxGlp.totalSupply());\n\n        // Deposits GLP, verifies event emission, and validates depositGmx return values\n        uint256[] memory depositAmounts = _depositGlpForTestAccounts(\n            separateCaller,\n            address(this),\n            multiplier,\n            useETH\n        );\n\n        // Assign the initial post-deposit values to their pre-deposit counterparts\n        uint256 expectedPostDepositGlpBalancePirexGmx = expectedPreDepositGlpBalancePirexGmx;\n        uint256 expectedPostDepositPxGlpSupply = expectedPreDepositPxGlpSupply;\n        uint256 tLen = testAccounts.length;\n\n        for (uint256 i; i < tLen; ++i) {\n            uint256 depositAmount = depositAmounts[i];\n\n            expectedPostDepositGlpBalancePirexGmx += depositAmount;\n            expectedPostDepositPxGlpSupply += depositAmount;\n\n            (uint256 postFeeAmount, ) = _computeAssetAmounts(\n                PirexGmx.Fees.Deposit,\n                depositAmount\n            );\n\n            // Check test account balances against post-fee pxGMX mint amount\n            assertEq(postFeeAmount, pxGlp.balanceOf(testAccounts[i]));\n        }\n\n        assertEq(\n            expectedPostDepositGlpBalancePirexGmx,\n            feeStakedGlp.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPostDepositPxGlpSupply, pxGlp.totalSupply());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        redeemPxGlpETH TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotRedeemPxGlpETHPaused() external {\n        (uint256 postFeeAmount, uint256 feeAmount) = _depositGlpETH(\n            1 ether,\n            address(this)\n        );\n        uint256 assets = postFeeAmount + feeAmount;\n        uint256 minOut = _calculateMinOutAmount(address(weth), assets);\n        address receiver = testAccounts[0];\n\n        // Pause after deposit\n        _pauseContract();\n\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.redeemPxGlpETH(assets, minOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: assets is zero\n     */\n    function testCannotRedeemPxGlpETHAssetsZeroAmount() external {\n        uint256 invalidAssets = 0;\n        uint256 minOut = 1;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.redeemPxGlpETH(invalidAssets, minOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: minOut is zero\n     */\n    function testCannotRedeemPxGlpETHMinOutZeroAmount() external {\n        uint256 assets = 1;\n        uint256 invalidMinOut = 0;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.redeemPxGlpETH(assets, invalidMinOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotRedeemPxGlpETHReceiverZeroAddress() external {\n        uint256 assets = 1;\n        uint256 minOut = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.redeemPxGlpETH(assets, minOut, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx reversion: minOut is greater than output\n     */\n    function testCannotRedeemPxGlpETHMinOutInsufficientOutput() external {\n        (uint256 postFeeAmount, uint256 feeAmount) = _depositGlpETH(\n            1 ether,\n            address(this)\n        );\n        uint256 assets = postFeeAmount + feeAmount;\n        uint256 invalidMinOut = _calculateMinOutAmount(address(weth), assets) *\n            2;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(INSUFFICIENT_OUTPUT_ERROR);\n\n        pirexGmx.redeemPxGlpETH(assets, invalidMinOut, receiver);\n    }\n\n    // /**\n    //     @notice Test tx success: testRedeemPxGlp fuzz test covers both methods\n    //  */\n    // function testRedeemPxGlpETH() external {}\n\n    /*//////////////////////////////////////////////////////////////\n                        redeemPxGlp TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotRedeemPxGlpPaused() external {\n        uint256 etherAmount = 1 ether;\n        address token = address(weth);\n        (uint256 postFeeAmount, uint256 feeAmount) = _depositGlpETH(\n            etherAmount,\n            address(this)\n        );\n        uint256 assets = postFeeAmount + feeAmount;\n        uint256 minOut = _calculateMinOutAmount(token, assets);\n        address receiver = testAccounts[0];\n\n        // Pause after deposit\n        _pauseContract();\n\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.redeemPxGlp(token, assets, minOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: token is zero address\n     */\n    function testCannotRedeemPxGlpTokenZeroAddress() external {\n        address invalidToken = address(0);\n        uint256 assets = 1;\n        uint256 minOut = 1;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.redeemPxGlp(invalidToken, assets, minOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: token is not whitelisted by GMX\n     */\n    function testCannotRedeemPxGlpInvalidToken() external {\n        address invalidToken = address(this);\n        uint256 assets = 1;\n        uint256 minOut = 1;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(\n            abi.encodeWithSelector(PirexGmx.InvalidToken.selector, invalidToken)\n        );\n\n        pirexGmx.redeemPxGlp(invalidToken, assets, minOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: assets is zero\n     */\n    function testCannotRedeemPxGlpAssetsZeroAmount() external {\n        address token = address(weth);\n        uint256 invalidAssets = 0;\n        uint256 minOut = 1;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.redeemPxGlp(token, invalidAssets, minOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: minOut is zero\n     */\n    function testCannotRedeemPxGlpMinOutZeroAmount() external {\n        address token = address(weth);\n        uint256 assets = 1;\n        uint256 invalidMinOut = 0;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n\n        pirexGmx.redeemPxGlp(token, assets, invalidMinOut, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotRedeemPxGlpReceiverZeroAddress() external {\n        address token = address(weth);\n        uint256 assets = 1;\n        uint256 minOut = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.redeemPxGlp(token, assets, minOut, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx reversion: minOut is greater than output amount\n     */\n    function testCannotRedeemPxGlpMinOutInsufficientOutput() external {\n        address token = address(weth);\n        (uint256 deposited, , ) = _depositGlp(1e8, address(this));\n        uint256 invalidMinOut = _calculateMinOutAmount(token, deposited) * 2;\n        address receiver = testAccounts[0];\n\n        vm.expectRevert(INSUFFICIENT_OUTPUT_ERROR);\n\n        pirexGmx.redeemPxGlp(token, deposited, invalidMinOut, receiver);\n    }\n\n    /**\n        @notice Test tx success: redeem pxGLP\n        @param  redemptionFee   uint24  Redemption fee\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  useETH          bool    Whether or not to use ETH as the source asset for minting GLP\n     */\n    function testRedeemPxGlp(\n        uint24 redemptionFee,\n        uint8 multiplier,\n        bool useETH\n    ) external {\n        vm.assume(redemptionFee <= feeMax);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        _setFee(PirexGmx.Fees.Redemption, redemptionFee);\n\n        uint256[] memory depositAmounts = _depositGlpForTestAccounts(\n            false,\n            address(this),\n            multiplier,\n            useETH\n        );\n\n        vm.warp(block.timestamp + 1 days);\n\n        uint256 tLen = testAccounts.length;\n        uint256 totalDeposits;\n\n        for (uint256 i; i < tLen; ++i) {\n            totalDeposits += depositAmounts[i];\n        }\n\n        uint256 expectedPreRedeemGlpBalancePirexGmx = totalDeposits;\n        uint256 expectedPreRedeemPxGlpSupply = totalDeposits;\n\n        assertEq(\n            expectedPreRedeemGlpBalancePirexGmx,\n            feeStakedGlp.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPreRedeemGlpBalancePirexGmx, pxGlp.totalSupply());\n\n        uint256 expectedPostRedeemGlpBalancePirexGmx = expectedPreRedeemGlpBalancePirexGmx;\n        uint256 expectedPostRedeemPxGlpSupply = expectedPreRedeemPxGlpSupply;\n\n        for (uint256 i; i < tLen; ++i) {\n            address testAccount = testAccounts[i];\n            uint256 depositAmount = depositAmounts[i];\n            (uint256 postFeeAmount, ) = _computeAssetAmounts(\n                PirexGmx.Fees.Redemption,\n                depositAmount\n            );\n            address token = address(weth);\n\n            vm.startPrank(testAccount);\n\n            pxGlp.approve(address(pirexGmx), depositAmount);\n\n            vm.expectEmit(true, true, true, false, address(pirexGmx));\n\n            emit RedeemGlp(\n                testAccount,\n                testAccount,\n                useETH ? address(0) : token,\n                0,\n                _calculateMinOutAmount(token, postFeeAmount),\n                0,\n                0,\n                0\n            );\n\n            (, uint256 returnedPostFeeAmount, ) = useETH\n                ? pirexGmx.redeemPxGlpETH(\n                    depositAmount,\n                    _calculateMinOutAmount(token, postFeeAmount),\n                    testAccount\n                )\n                : pirexGmx.redeemPxGlp(\n                    token,\n                    depositAmount,\n                    _calculateMinOutAmount(token, postFeeAmount),\n                    testAccount\n                );\n\n            vm.stopPrank();\n\n            expectedPostRedeemGlpBalancePirexGmx -= returnedPostFeeAmount;\n            expectedPostRedeemPxGlpSupply -= returnedPostFeeAmount;\n        }\n\n        assertEq(\n            expectedPostRedeemGlpBalancePirexGmx,\n            feeStakedGlp.balanceOf(address(pirexGmx))\n        );\n        assertEq(expectedPostRedeemPxGlpSupply, pxGlp.totalSupply());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        claimRewards TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is not pirexRewards\n     */\n    function testCannotClaimRewardsNotPirexRewards() external {\n        assertTrue(address(this) != pirexGmx.pirexRewards());\n\n        vm.expectRevert(PirexGmx.NotPirexRewards.selector);\n\n        pirexGmx.claimRewards();\n    }\n\n    /**\n        @notice Test tx success: claim WETH, esGMX, and bnGMX/MP rewards\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n        @param  tokenAmount     uint72  Amount of wrapped token used for minting GLP\n        @param  gmxAmount       uint80  Amount of GMX to mint and deposit\n     */\n    function testClaimRewards(\n        uint32 secondsElapsed,\n        uint72 tokenAmount,\n        uint80 gmxAmount\n    ) external {\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n        vm.assume(tokenAmount > 0.001 ether);\n        vm.assume(tokenAmount < 1000 ether);\n        vm.assume(gmxAmount > 1e15);\n        vm.assume(gmxAmount < 1000000e18);\n\n        _depositGlp(tokenAmount, address(this));\n        _depositGmx(gmxAmount, address(this));\n\n        vm.warp(block.timestamp + secondsElapsed);\n\n        // Commented out due to \"Stack too deep...\" error\n        // uint256 expectedWethBalanceBeforeClaim = 0;\n        // uint256 expectedEsGmxBalanceBeforeClaim = 0;\n\n        assertEq(0, weth.balanceOf(address(pirexGmx)));\n        assertEq(0, stakedGmx.depositBalances(address(pirexGmx), esGmx));\n\n        uint256 previousStakedGmxBalance = rewardTrackerGmx.balanceOf(\n            address(pirexGmx)\n        );\n        uint256 expectedWETHRewardsGmx = _calculateRewards(\n            address(pirexGmx),\n            true,\n            true\n        );\n        uint256 expectedWETHRewardsGlp = _calculateRewards(\n            address(pirexGmx),\n            true,\n            false\n        );\n        uint256 expectedEsGmxRewardsGmx = _calculateRewards(\n            address(pirexGmx),\n            false,\n            true\n        );\n        uint256 expectedEsGmxRewardsGlp = _calculateRewards(\n            address(pirexGmx),\n            false,\n            false\n        );\n        uint256 expectedBnGmxRewards = calculateBnGmxRewards(address(pirexGmx));\n        uint256 expectedWETHRewards = expectedWETHRewardsGmx +\n            expectedWETHRewardsGlp;\n        uint256 expectedEsGmxRewards = expectedEsGmxRewardsGmx +\n            expectedEsGmxRewardsGlp;\n\n        vm.expectEmit(false, false, false, true, address(pirexGmx));\n\n        // Limited variable counts due to stack-too-deep issue\n        emit ClaimRewards(\n            expectedWETHRewards,\n            expectedEsGmxRewards,\n            expectedWETHRewardsGmx,\n            expectedWETHRewardsGlp,\n            expectedEsGmxRewardsGmx,\n            expectedEsGmxRewardsGlp\n        );\n\n        // Impersonate pirexRewards and claim WETH rewards\n        vm.prank(address(pirexRewards));\n\n        (\n            ERC20[] memory producerTokens,\n            ERC20[] memory rewardTokens,\n            uint256[] memory rewardAmounts\n        ) = pirexGmx.claimRewards();\n\n        assertEq(address(pxGmx), address(producerTokens[0]));\n        assertEq(address(pxGlp), address(producerTokens[1]));\n        assertEq(address(pxGmx), address(producerTokens[2]));\n        assertEq(address(pxGlp), address(producerTokens[3]));\n        assertEq(address(weth), address(rewardTokens[0]));\n        assertEq(address(weth), address(rewardTokens[1]));\n        assertEq(address(pxGmx), address(rewardTokens[2]));\n        assertEq(address(pxGmx), address(rewardTokens[3]));\n        assertEq(expectedWETHRewardsGmx, rewardAmounts[0]);\n        assertEq(expectedWETHRewardsGlp, rewardAmounts[1]);\n        assertEq(expectedEsGmxRewardsGmx, rewardAmounts[2]);\n        assertEq(expectedEsGmxRewardsGlp, rewardAmounts[3]);\n\n        // Commented out due to \"Stack too deep...\" error\n        // uint256 expectedWethBalanceAfterClaim = expectedWETHRewards;\n        // uint256 expectedEsGmxBalanceAfterClaim = expectedEsGmxRewards;\n\n        assertEq(expectedWETHRewards, weth.balanceOf(address(pirexGmx)));\n        assertEq(\n            expectedEsGmxRewards,\n            stakedGmx.depositBalances(address(pirexGmx), esGmx)\n        );\n\n        // Claimable reward amounts should all be zero post-claim\n        assertEq(0, _calculateRewards(address(pirexGmx), true, true));\n        assertEq(0, _calculateRewards(address(pirexGmx), true, false));\n        assertEq(0, _calculateRewards(address(pirexGmx), false, true));\n        assertEq(0, _calculateRewards(address(pirexGmx), false, false));\n        assertEq(0, calculateBnGmxRewards(address(pirexGmx)));\n\n        // Claimed esGMX rewards + MP should also be staked immediately\n        assertEq(\n            previousStakedGmxBalance +\n                expectedEsGmxRewards +\n                expectedBnGmxRewards,\n            rewardTrackerGmx.balanceOf(address(pirexGmx))\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        claimUserReward TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is not pirexRewards\n     */\n    function testCannotClaimUserRewardNotPirexRewards() external {\n        address token = address(weth);\n        uint256 amount = 1;\n        address receiver = address(this);\n\n        assertTrue(address(this) != pirexGmx.pirexRewards());\n\n        vm.expectRevert(PirexGmx.NotPirexRewards.selector);\n\n        pirexGmx.claimUserReward(token, amount, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: token is zero address\n     */\n    function testCannotClaimUserRewardTokenZeroAddress() external {\n        address invalidToken = address(0);\n        uint256 amount = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n        vm.prank(address(pirexRewards));\n\n        pirexGmx.claimUserReward(invalidToken, amount, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: amount is zero\n     */\n    function testCannotClaimUserRewardAmountZeroAmount() external {\n        address token = address(weth);\n        uint256 invalidAmount = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(PirexGmx.ZeroAmount.selector);\n        vm.prank(address(pirexRewards));\n\n        pirexGmx.claimUserReward(token, invalidAmount, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotClaimUserRewardRecipientZeroAddress() external {\n        address token = address(weth);\n        uint256 amount = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n        vm.prank(address(pirexRewards));\n\n        pirexGmx.claimUserReward(token, amount, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx success: claim user reward\n        @param  wethAmount   uint72  Amount of claimable WETH\n        @param  pxGmxAmount  uint80  Amount of claimable pxGMX\n     */\n    function testClaimUserReward(uint72 wethAmount, uint80 pxGmxAmount)\n        external\n    {\n        vm.assume(wethAmount > 0.001 ether);\n        vm.assume(wethAmount < 1000 ether);\n        vm.assume(pxGmxAmount != 0);\n        vm.assume(pxGmxAmount < 1000000e18);\n\n        address tokenWeth = address(weth);\n        address tokenPxGmx = address(pxGmx);\n        address receiver = address(this);\n\n        assertEq(0, weth.balanceOf(receiver));\n        assertEq(0, pxGmx.balanceOf(receiver));\n\n        // Mint and transfers tokens for user claim tests\n        vm.deal(address(this), wethAmount);\n\n        _mintWrappedToken(wethAmount, address(pirexGmx));\n\n        vm.prank(address(pirexGmx));\n\n        pxGmx.mint(address(pirexGmx), pxGmxAmount);\n\n        // Test claim via PirexRewards contract\n        vm.startPrank(address(pirexRewards));\n\n        pirexGmx.claimUserReward(tokenWeth, wethAmount, receiver);\n        pirexGmx.claimUserReward(tokenPxGmx, pxGmxAmount, receiver);\n\n        vm.stopPrank();\n\n        assertEq(weth.balanceOf(receiver), wethAmount);\n        assertEq(pxGmx.balanceOf(receiver), pxGmxAmount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setDelegationSpace TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetDelegationSpaceUnauthorized() external {\n        string memory space = \"test.eth\";\n        bool clear = false;\n        address unauthorizedCaller = _getUnauthorizedCaller();\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.setDelegationSpace(space, clear);\n    }\n\n    /**\n        @notice Test tx reversion: space is empty string\n     */\n    function testCannotSetDelegationSpaceEmptyString() external {\n        string memory invalidSpace = \"\";\n        bool clear = false;\n\n        vm.expectRevert(PirexGmx.EmptyString.selector);\n\n        pirexGmx.setDelegationSpace(invalidSpace, clear);\n    }\n\n    /**\n        @notice Test tx success: set delegation space\n        @param  clear  bool  Whether to clear the vote delegate\n     */\n    function testSetDelegationSpace(bool clear) external {\n        DelegateRegistry d = DelegateRegistry(pirexGmx.delegateRegistry());\n        address voteDelegate = address(this);\n\n        // Set the vote delegate before clearing it when setting new delegation space\n        pirexGmx.setVoteDelegate(voteDelegate);\n\n        assertEq(delegationSpace, pirexGmx.delegationSpace());\n        assertEq(\n            voteDelegate,\n            d.delegation(address(pirexGmx), delegationSpace)\n        );\n\n        string memory space = \"new.eth\";\n        bytes32 expectedDelegationSpace = bytes32(bytes(space));\n        address expectedVoteDelegate = clear ? address(0) : voteDelegate;\n\n        assertFalse(expectedDelegationSpace == delegationSpace);\n\n        vm.expectEmit(false, false, false, true, address(pirexGmx));\n\n        emit SetDelegationSpace(space, clear);\n\n        pirexGmx.setDelegationSpace(space, clear);\n\n        assertEq(expectedDelegationSpace, pirexGmx.delegationSpace());\n        assertEq(\n            expectedVoteDelegate,\n            d.delegation(address(pirexGmx), delegationSpace)\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setVoteDelegate TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetVoteDelegateUnauthorized() external {\n        address unauthorizedCaller = _getUnauthorizedCaller();\n        address delegate = address(this);\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.setVoteDelegate(delegate);\n    }\n\n    /**\n        @notice Test tx reversion: delegate is zero address\n     */\n    function testCannotSetVoteDelegateDelegateZeroAddress() external {\n        address invalidDelegate = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.setVoteDelegate(invalidDelegate);\n    }\n\n    /**\n        @notice Test tx success: set vote delegate\n     */\n    function testSetVoteDelegate() external {\n        address oldDelegate = delegateRegistry.delegation(\n            address(pirexGmx),\n            pirexGmx.delegationSpace()\n        );\n        address newDelegate = address(this);\n\n        assertTrue(oldDelegate != newDelegate);\n\n        vm.expectEmit(false, false, false, true, address(pirexGmx));\n\n        emit SetVoteDelegate(newDelegate);\n\n        pirexGmx.setVoteDelegate(newDelegate);\n\n        address delegate = delegateRegistry.delegation(\n            address(pirexGmx),\n            pirexGmx.delegationSpace()\n        );\n\n        assertEq(delegate, newDelegate);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        clearVoteDelegate TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotClearVoteDelegateUnauthorized() external {\n        address unauthorizedCaller = _getUnauthorizedCaller();\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.clearVoteDelegate();\n    }\n\n    /**\n        @notice Test tx reversion: clear with no delegate set\n     */\n    function testCannotClearVoteDelegateNoDelegate() external {\n        assertEq(\n            address(0),\n            delegateRegistry.delegation(\n                address(pirexGmx),\n                pirexGmx.delegationSpace()\n            )\n        );\n\n        vm.expectRevert(\"No delegate set\");\n\n        pirexGmx.clearVoteDelegate();\n    }\n\n    /**\n        @notice Test tx success: clear vote delegate\n     */\n    function testClearVoteDelegate() external {\n        pirexGmx.setDelegationSpace(\"test.eth\", false);\n\n        address voteDelegate = address(this);\n\n        // Set the vote delegate before clearing it when setting new delegation space\n        pirexGmx.setVoteDelegate(voteDelegate);\n\n        assertEq(\n            voteDelegate,\n            delegateRegistry.delegation(\n                address(pirexGmx),\n                pirexGmx.delegationSpace()\n            )\n        );\n\n        vm.expectEmit(false, false, false, true, address(pirexGmx));\n\n        emit ClearVoteDelegate();\n\n        pirexGmx.clearVoteDelegate();\n\n        assertEq(\n            address(0),\n            delegateRegistry.delegation(\n                address(pirexGmx),\n                pirexGmx.delegationSpace()\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPauseState TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPauseStateUnauthorized() external {\n        address unauthorizedCaller = _getUnauthorizedCaller();\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.setPauseState(true);\n    }\n\n    /**\n        @notice Test tx reversion: contract is not paused\n     */\n    function testCannotSetPauseStateNotPaused() external {\n        assertEq(false, pirexGmx.paused());\n\n        vm.expectRevert(NOT_PAUSED_ERROR);\n\n        pirexGmx.setPauseState(false);\n    }\n\n    /**\n        @notice Test tx reversion: contract is paused\n     */\n    function testCannotSetPauseStatePaused() external {\n        _pauseContract();\n\n        vm.expectRevert(PAUSED_ERROR);\n\n        pirexGmx.setPauseState(true);\n    }\n\n    /**\n        @notice Test tx success: set pause state\n     */\n    function testSetPauseState() external {\n        assertEq(false, pirexGmx.paused());\n\n        _pauseContract();\n\n        pirexGmx.setPauseState(false);\n\n        assertEq(false, pirexGmx.paused());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        initiateMigration TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is not paused\n     */\n    function testCannotInitiateMigrationNotPaused() external {\n        assertEq(false, pirexGmx.paused());\n\n        address newContract = address(this);\n\n        vm.expectRevert(NOT_PAUSED_ERROR);\n\n        pirexGmx.initiateMigration(newContract);\n    }\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotInitiateMigrationUnauthorized() external {\n        _pauseContract();\n\n        address unauthorizedCaller = _getUnauthorizedCaller();\n        address newContract = address(this);\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.initiateMigration(newContract);\n    }\n\n    /**\n        @notice Test tx reversion: newContract is zero address\n     */\n    function testCannotInitiateMigrationNewContractZeroAddress() external {\n        _pauseContract();\n\n        address invalidNewContract = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.initiateMigration(invalidNewContract);\n    }\n\n    /**\n        @notice Test tx success: initiate migration\n     */\n    function testInitiateMigration() external {\n        _pauseContract();\n\n        address oldContract = address(pirexGmx);\n        address newContract = address(this);\n        address expectedPendingReceiverBeforeInitation = address(0);\n\n        assertEq(\n            expectedPendingReceiverBeforeInitation,\n            REWARD_ROUTER_V2.pendingReceivers(oldContract)\n        );\n\n        vm.expectEmit(false, false, false, true, address(pirexGmx));\n\n        emit InitiateMigration(newContract);\n\n        pirexGmx.initiateMigration(newContract);\n\n        address expectedPendingReceiverAfterInitation = newContract;\n\n        // Should properly set the pendingReceivers state\n        assertEq(\n            expectedPendingReceiverAfterInitation,\n            REWARD_ROUTER_V2.pendingReceivers(oldContract)\n        );\n\n        // Should also set the migratedTo state variable\n        assertEq(expectedPendingReceiverAfterInitation, pirexGmx.migratedTo());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        migrateReward TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is not paused\n     */\n    function testCannotMigrateRewardNotPaused() external {\n        assertEq(false, pirexGmx.paused());\n\n        vm.expectRevert(NOT_PAUSED_ERROR);\n\n        pirexGmx.migrateReward();\n    }\n\n    /**\n        @notice Test tx reversion: caller is not the migration target\n     */\n    function testCannotMigrateRewardNotMigratedTo() external {\n        _pauseContract();\n\n        vm.expectRevert(PirexGmx.NotMigratedTo.selector);\n\n        pirexGmx.migrateReward();\n    }\n\n    /**\n        @notice Test tx reversion: pending migration exists\n     */\n    function testCannotMigrateRewardPendingMigration() external {\n        _pauseContract();\n\n        uint96 rewardAmount = 1 ether;\n        address oldContract = address(pirexGmx);\n        address newContract = address(this);\n\n        // Test with WETH as the base reward token\n        _mintWrappedToken(rewardAmount, oldContract);\n\n        pirexGmx.initiateMigration(newContract);\n\n        vm.expectRevert(PirexGmx.PendingMigration.selector);\n\n        vm.prank(newContract);\n\n        // Should revert since the method should only be done after full migration\n        pirexGmx.migrateReward();\n    }\n\n    /**\n        @notice Test tx success: migrate base reward\n        @param  rewardAmount  uint96  Reward amount\n     */\n    function testMigrateReward(uint96 rewardAmount) external {\n        vm.assume(rewardAmount != 0);\n        vm.assume(rewardAmount < 1000 ether);\n\n        _pauseContract();\n\n        address oldContract = address(pirexGmx);\n        address newContract = address(this);\n\n        // Test with WETH as the base reward token\n        _mintWrappedToken(rewardAmount, oldContract);\n\n        pirexGmx.initiateMigration(newContract);\n\n        // Simulate full migration without triggering migrateReward\n        // so we can test it separately\n        vm.startPrank(newContract);\n\n        pirexRewards.harvest();\n\n        REWARD_ROUTER_V2.acceptTransfer(oldContract);\n\n        pirexGmx.migrateReward();\n\n        vm.stopPrank();\n\n        // Confirm the base reward balances for both contracts\n        assertEq(0, weth.balanceOf(oldContract));\n        assertEq(rewardAmount, weth.balanceOf(newContract));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        completeMigration TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: contract is not paused\n     */\n    function testCannotCompleteMigrationNotPaused() external {\n        assertEq(false, pirexGmx.paused());\n\n        address oldContract = address(this);\n\n        vm.expectRevert(NOT_PAUSED_ERROR);\n\n        pirexGmx.completeMigration(oldContract);\n    }\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotCompleteMigrationUnauthorized() external {\n        _pauseContract();\n\n        address unauthorizedCaller = _getUnauthorizedCaller();\n        address oldContract = address(pirexGmx);\n\n        vm.expectRevert(UNAUTHORIZED_ERROR);\n        vm.prank(unauthorizedCaller);\n\n        pirexGmx.completeMigration(oldContract);\n    }\n\n    /**\n        @notice Test tx reversion: oldContract is zero address\n     */\n    function testCannotCompleteMigrationZeroAddress() external {\n        _pauseContract();\n\n        address invalidOldContract = address(0);\n\n        vm.expectRevert(PirexGmx.ZeroAddress.selector);\n\n        pirexGmx.completeMigration(invalidOldContract);\n    }\n\n    /**\n        @notice Test tx reversion due to the caller not being the assigned new contract\n     */\n    function testCannotCompleteMigrationInvalidNewContract() external {\n        _pauseContract();\n\n        address oldContract = address(pirexGmx);\n        address newContract = address(this);\n\n        pirexGmx.initiateMigration(newContract);\n\n        assertEq(newContract, REWARD_ROUTER_V2.pendingReceivers(oldContract));\n\n        // Deploy a test contract but not assign it as the migration target\n        PirexGmx newPirexGmx = new PirexGmx(\n            address(pxGmx),\n            address(pxGlp),\n            address(pirexFees),\n            address(pirexRewards),\n            address(delegateRegistry),\n            REWARD_ROUTER_V2.weth(),\n            REWARD_ROUTER_V2.gmx(),\n            REWARD_ROUTER_V2.esGmx(),\n            address(REWARD_ROUTER_V2),\n            address(STAKED_GLP)\n        );\n\n        vm.expectRevert(\"RewardRouter: transfer not signalled\");\n\n        newPirexGmx.completeMigration(oldContract);\n    }\n\n    /**\n        @notice Test tx success: completing migration\n     */\n    function testCompleteMigration() external {\n        // Perform GMX deposit for balance tests after migration\n        uint256 assets = 1e18;\n        address receiver = address(this);\n        address oldContract = address(pirexGmx);\n\n        _mintApproveGmx(assets, address(this), oldContract, assets);\n        pirexGmx.depositGmx(assets, receiver);\n\n        // Perform GLP deposit for balance tests after migration\n        uint256 etherAmount = 1 ether;\n\n        vm.deal(address(this), etherAmount);\n\n        pirexGmx.depositGlpETH{value: etherAmount}(1, 1, receiver);\n\n        // Time skip to bypass the cooldown duration\n        vm.warp(block.timestamp + 1 days);\n\n        // Store the staked balances and rewards for later validations\n        uint256 oldStakedGmxBalance = rewardTrackerGmx.balanceOf(oldContract);\n        uint256 oldStakedGlpBalance = feeStakedGlp.balanceOf(oldContract);\n        uint256 oldEsGmxClaimable = _calculateRewards(\n            oldContract,\n            false,\n            true\n        ) + _calculateRewards(oldContract, false, false);\n        uint256 oldMpBalance = rewardTrackerMp.claimable(oldContract);\n        uint256 oldBaseRewardClaimable = _calculateRewards(\n            oldContract,\n            true,\n            true\n        ) + _calculateRewards(oldContract, true, false);\n\n        // Pause the contract before proceeding\n        _pauseContract();\n\n        // Deploy the new contract for migration tests\n        PirexGmx newPirexGmx = new PirexGmx(\n            address(pxGmx),\n            address(pxGlp),\n            address(pirexFees),\n            address(pirexRewards),\n            address(delegateRegistry),\n            REWARD_ROUTER_V2.weth(),\n            REWARD_ROUTER_V2.gmx(),\n            REWARD_ROUTER_V2.esGmx(),\n            address(REWARD_ROUTER_V2),\n            address(STAKED_GLP)\n        );\n\n        address newContract = address(newPirexGmx);\n\n        assertEq(REWARD_ROUTER_V2.pendingReceivers(oldContract), address(0));\n\n        pirexGmx.initiateMigration(newContract);\n\n        // Should properly set the pendingReceivers state\n        assertEq(REWARD_ROUTER_V2.pendingReceivers(oldContract), newContract);\n\n        vm.expectEmit(false, false, false, true, address(newPirexGmx));\n\n        emit CompleteMigration(oldContract);\n\n        // Complete the migration using the new contract\n        newPirexGmx.completeMigration(oldContract);\n\n        // Should properly clear the pendingReceivers state\n        assertEq(REWARD_ROUTER_V2.pendingReceivers(oldContract), address(0));\n\n        // Confirm that the token balances and claimables for old contract are correct\n        assertEq(0, rewardTrackerGmx.balanceOf(oldContract));\n        assertEq(0, feeStakedGlp.balanceOf(oldContract));\n        assertEq(0, stakedGmx.claimable(oldContract));\n        assertEq(0, feeStakedGlp.claimable(oldContract));\n        assertEq(0, rewardTrackerMp.claimable(oldContract));\n\n        // Confirm that the staked token balances for new contract are correct\n        // For Staked GMX balance, due to compounding in the migration,\n        // all pending claimable esGMX and MP are automatically staked\n        assertEq(\n            oldStakedGmxBalance + oldEsGmxClaimable + oldMpBalance,\n            rewardTrackerGmx.balanceOf(newContract)\n        );\n        assertEq(oldStakedGlpBalance, feeStakedGlp.balanceOf(newContract));\n\n        // Confirm that the remaining base reward has also been migrated\n        assertEq(0, pirexGmx.gmxBaseReward().balanceOf(oldContract));\n        assertEq(\n            oldBaseRewardClaimable,\n            pirexGmx.gmxBaseReward().balanceOf(newContract)\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "PirexGmx.sol",
            "PirexGmx.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PirexGmx.initiateMigration function",
                "Type": "Blocking Function",
                "Description": "PirexGmx.initiateMigration can be blocked so contract will not be able to migrate his funds to another contract using gmx.",
                "Repair": "Think about how to make contract ensure that he doesn't control any gmxVester and glpVester tokens before migration."
            },
            {
                "Location": "configureGmxState() function of PirexGmx contract",
                "Type": "Improper use of safeApprove()",
                "Description": "The configureGmxState() function doesn't properly call safeApprove() for stakedGmx address, which can cause different behavior in setContract() and configureGmxState() for handling stakedGmx address changes, reversion of calls to configureGmxState() in certain scenarios, possibility of losing all GMX balance of PirexGmx contract if old stakedGmx addresses are compromised, and contract getting stuck in an unrecoverable state if configureGmxState() is called multiple times and stakedGmx variable's value has been changed multiple times.",
                "Repair": "Reset the spending approval of old stakedGmx address to zero before setting approval for new stakedGmx address"
            },
            {
                "Location": "_calculateRewards() function in PirexGmx contract",
                "Type": "Division by zero",
                "Description": "The _calculateRewards() function in PirexGmx contract does not handle reward calculation properly, and it would revert when totalSupply() is zero which will cause claimRewards() to revert if one of 4 rewardTracker's totalSupply was zero.",
                "Repair": "Check that totalSupply() is not zero before using it"
            },
            {
                "Location": "PirexGmx.sol contract",
                "Type": "Blocked Redemption",
                "Description": "The redeem related functions are likely to be blocked due to the cooldownDuration limit on redeem/unstake in the GlpManager contract of GMX. This limitation is user-based, and PirexGmx contract is one such user. There are 3 risks that can block redemption for Pirex users: normal case, attack case, and GMX adjusts protocol parameters.",
                "Repair": "Reserve some time range for redemption only. e.g. 1 of every 7 days."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {AutoPxGmx} from \"src/vaults/AutoPxGmx.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {Helper} from \"./Helper.sol\";\n\ncontract AutoPxGmxTest is Helper {\n    event PoolFeeUpdated(uint24 _poolFee);\n    event Compounded(\n        address indexed caller,\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint256 wethAmountIn,\n        uint256 gmxAmountOut,\n        uint256 pxGmxMintAmount,\n        uint256 totalFee,\n        uint256 incentive\n    );\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n        @notice Provision reward state to test compounding of rewards\n        @param  assets            uint256    GMX/pxGMX amount to deposit in the vault\n        @param  receivers         address[]  Receivers of the apxGMX tokens\n        @param  secondsElapsed    uint256    Seconds to forward timestamp\n        @return wethRewardState   uint256    WETH reward state\n        @return pxGmxRewardState  uint256    pxGMX reward state\n        @return shareBalances     uint256[]  Receivers' apxGMX balances\n     */\n    function _provisionRewardState(\n        uint256 assets,\n        address[] memory receivers,\n        uint256 secondsElapsed\n    )\n        internal\n        returns (\n            uint256 wethRewardState,\n            uint256 pxGmxRewardState,\n            uint256[] memory shareBalances\n        )\n    {\n        uint256 rLen = receivers.length;\n        shareBalances = new uint256[](rLen);\n\n        for (uint256 i; i < rLen; ++i) {\n            address receiver = receivers[i];\n\n            _depositGmx(assets, receiver);\n\n            vm.startPrank(receiver);\n\n            pxGmx.approve(address(autoPxGmx), assets);\n\n            shareBalances[i] = autoPxGmx.deposit(assets, receiver);\n\n            vm.stopPrank();\n        }\n\n        vm.warp(block.timestamp + secondsElapsed);\n\n        pirexRewards.addRewardToken(pxGmx, weth);\n        pirexRewards.addRewardToken(pxGmx, pxGmx);\n        pirexRewards.harvest();\n\n        wethRewardState = pirexRewards.getRewardState(pxGmx, weth);\n        pxGmxRewardState = pirexRewards.getRewardState(pxGmx, pxGmx);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPoolFee TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPoolFeeUnauthorized() external {\n        uint24 fee = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setPoolFee(fee);\n    }\n\n    /**\n        @notice Test tx reversion: pool fee is zero\n     */\n    function testCannotSetPoolFeeZeroAmount() external {\n        uint24 invalidFee = 0;\n\n        vm.expectRevert(AutoPxGmx.ZeroAmount.selector);\n\n        autoPxGmx.setPoolFee(invalidFee);\n    }\n\n    /**\n        @notice Test tx success: set pool fee\n     */\n    function testSetPoolFee() external {\n        uint24 initialPoolFee = autoPxGmx.poolFee();\n        uint24 fee = 10000;\n        uint24 expectedPoolFee = fee;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit PoolFeeUpdated(expectedPoolFee);\n\n        autoPxGmx.setPoolFee(fee);\n\n        assertEq(expectedPoolFee, autoPxGmx.poolFee());\n        assertTrue(expectedPoolFee != initialPoolFee);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setWithdrawalPenalty TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetWithdrawalPenaltyUnauthorized() external {\n        // Define function arguments\n        uint256 penalty = 1;\n\n        // Define post-transition/upcoming state or effects\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        // Execute state transition\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setWithdrawalPenalty(penalty);\n    }\n\n    /**\n        @notice Test tx reversion: penalty exceeds max\n     */\n    function testCannotSetWithdrawalPenaltyExceedsMax() external {\n        uint256 invalidPenalty = autoPxGmx.MAX_WITHDRAWAL_PENALTY() + 1;\n\n        vm.expectRevert(AutoPxGmx.ExceedsMax.selector);\n\n        autoPxGmx.setWithdrawalPenalty(invalidPenalty);\n    }\n\n    /**\n        @notice Test tx success: set withdrawal penalty\n     */\n    function testSetWithdrawalPenalty() external {\n        uint256 initialWithdrawalPenalty = autoPxGmx.withdrawalPenalty();\n        uint256 penalty = 1;\n        uint256 expectedWithdrawalPenalty = penalty;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit WithdrawalPenaltyUpdated(expectedWithdrawalPenalty);\n\n        autoPxGmx.setWithdrawalPenalty(penalty);\n\n        assertEq(expectedWithdrawalPenalty, autoPxGmx.withdrawalPenalty());\n        assertTrue(expectedWithdrawalPenalty != initialWithdrawalPenalty);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPlatformFee TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPlatformFeeUnauthorized() external {\n        uint256 fee = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setPlatformFee(fee);\n    }\n\n    /**\n        @notice Test tx reversion: fee exceeds max\n     */\n    function testCannotSetPlatformFeeExceedsMax() external {\n        uint256 invalidFee = autoPxGmx.MAX_PLATFORM_FEE() + 1;\n\n        vm.expectRevert(AutoPxGmx.ExceedsMax.selector);\n\n        autoPxGmx.setPlatformFee(invalidFee);\n    }\n\n    /**\n        @notice Test tx success: set platform fee\n     */\n    function testSetPlatformFee() external {\n        uint256 initialPlatformFee = autoPxGmx.platformFee();\n        uint256 fee = 1;\n        uint256 expectedPlatformFee = fee;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit PlatformFeeUpdated(expectedPlatformFee);\n\n        autoPxGmx.setPlatformFee(fee);\n\n        assertEq(expectedPlatformFee, autoPxGmx.platformFee());\n        assertTrue(expectedPlatformFee != initialPlatformFee);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setCompoundIncentive TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetCompoundIncentiveUnauthorized() external {\n        uint256 incentive = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setCompoundIncentive(incentive);\n    }\n\n    /**\n        @notice Test tx reversion: incentive exceeds max\n     */\n    function testCannotSetCompoundIncentiveExceedsMax() external {\n        uint256 invalidIncentive = autoPxGmx.MAX_COMPOUND_INCENTIVE() + 1;\n\n        vm.expectRevert(AutoPxGmx.ExceedsMax.selector);\n\n        autoPxGmx.setCompoundIncentive(invalidIncentive);\n    }\n\n    /**\n        @notice Test tx success: set compound incentive percent\n     */\n    function testSetCompoundIncentive() external {\n        uint256 initialCompoundIncentive = autoPxGmx.compoundIncentive();\n        uint256 incentive = 1;\n        uint256 expectedCompoundIncentive = incentive;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit CompoundIncentiveUpdated(expectedCompoundIncentive);\n\n        autoPxGmx.setCompoundIncentive(incentive);\n\n        assertEq(expectedCompoundIncentive, autoPxGmx.compoundIncentive());\n        assertTrue(expectedCompoundIncentive != initialCompoundIncentive);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPlatform TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPlatformUnauthorized() external {\n        address platform = address(this);\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGmx.setPlatform(platform);\n    }\n\n    /**\n        @notice Test tx reversion: platform is zero address\n     */\n    function testCannotSetPlatformZeroAddress() external {\n        address invalidPlatform = address(0);\n\n        vm.expectRevert(AutoPxGmx.ZeroAddress.selector);\n\n        autoPxGmx.setPlatform(invalidPlatform);\n    }\n\n    /**\n        @notice Test tx success: set platform\n     */\n    function testSetPlatform() external {\n        address initialPlatform = autoPxGmx.platform();\n        address platform = address(this);\n        address expectedPlatform = platform;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGmx));\n\n        emit PlatformUpdated(expectedPlatform);\n\n        autoPxGmx.setPlatform(platform);\n\n        assertEq(expectedPlatform, autoPxGmx.platform());\n        assertTrue(expectedPlatform != initialPlatform);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        totalAssets TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice  Test tx success: return the total assets\n    */\n    function testTotalAssets() external {\n        uint256 initialTotalAssets = autoPxGmx.totalAssets();\n        uint256 assets = 1;\n        address receiver = address(this);\n        uint256 expectedTotalAssets = assets;\n\n        _depositGmx(assets, receiver);\n        pxGmx.approve(address(autoPxGmx), assets);\n        autoPxGmx.deposit(assets, receiver);\n\n        assertEq(expectedTotalAssets, autoPxGmx.totalAssets());\n        assertTrue(expectedTotalAssets != initialTotalAssets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        compound TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: fee is invalid param\n     */\n    function testCannotCompoundFeeInvalidParam() external {\n        uint24 invalidFee = 0;\n        uint256 amountOutMinimum = 1;\n        uint160 sqrtPriceLimitX96 = 1;\n        bool optOutIncentive = true;\n\n        vm.expectRevert(AutoPxGmx.InvalidParam.selector);\n\n        autoPxGmx.compound(\n            invalidFee,\n            amountOutMinimum,\n            sqrtPriceLimitX96,\n            optOutIncentive\n        );\n    }\n\n    /**\n        @notice Test tx reversion: amountOutMinimum is invalid param\n     */\n    function testCannotCompoundAmountOutMinimumInvalidParam() external {\n        uint24 fee = 3000;\n        uint256 invalidAmountOutMinimum = 0;\n        uint160 sqrtPriceLimitX96 = 1;\n        bool optOutIncentive = true;\n\n        vm.expectRevert(AutoPxGmx.InvalidParam.selector);\n\n        autoPxGmx.compound(\n            fee,\n            invalidAmountOutMinimum,\n            sqrtPriceLimitX96,\n            optOutIncentive\n        );\n    }\n\n    /**\n        @notice Test tx success: compound pxGMX rewards into more pxGMX\n        @param  gmxAmount       uint96  Amount of pxGMX to get from the deposit\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testCompound(uint96 gmxAmount, uint32 secondsElapsed) external {\n        vm.assume(gmxAmount > 5e17);\n        vm.assume(gmxAmount < 100000e18);\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n\n        address[] memory receivers = new address[](1);\n        receivers[0] = address(this);\n        (\n            uint256 wethRewardState,\n            uint256 pxGmxRewardState,\n\n        ) = _provisionRewardState(gmxAmount, receivers, secondsElapsed);\n        uint256 totalAssetsBeforeCompound = autoPxGmx.totalAssets();\n        uint256 shareToAssetAmountBeforeCompound = autoPxGmx.convertToAssets(\n            autoPxGmx.balanceOf(address(this))\n        );\n\n        // Confirm current state prior to primary state mutating action\n        assertEq(gmxAmount, autoPxGmx.balanceOf(address(this)));\n        assertEq(gmxAmount, totalAssetsBeforeCompound);\n        assertGt(wethRewardState, 0);\n        assertGt(pxGmxRewardState, 0);\n        assertEq(0, pxGmx.balanceOf(autoPxGmx.owner()));\n\n        vm.expectEmit(true, false, false, false, address(autoPxGmx));\n\n        emit Compounded(testAccounts[0], 3000, 1, 0, 0, 0, 0, 0, 0);\n\n        // Call as testAccounts[0] to test compound incentive transfer\n        vm.prank(testAccounts[0]);\n\n        // Input literal argument values due to callstack depth error\n        (\n            uint256 wethAmountIn,\n            uint256 gmxAmountOut,\n            uint256 pxGmxMintAmount,\n            uint256 totalFee,\n            uint256 incentive\n        ) = autoPxGmx.compound(3000, 1, 0, false);\n\n        uint256 expectedTotalFee = ((pxGmxMintAmount + pxGmxRewardState) *\n            autoPxGmx.platformFee()) / autoPxGmx.FEE_DENOMINATOR();\n        uint256 expectedCompoundIncentive = (totalFee *\n            autoPxGmx.compoundIncentive()) / autoPxGmx.FEE_DENOMINATOR();\n        uint256 expectedPlatformFee = expectedTotalFee -\n            expectedCompoundIncentive;\n        uint256 expectedTotalAssets = totalAssetsBeforeCompound +\n            pxGmxMintAmount +\n            pxGmxRewardState -\n            expectedTotalFee;\n        uint256 expectedShareToAssetAmountDifference = ((autoPxGmx.balanceOf(\n            address(this)\n        ) * expectedTotalAssets) / autoPxGmx.totalSupply()) -\n            shareToAssetAmountBeforeCompound;\n\n        assertEq(wethRewardState, wethAmountIn);\n\n        // // This will not always be the case in production (external party transfers GMX to vault)\n        // // But for this test, this assertion should hold true\n        assertEq(gmxAmountOut, pxGmxMintAmount);\n\n        assertEq(\n            gmxAmountOut + pxGmxRewardState - expectedTotalFee,\n            autoPxGmx.totalAssets() - totalAssetsBeforeCompound\n        );\n        assertEq(\n            pxGmxMintAmount + pxGmxRewardState - expectedTotalFee,\n            autoPxGmx.totalAssets() - totalAssetsBeforeCompound\n        );\n        assertGt(expectedTotalAssets, totalAssetsBeforeCompound);\n        assertEq(expectedTotalAssets, autoPxGmx.totalAssets());\n        assertEq(\n            expectedShareToAssetAmountDifference,\n            autoPxGmx.convertToAssets(autoPxGmx.balanceOf(address(this))) -\n                shareToAssetAmountBeforeCompound\n        );\n        assertEq(expectedTotalFee, totalFee);\n        assertEq(expectedCompoundIncentive, incentive);\n        assertEq(expectedPlatformFee + expectedCompoundIncentive, totalFee);\n        assertEq(expectedPlatformFee, pxGmx.balanceOf(autoPxGmx.owner()));\n        assertEq(expectedCompoundIncentive, pxGmx.balanceOf(testAccounts[0]));\n        assertLt(\n            shareToAssetAmountBeforeCompound,\n            autoPxGmx.convertToAssets(autoPxGmx.balanceOf(address(this)))\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        withdraw TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: withdraw from vault and assert the withdrawn assets\n        @param  gmxAmount       uint96  Amount of pxGMX to get from the deposit\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testWithdraw(uint96 gmxAmount, uint32 secondsElapsed) external {\n        vm.assume(gmxAmount > 5e17);\n        vm.assume(gmxAmount < 100000e18);\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n\n        address[] memory receivers = new address[](testAccounts.length);\n        uint256[] memory assetBalances = new uint256[](testAccounts.length);\n        for (uint256 i; i < testAccounts.length; ++i) {\n            receivers[i] = testAccounts[i];\n        }\n\n        (, , uint256[] memory shareBalances) = _provisionRewardState(\n            gmxAmount,\n            receivers,\n            secondsElapsed\n        );\n\n        // Store current redemption values before the first compound trigger\n        for (uint256 i; i < testAccounts.length; ++i) {\n            assetBalances[i] = autoPxGmx.previewRedeem(shareBalances[i]);\n        }\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            uint256 initialShare = autoPxGmx.balanceOf(testAccounts[i]);\n\n            assertEq(shareBalances[i], initialShare);\n\n            uint256 initialSupply = autoPxGmx.totalSupply();\n\n            // Withdraw from the vault and assert the updated assets\n            vm.prank(testAccounts[i]);\n\n            // Attempt to withdraw using previous asset snapshot before compound,\n            // which means the user might still have some leftover of the share due to the compound call\n            autoPxGmx.withdraw(\n                assetBalances[i],\n                testAccounts[i],\n                testAccounts[i]\n            );\n\n            // Withdrawal should still decrement the totalSupply and user shares\n            // Using approximation since we can't get exact amount of new GMX from the compound trigger\n            // before triggering it via the withdraw call\n            assertLe(initialSupply - initialShare, autoPxGmx.totalSupply());\n            assertGe(autoPxGmx.balanceOf(testAccounts[i]), 0);\n\n            // Since we use withdraw, the actual received pxGmx should be equal to the\n            // previously stored redeem preview balance\n            assertEq(pxGmx.balanceOf(testAccounts[i]), assetBalances[i]);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        redeem TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: redeem from vault and assert the redeemed assets\n        @param  gmxAmount       uint96  Amount of pxGMX to get from the deposit\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testRedeem(uint96 gmxAmount, uint32 secondsElapsed) external {\n        vm.assume(gmxAmount > 5e17);\n        vm.assume(gmxAmount < 100000e18);\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n\n        address[] memory receivers = new address[](testAccounts.length);\n        uint256[] memory assetBalances = new uint256[](testAccounts.length);\n        for (uint256 i; i < testAccounts.length; ++i) {\n            receivers[i] = testAccounts[i];\n        }\n\n        (, , uint256[] memory shareBalances) = _provisionRewardState(\n            gmxAmount,\n            receivers,\n            secondsElapsed\n        );\n\n        // Store current redemption values before the first compound trigger\n        for (uint256 i; i < testAccounts.length; ++i) {\n            assetBalances[i] = autoPxGmx.previewRedeem(shareBalances[i]);\n        }\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            uint256 initialShare = autoPxGmx.balanceOf(testAccounts[i]);\n\n            assertEq(shareBalances[i], initialShare);\n\n            uint256 initialSupply = autoPxGmx.totalSupply();\n\n            // Redeem from the vault and assert the updated assets\n            vm.prank(testAccounts[i]);\n\n            autoPxGmx.redeem(initialShare, testAccounts[i], testAccounts[i]);\n\n            // Redemption should still decrement the totalSupply and user shares\n            assertEq(initialSupply - initialShare, autoPxGmx.totalSupply());\n            assertEq(0, autoPxGmx.balanceOf(testAccounts[i]));\n\n            // Also check the actual redeemed pxGMX amount compared to the preview before the first compound\n            assertGt(pxGmx.balanceOf(testAccounts[i]), assetBalances[i]);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGmx TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: amount is zero\n     */\n    function testCannotDepositGmxAmountZeroAmount() external {\n        uint256 invalidAmount = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGmx.ZeroAmount.selector);\n\n        autoPxGmx.depositGmx(invalidAmount, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: receiver is the zero address\n     */\n    function testCannotDepositGmxReceiverZeroAddress() external {\n        uint256 amount = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(AutoPxGmx.ZeroAddress.selector);\n\n        autoPxGmx.depositGmx(amount, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx success: deposit GMX for apxGMX\n     */\n    function testDepositGmx() external {\n        uint256 amount = 1e18;\n        address receiver = address(this);\n        uint256 depositFee = 10000;\n\n        pirexGmx.setFee(PirexGmx.Fees.Deposit, depositFee);\n\n        (uint256 expectedAssets, ) = _computeAssetAmounts(\n            PirexGmx.Fees.Deposit,\n            amount\n        );\n        uint256 expectedShares = autoPxGmx.previewDeposit(expectedAssets);\n\n        _mintApproveGmx(amount, address(this), address(autoPxGmx), amount);\n\n        assertTrue(amount == gmx.balanceOf(address(this)));\n        assertTrue(0 == autoPxGmx.totalAssets());\n        assertTrue(0 == autoPxGmx.totalSupply());\n\n        vm.expectEmit(true, true, false, false, address(autoPxGmx));\n\n        emit Deposit(receiver, receiver, expectedAssets, expectedShares);\n\n        autoPxGmx.depositGmx(amount, receiver);\n\n        assertTrue(0 == gmx.balanceOf(address(this)));\n        assertTrue(expectedAssets == autoPxGmx.totalAssets());\n        assertTrue(expectedShares == autoPxGmx.totalSupply());\n    }\n\n    /**\n        @notice Test tx success: deposit GMX for apxGMX (fuzz)\n     */\n    function testDepositGmxFuzz(\n        uint80 amount,\n        uint24 depositFee,\n        bool separateCaller,\n        uint8 multiplier\n    ) external {\n        vm.assume(amount > 1e15);\n        vm.assume(amount < 10000e18);\n        vm.assume(depositFee != 0);\n        vm.assume(depositFee <= feeMax);\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        pirexGmx.setFee(PirexGmx.Fees.Deposit, depositFee);\n\n        uint256 expectedTotalAssets;\n        uint256 expectedTotalSupply;\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address receiver = testAccounts[i];\n            address caller = separateCaller ? address(this) : receiver;\n            uint256 amountWithMultiplier = uint256(amount) *\n                uint256(multiplier);\n            (uint256 expectedAssets, ) = _computeAssetAmounts(\n                PirexGmx.Fees.Deposit,\n                amountWithMultiplier\n            );\n            uint256 expectedShares = autoPxGmx.previewDeposit(expectedAssets);\n\n            expectedTotalAssets += expectedAssets;\n            expectedTotalSupply += expectedShares;\n\n            _mintApproveGmx(\n                amountWithMultiplier,\n                caller,\n                address(autoPxGmx),\n                amountWithMultiplier\n            );\n\n            vm.prank(caller);\n            vm.expectEmit(true, true, false, false, address(autoPxGmx));\n\n            emit Deposit(caller, receiver, expectedAssets, expectedShares);\n\n            autoPxGmx.depositGmx(amountWithMultiplier, receiver);\n\n            assertTrue(expectedShares == autoPxGmx.balanceOf(receiver));\n            assertTrue(expectedTotalAssets == autoPxGmx.totalAssets());\n            assertTrue(expectedTotalSupply == autoPxGmx.totalSupply());\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\nimport {IV3SwapRouter} from \"src/interfaces/IV3SwapRouter.sol\";\n\ncontract AutoPxGmx is ReentrancyGuard, Owned, PirexERC4626 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    IV3SwapRouter public constant SWAP_ROUTER =\n        IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n\n    // Uniswap pool fee\n    uint24 public poolFee = 3000;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    ERC20 public immutable gmxBaseReward;\n    ERC20 public immutable gmx;\n\n    event PoolFeeUpdated(uint24 _poolFee);\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint256 gmxBaseRewardAmountIn,\n        uint256 gmxAmountOut,\n        uint256 pxGmxMintAmount,\n        uint256 totalFee,\n        uint256 incentive\n    );\n\n    error ZeroAmount();\n    error ZeroAddress();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error AlreadySet();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _gmx            address  GMX token contract address\n        @param  _asset          address  Asset address (e.g. pxGMX)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGMX)\n        @param  _symbol         string   Asset symbol (e.g. apxGMX)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _gmx,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) Owned(msg.sender) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_gmx == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        gmx = ERC20(_gmx);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(SWAP_ROUTER), type(uint256).max);\n        gmx.safeApprove(_platform, type(uint256).max);\n    }\n\n    /**\n        @notice Set the Uniswap pool fee\n        @param  _poolFee  uint24  Uniswap pool fee\n     */\n    function setPoolFee(uint24 _poolFee) external onlyOwner {\n        if (_poolFee == 0) revert ZeroAmount();\n\n        poolFee = _poolFee;\n\n        emit PoolFeeUpdated(_poolFee);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGMX custodied by the AutoPxGmx contract\n        @return uint256  Amount of pxGMX custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares  uint256  Shares\n        @return uint256  Assets\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets  uint256  Assets\n        @return uint256  Shares\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGMX rewards before depositing\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(poolFee, 1, 0, true);\n    }\n\n    /**\n        @notice Compound pxGMX rewards\n        @param  fee                    uint24   Uniswap pool tier fee\n        @param  amountOutMinimum       uint256  Outbound token swap amount\n        @param  sqrtPriceLimitX96      uint160  Swap price impact limit (optional)\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  GMX base reward inbound swap amount\n        @return gmxAmountOut           uint256  GMX outbound swap amount\n        @return pxGmxMintAmount        uint256  pxGMX minted when depositing GMX\n        @return totalFee               uint256  Total platform fee\n        @return incentive              uint256  Compound incentive\n     */\n    function compound(\n        uint24 fee,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 gmxAmountOut,\n            uint256 pxGmxMintAmount,\n            uint256 totalFee,\n            uint256 incentive\n        )\n    {\n        if (fee == 0) revert InvalidParam();\n        if (amountOutMinimum == 0) revert InvalidParam();\n\n        uint256 assetsBeforeClaim = asset.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n\n        // Swap entire reward balance for GMX\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            gmxAmountOut = SWAP_ROUTER.exactInputSingle(\n                IV3SwapRouter.ExactInputSingleParams({\n                    tokenIn: address(gmxBaseReward),\n                    tokenOut: address(gmx),\n                    fee: fee,\n                    recipient: address(this),\n                    amountIn: gmxBaseRewardAmountIn,\n                    amountOutMinimum: amountOutMinimum,\n                    sqrtPriceLimitX96: sqrtPriceLimitX96\n                })\n            );\n\n            // Deposit entire GMX balance for pxGMX, increasing the asset/share amount\n            (, pxGmxMintAmount, ) = PirexGmx(platform).depositGmx(\n                gmx.balanceOf(address(this)),\n                address(this)\n            );\n        }\n\n        // Only distribute fees if the amount of vault assets increased\n        if ((totalAssets() - assetsBeforeClaim) != 0) {\n            totalFee =\n                ((asset.balanceOf(address(this)) - assetsBeforeClaim) *\n                    platformFee) /\n                FEE_DENOMINATOR;\n            incentive = optOutIncentive\n                ? 0\n                : (totalFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (incentive != 0) asset.safeTransfer(msg.sender, incentive);\n\n            asset.safeTransfer(owner, totalFee - incentive);\n        }\n\n        emit Compounded(\n            msg.sender,\n            fee,\n            amountOutMinimum,\n            sqrtPriceLimitX96,\n            gmxBaseRewardAmountIn,\n            gmxAmountOut,\n            pxGmxMintAmount,\n            totalFee,\n            incentive\n        );\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        // Compound rewards and ensure they are properly accounted for prior to withdrawal calculation\n        compound(poolFee, 1, 0, true);\n\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        // Compound rewards and ensure they are properly accounted for prior to redemption calculation\n        compound(poolFee, 1, 0, true);\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max)\n                allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /**\n        @notice Deposit GMX for apxGMX\n        @param  amount    uint256  GMX amount\n        @param  receiver  address  apxGMX receiver\n        @return shares    uint256  Vault shares (i.e. apxGMX)\n     */\n    function depositGmx(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256 shares)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        // Handle compounding of rewards before deposit (arguments are not used by `beforeDeposit` hook)\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // Intake sender GMX\n        gmx.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Convert sender GMX into pxGMX and get the post-fee amount (i.e. assets)\n        (, uint256 assets, ) = PirexGmx(platform).depositGmx(\n            amount,\n            address(this)\n        );\n\n        // NOTE: Modified `convertToShares` logic to consider assets already being in the vault\n        // and handle it by deducting the recently-deposited assets from the total\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {PirexERC4626} from \"src/vaults/PirexERC4626.sol\";\nimport {PxGmxReward} from \"src/vaults/PxGmxReward.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PirexRewards} from \"src/PirexRewards.sol\";\n\ncontract AutoPxGlp is PirexERC4626, PxGmxReward, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 500;\n    uint256 public constant MAX_PLATFORM_FEE = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n    uint256 public constant MAX_COMPOUND_INCENTIVE = 5000;\n    uint256 public constant EXPANDED_DECIMALS = 1e30;\n\n    uint256 public withdrawalPenalty = 300;\n    uint256 public platformFee = 1000;\n    uint256 public compoundIncentive = 1000;\n    address public platform;\n\n    // Address of the rewards module (ie. PirexRewards instance)\n    address public immutable rewardsModule;\n\n    // GMX protocol base reward (e.g. WETH)\n    ERC20 public immutable gmxBaseReward;\n\n    event WithdrawalPenaltyUpdated(uint256 penalty);\n    event PlatformFeeUpdated(uint256 fee);\n    event CompoundIncentiveUpdated(uint256 incentive);\n    event PlatformUpdated(address _platform);\n    event Compounded(\n        address indexed caller,\n        uint256 minGlp,\n        uint256 gmxBaseRewardAmount,\n        uint256 pxGmxAmountOut,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 totalPxGmxFee,\n        uint256 pxGlpIncentive,\n        uint256 pxGmxIncentive\n    );\n\n    error ZeroAmount();\n    error InvalidAssetParam();\n    error ExceedsMax();\n    error InvalidParam();\n    error ZeroShares();\n\n    /**\n        @param  _gmxBaseReward  address  GMX reward token contract address\n        @param  _asset          address  Asset address (vault asset, e.g. pxGLP)\n        @param  _pxGmx          address  pxGMX address (as secondary reward)\n        @param  _name           string   Asset name (e.g. Autocompounding pxGLP)\n        @param  _symbol         string   Asset symbol (e.g. apxGLP)\n        @param  _platform       address  Platform address (e.g. PirexGmx)\n        @param  _rewardsModule  address  Rewards module address\n     */\n    constructor(\n        address _gmxBaseReward,\n        address _asset,\n        address _pxGmx,\n        string memory _name,\n        string memory _symbol,\n        address _platform,\n        address _rewardsModule\n    ) PxGmxReward(_pxGmx) PirexERC4626(ERC20(_asset), _name, _symbol) {\n        if (_gmxBaseReward == address(0)) revert ZeroAddress();\n        if (_asset == address(0)) revert ZeroAddress();\n        if (bytes(_name).length == 0) revert InvalidAssetParam();\n        if (bytes(_symbol).length == 0) revert InvalidAssetParam();\n        if (_platform == address(0)) revert ZeroAddress();\n        if (_rewardsModule == address(0)) revert ZeroAddress();\n\n        gmxBaseReward = ERC20(_gmxBaseReward);\n        platform = _platform;\n        rewardsModule = _rewardsModule;\n\n        // Approve the Uniswap V3 router to manage our base reward (inbound swap token)\n        gmxBaseReward.safeApprove(address(_platform), type(uint256).max);\n    }\n\n    /**\n        @notice Set the withdrawal penalty\n        @param  penalty  uint256  Withdrawal penalty\n     */\n    function setWithdrawalPenalty(uint256 penalty) external onlyOwner {\n        if (penalty > MAX_WITHDRAWAL_PENALTY) revert ExceedsMax();\n\n        withdrawalPenalty = penalty;\n\n        emit WithdrawalPenaltyUpdated(penalty);\n    }\n\n    /**\n        @notice Set the platform fee\n        @param  fee  uint256  Platform fee\n     */\n    function setPlatformFee(uint256 fee) external onlyOwner {\n        if (fee > MAX_PLATFORM_FEE) revert ExceedsMax();\n\n        platformFee = fee;\n\n        emit PlatformFeeUpdated(fee);\n    }\n\n    /**\n        @notice Set the compound incentive\n        @param  incentive  uint256  Compound incentive\n     */\n    function setCompoundIncentive(uint256 incentive) external onlyOwner {\n        if (incentive > MAX_COMPOUND_INCENTIVE) revert ExceedsMax();\n\n        compoundIncentive = incentive;\n\n        emit CompoundIncentiveUpdated(incentive);\n    }\n\n    /**\n        @notice Set the platform\n        @param  _platform  address  Platform\n     */\n    function setPlatform(address _platform) external onlyOwner {\n        if (_platform == address(0)) revert ZeroAddress();\n\n        platform = _platform;\n\n        emit PlatformUpdated(_platform);\n    }\n\n    /**\n        @notice Get the pxGLP custodied by the AutoPxGlp contract\n        @return uint256  Amount of pxGLP custodied by the autocompounder\n     */\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n\n    /**\n        @notice Preview the amount of assets a user would receive from redeeming shares\n        @param  shares   uint256  Shares amount\n        @return          uint256  Assets amount\n     */\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate assets based on a user's % ownership of vault shares\n        uint256 assets = convertToAssets(shares);\n\n        uint256 _totalSupply = totalSupply;\n\n        // Calculate a penalty - zero if user is the last to withdraw\n        uint256 penalty = (_totalSupply == 0 || _totalSupply - shares == 0)\n            ? 0\n            : assets.mulDivDown(withdrawalPenalty, FEE_DENOMINATOR);\n\n        // Redeemable amount is the post-penalty amount\n        return assets - penalty;\n    }\n\n    /**\n        @notice Preview the amount of shares a user would need to redeem the specified asset amount\n        @notice This modified version takes into consideration the withdrawal fee\n        @param  assets   uint256  Assets amount\n        @return          uint256  Shares amount\n     */\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // Calculate shares based on the specified assets' proportion of the pool\n        uint256 shares = convertToShares(assets);\n\n        // Save 1 SLOAD\n        uint256 _totalSupply = totalSupply;\n\n        // Factor in additional shares to fulfill withdrawal if user is not the last to withdraw\n        return\n            (_totalSupply == 0 || _totalSupply - shares == 0)\n                ? shares\n                : (shares * FEE_DENOMINATOR) /\n                    (FEE_DENOMINATOR - withdrawalPenalty);\n    }\n\n    /**\n        @notice Compound pxGLP (and additionally pxGMX) rewards\n        @param  minUsdg                uint256  Minimum USDG amount used when minting GLP\n        @param  minGlp                 uint256  Minimum GLP amount received from the WETH deposit\n        @param  optOutIncentive        bool     Whether to opt out of the incentive\n        @return gmxBaseRewardAmountIn  uint256  WETH inbound amount\n        @return pxGmxAmountOut         uint256  pxGMX outbound amount\n        @return pxGlpAmountOut         uint256  pxGLP outbound amount\n        @return totalPxGlpFee          uint256  Total platform fee for pxGLP\n        @return totalPxGmxFee          uint256  Total platform fee for pxGMX\n        @return pxGlpIncentive         uint256  Compound incentive for pxGLP\n        @return pxGmxIncentive         uint256  Compound incentive for pxGMX\n     */\n    function compound(\n        uint256 minUsdg,\n        uint256 minGlp,\n        bool optOutIncentive\n    )\n        public\n        returns (\n            uint256 gmxBaseRewardAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        )\n    {\n        if (minUsdg == 0) revert InvalidParam();\n        if (minGlp == 0) revert InvalidParam();\n\n        uint256 preClaimTotalAssets = asset.balanceOf(address(this));\n        uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));\n\n        PirexRewards(rewardsModule).claim(asset, address(this));\n        PirexRewards(rewardsModule).claim(pxGmx, address(this));\n\n        // Track the amount of rewards received\n        gmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));\n\n        if (gmxBaseRewardAmountIn != 0) {\n            // Deposit received rewards for pxGLP\n            (, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(\n                address(gmxBaseReward),\n                gmxBaseRewardAmountIn,\n                minUsdg,\n                minGlp,\n                address(this)\n            );\n        }\n\n        // Distribute fees if the amount of vault assets increased\n        uint256 newAssets = totalAssets() - preClaimTotalAssets;\n        if (newAssets != 0) {\n            totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;\n            pxGlpIncentive = optOutIncentive\n                ? 0\n                : (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGlpIncentive != 0)\n                asset.safeTransfer(msg.sender, pxGlpIncentive);\n\n            asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);\n        }\n\n        // Track the amount of pxGMX received\n        pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;\n\n        if (pxGmxAmountOut != 0) {\n            // Calculate and distribute pxGMX fees if the amount of pxGMX increased\n            totalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;\n            pxGmxIncentive = optOutIncentive\n                ? 0\n                : (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;\n\n            if (pxGmxIncentive != 0)\n                pxGmx.safeTransfer(msg.sender, pxGmxIncentive);\n\n            pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);\n\n            // Update the pxGmx reward accrual\n            _harvest(pxGmxAmountOut - totalPxGmxFee);\n        } else {\n            // Required to keep the globalState up-to-date\n            _globalAccrue();\n        }\n\n        emit Compounded(\n            msg.sender,\n            minGlp,\n            gmxBaseRewardAmountIn,\n            pxGmxAmountOut,\n            pxGlpAmountOut,\n            totalPxGlpFee,\n            totalPxGmxFee,\n            pxGlpIncentive,\n            pxGmxIncentive\n        );\n    }\n\n    /**\n        @notice Internal deposit handler\n        @param  assets    uint256  pxGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return shares    uint256  Vault shares (i.e. apxGLP)\n     */\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        uint256 supply = totalSupply;\n\n        if (\n            (shares = supply == 0\n                ? assets\n                : assets.mulDivDown(supply, totalAssets() - assets)) == 0\n        ) revert ZeroShares();\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(receiver, assets, shares);\n    }\n\n    /**\n        @notice Deposit fsGLP for apxGLP\n        @param  amount    uint256  fsGLP amount\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositFsGlp(uint256 amount, address receiver)\n        external\n        nonReentrant\n        returns (uint256)\n    {\n        if (amount == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        ERC20 stakedGlp = ERC20(address(PirexGmx(platform).stakedGlp()));\n\n        // Transfer fsGLP from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        stakedGlp.safeTransferFrom(msg.sender, address(this), amount);\n\n        // Approve as needed here since the stakedGlp address is mutable in PirexGmx\n        stakedGlp.safeApprove(platform, amount);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositFsGlp(\n            amount,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ERC20 tokens) for apxGLP\n        @param  token        address  GMX-whitelisted token for minting GLP\n        @param  tokenAmount  uint256  Whitelisted token amount\n        @param  minUsdg      uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp       uint256  Minimum GLP amount minted from ERC20 tokens\n        @param  receiver     address  apxGLP receiver\n        @return              uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlp(\n        address token,\n        uint256 tokenAmount,\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external nonReentrant returns (uint256) {\n        if (token == address(0)) revert ZeroAddress();\n        if (tokenAmount == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        // PirexGmx will do the check whether the token is whitelisted or not\n        ERC20 erc20Token = ERC20(token);\n\n        // Transfer token from the caller to the vault\n        // before approving PirexGmx to proceed with the deposit\n        erc20Token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n\n        // Approve as needed here since it can be a new whitelisted token (unless it's the baseReward)\n        if (erc20Token != gmxBaseReward) {\n            erc20Token.safeApprove(platform, tokenAmount);\n        }\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            address(this)\n        );\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Deposit GLP (minted with ETH) for apxGLP\n        @param  minUsdg   uint256  Minimum USDG purchased and used to mint GLP\n        @param  minGlp    uint256  Minimum GLP amount minted from ETH\n        @param  receiver  address  apxGLP receiver\n        @return           uint256  Vault shares (i.e. apxGLP)\n     */\n    function depositGlpETH(\n        uint256 minUsdg,\n        uint256 minGlp,\n        address receiver\n    ) external payable nonReentrant returns (uint256) {\n        if (msg.value == 0) revert ZeroAmount();\n        if (minUsdg == 0) revert ZeroAmount();\n        if (minGlp == 0) revert ZeroAmount();\n        if (receiver == address(0)) revert ZeroAddress();\n\n        if (totalAssets() != 0) beforeDeposit(address(0), 0, 0);\n\n        (, uint256 assets, ) = PirexGmx(platform).depositGlpETH{\n            value: msg.value\n        }(minUsdg, minGlp, address(this));\n\n        // Handle vault deposit after minting pxGLP\n        return _deposit(assets, receiver);\n    }\n\n    /**\n        @notice Override the withdrawal method to make sure compound is called before withdrawing\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256 shares) {\n        compound(1, 1, true);\n\n        shares = PirexERC4626.withdraw(assets, receiver, owner);\n    }\n\n    /**\n        @notice Override the redemption method to make sure compound is called before redeeming\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256 assets) {\n        compound(1, 1, true);\n\n        assets = PirexERC4626.redeem(shares, receiver, owner);\n    }\n\n    /**\n        @notice Compound and internally update pxGMX reward accrual before deposit\n     */\n    function beforeDeposit(\n        address,\n        uint256,\n        uint256\n    ) internal override {\n        compound(1, 1, true);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after deposit\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterDeposit(\n        address receiver,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(receiver);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual after withdrawal\n        @param  owner  address  Owner of the vault shares\n     */\n    function afterWithdraw(\n        address owner,\n        uint256,\n        uint256\n    ) internal override {\n        _globalAccrue();\n        _userAccrue(owner);\n    }\n\n    /**\n        @notice Update pxGMX reward accrual for both sender and receiver after transfer\n        @param  owner     address  Owner of the vault shares\n        @param  receiver  address  Receiver of the vault shares\n     */\n    function afterTransfer(\n        address owner,\n        address receiver,\n        uint256\n    ) internal override {\n        _userAccrue(owner);\n        _userAccrue(receiver);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {AutoPxGlp} from \"src/vaults/AutoPxGlp.sol\";\nimport {PirexGmx} from \"src/PirexGmx.sol\";\nimport {PxGmxReward} from \"src/vaults/PxGmxReward.sol\";\nimport {Helper} from \"./Helper.sol\";\n\ncontract AutoPxGlpTest is Helper {\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n    event Compounded(\n        address indexed caller,\n        uint256 minGlp,\n        uint256 wethAmount,\n        uint256 pxGmxAmountOut,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 totalPxGmxFee,\n        uint256 pxGlpIncentive,\n        uint256 pxGmxIncentive\n    );\n    event PxGmxClaimed(\n        address indexed account,\n        address receiver,\n        uint256 amount\n    );\n\n    /**\n        @notice Calculate the global rewards accrued since the last update\n        @return uint256  Global rewards\n    */\n    function _calculateGlobalRewards() internal view returns (uint256) {\n        (uint256 lastUpdate, uint256 lastSupply, uint256 rewards) = autoPxGlp\n            .globalState();\n\n        return rewards + (block.timestamp - lastUpdate) * lastSupply;\n    }\n\n    /**\n        @notice Calculate a user's rewards since the last update\n        @param  user  address  User\n        @return       uint256  User rewards\n    */\n    function _calculateUserRewards(address user)\n        internal\n        view\n        returns (uint256)\n    {\n        (uint256 lastUpdate, uint256 lastBalance, uint256 rewards) = autoPxGlp\n            .userRewardStates(user);\n\n        return rewards + lastBalance * (block.timestamp - lastUpdate);\n    }\n\n    /**\n        @notice Perform assertions for global state\n        @param  expectedLastUpdate  uint256  Expected last update timestamp\n        @param  expectedLastSupply  uint256  Expected last supply\n        @param  expectedRewards     uint256  Expected rewards\n    */\n    function _assertGlobalState(\n        uint256 expectedLastUpdate,\n        uint256 expectedLastSupply,\n        uint256 expectedRewards\n    ) internal {\n        (uint256 lastUpdate, uint256 lastSupply, uint256 rewards) = autoPxGlp\n            .globalState();\n\n        assertEq(expectedLastUpdate, lastUpdate);\n        assertEq(expectedLastSupply, lastSupply);\n        assertEq(expectedRewards, rewards);\n    }\n\n    /**\n        @notice Perform assertions for user reward state\n        @param  user                 address  User address\n        @param  expectedLastUpdate   uint256  Expected last update timestamp\n        @param  expectedLastBalance  uint256  Expected last user balance\n        @param  expectedRewards      uint256  Expected rewards\n    */\n    function _assertUserRewardState(\n        address user,\n        uint256 expectedLastUpdate,\n        uint256 expectedLastBalance,\n        uint256 expectedRewards\n    ) internal {\n        (uint256 lastUpdate, uint256 lastBalance, uint256 rewards) = autoPxGlp\n            .userRewardStates(user);\n\n        assertEq(expectedLastUpdate, lastUpdate);\n        assertEq(expectedLastBalance, lastBalance);\n        assertEq(expectedRewards, rewards);\n    }\n\n    /**\n        @notice Validate common parameters used for deposits in the tests\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function _validateTestArgs(uint8 multiplier, uint32 secondsElapsed)\n        internal\n    {\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n        vm.assume(secondsElapsed > 10);\n        vm.assume(secondsElapsed < 365 days);\n    }\n\n    /**\n        @notice Perform common setup for reward accrual and test accounts for vault tests\n        @param  multiplier  uint8  Multiplied with fixed token amounts for randomness\n     */\n    function _setupRewardsAndTestAccounts(uint8 multiplier) internal {\n        pirexRewards.addRewardToken(pxGmx, weth);\n        pirexRewards.addRewardToken(pxGmx, pxGmx);\n        pirexRewards.addRewardToken(pxGlp, weth);\n        pirexRewards.addRewardToken(pxGlp, pxGmx);\n\n        // Some tests require different deposit setup, only process those with non-zero multiplier\n        if (multiplier > 0) {\n            _depositGlpForTestAccounts(true, address(this), multiplier, true);\n        }\n    }\n\n    /**\n        @notice Perform deposit to the vault\n        @param  user  address  User address\n        @return       uint256  Amount of shares\n     */\n    function _depositToVault(address user) internal returns (uint256) {\n        vm.startPrank(user);\n\n        pxGlp.approve(address(autoPxGlp), pxGlp.balanceOf(user));\n\n        uint256 shares = autoPxGlp.deposit(pxGlp.balanceOf(user), user);\n\n        vm.stopPrank();\n\n        return shares;\n    }\n\n    /**\n        @notice Calculate amount of accrued rewards by the vault\n        @param  rewardState  uint256  Reward state\n        @param  vaultState   uint256  Vault state\n        @param  globalState  uint256  Global state\n        @return              uint256  Amount of rewards\n     */\n    function _calculateVaultReward(\n        uint256 rewardState,\n        uint256 vaultState,\n        uint256 globalState\n    ) internal pure returns (uint256) {\n        if (globalState != 0) {\n            return (rewardState * vaultState) / globalState;\n        }\n\n        return 0;\n    }\n\n    /**\n        @notice Provision reward state to test compounding of rewards\n        @param  secondsElapsed    uint256  Seconds to forward timestamp\n        @return wethRewardState   uint256  WETH reward state\n        @return pxGmxRewardState  uint256  pxGMX reward state\n     */\n    function _provisionRewardState(uint256 secondsElapsed)\n        internal\n        returns (uint256 wethRewardState, uint256 pxGmxRewardState)\n    {\n        // Time skip to accrue rewards then return the latest reward states\n        vm.warp(block.timestamp + secondsElapsed);\n\n        pirexRewards.harvest();\n\n        // Take into account rewards from both pxGMX and pxGLP based on the vault's current shares\n        uint256 pxGmxGlobalRewards = _calculateGlobalRewards(pxGmx);\n        uint256 pxGlpGlobalRewards = _calculateGlobalRewards(pxGlp);\n        uint256 pxGmxVaultRewards = _calculateUserRewards(\n            pxGmx,\n            address(autoPxGlp)\n        );\n        uint256 pxGlpVaultRewards = _calculateUserRewards(\n            pxGlp,\n            address(autoPxGlp)\n        );\n\n        wethRewardState =\n            _calculateVaultReward(\n                pirexRewards.getRewardState(pxGmx, weth),\n                pxGmxVaultRewards,\n                pxGmxGlobalRewards\n            ) +\n            _calculateVaultReward(\n                pirexRewards.getRewardState(pxGlp, weth),\n                pxGlpVaultRewards,\n                pxGlpGlobalRewards\n            );\n        pxGmxRewardState =\n            _calculateVaultReward(\n                pirexRewards.getRewardState(pxGmx, pxGmx),\n                pxGmxVaultRewards,\n                pxGmxGlobalRewards\n            ) +\n            _calculateVaultReward(\n                pirexRewards.getRewardState(pxGlp, pxGmx),\n                pxGlpVaultRewards,\n                pxGlpGlobalRewards\n            );\n    }\n\n    /**\n        @notice Compound and perform assertions partially\n        @return wethAmount      uint256  WETH amount\n        @return pxGmxAmount     uint256  pxGMX amount\n        @return pxGlpAmount     uint256  pxGLP amount\n        @return pxGlpFee        uint256  pxGLP fee\n        @return pxGlpInc        uint256  pxGLP incentive\n        @return pxGmxFee        uint256  pxGMX fee\n    */\n    function _compoundAndAssert()\n        internal\n        returns (\n            uint256 wethAmount,\n            uint256 pxGmxAmount,\n            uint256 pxGlpAmount,\n            uint256 pxGlpFee,\n            uint256 pxGlpInc,\n            uint256 pxGmxFee\n        )\n    {\n        uint256 preCompoundOwnerBalance = pxGmx.balanceOf(autoPxGlp.owner());\n        uint256 preCompoundCompounderBalance = pxGmx.balanceOf(testAccounts[0]);\n\n        vm.expectEmit(true, false, false, false, address(autoPxGlp));\n\n        emit Compounded(testAccounts[0], 0, 0, 0, 0, 0, 0, 0, 0);\n\n        // Call as testAccounts[0] to test compound incentive transfer\n        vm.prank(testAccounts[0]);\n\n        (\n            uint256 wethAmountIn,\n            uint256 pxGmxAmountOut,\n            uint256 pxGlpAmountOut,\n            uint256 totalPxGlpFee,\n            uint256 totalPxGmxFee,\n            uint256 pxGlpIncentive,\n            uint256 pxGmxIncentive\n        ) = autoPxGlp.compound(1, 1, false);\n\n        // Assert updated states separately (stack-too-deep issue)\n        _assertPostCompoundPxGmxRewardStates(\n            preCompoundOwnerBalance,\n            preCompoundCompounderBalance,\n            pxGmxAmountOut,\n            totalPxGmxFee,\n            pxGmxIncentive\n        );\n\n        wethAmount = wethAmountIn;\n        pxGmxAmount = pxGmxAmountOut;\n        pxGlpAmount = pxGlpAmountOut;\n        pxGlpFee = totalPxGlpFee;\n        pxGlpInc = pxGlpIncentive;\n        pxGmxFee = totalPxGmxFee;\n    }\n\n    /**\n        @notice Assert main vault states after performing compound\n        @param  user                       address  Test user address\n        @param  pxGlpAmountOut             uint256  pxGLP rewards before fees\n        @param  totalPxGlpFee              uint256  Total fees for pxGLP\n        @param  pxGlpIncentive             uint256  Incentive for pxGLP\n        @param  totalAssetsBeforeCompound  uint256  Total assets before compound\n     */\n    function _assertPostCompoundVaultStates(\n        address user,\n        uint256 pxGlpAmountOut,\n        uint256 totalPxGlpFee,\n        uint256 pxGlpIncentive,\n        uint256 totalAssetsBeforeCompound\n    ) internal {\n        uint256 userShareBalance = autoPxGlp.balanceOf(user);\n        uint256 expectedTotalPxGlpFee = (pxGlpAmountOut *\n            autoPxGlp.platformFee()) / autoPxGlp.FEE_DENOMINATOR();\n        uint256 expectedCompoundIncentive = (totalPxGlpFee *\n            autoPxGlp.compoundIncentive()) / autoPxGlp.FEE_DENOMINATOR();\n        uint256 expectedTotalAssets = totalAssetsBeforeCompound +\n            pxGlpAmountOut -\n            totalPxGlpFee;\n\n        assertGt(expectedTotalAssets, totalAssetsBeforeCompound);\n        assertEq(expectedTotalAssets, autoPxGlp.totalAssets());\n        assertEq(expectedTotalAssets, pxGlp.balanceOf(address(autoPxGlp)));\n        assertEq(expectedTotalPxGlpFee, totalPxGlpFee);\n        assertEq(expectedCompoundIncentive, pxGlpIncentive);\n        assertEq(\n            expectedTotalPxGlpFee -\n                expectedCompoundIncentive +\n                expectedCompoundIncentive,\n            totalPxGlpFee\n        );\n        assertEq(userShareBalance, autoPxGlp.balanceOf(user));\n    }\n\n    /**\n        @notice Assert pxGMX reward states after performing compound\n        @param  preCompoundOwnerBalance       uint256  Pre-compound owner pxGmx balance\n        @param  preCompoundCompounderBalance  uint256  Pre-compound compounder pxGmx balance\n        @param  pxGmxAmountOut                uint256  pxGMX rewards before fees\n        @param  totalPxGmxFee                 uint256  Total fees for pxGMX\n        @param  pxGmxIncentive                uint256  Incentive for pxGMX\n     */\n    function _assertPostCompoundPxGmxRewardStates(\n        uint256 preCompoundOwnerBalance,\n        uint256 preCompoundCompounderBalance,\n        uint256 pxGmxAmountOut,\n        uint256 totalPxGmxFee,\n        uint256 pxGmxIncentive\n    ) internal {\n        uint256 expectedTotalPxGmxFee = (pxGmxAmountOut *\n            autoPxGlp.platformFee()) / autoPxGlp.FEE_DENOMINATOR();\n        uint256 expectedCompoundPxGmxIncentive = (totalPxGmxFee *\n            autoPxGlp.compoundIncentive()) / autoPxGlp.FEE_DENOMINATOR();\n        assertEq(expectedTotalPxGmxFee, totalPxGmxFee);\n        assertEq(expectedCompoundPxGmxIncentive, pxGmxIncentive);\n\n        // Check for pxGMX reward balances of the fee receivers\n        assertEq(\n            preCompoundOwnerBalance +\n                expectedTotalPxGmxFee -\n                expectedCompoundPxGmxIncentive,\n            pxGmx.balanceOf(autoPxGlp.owner())\n        );\n        assertEq(\n            preCompoundCompounderBalance + expectedCompoundPxGmxIncentive,\n            pxGmx.balanceOf(testAccounts[0])\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setWithdrawalPenalty TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetWithdrawalPenaltyUnauthorized() external {\n        // Define function arguments\n        uint256 penalty = 1;\n\n        // Define post-transition/upcoming state or effects\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        // Execute state transition\n        vm.prank(testAccounts[0]);\n\n        autoPxGlp.setWithdrawalPenalty(penalty);\n    }\n\n    /**\n        @notice Test tx reversion: penalty exceeds max\n     */\n    function testCannotSetWithdrawalPenaltyExceedsMax() external {\n        uint256 invalidPenalty = autoPxGlp.MAX_WITHDRAWAL_PENALTY() + 1;\n\n        vm.expectRevert(AutoPxGlp.ExceedsMax.selector);\n\n        autoPxGlp.setWithdrawalPenalty(invalidPenalty);\n    }\n\n    /**\n        @notice Test tx success: set withdrawal penalty\n     */\n    function testSetWithdrawalPenalty() external {\n        uint256 initialWithdrawalPenalty = autoPxGlp.withdrawalPenalty();\n        uint256 penalty = 1;\n        uint256 expectedWithdrawalPenalty = penalty;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGlp));\n\n        emit WithdrawalPenaltyUpdated(expectedWithdrawalPenalty);\n\n        autoPxGlp.setWithdrawalPenalty(penalty);\n\n        assertEq(expectedWithdrawalPenalty, autoPxGlp.withdrawalPenalty());\n        assertTrue(expectedWithdrawalPenalty != initialWithdrawalPenalty);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPlatformFee TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPlatformFeeUnauthorized() external {\n        uint256 fee = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGlp.setPlatformFee(fee);\n    }\n\n    /**\n        @notice Test tx reversion: fee exceeds max\n     */\n    function testCannotSetPlatformFeeExceedsMax() external {\n        uint256 invalidFee = autoPxGlp.MAX_PLATFORM_FEE() + 1;\n\n        vm.expectRevert(AutoPxGlp.ExceedsMax.selector);\n\n        autoPxGlp.setPlatformFee(invalidFee);\n    }\n\n    /**\n        @notice Test tx success: set platform fee\n     */\n    function testSetPlatformFee() external {\n        uint256 initialPlatformFee = autoPxGlp.platformFee();\n        uint256 fee = 1;\n        uint256 expectedPlatformFee = fee;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGlp));\n\n        emit PlatformFeeUpdated(expectedPlatformFee);\n\n        autoPxGlp.setPlatformFee(fee);\n\n        assertEq(expectedPlatformFee, autoPxGlp.platformFee());\n        assertTrue(expectedPlatformFee != initialPlatformFee);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setCompoundIncentive TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetCompoundIncentiveUnauthorized() external {\n        uint256 incentive = 1;\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGlp.setCompoundIncentive(incentive);\n    }\n\n    /**\n        @notice Test tx reversion: incentive exceeds max\n     */\n    function testCannotSetCompoundIncentiveExceedsMax() external {\n        uint256 invalidIncentive = autoPxGlp.MAX_COMPOUND_INCENTIVE() + 1;\n\n        vm.expectRevert(AutoPxGlp.ExceedsMax.selector);\n\n        autoPxGlp.setCompoundIncentive(invalidIncentive);\n    }\n\n    /**\n        @notice Test tx success: set compound incentive percent\n     */\n    function testSetCompoundIncentive() external {\n        uint256 initialCompoundIncentive = autoPxGlp.compoundIncentive();\n        uint256 incentive = 1;\n        uint256 expectedCompoundIncentive = incentive;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGlp));\n\n        emit CompoundIncentiveUpdated(expectedCompoundIncentive);\n\n        autoPxGlp.setCompoundIncentive(incentive);\n\n        assertEq(expectedCompoundIncentive, autoPxGlp.compoundIncentive());\n        assertTrue(expectedCompoundIncentive != initialCompoundIncentive);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        setPlatform TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: caller is unauthorized\n     */\n    function testCannotSetPlatformUnauthorized() external {\n        address platform = address(this);\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n\n        vm.prank(testAccounts[0]);\n\n        autoPxGlp.setPlatform(platform);\n    }\n\n    /**\n        @notice Test tx reversion: platform is zero address\n     */\n    function testCannotSetPlatformZeroAddress() external {\n        address invalidPlatform = address(0);\n\n        vm.expectRevert(PxGmxReward.ZeroAddress.selector);\n\n        autoPxGlp.setPlatform(invalidPlatform);\n    }\n\n    /**\n        @notice Test tx success: set platform\n     */\n    function testSetPlatform() external {\n        address initialPlatform = autoPxGlp.platform();\n        address platform = address(this);\n        address expectedPlatform = platform;\n\n        vm.expectEmit(false, false, false, true, address(autoPxGlp));\n\n        emit PlatformUpdated(expectedPlatform);\n\n        autoPxGlp.setPlatform(platform);\n\n        assertEq(expectedPlatform, autoPxGlp.platform());\n        assertTrue(expectedPlatform != initialPlatform);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        totalAssets TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: return the total assets\n        @param  multiplier  uint8  Multiplied with fixed token amounts for randomness\n    */\n    function testTotalAssets(uint8 multiplier) external {\n        vm.assume(multiplier != 0);\n        vm.assume(multiplier < 10);\n\n        uint256 initialTotalAssets = autoPxGlp.totalAssets();\n\n        uint256 totalDeposit;\n        uint256[] memory depositAmounts = _depositGlpForTestAccounts(\n            false,\n            address(this),\n            multiplier,\n            true\n        );\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address testAccount = testAccounts[i];\n\n            vm.startPrank(testAccount);\n\n            pxGlp.approve(address(autoPxGlp), pxGlp.balanceOf(testAccount));\n            autoPxGlp.deposit(pxGlp.balanceOf(testAccount), testAccount);\n\n            vm.stopPrank();\n\n            totalDeposit += depositAmounts[i];\n        }\n\n        uint256 assets = pxGlp.balanceOf(address(autoPxGlp));\n\n        assertEq(assets, autoPxGlp.totalAssets());\n        assertTrue(assets != initialTotalAssets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        compound TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: minUsdg is invalid (zero)\n     */\n    function testCannotCompoundMinUsdgInvalidParam() external {\n        uint256 invalidMinUsdg = 0;\n        uint256 minGlp = 1;\n        bool optOutIncentive = true;\n\n        vm.expectRevert(AutoPxGlp.InvalidParam.selector);\n\n        autoPxGlp.compound(invalidMinUsdg, minGlp, optOutIncentive);\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is invalid (zero)\n     */\n    function testCannotCompoundMinGlpInvalidParam() external {\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlpAmount = 0;\n        bool optOutIncentive = true;\n\n        vm.expectRevert(AutoPxGlp.InvalidParam.selector);\n\n        autoPxGlp.compound(minUsdg, invalidMinGlpAmount, optOutIncentive);\n    }\n\n    /**\n        @notice Test tx success: compound pxGLP rewards into more pxGLP and track pxGMX reward states\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testCompound(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            _depositToVault(testAccounts[i]);\n\n            (\n                uint256 wethRewardState,\n                uint256 pxGmxRewardState\n            ) = _provisionRewardState(secondsElapsed);\n\n            uint256 totalAssetsBeforeCompound = autoPxGlp.totalAssets();\n            uint256 pxGmxBalanceBeforeCompound = pxGmx.balanceOf(\n                address(autoPxGlp)\n            );\n            uint256 pxGlpOwnerBalanceBeforeCompound = pxGlp.balanceOf(\n                autoPxGlp.owner()\n            );\n            // Commented out due to Stack-too-deep\n            // uint256 pxGlpCompounderBalanceBeforeCompound = pxGlp.balanceOf(\n            //     testAccounts[0]\n            // );\n            uint256 expectedGlobalLastSupply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n\n            assertGt(wethRewardState, 0);\n\n            // Perform compound and assertions partially (stack-too-deep)\n            (\n                uint256 wethAmountIn,\n                uint256 pxGmxAmountOut,\n                uint256 pxGlpAmountOut,\n                uint256 totalPxGlpFee,\n                uint256 pxGlpIncentive,\n                uint256 totalPxGmxFee\n            ) = _compoundAndAssert();\n\n            // Perform the rest of the assertions (stack-too-deep)\n            assertEq(wethRewardState, wethAmountIn);\n            assertEq(pxGmxRewardState, pxGmxAmountOut);\n\n            _assertGlobalState(\n                block.timestamp,\n                expectedGlobalLastSupply,\n                expectedGlobalRewards\n            );\n\n            _assertPostCompoundVaultStates(\n                testAccounts[i],\n                pxGlpAmountOut,\n                totalPxGlpFee,\n                pxGlpIncentive,\n                totalAssetsBeforeCompound\n            );\n\n            assertEq(\n                (pxGmxAmountOut - totalPxGmxFee),\n                pxGmx.balanceOf(address(autoPxGlp)) - pxGmxBalanceBeforeCompound\n            );\n\n            // Check for vault asset balances of the fee receivers\n            assertEq(\n                pxGlpOwnerBalanceBeforeCompound +\n                    totalPxGlpFee -\n                    pxGlpIncentive,\n                pxGlp.balanceOf(autoPxGlp.owner())\n            );\n            // Commented out due to Stack-too-deep\n            // assertEq(\n            //     pxGlpCompounderBalanceBeforeCompound + pxGlpIncentive,\n            //     pxGlp.balanceOf(testAccounts[0])\n            // );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        deposit TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: deposit to vault and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testDeposit(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            _depositToVault(testAccounts[i]);\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedLastUpdate = block.timestamp;\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 pxGmxRewardAfterFees = pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n\n            // Perform another deposit and assert the updated pxGMX reward states\n            _depositGlpETHWithTimeSkip(\n                (1 ether * (i + 1) * multiplier),\n                testAccounts[i],\n                0\n            );\n\n            uint256 newShares = _depositToVault(testAccounts[i]);\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                expectedLastUpdate,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                expectedLastUpdate,\n                initialBalance + newShares,\n                expectedUserRewardState\n            );\n            assertEq(\n                initialRewardState + pxGmxRewardAfterFees,\n                autoPxGlp.rewardState()\n            );\n\n            // Deposit should still increment the totalSupply and user shares\n            assertEq(supply + newShares, autoPxGlp.totalSupply());\n            assertEq(\n                initialBalance + newShares,\n                autoPxGlp.balanceOf(testAccounts[i])\n            );\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance + pxGmxRewardAfterFees,\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositFsGlp TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: fsGLP amount is zero\n     */\n    function testCannotDepositFsGlpZeroAmount() external {\n        uint256 invalidAmount = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositFsGlp(invalidAmount, receiver);\n    }\n\n    /**\n        @notice Test tx reversion: fsGLP amount is zero\n     */\n    function testCannotDepositFsGlpZeroAddress() external {\n        uint256 amount = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PxGmxReward.ZeroAddress.selector);\n\n        autoPxGlp.depositFsGlp(amount, invalidReceiver);\n    }\n\n    /**\n        @notice Test tx success: deposit using fsGLP to vault and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testDepositFsGlp(uint8 multiplier, uint32 secondsElapsed)\n        external\n    {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(0);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            // Mint fsGLP for the testAccount then deposit to the vault\n            uint256 fsGlpBalance = _mintAndApproveFsGlp(\n                multiplier * 1 ether,\n                testAccounts[i]\n            );\n\n            vm.startPrank(testAccounts[i]);\n\n            STAKED_GLP.approve(address(autoPxGlp), fsGlpBalance);\n\n            vm.expectEmit(true, true, false, false, address(autoPxGlp));\n\n            emit Deposit(testAccounts[i], testAccounts[i], 0, 0);\n\n            autoPxGlp.depositFsGlp(fsGlpBalance, testAccounts[i]);\n\n            vm.stopPrank();\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n\n            // Make sure that the actual minted shares is correct\n            assertEq(\n                initialBalance,\n                autoPxGlp.previewDeposit(\n                    fsGlpBalance -\n                        (fsGlpBalance * pirexGmx.fees(PirexGmx.Fees.Deposit)) /\n                        pirexGmx.FEE_DENOMINATOR()\n                )\n            );\n\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 pxGmxRewardAfterFees = pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n\n            // Perform another deposit and assert the updated pxGMX reward states\n            _depositGlpETHWithTimeSkip(\n                (1 ether * (i + 1) * multiplier),\n                testAccounts[i],\n                0\n            );\n\n            uint256 newShares = _depositToVault(testAccounts[i]);\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                block.timestamp,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                block.timestamp,\n                initialBalance + newShares,\n                expectedUserRewardState\n            );\n            assertEq(\n                initialRewardState + pxGmxRewardAfterFees,\n                autoPxGlp.rewardState()\n            );\n\n            // Deposit should still increment the totalSupply and user shares\n            assertEq(supply + newShares, autoPxGlp.totalSupply());\n            assertEq(\n                initialBalance + newShares,\n                autoPxGlp.balanceOf(testAccounts[i])\n            );\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance + pxGmxRewardAfterFees,\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGlp TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: token address is the zero address\n     */\n    function testCannotDepositGlpTokenZeroAddress() external {\n        address invalidToken = address(0);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(PxGmxReward.ZeroAddress.selector);\n\n        autoPxGlp.depositGlp(\n            invalidToken,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: token amount is zero\n     */\n    function testCannotDepositGlpTokenZeroAmount() external {\n        address token = address(weth);\n        uint256 invalidTokenAmount = 0;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositGlp(\n            token,\n            invalidTokenAmount,\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minUsdg is zero\n     */\n    function testCannotDepositGlpMinUsdgZeroAmount() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 invalidMinUsdg = 0;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositGlp(\n            token,\n            tokenAmount,\n            invalidMinUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is zero\n     */\n    function testCannotDepositGlpMinGlpZeroAmount() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlp = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            invalidMinGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: receiver is the zero address\n     */\n    function testCannotDepositGlpReceiverZeroAddress() external {\n        address token = address(weth);\n        uint256 tokenAmount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PxGmxReward.ZeroAddress.selector);\n\n        autoPxGlp.depositGlp(\n            token,\n            tokenAmount,\n            minUsdg,\n            minGlp,\n            invalidReceiver\n        );\n    }\n\n    /**\n        @notice Test tx success: deposit using whitelisted token to vault and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testDepositGlp(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(0);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            // Mint WETH for the testAccount then deposit to the vault\n            vm.deal(address(this), multiplier * 1 ether);\n\n            _mintWrappedToken(multiplier * 1 ether, testAccounts[i]);\n\n            vm.startPrank(testAccounts[i]);\n\n            weth.approve(address(autoPxGlp), weth.balanceOf(testAccounts[i]));\n\n            vm.expectEmit(true, true, false, false, address(autoPxGlp));\n\n            emit Deposit(testAccounts[i], testAccounts[i], 0, 0);\n\n            autoPxGlp.depositGlp(\n                address(weth),\n                weth.balanceOf(testAccounts[i]),\n                1,\n                1,\n                testAccounts[i]\n            );\n\n            vm.stopPrank();\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 pxGmxRewardAfterFees = pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n\n            // Perform another deposit and assert the updated pxGMX reward states\n            _depositGlpETHWithTimeSkip(\n                (1 ether * (i + 1) * multiplier),\n                testAccounts[i],\n                0\n            );\n\n            uint256 newShares = _depositToVault(testAccounts[i]);\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                block.timestamp,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                block.timestamp,\n                initialBalance + newShares,\n                expectedUserRewardState\n            );\n            assertEq(\n                initialRewardState + pxGmxRewardAfterFees,\n                autoPxGlp.rewardState()\n            );\n\n            // Deposit should still increment the totalSupply and user shares\n            assertEq(supply + newShares, autoPxGlp.totalSupply());\n            assertEq(\n                initialBalance + newShares,\n                autoPxGlp.balanceOf(testAccounts[i])\n            );\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance + pxGmxRewardAfterFees,\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        depositGlpETH TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: msg.value is zero\n     */\n    function testCannotDepositGlpETHValueZeroAmount() external {\n        uint256 invalidAmount = 0;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositGlpETH{value: invalidAmount}(\n            minUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minUsdg is zero\n     */\n    function testCannotDepositGlpETHMinUsdgZeroAmount() external {\n        uint256 amount = 1;\n        uint256 invalidMinUsdg = 0;\n        uint256 minGlp = 1;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositGlpETH{value: amount}(\n            invalidMinUsdg,\n            minGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: minGlp is zero\n     */\n    function testCannotDepositGlpETHMinGlpZeroAmount() external {\n        uint256 amount = 1;\n        uint256 minUsdg = 1;\n        uint256 invalidMinGlp = 0;\n        address receiver = address(this);\n\n        vm.expectRevert(AutoPxGlp.ZeroAmount.selector);\n\n        autoPxGlp.depositGlpETH{value: amount}(\n            minUsdg,\n            invalidMinGlp,\n            receiver\n        );\n    }\n\n    /**\n        @notice Test tx reversion: receiver is the zero address\n     */\n    function testCannotDepositGlpETHReceiverZeroAddress() external {\n        uint256 amount = 1;\n        uint256 minUsdg = 1;\n        uint256 minGlp = 1;\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PxGmxReward.ZeroAddress.selector);\n\n        autoPxGlp.depositGlpETH{value: amount}(\n            minUsdg,\n            minGlp,\n            invalidReceiver\n        );\n    }\n\n    /**\n        @notice Test tx success: deposit using ETH to vault and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testDepositGlpETH(uint8 multiplier, uint32 secondsElapsed)\n        external\n    {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(0);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            // Deal ETH for the testAccount then deposit to the vault\n            uint256 ethAmount = multiplier * 1 ether;\n\n            vm.deal(testAccounts[i], ethAmount);\n\n            vm.startPrank(testAccounts[i]);\n\n            vm.expectEmit(true, true, false, false, address(autoPxGlp));\n\n            emit Deposit(testAccounts[i], testAccounts[i], 0, 0);\n\n            autoPxGlp.depositGlpETH{value: ethAmount}(1, 1, testAccounts[i]);\n\n            vm.stopPrank();\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 pxGmxRewardAfterFees = pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n\n            // Perform another deposit and assert the updated pxGMX reward states\n            _depositGlpETHWithTimeSkip(\n                (1 ether * (i + 1) * multiplier),\n                testAccounts[i],\n                0\n            );\n\n            uint256 newShares = _depositToVault(testAccounts[i]);\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                block.timestamp,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                block.timestamp,\n                initialBalance + newShares,\n                expectedUserRewardState\n            );\n            assertEq(\n                initialRewardState + pxGmxRewardAfterFees,\n                autoPxGlp.rewardState()\n            );\n\n            // Deposit should still increment the totalSupply and user shares\n            assertEq(supply + newShares, autoPxGlp.totalSupply());\n            assertEq(\n                initialBalance + newShares,\n                autoPxGlp.balanceOf(testAccounts[i])\n            );\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance + pxGmxRewardAfterFees,\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        mint TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: mint vault shares and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testMint(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            _depositToVault(testAccounts[i]);\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 pxGmxRewardAfterFees = pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n\n            // Perform mint instead of deposit and assert the updated pxGMX reward states\n            _depositGlpETHWithTimeSkip(\n                (1 ether * (i + 1) * multiplier),\n                testAccounts[i],\n                0\n            );\n\n            vm.startPrank(testAccounts[i]);\n\n            pxGlp.approve(address(autoPxGlp), pxGlp.balanceOf(testAccounts[i]));\n\n            uint256 newShares = autoPxGlp.previewDeposit(\n                pxGlp.balanceOf(testAccounts[i])\n            ) / 2;\n\n            autoPxGlp.mint(newShares, testAccounts[i]);\n\n            vm.stopPrank();\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                block.timestamp,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                block.timestamp,\n                initialBalance + newShares,\n                expectedUserRewardState\n            );\n            assertEq(\n                autoPxGlp.rewardState(),\n                initialRewardState + pxGmxRewardAfterFees\n            );\n\n            // Mint should still increment the totalSupply and user shares\n            assertEq(supply + newShares, autoPxGlp.totalSupply());\n            assertEq(\n                initialBalance + newShares,\n                autoPxGlp.balanceOf(testAccounts[i])\n            );\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance + pxGmxRewardAfterFees,\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        withdraw TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: withdraw from vault and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testWithdraw(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            _depositToVault(testAccounts[i]);\n\n            (\n                uint256 wethRewardState,\n                uint256 pxGmxRewardState\n            ) = _provisionRewardState(secondsElapsed);\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n            uint256 expectedAdditionalGlp = _calculateMinGlpAmount(\n                address(weth),\n                wethRewardState,\n                18\n            );\n            // Take into account fees\n            expectedAdditionalGlp -=\n                (expectedAdditionalGlp * pirexGmx.fees(PirexGmx.Fees.Deposit)) /\n                pirexGmx.FEE_DENOMINATOR();\n            expectedAdditionalGlp -=\n                (expectedAdditionalGlp * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n\n            // Withdraw from the vault and assert the updated pxGMX reward states\n            vm.startPrank(testAccounts[i]);\n\n            // Take into account additional glp from compound and withdraw all\n            uint256 shares = autoPxGlp.withdraw(\n                autoPxGlp.previewRedeem(initialBalance) + expectedAdditionalGlp,\n                testAccounts[i],\n                testAccounts[i]\n            );\n\n            vm.stopPrank();\n\n            // Since we withdraw the entire balance of the user, post-withdrawal should leave it with 0 share\n            assertEq(0, autoPxGlp.balanceOf(testAccounts[i]));\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                block.timestamp,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                block.timestamp,\n                initialBalance - shares,\n                expectedUserRewardState\n            );\n            assertEq(\n                initialRewardState +\n                    (pxGmxRewardState -\n                        (pxGmxRewardState * autoPxGlp.platformFee()) /\n                        autoPxGlp.FEE_DENOMINATOR()),\n                autoPxGlp.rewardState()\n            );\n\n            // Withdrawal should still decrement the totalSupply and user shares\n            assertEq(supply - shares, autoPxGlp.totalSupply());\n            assertEq(\n                initialBalance - shares,\n                autoPxGlp.balanceOf(testAccounts[i])\n            );\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance +\n                    (pxGmxRewardState -\n                        (pxGmxRewardState * autoPxGlp.platformFee()) /\n                        autoPxGlp.FEE_DENOMINATOR()),\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        redeem TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: redeem from vault and assert the pxGMX reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testRedeem(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            _depositToVault(testAccounts[i]);\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 initialBalance = autoPxGlp.balanceOf(testAccounts[i]);\n            uint256 initialRewardState = autoPxGlp.rewardState();\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n            uint256 expectedUserRewardState = _calculateUserRewards(\n                testAccounts[i]\n            );\n            uint256 pxGmxRewardAfterFees = pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 initialPxGmxBalance = pxGmx.balanceOf(address(autoPxGlp));\n\n            // Redeem from the vault and assert the updated pxGMX reward states\n            vm.prank(testAccounts[i]);\n\n            autoPxGlp.redeem(initialBalance, testAccounts[i], testAccounts[i]);\n\n            // Assert pxGMX reward states\n            _assertGlobalState(\n                block.timestamp,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards\n            );\n            _assertUserRewardState(\n                testAccounts[i],\n                block.timestamp,\n                0,\n                expectedUserRewardState\n            );\n            assertEq(\n                initialRewardState + pxGmxRewardAfterFees,\n                autoPxGlp.rewardState()\n            );\n\n            // Redemption should still decrement the totalSupply and user shares\n            assertEq(supply - initialBalance, autoPxGlp.totalSupply());\n            assertEq(0, autoPxGlp.balanceOf(testAccounts[i]));\n\n            // Also check the updated pxGMX balance updated from compound call\n            assertEq(\n                initialPxGmxBalance + pxGmxRewardAfterFees,\n                pxGmx.balanceOf(address(autoPxGlp))\n            );\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        claim TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx reversion: receiver is zero address\n     */\n    function testCannotClaimZeroAddress() external {\n        address invalidReceiver = address(0);\n\n        vm.expectRevert(PxGmxReward.ZeroAddress.selector);\n\n        autoPxGlp.claim(invalidReceiver);\n    }\n\n    /**\n        @notice Test tx success: claim pxGMX rewards and assert the reward states updates\n        @param  multiplier      uint8   Multiplied with fixed token amounts for randomness\n        @param  secondsElapsed  uint32  Seconds to forward timestamp\n     */\n    function testClaim(uint8 multiplier, uint32 secondsElapsed) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        uint256 totalClaimable;\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address account = testAccounts[i];\n            address receiver = testAccounts[i];\n\n            _depositToVault(account);\n\n            (, uint256 pxGmxRewardState) = _provisionRewardState(\n                secondsElapsed\n            );\n\n            uint256 pxGmxBalanceBeforeClaim = pxGmx.balanceOf(receiver);\n            uint256 expectedLastBalance = autoPxGlp.balanceOf(account);\n            uint256 expectedGlobalLastUpdate = block.timestamp;\n            uint256 expectedGlobalRewards = _calculateGlobalRewards();\n\n            totalClaimable +=\n                pxGmxRewardState -\n                (pxGmxRewardState * autoPxGlp.platformFee()) /\n                autoPxGlp.FEE_DENOMINATOR();\n            uint256 expectedUserRewardState = _calculateUserRewards(account);\n            uint256 expectedClaimableReward = (totalClaimable *\n                expectedUserRewardState) / expectedGlobalRewards;\n\n            // Event is only logged when rewards exists (ie. non-zero esGMX yields)\n            if (expectedClaimableReward != 0) {\n                vm.expectEmit(true, false, false, false, address(autoPxGlp));\n\n                emit PxGmxClaimed(account, receiver, 0);\n            }\n\n            // Claim pxGMX reward from the vault and transfer it to the receiver directly\n            vm.prank(account);\n\n            autoPxGlp.claim(receiver);\n\n            // Claiming should also update the pxGMX balance for the receiver and the reward state\n            assertEq(\n                expectedClaimableReward + pxGmxBalanceBeforeClaim,\n                pxGmx.balanceOf(receiver)\n            );\n            _assertGlobalState(\n                expectedGlobalLastUpdate,\n                autoPxGlp.totalSupply(),\n                expectedGlobalRewards - expectedUserRewardState\n            );\n            _assertUserRewardState(\n                account,\n                block.timestamp,\n                expectedLastBalance,\n                0\n            );\n\n            // Properly update the total tally of claimable pxGMX\n            totalClaimable -= expectedClaimableReward;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        transfer TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n        @notice Test tx success: transfer (or transferFrom) to another account and assert the pxGMX reward states\n        @param  multiplier          uint8   Multiplied with fixed token amounts for randomness\n        @param  transferPercentage  uint8   Percentage of sender balance to be transferred\n        @param  secondsElapsed      uint32  Seconds to forward timestamp\n        @param  useTransferFrom     bool    Whether to use transferFrom\n     */\n    function testTransfer(\n        uint8 multiplier,\n        uint8 transferPercentage,\n        uint32 secondsElapsed,\n        bool useTransferFrom\n    ) external {\n        _validateTestArgs(multiplier, secondsElapsed);\n\n        vm.assume(transferPercentage != 0);\n        vm.assume(transferPercentage <= 100);\n\n        _setupRewardsAndTestAccounts(multiplier);\n\n        for (uint256 i; i < testAccounts.length; ++i) {\n            address account = testAccounts[i];\n            address receiver = testAccounts[\n                (i < testAccounts.length - 1 ? i + 1 : 0)\n            ];\n\n            _depositToVault(account);\n\n            _provisionRewardState(secondsElapsed);\n\n            uint256 initialSenderBalance = autoPxGlp.balanceOf(account);\n            uint256 initialReceiverBalance = autoPxGlp.balanceOf(receiver);\n            uint256 supply = autoPxGlp.totalSupply();\n            uint256 expectedLastUpdate = block.timestamp;\n            uint256 expectedSenderRewardState = _calculateUserRewards(account);\n            uint256 expectedReceiverRewardState = _calculateUserRewards(\n                receiver\n            );\n\n            // Transfer certain percentages of the apxGLP holding to the other account\n            uint256 transferAmount = (initialSenderBalance *\n                transferPercentage) / 100;\n            uint256 expectedSenderBalance = initialSenderBalance -\n                transferAmount;\n            uint256 expectedReceiverBalance = initialReceiverBalance +\n                transferAmount;\n\n            // If transferFrom is used, make sure to properly approve the caller\n            if (useTransferFrom) {\n                vm.prank(account);\n\n                autoPxGlp.approve(address(this), transferAmount);\n\n                autoPxGlp.transferFrom(account, receiver, transferAmount);\n            } else {\n                vm.prank(account);\n\n                autoPxGlp.transfer(receiver, transferAmount);\n            }\n\n            // Assert pxGMX reward states for both sender and receiver\n            _assertUserRewardState(\n                account,\n                expectedLastUpdate,\n                expectedSenderBalance,\n                expectedSenderRewardState\n            );\n            _assertUserRewardState(\n                receiver,\n                expectedLastUpdate,\n                expectedReceiverBalance,\n                expectedReceiverRewardState\n            );\n\n            // Transfer should still update the balances and maintain totalSupply\n            assertEq(supply, autoPxGlp.totalSupply());\n            assertEq(expectedSenderBalance, autoPxGlp.balanceOf(account));\n            assertEq(expectedReceiverBalance, autoPxGlp.balanceOf(receiver));\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "AutoPxGmx.t.sol",
            "AutoPxGmx.sol",
            "AutoPxGlp.sol",
            "AutoPxGlp.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AutoPxGmx and AutoPxGlp contracts",
                "Type": "Loss of reward and fee",
                "Description": "Calling PirexRewards.claim(pxGmx/pxGpl, AutoPx*) directly transfers rewards to AutoPx* pool without compound logic get executed and fee calculation logic and pxGmx wouldn't be executed for those rewards. This bug would cause fee loss in AutoPxGmx and AutoPxGlp for contract and pxGmx's reward loss for users in AutoPxGlp.",
                "Repair": "Keep track of previous balance when compound() is executed and update this balance in deposits, withdraws, and claims so it can detect rewards that directly transferred to contract without call to compound()"
            },
            {
                "Location": "AutoPxGmx.maxWithdraw and AutoPxGlp.maxWithdraw functions",
                "Type": "Incorrect Calculation",
                "Description": "The maxWithdraw function in AutoPxGmx and AutoPxGlp calculates an asset amount that is too big and cannot be withdrawn, causing the withdraw function to revert. This is due to the function not taking into account the withdrawalPenalty, which is implemented in AutoPxGmx and AutoPxGlp but not in PirexERC4626. The fix is to implement the maxWithdraw function in AutoPxGmx and AutoPxGlp that overrides the function in PirexERC4626 and takes into account the withdrawalPenalty.",
                "Repair": "Implement the maxWithdraw function in AutoPxGmx and AutoPxGlp that overrides the function in PirexERC4626 and takes into account the withdrawalPenalty."
            }
        ]
    }
]