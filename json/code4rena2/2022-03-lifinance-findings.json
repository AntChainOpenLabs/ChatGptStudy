[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ITransactionManager } from \"../Interfaces/ITransactionManager.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title NXTP (Connext) Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through NXTP (Connext)\n */\ncontract NXTPFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.nxtp\");\n    struct Storage {\n        ITransactionManager nxtpTxManager;\n    }\n\n    /* ========== Events ========== */\n\n    event NXTPBridgeStarted(\n        bytes32 indexed lifiTransactionId,\n        bytes32 nxtpTransactionId,\n        ITransactionManager.TransactionData txData\n    );\n\n    /* ========== Init ========== */\n\n    function initNXTP(ITransactionManager _txMgrAddr) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.nxtpTxManager = _txMgrAddr;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice This function starts a cross-chain transaction using the NXTP protocol\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _nxtpData data needed to complete an NXTP cross-chain transaction\n     */\n    function startBridgeTokensViaNXTP(LiFiData memory _lifiData, ITransactionManager.PrepareArgs memory _nxtpData)\n        public\n        payable\n    {\n        // Ensure sender has enough to complete the bridge transaction\n        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;\n        if (sendingAssetId == address(0)) require(msg.value == _nxtpData.amount, \"ERR_INVALID_AMOUNT\");\n        else {\n            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _nxtpData.amount);\n            require(\n                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _nxtpData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        }\n\n        // Start the bridge process\n        _startBridge(_lifiData.transactionId, _nxtpData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice This function performs a swap or multiple swaps and then starts a cross-chain transaction\n     *         using the NXTP protocol.\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData array of data needed for swaps\n     * @param _nxtpData data needed to complete an NXTP cross-chain transaction\n     */\n    function swapAndStartBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        ITransactionManager.PrepareArgs memory _nxtpData\n    ) public payable {\n        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;\n        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;\n\n        require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n        _nxtpData.amount = _postSwapBalance;\n\n        _startBridge(_lifiData.transactionId, _nxtpData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Completes a cross-chain transaction on the receiving chain using the NXTP protocol.\n     * @param _lifiData data used purely for tracking and analytics\n     * @param assetId token received on the receiving chain\n     * @param receiver address that will receive the tokens\n     * @param amount number of tokens received\n     */\n    function completeBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        address assetId,\n        address receiver,\n        uint256 amount\n    ) public payable {\n        if (LibAsset.isNativeAsset(assetId)) {\n            require(msg.value == amount, \"INVALID_ETH_AMOUNT\");\n        } else {\n            require(msg.value == 0, \"ETH_WITH_ERC\");\n            LibAsset.transferFromERC20(assetId, msg.sender, address(this), amount);\n        }\n\n        LibAsset.transferAsset(assetId, payable(receiver), amount);\n\n        emit LiFiTransferCompleted(_lifiData.transactionId, assetId, receiver, amount, block.timestamp);\n    }\n\n    /**\n     * @notice Performs a swap before completing a cross-chain transaction\n     *         on the receiving chain using the NXTP protocol.\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData array of data needed for swaps\n     * @param finalAssetId token received on the receiving chain\n     * @param receiver address that will receive the tokens\n     */\n    function swapAndCompleteBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        address finalAssetId,\n        address receiver\n    ) public payable {\n        uint256 startingBalance = LibAsset.getOwnBalance(finalAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(finalAssetId);\n\n        uint256 finalBalance;\n\n        if (postSwapBalance > startingBalance) {\n            finalBalance = postSwapBalance - startingBalance;\n            LibAsset.transferAsset(finalAssetId, payable(receiver), finalBalance);\n        }\n\n        emit LiFiTransferCompleted(_lifiData.transactionId, finalAssetId, receiver, finalBalance, block.timestamp);\n    }\n\n    /* ========== Internal Functions ========== */\n\n    function _startBridge(bytes32 _transactionId, ITransactionManager.PrepareArgs memory _nxtpData) internal {\n        Storage storage s = getStorage();\n        IERC20 sendingAssetId = IERC20(_nxtpData.invariantData.sendingAssetId);\n\n        // Give Connext approval to bridge tokens\n        LibAsset.approveERC20(IERC20(sendingAssetId), address(s.nxtpTxManager), _nxtpData.amount);\n\n        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _nxtpData.amount : 0;\n\n        // Initiate bridge transaction on sending chain\n        ITransactionManager.TransactionData memory result = s.nxtpTxManager.prepare{ value: value }(_nxtpData);\n\n        emit NXTPBridgeStarted(_transactionId, result.transactionId, result);\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n\n    /* ========== Getter Functions ========== */\n\n    /**\n     * @notice show the NXTP transaction manager contract address\n     */\n    function getNXTPTransactionManager() external view returns (address) {\n        Storage storage s = getStorage();\n        return address(s.nxtpTxManager);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Anyswap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)\n */\ncontract AnyswapFacet is ILiFi, Swapper {\n    /* ========== Types ========== */\n\n    struct AnyswapData {\n        address token;\n        address router;\n        uint256 amount;\n        address recipient;\n        uint256 toChainId;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _anyswapData data specific to Anyswap\n     */\n    function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n            LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);\n\n            require(\n                LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _anyswapData data specific to Anyswap\n     */\n    function swapAndStartBridgeTokensViaAnyswap(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        AnyswapData memory _anyswapData\n    ) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /**\n     * @dev Conatains the business logic for the bridge via Anyswap\n     * @param _anyswapData data specific to Anyswap\n     */\n    function _startBridge(AnyswapData memory _anyswapData) internal {\n        // Check chain id\n        require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n        if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n                _anyswapData.token,\n                _anyswapData.recipient,\n                _anyswapData.toChainId\n            );\n            return;\n        }\n\n        if (_anyswapData.token != address(0)) {\n            // Has underlying token?\n            if (underlyingToken != address(0)) {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            } else {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOut(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ICBridge } from \"../Interfaces/ICBridge.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title CBridge Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through CBridge\n */\ncontract CBridgeFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.cbridge2\");\n    struct Storage {\n        address cBridge;\n        uint64 cBridgeChainId;\n    }\n\n    /* ========== Types ========== */\n\n    struct CBridgeData {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint64 dstChainId;\n        uint64 nonce;\n        uint32 maxSlippage;\n    }\n\n    /* ========== Init ========== */\n\n    /**\n     * @notice Initializes local variables for the CBridge facet\n     * @param _cBridge address of the canonical CBridge router contract\n     * @param _chainId chainId of this deployed contract\n     */\n    function initCbridge(address _cBridge, uint64 _chainId) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.cBridge = _cBridge;\n        s.cBridgeChainId = _chainId;\n        emit Inited(s.cBridge, s.cBridgeChainId);\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via CBridge\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _cBridgeData data specific to CBridge\n     */\n    function startBridgeTokensViaCBridge(LiFiData memory _lifiData, CBridgeData calldata _cBridgeData) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);\n\n            require(\n                LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via CBridge\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _cBridgeData data specific to CBridge\n     */\n    function swapAndStartBridgeTokensViaCBridge(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData memory _cBridgeData\n    ) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /*\n     * @dev Conatains the business logic for the bridge via CBridge\n     * @param _cBridgeData data specific to CBridge\n     */\n    function _startBridge(CBridgeData memory _cBridgeData) internal {\n        Storage storage s = getStorage();\n        address bridge = _bridge();\n\n        // Do CBridge stuff\n        require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n\n        if (LibAsset.isNativeAsset(_cBridgeData.token)) {\n            ICBridge(bridge).sendNative(\n                _cBridgeData.receiver,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        } else {\n            // Give CBridge approval to bridge tokens\n            LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);\n            // solhint-disable check-send-result\n            ICBridge(bridge).send(\n                _cBridgeData.receiver,\n                _cBridgeData.token,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        }\n    }\n\n    /*\n     * @dev Public view function for the CBridge router address\n     * @returns the router address\n     */\n    function _bridge() internal view returns (address) {\n        Storage storage s = getStorage();\n        return s.cBridge;\n    }\n\n    /**\n     * @dev fetch local storage\n     */\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IHopBridge } from \"../Interfaces/IHopBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Hop Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through Hop\n */\ncontract HopFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.hop\");\n    struct Storage {\n        mapping(string => IHopBridge.BridgeConfig) hopBridges;\n        uint256 hopChainId;\n    }\n\n    /* ========== Types ========== */\n\n    struct HopData {\n        string asset;\n        address recipient;\n        uint256 chainId;\n        uint256 amount;\n        uint256 bonderFee;\n        uint256 amountOutMin;\n        uint256 deadline;\n        uint256 destinationAmountOutMin;\n        uint256 destinationDeadline;\n    }\n\n    /* ========== Init ========== */\n\n    function initHop(\n        string[] memory _tokens,\n        IHopBridge.BridgeConfig[] memory _bridgeConfigs,\n        uint256 _chainId\n    ) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n\n        for (uint8 i; i < _tokens.length; i++) {\n            s.hopBridges[_tokens[i]] = _bridgeConfigs[i];\n        }\n        s.hopChainId = _chainId;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via Hop Protocol\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _hopData data specific to Hop Protocol\n     */\n    function startBridgeTokensViaHop(LiFiData memory _lifiData, HopData calldata _hopData) public payable {\n        address sendingAssetId = _bridge(_hopData.asset).token;\n\n        if (sendingAssetId == address(0)) require(msg.value == _hopData.amount, \"ERR_INVALID_AMOUNT\");\n        else {\n            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _hopData.amount);\n            require(\n                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _hopData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        }\n\n        _startBridge(_hopData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via Hop Protocol\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _hopData data specific to Hop Protocol\n     */\n    function swapAndStartBridgeTokensViaHop(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData memory _hopData\n    ) public payable {\n        address sendingAssetId = _bridge(_hopData.asset).token;\n\n        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;\n\n        require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n        _hopData.amount = _postSwapBalance;\n\n        _startBridge(_hopData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /**\n     * @dev Conatains the business logic for the bridge via Hop Protocol\n     * @param _hopData data specific to Hop Protocol\n     */\n    function _startBridge(HopData memory _hopData) internal {\n        Storage storage s = getStorage();\n        address sendingAssetId = _bridge(_hopData.asset).token;\n\n        address bridge;\n        if (s.hopChainId == 1) {\n            bridge = _bridge(_hopData.asset).bridge;\n        } else {\n            bridge = _bridge(_hopData.asset).ammWrapper;\n        }\n\n        // Do HOP stuff\n        require(s.hopChainId != _hopData.chainId, \"Cannot bridge to the same network.\");\n\n        // Give Hop approval to bridge tokens\n        LibAsset.approveERC20(IERC20(sendingAssetId), bridge, _hopData.amount);\n\n        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _hopData.amount : 0;\n\n        if (s.hopChainId == 1) {\n            // Ethereum L1\n            IHopBridge(bridge).sendToL2{ value: value }(\n                _hopData.chainId,\n                _hopData.recipient,\n                _hopData.amount,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline,\n                address(0),\n                0\n            );\n        } else {\n            // L2\n            // solhint-disable-next-line check-send-result\n            IHopBridge(bridge).swapAndSend{ value: value }(\n                _hopData.chainId,\n                _hopData.recipient,\n                _hopData.amount,\n                _hopData.bonderFee,\n                _hopData.amountOutMin,\n                _hopData.deadline,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline\n            );\n        }\n    }\n\n    function _bridge(string memory _asset) internal view returns (IHopBridge.BridgeConfig memory) {\n        Storage storage s = getStorage();\n        return s.hopBridges[_asset];\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "NXTPFacet.sol",
            "AnyswapFacet.sol",
            "CBridgeFacet.sol",
            "HopFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AnyswapFacet.sol, CBridgeFacet.sol, HopFacet.sol, NXTPFacet.sol",
                "Type": "ERC20 bridging functions do not revert on non-zero msg.value",
                "Description": "Any native funds mistakenly sent along with plain ERC20 bridging calls will be lost.",
                "Repair": "Consider reverting when bridging functions with non-native target are called with non-zero native amount added"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\n\nlibrary LibSwap {\n    uint256 private constant MAX_INT = 2**256 - 1;\n\n    struct SwapData {\n        address callTo;\n        address approveTo;\n        address sendingAssetId;\n        address receivingAssetId;\n        uint256 fromAmount;\n        bytes callData;\n    }\n\n    event AssetSwapped(\n        bytes32 transactionId,\n        address dex,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 timestamp\n    );\n\n    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n        uint256 fromAmount = _swapData.fromAmount;\n        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n        address fromAssetId = _swapData.sendingAssetId;\n        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n            LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);\n        }\n\n        if (!LibAsset.isNativeAsset(fromAssetId)) {\n            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n        emit AssetSwapped(\n            transactionId,\n            _swapData.callTo,\n            _swapData.sendingAssetId,\n            _swapData.receivingAssetId,\n            fromAmount,\n            toAmount,\n            block.timestamp\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibStorage } from \"../Libraries/LibStorage.sol\";\n\ncontract Swapper is ILiFi {\n    /* ========== Storage ========== */\n    LibStorage internal ls;\n\n    function _executeSwaps(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) internal {\n        // Swap\n        for (uint8 i; i < _swapData.length; i++) {\n            require(\n                ls.dexWhitelist[_swapData[i].approveTo] == true && ls.dexWhitelist[_swapData[i].callTo] == true,\n                \"Contract call not allowed!\"\n            );\n\n            LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "LibSwap.sol",
            "Swapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LibSwap.sol, Swapper.sol",
                "Type": "msg.value is Sent Multiple times When Performing a Swap",
                "Description": "If Swapper._executeSwaps() is called with the native token as the swapData.fromAssetId more than once and msg.value > 0 then more value will be transferred out of the contract than is received.",
                "Repair": "Only allow fromAssetId to be the native token once in _swapData in Swapper._executeSwaps(). If it occurs more than once the transaction should revert."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../Libraries/LibStorage.sol\";\nimport \"../Libraries/LibDiamond.sol\";\n\n/**\n * @title Optics Router Facet\n * @author Li.Finance (https://li.finance)\n * @notice Facet contract for managing approved DEXs to be used in swaps.\n */\ncontract DexManagerFacet {\n    LibStorage internal s;\n\n    /// @notice Register the address of a DEX contract to be approved for swapping.\n    /// @param _dex The address of the DEX contract to be approved.\n    function addDex(address _dex) external {\n        LibDiamond.enforceIsContractOwner();\n\n        if (s.dexWhitelist[_dex] == true) {\n            return;\n        }\n\n        s.dexWhitelist[_dex] = true;\n        s.dexs.push(_dex);\n    }\n\n    /// @notice Batch register the addresss of DEX contracts to be approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be approved.\n    function batchAddDex(address[] calldata _dexs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        for (uint256 i; i < _dexs.length; i++) {\n            if (s.dexWhitelist[_dexs[i]] == true) {\n                continue;\n            }\n            s.dexWhitelist[_dexs[i]] = true;\n            s.dexs.push(_dexs[i]);\n        }\n    }\n\n    /// @notice Unregister the address of a DEX contract approved for swapping.\n    /// @param _dex The address of the DEX contract to be unregistered.\n    function removeDex(address _dex) external {\n        LibDiamond.enforceIsContractOwner();\n\n        if (s.dexWhitelist[_dex] == false) {\n            return;\n        }\n\n        s.dexWhitelist[_dex] = false;\n        for (uint256 i; i < s.dexs.length; i++) {\n            if (s.dexs[i] == _dex) {\n                _removeDex(i);\n                return;\n            }\n        }\n    }\n\n    /// @notice Batch unregister the addresses of DEX contracts approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be unregistered.\n    function batchRemoveDex(address[] calldata _dexs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        for (uint256 i; i < _dexs.length; i++) {\n            if (s.dexWhitelist[_dexs[i]] == false) {\n                continue;\n            }\n            s.dexWhitelist[_dexs[i]] = false;\n            for (uint256 j; j < s.dexs.length; j++) {\n                if (s.dexs[j] == _dexs[i]) {\n                    _removeDex(j);\n                    return;\n                }\n            }\n        }\n    }\n\n    function approvedDexs() external view returns (address[] memory) {\n        return s.dexs;\n    }\n\n    function _removeDex(uint256 index) private {\n        // Move the last element into the place to delete\n        s.dexs[index] = s.dexs[s.dexs.length - 1];\n        // Remove the last element\n        s.dexs.pop();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\ncontract WithdrawFacet {\n    using SafeERC20 for IERC20;\n    address private constant NATIVE_ASSET = address(0);\n\n    event LogWithdraw(address indexed _assetAddress, address _from, uint256 amount);\n\n    /**\n     * @dev Withdraw asset.\n     * @param _assetAddress Asset to be withdrawn.\n     * @param _to address to withdraw to.\n     * @param _amount amount of asset to withdraw.\n     */\n    function withdraw(\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) public {\n        LibDiamond.enforceIsContractOwner();\n        address sendTo = (_to == address(0)) ? msg.sender : _to;\n        uint256 assetBalance;\n        if (_assetAddress == NATIVE_ASSET) {\n            address self = address(this); // workaround for a possible solidity bug\n            assert(_amount <= self.balance);\n            payable(sendTo).transfer(_amount);\n        } else {\n            assetBalance = IERC20(_assetAddress).balanceOf(address(this));\n            assert(_amount <= assetBalance);\n            IERC20(_assetAddress).safeTransfer(sendTo, _amount);\n        }\n        emit LogWithdraw(sendTo, _assetAddress, _amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { IDiamondCut } from \"../Interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n    }\n}\n\n\n",
        "CodeNames": [
            "DexManagerFacet.sol",
            "WithdrawFacet.sol",
            "DiamondCutFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "DiamondCutFacet.sol, WithdrawFacet.sol, DexManagerFacet.sol",
                "Type": "Reputation Risks with contractOwner",
                "Description": "contractOwner has complete freedom to change any functionality and withdraw/rug all assets.",
                "Repair": "Implement extra safeguards such as limiting the time period where sensitive functions can be used, having a waiting period before pushed update is executed, and using a multisig to mitigate single point of failure in case contractOwner private key leaks."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Anyswap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)\n */\ncontract AnyswapFacet is ILiFi, Swapper {\n    /* ========== Types ========== */\n\n    struct AnyswapData {\n        address token;\n        address router;\n        uint256 amount;\n        address recipient;\n        uint256 toChainId;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _anyswapData data specific to Anyswap\n     */\n    function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n            LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);\n\n            require(\n                LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _anyswapData data specific to Anyswap\n     */\n    function swapAndStartBridgeTokensViaAnyswap(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        AnyswapData memory _anyswapData\n    ) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /**\n     * @dev Conatains the business logic for the bridge via Anyswap\n     * @param _anyswapData data specific to Anyswap\n     */\n    function _startBridge(AnyswapData memory _anyswapData) internal {\n        // Check chain id\n        require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n        if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n                _anyswapData.token,\n                _anyswapData.recipient,\n                _anyswapData.toChainId\n            );\n            return;\n        }\n\n        if (_anyswapData.token != address(0)) {\n            // Has underlying token?\n            if (underlyingToken != address(0)) {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            } else {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOut(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "AnyswapFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AnyswapFacet.sol#L35-L53",
                "Type": "Arbitrary token approval",
                "Description": "AnyswapFacet can be exploited to approve arbitrary tokens.",
                "Repair": "Whitelist Anyswap tokens and routers, restrict attacker's ability to use malicious contracts, call IAnyswapToken(_anyswapData.token).underlying() only once and pass the value to _startBridge()"
            },
            {
                "Location": "AnyswapFacet.sol#L131-L157",
                "Type": "Infinite approval vulnerability",
                "Description": "Infinite approval to an arbitrary address can be used to steal all the funds from the contract.",
                "Repair": "Whitelisting the _anyswapData.router rather than trusting user's inputs; Or, only approve() for the amount that required for the current transaction instead of infinite approval."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Generic Swap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for swapping through ANY DEX\n * @dev Uses calldata to execute arbitrary methods on DEXs\n */\ncontract GenericSwapFacet is ILiFi, Swapper {\n    /* ========== Public Functions ========== */\n\n    /**\n     * @notice Performs a swap and that's it\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     */\n    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {\n        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n\n        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "GenericSwapFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GenericSwapFacet.sol#L23-L30",
                "Type": "Loss of funds",
                "Description": "Reliance on lifiData.receivingAssetId can cause loss of funds.",
                "Repair": "Add a check that _lifiData.receivingAssetId equals the receivingAssetId of the last index of the SwapData array, or simply use the receivingAssetId of the last index of the SwapData array for sending the final tokens to the user"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ICBridge } from \"../Interfaces/ICBridge.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title CBridge Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through CBridge\n */\ncontract CBridgeFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.cbridge2\");\n    struct Storage {\n        address cBridge;\n        uint64 cBridgeChainId;\n    }\n\n    /* ========== Types ========== */\n\n    struct CBridgeData {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint64 dstChainId;\n        uint64 nonce;\n        uint32 maxSlippage;\n    }\n\n    /* ========== Init ========== */\n\n    /**\n     * @notice Initializes local variables for the CBridge facet\n     * @param _cBridge address of the canonical CBridge router contract\n     * @param _chainId chainId of this deployed contract\n     */\n    function initCbridge(address _cBridge, uint64 _chainId) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.cBridge = _cBridge;\n        s.cBridgeChainId = _chainId;\n        emit Inited(s.cBridge, s.cBridgeChainId);\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via CBridge\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _cBridgeData data specific to CBridge\n     */\n    function startBridgeTokensViaCBridge(LiFiData memory _lifiData, CBridgeData calldata _cBridgeData) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);\n\n            require(\n                LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via CBridge\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _cBridgeData data specific to CBridge\n     */\n    function swapAndStartBridgeTokensViaCBridge(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData memory _cBridgeData\n    ) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /*\n     * @dev Conatains the business logic for the bridge via CBridge\n     * @param _cBridgeData data specific to CBridge\n     */\n    function _startBridge(CBridgeData memory _cBridgeData) internal {\n        Storage storage s = getStorage();\n        address bridge = _bridge();\n\n        // Do CBridge stuff\n        require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n\n        if (LibAsset.isNativeAsset(_cBridgeData.token)) {\n            ICBridge(bridge).sendNative(\n                _cBridgeData.receiver,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        } else {\n            // Give CBridge approval to bridge tokens\n            LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);\n            // solhint-disable check-send-result\n            ICBridge(bridge).send(\n                _cBridgeData.receiver,\n                _cBridgeData.token,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        }\n    }\n\n    /*\n     * @dev Public view function for the CBridge router address\n     * @returns the router address\n     */\n    function _bridge() internal view returns (address) {\n        Storage storage s = getStorage();\n        return s.cBridge;\n    }\n\n    /**\n     * @dev fetch local storage\n     */\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "CBridgeFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CBridgeFacet.sol#L68",
                "Type": "Loss of funds",
                "Description": "Should prevent users from sending more native tokens in the startBridgeTokensViaCBridge function.",
                "Repair": "Change = to == at line 68"
            },
            {
                "Location": "CBridgeFacet.sol#L150-L156",
                "Type": "Missing functionality vulnerability",
                "Description": "cBridge integration fails to send native tokens.",
                "Repair": "Add the payable keyword to the CBridge interface. The external sendNative() call should include sending the native tokens together with it."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\n\nlibrary LibSwap {\n    uint256 private constant MAX_INT = 2**256 - 1;\n\n    struct SwapData {\n        address callTo;\n        address approveTo;\n        address sendingAssetId;\n        address receivingAssetId;\n        uint256 fromAmount;\n        bytes callData;\n    }\n\n    event AssetSwapped(\n        bytes32 transactionId,\n        address dex,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 timestamp\n    );\n\n    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n        uint256 fromAmount = _swapData.fromAmount;\n        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n        address fromAssetId = _swapData.sendingAssetId;\n        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n            LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);\n        }\n\n        if (!LibAsset.isNativeAsset(fromAssetId)) {\n            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n        emit AssetSwapped(\n            transactionId,\n            _swapData.callTo,\n            _swapData.sendingAssetId,\n            _swapData.receivingAssetId,\n            fromAmount,\n            toAmount,\n            block.timestamp\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "LibSwap.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LibSwap.sol#L29-L58",
                "Type": "Excess funds not returned",
                "Description": "It is probable for _swapData.fromAmount to be greater than the actual amount used (eg. when swapping for an exact output, or when performing another swap after swapping with an exact input). However, these funds aren\u2019t returned back to the user and are left in the lifi contract.",
                "Repair": "Store the contract\u2019s from balance before and after the swap. Refund any excess back to the user."
            },
            {
                "Location": "LibSwap.sol#L42-L46",
                "Type": "Failed transfer vulnerability",
                "Description": "Failed transfer with low level call won't revert.",
                "Repair": "Use low-level call.value(amount) with the corresponding result check or using the OpenZeppelin's Address.sendValue."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\n\nlibrary LibSwap {\n    uint256 private constant MAX_INT = 2**256 - 1;\n\n    struct SwapData {\n        address callTo;\n        address approveTo;\n        address sendingAssetId;\n        address receivingAssetId;\n        uint256 fromAmount;\n        bytes callData;\n    }\n\n    event AssetSwapped(\n        bytes32 transactionId,\n        address dex,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 timestamp\n    );\n\n    function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n        uint256 fromAmount = _swapData.fromAmount;\n        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n        address fromAssetId = _swapData.sendingAssetId;\n        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n            LibAsset.transferFromERC20(fromAssetId, msg.sender, address(this), fromAmount);\n        }\n\n        if (!LibAsset.isNativeAsset(fromAssetId)) {\n            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n        emit AssetSwapped(\n            transactionId,\n            _swapData.callTo,\n            _swapData.sendingAssetId,\n            _swapData.receivingAssetId,\n            fromAmount,\n            toAmount,\n            block.timestamp\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Generic Swap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for swapping through ANY DEX\n * @dev Uses calldata to execute arbitrary methods on DEXs\n */\ncontract GenericSwapFacet is ILiFi, Swapper {\n    /* ========== Public Functions ========== */\n\n    /**\n     * @notice Performs a swap and that's it\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     */\n    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {\n        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n\n        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "LibSwap.sol",
            "GenericSwapFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GenericSwapFacet.sol#L23-L30, LibSwap.sol#L48",
                "Type": "Missing checks for returned tokens",
                "Description": "Every function that stems from the GenericSwapFacet lacks checks to ensure that some tokens have been returned via the swaps. In LibSwap.sol in the swap() function, the swap call is sent to the target DEX. A return of success is required, otherwise the operation will revert.",
                "Repair": "Add checks to ensure that some tokens have been returned via the swaps. Use function signature whitelists as opposed to contract address whitelists. Alternatively, add a require statement in swapTokensGeneric() to ensure that at least a single token was received."
            },
            {
                "Location": "LibSwap.swap(), GenericSwapFacet.sol",
                "Type": "Free swaps given certain conditions",
                "Description": "Anyone can get swaps for free given certain conditions in swap. Remaining or unaccounted ERC20 balance could be freely taken through swapTokensGenerics and swap.",
                "Repair": "Ensure funds are always subtracted from users account in swap, even if LiFi has enough balance to do the swap."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ITransactionManager } from \"../Interfaces/ITransactionManager.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title NXTP (Connext) Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through NXTP (Connext)\n */\ncontract NXTPFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.nxtp\");\n    struct Storage {\n        ITransactionManager nxtpTxManager;\n    }\n\n    /* ========== Events ========== */\n\n    event NXTPBridgeStarted(\n        bytes32 indexed lifiTransactionId,\n        bytes32 nxtpTransactionId,\n        ITransactionManager.TransactionData txData\n    );\n\n    /* ========== Init ========== */\n\n    function initNXTP(ITransactionManager _txMgrAddr) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.nxtpTxManager = _txMgrAddr;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice This function starts a cross-chain transaction using the NXTP protocol\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _nxtpData data needed to complete an NXTP cross-chain transaction\n     */\n    function startBridgeTokensViaNXTP(LiFiData memory _lifiData, ITransactionManager.PrepareArgs memory _nxtpData)\n        public\n        payable\n    {\n        // Ensure sender has enough to complete the bridge transaction\n        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;\n        if (sendingAssetId == address(0)) require(msg.value == _nxtpData.amount, \"ERR_INVALID_AMOUNT\");\n        else {\n            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _nxtpData.amount);\n            require(\n                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _nxtpData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        }\n\n        // Start the bridge process\n        _startBridge(_lifiData.transactionId, _nxtpData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice This function performs a swap or multiple swaps and then starts a cross-chain transaction\n     *         using the NXTP protocol.\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData array of data needed for swaps\n     * @param _nxtpData data needed to complete an NXTP cross-chain transaction\n     */\n    function swapAndStartBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        ITransactionManager.PrepareArgs memory _nxtpData\n    ) public payable {\n        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;\n        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;\n\n        require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n        _nxtpData.amount = _postSwapBalance;\n\n        _startBridge(_lifiData.transactionId, _nxtpData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Completes a cross-chain transaction on the receiving chain using the NXTP protocol.\n     * @param _lifiData data used purely for tracking and analytics\n     * @param assetId token received on the receiving chain\n     * @param receiver address that will receive the tokens\n     * @param amount number of tokens received\n     */\n    function completeBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        address assetId,\n        address receiver,\n        uint256 amount\n    ) public payable {\n        if (LibAsset.isNativeAsset(assetId)) {\n            require(msg.value == amount, \"INVALID_ETH_AMOUNT\");\n        } else {\n            require(msg.value == 0, \"ETH_WITH_ERC\");\n            LibAsset.transferFromERC20(assetId, msg.sender, address(this), amount);\n        }\n\n        LibAsset.transferAsset(assetId, payable(receiver), amount);\n\n        emit LiFiTransferCompleted(_lifiData.transactionId, assetId, receiver, amount, block.timestamp);\n    }\n\n    /**\n     * @notice Performs a swap before completing a cross-chain transaction\n     *         on the receiving chain using the NXTP protocol.\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData array of data needed for swaps\n     * @param finalAssetId token received on the receiving chain\n     * @param receiver address that will receive the tokens\n     */\n    function swapAndCompleteBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        address finalAssetId,\n        address receiver\n    ) public payable {\n        uint256 startingBalance = LibAsset.getOwnBalance(finalAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(finalAssetId);\n\n        uint256 finalBalance;\n\n        if (postSwapBalance > startingBalance) {\n            finalBalance = postSwapBalance - startingBalance;\n            LibAsset.transferAsset(finalAssetId, payable(receiver), finalBalance);\n        }\n\n        emit LiFiTransferCompleted(_lifiData.transactionId, finalAssetId, receiver, finalBalance, block.timestamp);\n    }\n\n    /* ========== Internal Functions ========== */\n\n    function _startBridge(bytes32 _transactionId, ITransactionManager.PrepareArgs memory _nxtpData) internal {\n        Storage storage s = getStorage();\n        IERC20 sendingAssetId = IERC20(_nxtpData.invariantData.sendingAssetId);\n\n        // Give Connext approval to bridge tokens\n        LibAsset.approveERC20(IERC20(sendingAssetId), address(s.nxtpTxManager), _nxtpData.amount);\n\n        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _nxtpData.amount : 0;\n\n        // Initiate bridge transaction on sending chain\n        ITransactionManager.TransactionData memory result = s.nxtpTxManager.prepare{ value: value }(_nxtpData);\n\n        emit NXTPBridgeStarted(_transactionId, result.transactionId, result);\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n\n    /* ========== Getter Functions ========== */\n\n    /**\n     * @notice show the NXTP transaction manager contract address\n     */\n    function getNXTPTransactionManager() external view returns (address) {\n        Storage storage s = getStorage();\n        return address(s.nxtpTxManager);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Generic Swap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for swapping through ANY DEX\n * @dev Uses calldata to execute arbitrary methods on DEXs\n */\ncontract GenericSwapFacet is ILiFi, Swapper {\n    /* ========== Public Functions ========== */\n\n    /**\n     * @notice Performs a swap and that's it\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     */\n    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {\n        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n\n        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IHopBridge } from \"../Interfaces/IHopBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Hop Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through Hop\n */\ncontract HopFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.hop\");\n    struct Storage {\n        mapping(string => IHopBridge.BridgeConfig) hopBridges;\n        uint256 hopChainId;\n    }\n\n    /* ========== Types ========== */\n\n    struct HopData {\n        string asset;\n        address recipient;\n        uint256 chainId;\n        uint256 amount;\n        uint256 bonderFee;\n        uint256 amountOutMin;\n        uint256 deadline;\n        uint256 destinationAmountOutMin;\n        uint256 destinationDeadline;\n    }\n\n    /* ========== Init ========== */\n\n    function initHop(\n        string[] memory _tokens,\n        IHopBridge.BridgeConfig[] memory _bridgeConfigs,\n        uint256 _chainId\n    ) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n\n        for (uint8 i; i < _tokens.length; i++) {\n            s.hopBridges[_tokens[i]] = _bridgeConfigs[i];\n        }\n        s.hopChainId = _chainId;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via Hop Protocol\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _hopData data specific to Hop Protocol\n     */\n    function startBridgeTokensViaHop(LiFiData memory _lifiData, HopData calldata _hopData) public payable {\n        address sendingAssetId = _bridge(_hopData.asset).token;\n\n        if (sendingAssetId == address(0)) require(msg.value == _hopData.amount, \"ERR_INVALID_AMOUNT\");\n        else {\n            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _hopData.amount);\n            require(\n                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _hopData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        }\n\n        _startBridge(_hopData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via Hop Protocol\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _hopData data specific to Hop Protocol\n     */\n    function swapAndStartBridgeTokensViaHop(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData memory _hopData\n    ) public payable {\n        address sendingAssetId = _bridge(_hopData.asset).token;\n\n        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;\n\n        require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n        _hopData.amount = _postSwapBalance;\n\n        _startBridge(_hopData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /**\n     * @dev Conatains the business logic for the bridge via Hop Protocol\n     * @param _hopData data specific to Hop Protocol\n     */\n    function _startBridge(HopData memory _hopData) internal {\n        Storage storage s = getStorage();\n        address sendingAssetId = _bridge(_hopData.asset).token;\n\n        address bridge;\n        if (s.hopChainId == 1) {\n            bridge = _bridge(_hopData.asset).bridge;\n        } else {\n            bridge = _bridge(_hopData.asset).ammWrapper;\n        }\n\n        // Do HOP stuff\n        require(s.hopChainId != _hopData.chainId, \"Cannot bridge to the same network.\");\n\n        // Give Hop approval to bridge tokens\n        LibAsset.approveERC20(IERC20(sendingAssetId), bridge, _hopData.amount);\n\n        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _hopData.amount : 0;\n\n        if (s.hopChainId == 1) {\n            // Ethereum L1\n            IHopBridge(bridge).sendToL2{ value: value }(\n                _hopData.chainId,\n                _hopData.recipient,\n                _hopData.amount,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline,\n                address(0),\n                0\n            );\n        } else {\n            // L2\n            // solhint-disable-next-line check-send-result\n            IHopBridge(bridge).swapAndSend{ value: value }(\n                _hopData.chainId,\n                _hopData.recipient,\n                _hopData.amount,\n                _hopData.bonderFee,\n                _hopData.amountOutMin,\n                _hopData.deadline,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline\n            );\n        }\n    }\n\n    function _bridge(string memory _asset) internal view returns (IHopBridge.BridgeConfig memory) {\n        Storage storage s = getStorage();\n        return s.hopBridges[_asset];\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibStorage } from \"../Libraries/LibStorage.sol\";\n\ncontract Swapper is ILiFi {\n    /* ========== Storage ========== */\n    LibStorage internal ls;\n\n    function _executeSwaps(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) internal {\n        // Swap\n        for (uint8 i; i < _swapData.length; i++) {\n            require(\n                ls.dexWhitelist[_swapData[i].approveTo] == true && ls.dexWhitelist[_swapData[i].callTo] == true,\n                \"Contract call not allowed!\"\n            );\n\n            LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Anyswap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)\n */\ncontract AnyswapFacet is ILiFi, Swapper {\n    /* ========== Types ========== */\n\n    struct AnyswapData {\n        address token;\n        address router;\n        uint256 amount;\n        address recipient;\n        uint256 toChainId;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _anyswapData data specific to Anyswap\n     */\n    function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n            LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);\n\n            require(\n                LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _anyswapData data specific to Anyswap\n     */\n    function swapAndStartBridgeTokensViaAnyswap(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        AnyswapData memory _anyswapData\n    ) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /**\n     * @dev Conatains the business logic for the bridge via Anyswap\n     * @param _anyswapData data specific to Anyswap\n     */\n    function _startBridge(AnyswapData memory _anyswapData) internal {\n        // Check chain id\n        require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n        if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n                _anyswapData.token,\n                _anyswapData.recipient,\n                _anyswapData.toChainId\n            );\n            return;\n        }\n\n        if (_anyswapData.token != address(0)) {\n            // Has underlying token?\n            if (underlyingToken != address(0)) {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            } else {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOut(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ICBridge } from \"../Interfaces/ICBridge.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title CBridge Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through CBridge\n */\ncontract CBridgeFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.cbridge2\");\n    struct Storage {\n        address cBridge;\n        uint64 cBridgeChainId;\n    }\n\n    /* ========== Types ========== */\n\n    struct CBridgeData {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint64 dstChainId;\n        uint64 nonce;\n        uint32 maxSlippage;\n    }\n\n    /* ========== Init ========== */\n\n    /**\n     * @notice Initializes local variables for the CBridge facet\n     * @param _cBridge address of the canonical CBridge router contract\n     * @param _chainId chainId of this deployed contract\n     */\n    function initCbridge(address _cBridge, uint64 _chainId) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.cBridge = _cBridge;\n        s.cBridgeChainId = _chainId;\n        emit Inited(s.cBridge, s.cBridgeChainId);\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via CBridge\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _cBridgeData data specific to CBridge\n     */\n    function startBridgeTokensViaCBridge(LiFiData memory _lifiData, CBridgeData calldata _cBridgeData) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);\n\n            require(\n                LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via CBridge\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _cBridgeData data specific to CBridge\n     */\n    function swapAndStartBridgeTokensViaCBridge(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData memory _cBridgeData\n    ) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /*\n     * @dev Conatains the business logic for the bridge via CBridge\n     * @param _cBridgeData data specific to CBridge\n     */\n    function _startBridge(CBridgeData memory _cBridgeData) internal {\n        Storage storage s = getStorage();\n        address bridge = _bridge();\n\n        // Do CBridge stuff\n        require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n\n        if (LibAsset.isNativeAsset(_cBridgeData.token)) {\n            ICBridge(bridge).sendNative(\n                _cBridgeData.receiver,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        } else {\n            // Give CBridge approval to bridge tokens\n            LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);\n            // solhint-disable check-send-result\n            ICBridge(bridge).send(\n                _cBridgeData.receiver,\n                _cBridgeData.token,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        }\n    }\n\n    /*\n     * @dev Public view function for the CBridge router address\n     * @returns the router address\n     */\n    function _bridge() internal view returns (address) {\n        Storage storage s = getStorage();\n        return s.cBridge;\n    }\n\n    /**\n     * @dev fetch local storage\n     */\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "NXTPFacet.sol",
            "GenericSwapFacet.sol",
            "HopFacet.sol",
            "Swapper.sol",
            "AnyswapFacet.sol",
            "CBridgeFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Functions which call Swapper._executeSwap() such as GenericSwapFacet.swapTokensGeneric(), CBridgeFacet.swapAndStartBridgeTokensViaCBridge(), AnyswapFacet.swapAndStartBridgeTokensViaAnyswap(), HopFacet.swapAndStartBridgeTokensViaHop(), NXTPFacet.swapAndStartBridgeTokensViaNXTP(), and NXTPFacet.swapAndCompleteBridgeTokensViaNXTP()",
                "Type": "Reentrancy",
                "Description": "There is a reentrancy vulnerability in functions which call Swapper._executeSwap() which would allow the attacker to change their postSwapBalance. The issue occurs since it is possible for an attacker to reenter this function during _executeSwaps(), that is because execute swap makes numerous external calls, such as to the AMM, or to untrusted ERC20 token addresses.",
                "Repair": "Add a reentrancy guard over every function which may send or receive tokens. Ensure the same slot is used to store the reentrancy guard so all required functions are covered by a single guard."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"../Libraries/LibStorage.sol\";\nimport \"../Libraries/LibDiamond.sol\";\n\n/**\n * @title Optics Router Facet\n * @author Li.Finance (https://li.finance)\n * @notice Facet contract for managing approved DEXs to be used in swaps.\n */\ncontract DexManagerFacet {\n    LibStorage internal s;\n\n    /// @notice Register the address of a DEX contract to be approved for swapping.\n    /// @param _dex The address of the DEX contract to be approved.\n    function addDex(address _dex) external {\n        LibDiamond.enforceIsContractOwner();\n\n        if (s.dexWhitelist[_dex] == true) {\n            return;\n        }\n\n        s.dexWhitelist[_dex] = true;\n        s.dexs.push(_dex);\n    }\n\n    /// @notice Batch register the addresss of DEX contracts to be approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be approved.\n    function batchAddDex(address[] calldata _dexs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        for (uint256 i; i < _dexs.length; i++) {\n            if (s.dexWhitelist[_dexs[i]] == true) {\n                continue;\n            }\n            s.dexWhitelist[_dexs[i]] = true;\n            s.dexs.push(_dexs[i]);\n        }\n    }\n\n    /// @notice Unregister the address of a DEX contract approved for swapping.\n    /// @param _dex The address of the DEX contract to be unregistered.\n    function removeDex(address _dex) external {\n        LibDiamond.enforceIsContractOwner();\n\n        if (s.dexWhitelist[_dex] == false) {\n            return;\n        }\n\n        s.dexWhitelist[_dex] = false;\n        for (uint256 i; i < s.dexs.length; i++) {\n            if (s.dexs[i] == _dex) {\n                _removeDex(i);\n                return;\n            }\n        }\n    }\n\n    /// @notice Batch unregister the addresses of DEX contracts approved for swapping.\n    /// @param _dexs The addresses of the DEX contracts to be unregistered.\n    function batchRemoveDex(address[] calldata _dexs) external {\n        LibDiamond.enforceIsContractOwner();\n\n        for (uint256 i; i < _dexs.length; i++) {\n            if (s.dexWhitelist[_dexs[i]] == false) {\n                continue;\n            }\n            s.dexWhitelist[_dexs[i]] = false;\n            for (uint256 j; j < s.dexs.length; j++) {\n                if (s.dexs[j] == _dexs[i]) {\n                    _removeDex(j);\n                    return;\n                }\n            }\n        }\n    }\n\n    function approvedDexs() external view returns (address[] memory) {\n        return s.dexs;\n    }\n\n    function _removeDex(uint256 index) private {\n        // Move the last element into the place to delete\n        s.dexs[index] = s.dexs[s.dexs.length - 1];\n        // Remove the last element\n        s.dexs.pop();\n    }\n}\n\n\n",
        "CodeNames": [
            "DexManagerFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "DexManagerFacet.sol#L71-L73",
                "Type": "Looping vulnerability",
                "Description": "DexManagerFacet: batchRemoveDex() removes first dex only.",
                "Repair": "Replace return with break. Emit an event whenever a DEX is added or removed."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\ncontract WithdrawFacet {\n    using SafeERC20 for IERC20;\n    address private constant NATIVE_ASSET = address(0);\n\n    event LogWithdraw(address indexed _assetAddress, address _from, uint256 amount);\n\n    /**\n     * @dev Withdraw asset.\n     * @param _assetAddress Asset to be withdrawn.\n     * @param _to address to withdraw to.\n     * @param _amount amount of asset to withdraw.\n     */\n    function withdraw(\n        address _assetAddress,\n        address _to,\n        uint256 _amount\n    ) public {\n        LibDiamond.enforceIsContractOwner();\n        address sendTo = (_to == address(0)) ? msg.sender : _to;\n        uint256 assetBalance;\n        if (_assetAddress == NATIVE_ASSET) {\n            address self = address(this); // workaround for a possible solidity bug\n            assert(_amount <= self.balance);\n            payable(sendTo).transfer(_amount);\n        } else {\n            assetBalance = IERC20(_assetAddress).balanceOf(address(this));\n            assert(_amount <= assetBalance);\n            IERC20(_assetAddress).safeTransfer(sendTo, _amount);\n        }\n        emit LogWithdraw(sendTo, _assetAddress, _amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "WithdrawFacet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "WithdrawFacet.sol#L28-L31",
                "Type": "Unsafe transfer vulnerability",
                "Description": "WithdrawFacet's withdraw calls native payable.transfer, which can be unusable for DiamondStorage owner contract.",
                "Repair": "Using low-level call.value(amount) with the corresponding result check or using the OpenZeppelin's Address.sendValue."
            }
        ]
    }
]