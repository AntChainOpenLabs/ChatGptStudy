[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function strategistBootyClaim()",
                "Type": "Reward Overpayment",
                "Description": "Strategists can take more rewards than they should using the function strategistBootyClaim(). A strategist can call the function using the same asset/quote parameters. Then both of fillCountA and fillCountQ will be the same positive values. The first code block for fillCountA(L597-L610) will work the same as expected but the second block for fillCountQ(L611-L624) will be executed for the same asset again. Two mappings(totalFillsPerAsset, strategist2Fills) that save rewards will be updated for the asset already after the first block but totalFillsPerAsset and balance of this contract for quote would be still positive as there would be remaining rewards for other strategists. So the strategist can get paid once more for the same asset. A reentrancy attack is possible also because two mappings are updated after transfer funds.",
                "Repair": "Add require(asset != quote, \"asset = quote\"); at the beginning of the function. Update the state of 2 mappings before transfer. Move L608-L609 to L601. Move L622-L623 to L615."
            },
            {
                "Location": "swapForETH or swapWithETH/swapEntireBalance/swap function",
                "Type": "User will lose funds",
                "Description": "User will lose funds if user accidentally pass route with only 1 value which is route[0]=X WETH while calling swapForETH or swapWithETH/swapEntireBalance/swap function.",
                "Repair": "Add a check to require a minimum length for the route parameter"
            },
            {
                "Location": "offer(uint, ERC20, uint, ERC20) and insert(uint, unint)",
                "Type": "Access Control",
                "Description": "The offer() and insert() functions should only be accessible by the keepers as per the comments. However, there is no authorization logic or access control implemented. Therefore, anyone could call these two functions.",
                "Repair": "Implement necessary access controls to ensure only authorized users can access or remove these functions to reduce the attack surface of the protocol"
            },
            {
                "Location": "Multiple Unsafe Arithmetic Operations",
                "Type": "Unsafe Arithmetic Operations",
                "Description": "The referenced lines all perform unsafe multiplications using the unitary denominations of either 1 ether (1e18) or 109 (1e9), both of which can easily lead to overflows when used as a multiplier for large amounts of assets.",
                "Repair": "Make use of the mul operation exposed by the DSMath library already incorporated into the codebase to guarantee all operations are performed safely and cannot overflow."
            },
            {
                "Location": "RubiconRouter: Offers created through offerForETH cannot be cancelled",
                "Type": "Locked Tokens",
                "Description": "If a user creates an offer through the offerForETH function of the RubiconRouter contract, the offer cannot be cancelled, and the user's tokens will be locked in the contract if no one accepts the offer.",
                "Repair": "Implement cancelForERC function to cancel this offer. And set the owner of offer_id to msg.sender in offerForETH function and check it in cancelForERC function"
            },
            {
                "Location": "previewWithdraw function",
                "Type": "Incorrect calculation",
                "Description": "The previewWithdraw function returns less shares than required assets due to incorrect fee calculation, causing the withdraw function to always revert.",
                "Repair": "Update the previewWithdraw function to return the correct amount of shares by adding the fee to the assets before converting to shares"
            },
            {
                "Location": "placeMarketMakingTrades function",
                "Type": "Ineffective ReserveRatio Enforcement",
                "Description": "Strategists could bypass the Reserve Ratio restriction and utilize all the funds in the pools, causing the pools to be illiquid. Effective reserve ratio enforcement is necessary to safeguard LP's funds.",
                "Repair": "Move the enforceReserveRatio function call to the end of the placeMarketMakingTrades function to ensure that the strategist does not overutilize the pool"
            },
            {
                "Location": "RubiconRouter's _swap function",
                "Type": "Incorrect Parameter",
                "Description": "When swapping amongst multiple pairs in RubiconRouter's _swap, the fee is wrongly accounted for.",
                "Repair": "Change the parameter to the abovementioned one."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./VestingWallet.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title BathBuddy\n * @dev *** This contract is a lightly modified version of Vesting Wallet by OpenZeppelin\n * @dev PLEASE FIND OZ DOCUMENTATION FOR THIS CONTRACT HERE: https://docs.openzeppelin.com/contracts/4.x/api/finance#VestingWallet\n *\n * @dev The only entrypoint used in the system is the release function called by the Bath Token. Extra care should be taken to make sure only the beneficiary can ever access the funds and send them to the withdrawer (and fee to self)\n *\n * @dev This contract handles the vesting ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract BathBuddy is IBathBuddy {\n    using SafeMath for uint256;\n\n    // Public versions of the base VestingWallet storage\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n\n    // Beneficiary must be the Bath Token vault recipient that will call release() for its withdrawer\n    address public beneficiary;\n    uint64 public start;\n    uint64 public duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint64 startTimestamp,\n        uint64 durationSeconds\n    ) {\n        require(\n            beneficiaryAddress != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        beneficiary = beneficiaryAddress;\n        start = startTimestamp;\n        duration = durationSeconds;\n    }\n\n    // OZ\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    /// @notice Log bonus token reward event\n    event LogClaimBonusToken(\n        address indexed receiver,\n        address indexed callingPool,\n        uint256 amountReceived,\n        uint256 shares,\n        IERC20 bonusToken,\n        uint256 releasableAmountToWholePool\n    );\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /// @inheritdoc IBathBuddy\n    /// @dev Added and modified release function. Should be the only callable release function\n    function release(\n        IERC20 token,\n        address recipient,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply,\n        uint256 poolFee\n    ) external override {\n        require(\n            msg.sender == beneficiary,\n            \"Caller is not the Bath Token beneficiary of these rewards\"\n        );\n        uint256 releasable = vestedAmount(\n            address(token),\n            uint64(block.timestamp)\n        ) - released(address(token));\n        if (releasable > 0) {\n            uint256 amount = releasable.mul(sharesWithdrawn).div(\n                initialTotalSupply\n            );\n            uint256 _fee = amount.mul(poolFee).div(10000);\n\n            // If FeeTo == address(this) then the fee is effectively accrued by the pool\n            // Assume the caller is the liquidity pool and they receive the fee\n            // Keep tokens here by not transfering the _fee anywhere, it is accrued to the Bath Token's Bath Buddy\n            // token.transfer(address(this), _fee);\n\n            uint256 amountWithdrawn = amount.sub(_fee);\n            token.transfer(recipient, amountWithdrawn);\n\n            _erc20Released[address(token)] += amount;\n            emit ERC20Released(address(token), amount);\n\n            emit LogClaimBonusToken(\n                recipient,\n                msg.sender,\n                amountWithdrawn,\n                sharesWithdrawn,\n                token,\n                releasable\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _vestingSchedule(\n                IERC20(token).balanceOf(address(this)) + released(token),\n                timestamp\n            );\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        if (timestamp < start) {\n            return 0;\n        } else if (timestamp > start + duration) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start)) / duration;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "BathBuddy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "release() function in BathBuddy.sol",
                "Type": "Possible token reentrancy",
                "Description": "A malicious beneficiary may get the vested amount back without waiting for the vesting period due to the lack of a modifier to stop reentrancy in the release() function. This allows for the malicious beneficiary contract to redeem the vested amount while bypassing the vesting period, due to the released token counter array which controls how many tokens are released being updated only after the transferring of all tokens occurs.",
                "Repair": "Add a mutex such as nonReentrant or the synchronized modifier used in other contracts. Implement checks-effects-interactions pattern."
            },
            {
                "Location": "BathBuddy contract's vestedAmount function",
                "Type": "Disproportionate reward distribution",
                "Description": "When a whale withdraws their tokens and receives rewards from the BathBuddy contract the fees they pay will erroneously become part of the calculation performed in function vestedAmount. This means that any subsequent withdrawer of funds may receive a disproportionate amount of tokens.",
                "Repair": "Keep a tally of the fees accrued in a separate variable and work out a fairer system for distributing rewards to HODLers."
            },
            {
                "Location": "BathBuddy Vesting Wallet",
                "Type": "Token Manipulation",
                "Description": "An attacker could steal almost all the bonusTokens in the BathBuddy Vesting Wallet by depositing a large amount of tokens into a BathToken Pool to gain a significant share of the pool and then withdrawing all the shares immediately. The withdraw call will trigger the BathToken.distributeBonusTokenRewards, and since the attacker holds an overwhelming amount of share in the pool, they will receive almost all the bonusToken in the BathBuddy Vesting wallet, leaving behind a dust amount of bonusToken in the wallet.",
                "Repair": "Update the reward mechanism to ensure that the bonusTokens are distributed fairly and rewards of each user are accrued correctly. Checkpointing mechanism should be implemented so that at the minimum, the user's amount of share in the previous block is used for determining the rewards. This makes flash-loan attack infeasible as such an attack has to happen within the same block/transaction."
            },
            {
                "Location": "receive() function in BathBuddy contract",
                "Type": "Locked Funds",
                "Description": "The BathBuddy contract is able to receive ETH. But, there's no way of ever retrieving that ETH from the contract. The funds will be locked up.",
                "Repair": "Remove the receive() function if the contract isn't supposed to handle ETH. Otherwise, add the necessary logic to release the ETH it gets."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract allows a strategist to use user funds in order to market make for a Rubicon pair\n/// @notice The BathPair is the admin for the pair's liquidity and has many security checks in place\n/// @notice This contract is also where strategists claim rewards for successful market making\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IStrategistUtility.sol\";\n\ncontract BathPair {\n    /// *** Libraries ***\n    using SafeMath for uint256;\n    using SafeMath for uint16;\n\n    /// *** Storage Variables ***\n\n    /// @notice The Bath House admin of this contract; used with onlyBathHouse()\n    address public bathHouse;\n\n    /// @notice The Rubicon Market strategists direct all activity towards. There is only one market, RubiconMarket.sol, in the Rubicon Protocol\n    address public RubiconMarketAddress;\n\n    /// @notice The initialization status of BathPair\n    bool public initialized;\n\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    int128 internal deprecatedStorageVarKept420Proxy;\n\n    /// @notice Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256 public deprecatedStorageVarKept4Proxy;\n\n    /// @dev The id of the last StrategistTrade made by any strategist on this contract\n    /// @dev This value is globally unique, and increments with every trade\n    uint256 internal last_stratTrade_id;\n\n    /// @notice The total amount of successful offer fills that all strategists have made for a given asset\n    mapping(address => uint256) public totalFillsPerAsset;\n\n    /// @notice Unique id => StrategistTrade created in marketMaking call\n    mapping(uint256 => StrategistTrade) public strategistTrades;\n\n    /// @notice Map a strategist to their outstanding order IDs\n    mapping(address => mapping(address => mapping(address => uint256[])))\n        public outOffersByStrategist;\n\n    /// @notice Tracks the market-kaing fill amounts on a per-asset basis of a strategist\n    /// @dev strategist => erc20asset => fill amount per asset;\n    mapping(address => mapping(address => uint256)) public strategist2Fills;\n\n    /// *** Structs ***\n\n    struct order {\n        uint256 pay_amt;\n        IERC20 pay_gem;\n        uint256 buy_amt;\n        IERC20 buy_gem;\n    }\n\n    struct StrategistTrade {\n        uint256 askId;\n        uint256 askPayAmt;\n        address askAsset;\n        uint256 bidId;\n        uint256 bidPayAmt;\n        address bidAsset;\n        address strategist;\n        uint256 timestamp;\n    }\n\n    /// *** Events ***\n\n    /// @notice Log a new market-making trade placed by a strategist, resulting in a StrategitTrade\n    event LogStrategistTrade(\n        uint256 strategistTradeID,\n        bytes32 askId,\n        bytes32 bidId,\n        address askAsset,\n        address bidAsset,\n        uint256 timestamp,\n        address strategist\n    );\n\n    /// @notice Logs the cancellation of a StrategistTrade\n    event LogScrubbedStratTrade(\n        uint256 strategistIDScrubbed,\n        uint256 assetFill,\n        address assetAddress,\n        address bathAssetAddress,\n        uint256 quoteFill,\n        address quoteAddress,\n        address bathQuoteAddress\n    );\n\n    /// @notice Log when a strategist claims their market-making rewards (effectively a rebate for good performance)\n    event LogStrategistRewardClaim(\n        address strategist,\n        address asset,\n        uint256 amountOfReward,\n        uint256 timestamp\n    );\n\n    /// *** External Functions ***\n\n    /// @notice Constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage\n    function initialize(uint256 _maxOrderSizeBPS, int128 _shapeCoefNum)\n        external\n    {\n        require(!initialized);\n        address _bathHouse = msg.sender; //Assume the initializer is BathHouse\n        require(\n            IBathHouse(_bathHouse).getMarket() !=\n                address(0x0000000000000000000000000000000000000000) &&\n                IBathHouse(_bathHouse).initialized(),\n            \"BathHouse not initialized\"\n        );\n        bathHouse = _bathHouse;\n\n        RubiconMarketAddress = IBathHouse(_bathHouse).getMarket();\n\n        // Shape variables for dynamic inventory management\n        /// *** DEprecate but keep storage variable on OP\n        deprecatedStorageVarKept4Proxy = _maxOrderSizeBPS;\n\n        /// @dev A deprecated storage variable! Turns out order books are elegant and complex math is simply computed off-chain, and priced in on-chain orders at the speed of Ethereum L2s!\n        deprecatedStorageVarKept420Proxy = _shapeCoefNum;\n\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyBathHouse() {\n        require(msg.sender == bathHouse);\n        _;\n    }\n\n    modifier onlyApprovedStrategist(address targetStrategist) {\n        require(\n            IBathHouse(bathHouse).isApprovedStrategist(targetStrategist) ==\n                true,\n            \"you are not an approved strategist - bathPair\"\n        );\n        _;\n    }\n\n    // *** Internal Functions ***\n\n    /// @notice This function enforces that the Bath House reserveRatio (a % of underlying pool liquidity) is enforced across all pools\n    /// @dev This function should ensure that reserveRatio % of the underlying liquidity always remains on the Bath Token. Utilization should be 1 - reserveRatio in practice assuming strategists use all available liquidity.\n    function enforceReserveRatio(\n        address underlyingAsset,\n        address underlyingQuote\n    )\n        internal\n        view\n        returns (address bathAssetAddress, address bathQuoteAddress)\n    {\n        bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingAsset\n        );\n        bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingQuote\n        );\n        require(\n            (\n                IBathToken(bathAssetAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingAsset).balanceOf(bathAssetAddress),\n            \"Failed to meet asset pool reserve ratio\"\n        );\n        require(\n            (\n                IBathToken(bathQuoteAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingQuote).balanceOf(bathQuoteAddress),\n            \"Failed to meet quote pool reserve ratio\"\n        );\n    }\n\n    /// @notice Log whenever a strategist rebalances a fill amount and log the amount while incrementing total fills for that specific asset\n    /// @dev Only log fills for each strategist in an asset specific manner\n    /// @dev Goal is to map a strategist to a fill\n    function logFill(\n        uint256 amt,\n        address strategist,\n        address asset\n    ) internal {\n        strategist2Fills[strategist][asset] += amt;\n        totalFillsPerAsset[asset] += amt;\n    }\n\n    /// @notice Internal function to provide the next unique StrategistTrade ID\n    function _next_id() internal returns (uint256) {\n        last_stratTrade_id++;\n        return last_stratTrade_id;\n    }\n\n    /// @notice This function results in the removal of the Strategist Trade (bid and/or ask on Rubicon Market) from the books and it being deleted from the contract\n    /// @dev The local array of strategist IDs that exists for any given strategist [query via getOutstandingStrategistTrades()] acts as an acitve RAM for outstanding strategist trades\n    /// @dev Cancels outstanding orders and manages the ledger of outstandingAmount() on bathTokens as Strategist Trades are cancelled/scrubbed or expired\n    function handleStratOrderAtID(uint256 id) internal {\n        StrategistTrade memory info = strategistTrades[id];\n        address _asset = info.askAsset;\n        address _quote = info.bidAsset;\n\n        address bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _asset\n        );\n        address bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _quote\n        );\n        order memory offer1 = getOfferInfo(info.askId); //ask\n        order memory offer2 = getOfferInfo(info.bidId); //bid\n        uint256 askDelta = info.askPayAmt - offer1.pay_amt;\n        uint256 bidDelta = info.bidPayAmt - offer2.pay_amt;\n\n        // if real\n        if (info.askId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (askDelta > 0) {\n                logFill(askDelta, info.strategist, info.askAsset);\n                IBathToken(bathAssetAddress).removeFilledTradeAmount(askDelta);\n                // not a full fill\n                if (askDelta != info.askPayAmt) {\n                    IBathToken(bathAssetAddress).cancel(\n                        info.askId,\n                        info.askPayAmt.sub(askDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathAssetAddress).cancel(info.askId, info.askPayAmt); // pas amount too\n            }\n        }\n\n        // if real\n        if (info.bidId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (bidDelta > 0) {\n                logFill(bidDelta, info.strategist, info.bidAsset);\n                IBathToken(bathQuoteAddress).removeFilledTradeAmount(bidDelta);\n                // not a full fill\n                if (bidDelta != info.bidPayAmt) {\n                    IBathToken(bathQuoteAddress).cancel(\n                        info.bidId,\n                        info.bidPayAmt.sub(bidDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathQuoteAddress).cancel(info.bidId, info.bidPayAmt); // pass amount too\n            }\n        }\n\n        // Delete the order from outOffersByStrategist\n        uint256 target = getIndexFromElement(\n            id,\n            outOffersByStrategist[_asset][_quote][info.strategist]\n        );\n        uint256[] storage current = outOffersByStrategist[_asset][_quote][\n            info.strategist\n        ];\n        current[target] = current[current.length - 1];\n        current.pop(); // Assign the last value to the value we want to delete and pop, best way to do this in solc AFAIK\n\n        emit LogScrubbedStratTrade(\n            id,\n            askDelta,\n            _asset,\n            bathAssetAddress,\n            bidDelta,\n            _quote,\n            bathQuoteAddress\n        );\n    }\n\n    /// @notice Get information about a Rubicon Market offer and return it as an order\n    function getOfferInfo(uint256 id) internal view returns (order memory) {\n        (\n            uint256 ask_amt,\n            IERC20 ask_gem,\n            uint256 bid_amt,\n            IERC20 bid_gem\n        ) = IRubiconMarket(RubiconMarketAddress).getOffer(id);\n        order memory offerInfo = order(ask_amt, ask_gem, bid_amt, bid_gem);\n        return offerInfo;\n    }\n\n    /// @notice A function that returns the index of uid from array\n    /// @dev uid must be in array for the purposes of this contract to enforce outstanding trades per strategist are tracked correctly\n    function getIndexFromElement(uint256 uid, uint256[] storage array)\n        internal\n        view\n        returns (uint256 _index)\n    {\n        bool assigned = false;\n        for (uint256 index = 0; index < array.length; index++) {\n            if (uid == array[index]) {\n                _index = index;\n                assigned = true;\n                return _index;\n            }\n        }\n        require(assigned, \"Didnt Find that element in live list, cannot scrub\");\n    }\n\n    // *** External Functions - Only Approved Strategists ***\n\n    /// @notice Key entry point for strategists to use Bath Token (LP) funds to place market-making trades on the Rubicon Order Book\n    function placeMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) returns (uint256 id) {\n        // Require at least one order is non-zero\n        require(\n            (askNumerator > 0 && askDenominator > 0) ||\n                (bidNumerator > 0 && bidDenominator > 0),\n            \"one order must be non-zero\"\n        );\n\n        address _underlyingAsset = tokenPair[0];\n        address _underlyingQuote = tokenPair[1];\n\n        (\n            address bathAssetAddress,\n            address bathQuoteAddress\n        ) = enforceReserveRatio(_underlyingAsset, _underlyingQuote);\n\n        require(\n            bathAssetAddress != address(0) && bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // Calculate new bid and/or ask\n        order memory ask = order(\n            askNumerator,\n            IERC20(_underlyingAsset),\n            askDenominator,\n            IERC20(_underlyingQuote)\n        );\n        order memory bid = order(\n            bidNumerator,\n            IERC20(_underlyingQuote),\n            bidDenominator,\n            IERC20(_underlyingAsset)\n        );\n\n        // Place new bid and/or ask\n        // Note: placeOffer returns a zero if an incomplete order\n        uint256 newAskID = IBathToken(bathAssetAddress).placeOffer(\n            ask.pay_amt,\n            ask.pay_gem,\n            ask.buy_amt,\n            ask.buy_gem\n        );\n\n        uint256 newBidID = IBathToken(bathQuoteAddress).placeOffer(\n            bid.pay_amt,\n            bid.pay_gem,\n            bid.buy_amt,\n            bid.buy_gem\n        );\n\n        // Strategist trade is recorded so they can get paid and the trade is logged for time\n        StrategistTrade memory outgoing = StrategistTrade(\n            newAskID,\n            ask.pay_amt,\n            _underlyingAsset,\n            newBidID,\n            bid.pay_amt,\n            _underlyingQuote,\n            msg.sender,\n            block.timestamp\n        );\n\n        // Give each trade a unique id for easy handling by strategists\n        id = _next_id();\n        strategistTrades[id] = outgoing;\n        // Allow strategists to easily call a list of their outstanding offers\n        outOffersByStrategist[_underlyingAsset][_underlyingQuote][msg.sender]\n            .push(id);\n\n        emit LogStrategistTrade(\n            id,\n            bytes32(outgoing.askId),\n            bytes32(outgoing.bidId),\n            outgoing.askAsset,\n            outgoing.bidAsset,\n            block.timestamp,\n            outgoing.strategist\n        );\n    }\n\n    /// @notice A function to batch together many placeMarketMakingTrades() in a single transaction\n    function batchMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length,\n            \"not all order lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            placeMarketMakingTrades(\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice A function to requote an outstanding order and replace it with a new Strategist Trade\n    /// @dev Note that this function will create a new unique id for the requote'd ID due to the low-level functionality\n    function requote(\n        uint256 id,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) {\n        // 1. Scrub strat trade\n        scrubStrategistTrade(id);\n\n        // 2. Place another\n        placeMarketMakingTrades(\n            tokenPair,\n            askNumerator,\n            askDenominator,\n            bidNumerator,\n            bidDenominator\n        );\n    }\n\n    /// @notice A function to batch together many requote() calls in a single transaction\n    /// @dev Ids and input are indexed through to execute requotes\n    function batchRequoteOffers(\n        uint256[] memory ids,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length &&\n                ids.length == askNumerators.length,\n            \"not all input lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            requote(\n                ids[index],\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice - function to rebalance fill between two pools\n    function rebalancePair(\n        uint256 assetRebalAmt, //amount of ASSET in the quote buffer\n        uint256 quoteRebalAmt, //amount of QUOTE in the asset buffer\n        address _underlyingAsset,\n        address _underlyingQuote\n    ) external onlyApprovedStrategist(msg.sender) {\n        address _bathHouse = bathHouse;\n        address _bathAssetAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingAsset\n        );\n        address _bathQuoteAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingQuote\n        );\n        require(\n            _bathAssetAddress != address(0) && _bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // This should be localized to the bathToken in future versions\n        uint16 stratReward = IBathHouse(_bathHouse).getBPSToStrats();\n\n        // Simply rebalance given amounts\n        if (assetRebalAmt > 0) {\n            IBathToken(_bathQuoteAddress).rebalance(\n                _bathAssetAddress,\n                _underlyingAsset,\n                stratReward,\n                assetRebalAmt\n            );\n        }\n        if (quoteRebalAmt > 0) {\n            IBathToken(_bathAssetAddress).rebalance(\n                _bathQuoteAddress,\n                _underlyingQuote,\n                stratReward,\n                quoteRebalAmt\n            );\n        }\n    }\n\n    /// @notice Function to attempt inventory risk tail off on an AMM\n    /// @dev This function calls the strategist utility which handles the trade and returns funds to LPs\n    function tailOff(\n        address targetPool,\n        address tokenToHandle,\n        address targetToken,\n        address _stratUtil, // delegatecall target\n        uint256 amount, //fill amount to handle\n        uint256 hurdle, //must clear this on tail off\n        uint24 _poolFee\n    ) external onlyApprovedStrategist(msg.sender) {\n        // transfer here\n        uint16 stratRewardBPS = IBathHouse(bathHouse).getBPSToStrats();\n\n        IBathToken(targetPool).rebalance(\n            _stratUtil,\n            tokenToHandle,\n            stratRewardBPS,\n            amount\n        );\n\n        // Should always exceed hurdle given amountOutMinimum\n        IStrategistUtility(_stratUtil).UNIdump(\n            amount.sub((stratRewardBPS.mul(amount)).div(10000)),\n            tokenToHandle,\n            targetToken,\n            hurdle,\n            _poolFee,\n            targetPool\n        );\n    }\n\n    /// @notice Cancel an outstanding strategist offers and return funds to LPs while logging fills\n    function scrubStrategistTrade(uint256 id)\n        public\n        onlyApprovedStrategist(msg.sender)\n    {\n        require(\n            msg.sender == strategistTrades[id].strategist,\n            \"you are not the strategist that made this order\"\n        );\n        handleStratOrderAtID(id);\n    }\n\n    /// @notice Batch scrub outstanding strategist trades and return funds to LPs\n    function scrubStrategistTrades(uint256[] memory ids)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        for (uint256 index = 0; index < ids.length; index++) {\n            uint256 _id = ids[index];\n            scrubStrategistTrade(_id);\n        }\n    }\n\n    /// @notice Function where strategists claim rewards proportional to their quantity of fills\n    /// @dev This function should allow a strategist to claim ERC20s sitting on this contract (earned via rebalancing) relative to their share or strategist activity on the pair\n    /// @dev Provide the pair on which you want to claim rewards\n    function strategistBootyClaim(address asset, address quote)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        uint256 fillCountA = strategist2Fills[msg.sender][asset];\n        uint256 fillCountQ = strategist2Fills[msg.sender][quote];\n        if (fillCountA > 0) {\n            uint256 booty = (\n                fillCountA.mul(IERC20(asset).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[asset]);\n            IERC20(asset).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                asset,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[asset] -= fillCountA;\n            strategist2Fills[msg.sender][asset] -= fillCountA;\n        }\n        if (fillCountQ > 0) {\n            uint256 booty = (\n                fillCountQ.mul(IERC20(quote).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[quote]);\n            IERC20(quote).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                quote,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[quote] -= fillCountQ;\n            strategist2Fills[msg.sender][quote] -= fillCountQ;\n        }\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The goal of this function is to enable a means to retrieve all outstanding orders a strategist has live in the books\n    /// @dev This is helpful to manage orders as well as track all strategist orders (like their RAM of StratTrade IDs) and place any would-be constraints on strategists\n    function getOutstandingStrategistTrades(\n        address asset,\n        address quote,\n        address strategist\n    ) public view returns (uint256[] memory) {\n        return outOffersByStrategist[asset][quote][strategist];\n    }\n}\n\n\n",
        "CodeNames": [
            "BathPair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BathPair.tailOff()",
                "Type": "Missing checks",
                "Description": "Strategists can call tailOff with malicious payload to steal all funds within any BathToken.",
                "Repair": "Whitelist the addresses that can be used as _stratUtil. Add a check in rebalance to prevent transferring underlying token."
            },
            {
                "Location": "placeMarketMakingTrades() function in BathPair.sol",
                "Type": "Strategist can transfer user funds to themselves",
                "Description": "The strategist is able to use user funds to trade on the RubiconMarket. They can abuse this to transfer user funds to themselves.",
                "Repair": "Limit the amount of funds a strategist has access to"
            },
            {
                "Location": "BathPair.sol#rebalancePair()",
                "Type": "Front-running",
                "Description": "The pending yields can be stolen by front-running the strategist's BathPair.sol#rebalancePair() transaction, depositing and taking a large share of the vault, and withdrawing right after the rebalancePair() transaction for instant profit.",
                "Repair": "Add a new variable to track rebalancingAmount on BathToken. BathToken should be notified for any pending rebalancing amount changes via BathPair in order to avoid sudden surge of pricePerShare over rebalancePair(). rebalancingAmount should be considered as part of underlyingBalance()."
            },
            {
                "Location": "BathPair.sol",
                "Type": "Smart Contract Vulnerability",
                "Description": "RubiconMarketAddress in BathPair can't be updated.",
                "Repair": "Sync RubiconMarketAddress between BathPair and BathHouse"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            uint256 amountWithdrawn;\n            uint256 _fee = assets.mul(feeBPS).div(10000);\n            amountWithdrawn = assets.sub(_fee);\n            shares = convertToShares(amountWithdrawn);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 _initialTotalSupply = totalSupply;\n\n        // Distribute network rewards first in order to handle bonus token == underlying token case; it only releases vested tokens in this call\n        distributeBonusTokenRewards(receiver, _shares, _initialTotalSupply);\n\n        uint256 r = (underlyingBalance().mul(_shares)).div(_initialTotalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.transfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.transfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern. Fees sit on BathBuddy to act as effectively accrued to the pool.\n    function distributeBonusTokenRewards(\n        address receiver,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply\n    ) internal {\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                // Note: Shares already burned in Bath Token _withdraw\n\n                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n                //  are released their relative share of this pool, of vested BathBuddy rewards\n                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n                if (rewardsVestingWallet != IBathBuddy(0)) {\n                    rewardsVestingWallet.release(\n                        (token),\n                        receiver,\n                        sharesWithdrawn,\n                        initialTotalSupply,\n                        feeBPS\n                    );\n                }\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}\n\n\n",
        "CodeNames": [
            "BathToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BathToken.initialize()",
                "Type": "Reentrancy",
                "Description": "Reentrancy in BathToken.initialize() can be exploited and this allows to create a pool which has a legitimate underlying token.",
                "Repair": "Add onlyBathHouse modifier to initialize function in BathToken to avoid reentrancy from malicious tokens."
            },
            {
                "Location": "BathToken.sol#_deposit()",
                "Type": "Reentrancy",
                "Description": "The _deposit() function in BathToken.sol is vulnerable to reentrancy attack, which can be used to mint more shares. The vulnerability is caused by the lack of a reentrancy guard on this function. An attacker can use a callback to the source of the funds before the balances are updated in transferFrom() to re-enter the function and inflate the amount. The vulnerability can be fixed by adding a reentrancy guard or using a nonReentrant modifier from OZ's ReentrancyGuard.",
                "Repair": "Add a reentrancy guard or use a nonReentrant modifier from OZ's ReentrancyGuard"
            },
            {
                "Location": "Cannot deposit to BathToken if token is Deflationary Token (BathHouse.sol)",
                "Type": "Smart Contract Logic",
                "Description": "Function openBathTokenSpawnAndSignal will always revert when newBathTokenUnderlying or desiredPairedAsset is a deflationary token. It means that deflationary/FoT tokens are not supported at all, which isn't necessarily a bad thing. Keeping it at medium severity, although could've potentially lowered to QA too.",
                "Repair": "Set initialLiquidityNew = newBathTokenUnderlying.balanceOf(address(this)) after line 163 and initialLiquidityExistingBathToken  = desiredPairedAsset.balanceOf(address(this)) after line 178"
            },
            {
                "Location": "initialize method in BathToken contract",
                "Type": "Incorrect Calculation",
                "Description": "The DOMAIN_SEPARATOR is wrongly calculated.",
                "Repair": "Set the name before using it."
            },
            {
                "Location": "onlyPair modifier in BathToken contract",
                "Type": "Centralized Risk",
                "Description": "The onlyPair modifier allows rogue pool behavior due to centralized risks.",
                "Repair": "Use timeLock, or avoid admin accounts."
            },
            {
                "Location": "BathToken.sol, function setBonusToken",
                "Type": "Smart Contract Vulnerability",
                "Description": "Early funds withdrawers can get bonus in multiples of vested bonus tokens (e.g. 2-times, 3-times, etc.).",
                "Repair": "Add the required validations to avoid duplicate additions of bonus tokens"
            },
            {
                "Location": "BathToken contract",
                "Type": "Smart Contract Logic",
                "Description": "BathToken LPs are unable to receive any bonus tokens from the BathBuddy Vesting Wallet during withdraw and the bonus tokens are struck in the BathBuddy Vesting Wallet due to the rewardsVestingWallet state variable always being zero.",
                "Repair": "Implement a setter method for the rewardsVestingWallet state variable in the contracts so that it can be initialised with BathBuddy Vesting Wallet address"
            }
        ]
    },
    {
        "Code": "/// SPDX-License-Identifier: Apache-2.0\n/// This contract is a derivative work of the open-source work of Oasis DEX: https://github.com/OasisDEX/oasis\n\n/// @title RubiconMarket.sol\n/// @notice Please see the repository for this code at https://github.com/RubiconDeFi/rubicon-protocol-v1;\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice DSAuth events for authentication schema\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n/// @notice DSAuth library for setting owner of the contract\n/// @dev Provides the auth modifier for authenticated function calls\ncontract DSAuth is DSAuthEvents {\n    address public owner;\n\n    function setOwner(address owner_) external auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    modifier auth() {\n        require(isAuthorized(msg.sender), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n/// @notice DSMath library for safe math without integer overflow/underflow\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n}\n\n// /// @notice ERC-20 interface as derived from EIP-20\n// contract ERC20 {\n//     function totalSupply() public view returns (uint256);\n\n//     function balanceOf(address guy) public view returns (uint256);\n\n//     function allowance(address src, address guy) public view returns (uint256);\n\n//     function approve(address guy, uint256 wad) public returns (bool);\n\n//     function transfer(address dst, uint256 wad) public returns (bool);\n\n//     function transferFrom(\n//         address src,\n//         address dst,\n//         uint256 wad\n//     ) public returns (bool);\n// }\n\n/// @notice Events contract for logging trade activity on Rubicon Market\n/// @dev Provides the key event logs that are used in all core functionality of exchanging on the Rubicon Market\ncontract EventfulMarket {\n    event LogItemUpdate(uint256 id);\n    event LogTrade(\n        uint256 pay_amt,\n        address indexed pay_gem,\n        uint256 buy_amt,\n        address indexed buy_gem\n    );\n\n    event LogMake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogBump(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogTake(\n        bytes32 id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        address indexed taker,\n        uint128 take_amt,\n        uint128 give_amt,\n        uint64 timestamp\n    );\n\n    event LogKill(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogInt(string lol, uint256 input);\n\n    event FeeTake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        ERC20 asset,\n        address indexed taker,\n        address feeTo,\n        uint256 feeAmt,\n        uint64 timestamp\n    );\n\n    event OfferDeleted(uint256 id);\n}\n\n/// @notice Core trading logic for ERC-20 pairs, an orderbook, and transacting of tokens\n/// @dev This contract holds the core ERC-20 / ERC-20 offer, buy, and cancel logic\ncontract SimpleMarket is EventfulMarket, DSMath {\n    uint256 public last_offer_id;\n\n    /// @dev The mapping that makes up the core orderbook of the exchange\n    mapping(uint256 => OfferInfo) public offers;\n\n    bool locked;\n\n    /// @dev This parameter is in basis points\n    uint256 internal feeBPS;\n\n    /// @dev This parameter provides the address to which fees are sent\n    address internal feeTo;\n\n    struct OfferInfo {\n        uint256 pay_amt;\n        ERC20 pay_gem;\n        uint256 buy_amt;\n        ERC20 buy_gem;\n        address owner;\n        uint64 timestamp;\n    }\n\n    /// @notice Modifier that insures an order exists and is properly in the orderbook\n    modifier can_buy(uint256 id) virtual {\n        require(isActive(id));\n        _;\n    }\n\n    /// @notice Modifier that checks the user to make sure they own the offer and its valid before they attempt to cancel it\n    modifier can_cancel(uint256 id) virtual {\n        require(isActive(id));\n        require(getOwner(id) == msg.sender);\n        _;\n    }\n\n    modifier can_offer() virtual {\n        _;\n    }\n\n    modifier synchronized() {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function isActive(uint256 id) public view returns (bool active) {\n        return offers[id].timestamp > 0;\n    }\n\n    function getOwner(uint256 id) public view returns (address owner) {\n        return offers[id].owner;\n    }\n\n    function getOffer(uint256 id)\n        public\n        view\n        returns (\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        OfferInfo memory _offer = offers[id];\n        return (_offer.pay_amt, _offer.pay_gem, _offer.buy_amt, _offer.buy_gem);\n    }\n\n    /// @notice Below are the main public entrypoints\n\n    function bump(bytes32 id_) external can_buy(uint256(id_)) {\n        uint256 id = uint256(id_);\n        emit LogBump(\n            id_,\n            keccak256(abi.encodePacked(offers[id].pay_gem, offers[id].buy_gem)),\n            offers[id].owner,\n            offers[id].pay_gem,\n            offers[id].buy_gem,\n            uint128(offers[id].pay_amt),\n            uint128(offers[id].buy_amt),\n            offers[id].timestamp\n        );\n    }\n\n    /// @notice Accept a given `quantity` of an offer. Transfers funds from caller/taker to offer maker, and from market to caller/taker.\n    /// @notice The fee for taker trades is paid in this function.\n    function buy(uint256 id, uint256 quantity)\n        public\n        virtual\n        can_buy(id)\n        synchronized\n        returns (bool)\n    {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        // Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 10000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend),\n            \"_offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend) failed - check that you can pay the fee\"\n        );\n        require(\n            _offer.pay_gem.transfer(msg.sender, quantity),\n            \"_offer.pay_gem.transfer(msg.sender, quantity) failed\"\n        );\n\n        emit LogItemUpdate(id);\n        emit LogTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            msg.sender,\n            uint128(quantity),\n            uint128(spend),\n            uint64(block.timestamp)\n        );\n        emit FeeTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.buy_gem,\n            msg.sender,\n            feeTo,\n            fee,\n            uint64(block.timestamp)\n        );\n        emit LogTrade(\n            quantity,\n            address(_offer.pay_gem),\n            spend,\n            address(_offer.buy_gem)\n        );\n\n        if (offers[id].pay_amt == 0) {\n            delete offers[id];\n            emit OfferDeleted(id);\n        }\n\n        return true;\n    }\n\n    /// @notice Allows the caller to cancel the offer if it is their own.\n    /// @notice This function refunds the offer to the maker.\n    function cancel(uint256 id)\n        public\n        virtual\n        can_cancel(id)\n        synchronized\n        returns (bool success)\n    {\n        OfferInfo memory _offer = offers[id];\n        delete offers[id];\n\n        require(_offer.pay_gem.transfer(_offer.owner, _offer.pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogKill(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            uint128(_offer.pay_amt),\n            uint128(_offer.buy_amt),\n            uint64(block.timestamp)\n        );\n\n        success = true;\n    }\n\n    function kill(bytes32 id) external virtual {\n        require(cancel(uint256(id)));\n    }\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) external virtual returns (bytes32 id) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    /// @notice Key function to make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) public virtual can_offer synchronized returns (uint256 id) {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(0x0));\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(0x0));\n        require(pay_gem != buy_gem);\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.owner = msg.sender;\n        info.timestamp = uint64(block.timestamp);\n        id = _next_id();\n        offers[id] = info;\n\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogMake(\n            bytes32(id),\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt),\n            uint64(block.timestamp)\n        );\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) external virtual {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function _next_id() internal returns (uint256) {\n        last_offer_id++;\n        return last_offer_id;\n    }\n\n    // Fee logic\n    function getFeeBPS() internal view returns (uint256) {\n        return feeBPS;\n    }\n}\n\n/// @notice Expiring market is a Simple Market with a market lifetime.\n/// @dev When the close_time has been reached, offers can only be cancelled (offer and buy will throw).\ncontract ExpiringMarket is DSAuth, SimpleMarket {\n    bool public stopped;\n\n    /// @dev After close_time has been reached, no new offers are allowed.\n    modifier can_offer() override {\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, no new buys are allowed.\n    modifier can_buy(uint256 id) override {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, anyone can cancel an offer.\n    modifier can_cancel(uint256 id) virtual override {\n        require(isActive(id));\n        require((msg.sender == getOwner(id)) || isClosed());\n        _;\n    }\n\n    function isClosed() public pure returns (bool closed) {\n        return false;\n    }\n\n    function getTime() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    function stop() external auth {\n        stopped = true;\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note() {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\ncontract MatchingEvents {\n    event LogBuyEnabled(bool isEnabled);\n    event LogMinSell(address pay_gem, uint256 min_amount);\n    event LogMatchingEnabled(bool isEnabled);\n    event LogUnsortedOffer(uint256 id);\n    event LogSortedOffer(uint256 id);\n    event LogInsert(address keeper, uint256 id);\n    event LogDelete(address keeper, uint256 id);\n    event LogMatch(uint256 id, uint256 amount);\n}\n\n/// @notice The core Rubicon Market smart contract\n/// @notice This contract is based on the original open-source work done by OasisDEX under the Apache License 2.0\n/// @dev This contract inherits the key trading functionality from SimpleMarket\ncontract RubiconMarket is MatchingEvents, ExpiringMarket, DSNote {\n    bool public buyEnabled = true; //buy enabled\n    bool public matchingEnabled = true; //true: enable matching,\n    //false: revert to expiring market\n    /// @dev Below is variable to allow for a proxy-friendly constructor\n    bool public initialized;\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    bool public AqueductDistributionLive;\n    /// @dev unused deprecated variable for applying a token distribution of this token on top of a trade\n    address public AqueductAddress;\n\n    struct sortInfo {\n        uint256 next; //points to id of next higher offer\n        uint256 prev; //points to id of previous lower offer\n        uint256 delb; //the blocknumber where this entry was marked for delete\n    }\n    mapping(uint256 => sortInfo) public _rank; //doubly linked lists of sorted offer ids\n    mapping(address => mapping(address => uint256)) public _best; //id of the highest offer for a token pair\n    mapping(address => mapping(address => uint256)) public _span; //number of offers stored for token pair in sorted orderbook\n    mapping(address => uint256) public _dust; //minimum sell amount for a token to avoid dust offers\n    mapping(uint256 => uint256) public _near; //next unsorted offer id\n    uint256 public _head; //first unsorted offer id\n    uint256 public dustId; // id of the latest offer marked as dust\n\n    /// @dev Proxy-safe initialization of storage\n    function initialize(bool _live, address _feeTo) public {\n        require(!initialized, \"contract is already initialized\");\n        AqueductDistributionLive = _live;\n\n        /// @notice The market fee recipient\n        feeTo = _feeTo;\n\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n\n        /// @notice The starting fee on taker trades in basis points\n        feeBPS = 20;\n\n        initialized = true;\n        matchingEnabled = true;\n        buyEnabled = true;\n    }\n\n    // After close, anyone can cancel an offer\n    modifier can_cancel(uint256 id) override {\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\n        require(\n            isClosed() || msg.sender == getOwner(id) || id == dustId,\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\n        );\n        _;\n    }\n\n    // ---- Public entrypoints ---- //\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) public override returns (bytes32) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) public override {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function kill(bytes32 id) external override {\n        require(cancel(uint256(id)));\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    //\n    // If matching is enabled:\n    //     * creates new offer without putting it in\n    //       the sorted list.\n    //     * available to authorized contracts only!\n    //     * keepers should call insert(id,pos)\n    //       to put offer in the sorted list.\n    //\n    // If matching is disabled:\n    //     * calls expiring market's offer().\n    //     * available to everyone without authorization.\n    //     * no sorting is done.\n    //\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //taker (ask) buy how much\n        ERC20 buy_gem //taker (ask) buy which token\n    ) public override returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n\n\n            function(uint256, ERC20, uint256, ERC20) returns (uint256) fn\n         = matchingEnabled ? _offeru : super.offer;\n        return fn(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external can_offer returns (uint256) {\n        return offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, true);\n    }\n\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos, //position to insert offer, 0 should be used if unknown\n        bool matching //match \"close enough\" orders?\n    ) public can_offer returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n        require(_dust[address(pay_gem)] <= pay_amt);\n\n        if (matchingEnabled) {\n            return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, matching);\n        }\n        return super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    //Transfers funds from caller to offer maker, and from market to caller.\n    function buy(uint256 id, uint256 amount)\n        public\n        override\n        can_buy(id)\n        returns (bool)\n    {\n        require(!locked, \"Reentrancy attempt\");\n\n        //Optional distribution on trade\n        if (AqueductDistributionLive) {\n            IAqueduct(AqueductAddress).distributeToMakerAndTaker(\n                getOwner(id),\n                msg.sender\n            );\n        }\n        function(uint256, uint256) returns (bool) fn = matchingEnabled\n            ? _buys\n            : super.buy;\n\n        return fn(id, amount);\n    }\n\n    // Cancel an offer. Refunds offer maker.\n    function cancel(uint256 id)\n        public\n        override\n        can_cancel(id)\n        returns (bool success)\n    {\n        require(!locked, \"Reentrancy attempt\");\n        if (matchingEnabled) {\n            if (isOfferSorted(id)) {\n                require(_unsort(id));\n            } else {\n                require(_hide(id));\n            }\n        }\n        return super.cancel(id); //delete the offer.\n    }\n\n    //insert offer into the sorted list\n    //keepers need to use this function\n    function insert(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) public returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(!isOfferSorted(id)); //make sure offers[id] is not yet sorted\n        require(isActive(id)); //make sure offers[id] is active\n\n        _hide(id); //remove offer from unsorted offers list\n        _sort(id, pos); //put offer into the sorted offers list\n        emit LogInsert(msg.sender, id);\n        return true;\n    }\n\n    //deletes _rank [id]\n    //  Function should be called by keepers.\n    function del_rank(uint256 id) external returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(\n            !isActive(id) &&\n                _rank[id].delb != 0 &&\n                _rank[id].delb < block.number - 10\n        );\n        delete _rank[id];\n        emit LogDelete(msg.sender, id);\n        return true;\n    }\n\n    //set the minimum sell amount for a token\n    //    Function is used to avoid \"dust offers\" that have\n    //    very small amount of tokens to sell, and it would\n    //    cost more gas to accept the offer, than the value\n    //    of tokens received.\n    function setMinSell(\n        ERC20 pay_gem, //token to assign minimum sell amount to\n        uint256 dust //maker (ask) minimum sell amount\n    ) external auth note returns (bool) {\n        _dust[address(pay_gem)] = dust;\n        emit LogMinSell(address(pay_gem), dust);\n        return true;\n    }\n\n    //returns the minimum sell amount for an offer\n    function getMinSell(\n        ERC20 pay_gem //token for which minimum sell amount is queried\n    ) external view returns (uint256) {\n        return _dust[address(pay_gem)];\n    }\n\n    //set buy functionality enabled/disabled\n    function setBuyEnabled(bool buyEnabled_) external auth returns (bool) {\n        buyEnabled = buyEnabled_;\n        emit LogBuyEnabled(buyEnabled);\n        return true;\n    }\n\n    //set matching enabled/disabled\n    //    If matchingEnabled true(default), then inserted offers are matched.\n    //    Except the ones inserted by contracts, because those end up\n    //    in the unsorted list of offers, that must be later sorted by\n    //    keepers using insert().\n    //    If matchingEnabled is false then RubiconMarket is reverted to ExpiringMarket,\n    //    and matching is not done, and sorted lists are disabled.\n    function setMatchingEnabled(bool matchingEnabled_)\n        external\n        auth\n        returns (bool)\n    {\n        matchingEnabled = matchingEnabled_;\n        emit LogMatchingEnabled(matchingEnabled);\n        return true;\n    }\n\n    //return the best offer for a token pair\n    //      the best offer is the lowest one if it's an ask,\n    //      and highest one if it's a bid offer\n    function getBestOffer(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _best[address(sell_gem)][address(buy_gem)];\n    }\n\n    //return the next worse offer in the sorted list\n    //      the worse offer is the higher one if its an ask,\n    //      a lower one if its a bid offer,\n    //      and in both cases the newer one if they're equal.\n    function getWorseOffer(uint256 id) public view returns (uint256) {\n        return _rank[id].prev;\n    }\n\n    //return the next better offer in the sorted list\n    //      the better offer is in the lower priced one if its an ask,\n    //      the next higher priced one if its a bid offer\n    //      and in both cases the older one if they're equal.\n    function getBetterOffer(uint256 id) external view returns (uint256) {\n        return _rank[id].next;\n    }\n\n    //return the amount of better offers for a token pair\n    function getOfferCount(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _span[address(sell_gem)][address(buy_gem)];\n    }\n\n    //get the first unsorted offer that was inserted by a contract\n    //      Contracts can't calculate the insertion position of their offer because it is not an O(1) operation.\n    //      Their offers get put in the unsorted list of offers.\n    //      Keepers can calculate the insertion position offchain and pass it to the insert() function to insert\n    //      the unsorted offer into the sorted list. Unsorted offers will not be matched, but can be bought with buy().\n    function getFirstUnsortedOffer() public view returns (uint256) {\n        return _head;\n    }\n\n    //get the next unsorted offer\n    //      Can be used to cycle through all the unsorted offers.\n    function getNextUnsortedOffer(uint256 id) public view returns (uint256) {\n        return _near[id];\n    }\n\n    function isOfferSorted(uint256 id) public view returns (bool) {\n        return\n            _rank[id].next != 0 ||\n            _rank[id].prev != 0 ||\n            _best[address(offers[id].pay_gem)][address(offers[id].buy_gem)] ==\n            id;\n    }\n\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                pay_amt * 1 ether <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    pay_amt * 10**9,\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10**9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount);\n    }\n\n    function buyAllAmount(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0);\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (\n                buy_amt * 1 ether <\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {\n                //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                //if lower\n                fill_amt = add(\n                    fill_amt,\n                    rmul(\n                        buy_amt * 10**9,\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n                    ) / 10**9\n                ); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\n                buy_amt = 0; //All amount is bought\n            }\n        }\n        require(fill_amt <= max_fill_amount);\n    }\n\n    function getBuyAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 pay_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (pay_amt > offers[offerId].buy_amt) {\n            fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount to buy accumulator\n            pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to pay\n            if (pay_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                pay_amt * 10**9,\n                rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to buy accumulator\n    }\n\n    function getPayAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 buy_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (buy_amt > offers[offerId].pay_amt) {\n            fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount to pay accumulator\n            buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n            if (buy_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                buy_amt * 10**9,\n                rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to pay accumulator\n    }\n\n    // ---- Internal Functions ---- //\n\n    function _buys(uint256 id, uint256 amount) internal returns (bool) {\n        require(buyEnabled);\n        if (amount == offers[id].pay_amt) {\n            if (isOfferSorted(id)) {\n                //offers[id] must be removed from sorted list because all of it is bought\n                _unsort(id);\n            } else {\n                _hide(id);\n            }\n        }\n\n        require(super.buy(id, amount));\n\n        // If offer has become dust during buy, we cancel it\n        if (\n            isActive(id) &&\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\n        ) {\n            dustId = id; //enable current msg.sender to call cancel(id)\n            cancel(id);\n        }\n        return true;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _find(uint256 id) internal view returns (uint256) {\n        require(id > 0);\n\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        uint256 top = _best[pay_gem][buy_gem];\n        uint256 old_top = 0;\n\n        // Find the larger-than-id order whose successor is less-than-id.\n        while (top != 0 && _isPricedLtOrEq(id, top)) {\n            old_top = top;\n            top = _rank[top].prev;\n        }\n        return old_top;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _findpos(uint256 id, uint256 pos) internal view returns (uint256) {\n        require(id > 0);\n\n        // Look for an active order.\n        while (pos != 0 && !isActive(pos)) {\n            pos = _rank[pos].prev;\n        }\n\n        if (pos == 0) {\n            //if we got to the end of list without a single active offer\n            return _find(id);\n        } else {\n            // if we did find a nearby active offer\n            // Walk the order book down from there...\n            if (_isPricedLtOrEq(id, pos)) {\n                uint256 old_pos;\n\n                // Guaranteed to run at least once because of\n                // the prior if statements.\n                while (pos != 0 && _isPricedLtOrEq(id, pos)) {\n                    old_pos = pos;\n                    pos = _rank[pos].prev;\n                }\n                return old_pos;\n\n                // ...or walk it up.\n            } else {\n                while (pos != 0 && !_isPricedLtOrEq(id, pos)) {\n                    pos = _rank[pos].next;\n                }\n                return pos;\n            }\n        }\n    }\n\n    //return true if offers[low] priced less than or equal to offers[high]\n    function _isPricedLtOrEq(\n        uint256 low, //lower priced offer's id\n        uint256 high //higher priced offer's id\n    ) internal view returns (bool) {\n        return\n            mul(offers[low].buy_amt, offers[high].pay_amt) >=\n            mul(offers[high].buy_amt, offers[low].pay_amt);\n    }\n\n    //these variables are global only because of solidity local variable limit\n\n    //match offers with taker offer, and execute token transactions\n    function _matcho(\n        uint256 t_pay_amt, //taker sell how much\n        ERC20 t_pay_gem, //taker sell which token\n        uint256 t_buy_amt, //taker buy how much\n        ERC20 t_buy_gem, //taker buy which token\n        uint256 pos, //position id\n        bool rounding //match \"close enough\" orders?\n    ) internal returns (uint256 id) {\n        uint256 best_maker_id; //highest maker id\n        uint256 t_buy_amt_old; //taker buy how much saved\n        uint256 m_buy_amt; //maker offer wants to buy this much token\n        uint256 m_pay_amt; //maker offer wants to sell this much token\n\n        // there is at least one offer stored for token pair\n        while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\n            best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\n            m_buy_amt = offers[best_maker_id].buy_amt;\n            m_pay_amt = offers[best_maker_id].pay_amt;\n\n            // Ugly hack to work around rounding errors. Based on the idea that\n            // the furthest the amounts can stray from their \"true\" values is 1.\n            // Ergo the worst case has t_pay_amt and m_pay_amt at +1 away from\n            // their \"correct\" values and m_buy_amt and t_buy_amt at -1.\n            // Since (c - 1) * (d - 1) > (a + 1) * (b + 1) is equivalent to\n            // c * d > a * b + a + b + c + d, we write...\n            if (\n                mul(m_buy_amt, t_buy_amt) >\n                mul(t_pay_amt, m_pay_amt) +\n                    (\n                        rounding\n                            ? m_buy_amt + t_buy_amt + t_pay_amt + m_pay_amt\n                            : 0\n                    )\n            ) {\n                break;\n            }\n            // ^ The `rounding` parameter is a compromise borne of a couple days\n            // of discussion.\n            buy(best_maker_id, min(m_pay_amt, t_buy_amt));\n            emit LogMatch(id, min(m_pay_amt, t_buy_amt));\n            t_buy_amt_old = t_buy_amt;\n            t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\n            t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\n\n            if (t_pay_amt == 0 || t_buy_amt == 0) {\n                break;\n            }\n        }\n\n        if (\n            t_buy_amt > 0 &&\n            t_pay_amt > 0 &&\n            t_pay_amt >= _dust[address(t_pay_gem)]\n        ) {\n            //new offer should be created\n            id = super.offer(t_pay_amt, t_pay_gem, t_buy_amt, t_buy_gem);\n            //insert offer into the sorted list\n            _sort(id, pos);\n        }\n    }\n\n    // Make a new offer without putting it in the sorted list.\n    // Takes funds from the caller into market escrow.\n    // Keepers should call insert(id,pos) to put offer in the sorted list.\n    function _offeru(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem //maker (ask) buy which token\n    ) internal returns (uint256 id) {\n        require(_dust[address(pay_gem)] <= pay_amt);\n        id = super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n        _near[id] = _head;\n        _head = id;\n        emit LogUnsortedOffer(id);\n    }\n\n    //put offer into the sorted list\n    function _sort(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) internal {\n        require(isActive(id));\n\n        ERC20 buy_gem = offers[id].buy_gem;\n        ERC20 pay_gem = offers[id].pay_gem;\n        uint256 prev_id; //maker (ask) id\n\n        pos = pos == 0 ||\n            offers[pos].pay_gem != pay_gem ||\n            offers[pos].buy_gem != buy_gem ||\n            !isOfferSorted(pos)\n            ? _find(id)\n            : _findpos(id, pos);\n\n        if (pos != 0) {\n            //offers[id] is not the highest offer\n            //requirement below is satisfied by statements above\n            //require(_isPricedLtOrEq(id, pos));\n            prev_id = _rank[pos].prev;\n            _rank[pos].prev = id;\n            _rank[id].next = pos;\n        } else {\n            //offers[id] is the highest offer\n            prev_id = _best[address(pay_gem)][address(buy_gem)];\n            _best[address(pay_gem)][address(buy_gem)] = id;\n        }\n\n        if (prev_id != 0) {\n            //if lower offer does exist\n            //requirement below is satisfied by statements above\n            //require(!_isPricedLtOrEq(id, prev_id));\n            _rank[prev_id].next = id;\n            _rank[id].prev = prev_id;\n        }\n\n        _span[address(pay_gem)][address(buy_gem)]++;\n        emit LogSortedOffer(id);\n    }\n\n    // Remove offer from the sorted list (does not cancel offer)\n    function _unsort(\n        uint256 id //id of maker (ask) offer to remove from sorted list\n    ) internal returns (bool) {\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        require(_span[pay_gem][buy_gem] > 0);\n\n        require(\n            _rank[id].delb == 0 && //assert id is in the sorted list\n                isOfferSorted(id)\n        );\n\n        if (id != _best[pay_gem][buy_gem]) {\n            // offers[id] is not the highest offer\n            require(_rank[_rank[id].next].prev == id);\n            _rank[_rank[id].next].prev = _rank[id].prev;\n        } else {\n            //offers[id] is the highest offer\n            _best[pay_gem][buy_gem] = _rank[id].prev;\n        }\n\n        if (_rank[id].prev != 0) {\n            //offers[id] is not the lowest offer\n            require(_rank[_rank[id].prev].next == id);\n            _rank[_rank[id].prev].next = _rank[id].next;\n        }\n\n        _span[pay_gem][buy_gem]--;\n        _rank[id].delb = block.number; //mark _rank[id] for deletion\n        return true;\n    }\n\n    //Hide offer from the unsorted order book (does not cancel offer)\n    function _hide(\n        uint256 id //id of maker offer to remove from unsorted list\n    ) internal returns (bool) {\n        uint256 uid = _head; //id of an offer in unsorted offers list\n        uint256 pre = uid; //id of previous offer in unsorted offers list\n\n        require(!isOfferSorted(id)); //make sure offer id is not in sorted offers list\n\n        if (_head == id) {\n            //check if offer is first offer in unsorted offers list\n            _head = _near[id]; //set head to new first unsorted offer\n            _near[id] = 0; //delete order from unsorted order list\n            return true;\n        }\n        while (uid > 0 && uid != id) {\n            //find offer in unsorted order list\n            pre = uid;\n            uid = _near[uid];\n        }\n        if (uid != id) {\n            //did not find offer id in unsorted offers list\n            return false;\n        }\n        _near[pre] = _near[id]; //set previous unsorted offer to point to offer after offer id\n        _near[id] = 0; //delete order from unsorted order list\n        return true;\n    }\n\n    function setFeeBPS(uint256 _newFeeBPS) external auth returns (bool) {\n        feeBPS = _newFeeBPS;\n        return true;\n    }\n\n    /// @dev unused deprecated function for applying a token distribution on top of a trade\n    function setAqueductDistributionLive(bool live)\n        external\n        auth\n        returns (bool)\n    {\n        AqueductDistributionLive = live;\n        return true;\n    }\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    function setAqueductAddress(address _Aqueduct)\n        external\n        auth\n        returns (bool)\n    {\n        AqueductAddress = _Aqueduct;\n        return true;\n    }\n\n    function setFeeTo(address newFeeTo) external auth returns (bool) {\n        feeTo = newFeeTo;\n        return true;\n    }\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n}\n\ninterface IAqueduct {\n    function distributeToMakerAndTaker(address maker, address taker)\n        external\n        returns (bool);\n}\n\n\n",
        "CodeNames": [
            "RubiconMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RubiconMarket.sol:448-449, 525-535",
                "Type": "Storage Gap",
                "Description": "For upgradeable contracts, there must be storage gap to allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments. Otherwise, it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts.",
                "Repair": "Add appropriate storage gap at the end of upgradeable contracts"
            },
            {
                "Location": "RubiconMarket.sol offer() function",
                "Type": "Inconsistent Order Book Accounting",
                "Description": "A transfer-on-fee token or a deflationary/rebasing token can cause the received amount to be less than the accounted amount, leading to internal accounting discrepancies in the order book.",
                "Repair": "Get the actual received amount by calculating the difference of token balance before and after the transfer, and set the info.pay_amt to the actual received amount. Alternatively, implement a whitelisting mechanism to not support deflationary tokens or Fee-on-transfer tokens."
            },
            {
                "Location": "RubiconMarket.feeTo set to zero-address can DoS buy function",
                "Type": "Denial of Service (DoS)",
                "Description": "The owner can set a zero-address as the feeTo address, causing subsequent buy function calls with a _offer.buy_gem ERC20 token reverting on zero-address transfers to revert.",
                "Repair": "Check if feeTo is set to a non-zero address before transferring fees."
            },
            {
                "Location": "Deprecated variables in RubiconMarket contract",
                "Type": "DoS",
                "Description": "A malicious admin can set the deprecated variables AqueductDistributionLive and AqueductAddress to deny specific users to buy.",
                "Repair": "Delete deprecated code, but reserve variable declaration for slots if using upgradable contracts."
            },
            {
                "Location": "RubiconMarket contract",
                "Type": "Smart Contract Logic",
                "Description": "Buys can not be disabled if offer matching is disabled due to a misplaced require check in the _buys function.",
                "Repair": "Move the require check for buyEnabled to the buy function or clarify the intended functionality of buyEnabled"
            },
            {
                "Location": "RubiconMarket.sol#isClosed()",
                "Type": "Incorrect behavior order",
                "Description": "The 'isClosed()' function always returns false, making the market unable to be stopped as designed. The 'stopped' storage variable is not used, which should be used for 'isClosed'.",
                "Repair": "Change the implementation of 'isClosed()' to return the value of 'stopped'"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Benjamin Hughes - Rubicon\n/// @notice This contract is a router to interact with the low-level functions present in RubiconMarket and Pools\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./RubiconMarket.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./peripheral_contracts/WETH9.sol\"; // @unsupported: ovm\nimport \"./interfaces/IBathToken.sol\";\n\n///@dev this contract is a high-level router that utilizes Rubicon smart contracts to provide\n///@dev added convenience and functionality when interacting with the Rubicon protocol\ncontract RubiconRouter {\n    using SafeMath for uint256;\n\n    address public RubiconMarketAddress;\n\n    address payable public wethAddress;\n\n    bool public started;\n\n    event LogNote(string, uint256);\n\n    event LogSwap(\n        uint256 inputAmount,\n        address inputERC20,\n        uint256 hurdleBuyAmtMin,\n        address targetERC20,\n        bytes32 indexed pair,\n        uint256 realizedFill,\n        address recipient\n    );\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function startErUp(address _theTrap, address payable _weth) external {\n        require(!started);\n        RubiconMarketAddress = _theTrap;\n        wethAddress = _weth;\n        started = true;\n    }\n\n    /// @notice Get the outstanding best N orders from both sides of the order book for a given pair\n    /// @dev The asset/quote pair ordering will affect return values - asset should be the top of the pair: for example, (ETH, USDC, 10) will return (10 best ETH asks, 10 best USDC bids, 10)\n    /// @param asset the ERC20 token that represents the ask/sell side of the order book\n    /// @param quote the ERC20 token that represents the bid/buy side of the order book\n    /// @param topNOrders the depth of the order book the caller would like to query/view for the asset-quote pair\n    /// @dev \"best\" orders are determined by proximity to the midpoint of the pair. Closest to the midpoint is best order.\n    /// @return Fixed arrays (of topNOrders length) in \"best\" order (returned asks/bids[0] is best and asks/bids[topNOrders] is worst) of asks and bids + topNOrders. Each offer array item is: [pay, buy, offerId]\n    function getBookFromPair(\n        ERC20 asset,\n        ERC20 quote,\n        uint256 topNOrders\n    )\n        public\n        view\n        returns (\n            uint256[3][] memory,\n            uint256[3][] memory,\n            uint256\n        )\n    {\n        uint256[3][] memory asks = new uint256[3][](topNOrders);\n        uint256[3][] memory bids = new uint256[3][](topNOrders);\n        address _RubiconMarketAddress = RubiconMarketAddress;\n\n        //1. Get best offer for each asset\n        uint256 bestAskID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            asset,\n            quote\n        );\n        uint256 bestBidID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            quote,\n            asset\n        );\n\n        uint256 lastBid = 0;\n        uint256 lastAsk = 0;\n        //2. Iterate from that offer down the book until topNOrders\n        for (uint256 index = 0; index < topNOrders; index++) {\n            if (index == 0) {\n                lastAsk = bestAskID;\n                lastBid = bestBidID;\n\n                (\n                    uint256 _ask_pay_amt,\n                    ,\n                    uint256 _ask_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestAskID);\n                (\n                    uint256 _bid_pay_amt,\n                    ,\n                    uint256 _bid_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestBidID);\n                asks[index] = [_ask_pay_amt, _ask_buy_amt, bestAskID];\n                bids[index] = [_bid_pay_amt, _bid_buy_amt, bestBidID];\n                continue;\n            }\n            uint256 nextBestAsk = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastAsk);\n            uint256 nextBestBid = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastBid);\n            (uint256 ask_pay_amt, , uint256 ask_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestAsk);\n            (uint256 bid_pay_amt, , uint256 bid_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestBid);\n\n            asks[index] = [ask_pay_amt, ask_buy_amt, nextBestAsk];\n            bids[index] = [bid_pay_amt, bid_buy_amt, nextBestBid];\n            // bids[index] = nextBestBid;\n            lastBid = nextBestBid;\n            lastAsk = nextBestAsk;\n        }\n\n        //3. Return those topNOrders for either side of the order book\n        return (asks, bids, topNOrders);\n    }\n\n    /// @dev this function returns the best offer for a pair's id and info\n    function getBestOfferAndInfo(address asset, address quote)\n        public\n        view\n        returns (\n            uint256, //id\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        address _market = RubiconMarketAddress;\n        uint256 offer = RubiconMarket(_market).getBestOffer(\n            ERC20(asset),\n            ERC20(quote)\n        );\n        (\n            uint256 pay_amt,\n            ERC20 pay_gem,\n            uint256 buy_amt,\n            ERC20 buy_gem\n        ) = RubiconMarket(_market).getOffer(offer);\n        return (offer, pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // function for infinite approvals of Rubicon Market\n    function approveAssetOnMarket(address toApprove) public {\n        // Approve exchange\n        ERC20(toApprove).approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @dev this function takes the same parameters of swap and returns the expected amount\n    function getExpectedSwapFill(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public view returns (uint256 fill_amt) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            uint256 wouldBeFillAmount = RubiconMarket(_market).getBuyAmount(\n                ERC20(output),\n                ERC20(input),\n                _pay\n            );\n            currentAmount = wouldBeFillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // Return the wouldbe resulting swap amount\n        return (currentAmount);\n    }\n\n    /// @dev This function lets a user swap from route[0] -> route[last] at some minimum expected rate\n    /// @dev pay_amt - amount to be swapped away from msg.sender of *first address in path*\n    /// @dev buy_amt_min - target minimum received of *last address in path*\n    function swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public returns (uint256) {\n        //**User must approve this contract first**\n        //transfer needed amount here first\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000)) // Account for expected fee\n        );\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    // Internal function requires that ERC20s are here before execution\n    function _swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS,\n        address to // Recipient of swap outputs!\n    ) internal returns (uint256) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            if (ERC20(input).allowance(address(this), _market) == 0) {\n                approveAssetOnMarket(input);\n            }\n            uint256 fillAmount = RubiconMarket(_market).sellAllAmount(\n                ERC20(input),\n                _pay,\n                ERC20(output),\n                0 //naively assume no fill_amt here for loop purposes?\n            );\n            currentAmount = fillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // send tokens back to sender if not keeping here\n        if (to != address(this)) {\n            ERC20(route[route.length - 1]).transfer(to, currentAmount);\n        }\n\n        emit LogSwap(\n            pay_amt,\n            route[0],\n            buy_amt_min,\n            route[route.length - 1],\n            keccak256(abi.encodePacked(route[0], route[route.length - 1])),\n            currentAmount,\n            to\n        );\n        return currentAmount;\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function swapEntireBalance(\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external returns (uint256) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(route[0]).balanceOf(msg.sender);\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            maxAmount // Account for expected fee\n        );\n        return\n            _swap(\n                maxAmount,\n                maxAmount.sub(buy_amt_min.mul(expectedMarketFeeBPS).div(10000)), //account for fee\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxBuyAllAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender's entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            maxAmount,\n            pay_gem,\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxSellAllAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(\n            pay_gem,\n            maxAmount,\n            buy_gem,\n            min_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    // ** Native ETH Wrapper Functions **\n    /// @dev WETH wrapper functions to obfuscate WETH complexities from ETH holders\n    function buyAllAmountWithETH(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        uint256 max_fill_amount,\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        address _weth = address(wethAddress);\n        uint256 _before = ERC20(_weth).balanceOf(address(this));\n        uint256 max_fill_withFee = max_fill_amount.add(\n            max_fill_amount.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= max_fill_withFee,\n            \"must send as much ETH as max_fill_withFee\"\n        );\n        WETH9(wethAddress).deposit{value: max_fill_withFee}(); // Pay with native ETH -> WETH\n        // An amount in WETH\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, buy_amt);\n\n        uint256 _after = ERC20(_weth).balanceOf(address(this));\n        uint256 delta = _after - _before;\n\n        // Return unspent coins to sender\n        if (delta > 0) {\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n    }\n\n    // Paying ERC20 to buy native ETH\n    function buyAllAmountForETH(\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), max_fill_amount); //transfer pay here\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            ERC20(wethAddress),\n            buy_amt,\n            pay_gem,\n            max_fill_amount\n        );\n        WETH9(wethAddress).withdraw(buy_amt); // Fill in WETH\n        msg.sender.transfer(buy_amt); // Return native ETH\n        // Return unspent coins to sender\n        if (max_fill_amount > fill) {\n            ERC20(pay_gem).transfer(msg.sender, max_fill_amount - fill);\n        }\n        return fill;\n    }\n\n    // Pay in native ETH\n    function offerWithETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        // ERC20 nativeETH, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external payable returns (uint256) {\n        require(\n            msg.value >= pay_amt,\n            \"didnt send enough native ETH for WETH offer\"\n        );\n        uint256 _before = ERC20(buy_gem).balanceOf(address(this));\n        WETH9(wethAddress).deposit{value: pay_amt}();\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            ERC20(wethAddress),\n            buy_amt,\n            buy_gem,\n            pos\n        );\n        uint256 _after = ERC20(buy_gem).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer\n            ERC20(buy_gem).transfer(msg.sender, _after - _before);\n        }\n        return id;\n    }\n\n    // Pay in native ETH\n    function offerForETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        // ERC20 nativeETH, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external returns (uint256) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), pay_amt);\n\n        uint256 _before = ERC20(wethAddress).balanceOf(address(this));\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            pos\n        );\n        uint256 _after = ERC20(wethAddress).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer as native ETH\n            uint256 delta = _after - _before;\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n        return id;\n    }\n\n    // Cancel an offer made in WETH\n    function cancelForETH(uint256 id) external returns (bool outcome) {\n        (uint256 pay_amt, ERC20 pay_gem, , ) = RubiconMarket(\n            RubiconMarketAddress\n        ).getOffer(id);\n        require(\n            address(pay_gem) == wethAddress,\n            \"trying to cancel a non WETH order\"\n        );\n        // Cancel order and receive WETH here in amount of pay_amt\n        outcome = RubiconMarket(RubiconMarketAddress).cancel(id);\n        WETH9(wethAddress).withdraw(pay_amt);\n        msg.sender.transfer(pay_amt);\n    }\n\n    // Deposit native ETH -> WETH pool\n    function depositWithETH(uint256 amount, address targetPool)\n        external\n        payable\n        returns (uint256 newShares)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(msg.value >= amount, \"didnt send enough eth\");\n\n        if (target.allowance(address(this), targetPool) == 0) {\n            target.approve(targetPool, amount);\n        }\n\n        WETH9(wethAddress).deposit{value: amount}();\n        newShares = IBathToken(targetPool).deposit(amount);\n        //Send back bathTokens to sender\n        ERC20(targetPool).transfer(msg.sender, newShares);\n    }\n\n    // Withdraw native ETH <- WETH pool\n    function withdrawForETH(uint256 shares, address targetPool)\n        external\n        payable\n        returns (uint256 withdrawnWETH)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(\n            IBathToken(targetPool).balanceOf(msg.sender) >= shares,\n            \"don't own enough shares\"\n        );\n        IBathToken(targetPool).transferFrom(msg.sender, address(this), shares);\n        withdrawnWETH = IBathToken(targetPool).withdraw(shares);\n        WETH9(wethAddress).withdraw(withdrawnWETH);\n\n        //Send back withdrawn native eth to sender\n        msg.sender.transfer(withdrawnWETH);\n    }\n\n    function swapWithETH(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256) {\n        require(route[0] == wethAddress, \"Initial value in path not WETH\");\n        uint256 amtWithFee = pay_amt.add(\n            pay_amt.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= amtWithFee,\n            \"must send enough native ETH to pay as weth and account for fee\"\n        );\n        WETH9(wethAddress).deposit{value: amtWithFee}();\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    function swapForETH(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        require(\n            route[route.length - 1] == wethAddress,\n            \"target of swap is not WETH\"\n        );\n        //Transfer tokens here first and account for fee\n        require(\n            ERC20(route[0]).transferFrom(\n                msg.sender,\n                address(this),\n                pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000))\n            ),\n            \"initial ERC20 transfer failed\"\n        );\n        fill = _swap(\n            pay_amt,\n            buy_amt_min,\n            route,\n            expectedMarketFeeBPS,\n            address(this)\n        );\n\n        WETH9(wethAddress).withdraw(fill);\n        // msg.sender.transfer(fill);\n        msg.sender.transfer(fill);\n    }\n}\n\n\n",
        "CodeNames": [
            "RubiconRouter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "swapWithETH/buyAllAmountWithETH/offerWithETH/depositWithETH functions of the RubiconRouter contract",
                "Type": "Excess ether did not return to the user",
                "Description": "In swapWithETH/buyAllAmountWithETH/offerWithETH/depositWithETH functions of the RubiconRouter contract, when msg.value  max_fill_withFee/pay_amt/amount/amtWithFee, the excess ether will not be returned to the user.",
                "Repair": "Return excess ether to msg.sender, or require msg.value == max_fill_withFee/pay_amt/amount/amtWithFee"
            },
            {
                "Location": "RubiconRouter contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "Offers created through offerWithETH() can be cancelled by anyone.",
                "Repair": "Set the owner of offer_id to msg.sender in offerWithETH function and check it in cancelForETH function"
            },
            {
                "Location": "RubiconRouter function maxSellAllAmount",
                "Type": "Smart Contract Vulnerability",
                "Description": "RubiconRouter maxSellAllAmount does not transfer user's fund into its address, causing calls to always revert.",
                "Repair": "Add a transfer of fund to the function"
            },
            {
                "Location": "Use  call()  instead of  transfer()  when transferring ETH in RubiconRouter",
                "Type": "Gas Limit",
                "Description": "When transferring ETH, using transfer() function only allows the recipient to use 2300 gas, which may not be enough in the future if gas costs change, leading to transfer failures.",
                "Repair": "Replace transfer() calls with call(). Keep in mind to check whether the call was successful by validating the return value"
            },
            {
                "Location": "withdrawForETH could be used to drain the WETH in RubiconRouter.sol",
                "Type": "Unauthorized Withdrawal",
                "Description": "The withdrawForETH function in RubiconRouter.sol can be used to withdraw the entire WETH balance of the contract without providing any WETH, as long as the targetPool does not transfer any WETH to RubiconRouter.sol, leading to unauthorized withdrawal.",
                "Repair": "Check the contract's WETH balance before the caller is supposed to send the WETH and after the WETH is sent to confirm the contract has received enough WETH from the caller"
            },
            {
                "Location": "maxSellAllAmount and maxBuyAllAmount functions in RubiconRouter.sol",
                "Type": "Unintentional Pausing",
                "Description": "The two functions maxSellAllAmount and maxBuyAllAmount will always revert in case at least (100-fee)% of user's balance can be matched with orders.",
                "Repair": "Add the fee calculating before passing the amount to the RubiconMarket's buyAll, sellAll function."
            },
            {
                "Location": "RubiconRouter.swapEntireBalance()",
                "Type": "Improper input validation",
                "Description": "The 'swapEntireBalance()' function doesn't pass the 'buy_amt_min' value to the underlying 'swap()' function, resulting in unexpected outcomes where user funds might be lost.",
                "Repair": "Pass 'buy_amt_min' directly to '_swap()'"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @title  The administrator contract of Rubicon Pools\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice The BathHouse initializes proxy-wrapped bathTokens, manages approved strategists, and sets system variables\n\npragma solidity =0.7.6;\n\nimport \"./BathToken.sol\";\nimport \"../interfaces/IBathPair.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\n\ncontract BathHouse {\n    /// *** Storage Variables ***\n\n    /// @notice Rubicon Bath House\n    string public name;\n\n    /// @notice The administrator of the Bath House contract\n    address public admin;\n\n    /// @notice The proxy administrator of Bath Tokens\n    address public proxyManager;\n\n    /// @notice The core Rubicon Market of the Pools system\n    address public RubiconMarketAddress;\n\n    /// @notice A mapping of approved strategists to access Pools liquidity\n    mapping(address => bool) public approvedStrategists;\n\n    /// @notice The initialization status of BathHouse\n    bool public initialized;\n\n    /// @notice If true, strategists are permissioned and must be approved by admin\n    bool public permissionedStrategists;\n\n    /// @notice Key, system-wide risk parameter for all liquity Pools\n    /// @notice This represents the proportion of a pool's underlying assets that must remain in the pool\n    /// @dev This protects a run on the bank scenario and ensures users can withdraw while allowing funds to be utilized for yield in the market\n    uint256 public reserveRatio;\n\n    /// @notice A variable time delay after which a strategist must return funds to the Bath Token\n    uint256 public timeDelay;\n\n    /// @notice The lone Bath Pair contract of the system which acts as the strategist entry point and logic contract\n    address public approvedPairContract;\n\n    /// @notice The basis point fee that is paid to strategists from LPs on capital that is successfully rebalanced to a Bath Token\n    uint8 public bpsToStrategists;\n\n    /// @notice Key mapping for determining the address of a Bath Token based on its underlying asset\n    /// @dev Source of truth mapping that logs all ERC20 Liquidity pools underlying asset => bathToken Address\n    mapping(address => address) public tokenToBathToken;\n\n    /// @notice The BathToken.sol implementation that any new bathTokens inherit\n    /// @dev The implementation of any ~newly spawned~ proxy-wrapped Bath Tokens via _createBathToken\n    address public newBathTokenImplementation;\n\n    /// *** Events ***\n\n    /// @notice An event that signals the creation of a new Bath Token\n    event LogNewBathToken(\n        address underlyingToken,\n        address bathTokenAddress,\n        address bathTokenFeeAdmin,\n        uint256 timestamp,\n        address bathTokenCreator\n    );\n\n    /// @notice An event that signals the permissionless spawning of a new Bath Token\n    event LogOpenCreationSignal(\n        ERC20 newERC20Underlying,\n        address spawnedBathToken,\n        uint256 initialNewBathTokenDeposit,\n        ERC20 pairedExistingAsset,\n        address pairedExistingBathToken,\n        uint256 pairedBathTokenDeposit,\n        address signaler\n    );\n\n    /// *** Modifiers ***\n\n    /// @notice This modifier enforces that only the admin can call these functions\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    /// *** External Functions ***\n\n    /// @notice The constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage that sets key storage variables\n    /// @dev Admin is set to msg.sender\n    function initialize(\n        address market,\n        uint256 _reserveRatio,\n        uint256 _timeDelay,\n        address _newBathTokenImplementation,\n        address _proxyAdmin\n    ) external {\n        require(!initialized);\n        name = \"Rubicon Bath House\";\n        admin = msg.sender;\n        timeDelay = _timeDelay;\n\n        // Set Bath Token reserve ratio globally\n        require(_reserveRatio <= 100);\n        require(_reserveRatio > 0);\n        reserveRatio = _reserveRatio;\n\n        // Set BPS reward fee for successful strategist market-making\n        /// @notice [(10000 - {bpsToStrategists}) / 10000] BPS of MM-ing activity is passed to users\n        bpsToStrategists = 20;\n\n        // Set key storage variables\n        RubiconMarketAddress = market;\n        permissionedStrategists = true;\n        newBathTokenImplementation = _newBathTokenImplementation;\n        proxyManager = _proxyAdmin;\n\n        // Automatically approve admin as an approved strategist\n        approveStrategist(admin);\n\n        // Complete contract instantiation\n        initialized = true;\n    }\n\n    /// @notice Permissionless entry point to spawn a Bath Token while posting liquidity to a ~pair of Bath Tokens~\n    /// @notice Please note, creating a Bath Token in this fashion ~does not~ gaurentee markets will be made for the new pair. This function signals the desire to have a new pair supported on Rubicon for strategists to consider market-making for\n    /// @notice The best desiredPairedAsset to select is a popular quote currency. Many traditional systems quote in USD while the ETH quote is superior - the choice is yours sweet msg.sender\n    /// @dev The user must approve the bathHouse to spend their ERC20s\n    /// @dev The user can only spawn a Bath Token for an ERC20 that is not yet in the Pools system and they must post liquidity on the other side of the pair for an ~extant Bath Token~\n    function openBathTokenSpawnAndSignal(\n        ERC20 newBathTokenUnderlying,\n        uint256 initialLiquidityNew, // Must approve this contract to spend\n        ERC20 desiredPairedAsset, // Must be paired with an existing quote for v1\n        uint256 initialLiquidityExistingBathToken\n    ) external returns (address newBathToken) {\n        // Check that it doesn't already exist\n        require(\n            getBathTokenfromAsset(newBathTokenUnderlying) == address(0),\n            \"bathToken already exists for that ERC20\"\n        );\n        require(\n            getBathTokenfromAsset(desiredPairedAsset) != address(0),\n            \"bathToken does not exist for that desiredPairedAsset\"\n        );\n\n        // Spawn a bathToken for the new asset\n        address newOne = _createBathToken(newBathTokenUnderlying, address(0)); // NOTE: address(0) as feeAdmin means fee is paid to pool holders\n\n        // Deposit initial liquidity posted of newBathTokenUnderlying\n        require(\n            newBathTokenUnderlying.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityNew\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n\n        newBathTokenUnderlying.approve(newOne, initialLiquidityNew);\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(newOne).deposit(initialLiquidityNew, msg.sender);\n\n        // desiredPairedAsset must be pulled and deposited into bathToken\n        require(\n            desiredPairedAsset.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityExistingBathToken\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n        address pairedPool = getBathTokenfromAsset((desiredPairedAsset));\n        desiredPairedAsset.approve(\n            pairedPool,\n            initialLiquidityExistingBathToken\n        );\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(pairedPool).deposit(\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        // emit an event describing the new pair, underlyings and bathTokens\n        emit LogOpenCreationSignal(\n            newBathTokenUnderlying,\n            newOne,\n            initialLiquidityNew,\n            desiredPairedAsset,\n            pairedPool,\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        newBathToken = newOne;\n    }\n\n    /// ** Admin-Only Functions **\n\n    /// @notice An admin-only function to create a new Bath Token for any ERC20\n    function createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        external\n        onlyAdmin\n        returns (address newBathTokenAddress)\n    {\n        newBathTokenAddress = _createBathToken(underlyingERC20, _feeAdmin);\n    }\n\n    /// @notice A migration function that allows the admin to write arbitrarily to tokenToBathToken\n    function adminWriteBathToken(ERC20 overwriteERC20, address newBathToken)\n        external\n        onlyAdmin\n    {\n        tokenToBathToken[address(overwriteERC20)] = newBathToken;\n        emit LogNewBathToken(\n            address(overwriteERC20),\n            newBathToken,\n            address(0),\n            block.timestamp,\n            msg.sender\n        );\n    }\n\n    /// @notice Function to initialize and store the address of the ~lone~ bathPair contract for the Rubicon protocol\n    function initBathPair(\n        address _bathPairAddress,\n        uint256 _maxOrderSizeBPS,\n        int128 _shapeCoefNum\n    ) external onlyAdmin returns (address newPair) {\n        require(\n            approvedPairContract == address(0),\n            \"BathPair already approved\"\n        );\n        require(\n            IBathPair(_bathPairAddress).initialized() != true,\n            \"BathPair already initialized\"\n        );\n        newPair = _bathPairAddress;\n\n        IBathPair(newPair).initialize(_maxOrderSizeBPS, _shapeCoefNum);\n\n        approvedPairContract = newPair;\n    }\n\n    /// @notice Admin-only function to set a new Admin\n    function setBathHouseAdmin(address newAdmin) external onlyAdmin {\n        admin = newAdmin;\n    }\n\n    /// @notice Admin-only function to set a new Bath Token implementation\n    /// @dev Please note that all bathTokens created will use this abi\n    function setNewBathTokenImplementation(address newImplementation) external onlyAdmin {\n        newBathTokenImplementation = newImplementation;\n    }\n\n    /// @notice Admin-only function to approve a new permissioned strategist\n    function approveStrategist(address strategist) public onlyAdmin {\n        approvedStrategists[strategist] = true;\n    }\n\n    /// @notice Admin-only function to set whether or not strategists are permissioned\n    function setPermissionedStrategists(bool _new) external onlyAdmin {\n        permissionedStrategists = _new;\n    }\n\n    /// @notice Admin-only function to set timeDelay\n    function setCancelTimeDelay(uint256 value) external onlyAdmin {\n        timeDelay = value;\n    }\n\n    /// @notice Admin-only function to set reserveRatio\n    function setReserveRatio(uint256 rr) external onlyAdmin {\n        require(rr <= 100);\n        require(rr > 0);\n        reserveRatio = rr;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's timeDelay\n    function setBathTokenMarket(address bathToken, address newMarket)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setMarket(newMarket);\n    }\n\n    /// @notice Admin-only function to add a bonus token to a Bath Token's reward schema\n    function setBonusToken(address bathToken, address newBonusToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBonusToken(newBonusToken);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathTokenBathHouse(address bathToken, address newAdmin)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBathHouse(newAdmin);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setBathTokenFeeBPS(address bathToken, uint256 newBPS)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeBPS(newBPS);\n    }\n\n    /// @notice Admin-only function to approve the Bath Token's underlying token on the assigned market\n    /// @dev required in case the market address ever changes.. #battleScars\n    function bathTokenApproveSetMarket(address targetBathToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(targetBathToken).approveMarket();\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient (typically the Bath Token itself)\n    function setBathTokenFeeTo(address bathToken, address feeTo)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeTo(feeTo);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's target Rubicon Market\n    function setMarket(address newMarket) external onlyAdmin {\n        RubiconMarketAddress = newMarket;\n    }\n\n    /// *** View Functions ***\n\n    // Getter Functions for parameters\n    function getMarket() external view returns (address) {\n        return RubiconMarketAddress;\n    }\n\n    function getReserveRatio() external view returns (uint256) {\n        return reserveRatio;\n    }\n\n    function getCancelTimeDelay() external view returns (uint256) {\n        return timeDelay;\n    }\n\n    /// @notice Returns the address of any bathToken in the system based on its corresponding underlying asset\n    function getBathTokenfromAsset(ERC20 asset) public view returns (address) {\n        return tokenToBathToken[address(asset)];\n    }\n\n    function getBPSToStrats() public view returns (uint8) {\n        return bpsToStrategists;\n    }\n\n    /// *** System Security Checks ***\n\n    /// @notice A function to check whether or not an address is an approved strategist\n    function isApprovedStrategist(address wouldBeStrategist)\n        external\n        view\n        returns (bool)\n    {\n        if (\n            approvedStrategists[wouldBeStrategist] == true ||\n            !permissionedStrategists\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice A function to check whether or not an address is the approved system instance of BathPair.sol\n    function isApprovedPair(address pair) public view returns (bool outcome) {\n        pair == approvedPairContract ? outcome = true : outcome = false;\n    }\n\n    /// *** Internal Functions ***\n\n    /// @dev Low-level functionality to spawn a Bath Token using the OZ Transparent Upgradeable Proxy standard\n    /// @param underlyingERC20 The underlying ERC-20 asset that underlies the newBathTokenAddress\n    /// @param _feeAdmin Recipient of pool withdrawal fees, typically the pool itself\n    function _createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        internal\n        returns (address newBathTokenAddress)\n    {\n        require(initialized, \"BathHouse not initialized\");\n        address _underlyingERC20 = address(underlyingERC20);\n        require(\n            _underlyingERC20 != address(0),\n            \"Cant create bathToken for zero address\"\n        );\n\n        // Check that it isn't already logged in the registry\n        require(\n            tokenToBathToken[_underlyingERC20] == address(0),\n            \"bathToken already exists\"\n        );\n\n        // Creates a new bathToken that is upgradeable by the proxyManager\n        require(\n            newBathTokenImplementation != address(0),\n            \"no implementation set for bathTokens\"\n        );\n\n        // Note, the option of a fee recipient for pool withdrawls exists. For all pools this is set to the pool itself in production and is visible via ~feeTo~ on any respective contract\n        // Note, fee admin presently ignored in the Bath Token initialization() call via defaulting to itself; though, this is still upgradeable by the Bath House admin via\n        bytes memory _initData = abi.encodeWithSignature(\n            \"initialize(address,address,address)\",\n            _underlyingERC20,\n            (RubiconMarketAddress),\n            (_feeAdmin)\n        );\n\n\n            TransparentUpgradeableProxy newBathToken\n         = new TransparentUpgradeableProxy(\n            newBathTokenImplementation,\n            proxyManager,\n            _initData\n        );\n\n        // New Bath Token Address\n        newBathTokenAddress = address(newBathToken);\n\n        // Write to source-of-truth router mapping for this ERC-20 => Bath Token\n        tokenToBathToken[_underlyingERC20] = newBathTokenAddress;\n\n        // Log Data\n        emit LogNewBathToken(\n            _underlyingERC20,\n            newBathTokenAddress,\n            _feeAdmin,\n            block.timestamp,\n            msg.sender\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "BathHouse.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BathHouse.sol",
                "Type": "Strategists can't be removed",
                "Description": "There is no option to revoke strategist's privilege. A rogue / compromised / cancelled strategist can not be revoked of permissions.",
                "Repair": "Add a function/change the function and allow setting strategist's access to false"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract allows a strategist to use user funds in order to market make for a Rubicon pair\n/// @notice The BathPair is the admin for the pair's liquidity and has many security checks in place\n/// @notice This contract is also where strategists claim rewards for successful market making\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IStrategistUtility.sol\";\n\ncontract BathPair {\n    /// *** Libraries ***\n    using SafeMath for uint256;\n    using SafeMath for uint16;\n\n    /// *** Storage Variables ***\n\n    /// @notice The Bath House admin of this contract; used with onlyBathHouse()\n    address public bathHouse;\n\n    /// @notice The Rubicon Market strategists direct all activity towards. There is only one market, RubiconMarket.sol, in the Rubicon Protocol\n    address public RubiconMarketAddress;\n\n    /// @notice The initialization status of BathPair\n    bool public initialized;\n\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    int128 internal deprecatedStorageVarKept420Proxy;\n\n    /// @notice Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256 public deprecatedStorageVarKept4Proxy;\n\n    /// @dev The id of the last StrategistTrade made by any strategist on this contract\n    /// @dev This value is globally unique, and increments with every trade\n    uint256 internal last_stratTrade_id;\n\n    /// @notice The total amount of successful offer fills that all strategists have made for a given asset\n    mapping(address => uint256) public totalFillsPerAsset;\n\n    /// @notice Unique id => StrategistTrade created in marketMaking call\n    mapping(uint256 => StrategistTrade) public strategistTrades;\n\n    /// @notice Map a strategist to their outstanding order IDs\n    mapping(address => mapping(address => mapping(address => uint256[])))\n        public outOffersByStrategist;\n\n    /// @notice Tracks the market-kaing fill amounts on a per-asset basis of a strategist\n    /// @dev strategist => erc20asset => fill amount per asset;\n    mapping(address => mapping(address => uint256)) public strategist2Fills;\n\n    /// *** Structs ***\n\n    struct order {\n        uint256 pay_amt;\n        IERC20 pay_gem;\n        uint256 buy_amt;\n        IERC20 buy_gem;\n    }\n\n    struct StrategistTrade {\n        uint256 askId;\n        uint256 askPayAmt;\n        address askAsset;\n        uint256 bidId;\n        uint256 bidPayAmt;\n        address bidAsset;\n        address strategist;\n        uint256 timestamp;\n    }\n\n    /// *** Events ***\n\n    /// @notice Log a new market-making trade placed by a strategist, resulting in a StrategitTrade\n    event LogStrategistTrade(\n        uint256 strategistTradeID,\n        bytes32 askId,\n        bytes32 bidId,\n        address askAsset,\n        address bidAsset,\n        uint256 timestamp,\n        address strategist\n    );\n\n    /// @notice Logs the cancellation of a StrategistTrade\n    event LogScrubbedStratTrade(\n        uint256 strategistIDScrubbed,\n        uint256 assetFill,\n        address assetAddress,\n        address bathAssetAddress,\n        uint256 quoteFill,\n        address quoteAddress,\n        address bathQuoteAddress\n    );\n\n    /// @notice Log when a strategist claims their market-making rewards (effectively a rebate for good performance)\n    event LogStrategistRewardClaim(\n        address strategist,\n        address asset,\n        uint256 amountOfReward,\n        uint256 timestamp\n    );\n\n    /// *** External Functions ***\n\n    /// @notice Constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage\n    function initialize(uint256 _maxOrderSizeBPS, int128 _shapeCoefNum)\n        external\n    {\n        require(!initialized);\n        address _bathHouse = msg.sender; //Assume the initializer is BathHouse\n        require(\n            IBathHouse(_bathHouse).getMarket() !=\n                address(0x0000000000000000000000000000000000000000) &&\n                IBathHouse(_bathHouse).initialized(),\n            \"BathHouse not initialized\"\n        );\n        bathHouse = _bathHouse;\n\n        RubiconMarketAddress = IBathHouse(_bathHouse).getMarket();\n\n        // Shape variables for dynamic inventory management\n        /// *** DEprecate but keep storage variable on OP\n        deprecatedStorageVarKept4Proxy = _maxOrderSizeBPS;\n\n        /// @dev A deprecated storage variable! Turns out order books are elegant and complex math is simply computed off-chain, and priced in on-chain orders at the speed of Ethereum L2s!\n        deprecatedStorageVarKept420Proxy = _shapeCoefNum;\n\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyBathHouse() {\n        require(msg.sender == bathHouse);\n        _;\n    }\n\n    modifier onlyApprovedStrategist(address targetStrategist) {\n        require(\n            IBathHouse(bathHouse).isApprovedStrategist(targetStrategist) ==\n                true,\n            \"you are not an approved strategist - bathPair\"\n        );\n        _;\n    }\n\n    // *** Internal Functions ***\n\n    /// @notice This function enforces that the Bath House reserveRatio (a % of underlying pool liquidity) is enforced across all pools\n    /// @dev This function should ensure that reserveRatio % of the underlying liquidity always remains on the Bath Token. Utilization should be 1 - reserveRatio in practice assuming strategists use all available liquidity.\n    function enforceReserveRatio(\n        address underlyingAsset,\n        address underlyingQuote\n    )\n        internal\n        view\n        returns (address bathAssetAddress, address bathQuoteAddress)\n    {\n        bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingAsset\n        );\n        bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingQuote\n        );\n        require(\n            (\n                IBathToken(bathAssetAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingAsset).balanceOf(bathAssetAddress),\n            \"Failed to meet asset pool reserve ratio\"\n        );\n        require(\n            (\n                IBathToken(bathQuoteAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingQuote).balanceOf(bathQuoteAddress),\n            \"Failed to meet quote pool reserve ratio\"\n        );\n    }\n\n    /// @notice Log whenever a strategist rebalances a fill amount and log the amount while incrementing total fills for that specific asset\n    /// @dev Only log fills for each strategist in an asset specific manner\n    /// @dev Goal is to map a strategist to a fill\n    function logFill(\n        uint256 amt,\n        address strategist,\n        address asset\n    ) internal {\n        strategist2Fills[strategist][asset] += amt;\n        totalFillsPerAsset[asset] += amt;\n    }\n\n    /// @notice Internal function to provide the next unique StrategistTrade ID\n    function _next_id() internal returns (uint256) {\n        last_stratTrade_id++;\n        return last_stratTrade_id;\n    }\n\n    /// @notice This function results in the removal of the Strategist Trade (bid and/or ask on Rubicon Market) from the books and it being deleted from the contract\n    /// @dev The local array of strategist IDs that exists for any given strategist [query via getOutstandingStrategistTrades()] acts as an acitve RAM for outstanding strategist trades\n    /// @dev Cancels outstanding orders and manages the ledger of outstandingAmount() on bathTokens as Strategist Trades are cancelled/scrubbed or expired\n    function handleStratOrderAtID(uint256 id) internal {\n        StrategistTrade memory info = strategistTrades[id];\n        address _asset = info.askAsset;\n        address _quote = info.bidAsset;\n\n        address bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _asset\n        );\n        address bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _quote\n        );\n        order memory offer1 = getOfferInfo(info.askId); //ask\n        order memory offer2 = getOfferInfo(info.bidId); //bid\n        uint256 askDelta = info.askPayAmt - offer1.pay_amt;\n        uint256 bidDelta = info.bidPayAmt - offer2.pay_amt;\n\n        // if real\n        if (info.askId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (askDelta > 0) {\n                logFill(askDelta, info.strategist, info.askAsset);\n                IBathToken(bathAssetAddress).removeFilledTradeAmount(askDelta);\n                // not a full fill\n                if (askDelta != info.askPayAmt) {\n                    IBathToken(bathAssetAddress).cancel(\n                        info.askId,\n                        info.askPayAmt.sub(askDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathAssetAddress).cancel(info.askId, info.askPayAmt); // pas amount too\n            }\n        }\n\n        // if real\n        if (info.bidId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (bidDelta > 0) {\n                logFill(bidDelta, info.strategist, info.bidAsset);\n                IBathToken(bathQuoteAddress).removeFilledTradeAmount(bidDelta);\n                // not a full fill\n                if (bidDelta != info.bidPayAmt) {\n                    IBathToken(bathQuoteAddress).cancel(\n                        info.bidId,\n                        info.bidPayAmt.sub(bidDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathQuoteAddress).cancel(info.bidId, info.bidPayAmt); // pass amount too\n            }\n        }\n\n        // Delete the order from outOffersByStrategist\n        uint256 target = getIndexFromElement(\n            id,\n            outOffersByStrategist[_asset][_quote][info.strategist]\n        );\n        uint256[] storage current = outOffersByStrategist[_asset][_quote][\n            info.strategist\n        ];\n        current[target] = current[current.length - 1];\n        current.pop(); // Assign the last value to the value we want to delete and pop, best way to do this in solc AFAIK\n\n        emit LogScrubbedStratTrade(\n            id,\n            askDelta,\n            _asset,\n            bathAssetAddress,\n            bidDelta,\n            _quote,\n            bathQuoteAddress\n        );\n    }\n\n    /// @notice Get information about a Rubicon Market offer and return it as an order\n    function getOfferInfo(uint256 id) internal view returns (order memory) {\n        (\n            uint256 ask_amt,\n            IERC20 ask_gem,\n            uint256 bid_amt,\n            IERC20 bid_gem\n        ) = IRubiconMarket(RubiconMarketAddress).getOffer(id);\n        order memory offerInfo = order(ask_amt, ask_gem, bid_amt, bid_gem);\n        return offerInfo;\n    }\n\n    /// @notice A function that returns the index of uid from array\n    /// @dev uid must be in array for the purposes of this contract to enforce outstanding trades per strategist are tracked correctly\n    function getIndexFromElement(uint256 uid, uint256[] storage array)\n        internal\n        view\n        returns (uint256 _index)\n    {\n        bool assigned = false;\n        for (uint256 index = 0; index < array.length; index++) {\n            if (uid == array[index]) {\n                _index = index;\n                assigned = true;\n                return _index;\n            }\n        }\n        require(assigned, \"Didnt Find that element in live list, cannot scrub\");\n    }\n\n    // *** External Functions - Only Approved Strategists ***\n\n    /// @notice Key entry point for strategists to use Bath Token (LP) funds to place market-making trades on the Rubicon Order Book\n    function placeMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) returns (uint256 id) {\n        // Require at least one order is non-zero\n        require(\n            (askNumerator > 0 && askDenominator > 0) ||\n                (bidNumerator > 0 && bidDenominator > 0),\n            \"one order must be non-zero\"\n        );\n\n        address _underlyingAsset = tokenPair[0];\n        address _underlyingQuote = tokenPair[1];\n\n        (\n            address bathAssetAddress,\n            address bathQuoteAddress\n        ) = enforceReserveRatio(_underlyingAsset, _underlyingQuote);\n\n        require(\n            bathAssetAddress != address(0) && bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // Calculate new bid and/or ask\n        order memory ask = order(\n            askNumerator,\n            IERC20(_underlyingAsset),\n            askDenominator,\n            IERC20(_underlyingQuote)\n        );\n        order memory bid = order(\n            bidNumerator,\n            IERC20(_underlyingQuote),\n            bidDenominator,\n            IERC20(_underlyingAsset)\n        );\n\n        // Place new bid and/or ask\n        // Note: placeOffer returns a zero if an incomplete order\n        uint256 newAskID = IBathToken(bathAssetAddress).placeOffer(\n            ask.pay_amt,\n            ask.pay_gem,\n            ask.buy_amt,\n            ask.buy_gem\n        );\n\n        uint256 newBidID = IBathToken(bathQuoteAddress).placeOffer(\n            bid.pay_amt,\n            bid.pay_gem,\n            bid.buy_amt,\n            bid.buy_gem\n        );\n\n        // Strategist trade is recorded so they can get paid and the trade is logged for time\n        StrategistTrade memory outgoing = StrategistTrade(\n            newAskID,\n            ask.pay_amt,\n            _underlyingAsset,\n            newBidID,\n            bid.pay_amt,\n            _underlyingQuote,\n            msg.sender,\n            block.timestamp\n        );\n\n        // Give each trade a unique id for easy handling by strategists\n        id = _next_id();\n        strategistTrades[id] = outgoing;\n        // Allow strategists to easily call a list of their outstanding offers\n        outOffersByStrategist[_underlyingAsset][_underlyingQuote][msg.sender]\n            .push(id);\n\n        emit LogStrategistTrade(\n            id,\n            bytes32(outgoing.askId),\n            bytes32(outgoing.bidId),\n            outgoing.askAsset,\n            outgoing.bidAsset,\n            block.timestamp,\n            outgoing.strategist\n        );\n    }\n\n    /// @notice A function to batch together many placeMarketMakingTrades() in a single transaction\n    function batchMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length,\n            \"not all order lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            placeMarketMakingTrades(\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice A function to requote an outstanding order and replace it with a new Strategist Trade\n    /// @dev Note that this function will create a new unique id for the requote'd ID due to the low-level functionality\n    function requote(\n        uint256 id,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) {\n        // 1. Scrub strat trade\n        scrubStrategistTrade(id);\n\n        // 2. Place another\n        placeMarketMakingTrades(\n            tokenPair,\n            askNumerator,\n            askDenominator,\n            bidNumerator,\n            bidDenominator\n        );\n    }\n\n    /// @notice A function to batch together many requote() calls in a single transaction\n    /// @dev Ids and input are indexed through to execute requotes\n    function batchRequoteOffers(\n        uint256[] memory ids,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length &&\n                ids.length == askNumerators.length,\n            \"not all input lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            requote(\n                ids[index],\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice - function to rebalance fill between two pools\n    function rebalancePair(\n        uint256 assetRebalAmt, //amount of ASSET in the quote buffer\n        uint256 quoteRebalAmt, //amount of QUOTE in the asset buffer\n        address _underlyingAsset,\n        address _underlyingQuote\n    ) external onlyApprovedStrategist(msg.sender) {\n        address _bathHouse = bathHouse;\n        address _bathAssetAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingAsset\n        );\n        address _bathQuoteAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingQuote\n        );\n        require(\n            _bathAssetAddress != address(0) && _bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // This should be localized to the bathToken in future versions\n        uint16 stratReward = IBathHouse(_bathHouse).getBPSToStrats();\n\n        // Simply rebalance given amounts\n        if (assetRebalAmt > 0) {\n            IBathToken(_bathQuoteAddress).rebalance(\n                _bathAssetAddress,\n                _underlyingAsset,\n                stratReward,\n                assetRebalAmt\n            );\n        }\n        if (quoteRebalAmt > 0) {\n            IBathToken(_bathAssetAddress).rebalance(\n                _bathQuoteAddress,\n                _underlyingQuote,\n                stratReward,\n                quoteRebalAmt\n            );\n        }\n    }\n\n    /// @notice Function to attempt inventory risk tail off on an AMM\n    /// @dev This function calls the strategist utility which handles the trade and returns funds to LPs\n    function tailOff(\n        address targetPool,\n        address tokenToHandle,\n        address targetToken,\n        address _stratUtil, // delegatecall target\n        uint256 amount, //fill amount to handle\n        uint256 hurdle, //must clear this on tail off\n        uint24 _poolFee\n    ) external onlyApprovedStrategist(msg.sender) {\n        // transfer here\n        uint16 stratRewardBPS = IBathHouse(bathHouse).getBPSToStrats();\n\n        IBathToken(targetPool).rebalance(\n            _stratUtil,\n            tokenToHandle,\n            stratRewardBPS,\n            amount\n        );\n\n        // Should always exceed hurdle given amountOutMinimum\n        IStrategistUtility(_stratUtil).UNIdump(\n            amount.sub((stratRewardBPS.mul(amount)).div(10000)),\n            tokenToHandle,\n            targetToken,\n            hurdle,\n            _poolFee,\n            targetPool\n        );\n    }\n\n    /// @notice Cancel an outstanding strategist offers and return funds to LPs while logging fills\n    function scrubStrategistTrade(uint256 id)\n        public\n        onlyApprovedStrategist(msg.sender)\n    {\n        require(\n            msg.sender == strategistTrades[id].strategist,\n            \"you are not the strategist that made this order\"\n        );\n        handleStratOrderAtID(id);\n    }\n\n    /// @notice Batch scrub outstanding strategist trades and return funds to LPs\n    function scrubStrategistTrades(uint256[] memory ids)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        for (uint256 index = 0; index < ids.length; index++) {\n            uint256 _id = ids[index];\n            scrubStrategistTrade(_id);\n        }\n    }\n\n    /// @notice Function where strategists claim rewards proportional to their quantity of fills\n    /// @dev This function should allow a strategist to claim ERC20s sitting on this contract (earned via rebalancing) relative to their share or strategist activity on the pair\n    /// @dev Provide the pair on which you want to claim rewards\n    function strategistBootyClaim(address asset, address quote)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        uint256 fillCountA = strategist2Fills[msg.sender][asset];\n        uint256 fillCountQ = strategist2Fills[msg.sender][quote];\n        if (fillCountA > 0) {\n            uint256 booty = (\n                fillCountA.mul(IERC20(asset).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[asset]);\n            IERC20(asset).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                asset,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[asset] -= fillCountA;\n            strategist2Fills[msg.sender][asset] -= fillCountA;\n        }\n        if (fillCountQ > 0) {\n            uint256 booty = (\n                fillCountQ.mul(IERC20(quote).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[quote]);\n            IERC20(quote).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                quote,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[quote] -= fillCountQ;\n            strategist2Fills[msg.sender][quote] -= fillCountQ;\n        }\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The goal of this function is to enable a means to retrieve all outstanding orders a strategist has live in the books\n    /// @dev This is helpful to manage orders as well as track all strategist orders (like their RAM of StratTrade IDs) and place any would-be constraints on strategists\n    function getOutstandingStrategistTrades(\n        address asset,\n        address quote,\n        address strategist\n    ) public view returns (uint256[] memory) {\n        return outOffersByStrategist[asset][quote][strategist];\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            uint256 amountWithdrawn;\n            uint256 _fee = assets.mul(feeBPS).div(10000);\n            amountWithdrawn = assets.sub(_fee);\n            shares = convertToShares(amountWithdrawn);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 _initialTotalSupply = totalSupply;\n\n        // Distribute network rewards first in order to handle bonus token == underlying token case; it only releases vested tokens in this call\n        distributeBonusTokenRewards(receiver, _shares, _initialTotalSupply);\n\n        uint256 r = (underlyingBalance().mul(_shares)).div(_initialTotalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.transfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.transfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern. Fees sit on BathBuddy to act as effectively accrued to the pool.\n    function distributeBonusTokenRewards(\n        address receiver,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply\n    ) internal {\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                // Note: Shares already burned in Bath Token _withdraw\n\n                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n                //  are released their relative share of this pool, of vested BathBuddy rewards\n                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n                if (rewardsVestingWallet != IBathBuddy(0)) {\n                    rewardsVestingWallet.release(\n                        (token),\n                        receiver,\n                        sharesWithdrawn,\n                        initialTotalSupply,\n                        feeBPS\n                    );\n                }\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}\n\n\n",
        "CodeNames": [
            "BathPair.sol",
            "BathToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BathPair.scrubStrategistTrade() and BathToken.removeFilledTradeAmount()",
                "Type": "Inaccurate outstanding amount",
                "Description": "The outstanding amount of the pool is reduced prematurely when a trade order is scrubbed by strategist, thus making the outstanding amount inaccurate. This causes unintended impact on key functions of the protocol that rely on proper accounting of the underlying balance or outstanding amount.",
                "Repair": "Remove the BathToken.removeFilledTradeAmount() call in BathPair.handleStratOrderAtID() and only call it in BathPair.rebalancePair() if tokens have been repaid back"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract allows a strategist to use user funds in order to market make for a Rubicon pair\n/// @notice The BathPair is the admin for the pair's liquidity and has many security checks in place\n/// @notice This contract is also where strategists claim rewards for successful market making\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IStrategistUtility.sol\";\n\ncontract BathPair {\n    /// *** Libraries ***\n    using SafeMath for uint256;\n    using SafeMath for uint16;\n\n    /// *** Storage Variables ***\n\n    /// @notice The Bath House admin of this contract; used with onlyBathHouse()\n    address public bathHouse;\n\n    /// @notice The Rubicon Market strategists direct all activity towards. There is only one market, RubiconMarket.sol, in the Rubicon Protocol\n    address public RubiconMarketAddress;\n\n    /// @notice The initialization status of BathPair\n    bool public initialized;\n\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    int128 internal deprecatedStorageVarKept420Proxy;\n\n    /// @notice Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256 public deprecatedStorageVarKept4Proxy;\n\n    /// @dev The id of the last StrategistTrade made by any strategist on this contract\n    /// @dev This value is globally unique, and increments with every trade\n    uint256 internal last_stratTrade_id;\n\n    /// @notice The total amount of successful offer fills that all strategists have made for a given asset\n    mapping(address => uint256) public totalFillsPerAsset;\n\n    /// @notice Unique id => StrategistTrade created in marketMaking call\n    mapping(uint256 => StrategistTrade) public strategistTrades;\n\n    /// @notice Map a strategist to their outstanding order IDs\n    mapping(address => mapping(address => mapping(address => uint256[])))\n        public outOffersByStrategist;\n\n    /// @notice Tracks the market-kaing fill amounts on a per-asset basis of a strategist\n    /// @dev strategist => erc20asset => fill amount per asset;\n    mapping(address => mapping(address => uint256)) public strategist2Fills;\n\n    /// *** Structs ***\n\n    struct order {\n        uint256 pay_amt;\n        IERC20 pay_gem;\n        uint256 buy_amt;\n        IERC20 buy_gem;\n    }\n\n    struct StrategistTrade {\n        uint256 askId;\n        uint256 askPayAmt;\n        address askAsset;\n        uint256 bidId;\n        uint256 bidPayAmt;\n        address bidAsset;\n        address strategist;\n        uint256 timestamp;\n    }\n\n    /// *** Events ***\n\n    /// @notice Log a new market-making trade placed by a strategist, resulting in a StrategitTrade\n    event LogStrategistTrade(\n        uint256 strategistTradeID,\n        bytes32 askId,\n        bytes32 bidId,\n        address askAsset,\n        address bidAsset,\n        uint256 timestamp,\n        address strategist\n    );\n\n    /// @notice Logs the cancellation of a StrategistTrade\n    event LogScrubbedStratTrade(\n        uint256 strategistIDScrubbed,\n        uint256 assetFill,\n        address assetAddress,\n        address bathAssetAddress,\n        uint256 quoteFill,\n        address quoteAddress,\n        address bathQuoteAddress\n    );\n\n    /// @notice Log when a strategist claims their market-making rewards (effectively a rebate for good performance)\n    event LogStrategistRewardClaim(\n        address strategist,\n        address asset,\n        uint256 amountOfReward,\n        uint256 timestamp\n    );\n\n    /// *** External Functions ***\n\n    /// @notice Constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage\n    function initialize(uint256 _maxOrderSizeBPS, int128 _shapeCoefNum)\n        external\n    {\n        require(!initialized);\n        address _bathHouse = msg.sender; //Assume the initializer is BathHouse\n        require(\n            IBathHouse(_bathHouse).getMarket() !=\n                address(0x0000000000000000000000000000000000000000) &&\n                IBathHouse(_bathHouse).initialized(),\n            \"BathHouse not initialized\"\n        );\n        bathHouse = _bathHouse;\n\n        RubiconMarketAddress = IBathHouse(_bathHouse).getMarket();\n\n        // Shape variables for dynamic inventory management\n        /// *** DEprecate but keep storage variable on OP\n        deprecatedStorageVarKept4Proxy = _maxOrderSizeBPS;\n\n        /// @dev A deprecated storage variable! Turns out order books are elegant and complex math is simply computed off-chain, and priced in on-chain orders at the speed of Ethereum L2s!\n        deprecatedStorageVarKept420Proxy = _shapeCoefNum;\n\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyBathHouse() {\n        require(msg.sender == bathHouse);\n        _;\n    }\n\n    modifier onlyApprovedStrategist(address targetStrategist) {\n        require(\n            IBathHouse(bathHouse).isApprovedStrategist(targetStrategist) ==\n                true,\n            \"you are not an approved strategist - bathPair\"\n        );\n        _;\n    }\n\n    // *** Internal Functions ***\n\n    /// @notice This function enforces that the Bath House reserveRatio (a % of underlying pool liquidity) is enforced across all pools\n    /// @dev This function should ensure that reserveRatio % of the underlying liquidity always remains on the Bath Token. Utilization should be 1 - reserveRatio in practice assuming strategists use all available liquidity.\n    function enforceReserveRatio(\n        address underlyingAsset,\n        address underlyingQuote\n    )\n        internal\n        view\n        returns (address bathAssetAddress, address bathQuoteAddress)\n    {\n        bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingAsset\n        );\n        bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingQuote\n        );\n        require(\n            (\n                IBathToken(bathAssetAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingAsset).balanceOf(bathAssetAddress),\n            \"Failed to meet asset pool reserve ratio\"\n        );\n        require(\n            (\n                IBathToken(bathQuoteAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingQuote).balanceOf(bathQuoteAddress),\n            \"Failed to meet quote pool reserve ratio\"\n        );\n    }\n\n    /// @notice Log whenever a strategist rebalances a fill amount and log the amount while incrementing total fills for that specific asset\n    /// @dev Only log fills for each strategist in an asset specific manner\n    /// @dev Goal is to map a strategist to a fill\n    function logFill(\n        uint256 amt,\n        address strategist,\n        address asset\n    ) internal {\n        strategist2Fills[strategist][asset] += amt;\n        totalFillsPerAsset[asset] += amt;\n    }\n\n    /// @notice Internal function to provide the next unique StrategistTrade ID\n    function _next_id() internal returns (uint256) {\n        last_stratTrade_id++;\n        return last_stratTrade_id;\n    }\n\n    /// @notice This function results in the removal of the Strategist Trade (bid and/or ask on Rubicon Market) from the books and it being deleted from the contract\n    /// @dev The local array of strategist IDs that exists for any given strategist [query via getOutstandingStrategistTrades()] acts as an acitve RAM for outstanding strategist trades\n    /// @dev Cancels outstanding orders and manages the ledger of outstandingAmount() on bathTokens as Strategist Trades are cancelled/scrubbed or expired\n    function handleStratOrderAtID(uint256 id) internal {\n        StrategistTrade memory info = strategistTrades[id];\n        address _asset = info.askAsset;\n        address _quote = info.bidAsset;\n\n        address bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _asset\n        );\n        address bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _quote\n        );\n        order memory offer1 = getOfferInfo(info.askId); //ask\n        order memory offer2 = getOfferInfo(info.bidId); //bid\n        uint256 askDelta = info.askPayAmt - offer1.pay_amt;\n        uint256 bidDelta = info.bidPayAmt - offer2.pay_amt;\n\n        // if real\n        if (info.askId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (askDelta > 0) {\n                logFill(askDelta, info.strategist, info.askAsset);\n                IBathToken(bathAssetAddress).removeFilledTradeAmount(askDelta);\n                // not a full fill\n                if (askDelta != info.askPayAmt) {\n                    IBathToken(bathAssetAddress).cancel(\n                        info.askId,\n                        info.askPayAmt.sub(askDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathAssetAddress).cancel(info.askId, info.askPayAmt); // pas amount too\n            }\n        }\n\n        // if real\n        if (info.bidId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (bidDelta > 0) {\n                logFill(bidDelta, info.strategist, info.bidAsset);\n                IBathToken(bathQuoteAddress).removeFilledTradeAmount(bidDelta);\n                // not a full fill\n                if (bidDelta != info.bidPayAmt) {\n                    IBathToken(bathQuoteAddress).cancel(\n                        info.bidId,\n                        info.bidPayAmt.sub(bidDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathQuoteAddress).cancel(info.bidId, info.bidPayAmt); // pass amount too\n            }\n        }\n\n        // Delete the order from outOffersByStrategist\n        uint256 target = getIndexFromElement(\n            id,\n            outOffersByStrategist[_asset][_quote][info.strategist]\n        );\n        uint256[] storage current = outOffersByStrategist[_asset][_quote][\n            info.strategist\n        ];\n        current[target] = current[current.length - 1];\n        current.pop(); // Assign the last value to the value we want to delete and pop, best way to do this in solc AFAIK\n\n        emit LogScrubbedStratTrade(\n            id,\n            askDelta,\n            _asset,\n            bathAssetAddress,\n            bidDelta,\n            _quote,\n            bathQuoteAddress\n        );\n    }\n\n    /// @notice Get information about a Rubicon Market offer and return it as an order\n    function getOfferInfo(uint256 id) internal view returns (order memory) {\n        (\n            uint256 ask_amt,\n            IERC20 ask_gem,\n            uint256 bid_amt,\n            IERC20 bid_gem\n        ) = IRubiconMarket(RubiconMarketAddress).getOffer(id);\n        order memory offerInfo = order(ask_amt, ask_gem, bid_amt, bid_gem);\n        return offerInfo;\n    }\n\n    /// @notice A function that returns the index of uid from array\n    /// @dev uid must be in array for the purposes of this contract to enforce outstanding trades per strategist are tracked correctly\n    function getIndexFromElement(uint256 uid, uint256[] storage array)\n        internal\n        view\n        returns (uint256 _index)\n    {\n        bool assigned = false;\n        for (uint256 index = 0; index < array.length; index++) {\n            if (uid == array[index]) {\n                _index = index;\n                assigned = true;\n                return _index;\n            }\n        }\n        require(assigned, \"Didnt Find that element in live list, cannot scrub\");\n    }\n\n    // *** External Functions - Only Approved Strategists ***\n\n    /// @notice Key entry point for strategists to use Bath Token (LP) funds to place market-making trades on the Rubicon Order Book\n    function placeMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) returns (uint256 id) {\n        // Require at least one order is non-zero\n        require(\n            (askNumerator > 0 && askDenominator > 0) ||\n                (bidNumerator > 0 && bidDenominator > 0),\n            \"one order must be non-zero\"\n        );\n\n        address _underlyingAsset = tokenPair[0];\n        address _underlyingQuote = tokenPair[1];\n\n        (\n            address bathAssetAddress,\n            address bathQuoteAddress\n        ) = enforceReserveRatio(_underlyingAsset, _underlyingQuote);\n\n        require(\n            bathAssetAddress != address(0) && bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // Calculate new bid and/or ask\n        order memory ask = order(\n            askNumerator,\n            IERC20(_underlyingAsset),\n            askDenominator,\n            IERC20(_underlyingQuote)\n        );\n        order memory bid = order(\n            bidNumerator,\n            IERC20(_underlyingQuote),\n            bidDenominator,\n            IERC20(_underlyingAsset)\n        );\n\n        // Place new bid and/or ask\n        // Note: placeOffer returns a zero if an incomplete order\n        uint256 newAskID = IBathToken(bathAssetAddress).placeOffer(\n            ask.pay_amt,\n            ask.pay_gem,\n            ask.buy_amt,\n            ask.buy_gem\n        );\n\n        uint256 newBidID = IBathToken(bathQuoteAddress).placeOffer(\n            bid.pay_amt,\n            bid.pay_gem,\n            bid.buy_amt,\n            bid.buy_gem\n        );\n\n        // Strategist trade is recorded so they can get paid and the trade is logged for time\n        StrategistTrade memory outgoing = StrategistTrade(\n            newAskID,\n            ask.pay_amt,\n            _underlyingAsset,\n            newBidID,\n            bid.pay_amt,\n            _underlyingQuote,\n            msg.sender,\n            block.timestamp\n        );\n\n        // Give each trade a unique id for easy handling by strategists\n        id = _next_id();\n        strategistTrades[id] = outgoing;\n        // Allow strategists to easily call a list of their outstanding offers\n        outOffersByStrategist[_underlyingAsset][_underlyingQuote][msg.sender]\n            .push(id);\n\n        emit LogStrategistTrade(\n            id,\n            bytes32(outgoing.askId),\n            bytes32(outgoing.bidId),\n            outgoing.askAsset,\n            outgoing.bidAsset,\n            block.timestamp,\n            outgoing.strategist\n        );\n    }\n\n    /// @notice A function to batch together many placeMarketMakingTrades() in a single transaction\n    function batchMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length,\n            \"not all order lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            placeMarketMakingTrades(\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice A function to requote an outstanding order and replace it with a new Strategist Trade\n    /// @dev Note that this function will create a new unique id for the requote'd ID due to the low-level functionality\n    function requote(\n        uint256 id,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) {\n        // 1. Scrub strat trade\n        scrubStrategistTrade(id);\n\n        // 2. Place another\n        placeMarketMakingTrades(\n            tokenPair,\n            askNumerator,\n            askDenominator,\n            bidNumerator,\n            bidDenominator\n        );\n    }\n\n    /// @notice A function to batch together many requote() calls in a single transaction\n    /// @dev Ids and input are indexed through to execute requotes\n    function batchRequoteOffers(\n        uint256[] memory ids,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length &&\n                ids.length == askNumerators.length,\n            \"not all input lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            requote(\n                ids[index],\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice - function to rebalance fill between two pools\n    function rebalancePair(\n        uint256 assetRebalAmt, //amount of ASSET in the quote buffer\n        uint256 quoteRebalAmt, //amount of QUOTE in the asset buffer\n        address _underlyingAsset,\n        address _underlyingQuote\n    ) external onlyApprovedStrategist(msg.sender) {\n        address _bathHouse = bathHouse;\n        address _bathAssetAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingAsset\n        );\n        address _bathQuoteAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingQuote\n        );\n        require(\n            _bathAssetAddress != address(0) && _bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // This should be localized to the bathToken in future versions\n        uint16 stratReward = IBathHouse(_bathHouse).getBPSToStrats();\n\n        // Simply rebalance given amounts\n        if (assetRebalAmt > 0) {\n            IBathToken(_bathQuoteAddress).rebalance(\n                _bathAssetAddress,\n                _underlyingAsset,\n                stratReward,\n                assetRebalAmt\n            );\n        }\n        if (quoteRebalAmt > 0) {\n            IBathToken(_bathAssetAddress).rebalance(\n                _bathQuoteAddress,\n                _underlyingQuote,\n                stratReward,\n                quoteRebalAmt\n            );\n        }\n    }\n\n    /// @notice Function to attempt inventory risk tail off on an AMM\n    /// @dev This function calls the strategist utility which handles the trade and returns funds to LPs\n    function tailOff(\n        address targetPool,\n        address tokenToHandle,\n        address targetToken,\n        address _stratUtil, // delegatecall target\n        uint256 amount, //fill amount to handle\n        uint256 hurdle, //must clear this on tail off\n        uint24 _poolFee\n    ) external onlyApprovedStrategist(msg.sender) {\n        // transfer here\n        uint16 stratRewardBPS = IBathHouse(bathHouse).getBPSToStrats();\n\n        IBathToken(targetPool).rebalance(\n            _stratUtil,\n            tokenToHandle,\n            stratRewardBPS,\n            amount\n        );\n\n        // Should always exceed hurdle given amountOutMinimum\n        IStrategistUtility(_stratUtil).UNIdump(\n            amount.sub((stratRewardBPS.mul(amount)).div(10000)),\n            tokenToHandle,\n            targetToken,\n            hurdle,\n            _poolFee,\n            targetPool\n        );\n    }\n\n    /// @notice Cancel an outstanding strategist offers and return funds to LPs while logging fills\n    function scrubStrategistTrade(uint256 id)\n        public\n        onlyApprovedStrategist(msg.sender)\n    {\n        require(\n            msg.sender == strategistTrades[id].strategist,\n            \"you are not the strategist that made this order\"\n        );\n        handleStratOrderAtID(id);\n    }\n\n    /// @notice Batch scrub outstanding strategist trades and return funds to LPs\n    function scrubStrategistTrades(uint256[] memory ids)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        for (uint256 index = 0; index < ids.length; index++) {\n            uint256 _id = ids[index];\n            scrubStrategistTrade(_id);\n        }\n    }\n\n    /// @notice Function where strategists claim rewards proportional to their quantity of fills\n    /// @dev This function should allow a strategist to claim ERC20s sitting on this contract (earned via rebalancing) relative to their share or strategist activity on the pair\n    /// @dev Provide the pair on which you want to claim rewards\n    function strategistBootyClaim(address asset, address quote)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        uint256 fillCountA = strategist2Fills[msg.sender][asset];\n        uint256 fillCountQ = strategist2Fills[msg.sender][quote];\n        if (fillCountA > 0) {\n            uint256 booty = (\n                fillCountA.mul(IERC20(asset).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[asset]);\n            IERC20(asset).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                asset,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[asset] -= fillCountA;\n            strategist2Fills[msg.sender][asset] -= fillCountA;\n        }\n        if (fillCountQ > 0) {\n            uint256 booty = (\n                fillCountQ.mul(IERC20(quote).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[quote]);\n            IERC20(quote).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                quote,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[quote] -= fillCountQ;\n            strategist2Fills[msg.sender][quote] -= fillCountQ;\n        }\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The goal of this function is to enable a means to retrieve all outstanding orders a strategist has live in the books\n    /// @dev This is helpful to manage orders as well as track all strategist orders (like their RAM of StratTrade IDs) and place any would-be constraints on strategists\n    function getOutstandingStrategistTrades(\n        address asset,\n        address quote,\n        address strategist\n    ) public view returns (uint256[] memory) {\n        return outOffersByStrategist[asset][quote][strategist];\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./VestingWallet.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title BathBuddy\n * @dev *** This contract is a lightly modified version of Vesting Wallet by OpenZeppelin\n * @dev PLEASE FIND OZ DOCUMENTATION FOR THIS CONTRACT HERE: https://docs.openzeppelin.com/contracts/4.x/api/finance#VestingWallet\n *\n * @dev The only entrypoint used in the system is the release function called by the Bath Token. Extra care should be taken to make sure only the beneficiary can ever access the funds and send them to the withdrawer (and fee to self)\n *\n * @dev This contract handles the vesting ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract BathBuddy is IBathBuddy {\n    using SafeMath for uint256;\n\n    // Public versions of the base VestingWallet storage\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n\n    // Beneficiary must be the Bath Token vault recipient that will call release() for its withdrawer\n    address public beneficiary;\n    uint64 public start;\n    uint64 public duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint64 startTimestamp,\n        uint64 durationSeconds\n    ) {\n        require(\n            beneficiaryAddress != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        beneficiary = beneficiaryAddress;\n        start = startTimestamp;\n        duration = durationSeconds;\n    }\n\n    // OZ\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    /// @notice Log bonus token reward event\n    event LogClaimBonusToken(\n        address indexed receiver,\n        address indexed callingPool,\n        uint256 amountReceived,\n        uint256 shares,\n        IERC20 bonusToken,\n        uint256 releasableAmountToWholePool\n    );\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /// @inheritdoc IBathBuddy\n    /// @dev Added and modified release function. Should be the only callable release function\n    function release(\n        IERC20 token,\n        address recipient,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply,\n        uint256 poolFee\n    ) external override {\n        require(\n            msg.sender == beneficiary,\n            \"Caller is not the Bath Token beneficiary of these rewards\"\n        );\n        uint256 releasable = vestedAmount(\n            address(token),\n            uint64(block.timestamp)\n        ) - released(address(token));\n        if (releasable > 0) {\n            uint256 amount = releasable.mul(sharesWithdrawn).div(\n                initialTotalSupply\n            );\n            uint256 _fee = amount.mul(poolFee).div(10000);\n\n            // If FeeTo == address(this) then the fee is effectively accrued by the pool\n            // Assume the caller is the liquidity pool and they receive the fee\n            // Keep tokens here by not transfering the _fee anywhere, it is accrued to the Bath Token's Bath Buddy\n            // token.transfer(address(this), _fee);\n\n            uint256 amountWithdrawn = amount.sub(_fee);\n            token.transfer(recipient, amountWithdrawn);\n\n            _erc20Released[address(token)] += amount;\n            emit ERC20Released(address(token), amount);\n\n            emit LogClaimBonusToken(\n                recipient,\n                msg.sender,\n                amountWithdrawn,\n                sharesWithdrawn,\n                token,\n                releasable\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _vestingSchedule(\n                IERC20(token).balanceOf(address(this)) + released(token),\n                timestamp\n            );\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        if (timestamp < start) {\n            return 0;\n        } else if (timestamp > start + duration) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start)) / duration;\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Benjamin Hughes - Rubicon\n/// @notice This contract is a router to interact with the low-level functions present in RubiconMarket and Pools\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./RubiconMarket.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./peripheral_contracts/WETH9.sol\"; // @unsupported: ovm\nimport \"./interfaces/IBathToken.sol\";\n\n///@dev this contract is a high-level router that utilizes Rubicon smart contracts to provide\n///@dev added convenience and functionality when interacting with the Rubicon protocol\ncontract RubiconRouter {\n    using SafeMath for uint256;\n\n    address public RubiconMarketAddress;\n\n    address payable public wethAddress;\n\n    bool public started;\n\n    event LogNote(string, uint256);\n\n    event LogSwap(\n        uint256 inputAmount,\n        address inputERC20,\n        uint256 hurdleBuyAmtMin,\n        address targetERC20,\n        bytes32 indexed pair,\n        uint256 realizedFill,\n        address recipient\n    );\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function startErUp(address _theTrap, address payable _weth) external {\n        require(!started);\n        RubiconMarketAddress = _theTrap;\n        wethAddress = _weth;\n        started = true;\n    }\n\n    /// @notice Get the outstanding best N orders from both sides of the order book for a given pair\n    /// @dev The asset/quote pair ordering will affect return values - asset should be the top of the pair: for example, (ETH, USDC, 10) will return (10 best ETH asks, 10 best USDC bids, 10)\n    /// @param asset the ERC20 token that represents the ask/sell side of the order book\n    /// @param quote the ERC20 token that represents the bid/buy side of the order book\n    /// @param topNOrders the depth of the order book the caller would like to query/view for the asset-quote pair\n    /// @dev \"best\" orders are determined by proximity to the midpoint of the pair. Closest to the midpoint is best order.\n    /// @return Fixed arrays (of topNOrders length) in \"best\" order (returned asks/bids[0] is best and asks/bids[topNOrders] is worst) of asks and bids + topNOrders. Each offer array item is: [pay, buy, offerId]\n    function getBookFromPair(\n        ERC20 asset,\n        ERC20 quote,\n        uint256 topNOrders\n    )\n        public\n        view\n        returns (\n            uint256[3][] memory,\n            uint256[3][] memory,\n            uint256\n        )\n    {\n        uint256[3][] memory asks = new uint256[3][](topNOrders);\n        uint256[3][] memory bids = new uint256[3][](topNOrders);\n        address _RubiconMarketAddress = RubiconMarketAddress;\n\n        //1. Get best offer for each asset\n        uint256 bestAskID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            asset,\n            quote\n        );\n        uint256 bestBidID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            quote,\n            asset\n        );\n\n        uint256 lastBid = 0;\n        uint256 lastAsk = 0;\n        //2. Iterate from that offer down the book until topNOrders\n        for (uint256 index = 0; index < topNOrders; index++) {\n            if (index == 0) {\n                lastAsk = bestAskID;\n                lastBid = bestBidID;\n\n                (\n                    uint256 _ask_pay_amt,\n                    ,\n                    uint256 _ask_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestAskID);\n                (\n                    uint256 _bid_pay_amt,\n                    ,\n                    uint256 _bid_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestBidID);\n                asks[index] = [_ask_pay_amt, _ask_buy_amt, bestAskID];\n                bids[index] = [_bid_pay_amt, _bid_buy_amt, bestBidID];\n                continue;\n            }\n            uint256 nextBestAsk = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastAsk);\n            uint256 nextBestBid = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastBid);\n            (uint256 ask_pay_amt, , uint256 ask_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestAsk);\n            (uint256 bid_pay_amt, , uint256 bid_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestBid);\n\n            asks[index] = [ask_pay_amt, ask_buy_amt, nextBestAsk];\n            bids[index] = [bid_pay_amt, bid_buy_amt, nextBestBid];\n            // bids[index] = nextBestBid;\n            lastBid = nextBestBid;\n            lastAsk = nextBestAsk;\n        }\n\n        //3. Return those topNOrders for either side of the order book\n        return (asks, bids, topNOrders);\n    }\n\n    /// @dev this function returns the best offer for a pair's id and info\n    function getBestOfferAndInfo(address asset, address quote)\n        public\n        view\n        returns (\n            uint256, //id\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        address _market = RubiconMarketAddress;\n        uint256 offer = RubiconMarket(_market).getBestOffer(\n            ERC20(asset),\n            ERC20(quote)\n        );\n        (\n            uint256 pay_amt,\n            ERC20 pay_gem,\n            uint256 buy_amt,\n            ERC20 buy_gem\n        ) = RubiconMarket(_market).getOffer(offer);\n        return (offer, pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // function for infinite approvals of Rubicon Market\n    function approveAssetOnMarket(address toApprove) public {\n        // Approve exchange\n        ERC20(toApprove).approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @dev this function takes the same parameters of swap and returns the expected amount\n    function getExpectedSwapFill(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public view returns (uint256 fill_amt) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            uint256 wouldBeFillAmount = RubiconMarket(_market).getBuyAmount(\n                ERC20(output),\n                ERC20(input),\n                _pay\n            );\n            currentAmount = wouldBeFillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // Return the wouldbe resulting swap amount\n        return (currentAmount);\n    }\n\n    /// @dev This function lets a user swap from route[0] -> route[last] at some minimum expected rate\n    /// @dev pay_amt - amount to be swapped away from msg.sender of *first address in path*\n    /// @dev buy_amt_min - target minimum received of *last address in path*\n    function swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public returns (uint256) {\n        //**User must approve this contract first**\n        //transfer needed amount here first\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000)) // Account for expected fee\n        );\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    // Internal function requires that ERC20s are here before execution\n    function _swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS,\n        address to // Recipient of swap outputs!\n    ) internal returns (uint256) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            if (ERC20(input).allowance(address(this), _market) == 0) {\n                approveAssetOnMarket(input);\n            }\n            uint256 fillAmount = RubiconMarket(_market).sellAllAmount(\n                ERC20(input),\n                _pay,\n                ERC20(output),\n                0 //naively assume no fill_amt here for loop purposes?\n            );\n            currentAmount = fillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // send tokens back to sender if not keeping here\n        if (to != address(this)) {\n            ERC20(route[route.length - 1]).transfer(to, currentAmount);\n        }\n\n        emit LogSwap(\n            pay_amt,\n            route[0],\n            buy_amt_min,\n            route[route.length - 1],\n            keccak256(abi.encodePacked(route[0], route[route.length - 1])),\n            currentAmount,\n            to\n        );\n        return currentAmount;\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function swapEntireBalance(\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external returns (uint256) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(route[0]).balanceOf(msg.sender);\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            maxAmount // Account for expected fee\n        );\n        return\n            _swap(\n                maxAmount,\n                maxAmount.sub(buy_amt_min.mul(expectedMarketFeeBPS).div(10000)), //account for fee\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxBuyAllAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender's entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            maxAmount,\n            pay_gem,\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxSellAllAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(\n            pay_gem,\n            maxAmount,\n            buy_gem,\n            min_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    // ** Native ETH Wrapper Functions **\n    /// @dev WETH wrapper functions to obfuscate WETH complexities from ETH holders\n    function buyAllAmountWithETH(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        uint256 max_fill_amount,\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        address _weth = address(wethAddress);\n        uint256 _before = ERC20(_weth).balanceOf(address(this));\n        uint256 max_fill_withFee = max_fill_amount.add(\n            max_fill_amount.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= max_fill_withFee,\n            \"must send as much ETH as max_fill_withFee\"\n        );\n        WETH9(wethAddress).deposit{value: max_fill_withFee}(); // Pay with native ETH -> WETH\n        // An amount in WETH\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, buy_amt);\n\n        uint256 _after = ERC20(_weth).balanceOf(address(this));\n        uint256 delta = _after - _before;\n\n        // Return unspent coins to sender\n        if (delta > 0) {\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n    }\n\n    // Paying ERC20 to buy native ETH\n    function buyAllAmountForETH(\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), max_fill_amount); //transfer pay here\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            ERC20(wethAddress),\n            buy_amt,\n            pay_gem,\n            max_fill_amount\n        );\n        WETH9(wethAddress).withdraw(buy_amt); // Fill in WETH\n        msg.sender.transfer(buy_amt); // Return native ETH\n        // Return unspent coins to sender\n        if (max_fill_amount > fill) {\n            ERC20(pay_gem).transfer(msg.sender, max_fill_amount - fill);\n        }\n        return fill;\n    }\n\n    // Pay in native ETH\n    function offerWithETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        // ERC20 nativeETH, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external payable returns (uint256) {\n        require(\n            msg.value >= pay_amt,\n            \"didnt send enough native ETH for WETH offer\"\n        );\n        uint256 _before = ERC20(buy_gem).balanceOf(address(this));\n        WETH9(wethAddress).deposit{value: pay_amt}();\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            ERC20(wethAddress),\n            buy_amt,\n            buy_gem,\n            pos\n        );\n        uint256 _after = ERC20(buy_gem).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer\n            ERC20(buy_gem).transfer(msg.sender, _after - _before);\n        }\n        return id;\n    }\n\n    // Pay in native ETH\n    function offerForETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        // ERC20 nativeETH, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external returns (uint256) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), pay_amt);\n\n        uint256 _before = ERC20(wethAddress).balanceOf(address(this));\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            pos\n        );\n        uint256 _after = ERC20(wethAddress).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer as native ETH\n            uint256 delta = _after - _before;\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n        return id;\n    }\n\n    // Cancel an offer made in WETH\n    function cancelForETH(uint256 id) external returns (bool outcome) {\n        (uint256 pay_amt, ERC20 pay_gem, , ) = RubiconMarket(\n            RubiconMarketAddress\n        ).getOffer(id);\n        require(\n            address(pay_gem) == wethAddress,\n            \"trying to cancel a non WETH order\"\n        );\n        // Cancel order and receive WETH here in amount of pay_amt\n        outcome = RubiconMarket(RubiconMarketAddress).cancel(id);\n        WETH9(wethAddress).withdraw(pay_amt);\n        msg.sender.transfer(pay_amt);\n    }\n\n    // Deposit native ETH -> WETH pool\n    function depositWithETH(uint256 amount, address targetPool)\n        external\n        payable\n        returns (uint256 newShares)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(msg.value >= amount, \"didnt send enough eth\");\n\n        if (target.allowance(address(this), targetPool) == 0) {\n            target.approve(targetPool, amount);\n        }\n\n        WETH9(wethAddress).deposit{value: amount}();\n        newShares = IBathToken(targetPool).deposit(amount);\n        //Send back bathTokens to sender\n        ERC20(targetPool).transfer(msg.sender, newShares);\n    }\n\n    // Withdraw native ETH <- WETH pool\n    function withdrawForETH(uint256 shares, address targetPool)\n        external\n        payable\n        returns (uint256 withdrawnWETH)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(\n            IBathToken(targetPool).balanceOf(msg.sender) >= shares,\n            \"don't own enough shares\"\n        );\n        IBathToken(targetPool).transferFrom(msg.sender, address(this), shares);\n        withdrawnWETH = IBathToken(targetPool).withdraw(shares);\n        WETH9(wethAddress).withdraw(withdrawnWETH);\n\n        //Send back withdrawn native eth to sender\n        msg.sender.transfer(withdrawnWETH);\n    }\n\n    function swapWithETH(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256) {\n        require(route[0] == wethAddress, \"Initial value in path not WETH\");\n        uint256 amtWithFee = pay_amt.add(\n            pay_amt.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= amtWithFee,\n            \"must send enough native ETH to pay as weth and account for fee\"\n        );\n        WETH9(wethAddress).deposit{value: amtWithFee}();\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    function swapForETH(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        require(\n            route[route.length - 1] == wethAddress,\n            \"target of swap is not WETH\"\n        );\n        //Transfer tokens here first and account for fee\n        require(\n            ERC20(route[0]).transferFrom(\n                msg.sender,\n                address(this),\n                pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000))\n            ),\n            \"initial ERC20 transfer failed\"\n        );\n        fill = _swap(\n            pay_amt,\n            buy_amt_min,\n            route,\n            expectedMarketFeeBPS,\n            address(this)\n        );\n\n        WETH9(wethAddress).withdraw(fill);\n        // msg.sender.transfer(fill);\n        msg.sender.transfer(fill);\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            uint256 amountWithdrawn;\n            uint256 _fee = assets.mul(feeBPS).div(10000);\n            amountWithdrawn = assets.sub(_fee);\n            shares = convertToShares(amountWithdrawn);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 _initialTotalSupply = totalSupply;\n\n        // Distribute network rewards first in order to handle bonus token == underlying token case; it only releases vested tokens in this call\n        distributeBonusTokenRewards(receiver, _shares, _initialTotalSupply);\n\n        uint256 r = (underlyingBalance().mul(_shares)).div(_initialTotalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.transfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.transfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern. Fees sit on BathBuddy to act as effectively accrued to the pool.\n    function distributeBonusTokenRewards(\n        address receiver,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply\n    ) internal {\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                // Note: Shares already burned in Bath Token _withdraw\n\n                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n                //  are released their relative share of this pool, of vested BathBuddy rewards\n                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n                if (rewardsVestingWallet != IBathBuddy(0)) {\n                    rewardsVestingWallet.release(\n                        (token),\n                        receiver,\n                        sharesWithdrawn,\n                        initialTotalSupply,\n                        feeBPS\n                    );\n                }\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}\n\n\n",
        "CodeNames": [
            "BathPair.sol",
            "BathBuddy.sol",
            "RubiconRouter.sol",
            "BathToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Multiple locations in RubiconRouter.sol, BathBuddy.sol, BathPair.sol, and BathToken.sol",
                "Type": "Use of unsafe transfer functions",
                "Description": "Failure to use safeTransfer()/safeTransferFrom() or add a require() statement to check the return value of ERC20 token transfers can cause silent failures of transfers and affect token accounting in contract.",
                "Repair": "Use OpenZeppelin\u2019s safeTransfer()/safeTransferFrom() or add a require() statement that checks the return value of ERC20 token transfers"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Benjamin Hughes - Rubicon\n/// @notice This contract is a router to interact with the low-level functions present in RubiconMarket and Pools\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./RubiconMarket.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./peripheral_contracts/WETH9.sol\"; // @unsupported: ovm\nimport \"./interfaces/IBathToken.sol\";\n\n///@dev this contract is a high-level router that utilizes Rubicon smart contracts to provide\n///@dev added convenience and functionality when interacting with the Rubicon protocol\ncontract RubiconRouter {\n    using SafeMath for uint256;\n\n    address public RubiconMarketAddress;\n\n    address payable public wethAddress;\n\n    bool public started;\n\n    event LogNote(string, uint256);\n\n    event LogSwap(\n        uint256 inputAmount,\n        address inputERC20,\n        uint256 hurdleBuyAmtMin,\n        address targetERC20,\n        bytes32 indexed pair,\n        uint256 realizedFill,\n        address recipient\n    );\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function startErUp(address _theTrap, address payable _weth) external {\n        require(!started);\n        RubiconMarketAddress = _theTrap;\n        wethAddress = _weth;\n        started = true;\n    }\n\n    /// @notice Get the outstanding best N orders from both sides of the order book for a given pair\n    /// @dev The asset/quote pair ordering will affect return values - asset should be the top of the pair: for example, (ETH, USDC, 10) will return (10 best ETH asks, 10 best USDC bids, 10)\n    /// @param asset the ERC20 token that represents the ask/sell side of the order book\n    /// @param quote the ERC20 token that represents the bid/buy side of the order book\n    /// @param topNOrders the depth of the order book the caller would like to query/view for the asset-quote pair\n    /// @dev \"best\" orders are determined by proximity to the midpoint of the pair. Closest to the midpoint is best order.\n    /// @return Fixed arrays (of topNOrders length) in \"best\" order (returned asks/bids[0] is best and asks/bids[topNOrders] is worst) of asks and bids + topNOrders. Each offer array item is: [pay, buy, offerId]\n    function getBookFromPair(\n        ERC20 asset,\n        ERC20 quote,\n        uint256 topNOrders\n    )\n        public\n        view\n        returns (\n            uint256[3][] memory,\n            uint256[3][] memory,\n            uint256\n        )\n    {\n        uint256[3][] memory asks = new uint256[3][](topNOrders);\n        uint256[3][] memory bids = new uint256[3][](topNOrders);\n        address _RubiconMarketAddress = RubiconMarketAddress;\n\n        //1. Get best offer for each asset\n        uint256 bestAskID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            asset,\n            quote\n        );\n        uint256 bestBidID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            quote,\n            asset\n        );\n\n        uint256 lastBid = 0;\n        uint256 lastAsk = 0;\n        //2. Iterate from that offer down the book until topNOrders\n        for (uint256 index = 0; index < topNOrders; index++) {\n            if (index == 0) {\n                lastAsk = bestAskID;\n                lastBid = bestBidID;\n\n                (\n                    uint256 _ask_pay_amt,\n                    ,\n                    uint256 _ask_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestAskID);\n                (\n                    uint256 _bid_pay_amt,\n                    ,\n                    uint256 _bid_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestBidID);\n                asks[index] = [_ask_pay_amt, _ask_buy_amt, bestAskID];\n                bids[index] = [_bid_pay_amt, _bid_buy_amt, bestBidID];\n                continue;\n            }\n            uint256 nextBestAsk = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastAsk);\n            uint256 nextBestBid = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastBid);\n            (uint256 ask_pay_amt, , uint256 ask_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestAsk);\n            (uint256 bid_pay_amt, , uint256 bid_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestBid);\n\n            asks[index] = [ask_pay_amt, ask_buy_amt, nextBestAsk];\n            bids[index] = [bid_pay_amt, bid_buy_amt, nextBestBid];\n            // bids[index] = nextBestBid;\n            lastBid = nextBestBid;\n            lastAsk = nextBestAsk;\n        }\n\n        //3. Return those topNOrders for either side of the order book\n        return (asks, bids, topNOrders);\n    }\n\n    /// @dev this function returns the best offer for a pair's id and info\n    function getBestOfferAndInfo(address asset, address quote)\n        public\n        view\n        returns (\n            uint256, //id\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        address _market = RubiconMarketAddress;\n        uint256 offer = RubiconMarket(_market).getBestOffer(\n            ERC20(asset),\n            ERC20(quote)\n        );\n        (\n            uint256 pay_amt,\n            ERC20 pay_gem,\n            uint256 buy_amt,\n            ERC20 buy_gem\n        ) = RubiconMarket(_market).getOffer(offer);\n        return (offer, pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // function for infinite approvals of Rubicon Market\n    function approveAssetOnMarket(address toApprove) public {\n        // Approve exchange\n        ERC20(toApprove).approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @dev this function takes the same parameters of swap and returns the expected amount\n    function getExpectedSwapFill(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public view returns (uint256 fill_amt) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            uint256 wouldBeFillAmount = RubiconMarket(_market).getBuyAmount(\n                ERC20(output),\n                ERC20(input),\n                _pay\n            );\n            currentAmount = wouldBeFillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // Return the wouldbe resulting swap amount\n        return (currentAmount);\n    }\n\n    /// @dev This function lets a user swap from route[0] -> route[last] at some minimum expected rate\n    /// @dev pay_amt - amount to be swapped away from msg.sender of *first address in path*\n    /// @dev buy_amt_min - target minimum received of *last address in path*\n    function swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public returns (uint256) {\n        //**User must approve this contract first**\n        //transfer needed amount here first\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000)) // Account for expected fee\n        );\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    // Internal function requires that ERC20s are here before execution\n    function _swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS,\n        address to // Recipient of swap outputs!\n    ) internal returns (uint256) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            if (ERC20(input).allowance(address(this), _market) == 0) {\n                approveAssetOnMarket(input);\n            }\n            uint256 fillAmount = RubiconMarket(_market).sellAllAmount(\n                ERC20(input),\n                _pay,\n                ERC20(output),\n                0 //naively assume no fill_amt here for loop purposes?\n            );\n            currentAmount = fillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // send tokens back to sender if not keeping here\n        if (to != address(this)) {\n            ERC20(route[route.length - 1]).transfer(to, currentAmount);\n        }\n\n        emit LogSwap(\n            pay_amt,\n            route[0],\n            buy_amt_min,\n            route[route.length - 1],\n            keccak256(abi.encodePacked(route[0], route[route.length - 1])),\n            currentAmount,\n            to\n        );\n        return currentAmount;\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function swapEntireBalance(\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external returns (uint256) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(route[0]).balanceOf(msg.sender);\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            maxAmount // Account for expected fee\n        );\n        return\n            _swap(\n                maxAmount,\n                maxAmount.sub(buy_amt_min.mul(expectedMarketFeeBPS).div(10000)), //account for fee\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxBuyAllAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender's entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            maxAmount,\n            pay_gem,\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxSellAllAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(\n            pay_gem,\n            maxAmount,\n            buy_gem,\n            min_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    // ** Native ETH Wrapper Functions **\n    /// @dev WETH wrapper functions to obfuscate WETH complexities from ETH holders\n    function buyAllAmountWithETH(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        uint256 max_fill_amount,\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        address _weth = address(wethAddress);\n        uint256 _before = ERC20(_weth).balanceOf(address(this));\n        uint256 max_fill_withFee = max_fill_amount.add(\n            max_fill_amount.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= max_fill_withFee,\n            \"must send as much ETH as max_fill_withFee\"\n        );\n        WETH9(wethAddress).deposit{value: max_fill_withFee}(); // Pay with native ETH -> WETH\n        // An amount in WETH\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, buy_amt);\n\n        uint256 _after = ERC20(_weth).balanceOf(address(this));\n        uint256 delta = _after - _before;\n\n        // Return unspent coins to sender\n        if (delta > 0) {\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n    }\n\n    // Paying ERC20 to buy native ETH\n    function buyAllAmountForETH(\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), max_fill_amount); //transfer pay here\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            ERC20(wethAddress),\n            buy_amt,\n            pay_gem,\n            max_fill_amount\n        );\n        WETH9(wethAddress).withdraw(buy_amt); // Fill in WETH\n        msg.sender.transfer(buy_amt); // Return native ETH\n        // Return unspent coins to sender\n        if (max_fill_amount > fill) {\n            ERC20(pay_gem).transfer(msg.sender, max_fill_amount - fill);\n        }\n        return fill;\n    }\n\n    // Pay in native ETH\n    function offerWithETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        // ERC20 nativeETH, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external payable returns (uint256) {\n        require(\n            msg.value >= pay_amt,\n            \"didnt send enough native ETH for WETH offer\"\n        );\n        uint256 _before = ERC20(buy_gem).balanceOf(address(this));\n        WETH9(wethAddress).deposit{value: pay_amt}();\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            ERC20(wethAddress),\n            buy_amt,\n            buy_gem,\n            pos\n        );\n        uint256 _after = ERC20(buy_gem).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer\n            ERC20(buy_gem).transfer(msg.sender, _after - _before);\n        }\n        return id;\n    }\n\n    // Pay in native ETH\n    function offerForETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        // ERC20 nativeETH, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external returns (uint256) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), pay_amt);\n\n        uint256 _before = ERC20(wethAddress).balanceOf(address(this));\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            pos\n        );\n        uint256 _after = ERC20(wethAddress).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer as native ETH\n            uint256 delta = _after - _before;\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n        return id;\n    }\n\n    // Cancel an offer made in WETH\n    function cancelForETH(uint256 id) external returns (bool outcome) {\n        (uint256 pay_amt, ERC20 pay_gem, , ) = RubiconMarket(\n            RubiconMarketAddress\n        ).getOffer(id);\n        require(\n            address(pay_gem) == wethAddress,\n            \"trying to cancel a non WETH order\"\n        );\n        // Cancel order and receive WETH here in amount of pay_amt\n        outcome = RubiconMarket(RubiconMarketAddress).cancel(id);\n        WETH9(wethAddress).withdraw(pay_amt);\n        msg.sender.transfer(pay_amt);\n    }\n\n    // Deposit native ETH -> WETH pool\n    function depositWithETH(uint256 amount, address targetPool)\n        external\n        payable\n        returns (uint256 newShares)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(msg.value >= amount, \"didnt send enough eth\");\n\n        if (target.allowance(address(this), targetPool) == 0) {\n            target.approve(targetPool, amount);\n        }\n\n        WETH9(wethAddress).deposit{value: amount}();\n        newShares = IBathToken(targetPool).deposit(amount);\n        //Send back bathTokens to sender\n        ERC20(targetPool).transfer(msg.sender, newShares);\n    }\n\n    // Withdraw native ETH <- WETH pool\n    function withdrawForETH(uint256 shares, address targetPool)\n        external\n        payable\n        returns (uint256 withdrawnWETH)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(\n            IBathToken(targetPool).balanceOf(msg.sender) >= shares,\n            \"don't own enough shares\"\n        );\n        IBathToken(targetPool).transferFrom(msg.sender, address(this), shares);\n        withdrawnWETH = IBathToken(targetPool).withdraw(shares);\n        WETH9(wethAddress).withdraw(withdrawnWETH);\n\n        //Send back withdrawn native eth to sender\n        msg.sender.transfer(withdrawnWETH);\n    }\n\n    function swapWithETH(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256) {\n        require(route[0] == wethAddress, \"Initial value in path not WETH\");\n        uint256 amtWithFee = pay_amt.add(\n            pay_amt.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= amtWithFee,\n            \"must send enough native ETH to pay as weth and account for fee\"\n        );\n        WETH9(wethAddress).deposit{value: amtWithFee}();\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    function swapForETH(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        require(\n            route[route.length - 1] == wethAddress,\n            \"target of swap is not WETH\"\n        );\n        //Transfer tokens here first and account for fee\n        require(\n            ERC20(route[0]).transferFrom(\n                msg.sender,\n                address(this),\n                pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000))\n            ),\n            \"initial ERC20 transfer failed\"\n        );\n        fill = _swap(\n            pay_amt,\n            buy_amt_min,\n            route,\n            expectedMarketFeeBPS,\n            address(this)\n        );\n\n        WETH9(wethAddress).withdraw(fill);\n        // msg.sender.transfer(fill);\n        msg.sender.transfer(fill);\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            uint256 amountWithdrawn;\n            uint256 _fee = assets.mul(feeBPS).div(10000);\n            amountWithdrawn = assets.sub(_fee);\n            shares = convertToShares(amountWithdrawn);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 _initialTotalSupply = totalSupply;\n\n        // Distribute network rewards first in order to handle bonus token == underlying token case; it only releases vested tokens in this call\n        distributeBonusTokenRewards(receiver, _shares, _initialTotalSupply);\n\n        uint256 r = (underlyingBalance().mul(_shares)).div(_initialTotalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.transfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.transfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern. Fees sit on BathBuddy to act as effectively accrued to the pool.\n    function distributeBonusTokenRewards(\n        address receiver,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply\n    ) internal {\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                // Note: Shares already burned in Bath Token _withdraw\n\n                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n                //  are released their relative share of this pool, of vested BathBuddy rewards\n                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n                if (rewardsVestingWallet != IBathBuddy(0)) {\n                    rewardsVestingWallet.release(\n                        (token),\n                        receiver,\n                        sharesWithdrawn,\n                        initialTotalSupply,\n                        feeBPS\n                    );\n                }\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\n/// @title  The administrator contract of Rubicon Pools\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice The BathHouse initializes proxy-wrapped bathTokens, manages approved strategists, and sets system variables\n\npragma solidity =0.7.6;\n\nimport \"./BathToken.sol\";\nimport \"../interfaces/IBathPair.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\n\ncontract BathHouse {\n    /// *** Storage Variables ***\n\n    /// @notice Rubicon Bath House\n    string public name;\n\n    /// @notice The administrator of the Bath House contract\n    address public admin;\n\n    /// @notice The proxy administrator of Bath Tokens\n    address public proxyManager;\n\n    /// @notice The core Rubicon Market of the Pools system\n    address public RubiconMarketAddress;\n\n    /// @notice A mapping of approved strategists to access Pools liquidity\n    mapping(address => bool) public approvedStrategists;\n\n    /// @notice The initialization status of BathHouse\n    bool public initialized;\n\n    /// @notice If true, strategists are permissioned and must be approved by admin\n    bool public permissionedStrategists;\n\n    /// @notice Key, system-wide risk parameter for all liquity Pools\n    /// @notice This represents the proportion of a pool's underlying assets that must remain in the pool\n    /// @dev This protects a run on the bank scenario and ensures users can withdraw while allowing funds to be utilized for yield in the market\n    uint256 public reserveRatio;\n\n    /// @notice A variable time delay after which a strategist must return funds to the Bath Token\n    uint256 public timeDelay;\n\n    /// @notice The lone Bath Pair contract of the system which acts as the strategist entry point and logic contract\n    address public approvedPairContract;\n\n    /// @notice The basis point fee that is paid to strategists from LPs on capital that is successfully rebalanced to a Bath Token\n    uint8 public bpsToStrategists;\n\n    /// @notice Key mapping for determining the address of a Bath Token based on its underlying asset\n    /// @dev Source of truth mapping that logs all ERC20 Liquidity pools underlying asset => bathToken Address\n    mapping(address => address) public tokenToBathToken;\n\n    /// @notice The BathToken.sol implementation that any new bathTokens inherit\n    /// @dev The implementation of any ~newly spawned~ proxy-wrapped Bath Tokens via _createBathToken\n    address public newBathTokenImplementation;\n\n    /// *** Events ***\n\n    /// @notice An event that signals the creation of a new Bath Token\n    event LogNewBathToken(\n        address underlyingToken,\n        address bathTokenAddress,\n        address bathTokenFeeAdmin,\n        uint256 timestamp,\n        address bathTokenCreator\n    );\n\n    /// @notice An event that signals the permissionless spawning of a new Bath Token\n    event LogOpenCreationSignal(\n        ERC20 newERC20Underlying,\n        address spawnedBathToken,\n        uint256 initialNewBathTokenDeposit,\n        ERC20 pairedExistingAsset,\n        address pairedExistingBathToken,\n        uint256 pairedBathTokenDeposit,\n        address signaler\n    );\n\n    /// *** Modifiers ***\n\n    /// @notice This modifier enforces that only the admin can call these functions\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    /// *** External Functions ***\n\n    /// @notice The constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage that sets key storage variables\n    /// @dev Admin is set to msg.sender\n    function initialize(\n        address market,\n        uint256 _reserveRatio,\n        uint256 _timeDelay,\n        address _newBathTokenImplementation,\n        address _proxyAdmin\n    ) external {\n        require(!initialized);\n        name = \"Rubicon Bath House\";\n        admin = msg.sender;\n        timeDelay = _timeDelay;\n\n        // Set Bath Token reserve ratio globally\n        require(_reserveRatio <= 100);\n        require(_reserveRatio > 0);\n        reserveRatio = _reserveRatio;\n\n        // Set BPS reward fee for successful strategist market-making\n        /// @notice [(10000 - {bpsToStrategists}) / 10000] BPS of MM-ing activity is passed to users\n        bpsToStrategists = 20;\n\n        // Set key storage variables\n        RubiconMarketAddress = market;\n        permissionedStrategists = true;\n        newBathTokenImplementation = _newBathTokenImplementation;\n        proxyManager = _proxyAdmin;\n\n        // Automatically approve admin as an approved strategist\n        approveStrategist(admin);\n\n        // Complete contract instantiation\n        initialized = true;\n    }\n\n    /// @notice Permissionless entry point to spawn a Bath Token while posting liquidity to a ~pair of Bath Tokens~\n    /// @notice Please note, creating a Bath Token in this fashion ~does not~ gaurentee markets will be made for the new pair. This function signals the desire to have a new pair supported on Rubicon for strategists to consider market-making for\n    /// @notice The best desiredPairedAsset to select is a popular quote currency. Many traditional systems quote in USD while the ETH quote is superior - the choice is yours sweet msg.sender\n    /// @dev The user must approve the bathHouse to spend their ERC20s\n    /// @dev The user can only spawn a Bath Token for an ERC20 that is not yet in the Pools system and they must post liquidity on the other side of the pair for an ~extant Bath Token~\n    function openBathTokenSpawnAndSignal(\n        ERC20 newBathTokenUnderlying,\n        uint256 initialLiquidityNew, // Must approve this contract to spend\n        ERC20 desiredPairedAsset, // Must be paired with an existing quote for v1\n        uint256 initialLiquidityExistingBathToken\n    ) external returns (address newBathToken) {\n        // Check that it doesn't already exist\n        require(\n            getBathTokenfromAsset(newBathTokenUnderlying) == address(0),\n            \"bathToken already exists for that ERC20\"\n        );\n        require(\n            getBathTokenfromAsset(desiredPairedAsset) != address(0),\n            \"bathToken does not exist for that desiredPairedAsset\"\n        );\n\n        // Spawn a bathToken for the new asset\n        address newOne = _createBathToken(newBathTokenUnderlying, address(0)); // NOTE: address(0) as feeAdmin means fee is paid to pool holders\n\n        // Deposit initial liquidity posted of newBathTokenUnderlying\n        require(\n            newBathTokenUnderlying.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityNew\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n\n        newBathTokenUnderlying.approve(newOne, initialLiquidityNew);\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(newOne).deposit(initialLiquidityNew, msg.sender);\n\n        // desiredPairedAsset must be pulled and deposited into bathToken\n        require(\n            desiredPairedAsset.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityExistingBathToken\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n        address pairedPool = getBathTokenfromAsset((desiredPairedAsset));\n        desiredPairedAsset.approve(\n            pairedPool,\n            initialLiquidityExistingBathToken\n        );\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(pairedPool).deposit(\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        // emit an event describing the new pair, underlyings and bathTokens\n        emit LogOpenCreationSignal(\n            newBathTokenUnderlying,\n            newOne,\n            initialLiquidityNew,\n            desiredPairedAsset,\n            pairedPool,\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        newBathToken = newOne;\n    }\n\n    /// ** Admin-Only Functions **\n\n    /// @notice An admin-only function to create a new Bath Token for any ERC20\n    function createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        external\n        onlyAdmin\n        returns (address newBathTokenAddress)\n    {\n        newBathTokenAddress = _createBathToken(underlyingERC20, _feeAdmin);\n    }\n\n    /// @notice A migration function that allows the admin to write arbitrarily to tokenToBathToken\n    function adminWriteBathToken(ERC20 overwriteERC20, address newBathToken)\n        external\n        onlyAdmin\n    {\n        tokenToBathToken[address(overwriteERC20)] = newBathToken;\n        emit LogNewBathToken(\n            address(overwriteERC20),\n            newBathToken,\n            address(0),\n            block.timestamp,\n            msg.sender\n        );\n    }\n\n    /// @notice Function to initialize and store the address of the ~lone~ bathPair contract for the Rubicon protocol\n    function initBathPair(\n        address _bathPairAddress,\n        uint256 _maxOrderSizeBPS,\n        int128 _shapeCoefNum\n    ) external onlyAdmin returns (address newPair) {\n        require(\n            approvedPairContract == address(0),\n            \"BathPair already approved\"\n        );\n        require(\n            IBathPair(_bathPairAddress).initialized() != true,\n            \"BathPair already initialized\"\n        );\n        newPair = _bathPairAddress;\n\n        IBathPair(newPair).initialize(_maxOrderSizeBPS, _shapeCoefNum);\n\n        approvedPairContract = newPair;\n    }\n\n    /// @notice Admin-only function to set a new Admin\n    function setBathHouseAdmin(address newAdmin) external onlyAdmin {\n        admin = newAdmin;\n    }\n\n    /// @notice Admin-only function to set a new Bath Token implementation\n    /// @dev Please note that all bathTokens created will use this abi\n    function setNewBathTokenImplementation(address newImplementation) external onlyAdmin {\n        newBathTokenImplementation = newImplementation;\n    }\n\n    /// @notice Admin-only function to approve a new permissioned strategist\n    function approveStrategist(address strategist) public onlyAdmin {\n        approvedStrategists[strategist] = true;\n    }\n\n    /// @notice Admin-only function to set whether or not strategists are permissioned\n    function setPermissionedStrategists(bool _new) external onlyAdmin {\n        permissionedStrategists = _new;\n    }\n\n    /// @notice Admin-only function to set timeDelay\n    function setCancelTimeDelay(uint256 value) external onlyAdmin {\n        timeDelay = value;\n    }\n\n    /// @notice Admin-only function to set reserveRatio\n    function setReserveRatio(uint256 rr) external onlyAdmin {\n        require(rr <= 100);\n        require(rr > 0);\n        reserveRatio = rr;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's timeDelay\n    function setBathTokenMarket(address bathToken, address newMarket)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setMarket(newMarket);\n    }\n\n    /// @notice Admin-only function to add a bonus token to a Bath Token's reward schema\n    function setBonusToken(address bathToken, address newBonusToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBonusToken(newBonusToken);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathTokenBathHouse(address bathToken, address newAdmin)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBathHouse(newAdmin);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setBathTokenFeeBPS(address bathToken, uint256 newBPS)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeBPS(newBPS);\n    }\n\n    /// @notice Admin-only function to approve the Bath Token's underlying token on the assigned market\n    /// @dev required in case the market address ever changes.. #battleScars\n    function bathTokenApproveSetMarket(address targetBathToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(targetBathToken).approveMarket();\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient (typically the Bath Token itself)\n    function setBathTokenFeeTo(address bathToken, address feeTo)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeTo(feeTo);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's target Rubicon Market\n    function setMarket(address newMarket) external onlyAdmin {\n        RubiconMarketAddress = newMarket;\n    }\n\n    /// *** View Functions ***\n\n    // Getter Functions for parameters\n    function getMarket() external view returns (address) {\n        return RubiconMarketAddress;\n    }\n\n    function getReserveRatio() external view returns (uint256) {\n        return reserveRatio;\n    }\n\n    function getCancelTimeDelay() external view returns (uint256) {\n        return timeDelay;\n    }\n\n    /// @notice Returns the address of any bathToken in the system based on its corresponding underlying asset\n    function getBathTokenfromAsset(ERC20 asset) public view returns (address) {\n        return tokenToBathToken[address(asset)];\n    }\n\n    function getBPSToStrats() public view returns (uint8) {\n        return bpsToStrategists;\n    }\n\n    /// *** System Security Checks ***\n\n    /// @notice A function to check whether or not an address is an approved strategist\n    function isApprovedStrategist(address wouldBeStrategist)\n        external\n        view\n        returns (bool)\n    {\n        if (\n            approvedStrategists[wouldBeStrategist] == true ||\n            !permissionedStrategists\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice A function to check whether or not an address is the approved system instance of BathPair.sol\n    function isApprovedPair(address pair) public view returns (bool outcome) {\n        pair == approvedPairContract ? outcome = true : outcome = false;\n    }\n\n    /// *** Internal Functions ***\n\n    /// @dev Low-level functionality to spawn a Bath Token using the OZ Transparent Upgradeable Proxy standard\n    /// @param underlyingERC20 The underlying ERC-20 asset that underlies the newBathTokenAddress\n    /// @param _feeAdmin Recipient of pool withdrawal fees, typically the pool itself\n    function _createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        internal\n        returns (address newBathTokenAddress)\n    {\n        require(initialized, \"BathHouse not initialized\");\n        address _underlyingERC20 = address(underlyingERC20);\n        require(\n            _underlyingERC20 != address(0),\n            \"Cant create bathToken for zero address\"\n        );\n\n        // Check that it isn't already logged in the registry\n        require(\n            tokenToBathToken[_underlyingERC20] == address(0),\n            \"bathToken already exists\"\n        );\n\n        // Creates a new bathToken that is upgradeable by the proxyManager\n        require(\n            newBathTokenImplementation != address(0),\n            \"no implementation set for bathTokens\"\n        );\n\n        // Note, the option of a fee recipient for pool withdrawls exists. For all pools this is set to the pool itself in production and is visible via ~feeTo~ on any respective contract\n        // Note, fee admin presently ignored in the Bath Token initialization() call via defaulting to itself; though, this is still upgradeable by the Bath House admin via\n        bytes memory _initData = abi.encodeWithSignature(\n            \"initialize(address,address,address)\",\n            _underlyingERC20,\n            (RubiconMarketAddress),\n            (_feeAdmin)\n        );\n\n\n            TransparentUpgradeableProxy newBathToken\n         = new TransparentUpgradeableProxy(\n            newBathTokenImplementation,\n            proxyManager,\n            _initData\n        );\n\n        // New Bath Token Address\n        newBathTokenAddress = address(newBathToken);\n\n        // Write to source-of-truth router mapping for this ERC-20 => Bath Token\n        tokenToBathToken[_underlyingERC20] = newBathTokenAddress;\n\n        // Log Data\n        emit LogNewBathToken(\n            _underlyingERC20,\n            newBathTokenAddress,\n            _feeAdmin,\n            block.timestamp,\n            msg.sender\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "RubiconRouter.sol",
            "BathToken.sol",
            "BathHouse.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Rubicon contracts: BathHouse.sol, RubiconRouter.sol, BathToken.sol",
                "Type": "Approval vulnerability",
                "Description": "When creating a pair, the paired asset's approval is not set to 0 before it is updated, causing the function to revert when desiredPairedAsset is USDT. This problem will also manifest in RubiconMarket's approval function and BathToken's approval function.",
                "Repair": "Set the allowance to 0 before setting it to the new value."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            uint256 amountWithdrawn;\n            uint256 _fee = assets.mul(feeBPS).div(10000);\n            amountWithdrawn = assets.sub(_fee);\n            shares = convertToShares(amountWithdrawn);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 _initialTotalSupply = totalSupply;\n\n        // Distribute network rewards first in order to handle bonus token == underlying token case; it only releases vested tokens in this call\n        distributeBonusTokenRewards(receiver, _shares, _initialTotalSupply);\n\n        uint256 r = (underlyingBalance().mul(_shares)).div(_initialTotalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.transfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.transfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern. Fees sit on BathBuddy to act as effectively accrued to the pool.\n    function distributeBonusTokenRewards(\n        address receiver,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply\n    ) internal {\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                // Note: Shares already burned in Bath Token _withdraw\n\n                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n                //  are released their relative share of this pool, of vested BathBuddy rewards\n                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n                if (rewardsVestingWallet != IBathBuddy(0)) {\n                    rewardsVestingWallet.release(\n                        (token),\n                        receiver,\n                        sharesWithdrawn,\n                        initialTotalSupply,\n                        feeBPS\n                    );\n                }\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}\n\n\n/// SPDX-License-Identifier: Apache-2.0\n/// This contract is a derivative work of the open-source work of Oasis DEX: https://github.com/OasisDEX/oasis\n\n/// @title RubiconMarket.sol\n/// @notice Please see the repository for this code at https://github.com/RubiconDeFi/rubicon-protocol-v1;\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice DSAuth events for authentication schema\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n/// @notice DSAuth library for setting owner of the contract\n/// @dev Provides the auth modifier for authenticated function calls\ncontract DSAuth is DSAuthEvents {\n    address public owner;\n\n    function setOwner(address owner_) external auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    modifier auth() {\n        require(isAuthorized(msg.sender), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n/// @notice DSMath library for safe math without integer overflow/underflow\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n}\n\n// /// @notice ERC-20 interface as derived from EIP-20\n// contract ERC20 {\n//     function totalSupply() public view returns (uint256);\n\n//     function balanceOf(address guy) public view returns (uint256);\n\n//     function allowance(address src, address guy) public view returns (uint256);\n\n//     function approve(address guy, uint256 wad) public returns (bool);\n\n//     function transfer(address dst, uint256 wad) public returns (bool);\n\n//     function transferFrom(\n//         address src,\n//         address dst,\n//         uint256 wad\n//     ) public returns (bool);\n// }\n\n/// @notice Events contract for logging trade activity on Rubicon Market\n/// @dev Provides the key event logs that are used in all core functionality of exchanging on the Rubicon Market\ncontract EventfulMarket {\n    event LogItemUpdate(uint256 id);\n    event LogTrade(\n        uint256 pay_amt,\n        address indexed pay_gem,\n        uint256 buy_amt,\n        address indexed buy_gem\n    );\n\n    event LogMake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogBump(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogTake(\n        bytes32 id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        address indexed taker,\n        uint128 take_amt,\n        uint128 give_amt,\n        uint64 timestamp\n    );\n\n    event LogKill(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogInt(string lol, uint256 input);\n\n    event FeeTake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        ERC20 asset,\n        address indexed taker,\n        address feeTo,\n        uint256 feeAmt,\n        uint64 timestamp\n    );\n\n    event OfferDeleted(uint256 id);\n}\n\n/// @notice Core trading logic for ERC-20 pairs, an orderbook, and transacting of tokens\n/// @dev This contract holds the core ERC-20 / ERC-20 offer, buy, and cancel logic\ncontract SimpleMarket is EventfulMarket, DSMath {\n    uint256 public last_offer_id;\n\n    /// @dev The mapping that makes up the core orderbook of the exchange\n    mapping(uint256 => OfferInfo) public offers;\n\n    bool locked;\n\n    /// @dev This parameter is in basis points\n    uint256 internal feeBPS;\n\n    /// @dev This parameter provides the address to which fees are sent\n    address internal feeTo;\n\n    struct OfferInfo {\n        uint256 pay_amt;\n        ERC20 pay_gem;\n        uint256 buy_amt;\n        ERC20 buy_gem;\n        address owner;\n        uint64 timestamp;\n    }\n\n    /// @notice Modifier that insures an order exists and is properly in the orderbook\n    modifier can_buy(uint256 id) virtual {\n        require(isActive(id));\n        _;\n    }\n\n    /// @notice Modifier that checks the user to make sure they own the offer and its valid before they attempt to cancel it\n    modifier can_cancel(uint256 id) virtual {\n        require(isActive(id));\n        require(getOwner(id) == msg.sender);\n        _;\n    }\n\n    modifier can_offer() virtual {\n        _;\n    }\n\n    modifier synchronized() {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function isActive(uint256 id) public view returns (bool active) {\n        return offers[id].timestamp > 0;\n    }\n\n    function getOwner(uint256 id) public view returns (address owner) {\n        return offers[id].owner;\n    }\n\n    function getOffer(uint256 id)\n        public\n        view\n        returns (\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        OfferInfo memory _offer = offers[id];\n        return (_offer.pay_amt, _offer.pay_gem, _offer.buy_amt, _offer.buy_gem);\n    }\n\n    /// @notice Below are the main public entrypoints\n\n    function bump(bytes32 id_) external can_buy(uint256(id_)) {\n        uint256 id = uint256(id_);\n        emit LogBump(\n            id_,\n            keccak256(abi.encodePacked(offers[id].pay_gem, offers[id].buy_gem)),\n            offers[id].owner,\n            offers[id].pay_gem,\n            offers[id].buy_gem,\n            uint128(offers[id].pay_amt),\n            uint128(offers[id].buy_amt),\n            offers[id].timestamp\n        );\n    }\n\n    /// @notice Accept a given `quantity` of an offer. Transfers funds from caller/taker to offer maker, and from market to caller/taker.\n    /// @notice The fee for taker trades is paid in this function.\n    function buy(uint256 id, uint256 quantity)\n        public\n        virtual\n        can_buy(id)\n        synchronized\n        returns (bool)\n    {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        // Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 10000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend),\n            \"_offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend) failed - check that you can pay the fee\"\n        );\n        require(\n            _offer.pay_gem.transfer(msg.sender, quantity),\n            \"_offer.pay_gem.transfer(msg.sender, quantity) failed\"\n        );\n\n        emit LogItemUpdate(id);\n        emit LogTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            msg.sender,\n            uint128(quantity),\n            uint128(spend),\n            uint64(block.timestamp)\n        );\n        emit FeeTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.buy_gem,\n            msg.sender,\n            feeTo,\n            fee,\n            uint64(block.timestamp)\n        );\n        emit LogTrade(\n            quantity,\n            address(_offer.pay_gem),\n            spend,\n            address(_offer.buy_gem)\n        );\n\n        if (offers[id].pay_amt == 0) {\n            delete offers[id];\n            emit OfferDeleted(id);\n        }\n\n        return true;\n    }\n\n    /// @notice Allows the caller to cancel the offer if it is their own.\n    /// @notice This function refunds the offer to the maker.\n    function cancel(uint256 id)\n        public\n        virtual\n        can_cancel(id)\n        synchronized\n        returns (bool success)\n    {\n        OfferInfo memory _offer = offers[id];\n        delete offers[id];\n\n        require(_offer.pay_gem.transfer(_offer.owner, _offer.pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogKill(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            uint128(_offer.pay_amt),\n            uint128(_offer.buy_amt),\n            uint64(block.timestamp)\n        );\n\n        success = true;\n    }\n\n    function kill(bytes32 id) external virtual {\n        require(cancel(uint256(id)));\n    }\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) external virtual returns (bytes32 id) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    /// @notice Key function to make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) public virtual can_offer synchronized returns (uint256 id) {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(0x0));\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(0x0));\n        require(pay_gem != buy_gem);\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.owner = msg.sender;\n        info.timestamp = uint64(block.timestamp);\n        id = _next_id();\n        offers[id] = info;\n\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogMake(\n            bytes32(id),\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt),\n            uint64(block.timestamp)\n        );\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) external virtual {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function _next_id() internal returns (uint256) {\n        last_offer_id++;\n        return last_offer_id;\n    }\n\n    // Fee logic\n    function getFeeBPS() internal view returns (uint256) {\n        return feeBPS;\n    }\n}\n\n/// @notice Expiring market is a Simple Market with a market lifetime.\n/// @dev When the close_time has been reached, offers can only be cancelled (offer and buy will throw).\ncontract ExpiringMarket is DSAuth, SimpleMarket {\n    bool public stopped;\n\n    /// @dev After close_time has been reached, no new offers are allowed.\n    modifier can_offer() override {\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, no new buys are allowed.\n    modifier can_buy(uint256 id) override {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, anyone can cancel an offer.\n    modifier can_cancel(uint256 id) virtual override {\n        require(isActive(id));\n        require((msg.sender == getOwner(id)) || isClosed());\n        _;\n    }\n\n    function isClosed() public pure returns (bool closed) {\n        return false;\n    }\n\n    function getTime() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    function stop() external auth {\n        stopped = true;\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note() {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\ncontract MatchingEvents {\n    event LogBuyEnabled(bool isEnabled);\n    event LogMinSell(address pay_gem, uint256 min_amount);\n    event LogMatchingEnabled(bool isEnabled);\n    event LogUnsortedOffer(uint256 id);\n    event LogSortedOffer(uint256 id);\n    event LogInsert(address keeper, uint256 id);\n    event LogDelete(address keeper, uint256 id);\n    event LogMatch(uint256 id, uint256 amount);\n}\n\n/// @notice The core Rubicon Market smart contract\n/// @notice This contract is based on the original open-source work done by OasisDEX under the Apache License 2.0\n/// @dev This contract inherits the key trading functionality from SimpleMarket\ncontract RubiconMarket is MatchingEvents, ExpiringMarket, DSNote {\n    bool public buyEnabled = true; //buy enabled\n    bool public matchingEnabled = true; //true: enable matching,\n    //false: revert to expiring market\n    /// @dev Below is variable to allow for a proxy-friendly constructor\n    bool public initialized;\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    bool public AqueductDistributionLive;\n    /// @dev unused deprecated variable for applying a token distribution of this token on top of a trade\n    address public AqueductAddress;\n\n    struct sortInfo {\n        uint256 next; //points to id of next higher offer\n        uint256 prev; //points to id of previous lower offer\n        uint256 delb; //the blocknumber where this entry was marked for delete\n    }\n    mapping(uint256 => sortInfo) public _rank; //doubly linked lists of sorted offer ids\n    mapping(address => mapping(address => uint256)) public _best; //id of the highest offer for a token pair\n    mapping(address => mapping(address => uint256)) public _span; //number of offers stored for token pair in sorted orderbook\n    mapping(address => uint256) public _dust; //minimum sell amount for a token to avoid dust offers\n    mapping(uint256 => uint256) public _near; //next unsorted offer id\n    uint256 public _head; //first unsorted offer id\n    uint256 public dustId; // id of the latest offer marked as dust\n\n    /// @dev Proxy-safe initialization of storage\n    function initialize(bool _live, address _feeTo) public {\n        require(!initialized, \"contract is already initialized\");\n        AqueductDistributionLive = _live;\n\n        /// @notice The market fee recipient\n        feeTo = _feeTo;\n\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n\n        /// @notice The starting fee on taker trades in basis points\n        feeBPS = 20;\n\n        initialized = true;\n        matchingEnabled = true;\n        buyEnabled = true;\n    }\n\n    // After close, anyone can cancel an offer\n    modifier can_cancel(uint256 id) override {\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\n        require(\n            isClosed() || msg.sender == getOwner(id) || id == dustId,\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\n        );\n        _;\n    }\n\n    // ---- Public entrypoints ---- //\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) public override returns (bytes32) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) public override {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function kill(bytes32 id) external override {\n        require(cancel(uint256(id)));\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    //\n    // If matching is enabled:\n    //     * creates new offer without putting it in\n    //       the sorted list.\n    //     * available to authorized contracts only!\n    //     * keepers should call insert(id,pos)\n    //       to put offer in the sorted list.\n    //\n    // If matching is disabled:\n    //     * calls expiring market's offer().\n    //     * available to everyone without authorization.\n    //     * no sorting is done.\n    //\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //taker (ask) buy how much\n        ERC20 buy_gem //taker (ask) buy which token\n    ) public override returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n\n\n            function(uint256, ERC20, uint256, ERC20) returns (uint256) fn\n         = matchingEnabled ? _offeru : super.offer;\n        return fn(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external can_offer returns (uint256) {\n        return offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, true);\n    }\n\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos, //position to insert offer, 0 should be used if unknown\n        bool matching //match \"close enough\" orders?\n    ) public can_offer returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n        require(_dust[address(pay_gem)] <= pay_amt);\n\n        if (matchingEnabled) {\n            return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, matching);\n        }\n        return super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    //Transfers funds from caller to offer maker, and from market to caller.\n    function buy(uint256 id, uint256 amount)\n        public\n        override\n        can_buy(id)\n        returns (bool)\n    {\n        require(!locked, \"Reentrancy attempt\");\n\n        //Optional distribution on trade\n        if (AqueductDistributionLive) {\n            IAqueduct(AqueductAddress).distributeToMakerAndTaker(\n                getOwner(id),\n                msg.sender\n            );\n        }\n        function(uint256, uint256) returns (bool) fn = matchingEnabled\n            ? _buys\n            : super.buy;\n\n        return fn(id, amount);\n    }\n\n    // Cancel an offer. Refunds offer maker.\n    function cancel(uint256 id)\n        public\n        override\n        can_cancel(id)\n        returns (bool success)\n    {\n        require(!locked, \"Reentrancy attempt\");\n        if (matchingEnabled) {\n            if (isOfferSorted(id)) {\n                require(_unsort(id));\n            } else {\n                require(_hide(id));\n            }\n        }\n        return super.cancel(id); //delete the offer.\n    }\n\n    //insert offer into the sorted list\n    //keepers need to use this function\n    function insert(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) public returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(!isOfferSorted(id)); //make sure offers[id] is not yet sorted\n        require(isActive(id)); //make sure offers[id] is active\n\n        _hide(id); //remove offer from unsorted offers list\n        _sort(id, pos); //put offer into the sorted offers list\n        emit LogInsert(msg.sender, id);\n        return true;\n    }\n\n    //deletes _rank [id]\n    //  Function should be called by keepers.\n    function del_rank(uint256 id) external returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(\n            !isActive(id) &&\n                _rank[id].delb != 0 &&\n                _rank[id].delb < block.number - 10\n        );\n        delete _rank[id];\n        emit LogDelete(msg.sender, id);\n        return true;\n    }\n\n    //set the minimum sell amount for a token\n    //    Function is used to avoid \"dust offers\" that have\n    //    very small amount of tokens to sell, and it would\n    //    cost more gas to accept the offer, than the value\n    //    of tokens received.\n    function setMinSell(\n        ERC20 pay_gem, //token to assign minimum sell amount to\n        uint256 dust //maker (ask) minimum sell amount\n    ) external auth note returns (bool) {\n        _dust[address(pay_gem)] = dust;\n        emit LogMinSell(address(pay_gem), dust);\n        return true;\n    }\n\n    //returns the minimum sell amount for an offer\n    function getMinSell(\n        ERC20 pay_gem //token for which minimum sell amount is queried\n    ) external view returns (uint256) {\n        return _dust[address(pay_gem)];\n    }\n\n    //set buy functionality enabled/disabled\n    function setBuyEnabled(bool buyEnabled_) external auth returns (bool) {\n        buyEnabled = buyEnabled_;\n        emit LogBuyEnabled(buyEnabled);\n        return true;\n    }\n\n    //set matching enabled/disabled\n    //    If matchingEnabled true(default), then inserted offers are matched.\n    //    Except the ones inserted by contracts, because those end up\n    //    in the unsorted list of offers, that must be later sorted by\n    //    keepers using insert().\n    //    If matchingEnabled is false then RubiconMarket is reverted to ExpiringMarket,\n    //    and matching is not done, and sorted lists are disabled.\n    function setMatchingEnabled(bool matchingEnabled_)\n        external\n        auth\n        returns (bool)\n    {\n        matchingEnabled = matchingEnabled_;\n        emit LogMatchingEnabled(matchingEnabled);\n        return true;\n    }\n\n    //return the best offer for a token pair\n    //      the best offer is the lowest one if it's an ask,\n    //      and highest one if it's a bid offer\n    function getBestOffer(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _best[address(sell_gem)][address(buy_gem)];\n    }\n\n    //return the next worse offer in the sorted list\n    //      the worse offer is the higher one if its an ask,\n    //      a lower one if its a bid offer,\n    //      and in both cases the newer one if they're equal.\n    function getWorseOffer(uint256 id) public view returns (uint256) {\n        return _rank[id].prev;\n    }\n\n    //return the next better offer in the sorted list\n    //      the better offer is in the lower priced one if its an ask,\n    //      the next higher priced one if its a bid offer\n    //      and in both cases the older one if they're equal.\n    function getBetterOffer(uint256 id) external view returns (uint256) {\n        return _rank[id].next;\n    }\n\n    //return the amount of better offers for a token pair\n    function getOfferCount(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _span[address(sell_gem)][address(buy_gem)];\n    }\n\n    //get the first unsorted offer that was inserted by a contract\n    //      Contracts can't calculate the insertion position of their offer because it is not an O(1) operation.\n    //      Their offers get put in the unsorted list of offers.\n    //      Keepers can calculate the insertion position offchain and pass it to the insert() function to insert\n    //      the unsorted offer into the sorted list. Unsorted offers will not be matched, but can be bought with buy().\n    function getFirstUnsortedOffer() public view returns (uint256) {\n        return _head;\n    }\n\n    //get the next unsorted offer\n    //      Can be used to cycle through all the unsorted offers.\n    function getNextUnsortedOffer(uint256 id) public view returns (uint256) {\n        return _near[id];\n    }\n\n    function isOfferSorted(uint256 id) public view returns (bool) {\n        return\n            _rank[id].next != 0 ||\n            _rank[id].prev != 0 ||\n            _best[address(offers[id].pay_gem)][address(offers[id].buy_gem)] ==\n            id;\n    }\n\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                pay_amt * 1 ether <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    pay_amt * 10**9,\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10**9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount);\n    }\n\n    function buyAllAmount(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0);\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (\n                buy_amt * 1 ether <\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {\n                //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                //if lower\n                fill_amt = add(\n                    fill_amt,\n                    rmul(\n                        buy_amt * 10**9,\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n                    ) / 10**9\n                ); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\n                buy_amt = 0; //All amount is bought\n            }\n        }\n        require(fill_amt <= max_fill_amount);\n    }\n\n    function getBuyAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 pay_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (pay_amt > offers[offerId].buy_amt) {\n            fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount to buy accumulator\n            pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to pay\n            if (pay_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                pay_amt * 10**9,\n                rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to buy accumulator\n    }\n\n    function getPayAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 buy_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (buy_amt > offers[offerId].pay_amt) {\n            fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount to pay accumulator\n            buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n            if (buy_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                buy_amt * 10**9,\n                rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to pay accumulator\n    }\n\n    // ---- Internal Functions ---- //\n\n    function _buys(uint256 id, uint256 amount) internal returns (bool) {\n        require(buyEnabled);\n        if (amount == offers[id].pay_amt) {\n            if (isOfferSorted(id)) {\n                //offers[id] must be removed from sorted list because all of it is bought\n                _unsort(id);\n            } else {\n                _hide(id);\n            }\n        }\n\n        require(super.buy(id, amount));\n\n        // If offer has become dust during buy, we cancel it\n        if (\n            isActive(id) &&\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\n        ) {\n            dustId = id; //enable current msg.sender to call cancel(id)\n            cancel(id);\n        }\n        return true;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _find(uint256 id) internal view returns (uint256) {\n        require(id > 0);\n\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        uint256 top = _best[pay_gem][buy_gem];\n        uint256 old_top = 0;\n\n        // Find the larger-than-id order whose successor is less-than-id.\n        while (top != 0 && _isPricedLtOrEq(id, top)) {\n            old_top = top;\n            top = _rank[top].prev;\n        }\n        return old_top;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _findpos(uint256 id, uint256 pos) internal view returns (uint256) {\n        require(id > 0);\n\n        // Look for an active order.\n        while (pos != 0 && !isActive(pos)) {\n            pos = _rank[pos].prev;\n        }\n\n        if (pos == 0) {\n            //if we got to the end of list without a single active offer\n            return _find(id);\n        } else {\n            // if we did find a nearby active offer\n            // Walk the order book down from there...\n            if (_isPricedLtOrEq(id, pos)) {\n                uint256 old_pos;\n\n                // Guaranteed to run at least once because of\n                // the prior if statements.\n                while (pos != 0 && _isPricedLtOrEq(id, pos)) {\n                    old_pos = pos;\n                    pos = _rank[pos].prev;\n                }\n                return old_pos;\n\n                // ...or walk it up.\n            } else {\n                while (pos != 0 && !_isPricedLtOrEq(id, pos)) {\n                    pos = _rank[pos].next;\n                }\n                return pos;\n            }\n        }\n    }\n\n    //return true if offers[low] priced less than or equal to offers[high]\n    function _isPricedLtOrEq(\n        uint256 low, //lower priced offer's id\n        uint256 high //higher priced offer's id\n    ) internal view returns (bool) {\n        return\n            mul(offers[low].buy_amt, offers[high].pay_amt) >=\n            mul(offers[high].buy_amt, offers[low].pay_amt);\n    }\n\n    //these variables are global only because of solidity local variable limit\n\n    //match offers with taker offer, and execute token transactions\n    function _matcho(\n        uint256 t_pay_amt, //taker sell how much\n        ERC20 t_pay_gem, //taker sell which token\n        uint256 t_buy_amt, //taker buy how much\n        ERC20 t_buy_gem, //taker buy which token\n        uint256 pos, //position id\n        bool rounding //match \"close enough\" orders?\n    ) internal returns (uint256 id) {\n        uint256 best_maker_id; //highest maker id\n        uint256 t_buy_amt_old; //taker buy how much saved\n        uint256 m_buy_amt; //maker offer wants to buy this much token\n        uint256 m_pay_amt; //maker offer wants to sell this much token\n\n        // there is at least one offer stored for token pair\n        while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\n            best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\n            m_buy_amt = offers[best_maker_id].buy_amt;\n            m_pay_amt = offers[best_maker_id].pay_amt;\n\n            // Ugly hack to work around rounding errors. Based on the idea that\n            // the furthest the amounts can stray from their \"true\" values is 1.\n            // Ergo the worst case has t_pay_amt and m_pay_amt at +1 away from\n            // their \"correct\" values and m_buy_amt and t_buy_amt at -1.\n            // Since (c - 1) * (d - 1) > (a + 1) * (b + 1) is equivalent to\n            // c * d > a * b + a + b + c + d, we write...\n            if (\n                mul(m_buy_amt, t_buy_amt) >\n                mul(t_pay_amt, m_pay_amt) +\n                    (\n                        rounding\n                            ? m_buy_amt + t_buy_amt + t_pay_amt + m_pay_amt\n                            : 0\n                    )\n            ) {\n                break;\n            }\n            // ^ The `rounding` parameter is a compromise borne of a couple days\n            // of discussion.\n            buy(best_maker_id, min(m_pay_amt, t_buy_amt));\n            emit LogMatch(id, min(m_pay_amt, t_buy_amt));\n            t_buy_amt_old = t_buy_amt;\n            t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\n            t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\n\n            if (t_pay_amt == 0 || t_buy_amt == 0) {\n                break;\n            }\n        }\n\n        if (\n            t_buy_amt > 0 &&\n            t_pay_amt > 0 &&\n            t_pay_amt >= _dust[address(t_pay_gem)]\n        ) {\n            //new offer should be created\n            id = super.offer(t_pay_amt, t_pay_gem, t_buy_amt, t_buy_gem);\n            //insert offer into the sorted list\n            _sort(id, pos);\n        }\n    }\n\n    // Make a new offer without putting it in the sorted list.\n    // Takes funds from the caller into market escrow.\n    // Keepers should call insert(id,pos) to put offer in the sorted list.\n    function _offeru(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem //maker (ask) buy which token\n    ) internal returns (uint256 id) {\n        require(_dust[address(pay_gem)] <= pay_amt);\n        id = super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n        _near[id] = _head;\n        _head = id;\n        emit LogUnsortedOffer(id);\n    }\n\n    //put offer into the sorted list\n    function _sort(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) internal {\n        require(isActive(id));\n\n        ERC20 buy_gem = offers[id].buy_gem;\n        ERC20 pay_gem = offers[id].pay_gem;\n        uint256 prev_id; //maker (ask) id\n\n        pos = pos == 0 ||\n            offers[pos].pay_gem != pay_gem ||\n            offers[pos].buy_gem != buy_gem ||\n            !isOfferSorted(pos)\n            ? _find(id)\n            : _findpos(id, pos);\n\n        if (pos != 0) {\n            //offers[id] is not the highest offer\n            //requirement below is satisfied by statements above\n            //require(_isPricedLtOrEq(id, pos));\n            prev_id = _rank[pos].prev;\n            _rank[pos].prev = id;\n            _rank[id].next = pos;\n        } else {\n            //offers[id] is the highest offer\n            prev_id = _best[address(pay_gem)][address(buy_gem)];\n            _best[address(pay_gem)][address(buy_gem)] = id;\n        }\n\n        if (prev_id != 0) {\n            //if lower offer does exist\n            //requirement below is satisfied by statements above\n            //require(!_isPricedLtOrEq(id, prev_id));\n            _rank[prev_id].next = id;\n            _rank[id].prev = prev_id;\n        }\n\n        _span[address(pay_gem)][address(buy_gem)]++;\n        emit LogSortedOffer(id);\n    }\n\n    // Remove offer from the sorted list (does not cancel offer)\n    function _unsort(\n        uint256 id //id of maker (ask) offer to remove from sorted list\n    ) internal returns (bool) {\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        require(_span[pay_gem][buy_gem] > 0);\n\n        require(\n            _rank[id].delb == 0 && //assert id is in the sorted list\n                isOfferSorted(id)\n        );\n\n        if (id != _best[pay_gem][buy_gem]) {\n            // offers[id] is not the highest offer\n            require(_rank[_rank[id].next].prev == id);\n            _rank[_rank[id].next].prev = _rank[id].prev;\n        } else {\n            //offers[id] is the highest offer\n            _best[pay_gem][buy_gem] = _rank[id].prev;\n        }\n\n        if (_rank[id].prev != 0) {\n            //offers[id] is not the lowest offer\n            require(_rank[_rank[id].prev].next == id);\n            _rank[_rank[id].prev].next = _rank[id].next;\n        }\n\n        _span[pay_gem][buy_gem]--;\n        _rank[id].delb = block.number; //mark _rank[id] for deletion\n        return true;\n    }\n\n    //Hide offer from the unsorted order book (does not cancel offer)\n    function _hide(\n        uint256 id //id of maker offer to remove from unsorted list\n    ) internal returns (bool) {\n        uint256 uid = _head; //id of an offer in unsorted offers list\n        uint256 pre = uid; //id of previous offer in unsorted offers list\n\n        require(!isOfferSorted(id)); //make sure offer id is not in sorted offers list\n\n        if (_head == id) {\n            //check if offer is first offer in unsorted offers list\n            _head = _near[id]; //set head to new first unsorted offer\n            _near[id] = 0; //delete order from unsorted order list\n            return true;\n        }\n        while (uid > 0 && uid != id) {\n            //find offer in unsorted order list\n            pre = uid;\n            uid = _near[uid];\n        }\n        if (uid != id) {\n            //did not find offer id in unsorted offers list\n            return false;\n        }\n        _near[pre] = _near[id]; //set previous unsorted offer to point to offer after offer id\n        _near[id] = 0; //delete order from unsorted order list\n        return true;\n    }\n\n    function setFeeBPS(uint256 _newFeeBPS) external auth returns (bool) {\n        feeBPS = _newFeeBPS;\n        return true;\n    }\n\n    /// @dev unused deprecated function for applying a token distribution on top of a trade\n    function setAqueductDistributionLive(bool live)\n        external\n        auth\n        returns (bool)\n    {\n        AqueductDistributionLive = live;\n        return true;\n    }\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    function setAqueductAddress(address _Aqueduct)\n        external\n        auth\n        returns (bool)\n    {\n        AqueductAddress = _Aqueduct;\n        return true;\n    }\n\n    function setFeeTo(address newFeeTo) external auth returns (bool) {\n        feeTo = newFeeTo;\n        return true;\n    }\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n}\n\ninterface IAqueduct {\n    function distributeToMakerAndTaker(address maker, address taker)\n        external\n        returns (bool);\n}\n\n\n",
        "CodeNames": [
            "BathToken.sol",
            "RubiconMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BathToken.sol and RubiconMarket.sol",
                "Type": "No Cap on Fees",
                "Description": "The owner can set an arbitrary fee. If they set it to a value above 100%, withdrawing BathTokens won't be possible anymore because of an underflow.",
                "Repair": "Add a limit to the constructors where a fee is set and to all the configuration functions for fees."
            }
        ]
    }
]