[
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport \"./TestUtil.sol\";\n\ncontract VaultFactoryTest is TestUtil {\n    uint256 seed_1;\n    uint256 seed_2;\n    uint256 seed_3;\n    address predicted_1;\n    address predicted_2;\n    address actual_1;\n    address actual_2;\n\n    function setUp() public {\n        setUpContract();\n    }\n\n    function checkNextCreate2Helper(address who)\n        public\n        view\n        returns (uint256, address)\n    {\n        bytes32 seed = IVaultFactory(factory).getNextSeed(who);\n        return (uint256(seed), IVaultFactory(factory).getNextAddress(who));\n    }\n\n    function testDeploy() public {\n        factory = registry.factory();\n        (seed_1, predicted_1) = checkNextCreate2Helper(tx.origin);\n        actual_1 = IVaultFactory(factory).deploy();\n        (seed_2, ) = checkNextCreate2Helper(tx.origin);\n        assertEq(seed_2, seed_1 + 1);\n        assertEq(predicted_1, actual_1);\n    }\n\n    function testDeploy(address who) public {\n        factory = registry.factory();\n        (seed_1, predicted_1) = checkNextCreate2Helper(who);\n        vm.startPrank(who, who);\n        actual_1 = IVaultFactory(factory).deploy();\n        vm.stopPrank();\n        (seed_2, predicted_2) = checkNextCreate2Helper(who);\n        vm.startPrank(who, who);\n        actual_2 = IVaultFactory(factory).deploy();\n        vm.stopPrank();\n\n        (seed_3, ) = checkNextCreate2Helper(who);\n        assertEq(seed_2, seed_1 + 1);\n        assertEq(predicted_1, actual_1);\n        assertEq(seed_3, seed_2 + 1);\n        assertEq(predicted_2, actual_2);\n    }\n\n    function testDeployFor(address who) public {\n        factory = registry.factory();\n        (seed_1, predicted_1) = checkNextCreate2Helper(who);\n        vm.startPrank(who, who);\n        actual_1 = IVaultFactory(factory).deployFor(address(this));\n        vm.stopPrank();\n        (seed_2, predicted_2) = checkNextCreate2Helper(who);\n        vm.startPrank(who, who);\n        actual_2 = IVaultFactory(factory).deployFor(address(this));\n        vm.stopPrank();\n\n        (seed_3, ) = checkNextCreate2Helper(who);\n        assertEq(seed_2, seed_1 + 1);\n        assertEq(predicted_1, actual_1);\n        assertEq(seed_3, seed_2 + 1);\n        assertEq(predicted_2, actual_2);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Create2ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/Create2ClonesWithImmutableArgs.sol\";\nimport {IVaultFactory} from \"./interfaces/IVaultFactory.sol\";\nimport {Vault} from \"./Vault.sol\";\n\n/// @title Vault Factory\n/// @author Fractional Art\n/// @notice Factory contract for deploying fractional vaults\ncontract VaultFactory is IVaultFactory {\n    /// @dev Use clones library for address types\n    using Create2ClonesWithImmutableArgs for address;\n    /// @notice Address of Vault proxy contract\n    address public implementation;\n    /// @dev Internal mapping to track the next seed to be used by an EOA\n    mapping(address => bytes32) internal nextSeeds;\n\n    /// @notice Initializes implementation contract\n    constructor() {\n        implementation = address(new Vault());\n    }\n\n    /// @notice Deploys new vault for sender\n    /// @return vault Address of deployed vault\n    function deploy() external returns (address payable vault) {\n        vault = deployFor(msg.sender);\n    }\n\n    /// @notice Gets pre-computed address of vault deployed by given account\n    /// @param _deployer Address of vault deployer\n    /// @return vault Address of next vault\n    function getNextAddress(address _deployer)\n        external\n        view\n        returns (address vault)\n    {\n        bytes32 salt = keccak256(abi.encode(_deployer, nextSeeds[_deployer]));\n        (uint256 creationPtr, uint256 creationSize) = implementation\n            .cloneCreationCode(abi.encodePacked());\n\n        bytes32 creationHash;\n        assembly {\n            creationHash := keccak256(creationPtr, creationSize)\n        }\n        bytes32 data = keccak256(\n            abi.encodePacked(bytes1(0xff), address(this), salt, creationHash)\n        );\n        vault = address(uint160(uint256(data)));\n    }\n\n    /// @notice Gets next seed value of given account\n    /// @param _deployer Address of vault deployer\n    /// @return Value of next seed\n    function getNextSeed(address _deployer) external view returns (bytes32) {\n        return nextSeeds[_deployer];\n    }\n\n    /// @notice Deploys new vault for given address\n    /// @param _owner Address of vault owner\n    /// @return vault Address of deployed vault\n    function deployFor(address _owner) public returns (address payable vault) {\n        bytes32 seed = nextSeeds[tx.origin];\n\n        // Prevent front-running the salt by hashing the concatenation of tx.origin and the user-provided seed.\n        bytes32 salt = keccak256(abi.encode(tx.origin, seed));\n\n        bytes memory data = abi.encodePacked();\n        vault = implementation.clone(salt, data);\n        Vault(vault).init();\n\n        // Transfer the ownership from this factory contract to the specified owner.\n        Vault(vault).transferOwnership(_owner);\n\n        // Increment the seed.\n        unchecked {\n            nextSeeds[tx.origin] = bytes32(uint256(seed) + 1);\n        }\n\n        // Log the vault via en event.\n        emit DeployVault(\n            tx.origin,\n            msg.sender,\n            _owner,\n            seed,\n            salt,\n            address(vault)\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "VaultFactory.t.sol",
            "VaultFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaultFactory.sol",
                "Type": "Uninitialized Proxy",
                "Description": "The implementation vault is not initialized, which means that anybody can initialize the contract to become the owner, and then destroy it by doing a delegate call (via the execute function) to a function with the selfdestruct opcode. Once the implementation is destroyed all of the vaults will be unusable. This is a critical bug, since ALL assets held by ALL vaults will be lost.",
                "Repair": "Add init in Vault's constructor (and make the init function public instead of external) or add init in VaultFactory.sol constructor"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport \"./TestUtil.sol\";\n\ncontract MigrationTest is TestUtil {\n    /// =================\n    /// ===== SETUP =====\n    /// =================\n    function setUp() public {\n        setUpContract();\n        alice = setUpUser(111, 1);\n        bob = setUpUser(222, 2);\n\n        vm.label(address(this), \"MigrateTest\");\n        vm.label(alice.addr, \"Alice\");\n        vm.label(bob.addr, \"Bob\");\n    }\n\n    function testProposal() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        //Migrate to a vault with no permissions (just to test out migration)\n        address[] memory modules = new address[](1);\n        modules[0] = address(mockModule);\n        bob.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n    }\n\n    function testProposalNotVault() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        //Migrate to a vault with no permissions (just to test out migration)\n        address[] memory modules = new address[](1);\n        modules[0] = address(mockModule);\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.NotVault.selector, address(0))\n        );\n        bob.migrationModule.propose(\n            address(0),\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n    }\n\n    function testJoin() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory modules = new address[](1);\n        modules[0] = address(mockModule);\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 0.5 ether}(vault, 1, HALF_SUPPLY);\n    }\n\n    function testJoinNotVault() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory modules = new address[](1);\n        modules[0] = address(mockModule);\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.NotVault.selector, address(0))\n        );\n        bob.migrationModule.join{value: 0.5 ether}(address(0), 1, HALF_SUPPLY);\n    }\n\n    function testLeave() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory modules = new address[](1);\n        modules[0] = address(mockModule);\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 0.5 ether}(vault, 1, HALF_SUPPLY);\n        // Bob leaves the proposal\n        bob.migrationModule.leave(vault, 1);\n    }\n\n    function testLeaveNotVault() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory modules = new address[](1);\n        modules[0] = address(mockModule);\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 0.5 ether}(vault, 1, HALF_SUPPLY);\n        // Bob leaves the proposal\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.NotVault.selector, address(0))\n        );\n        bob.migrationModule.leave(address(0), 1);\n    }\n\n    function testCommit() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory modules = new address[](1);\n        modules[0] = address(mockModule);\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);\n\n        vm.warp(proposalPeriod + 1);\n        // bob calls commit to kickoff the buyout process\n        bool started = bob.migrationModule.commit(vault, 1);\n        assertTrue(started);\n    }\n\n    function testCommitNotVault() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory modules = new address[](1);\n        modules[0] = address(mockModule);\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);\n\n        vm.warp(proposalPeriod + 1);\n        // bob calls commit to kickoff the buyout process\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.NotVault.selector, address(0))\n        );\n        bob.migrationModule.commit(address(0), 1);\n    }\n\n    function testCommitProposalOver() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory modules = new address[](1);\n        modules[0] = address(mockModule);\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            modules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);\n\n        vm.warp(proposalPeriod * 10);\n        // bob calls commit to kickoff the buyout process\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.ProposalOver.selector)\n        );\n        bob.migrationModule.commit(vault, 1);\n    }\n\n    function testSettle() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory newModules = new address[](2);\n\n        newModules[0] = migration;\n        newModules[1] = modules[1];\n\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            newModules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);\n        // Alice joins the proposal\n        alice.migrationModule.join{value: 1 ether}(vault, 1, 1000);\n\n        vm.warp(proposalPeriod + 1);\n        // bob calls commit to kickoff the buyout process\n        bool started = bob.migrationModule.commit(vault, 1);\n        assertTrue(started);\n\n        vm.warp(proposalPeriod + rejectionPeriod + 2);\n        bob.buyoutModule.end(vault, burnProof);\n\n        bob.migrationModule.settleVault(vault, 1);\n        bob.migrationModule.settleFractions(vault, 1, mintProof);\n    }\n\n    function testSettleVaultUnsuccessfulMigration() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory newModules = new address[](2);\n\n        newModules[0] = migration;\n        newModules[1] = modules[1];\n\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            newModules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 1 ether}(vault, 1, 1000);\n\n        vm.warp(proposalPeriod + 1);\n        // bob calls commit to kickoff the buyout process\n        bool started = bob.migrationModule.commit(vault, 1);\n        assertTrue(started);\n\n        vm.warp(proposalPeriod + rejectionPeriod + 2);\n        bob.buyoutModule.end(vault, burnProof);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.UnsuccessfulMigration.selector)\n        );\n        bob.migrationModule.settleVault(vault, 1);\n    }\n\n    function testSettleVaultNewVaultAlreadyDeployed() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory newModules = new address[](2);\n\n        newModules[0] = migration;\n        newModules[1] = modules[1];\n\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            newModules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);\n        // Alice joins the proposal\n        alice.migrationModule.join{value: 1 ether}(vault, 1, 1000);\n\n        vm.warp(proposalPeriod + 1);\n        // bob calls commit to kickoff the buyout process\n        bool started = bob.migrationModule.commit(vault, 1);\n        assertTrue(started);\n\n        vm.warp(proposalPeriod + rejectionPeriod + 2);\n        bob.buyoutModule.end(vault, burnProof);\n\n        bob.migrationModule.settleVault(vault, 1);\n        (, , , , address newVault, , , , ) = migrationModule.migrationInfo(\n            vault,\n            1\n        );\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IMigration.NewVaultAlreadyDeployed.selector,\n                newVault\n            )\n        );\n        bob.migrationModule.settleVault(vault, 1);\n    }\n\n    function testSettleFractionsUnsuccessfulMigration() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory newModules = new address[](2);\n\n        newModules[0] = migration;\n        newModules[1] = modules[1];\n\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            newModules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 1 ether}(vault, 1, 1000);\n\n        vm.warp(proposalPeriod + 1);\n        // bob calls commit to kickoff the buyout process\n        bool started = bob.migrationModule.commit(vault, 1);\n        assertTrue(started);\n\n        vm.warp(proposalPeriod + rejectionPeriod + 2);\n        bob.buyoutModule.end(vault, burnProof);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.UnsuccessfulMigration.selector)\n        );\n        bob.migrationModule.settleFractions(vault, 1, mintProof);\n    }\n\n    function testSettleFractionsNoVaultToMigrateTo() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory newModules = new address[](2);\n\n        newModules[0] = migration;\n        newModules[1] = modules[1];\n\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            newModules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);\n        // Alice joins the proposal\n        alice.migrationModule.join{value: 1 ether}(vault, 1, 1000);\n\n        vm.warp(proposalPeriod + 1);\n        // bob calls commit to kickoff the buyout process\n        bool started = bob.migrationModule.commit(vault, 1);\n        assertTrue(started);\n\n        vm.warp(proposalPeriod + rejectionPeriod + 2);\n        bob.buyoutModule.end(vault, burnProof);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.NoVaultToMigrateTo.selector)\n        );\n        bob.migrationModule.settleFractions(vault, 1, mintProof);\n    }\n\n    function testSettleFractionsAlreadyMinted() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory newModules = new address[](2);\n\n        newModules[0] = migration;\n        newModules[1] = modules[1];\n\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            newModules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);\n        // Alice joins the proposal\n        alice.migrationModule.join{value: 1 ether}(vault, 1, 1000);\n\n        vm.warp(proposalPeriod + 1);\n        // bob calls commit to kickoff the buyout process\n        bool started = bob.migrationModule.commit(vault, 1);\n        assertTrue(started);\n\n        vm.warp(proposalPeriod + rejectionPeriod + 2);\n        bob.buyoutModule.end(vault, burnProof);\n\n        bob.migrationModule.settleVault(vault, 1);\n        bob.migrationModule.settleFractions(vault, 1, mintProof);\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IMigration.NewFractionsAlreadyMinted.selector\n            )\n        );\n        bob.migrationModule.settleFractions(vault, 1, mintProof);\n    }\n\n    function testWithdrawERC20() public {\n        testSettle();\n        MockERC20(erc20).mint(vault, 10);\n\n        bob.migrationModule.migrateVaultERC20(\n            vault,\n            1,\n            erc20,\n            10,\n            erc20TransferProof\n        );\n    }\n\n    function testWithdrawERC20NotVault() public {\n        testSettle();\n        MockERC20(erc20).mint(vault, 10);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.NotVault.selector, address(0))\n        );\n        bob.migrationModule.migrateVaultERC20(\n            address(0),\n            1,\n            erc20,\n            10,\n            erc20TransferProof\n        );\n    }\n\n    function testWithdrawERC20UnsuccesfulBuyout() public {\n        testSettleVaultUnsuccessfulMigration();\n        MockERC20(erc20).mint(vault, 10);\n\n        vm.stopPrank();\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.InvalidState.selector, 2, 0)\n        );\n        bob.migrationModule.migrateVaultERC20(\n            vault,\n            1,\n            erc20,\n            10,\n            erc20TransferProof\n        );\n    }\n\n    function testWithdrawERC721() public {\n        testSettle();\n\n        bob.migrationModule.migrateVaultERC721(\n            vault,\n            1,\n            erc721,\n            1,\n            erc721TransferProof\n        );\n    }\n\n    function testWithdrawERC721NotVault() public {\n        testSettle();\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.NotVault.selector, address(0))\n        );\n        bob.migrationModule.migrateVaultERC721(\n            address(0),\n            1,\n            erc721,\n            1,\n            erc721TransferProof\n        );\n    }\n\n    function testWithdrawERC721UnsuccesfulBuyout() public {\n        testSettleVaultUnsuccessfulMigration();\n\n        vm.stopPrank();\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.InvalidState.selector, 2, 0)\n        );\n        bob.migrationModule.migrateVaultERC721(\n            vault,\n            1,\n            erc721,\n            1,\n            erc721TransferProof\n        );\n    }\n\n    function testWithdrawERC1155() public {\n        testSettle();\n        // mint some ERC1155 to the vault\n        MockERC1155(erc1155).mint(vault, 1, 10, \"\");\n\n        bob.migrationModule.migrateVaultERC1155(\n            vault,\n            1,\n            erc1155,\n            1,\n            10,\n            erc1155TransferProof\n        );\n    }\n\n    function testWithdrawERC1155NotVault() public {\n        testSettle();\n        // mint some ERC1155 to the vault\n        MockERC1155(erc1155).mint(vault, 1, 10, \"\");\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.NotVault.selector, address(0))\n        );\n        bob.migrationModule.migrateVaultERC1155(\n            address(0),\n            1,\n            erc1155,\n            1,\n            10,\n            erc1155TransferProof\n        );\n    }\n\n    function testWithdrawERC1155UnsuccesfulBuyout() public {\n        testSettleVaultUnsuccessfulMigration();\n        // mint some ERC1155 to the vault\n        MockERC1155(erc1155).mint(vault, 1, 10, \"\");\n\n        vm.stopPrank();\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.InvalidState.selector, 2, 0)\n        );\n        bob.migrationModule.migrateVaultERC1155(\n            vault,\n            1,\n            erc1155,\n            1,\n            10,\n            erc1155TransferProof\n        );\n    }\n\n    function testbBatchWithdrawERC1155() public {\n        testSettle();\n        // mint some ERC1155 to the vault\n        MockERC1155(erc1155).mint(vault, 1, 10, \"\");\n        MockERC1155(erc1155).mint(vault, 2, 10, \"\");\n\n        uint256[] memory ids = new uint256[](2);\n        ids[0] = 1;\n        ids[1] = 2;\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 10;\n        amounts[1] = 10;\n\n        bob.migrationModule.batchMigrateVaultERC1155(\n            vault,\n            1,\n            erc1155,\n            ids,\n            amounts,\n            erc1155BatchTransferProof\n        );\n    }\n\n    function testBatchWithdrawERC1155NotVault() public {\n        testSettle();\n        // mint some ERC1155 to the vault\n        MockERC1155(erc1155).mint(vault, 1, 10, \"\");\n        MockERC1155(erc1155).mint(vault, 2, 10, \"\");\n\n        uint256[] memory ids = new uint256[](2);\n        ids[0] = 1;\n        ids[1] = 2;\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 10;\n        amounts[1] = 10;\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.NotVault.selector, address(0))\n        );\n        bob.migrationModule.batchMigrateVaultERC1155(\n            address(0),\n            1,\n            erc1155,\n            ids,\n            amounts,\n            erc1155BatchTransferProof\n        );\n    }\n\n    function testBatchWithdrawERC1155UnsuccesfulBuyout() public {\n        testSettleVaultUnsuccessfulMigration();\n        // mint some ERC1155 to the vault\n        MockERC1155(erc1155).mint(vault, 1, 10, \"\");\n        MockERC1155(erc1155).mint(vault, 2, 10, \"\");\n\n        uint256[] memory ids = new uint256[](2);\n        ids[0] = 1;\n        ids[1] = 2;\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 10;\n        amounts[1] = 10;\n\n        vm.stopPrank();\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.InvalidState.selector, 2, 0)\n        );\n        bob.migrationModule.batchMigrateVaultERC1155(\n            vault,\n            1,\n            erc1155,\n            ids,\n            amounts,\n            erc1155BatchTransferProof\n        );\n    }\n\n    function testWithdrawItems() public {\n        testSettle();\n        // mint some ERC1155 to the vault\n        MockERC1155(erc1155).mint(vault, 1, 10, \"\");\n        MockERC1155(erc1155).mint(vault, 2, 10, \"\");\n        // mint some ERC20 to the vault\n        MockERC20(erc20).mint(vault, 10);\n\n        // Migrate\n        // migrateVaultERC20()\n        bytes[] memory data = new bytes[](3);\n        data[0] = initializeERC721Migration(vault, 1, 1);\n        uint256[] memory ids = new uint256[](2);\n        ids[0] = 1;\n        ids[1] = 2;\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 10;\n        amounts[1] = 10;\n        data[1] = initializeBatchMigrationERC1155(vault, 1, ids, amounts);\n        data[2] = initializeERC20Migration(vault, 1, 10);\n\n        bob.migrationModule.multicall(data);\n    }\n\n    function testWithdrawItemsNotVault() public {\n        testSettle();\n        // mint some ERC1155 to the vault\n        MockERC1155(erc1155).mint(vault, 1, 10, \"\");\n        MockERC1155(erc1155).mint(vault, 2, 10, \"\");\n        // mint some ERC20 to the vault\n        MockERC20(erc20).mint(vault, 10);\n\n        // migrateVaultERC20()\n        bytes[] memory data = new bytes[](3);\n        data[0] = initializeERC721Migration(address(0), 1, 1);\n        uint256[] memory ids = new uint256[](2);\n        ids[0] = 1;\n        ids[1] = 2;\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 10;\n        amounts[1] = 10;\n        data[1] = initializeBatchMigrationERC1155(address(0), 1, ids, amounts);\n        data[2] = initializeERC20Migration(address(0), 1, 10);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.NotVault.selector, address(0))\n        );\n        bob.migrationModule.multicall(data);\n    }\n\n    function testWithdrawItemsUnsuccesfulBuyout() public {\n        testSettleVaultUnsuccessfulMigration();\n        // mint some ERC1155 to the vault\n        MockERC1155(erc1155).mint(vault, 1, 10, \"\");\n        MockERC1155(erc1155).mint(vault, 2, 10, \"\");\n        // mint some ERC20 to the vault\n        MockERC20(erc20).mint(vault, 10);\n\n        // migrateVaultERC20()\n        bytes[] memory data = new bytes[](3);\n        data[0] = initializeERC721Migration(vault, 1, 1);\n        uint256[] memory ids = new uint256[](2);\n        ids[0] = 1;\n        ids[1] = 2;\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 10;\n        amounts[1] = 10;\n        data[1] = initializeBatchMigrationERC1155(vault, 1, ids, amounts);\n        data[2] = initializeERC20Migration(vault, 1, 10);\n\n        vm.stopPrank();\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.InvalidState.selector, 2, 0)\n        );\n        bob.migrationModule.multicall(data);\n    }\n\n    function testMigrateFractions() public {\n        testSettle();\n        (, , , , address newVault, , , , ) = migrationModule.migrationInfo(\n            vault,\n            1\n        );\n        (address newToken, uint256 id) = registry.vaultToToken(newVault);\n\n        assertEq(getFractionBalance(alice.addr), 4000);\n        alice.migrationModule.migrateFractions(vault, 1);\n        assertEq(IERC1155(newToken).balanceOf(alice.addr, id), 6000);\n\n        assertEq(getFractionBalance(bob.addr), 0);\n        bob.migrationModule.migrateFractions(vault, 1);\n        assertEq(IERC1155(newToken).balanceOf(bob.addr, id), 14000);\n    }\n\n    function testMigrateFractionsNotVault() public {\n        testSettle();\n\n        assertEq(getFractionBalance(alice.addr), 4000);\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.NotVault.selector, address(0))\n        );\n        alice.migrationModule.migrateFractions(address(0), 1);\n\n        vm.stopPrank();\n\n        assertEq(getFractionBalance(bob.addr), 0);\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.NotVault.selector, address(0))\n        );\n        bob.migrationModule.migrateFractions(address(0), 1);\n    }\n\n    function testMigrateFractionsUnsuccesfulBuyout() public {\n        testSettleVaultUnsuccessfulMigration();\n\n        vm.stopPrank();\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.InvalidState.selector, 2, 0)\n        );\n        alice.migrationModule.migrateFractions(vault, 1);\n\n        vm.stopPrank();\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.InvalidState.selector, 2, 0)\n        );\n        bob.migrationModule.migrateFractions(vault, 1);\n    }\n\n    function testWithdrawContribution() public {\n        testSettleVaultUnsuccessfulMigration();\n\n        vm.stopPrank();\n\n        bob.migrationModule.withdrawContribution(vault, 1);\n    }\n\n    function testWithdrawContributionNotVault() public {\n        initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n\n        // Migrate to a vault with no permissions (just to test out migration)\n        address[] memory newModules = new address[](3);\n\n        newModules[0] = migration;\n        newModules[1] = modules[1];\n\n        // Bob makes the proposal\n        bob.migrationModule.propose(\n            vault,\n            newModules,\n            nftReceiverPlugins,\n            nftReceiverSelectors,\n            TOTAL_SUPPLY * 2,\n            1 ether\n        );\n        // Bob joins the proposal\n        bob.migrationModule.join{value: 1 ether}(vault, 1, HALF_SUPPLY);\n\n        vm.warp(proposalPeriod + 1);\n        // bob calls commit to kickoff the buyout process\n        bool started = bob.migrationModule.commit(vault, 1);\n        assertTrue(started);\n\n        vm.warp(proposalPeriod + rejectionPeriod + 2);\n        bob.buyoutModule.end(vault, burnProof);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.NotVault.selector, address(0))\n        );\n        bob.migrationModule.withdrawContribution(address(0), 1);\n    }\n\n    function testWithdrawContributionNothingToWithdraw() public {\n        testSettle();\n\n        vm.stopPrank();\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IMigration.NoContributionToWithdraw.selector)\n        );\n        bob.migrationModule.withdrawContribution(vault, 1);\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {IFERC1155} from \"../interfaces/IFERC1155.sol\";\nimport {IMigration, Proposal} from \"../interfaces/IMigration.sol\";\nimport {IModule} from \"../interfaces/IModule.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {MerkleBase} from \"../utils/MerkleBase.sol\";\nimport {Minter} from \"./Minter.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\n\n/// @title Migration\n/// @author Fractional Art\n/// @notice Module contract for vaults to migrate to a new set of permissions\n/// - A fractional holder creates a proposal with a target price and list of modules\n/// - For 7 days, users can contribute their fractions / ether to signal support\n/// - If the target price is reached then a buyout can be triggered and trading\n///   against the proposed buyout price can take place to resolve the outcome\n/// - If a proposal holds more than 51% of the total supply, the buyout succeeds, a new vault can\n///   be created and the underlying assets (ERC-20, ERC-721 and ERC-1155 tokens) can be migrated\ncontract Migration is\n    IMigration,\n    MerkleBase,\n    Minter,\n    Multicall,\n    NFTReceiver,\n    ReentrancyGuard\n{\n    /// @notice Address of Buyout module contract\n    address payable public buyout;\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Counter used to assign IDs to new proposals\n    uint256 public nextId;\n    /// @notice The length for the migration proposal period\n    uint256 public constant PROPOSAL_PERIOD = 7 days;\n    /// @notice Mapping of a vault to it's proposal migration information\n    mapping(address => mapping(uint256 => Proposal)) public migrationInfo;\n    /// @notice Mapping of a proposal ID to a user's ether contribution\n    mapping(uint256 => mapping(address => uint256)) private userProposalEth;\n    /// @notice Mapping of a proposal ID to a user's fractions contribution\n    mapping(uint256 => mapping(address => uint256))\n        private userProposalFractions;\n\n    /// @notice Initializes buyout, registry, and supply contracts\n    constructor(\n        address _buyout,\n        address _registry,\n        address _supply\n    ) Minter(_supply) {\n        buyout = payable(_buyout);\n        registry = _registry;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Proposes a set of modules and plugins to migrate a vault to\n    /// @param _vault Address of the vault\n    /// @param _modules Addresses of module contracts\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of plugin function selectors\n    /// @param _newFractionSupply New supply of fractional tokens\n    /// @param _targetPrice Target price of the buyout\n    function propose(\n        address _vault,\n        address[] calldata _modules,\n        address[] calldata _plugins,\n        bytes4[] calldata _selectors,\n        uint256 _newFractionSupply,\n        uint256 _targetPrice\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Initializes migration proposal info\n        Proposal storage proposal = migrationInfo[_vault][++nextId];\n        proposal.startTime = block.timestamp;\n        proposal.targetPrice = _targetPrice;\n        proposal.modules = _modules;\n        proposal.plugins = _plugins;\n        proposal.selectors = _selectors;\n        proposal.oldFractionSupply = IVaultRegistry(registry).totalSupply(\n            _vault\n        );\n        proposal.newFractionSupply = _newFractionSupply;\n    }\n\n    /// @notice Joins a migration proposal by contributing ether and fractional tokens\n    /// @param _vault The address of the vault\n    /// @param _proposalId ID of the proposal being contributed to\n    /// @param _amount Number of fractions being contributed\n    function join(\n        address _vault,\n        uint256 _proposalId,\n        uint256 _amount\n    ) external payable nonReentrant {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates ether balances of the proposal and caller\n        proposal.totalEth += msg.value;\n        userProposalEth[_proposalId][msg.sender] += msg.value;\n        // Deposits fractional tokens into contract\n        IFERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates fraction balances of the proposal and caller\n        proposal.totalFractions += _amount;\n        userProposalFractions[_proposalId][msg.sender] += _amount;\n    }\n\n    /// @notice Leaves a proposed migration with contribution amount\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being left\n    function leave(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n\n        // Gets the migration proposal for the given ID\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        // Updates fraction balances of the proposal and caller\n        uint256 amount = userProposalFractions[_proposalId][msg.sender];\n        proposal.totalFractions -= amount;\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Updates ether balances of the proposal and caller\n        uint256 ethAmount = userProposalEth[_proposalId][msg.sender];\n        proposal.totalEth -= ethAmount;\n        userProposalEth[_proposalId][msg.sender] = 0;\n\n        // Withdraws fractions from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(ethAmount);\n    }\n\n    /// @notice Kicks off the buyout process for a migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being committed to\n    /// @return started Bool status of starting the buyout process\n    function commit(address _vault, uint256 _proposalId)\n        external\n        returns (bool started)\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not inactive\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if migration is passed proposal period\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (block.timestamp > proposal.startTime + PROPOSAL_PERIOD)\n            revert ProposalOver();\n\n        // Calculates current price of the proposal based on total supply\n        uint256 currentPrice = _calculateTotal(\n            100,\n            IVaultRegistry(registry).totalSupply(_vault),\n            proposal.totalEth,\n            proposal.totalFractions\n        );\n\n        // Checks if the current price is greater than target price of the proposal\n        if (currentPrice > proposal.targetPrice) {\n            // Sets token approval to the buyout contract\n            IFERC1155(token).setApprovalFor(address(buyout), id, true);\n            // Starts the buyout process\n            IBuyout(buyout).start{value: proposal.totalEth}(_vault);\n            proposal.isCommited = true;\n            started = true;\n        }\n    }\n\n    /// @notice Settles a migration by ending the buyout\n    /// @dev Succeeds if buyout goes through, fails otherwise\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal being settled\n    function settleVault(address _vault, uint256 _proposalId) external {\n        // Reverts if the migration was not proposed\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (!(proposal.isCommited)) revert NotProposed();\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if the new vault has already been deployed\n        if (proposal.newVault != address(0))\n            revert NewVaultAlreadyDeployed(proposal.newVault);\n\n        // Gets the merkle root for the vault and given proposal ID\n        bytes32[] memory merkleTree = generateMerkleTree(proposal.modules);\n        bytes32 merkleRoot = getRoot(merkleTree);\n        // Deploys a new vault with set permissions and plugins\n        address newVault = IVaultRegistry(registry).create(\n            merkleRoot,\n            proposal.plugins,\n            proposal.selectors\n        );\n        // Sets address of the newly deployed vault\n        proposal.newVault = newVault;\n        // Emits event for settling the new vault\n        emit VaultMigrated(\n            _vault,\n            newVault,\n            _proposalId,\n            proposal.modules,\n            proposal.plugins,\n            proposal.selectors\n        );\n    }\n\n    /// @notice Mints the fractional tokens for a new vault\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _mintProof Merkle proof for minting fractional tokens\n    function settleFractions(\n        address _vault,\n        uint256 _proposalId,\n        bytes32[] calldata _mintProof\n    ) external {\n        // Reverts if the migration was unsuccessful\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (current != State.SUCCESS) revert UnsuccessfulMigration();\n        // Reverts if there is no new vault to migrate to\n        Proposal storage proposal = migrationInfo[_vault][_proposalId];\n        if (proposal.newVault == address(0)) revert NoVaultToMigrateTo();\n        // Reverts if fractions of the new vault have already been minted\n        if (proposal.fractionsMigrated) revert NewFractionsAlreadyMinted();\n\n        // Mints initial supply of fractions for the new vault\n        _mintFractions(\n            proposal.newVault,\n            address(this),\n            proposal.newFractionSupply,\n            _mintProof\n        );\n\n        migrationInfo[_vault][_proposalId].fractionsMigrated = true;\n        // Emits event for minting fractional tokens for the new vault\n        emit FractionsMigrated(\n            _vault,\n            proposal.newVault,\n            _proposalId,\n            proposal.newFractionSupply\n        );\n    }\n\n    /// @notice Retrieves ether and fractions deposited from an unsuccessful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the failed proposal\n    function withdrawContribution(address _vault, uint256 _proposalId)\n        external\n    {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if caller has no fractional balance to withdraw\n        (, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);\n        if (\n            current != State.INACTIVE ||\n            migrationInfo[_vault][_proposalId].newVault != address(0)\n        ) revert NoContributionToWithdraw();\n\n        // Temporarily store user's fractions for the transfer\n        uint256 userFractions = userProposalFractions[_proposalId][msg.sender];\n        // Updates fractional balance of caller\n        userProposalFractions[_proposalId][msg.sender] = 0;\n        // Withdraws fractional tokens from contract back to caller\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            userFractions,\n            \"\"\n        );\n\n        // Temporarily store user's eth for the transfer\n        uint256 userEth = userProposalEth[_proposalId][msg.sender];\n        // Udpates ether balance of caller\n        userProposalEth[_proposalId][msg.sender] = 0;\n        // Withdraws ether from contract back to caller\n        payable(msg.sender).transfer(userEth);\n    }\n\n    /// @notice Migrates an ERC-20 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-20 token\n    /// @param _amount Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function migrateVaultERC20(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _amount,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-20 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC20(\n            _vault,\n            _token,\n            newVault,\n            _amount,\n            _erc20TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-721 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-721 token\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function migrateVaultERC721(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-721 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC721(\n            _vault,\n            _token,\n            newVault,\n            _tokenId,\n            _erc721TransferProof\n        );\n    }\n\n    /// @notice Migrates an ERC-1155 token to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _id ID of the token\n    /// @param _amount amount to be transferred\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function migrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256 _id,\n        uint256 _amount,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Withdraws an ERC-1155 token from the old vault and transfers to the new vault\n        IBuyout(buyout).withdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _id,\n            _amount,\n            _erc1155TransferProof\n        );\n    }\n\n    /// @notice Batch migrates multiple ERC-1155 tokens to the new vault after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    /// @param _token Address of the ERC-1155 token\n    /// @param _ids IDs of each token type\n    /// @param _amounts Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for batch transferring multiple ERC-1155 tokens\n    function batchMigrateVaultERC1155(\n        address _vault,\n        uint256 _proposalId,\n        address _token,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        // Batch withdraws multiple ERC-1155 tokens from the old vault and transfers to the new vault\n        IBuyout(buyout).batchWithdrawERC1155(\n            _vault,\n            _token,\n            newVault,\n            _ids,\n            _amounts,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Migrates the caller's fractions from an old vault to a new one after a successful migration\n    /// @param _vault Address of the vault\n    /// @param _proposalId ID of the proposal\n    function migrateFractions(address _vault, uint256 _proposalId) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if buyout state is not successful\n        (, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        State required = State.SUCCESS;\n        if (current != required) revert IBuyout.InvalidState(required, current);\n        // Reverts if proposer of buyout is not this contract\n        if (proposer != address(this)) revert NotProposalBuyout();\n\n        // Gets the last total supply of fractions for the vault\n        (, , , , , uint256 lastTotalSupply) = IBuyout(buyout).buyoutInfo(\n            _vault\n        );\n        // Calculates the total ether amount of a successful proposal\n        uint256 totalInEth = _calculateTotal(\n            1 ether,\n            lastTotalSupply,\n            migrationInfo[_vault][_proposalId].totalEth,\n            migrationInfo[_vault][_proposalId].totalFractions\n        );\n        // Calculates balance of caller based on ether contribution\n        uint256 balanceContributedInEth = _calculateContribution(\n            totalInEth,\n            lastTotalSupply,\n            userProposalEth[_proposalId][msg.sender],\n            userProposalFractions[_proposalId][msg.sender]\n        );\n\n        // Gets the token and fraction ID of the new vault\n        address newVault = migrationInfo[_vault][_proposalId].newVault;\n        (address token, uint256 newFractionId) = IVaultRegistry(registry)\n            .vaultToToken(newVault);\n        // Calculates share amount of fractions for the new vault based on the new total supply\n        uint256 newTotalSupply = IVaultRegistry(registry).totalSupply(newVault);\n        uint256 shareAmount = (balanceContributedInEth * newTotalSupply) /\n            totalInEth;\n\n        // Transfers fractional tokens to caller based on share amount\n        IFERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            newFractionId,\n            shareAmount,\n            \"\"\n        );\n    }\n\n    /// @notice Generates the merkle tree of a given proposal\n    /// @param _modules List of module contracts\n    /// @return hashes Combined list of leaf nodes\n    function generateMerkleTree(address[] memory _modules)\n        public\n        view\n        returns (bytes32[] memory hashes)\n    {\n        uint256 treeLength;\n        uint256 modulesLength = _modules.length;\n\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                treeLength += IModule(_modules[i]).getLeafNodes().length;\n            }\n        }\n\n        uint256 counter;\n        hashes = new bytes32[](treeLength);\n        unchecked {\n            for (uint256 i; i < modulesLength; ++i) {\n                bytes32[] memory leaves = IModule(_modules[i]).getLeafNodes();\n                uint256 leavesLength = leaves.length;\n                for (uint256 j; j < leavesLength; ++j) {\n                    hashes[counter++] = leaves[j];\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates the total amount of ether\n    /// @param _scalar Scalar used for multiplication\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _totalEth Total ether balance of the proposal\n    /// @param _totalFractions Total fractional balance of the proposal\n    /// @return Total amount of ether\n    function _calculateTotal(\n        uint256 _scalar,\n        uint256 _lastTotalSupply,\n        uint256 _totalEth,\n        uint256 _totalFractions\n    ) private pure returns (uint256) {\n        return\n            (_totalEth * _scalar) /\n            (_scalar - ((_totalFractions * _scalar) / _lastTotalSupply));\n    }\n\n    /// @notice Calculates the amount of ether contributed by the user\n    /// @param _totalInEth Total amount of ether\n    /// @param _lastTotalSupply Previous total fractional supply of the vault\n    /// @param _userProposalEth User balance of ether for the proposal\n    /// @param _userProposalFractions User balance of fractions for the proposal\n    /// @return Total contribution amount\n    function _calculateContribution(\n        uint256 _totalInEth,\n        uint256 _lastTotalSupply,\n        uint256 _userProposalEth,\n        uint256 _userProposalFractions\n    ) private pure returns (uint256) {\n        return\n            _userProposalEth +\n            (_userProposalFractions * _totalInEth) /\n            _lastTotalSupply;\n    }\n}\n\n\n",
        "CodeNames": [
            "Migration.t.sol",
            "Migration.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "withdrawContribution function in Migration.sol module",
                "Type": "Inflation Bug",
                "Description": "The withdrawContribution function in Migration.sol module does not update the variables totalEth and totalFractions (as join and leave do), leading to an inflation of ETH and fractional tokens if the user calls join, withdrawContribution and join again. An attacker can exploit this inflation bug to steal all Ether and fractional tokens sent to a legit proposal by legit users of the community, and redirect them to an evil proposal that will win (because it has over 51% of token supply) and at the same time invalidate the legit proposal.",
                "Repair": "Update the proposal.totalEth and proposal.totalFractions in the withdrawContribution function."
            },
            {
                "Location": "Migration.sol",
                "Type": "Asset Burning",
                "Description": "An attacker could call Migration.migrateVaultERC20, Migration.migrateVaultERC721, and/or Migration.migrateVaultERC1155 with an invalid _proposalId parameter, causing the assets within the vault to be burned. The vulnerability is caused by the fact that newVault will be set to address(0) if an invalid _proposalId is submitted, and the assets will be transferred to address(0) if the validation checks are not implemented.",
                "Repair": "Perform additional validation to ensure that the _proposalId submitted is valid. Check if newVault points to a valid vault address before transferring the assets from old vault to new vault. Implement validation checks to ensure that the _to address is not address(0) within the Buyout.withdrawERC721 function."
            },
            {
                "Location": "propose() function in Migration.sol",
                "Type": "Array out of bounds",
                "Description": "Migration can permanently fail if user specifies different lengths for selectors and plugins.",
                "Repair": "Add a check in propose() function to ensure that the lengths of selectors and plugins arrays match"
            },
            {
                "Location": "Migration.sol",
                "Type": "Total supply reduction can be used to remove minority shareholders",
                "Description": "A migration that changes the supply can result in some users losing their expected share of funds.",
                "Repair": "Require that the new total supply should be greater than the old one"
            },
            {
                "Location": "Migration.sol",
                "Type": "Migration logic issue",
                "Description": "The join() and leave() functions in Migration.sol can still work after an unsuccessful migration, which can cause issues with withdrawal logic. Users may not be able to withdraw their contributions or may withdraw funds that belong to other users. Adding conditions to join() and leave() functions can prevent this issue.",
                "Repair": "Add conditions to join() and leave() functions so that users can only call these functions for 7 days before the migration is committed"
            },
            {
                "Location": "Migration.sol",
                "Type": "Precision loss causing loss of user value",
                "Description": "If the supply of the fraction is set too low, users can lose fractions to precision loss during migration, causing loss of user value and potentially causing complete loss to the vault. Requiring that _newFractionSupply is greater than some value when calling propose can prevent this issue.",
                "Repair": "Require that _newFractionSupply is greater than some value when calling propose"
            },
            {
                "Location": "Migration.sol",
                "Type": "Incorrect withdrawal logic",
                "Description": "The withdrawContribution function in Migration.sol falsely assumes that users should get exactly their original contribution back, which can cause loss of funds for users. If the proposal has been committed and other users have interacted with the buyout, Migration will receive back a different amount of ETH and tokens. Implementing a hook call from Buyout to Migration upon a failed proposal's end can update the proposal with the correct amount of ETH/tokens received.",
                "Repair": "Implement a hook call from Buyout to Migration upon a failed proposal's end to update the proposal with the correct amount of ETH/tokens received"
            },
            {
                "Location": "Migration.sol",
                "Type": "Fraudulent Withdrawal",
                "Description": "Fraudulent withdrawal of fractions deposited into any proposal can be done until it is committed.",
                "Repair": "Include amount of fractions a proposer deposits when starting a buyout in Buyout start function and specify correct fractions amount when starting a buyout in Migration's commit function"
            },
            {
                "Location": "Migration.sol",
                "Type": "Funds Stuck",
                "Description": "Funds in migration proposals could potentially be stuck forever if a buyout auction on the same vault is started by another party.",
                "Repair": "Modify checks for leave and withdrawContribution functions to allow users to withdraw their funds from the proposal when the buyout auction proposer is not Migration.sol. Track the latest proposalId that started the buyout on a vault."
            },
            {
                "Location": "Migration.sol",
                "Type": "Division by Zero",
                "Description": "When proposal.totalFractions is equal to the total supply (meaning that all token holders want to participate in a migration), there is a division by zero in _calculateTotal. In such a case, redeem can be used instead of starting a buyout.",
                "Repair": "Handle the case when all token holders want to participate in a migration"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport \"./TestUtil.sol\";\n\ncontract BuyoutTest is TestUtil {\n    /// =================\n    /// ===== SETUP =====\n    /// =================\n    function setUp() public {\n        setUpContract();\n        alice = setUpUser(111, 1);\n        bob = setUpUser(222, 2);\n\n        vm.label(address(this), \"BuyoutTest\");\n        vm.label(alice.addr, \"Alice\");\n        vm.label(bob.addr, \"Bob\");\n    }\n\n    /// ========================\n    /// ===== START BUYOUT =====\n    /// ========================\n    function testStart() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        assertEq(getFractionBalance(bob.addr), HALF_SUPPLY);\n        assertEq(getFractionBalance(buyout), 0);\n        assertEq(getETHBalance(bob.addr), INITIAL_BALANCE);\n        assertEq(getETHBalance(buyout), 0 ether);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        assertEq(getFractionBalance(bob.addr), 0);\n        assertEq(getFractionBalance(buyout), HALF_SUPPLY);\n        assertEq(getETHBalance(bob.addr), 99 ether);\n        assertEq(getETHBalance(buyout), 1 ether);\n    }\n\n    function testStartNoFractions() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, 0, true);\n\n        assertEq(getFractionBalance(bob.addr), 0);\n        assertEq(getFractionBalance(buyout), 0);\n        assertEq(getETHBalance(bob.addr), INITIAL_BALANCE);\n        assertEq(getETHBalance(buyout), 0 ether);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        assertEq(getFractionBalance(bob.addr), 0);\n        assertEq(getFractionBalance(buyout), 0);\n        assertEq(getETHBalance(bob.addr), 99 ether);\n        assertEq(getETHBalance(buyout), 1 ether);\n    }\n\n    function testStartRevertNotAVault() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.NotVault.selector,\n                address(baseVault)\n            )\n        );\n        bob.buyoutModule.start{value: 1 ether}(address(baseVault));\n    }\n\n    function testStartRevertStateLIVE() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        alice.buyoutModule.start{value: 1 ether}(vault);\n\n        revertBuyoutState(State.INACTIVE, State.LIVE);\n        bob.buyoutModule.start{value: 1 ether}(vault);\n    }\n\n    function testStartRevertZeroDeposit() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        vm.expectRevert(abi.encodeWithSelector(IBuyout.ZeroDeposit.selector));\n        bob.buyoutModule.start(vault);\n    }\n\n    function testStartRevertNotApproved() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, false);\n\n        vm.expectRevert(bytes(\"NOT_AUTHORIZED\"));\n        alice.buyoutModule.start{value: 1 ether}(vault);\n    }\n\n    function testStartRevertTotalSupply() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, 0, true);\n\n        vm.expectRevert(stdError.divisionError);\n        alice.buyoutModule.start{value: 1 ether}(vault);\n    }\n\n    /// ==========================\n    /// ===== SELL FRACTIONS =====\n    /// ==========================\n    function testSellFractions() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        assertEq(getFractionBalance(alice.addr), HALF_SUPPLY);\n        assertEq(getFractionBalance(buyout), HALF_SUPPLY);\n        assertEq(getETHBalance(alice.addr), INITIAL_BALANCE);\n        assertEq(getETHBalance(buyout), 1 ether);\n\n        alice.buyoutModule.sellFractions(vault, 1000);\n\n        assertEq(getFractionBalance(alice.addr), 4000);\n        assertEq(getFractionBalance(buyout), 6000);\n        assertEq(getETHBalance(alice.addr), 100.2 ether);\n        assertEq(getETHBalance(buyout), 0.8 ether);\n    }\n\n    function testSellFractionsSelfPermit() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        assertEq(getFractionBalance(alice.addr), HALF_SUPPLY);\n        assertEq(getFractionBalance(buyout), HALF_SUPPLY);\n        assertEq(getETHBalance(alice.addr), INITIAL_BALANCE);\n        assertEq(getETHBalance(buyout), 1 ether);\n\n        alice.ferc1155 = new FERC1155BS(address(0), 111, token);\n        alice.ferc1155.setApprovalForAll(buyout, false);\n        (uint8 v, bytes32 r, bytes32 s) = signPermitAll(\n            alice,\n            buyout,\n            true,\n            FERC1155(token).nonces(alice.addr),\n            block.timestamp + 1\n        );\n\n        alice.buyoutModule.selfPermitAll(\n            token,\n            true,\n            block.timestamp + 1,\n            v,\n            r,\n            s\n        );\n\n        alice.buyoutModule.sellFractions(vault, 1000);\n\n        assertEq(getFractionBalance(alice.addr), 4000);\n        assertEq(getFractionBalance(buyout), 6000);\n        assertEq(getETHBalance(alice.addr), 100.2 ether);\n        assertEq(getETHBalance(buyout), 0.8 ether);\n    }\n\n    function testSellFractionsNoDepositAmount() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        alice.buyoutModule.start{value: 1 ether}(vault);\n\n        assertEq(getFractionBalance(alice.addr), 0);\n        assertEq(getFractionBalance(buyout), HALF_SUPPLY);\n        assertEq(getETHBalance(alice.addr), 99 ether);\n        assertEq(getETHBalance(buyout), 1 ether);\n\n        alice.buyoutModule.sellFractions(vault, 0);\n\n        assertEq(getFractionBalance(alice.addr), 0);\n        assertEq(getFractionBalance(buyout), HALF_SUPPLY);\n        assertEq(getETHBalance(alice.addr), 99 ether);\n        assertEq(getETHBalance(buyout), 1 ether);\n    }\n\n    function testSellFractionsRevertTimeExpired() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        vm.warp(proposalPeriod + 1);\n\n        uint256 expected = block.timestamp - 1;\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.TimeExpired.selector,\n                block.timestamp,\n                expected\n            )\n        );\n        alice.buyoutModule.sellFractions(vault, 1000);\n    }\n\n    function testSellFractionsRevertNotAVault() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.NotVault.selector,\n                address(baseVault)\n            )\n        );\n        alice.buyoutModule.sellFractions(address(baseVault), 1000);\n    }\n\n    function testSellFractionsRevertStateINACTIVE() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        revertBuyoutState(State.LIVE, State.INACTIVE);\n        alice.buyoutModule.sellFractions(vault, 1000);\n    }\n\n    function testSellFractionsRevertNotApproved() public {\n        deployBaseVault(alice, TOTAL_SUPPLY);\n        (token, tokenId) = registry.vaultToToken(vault);\n        bob.ferc1155 = new FERC1155BS(address(0), 222, address(token));\n        setApproval(bob, vault, true);\n        setApproval(bob, address(buyoutModule), true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        vm.expectRevert(bytes(\"NOT_AUTHORIZED\"));\n        alice.buyoutModule.sellFractions(vault, 1000);\n    }\n\n    /// =========================\n    /// ===== BUY FRACTIONS =====\n    /// =========================\n    function testBuyFractionsSingle() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        assertEq(getFractionBalance(alice.addr), HALF_SUPPLY);\n        assertEq(getFractionBalance(buyout), HALF_SUPPLY);\n        assertEq(getETHBalance(alice.addr), INITIAL_BALANCE);\n        assertEq(getETHBalance(buyout), 1 ether);\n\n        alice.buyoutModule.buyFractions{value: 0.2 ether}(vault, 1000);\n\n        assertEq(getFractionBalance(alice.addr), 6000);\n        assertEq(getFractionBalance(buyout), 4000);\n        assertEq(getETHBalance(alice.addr), 99.8 ether);\n        assertEq(getETHBalance(buyout), 1.2 ether);\n    }\n\n    function testBuyFractionsNoDepositAmount() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        assertEq(getFractionBalance(alice.addr), HALF_SUPPLY);\n        assertEq(getFractionBalance(buyout), HALF_SUPPLY);\n        assertEq(getETHBalance(alice.addr), INITIAL_BALANCE);\n        assertEq(getETHBalance(buyout), 1 ether);\n\n        alice.buyoutModule.buyFractions{value: 0 ether}(vault, 0);\n\n        assertEq(getFractionBalance(alice.addr), HALF_SUPPLY);\n        assertEq(getFractionBalance(buyout), HALF_SUPPLY);\n        assertEq(getETHBalance(alice.addr), INITIAL_BALANCE);\n        assertEq(getETHBalance(buyout), 1 ether);\n    }\n\n    function testBuyFractionsNotAVault() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.NotVault.selector,\n                address(baseVault)\n            )\n        );\n        alice.buyoutModule.buyFractions{value: 0.2 ether}(\n            address(baseVault),\n            1000\n        );\n    }\n\n    function testBuyFractionsRevertStateINACTIVE() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        revertBuyoutState(State.LIVE, State.INACTIVE);\n        alice.buyoutModule.buyFractions{value: 0.2 ether}(vault, 1000);\n    }\n\n    function testBuyFractionsRevertTimeExpired() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        vm.warp(rejectionPeriod + 1);\n        uint256 expected = block.timestamp - 1;\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.TimeExpired.selector,\n                block.timestamp,\n                expected\n            )\n        );\n\n        alice.buyoutModule.buyFractions{value: 0.2 ether}(vault, 1000);\n    }\n\n    function testBuyFractionsRevertInvalidPayment() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(IBuyout.InvalidPayment.selector)\n        );\n\n        alice.buyoutModule.buyFractions{value: 0.19 ether}(vault, 1000);\n    }\n\n    /// ======================\n    /// ===== END BUYOUT =====\n    /// ======================\n    function testEndSuccesfull() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        alice.buyoutModule.sellFractions(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n\n        assertEq(getFractionBalance(bob.addr), 0);\n        assertEq(getFractionBalance(buyout), 6000);\n\n        bob.buyoutModule.end(vault, burnProof);\n\n        assertEq(getFractionBalance(bob.addr), 0);\n        assertEq(getFractionBalance(buyout), 0);\n    }\n\n    function testEndUnsuccesfull() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        alice.buyoutModule.buyFractions{value: 0.2 ether}(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n\n        assertEq(getFractionBalance(bob.addr), 0);\n        assertEq(getFractionBalance(buyout), 4000);\n        assertEq(getETHBalance(bob.addr), 99 ether);\n        assertEq(getETHBalance(buyout), 1.2 ether);\n\n        bob.buyoutModule.end(vault, burnProof);\n\n        assertEq(getFractionBalance(bob.addr), 4000);\n        assertEq(getFractionBalance(buyout), 0);\n        assertEq(getETHBalance(bob.addr), 100.2 ether);\n        assertEq(getETHBalance(buyout), 0 ether);\n    }\n\n    function testEndRevertNotAVault() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        alice.buyoutModule.sellFractions(vault, 1000);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.NotVault.selector,\n                address(baseVault)\n            )\n        );\n        bob.buyoutModule.end(address(baseVault), burnProof);\n    }\n\n    function testEndRevertStateINACTIVE() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        revertBuyoutState(State.LIVE, State.INACTIVE);\n        bob.buyoutModule.end(vault, burnProof);\n    }\n\n    function testEndRevertTimeNotElapsed() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        alice.buyoutModule.buyFractions{value: 0.2 ether}(vault, 1000);\n        vm.warp(rejectionPeriod);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.TimeNotElapsed.selector,\n                block.timestamp,\n                block.timestamp\n            )\n        );\n        bob.buyoutModule.end(vault, burnProof);\n    }\n\n    /// ====================\n    /// ===== CASH OUT =====\n    /// ====================\n    function testCash() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpBuyoutCash(alice, bob);\n\n        assertEq(getFractionBalance(alice.addr), 4000);\n        assertEq(getFractionBalance(buyout), 0);\n        assertEq(getETHBalance(alice.addr), 100.2 ether);\n        assertEq(getETHBalance(buyout), 0.8 ether);\n\n        alice.buyoutModule.cash(vault, burnProof);\n\n        assertEq(getFractionBalance(alice.addr), 0);\n        assertEq(getFractionBalance(buyout), 0);\n        assertEq(getETHBalance(alice.addr), 101 ether);\n        assertEq(getETHBalance(buyout), 0 ether);\n    }\n\n    function testCashRevertNotAVault() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpBuyoutCash(alice, bob);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.NotVault.selector,\n                address(baseVault)\n            )\n        );\n        bob.buyoutModule.cash(address(baseVault), burnProof);\n    }\n\n    function testCashRevertStateLIVE() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        alice.buyoutModule.sellFractions(vault, 1000);\n        vm.warp(rejectionPeriod);\n\n        revertBuyoutState(State.SUCCESS, State.LIVE);\n        bob.buyoutModule.cash(vault, burnProof);\n    }\n\n    function testCashRevertStateINACTIVE() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        alice.buyoutModule.buyFractions{value: 0.2 ether}(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n        bob.buyoutModule.end(vault, burnProof);\n\n        revertBuyoutState(State.SUCCESS, State.INACTIVE);\n        bob.buyoutModule.cash(vault, burnProof);\n    }\n\n    function testCashRevertNoFractions() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        alice.buyoutModule.sellFractions(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n        bob.buyoutModule.end(vault, burnProof);\n\n        vm.expectRevert(abi.encodeWithSelector(IBuyout.NoFractions.selector));\n        bob.buyoutModule.cash(vault, burnProof);\n    }\n\n    // ======================\n    // ===== REDEEM NFT =====\n    // ======================\n    function testRedeem() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, TOTAL_SUPPLY, true);\n\n        assertEq(getFractionBalance(bob.addr), TOTAL_SUPPLY);\n        bob.buyoutModule.redeem(vault, burnProof);\n        assertEq(getFractionBalance(bob.addr), 0);\n    }\n\n    function testRedeemRevertNotAVault() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.NotVault.selector,\n                address(baseVault)\n            )\n        );\n        bob.buyoutModule.redeem(address(baseVault), burnProof);\n    }\n\n    function testRedeemRevertStateLIVE() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        alice.buyoutModule.buyFractions{value: 1 ether}(vault, HALF_SUPPLY);\n\n        revertBuyoutState(State.INACTIVE, State.LIVE);\n        alice.buyoutModule.redeem(vault, burnProof);\n    }\n\n    function testRedeemRevertNotTotalSupply() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        vm.expectRevert(stdError.arithmeticError);\n        bob.buyoutModule.redeem(vault, burnProof);\n    }\n\n    /// ===========================\n    /// ===== WITHDRAW ERC721 =====\n    /// ===========================\n    function testWithdrawERC721() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpWithdrawERC721(alice, bob);\n\n        bytes memory withdrawERC721 = initializeWithdrawalERC721(\n            vault,\n            bob.addr,\n            1\n        );\n        bytes memory withdraw2ERC721 = initializeWithdrawalERC721(\n            vault,\n            bob.addr,\n            2\n        );\n        bytes[] memory data = new bytes[](2);\n        data[0] = withdrawERC721;\n        data[1] = withdraw2ERC721;\n\n        assertEq(IERC721(erc721).balanceOf(bob.addr), 0);\n        bob.buyoutModule.multicall(data);\n        assertEq(IERC721(erc721).balanceOf(bob.addr), 2);\n    }\n\n    function testWithdrawERC721Redeem() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, TOTAL_SUPPLY, true);\n        bob.erc721.safeTransferFrom(bob.addr, vault, 2);\n        bob.buyoutModule.redeem(vault, burnProof);\n\n        bytes memory withdrawERC721 = initializeWithdrawalERC721(\n            vault,\n            bob.addr,\n            1\n        );\n        bytes memory withdraw2ERC721 = initializeWithdrawalERC721(\n            vault,\n            bob.addr,\n            2\n        );\n        bytes[] memory data = new bytes[](2);\n        data[0] = withdrawERC721;\n        data[1] = withdraw2ERC721;\n\n        bob.buyoutModule.multicall(data);\n        assertEq(IERC721(erc721).balanceOf(bob.addr), 2);\n    }\n\n    function testWithdrawERC721RevertNotAVault() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpWithdrawERC721(alice, bob);\n\n        bytes memory withdrawERC721 = initializeWithdrawalERC721(\n            address(baseVault),\n            bob.addr,\n            1\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = withdrawERC721;\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.NotVault.selector,\n                address(baseVault)\n            )\n        );\n        bob.buyoutModule.multicall(data);\n    }\n\n    function testWithdrawERC721RevertStateINACTIVE() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        alice.buyoutModule.buyFractions{value: 0.2 ether}(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n        bob.buyoutModule.end(vault, burnProof);\n\n        revertBuyoutState(State.SUCCESS, State.INACTIVE);\n        bob.buyoutModule.withdrawERC721(\n            vault,\n            address(erc721),\n            bob.addr,\n            1,\n            erc721TransferProof\n        );\n    }\n\n    function testWithdrawERC721RevertNotAllowed() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpWithdrawERC721(alice, bob);\n\n        bytes memory withdrawERC721 = initializeWithdrawalERC721(\n            vault,\n            alice.addr,\n            1\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = withdrawERC721;\n\n        vm.expectRevert(abi.encodeWithSelector(IBuyout.NotWinner.selector));\n        alice.buyoutModule.multicall(data);\n    }\n\n    /// ============================\n    /// ===== WITHDRAW ERC1155 =====\n    /// ============================\n    function testWithdrawERC1155() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpWithdrawERC1155(alice, bob);\n\n        bytes memory withdrawERC1155 = initializeWithdrawalERC1155(\n            vault,\n            bob.addr,\n            1,\n            10\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = withdrawERC1155;\n\n        assertEq(IERC1155(erc1155).balanceOf(bob.addr, 1), 0);\n        bob.buyoutModule.multicall(data);\n        assertEq(IERC1155(erc1155).balanceOf(bob.addr, 1), 10);\n    }\n\n    function testWithdrawERC1155Redeem() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, TOTAL_SUPPLY, true);\n        MockERC1155(erc1155).mint(vault, 1, 10, \"\");\n        bob.buyoutModule.redeem(vault, burnProof);\n\n        bytes memory withdrawERC1155 = initializeWithdrawalERC1155(\n            vault,\n            bob.addr,\n            1,\n            10\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = withdrawERC1155;\n\n        bob.buyoutModule.multicall(data);\n        assertEq(IERC1155(erc1155).balanceOf(bob.addr, 1), 10);\n    }\n\n    function testWithdrawERC1155RevertNotAVault() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpWithdrawERC1155(alice, bob);\n\n        bytes memory withdrawERC1155 = initializeWithdrawalERC1155(\n            address(baseVault),\n            bob.addr,\n            1,\n            10\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = withdrawERC1155;\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.NotVault.selector,\n                address(baseVault)\n            )\n        );\n        bob.buyoutModule.multicall(data);\n    }\n\n    function testWithdrawERC1155RevertStateINACTIVE() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        alice.buyoutModule.buyFractions{value: 0.2 ether}(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n        bob.buyoutModule.end(vault, burnProof);\n\n        revertBuyoutState(State.SUCCESS, State.INACTIVE);\n        bob.buyoutModule.withdrawERC1155(\n            vault,\n            address(erc1155),\n            bob.addr,\n            1,\n            10,\n            erc1155TransferProof\n        );\n    }\n\n    function testWithdrawERC1155RevertNotAllowed() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpWithdrawERC1155(alice, bob);\n\n        bytes memory withdrawERC1155 = initializeWithdrawalERC1155(\n            vault,\n            alice.addr,\n            1,\n            10\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = withdrawERC1155;\n\n        vm.expectRevert(abi.encodeWithSelector(IBuyout.NotWinner.selector));\n        alice.buyoutModule.multicall(data);\n    }\n\n    /// ==================================\n    /// ===== BATCH WITHDRAW ERC1155 =====\n    /// ==================================\n    function testBatchWithdrawERC1155() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpBatchWithdrawERC1155(alice, bob);\n\n        bytes memory batchWithdrawERC1155 = initializeBatchWithdrawalERC1155(\n            vault,\n            bob.addr,\n            3\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = batchWithdrawERC1155;\n\n        assertEq(IERC1155(erc1155).balanceOf(bob.addr, 1), 0);\n        assertEq(IERC1155(erc1155).balanceOf(bob.addr, 2), 0);\n        assertEq(IERC1155(erc1155).balanceOf(bob.addr, 3), 0);\n\n        bob.buyoutModule.multicall(data);\n\n        assertEq(IERC1155(erc1155).balanceOf(bob.addr, 1), 10);\n        assertEq(IERC1155(erc1155).balanceOf(bob.addr, 2), 10);\n        assertEq(IERC1155(erc1155).balanceOf(bob.addr, 3), 10);\n    }\n\n    function testBatchWithdrawERC1155Redeem() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, TOTAL_SUPPLY, true);\n        mintERC1155(vault, 3);\n        bob.buyoutModule.redeem(vault, burnProof);\n\n        bytes memory batchWithdrawERC1155 = initializeBatchWithdrawalERC1155(\n            vault,\n            bob.addr,\n            3\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = batchWithdrawERC1155;\n\n        bob.buyoutModule.multicall(data);\n        assertEq(IERC1155(erc1155).balanceOf(bob.addr, 1), 10);\n        assertEq(IERC1155(erc1155).balanceOf(bob.addr, 2), 10);\n        assertEq(IERC1155(erc1155).balanceOf(bob.addr, 3), 10);\n    }\n\n    function testBatchWithdrawERC1155RevertNotAVault() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpBatchWithdrawERC1155(alice, bob);\n\n        bytes memory batchWithdrawERC1155 = initializeBatchWithdrawalERC1155(\n            address(baseVault),\n            bob.addr,\n            3\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = batchWithdrawERC1155;\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.NotVault.selector,\n                address(baseVault)\n            )\n        );\n        bob.buyoutModule.multicall(data);\n    }\n\n    function testBatchWithdrawERC1155RevertStateINACTIVE() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        alice.buyoutModule.buyFractions{value: 0.2 ether}(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n        bob.buyoutModule.end(vault, burnProof);\n\n        uint256[] memory ids = new uint256[](3);\n        uint256[] memory amounts = new uint256[](3);\n        for (uint256 i; i < 3; i++) {\n            ids[i] = i + 1;\n            amounts[i] = 10;\n        }\n\n        revertBuyoutState(State.SUCCESS, State.INACTIVE);\n        bob.buyoutModule.batchWithdrawERC1155(\n            vault,\n            address(erc1155),\n            bob.addr,\n            ids,\n            amounts,\n            erc1155BatchTransferProof\n        );\n    }\n\n    function testBatchWithdrawERC1155RevertNotAllowed() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpBatchWithdrawERC1155(alice, bob);\n\n        bytes memory batchWithdrawERC1155 = initializeBatchWithdrawalERC1155(\n            vault,\n            alice.addr,\n            3\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = batchWithdrawERC1155;\n\n        vm.expectRevert(abi.encodeWithSelector(IBuyout.NotWinner.selector));\n        alice.buyoutModule.multicall(data);\n    }\n\n    /// ============================\n    /// ===== WITHDRAW ERC20 =======\n    /// ============================\n    function testWithdrawERC20() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpWithdrawERC20(alice, bob);\n\n        bytes memory withdrawERC20 = initializeWithdrawalERC20(\n            vault,\n            bob.addr,\n            10\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = withdrawERC20;\n        IERC20(erc20).balanceOf(vault);\n        assertEq(IERC20(erc20).balanceOf(bob.addr), 0);\n        bob.buyoutModule.multicall(data);\n        assertEq(IERC20(erc20).balanceOf(bob.addr), 10);\n    }\n\n    function testWithdrawERC20Redeem() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, TOTAL_SUPPLY, true);\n        MockERC20(erc20).mint(vault, 10);\n        bob.buyoutModule.redeem(vault, burnProof);\n\n        bytes memory withdrawERC20 = initializeWithdrawalERC20(\n            vault,\n            bob.addr,\n            10\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = withdrawERC20;\n        IERC20(erc20).balanceOf(vault);\n        bob.buyoutModule.multicall(data);\n        assertEq(IERC20(erc20).balanceOf(bob.addr), 10);\n    }\n\n    function testWithdrawERC20RevertNotAVault() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpWithdrawERC1155(alice, bob);\n\n        bytes memory withdrawERC20 = initializeWithdrawalERC20(\n            address(baseVault),\n            bob.addr,\n            10\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = withdrawERC20;\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IBuyout.NotVault.selector,\n                address(baseVault)\n            )\n        );\n        bob.buyoutModule.multicall(data);\n    }\n\n    function testWithdrawERC20RevertStateINACTIVE() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n\n        bob.buyoutModule.start{value: 1 ether}(vault);\n        alice.buyoutModule.buyFractions{value: 0.2 ether}(vault, 1000);\n        vm.warp(rejectionPeriod + 1);\n        bob.buyoutModule.end(vault, burnProof);\n\n        revertBuyoutState(State.SUCCESS, State.INACTIVE);\n        bob.buyoutModule.withdrawERC20(\n            vault,\n            address(erc20),\n            bob.addr,\n            10,\n            erc20TransferProof\n        );\n    }\n\n    function testWithdrawERC20RevertNotAllowed() public {\n        initializeBuyout(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);\n        setUpWithdrawERC20(alice, bob);\n\n        bytes memory withdrawERC20 = initializeWithdrawalERC20(\n            vault,\n            alice.addr,\n            10\n        );\n        bytes[] memory data = new bytes[](1);\n        data[0] = withdrawERC20;\n\n        vm.expectRevert(abi.encodeWithSelector(IBuyout.NotWinner.selector));\n        alice.buyoutModule.multicall(data);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../utils/SelfPermit.sol\";\n\n/// @title Buyout\n/// @author Fractional Art\n/// @notice Module contract for vaults to hold buyout pools\n/// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n/// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n/// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n///   gains access to withdraw the underlying assets (ERC20, ERC721, and ERC1155 tokens) from the vault.\n///   Otherwise the buyout is considered unsuccessful and a new one may then begin.\n/// - NOTE: A vault may only have one active buyout at any given time.\n/// - buyoutPrice = (ethDeposit * 100) / (100 - ((fractionDeposit * 100) / totalSupply))\n/// - buyoutShare = (tokenBalance * ethBalance) / (totalSupply + tokenBalance)\ncontract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Address of Supply target contract\n    address public supply;\n    /// @notice Address of Transfer target contract\n    address public transfer;\n    /// @notice Time length of the proposal period\n    uint256 public constant PROPOSAL_PERIOD = 2 days;\n    /// @notice Time length of the rejection period\n    uint256 public constant REJECTION_PERIOD = 4 days;\n    /// @notice Mapping of vault address to auction struct\n    mapping(address => Auction) public buyoutInfo;\n\n    /// @notice Initializes registry, supply, and transfer contracts\n    constructor(\n        address _registry,\n        address _supply,\n        address _transfer\n    ) {\n        registry = _registry;\n        supply = _supply;\n        transfer = _transfer;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Starts the auction for a buyout pool\n    /// @param _vault Address of the vault\n    function start(address _vault) external payable {\n        // Reverts if ether deposit amount is zero\n        if (msg.value == 0) revert ZeroDeposit();\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Gets total supply of fractional tokens for the vault\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        // Gets total balance of fractional tokens owned by caller\n        uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id);\n\n        // Transfers fractional tokens into the buyout pool\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            depositAmount,\n            \"\"\n        );\n\n        // Calculates price of buyout and fractions\n        // @dev Reverts with division error if called with total supply of tokens\n        uint256 buyoutPrice = (msg.value * 100) /\n            (100 - ((depositAmount * 100) / totalSupply));\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n\n        // Sets info mapping of the vault address to auction struct\n        buyoutInfo[_vault] = Auction(\n            block.timestamp,\n            msg.sender,\n            State.LIVE,\n            fractionPrice,\n            msg.value,\n            totalSupply\n        );\n        // Emits event for starting auction\n        emit Start(\n            _vault,\n            msg.sender,\n            block.timestamp,\n            buyoutPrice,\n            fractionPrice\n        );\n    }\n\n    /// @notice Sells fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function sellFractions(address _vault, uint256 _amount) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        // Reverts if auction state is not live\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of proposal period\n        uint256 endTime = startTime + PROPOSAL_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n\n        // Transfers fractional tokens to pool from caller\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n\n        // Updates ether balance of pool\n        uint256 ethAmount = fractionPrice * _amount;\n        buyoutInfo[_vault].ethBalance -= ethAmount;\n        // Transfers ether amount to caller\n        _sendEthOrWeth(msg.sender, ethAmount);\n        // Emits event for selling fractions into pool\n        emit SellFractions(msg.sender, _amount);\n    }\n\n    /// @notice Buys fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function buyFractions(address _vault, uint256 _amount) external payable {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of rejection period\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n        // Reverts if payment amount does not equal price of fractional amount\n        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n\n        // Transfers fractional tokens to caller\n        IERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates ether balance of pool\n        buyoutInfo[_vault].ethBalance += msg.value;\n        // Emits event for buying fractions from pool\n        emit BuyFractions(msg.sender, _amount);\n    }\n\n    /// @notice Ends the auction for a live buyout pool\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function end(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (\n            uint256 startTime,\n            address proposer,\n            State current,\n            ,\n            uint256 ethBalance,\n\n        ) = this.buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is less than or equal to end time of auction\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp <= endTime)\n            revert TimeNotElapsed(block.timestamp, endTime);\n\n        uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n        // Checks totalSupply of auction pool to determine if buyout is successful or not\n        if (\n            (tokenBalance * 1000) /\n                IVaultRegistry(registry).totalSupply(_vault) >\n            500\n        ) {\n            // Initializes vault transaction\n            bytes memory data = abi.encodeCall(\n                ISupply.burn,\n                (address(this), tokenBalance)\n            );\n            // Executes burn of fractional tokens from pool\n            IVault(payable(_vault)).execute(supply, data, _burnProof);\n            // Sets buyout state to successful\n            buyoutInfo[_vault].state = State.SUCCESS;\n            // Emits event for ending successful auction\n            emit End(_vault, State.SUCCESS, proposer);\n        } else {\n            // Deletes auction info\n            delete buyoutInfo[_vault];\n            // Transfers fractions and ether back to proposer of the buyout pool\n            IERC1155(token).safeTransferFrom(\n                address(this),\n                proposer,\n                id,\n                tokenBalance,\n                \"\"\n            );\n            _sendEthOrWeth(proposer, ethBalance);\n            // Emits event for ending unsuccessful auction\n            emit End(_vault, State.INACTIVE, proposer);\n        }\n    }\n\n    /// @notice Cashes out proceeds from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller has a balance of zero fractional tokens\n        uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n        if (tokenBalance == 0) revert NoFractions();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, tokenBalance)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Transfers buyout share amount to caller based on total supply\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        uint256 buyoutShare = (tokenBalance * ethBalance) /\n            (totalSupply + tokenBalance);\n        _sendEthOrWeth(msg.sender, buyoutShare);\n        // Emits event for cashing out of buyout pool\n        emit Cash(_vault, msg.sender, buyoutShare);\n    }\n\n    /// @notice Terminates a vault with an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function redeem(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Initializes vault transaction\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, totalSupply)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Sets buyout state to successful and proposer to caller\n        (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = (\n            State.SUCCESS,\n            msg.sender\n        );\n        // Emits event for redeem underlying assets from the vault\n        emit Redeem(_vault, msg.sender);\n    }\n\n    /// @notice Withdraws an ERC-20 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _value Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC20Transfer,\n            (_token, _to, _value)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-721 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC721TransferFrom,\n            (_token, _vault, _to, _tokenId)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-1155 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _id ID of the token type\n    /// @param _value Transfer amount\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155TransferFrom,\n            (_token, _vault, _to, _id, _value)\n        );\n        // Executes transfer of ERC1155 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc1155TransferProof);\n    }\n\n    /// @notice Batch withdraws ERC-1155 tokens from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _ids IDs of each token type\n    /// @param _values Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for transferring multiple ERC-1155 tokens\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155BatchTransferFrom,\n            (_token, _vault, _to, _ids, _values)\n        );\n        // Executes batch transfer of multiple ERC1155 tokens to caller\n        IVault(payable(_vault)).execute(\n            transfer,\n            data,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Gets the list of leaf nodes used to generate a merkle tree\n    /// @dev Leaf nodes are hashed permissions of the merkle tree\n    /// @return nodes Hashes of leaf nodes\n    function getLeafNodes() external view returns (bytes32[] memory nodes) {\n        nodes = new bytes32[](5);\n        // Gets list of permissions from this module\n        Permission[] memory permissions = getPermissions();\n        for (uint256 i; i < permissions.length; ) {\n            // Hashes permission into leaf node\n            nodes[i] = keccak256(abi.encode(permissions[i]));\n            // Can't overflow since loop is a fixed size\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets the list of permissions installed on a vault\n    /// @dev Permissions consist of a module contract, target contract, and function selector\n    /// @return permissions List of vault permissions\n    function getPermissions()\n        public\n        view\n        returns (Permission[] memory permissions)\n    {\n        permissions = new Permission[](5);\n        // Burn function selector from supply contract\n        permissions[0] = Permission(\n            address(this),\n            supply,\n            ISupply(supply).burn.selector\n        );\n        // ERC20Transfer function selector from transfer contract\n        permissions[1] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC20Transfer.selector\n        );\n        // ERC721TransferFrom function selector from transfer contract\n        permissions[2] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC721TransferFrom.selector\n        );\n        // ERC1155TransferFrom function selector from transfer contract\n        permissions[3] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155TransferFrom.selector\n        );\n        // ERC1155BatchTransferFrom function selector from transfer contract\n        permissions[4] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155BatchTransferFrom.selector\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "Buyout.t.sol",
            "Buyout.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Buyout Module: redeeming before the update of totalSupply",
                "Type": "State manipulation",
                "Description": "A vault can be created with an incorrect buyout status due to totalSupply being updated after an external call.",
                "Repair": "Update totalSupply before _mint"
            },
            {
                "Location": "Buyout.cash function",
                "Type": "Incorrect Calculation",
                "Description": "The calculation of buyoutShare in Buyout.cash is wrong as it uses the initial Ether balance stored in buyoutInfo[_vault].ethBalance. Each consecutive cash-out will lead to a user receiving more Ether, ultimately draining the Ether funds of the Buyout contract.",
                "Repair": "Decrement ethBalance from buyout info buyoutInfo[_vault].ethBalance -= buyoutShare;"
            },
            {
                "Location": "end function in the Buyout contract",
                "Type": "Time constraint bypass",
                "Description": "The time constraint of selling fractions can be bypassed by directly transferring fraction tokens to the buyout contract.",
                "Repair": "Add a new field to record the amount of fraction tokens deposited by sellFractions. And in the end function, use the newly-added field to determine whether the buyout can be processed or not."
            },
            {
                "Location": "Buyout module",
                "Type": "Denial of Service (DoS)",
                "Description": "An attacker can DoS vault's buyout with as little as 1 wei per 4 days.",
                "Repair": "While a buyout is running allow other users to offer a higher buyout. Alternately, you can require a user to hold a minimum percent of fractions to start a buyout, this way if the offer is unrealistically low the user would lose their fractions. Effectively putting a price tag for DoS-ing a vault."
            },
            {
                "Location": "end() function in Buyout.sol",
                "Type": "Forced buyouts by malicious buyers",
                "Description": "Forced buyouts can be performed by malicious buyers.",
                "Repair": "Save the status of the proposer after a failed buyout and implement functions to allow the proposer to withdraw the ERC1155 tokens and eth"
            },
            {
                "Location": "start() function in Buyout.sol",
                "Type": "Perpetual buyout",
                "Description": "Proposer can start a perpetual buyout which can only end if the auction succeeds and is not rejected.",
                "Repair": "Prevent re-entrancy in the start() function by using the nonReentrant modifier provided by OpenZeppelin's ReentrancyGuard contract, or use an equivalent custom solution"
            },
            {
                "Location": "Buyout module",
                "Type": "Inconsistent State Variable",
                "Description": "The total supply might change between the time the buyout starts till the buy/sell time, and the fractionPrice stored in the module might not represent the real price anymore. This can cause issues such as the buyout proposer paying the entire buyout price but ending up with only part of the vault, users buying fractions for more than they're really worth, and users getting a lower price than intended while selling their fractions.",
                "Repair": "Calculate fraction price at the time of buy/sell according to the current total supply and add functionality to update the lastTotalSupply with an event notifying about the fraction-price change before the user buys/sells"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport \"./TestUtil.sol\";\n\ncontract VaultTest is TestUtil {\n    /// =================\n    /// ===== SETUP =====\n    /// =================\n    function setUp() public {\n        setUpContract();\n        vaultProxy = new Vault();\n        vault = address(vaultProxy);\n        alice = setUpUser(111, 1);\n        alice.vaultProxy = new VaultBS(address(0), 111, vault);\n\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n\n        vm.label(address(this), \"VaultTest\");\n        vm.label(vault, \"VaultProxy\");\n        vm.label(alice.addr, \"Alice\");\n    }\n\n    /// ============================\n    /// ===== INITIALIZE PROXY =====\n    /// ============================\n    function testInit() public {\n        assertEq(vaultProxy.nonce(), 0);\n        assertEq(vaultProxy.owner(), address(0));\n\n        vaultProxy.init();\n\n        assertEq(vaultProxy.nonce(), 1);\n        assertEq(vaultProxy.owner(), address(this));\n    }\n\n    function testInitRevertInvalidNonce() public {\n        vaultProxy.init();\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IVault.Initialized.selector,\n                vaultProxy.owner(),\n                address(this),\n                vaultProxy.nonce()\n            )\n        );\n        vaultProxy.init();\n    }\n\n    /// ==============================\n    /// ===== TRANSFER OWNERSHIP =====\n    /// ==============================\n    function testTransferOwnership(address _newOwner) public {\n        alice.vaultProxy.init();\n        alice.vaultProxy.transferOwnership(_newOwner);\n\n        assertEq(vaultProxy.owner(), _newOwner);\n    }\n\n    function testTransferOwnershipRevertNotOwner(address _newOwner) public {\n        vm.assume(_newOwner != address(this));\n        vaultProxy.init();\n        vaultProxy.transferOwnership(_newOwner);\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IVault.NotOwner.selector,\n                _newOwner,\n                address(this)\n            )\n        );\n        vaultProxy.transferOwnership(alice.addr);\n    }\n\n    /// ===========================\n    /// ===== SET MERKLE ROOT =====\n    /// ===========================\n    function testSetMerkleRoot() public {\n        vaultProxy.init();\n        vaultProxy.setMerkleRoot(merkleRoot);\n\n        assertEq(vaultProxy.merkleRoot(), merkleRoot);\n    }\n\n    function testSetMerkleRootRevertNotOwner() public {\n        vaultProxy.init();\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IVault.NotOwner.selector,\n                address(this),\n                alice.addr\n            )\n        );\n        alice.vaultProxy.setMerkleRoot(merkleRoot);\n    }\n\n    /// =========================\n    /// ===== RECEIVE TOKEN =====\n    /// =========================\n    function testReceiveEther() public {\n        vaultProxy.init();\n        payable(vault).transfer(1 ether);\n\n        assertEq(vault.balance, 1 ether);\n    }\n\n    function testReceiveERC721() public {\n        vaultProxy.init();\n        vaultProxy.install(nftReceiverSelectors, nftReceiverPlugins);\n        MockERC721(erc721).mint(vault, 2);\n\n        assertEq(IERC721(erc721).balanceOf(vault), 1);\n    }\n\n    function testReceiveERC1155() public {\n        vaultProxy.init();\n        vaultProxy.install(nftReceiverSelectors, nftReceiverPlugins);\n        mintERC1155(vault, 1);\n\n        assertEq(IERC1155(erc1155).balanceOf(vault, 1), 10);\n    }\n\n    /// ===================\n    /// ===== EXECUTE =====\n    /// ===================\n    function testExecute() public {\n        bytes memory data = setUpExecute(alice);\n        vaultProxy.execute(address(transferTarget), data, erc721TransferProof);\n\n        assertEq(IERC721(erc721).balanceOf(vault), 0);\n        assertEq(IERC721(erc721).balanceOf(alice.addr), 1);\n    }\n\n    function testExecuteRevert() public {\n        bytes memory data = setUpExecute(alice);\n        vm.expectRevert(\n            abi.encodeWithSelector(IVault.ExecutionReverted.selector)\n        );\n        vaultProxy.execute(address(supplyTarget), data, erc721TransferProof);\n    }\n\n    function testExecuteRevertNotAuthorized() public {\n        bytes memory data = setUpExecute(alice);\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IVault.NotAuthorized.selector,\n                alice.addr,\n                address(transferTarget),\n                transferTarget.ERC721TransferFrom.selector\n            )\n        );\n        alice.vaultProxy.execute(\n            address(transferTarget),\n            data,\n            erc721TransferProof\n        );\n    }\n\n    function testExecuteRevertTargetInvalid() public {\n        bytes memory data = setUpExecute(alice);\n        vm.expectRevert(\n            abi.encodeWithSelector(IVault.TargetInvalid.selector, alice.addr)\n        );\n        vaultProxy.execute(alice.addr, data, erc721TransferProof);\n    }\n\n    function testExecuteRevertNotOwner() public {\n        vaultProxy.init();\n        TargetContract targetContract = new TargetContract();\n        bytes32[] memory proof = new bytes32[](1);\n        proof[0] = keccak256(\n            abi.encode(\n                alice.addr,\n                address(targetContract),\n                TargetContract.transferOwnership.selector\n            )\n        );\n        vaultProxy.setMerkleRoot(proof[0]);\n        bytes memory data = abi.encodeCall(\n            targetContract.transferOwnership,\n            ()\n        );\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IVault.NotOwner.selector,\n                address(this),\n                address(vaultProxy)\n            )\n        );\n        vaultProxy.execute(address(targetContract), data, proof);\n    }\n\n    function testExecuteRevertOwnerChanged() public {\n        vaultProxy.init();\n        TargetContract targetContract = new TargetContract();\n        bytes32[] memory proof = new bytes32[](1);\n        proof[0] = keccak256(\n            abi.encode(\n                alice.addr,\n                address(targetContract),\n                TargetContract.changeOwner.selector\n            )\n        );\n        vaultProxy.setMerkleRoot(proof[0]);\n        bytes memory data = abi.encodeCall(\n            targetContract.changeOwner,\n            (alice.addr)\n        );\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IVault.OwnerChanged.selector,\n                address(this),\n                alice.addr\n            )\n        );\n        vaultProxy.execute(address(targetContract), data, proof);\n    }\n}\n\ncontract TargetContract {\n    address public owner;\n\n    function changeOwner(address _owner) public {\n        owner = _owner;\n    }\n\n    function transferOwnership() external {\n        Vault(payable(address(this))).transferOwnership(address(1));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.t.sol",
            "Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "fallback() function in Vault contract",
                "Type": "Bypassing permission checks",
                "Description": "Vault owners can install plugins via Vault.install(), with calls to the installed plugins made through the vault's fallback function. Unlike the vault's external Vault.execute() function, fallback() imposes no checks on the permissions of the caller.",
                "Repair": "Track which installed plugins require permissions alongside the methods mapping in storage and use auths[plugin] in fallback()"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\";\nimport {FERC1155} from \"./FERC1155.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IVaultRegistry, VaultInfo} from \"./interfaces/IVaultRegistry.sol\";\nimport {VaultFactory} from \"./VaultFactory.sol\";\n\n/// @title Vault Registry\n/// @author Fractional Art\n/// @notice Registry contract for tracking all fractional vaults\ncontract VaultRegistry is IVaultRegistry {\n    /// @dev Use clones library with address types\n    using ClonesWithImmutableArgs for address;\n    /// @notice Address of VaultFactory contract\n    address public immutable factory;\n    /// @notice Address of FERC1155 token contract\n    address public immutable fNFT;\n    /// @notice Address of Implementation for FERC1155 token contract\n    address public immutable fNFTImplementation;\n    /// @notice Mapping of collection address to next token ID type\n    mapping(address => uint256) public nextId;\n    /// @notice Mapping of vault address to vault information\n    mapping(address => VaultInfo) public vaultToToken;\n\n    /// @notice Initializes factory, implementation, and token contracts\n    constructor() {\n        factory = address(new VaultFactory());\n        fNFTImplementation = address(new FERC1155());\n        fNFT = fNFTImplementation.clone(\n            abi.encodePacked(msg.sender, address(this))\n        );\n    }\n\n    /// @notice Burns vault tokens\n    /// @param _from Source address\n    /// @param _value Amount of tokens\n    function burn(address _from, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).burn(_from, id, _value);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function create(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins, and transfers ownership to a given owner\n    /// @dev This should only be done in limited cases i.e. if you're okay with a trusted individual(s)\n    /// having control over the vault. Ideally, execution would be locked behind a Multisig wallet.\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _owner Address of the vault owner\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createFor(\n        bytes32 _merkleRoot,\n        address _owner,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n        IVault(vault).transferOwnership(_owner);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for the message sender\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollection(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault, address token) {\n        (vault, token) = createCollectionFor(\n            _merkleRoot,\n            msg.sender,\n            _plugins,\n            _selectors\n        );\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for an existing collection\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createInCollection(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        address controller = FERC1155(_token).controller();\n        if (controller != msg.sender)\n            revert InvalidController(controller, msg.sender);\n        vault = _deployVault(_merkleRoot, _token, _plugins, _selectors);\n    }\n\n    /// @notice Mints vault tokens\n    /// @param _to Target address\n    /// @param _value Amount of tokens\n    function mint(address _to, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).mint(_to, id, _value, \"\");\n    }\n\n    /// @notice Gets the total supply for a token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return Total supply\n    function totalSupply(address _vault) external view returns (uint256) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).totalSupply(info.id);\n    }\n\n    /// @notice Gets the uri for a given token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return URI of token\n    function uri(address _vault) external view returns (string memory) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).uri(info.id);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for a given controller\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _controller Address of token controller\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollectionFor(\n        bytes32 _merkleRoot,\n        address _controller,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) public returns (address vault, address token) {\n        token = fNFTImplementation.clone(\n            abi.encodePacked(_controller, address(this))\n        );\n        vault = _deployVault(_merkleRoot, token, _plugins, _selectors);\n    }\n\n    /// @dev Deploys new vault for specified token, sets merkle root, and installs plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function _deployVault(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) private returns (address vault) {\n        vault = VaultFactory(factory).deploy();\n        vaultToToken[vault] = VaultInfo(_token, ++nextId[_token]);\n        IVault(vault).setMerkleRoot(_merkleRoot);\n        IVault(vault).install(_selectors, _plugins);\n\n        emit VaultDeployed(vault, _token, nextId[_token]);\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport \"./TestUtil.sol\";\n\ncontract VaultRegistryTest is TestUtil {\n    /// =================\n    /// ===== SETUP =====\n    /// =================\n    function setUp() public {\n        setUpContract();\n        alice = setUpUser(111, 1);\n        bob = setUpUser(222, 2);\n        setUpCreateFor(alice);\n        (nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();\n\n        vm.label(address(this), \"VaultRegistryTest\");\n        vm.label(alice.addr, \"Alice\");\n        vm.label(bob.addr, \"Bob\");\n    }\n\n    /// ========================\n    /// ===== CREATE VAULT =====\n    /// ========================\n    function testCreate() public {\n        vault = alice.registry.create(\n            merkleRoot,\n            nftReceiverPlugins,\n            nftReceiverSelectors\n        );\n        token = registry.fNFT();\n        setUpFERC1155(alice, token);\n\n        assertEq(IVault(vault).owner(), address(registry));\n        assertEq(fERC1155.controller(), address(this));\n    }\n\n    function testCreateFor() public {\n        vault = alice.registry.createFor(\n            merkleRoot,\n            alice.addr,\n            nftReceiverPlugins,\n            nftReceiverSelectors\n        );\n        token = registry.fNFT();\n        setUpFERC1155(alice, token);\n\n        assertEq(IVault(vault).owner(), alice.addr);\n        assertEq(fERC1155.controller(), address(this));\n    }\n\n    function testCreateCollection() public {\n        (vault, token) = alice.registry.createCollection(\n            merkleRoot,\n            nftReceiverPlugins,\n            nftReceiverSelectors\n        );\n\n        assertEq(IVault(vault).owner(), address(registry));\n        assertEq(IFERC1155(token).controller(), alice.addr);\n    }\n\n    function testCreateCollectionFor() public {\n        (vault, token) = alice.registry.createCollectionFor(\n            merkleRoot,\n            bob.addr,\n            nftReceiverPlugins,\n            nftReceiverSelectors\n        );\n\n        assertEq(IVault(vault).owner(), address(registry));\n        assertEq(IFERC1155(token).controller(), bob.addr);\n    }\n\n    function testCreateInCollection() public {\n        testCreateCollectionFor();\n\n        vault = bob.registry.createInCollection(\n            merkleRoot,\n            token,\n            nftReceiverPlugins,\n            nftReceiverSelectors\n        );\n\n        assertEq(IVault(vault).owner(), address(registry));\n        assertEq(IFERC1155(token).controller(), bob.addr);\n    }\n\n    function testCreateInCollectionRevertNotController() public {\n        token = registry.fNFT();\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IVaultRegistry.InvalidController.selector,\n                address(this),\n                bob.addr\n            )\n        );\n        bob.registry.createInCollection(\n            merkleRoot,\n            token,\n            nftReceiverPlugins,\n            nftReceiverSelectors\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/// @dev Interface for Vault proxy contract\ninterface IVault {\n    /// @dev Emitted when execution reverted with no reason\n    error ExecutionReverted();\n    /// @dev Emitted when ownership of the proxy has been renounced\n    error Initialized(address _owner, address _newOwner, uint256 _nonce);\n    /// @dev Emitted when there is no implementation stored in methods for a function signature\n    error MethodNotFound();\n    /// @dev Emitted when the caller is not the owner\n    error NotAuthorized(address _caller, address _target, bytes4 _selector);\n    /// @dev Emitted when the caller is not the owner\n    error NotOwner(address _owner, address _caller);\n    /// @dev Emitted when the owner is changed during the DELEGATECALL\n    error OwnerChanged(address _originalOwner, address _newOwner);\n    /// @dev Emitted when passing an EOA or an undeployed contract as the target\n    error TargetInvalid(address _target);\n\n    /// @dev Event log for executing transactions\n    /// @param _target Address of target contract\n    /// @param _data Transaction data being executed\n    /// @param _response Return data of delegatecall\n    event Execute(address indexed _target, bytes _data, bytes _response);\n    /// @dev Event log for installing plugins\n    /// @param _selectors List of function selectors\n    /// @param _plugins List of plugin contracts\n    event InstallPlugin(bytes4[] _selectors, address[] _plugins);\n    /// @dev Event log for transferring ownership\n    /// @param _oldOwner Address of old owner\n    /// @param _newOwner Address of new owner\n    event TransferOwnership(\n        address indexed _oldOwner,\n        address indexed _newOwner\n    );\n    /// @dev Event log for uninstalling plugins\n    /// @param _selectors List of function selectors\n    event UninstallPlugin(bytes4[] _selectors);\n\n    function execute(\n        address _target,\n        bytes memory _data,\n        bytes32[] memory _proof\n    ) external payable returns (bool success, bytes memory response);\n\n    function init() external;\n\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external;\n\n    function merkleRoot() external view returns (bytes32);\n\n    function methods(bytes4) external view returns (address);\n\n    function nonce() external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function setMerkleRoot(bytes32 _rootHash) external;\n\n    function transferOwnership(address _newOwner) external;\n\n    function uninstall(bytes4[] memory _selectors) external;\n}\n\n\n",
        "CodeNames": [
            "VaultRegistry.sol",
            "VaultRegistry.t.sol",
            "IVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaultRegistry.createFor(), IVault.methods(), IVault.install()",
                "Type": "Overwriting Plugin Implementation",
                "Description": "A vault owner can frontrun a plugin call and change its implementation by overwriting a current plugin selector with a new address and change the implementation of that plugin at any time. This can be used to bypass the need to uninstall a plugin by overwriting a currently installed one with a different implementation without needing to first remove the old plugin and then install the new one.",
                "Repair": "Check if the plugin that is willing to be installed is not overwriting the methods mapping and if plugins are not intended to work as emergency functions that need to be injected into a vault quickly, consider timelocking the process of plugin installation."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "baseVault.batchDepositERC20, baseVault.batchDepositERC721, and baseVault.batchDepositERC1155 functions",
                "Type": "Residual Allowance Exploit",
                "Description": "Malicious users can exploit residual allowance to steal assets from depositors in the BaseVault contract.",
                "Repair": "Update the affected functions to remove the 'from' parameter, and use 'msg.sender' instead"
            },
            {
                "Location": "modules/Migration.sol::commit",
                "Type": "Re-entrancy",
                "Description": "Assets can be compromised directly. One can drain eth out from migration module to buyout module using custom made FERC1155 token.",
                "Repair": "Follow Checks, Effects, Interactions patterns. One can also consider adding reentrancy guard."
            },
            {
                "Location": "modules/Migration.sol::join, modules/Migration.sol::leave",
                "Type": "Mismatched Parameters",
                "Description": "When joining or leaving a migration proposal, Fractional does not check whether the user supplied proposalId and vault match the actual vault that the proposal belongs to. This allows the user to trick the accounting. Loss of funds for users.",
                "Repair": "Save for each proposal which vault it corresponds to. Verify that user supplies a matching vault-proposal pair, or he can even just supply proposal and the contract will get the vault from that. Another solution would be to have userProposalFractions save the relevant vault also, not just a general proposal id."
            },
            {
                "Location": "src/modules/Migration.sol#L194",
                "Type": "Replay Attack",
                "Description": "Failed proposal can be committed again and eth stolen from migration contract in combination with other vulnerabilities submitted.",
                "Repair": "Change the length of either the migration period or the buyout period to match so that a proposal can't be replayed."
            },
            {
                "Location": "Divisions in EVM",
                "Type": "Division rounding",
                "Description": "Divisions in EVM are rounded down, which means when the fraction price is close to 1 (e.g. 0.999) it would effectively be zero, when it's close to 2 (1.999) it would be rounded to 1 losing close to 50% of the intended price.",
                "Repair": "Request the user to send the intended fraction price (as a function arg) and then make sure he sent enough ETH. This way the user is well aware of the fraction price."
            },
            {
                "Location": "src/modules/Migration.sol, lines 159-172 and 320-325",
                "Type": "Use of payable.transfer() may lock user funds",
                "Description": "The use of payable.transfer() can lead to the locking of funds if the recipient does not have a payable callback, the callback spends more than 2300 gas, or the contract is called through a proxy which itself uses up the 2300 gas.",
                "Repair": "Use address.call{value:x}() instead of payable.transfer()"
            },
            {
                "Location": "Migrations.sol, function migrateFractions",
                "Type": "migrateFractions may be called more than once by the same user which may lead to loss of tokens for other users",
                "Description": "The migrateFractions function does not check if the user had already called it, allowing a user to gain more new vault tokens than they are owed, potentially causing other users to not be able to get their new tokens.",
                "Repair": "Set the userProposalEth and userProposalFractions to 0 after the user's tokens have been migrated"
            },
            {
                "Location": "Migration's leave function",
                "Type": "User assets loss",
                "Description": "The leave function allows leaving a proposal even if the proposal has been committed and failed, which makes it a duplicate functionality of withdrawContributions. If leave does not check if the proposal has been committed, users could call leave instead of withdrawContribution and get back a different amount of assets than they deserve, on the expense of other users.",
                "Repair": "Add a check in the leave function to verify if the proposal has been committed before returning the original contribution. Alternatively, merge the functionality of leave and withdrawContribution."
            },
            {
                "Location": "Vault#_execute function",
                "Type": "Ownership takeover",
                "Description": "The Vault#execute function calls a target contract's function via delegatecall, which can alter the Vault's ownership if the nonce variable is re-set to 0. Changing the owner variable is not the only way the callee contract is able to overtake the Vault's ownership. Due to the high number of security issues in connection to faulty usage of delegatecall, the severity is rated as MEDIUM.",
                "Repair": "Check the nonce variable before and after the delegatecall inside the _execute function. Add a test to check if the Vault got re-initialized due to a delegatecall altering the Vault's nonce variable."
            },
            {
                "Location": "settleVault function",
                "Type": "Incorrect state transition",
                "Description": "If one proposal starts a buyout which fails, and then another proposal starts a buyout which succeeds, then both of them will be committed and settleVault can be called on any of them. If it's called on the failed proposal first, then it will settle even though buyout has failed (and it can proceed to withdraw all tokens to a new vault). This can allow a malicious proposal to successfully migrate and steal assets from another proposal.",
                "Repair": "Add a new storage variable for currently active proposal id. Allow calling settleVault only for active proposal id (and also only if buyout's proposer equals Migration address, otherwise there can be a different successful buyout not connected to the active proposal). Also add appropriate checks with active proposal in the other functions as well (don't allow to commit if there is an active proposal etc)."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\";\nimport {FERC1155} from \"./FERC1155.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IVaultRegistry, VaultInfo} from \"./interfaces/IVaultRegistry.sol\";\nimport {VaultFactory} from \"./VaultFactory.sol\";\n\n/// @title Vault Registry\n/// @author Fractional Art\n/// @notice Registry contract for tracking all fractional vaults\ncontract VaultRegistry is IVaultRegistry {\n    /// @dev Use clones library with address types\n    using ClonesWithImmutableArgs for address;\n    /// @notice Address of VaultFactory contract\n    address public immutable factory;\n    /// @notice Address of FERC1155 token contract\n    address public immutable fNFT;\n    /// @notice Address of Implementation for FERC1155 token contract\n    address public immutable fNFTImplementation;\n    /// @notice Mapping of collection address to next token ID type\n    mapping(address => uint256) public nextId;\n    /// @notice Mapping of vault address to vault information\n    mapping(address => VaultInfo) public vaultToToken;\n\n    /// @notice Initializes factory, implementation, and token contracts\n    constructor() {\n        factory = address(new VaultFactory());\n        fNFTImplementation = address(new FERC1155());\n        fNFT = fNFTImplementation.clone(\n            abi.encodePacked(msg.sender, address(this))\n        );\n    }\n\n    /// @notice Burns vault tokens\n    /// @param _from Source address\n    /// @param _value Amount of tokens\n    function burn(address _from, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).burn(_from, id, _value);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function create(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins, and transfers ownership to a given owner\n    /// @dev This should only be done in limited cases i.e. if you're okay with a trusted individual(s)\n    /// having control over the vault. Ideally, execution would be locked behind a Multisig wallet.\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _owner Address of the vault owner\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createFor(\n        bytes32 _merkleRoot,\n        address _owner,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n        IVault(vault).transferOwnership(_owner);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for the message sender\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollection(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault, address token) {\n        (vault, token) = createCollectionFor(\n            _merkleRoot,\n            msg.sender,\n            _plugins,\n            _selectors\n        );\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for an existing collection\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createInCollection(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        address controller = FERC1155(_token).controller();\n        if (controller != msg.sender)\n            revert InvalidController(controller, msg.sender);\n        vault = _deployVault(_merkleRoot, _token, _plugins, _selectors);\n    }\n\n    /// @notice Mints vault tokens\n    /// @param _to Target address\n    /// @param _value Amount of tokens\n    function mint(address _to, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).mint(_to, id, _value, \"\");\n    }\n\n    /// @notice Gets the total supply for a token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return Total supply\n    function totalSupply(address _vault) external view returns (uint256) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).totalSupply(info.id);\n    }\n\n    /// @notice Gets the uri for a given token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return URI of token\n    function uri(address _vault) external view returns (string memory) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).uri(info.id);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for a given controller\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _controller Address of token controller\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollectionFor(\n        bytes32 _merkleRoot,\n        address _controller,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) public returns (address vault, address token) {\n        token = fNFTImplementation.clone(\n            abi.encodePacked(_controller, address(this))\n        );\n        vault = _deployVault(_merkleRoot, token, _plugins, _selectors);\n    }\n\n    /// @dev Deploys new vault for specified token, sets merkle root, and installs plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function _deployVault(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) private returns (address vault) {\n        vault = VaultFactory(factory).deploy();\n        vaultToToken[vault] = VaultInfo(_token, ++nextId[_token]);\n        IVault(vault).setMerkleRoot(_merkleRoot);\n        IVault(vault).install(_selectors, _plugins);\n\n        emit VaultDeployed(vault, _token, nextId[_token]);\n    }\n}\n\n\n",
        "CodeNames": [
            "VaultRegistry.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaultRegistry.sol#L147",
                "Type": "Arbitrary Setting of Secondary Market Royalties",
                "Description": "A vault owner can also be the controller and arbitrarily set the secondary market royalties.",
                "Repair": "Define clearly how users are intended to deploy vaults under which privileges. Set a maximum cap for the royalties. Set a timelock that function so that vault owners have to wait a certain amount of time before changing the royalties in order to bring predictability for the community."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.13;\n\nimport \"./TestUtil.sol\";\n\ncontract FERC1155Test is TestUtil {\n    string tokenURI = \"token uri\";\n    string contractURI = \"contract uri\";\n    event URI(string value, uint256 indexed id);\n\n    /// =================\n    /// ===== SETUP =====\n    /// =================\n    function setUp() public {\n        setUpContract();\n        alice = setUpUser(111, 1);\n        bob = setUpUser(222, 2);\n        setUpCreateFor(alice);\n        setUpMetadata(alice);\n\n        vm.label(address(this), \"FERC1155Test\");\n        vm.label(alice.addr, \"Alice\");\n        vm.label(bob.addr, \"Bob\");\n    }\n\n    /// ============================\n    /// ===== SET CONTRACT URI =====\n    /// ============================\n    function testSetContractURI() public {\n        fERC1155.setContractURI(contractURI);\n        assertEq(fERC1155.contractURI(), contractURI);\n    }\n\n    function testSetContractURIRevertInvalidSender() public {\n        (token, ) = registry.vaultToToken(vault);\n        setUpFERC1155(bob, token);\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IFERC1155.InvalidSender.selector,\n                fERC1155.controller(),\n                bob.addr\n            )\n        );\n\n        fERC1155.setContractURI(contractURI);\n    }\n\n    /// ========================\n    /// ===== SET METADATA =====\n    /// ========================\n    function testSetMetadata() public {\n        fERC1155.setMetadata(address(metadata), tokenId);\n        assertEq(address(metadata), fERC1155.metadata(tokenId));\n    }\n\n    /// ===================\n    /// ===== SET URI =====\n    /// ===================\n    function testSetURI() public {\n        fERC1155.setMetadata(address(metadata), tokenId);\n\n        vm.expectEmit(true, true, false, true);\n        emit URI(tokenURI, tokenId);\n\n        vm.startPrank(alice.addr);\n        metadata.setURI(tokenId, tokenURI);\n        vm.stopPrank();\n    }\n\n    function testSetURIRevertInvalidSender() public {\n        fERC1155.setMetadata(address(metadata), tokenId);\n\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                IFERC1155.InvalidSender.selector,\n                fERC1155.controller(),\n                address(this)\n            )\n        );\n\n        metadata.setURI(tokenId, tokenURI);\n    }\n\n    /// ======================\n    /// ===== PERMIT ALL =====\n    /// ======================\n    function testPermitAll(bool _approved, uint256 _deadline) public {\n        setUpPermit(alice, _approved, _deadline);\n        (uint8 v, bytes32 r, bytes32 s) = signPermitAll(\n            alice,\n            bob.addr,\n            approved,\n            nonce,\n            deadline\n        );\n\n        fERC1155.permitAll(alice.addr, bob.addr, approved, deadline, v, r, s);\n    }\n\n    function testPermitAllApproval() public {\n        setUpPermit(alice, true, 1);\n        (uint8 v, bytes32 r, bytes32 s) = signPermitAll(\n            alice,\n            bob.addr,\n            approved,\n            nonce,\n            deadline\n        );\n\n        fERC1155.permitAll(alice.addr, bob.addr, approved, deadline, v, r, s);\n        assertTrue(fERC1155.isApprovedForAll(alice.addr, bob.addr));\n    }\n\n    function testPermitAllRemoval() public {\n        testPermitAllApproval();\n        approved = false;\n        (uint8 v, bytes32 r, bytes32 s) = signPermitAll(\n            alice,\n            bob.addr,\n            approved,\n            nonce + 1,\n            deadline\n        );\n\n        fERC1155.permitAll(alice.addr, bob.addr, approved, deadline, v, r, s);\n        assertTrue(!fERC1155.isApprovedForAll(alice.addr, bob.addr));\n    }\n\n    function testFailPermitAllApproved() public {\n        setUpPermit(alice, true, 1);\n        (uint8 v, bytes32 r, bytes32 s) = signPermitAll(\n            alice,\n            bob.addr,\n            !approved,\n            nonce,\n            deadline\n        );\n\n        fERC1155.permitAll(alice.addr, bob.addr, approved, deadline, v, r, s);\n    }\n\n    function testFailPermitAllNonce() public {\n        setUpPermit(alice, true, 1);\n        (uint8 v, bytes32 r, bytes32 s) = signPermitAll(\n            alice,\n            bob.addr,\n            approved,\n            nonce + 1,\n            deadline\n        );\n\n        fERC1155.permitAll(alice.addr, bob.addr, approved, deadline, v, r, s);\n    }\n\n    function testFailPermitAllDeadline() public {\n        setUpPermit(alice, true, 1);\n        vm.warp(deadline + 1);\n        (uint8 v, bytes32 r, bytes32 s) = signPermitAll(\n            alice,\n            bob.addr,\n            approved,\n            nonce,\n            deadline\n        );\n\n        fERC1155.permitAll(alice.addr, bob.addr, approved, deadline, v, r, s);\n    }\n\n    /// =========================\n    /// ===== SINGLE PERMIT =====\n    /// =========================\n    function testSinglePermit(bool _approved, uint256 _deadline) public {\n        setUpPermit(alice, _approved, _deadline);\n        (uint8 v, bytes32 r, bytes32 s) = signPermit(\n            alice,\n            bob.addr,\n            approved,\n            nonce,\n            deadline\n        );\n\n        fERC1155.permit(\n            alice.addr,\n            bob.addr,\n            tokenId,\n            approved,\n            deadline,\n            v,\n            r,\n            s\n        );\n    }\n\n    function testSinglePermitApproval() public {\n        setUpPermit(alice, true, 1);\n        (uint8 v, bytes32 r, bytes32 s) = signPermit(\n            alice,\n            bob.addr,\n            approved,\n            nonce,\n            deadline\n        );\n\n        fERC1155.permit(\n            alice.addr,\n            bob.addr,\n            tokenId,\n            approved,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        assertTrue(fERC1155.isApproved(alice.addr, bob.addr, tokenId));\n    }\n\n    function testSinglePermitRemoval() public {\n        testSinglePermitApproval();\n        approved = false;\n        (uint8 v, bytes32 r, bytes32 s) = signPermit(\n            alice,\n            bob.addr,\n            approved,\n            nonce + 1,\n            deadline\n        );\n\n        fERC1155.permit(\n            alice.addr,\n            bob.addr,\n            tokenId,\n            approved,\n            deadline,\n            v,\n            r,\n            s\n        );\n\n        assertTrue(!fERC1155.isApproved(alice.addr, bob.addr, tokenId));\n    }\n\n    function testFailSinglePermitApproved() public {\n        setUpPermit(alice, true, 1);\n        (uint8 v, bytes32 r, bytes32 s) = signPermit(\n            alice,\n            bob.addr,\n            !approved,\n            nonce,\n            deadline\n        );\n\n        fERC1155.permit(\n            alice.addr,\n            bob.addr,\n            tokenId,\n            approved,\n            deadline,\n            v,\n            r,\n            s\n        );\n    }\n\n    function testFailSinglePermitNonce() public {\n        setUpPermit(alice, true, 1);\n        (uint8 v, bytes32 r, bytes32 s) = signPermit(\n            alice,\n            bob.addr,\n            approved,\n            nonce + 1,\n            deadline\n        );\n\n        fERC1155.permit(\n            alice.addr,\n            bob.addr,\n            tokenId,\n            approved,\n            deadline,\n            v,\n            r,\n            s\n        );\n    }\n\n    function testFailSinglePermitDeadline() public {\n        setUpPermit(alice, true, 1);\n        vm.warp(deadline + 1);\n        (uint8 v, bytes32 r, bytes32 s) = signPermit(\n            alice,\n            bob.addr,\n            approved,\n            nonce,\n            deadline\n        );\n\n        fERC1155.permit(\n            alice.addr,\n            bob.addr,\n            tokenId,\n            approved,\n            deadline,\n            v,\n            r,\n            s\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Clone} from \"clones-with-immutable-args/src/Clone.sol\";\nimport {ERC1155} from \"@rari-capital/solmate/src/tokens/ERC1155.sol\";\nimport {IFERC1155} from \"./interfaces/IFERC1155.sol\";\nimport {INFTReceiver} from \"./interfaces/INFTReceiver.sol\";\nimport \"./constants/Permit.sol\";\n\n/// @title FERC1155\n/// @author Fractional Art\n/// @notice An ERC-1155 implementation for Fractions\ncontract FERC1155 is Clone, ERC1155, IFERC1155 {\n    /// @notice Name of the token contract\n    string public constant NAME = \"FERC1155\";\n    /// @notice Version number of the token contract\n    string public constant VERSION = \"1\";\n    /// @notice Address that can deploy new vaults for this collection, manage metadata, etc\n    address internal _controller;\n    /// @notice URI of contract metadata\n    string public contractURI;\n    /// @notice Mapping of token type approvals owner => operator => tokenId => approved\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        public isApproved;\n    /// @notice Mapping of metadata contracts for token ID types => metadata address\n    mapping(uint256 => address) public metadata;\n    /// @notice Mapping to track account nonces for metadata txs owner => nonces\n    mapping(address => uint256) public nonces;\n    /// @notice Mapping to track total supply for token ID types => totalSupply\n    mapping(uint256 => uint256) public totalSupply;\n    /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress\n    mapping(uint256 => address) private royaltyAddress;\n    /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent\n    mapping(uint256 => uint256) private royaltyPercent;\n\n    /// @notice Modifier for restricting function calls to the controller account\n    modifier onlyController() {\n        address controller_ = controller();\n        if (msg.sender != controller_)\n            revert InvalidSender(controller_, msg.sender);\n        _;\n    }\n\n    /// @notice Modifier for restricting function calls to the VaultRegistry\n    modifier onlyRegistry() {\n        address vaultRegistry = VAULT_REGISTRY();\n        if (msg.sender != vaultRegistry)\n            revert InvalidSender(vaultRegistry, msg.sender);\n        _;\n    }\n\n    /// @notice Burns fractions for an ID\n    /// @param _from Address to burn fraction tokens from\n    /// @param _id Token ID to burn\n    /// @param _amount Number of tokens to burn\n    function burn(\n        address _from,\n        uint256 _id,\n        uint256 _amount\n    ) external onlyRegistry {\n        _burn(_from, _id, _amount);\n        totalSupply[_id] -= _amount;\n    }\n\n    /// @notice Hook to emit the URI update when setting the metadata or updating\n    /// @param _id Token ID metadata was updated for\n    /// @param _uri URI of metadata\n    function emitSetURI(uint256 _id, string memory _uri) external {\n        if (msg.sender != metadata[_id])\n            revert InvalidSender(metadata[_id], msg.sender);\n        emit URI(_uri, _id);\n    }\n\n    /// @notice Mints new fractions for an ID\n    /// @param _to Address to mint fraction tokens to\n    /// @param _id Token ID to mint\n    /// @param _amount Number of tokens to mint\n    /// @param _data Extra calldata to include in the mint\n    function mint(\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external onlyRegistry {\n        _mint(_to, _id, _amount, _data);\n        totalSupply[_id] += _amount;\n    }\n\n    /// @notice Permit function that approves an operator for token type with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permit(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitStructHash(\n                _owner,\n                _operator,\n                _id,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApproved[_owner][_operator][_id] = _approved;\n\n        emit SingleApproval(_owner, _operator, _id, _approved);\n    }\n\n    /// @notice Permit function that approves an operator for all token types with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permitAll(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitAllStructHash(\n                _owner,\n                _operator,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApprovedForAll[_owner][_operator] = _approved;\n\n        emit ApprovalForAll(_owner, _operator, _approved);\n    }\n\n    /// @notice Scoped approvals allow us to eliminate some of the risks associated with setting the approval for an entire collection\n    /// @param _operator Address of spender account\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for operator(spender) account\n    function setApprovalFor(\n        address _operator,\n        uint256 _id,\n        bool _approved\n    ) external {\n        isApproved[msg.sender][_operator][_id] = _approved;\n\n        emit SingleApproval(msg.sender, _operator, _id, _approved);\n    }\n\n    /// @notice Sets the contract metadata\n    /// @param _uri URI of metadata\n    function setContractURI(string calldata _uri) external onlyController {\n        contractURI = _uri;\n    }\n\n    /// @notice Sets the token metadata contract\n    /// @param _metadata Address for metadata contract\n    /// @param _id Token ID to set the metadata for\n    function setMetadata(address _metadata, uint256 _id)\n        external\n        onlyController\n    {\n        metadata[_id] = _metadata;\n        emit SetMetadata(_metadata, _id);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _receiver Address to receive royalties\n    /// @param _percentage Percentage of royalties on secondary sales\n    function setRoyalties(\n        uint256 _id,\n        address _receiver,\n        uint256 _percentage\n    ) external onlyController {\n        royaltyAddress[_id] = _receiver;\n        royaltyPercent[_id] = _percentage;\n        emit SetRoyalty(_receiver, _id, _percentage);\n    }\n\n    /// @notice Updates the controller address for the FERC1155 token contract\n    /// @param _newController Address of new controlling entity\n    function transferController(address _newController)\n        external\n        onlyController\n    {\n        if (_newController == address(0)) revert ZeroAddress();\n        _controller = _newController;\n        emit ControllerTransferred(_newController);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _salePrice Sale price to calculate the royalty for\n    function royaltyInfo(uint256 _id, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        receiver = royaltyAddress[_id];\n        royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100;\n    }\n\n    /// @notice Transfer an amount of a token type between two accounts\n    /// @param _from Source address for an amount of tokens\n    /// @param _to Destination address for an amount of tokens\n    /// @param _id ID of the token type\n    /// @param _amount The amount of tokens being transferred\n    /// @param _data Additional calldata\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override(ERC1155, IFERC1155) {\n        require(\n            msg.sender == _from ||\n                isApprovedForAll[_from][msg.sender] ||\n                isApproved[_from][msg.sender][_id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        balanceOf[_from][_id] -= _amount;\n        balanceOf[_to][_id] += _amount;\n\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n\n        require(\n            _to.code.length == 0\n                ? _to != address(0)\n                : INFTReceiver(_to).onERC1155Received(\n                    msg.sender,\n                    _from,\n                    _id,\n                    _amount,\n                    _data\n                ) == INFTReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /// @notice Getter for URI of a token type\n    /// @param _id ID of the token type\n    function uri(uint256 _id)\n        public\n        view\n        override(ERC1155, IFERC1155)\n        returns (string memory)\n    {\n        require(metadata[_id] != address(0), \"NO METADATA\");\n        return IFERC1155(metadata[_id]).uri(_id);\n    }\n\n    /// @notice Getter for controller account\n    function controller() public view returns (address controllerAddress) {\n        _controller == address(0)\n            ? controllerAddress = INITIAL_CONTROLLER()\n            : controllerAddress = _controller;\n    }\n\n    /// @notice Getter for initial controller account immutable argument stored in calldata\n    function INITIAL_CONTROLLER() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    /// @notice VaultRegistry address that is allowed to call mint() and burn()\n    function VAULT_REGISTRY() public pure returns (address) {\n        return _getArgAddress(20);\n    }\n\n    /// @dev Computes hash of permit struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitStructHash(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _id,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes hash of permit all struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitAllStructHash(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_ALL_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes domain separator to prevent signature collisions\n    /// @return Hash of the contract-specific fields\n    function _computeDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(NAME)),\n                    keccak256(bytes(VERSION)),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @dev Computes digest of domain separator and struct hash\n    /// @param _domainSeparator Hash of contract-specific fields\n    /// @param _structHash Hash of signature fields struct\n    /// @return Hash of the signature digest\n    function _computeDigest(bytes32 _domainSeparator, bytes32 _structHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", _domainSeparator, _structHash)\n            );\n    }\n}\n\n\n",
        "CodeNames": [
            "FERC1155.t.sol",
            "FERC1155.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FERC1155.sol",
                "Type": "Incomplete implementation of EIP-2981",
                "Description": "The FERC1155.sol contract does not fully implement the NFT Royalty Standard EIP-2981, specifically missing the implementation of function supportsInterface(bytes4 interfaceID) external view returns (bool) from EIP-165, which can cause issues with external marketplaces that check for royalties.",
                "Repair": "Add implementation of function supportsInterface(bytes4 interfaceID) external view returns (bool) from EIP-165 to FERC1155.sol and register the ERC2981 interface ID on the _registerInterface"
            }
        ]
    }
]