[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Use of Solidity version 0.8.13",
                "Type": "Solidity version vulnerability",
                "Description": "Solidity version 0.8.13 has two known issues applicable to PuttyV2.",
                "Repair": "Use recent Solidity version 0.8.15 which has the fix for these issues"
            },
            {
                "Location": "exercise() and withdraw() functions",
                "Type": "Malicious Token Contracts vulnerability",
                "Description": "Malicious Token Contracts May Lead To Locking Orders",
                "Repair": "Consider whitelisting approved ERC20 token or ERC721 address contracts to prevent users setting malicious token contracts"
            },
            {
                "Location": "fillOrder() function",
                "Type": "Put option exercise prevention",
                "Description": "Put option sellers can prevent exercise by specifying zero amounts, or non-existant tokens. If the put option seller includes in order.erc20Assets, an amount of zero for any of the assets, or specifies an asset that doesn't currently have any code at its address, the put buyer will be unable to exercise the option.",
                "Repair": "Verify the asset amounts and addresses during fillOrder(), and allow exercise if the token no longer exists at that point in time"
            },
            {
                "Location": "Creating a short call order with non-empty floorTokens array",
                "Type": "Loss of assets",
                "Description": "If a short call order is created with non-empty floorTokens array, the taker cannot exercise. Also, the maker cannot withdraw after the expiration. The maker will still get premium when the order is filled. If the non-empty floorTokens array was included as an accident, it is a loss for both parties: the taker loses premium without possible exercise, the maker loses the locked ERC20s and ERC721s.",
                "Repair": "Prohibiting non-empty floorTokens for short calls"
            },
            {
                "Location": "M-15",
                "Type": "Design",
                "Description": "Zero strike call options will avoid paying system fee.",
                "Repair": "Link the fee to option premium or move fee gathering to fillOrder"
            },
            {
                "Location": "M-02",
                "Type": "Logic",
                "Description": "Unbounded loops may cause exercise()s and withdraw()s to fail.",
                "Repair": "Have an upper bound on the number of assets, or allow them to be transferred out one at a time"
            },
            {
                "Location": "M-04",
                "Type": "Logic",
                "Description": "Put options are free of any fees.",
                "Repair": "Charge fees also for exercised put options"
            },
            {
                "Location": "fillOrder() and exercise()",
                "Type": "Zero-value token transfer",
                "Description": "Ether sent to the contract when non-Ether code paths are taken is locked in the contract forever.",
                "Repair": "Add a require(0 == msg.value) for the above three conditions."
            },
            {
                "Location": "Order cancellation",
                "Type": "Dependency on centralized database",
                "Description": "Order cancellation is prone to frontrunning and is dependent on a centralized database.",
                "Repair": "Add an extra method to cancel all orders of a caller using a minimum valid nonce state variable or counters."
            },
            {
                "Location": "acceptCounterOffer() function",
                "Type": "Double Fill",
                "Description": "An attacker can fill both originalOrder and order when a user is attempting to accept a counter offer, resulting in both orders being filled.",
                "Repair": "Require that order can't be in the filled state on cancel"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/**\n\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557    \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d    \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551    \u255a\u2588\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2554\u255d\n    \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551     \u255a\u2588\u2588\u2554\u255d      \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u255d \n    \u2588\u2588\u2551     \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551      \u2588\u2588\u2551      \u2588\u2588\u2551        \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n    \u255a\u2550\u255d      \u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d      \u255a\u2550\u255d      \u255a\u2550\u255d         \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \n                                \n            _..._               \n          .'     '.      _       \n         /    .-\"\"-\\   _/ \\ \n       .-|   /:.   |  |   |   bussin\n       |  \\  |:.   /.-'-./\n       | .-'-;:__.'    =/\n       .'=  *=|     _.='\n      /   _.  |    ;        minister you satoshi\n     ;-.-'|    \\   |\n    /   | \\    _\\  _\\\n    \\__/'._;.  ==' ==\\\n             \\    \\   |\n             /    /   / \n             /-._/-._/\n      jgs    \\   `\\  \\\n              `-._/._/\n\n\n    this is a public good.\n    by out.eth and tamagoyaki\n    \n */\n\nimport \"./lib/IWETH.sol\";\n\nimport \"openzeppelin/utils/cryptography/SignatureChecker.sol\";\nimport \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport \"openzeppelin/utils/Strings.sol\";\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC721.sol\";\n\nimport \"./PuttyV2Nft.sol\";\n\n/**\n    @title PuttyV2\n    @author out.eth\n    @notice An otc erc721 and erc20 option market.\n */\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n    /* ~~~ TYPES ~~~ */\n\n    using SafeTransferLib for ERC20;\n\n    struct ERC20Asset {\n        address token;\n        uint256 tokenAmount;\n    }\n\n    struct ERC721Asset {\n        address token;\n        uint256 tokenId;\n    }\n\n    struct Order {\n        address maker;\n        bool isCall;\n        bool isLong;\n        address baseAsset;\n        uint256 strike;\n        uint256 premium;\n        uint256 duration;\n        uint256 expiration;\n        uint256 nonce;\n        address[] whitelist;\n        address[] floorTokens;\n        ERC20Asset[] erc20Assets;\n        ERC721Asset[] erc721Assets;\n    }\n\n    /* ~~~ STATE VARIABLES ~~~ */\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC721ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC721Asset(address token,uint256 tokenId)\"));\n\n    /**\n        @dev ERC20Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC20ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC20Asset(address token,uint256 tokenAmount)\"));\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ORDER_TYPE_HASH =\n        keccak256(\n            abi.encodePacked(\n                \"Order(\",\n                \"address maker,\",\n                \"bool isCall,\",\n                \"bool isLong,\",\n                \"address baseAsset,\",\n                \"uint256 strike,\",\n                \"uint256 premium,\",\n                \"uint256 duration,\",\n                \"uint256 expiration,\",\n                \"uint256 nonce,\",\n                \"address[] whitelist,\",\n                \"address[] floorTokens,\",\n                \"ERC20Asset[] erc20Assets,\",\n                \"ERC721Asset[] erc721Assets\",\n                \")\",\n                \"ERC20Asset(address token,uint256 tokenAmount)\",\n                \"ERC721Asset(address token,uint256 tokenId)\"\n            )\n        );\n\n    /**\n        @dev Contract address for Wrapped Ethereum.\n     */\n    address public immutable weth;\n\n    /**\n        @dev baseURI used to generate the tokenURI for PuttyV2 NFTs.\n    */\n    string public baseURI;\n\n    /**\n        @notice Fee rate that is applied on exercise.\n    */\n    uint256 public fee;\n\n    /**\n        @notice Whether or not an order has been cancelled. Maps \n                from orderHash to isCancelled.\n    */\n    mapping(bytes32 => bool) public cancelledOrders;\n\n    /**\n        @notice The current expiration timestamp of a position. Maps \n                from positionId to an expiration unix timestamp.\n    */\n    mapping(uint256 => uint256) public positionExpirations;\n\n    /**\n        @notice Whether or not a position has been exercised. Maps \n                from positionId to isExercised.\n    */\n    mapping(uint256 => bool) public exercisedPositions;\n\n    /**\n        @notice The floor asset token ids for a position. Maps from \n                positionId to floor asset token ids. This should only \n                be set for a long call position in `fillOrder`, or for \n                a short put position in `exercise`.\n    */\n    mapping(uint256 => uint256[]) public positionFloorAssetTokenIds;\n\n    /* ~~~ EVENTS ~~~ */\n\n    /**\n        @notice Emitted when a new base URI is set.\n        @param baseURI The new baseURI.\n     */\n    event NewBaseURI(string baseURI);\n\n    /**\n        @notice Emitted when a new fee is set.\n        @param fee The new fee.\n     */\n    event NewFee(uint256 fee);\n\n    /**\n        @notice Emitted when an order is filled.\n        @param orderHash The hash of the order that was filled.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was filled.\n     */\n    event FilledOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is exercised.\n        @param orderHash The hash of the order that was exercised.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was exercised.\n     */\n    event ExercisedOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is withdrawn.\n        @param orderHash The hash of the order that was withdrawn.\n        @param order The order that was withdrawn.\n     */\n    event WithdrawOrder(bytes32 indexed orderHash, Order order);\n\n    /**\n        @notice emitted When an order is cancelled.\n        @param orderHash The hash of the order that was cancelled.\n        @param order The order that was cancelled.\n     */\n    event CancelledOrder(bytes32 indexed orderHash, Order order);\n\n    constructor(\n        string memory _baseURI,\n        uint256 _fee,\n        address _weth\n    ) {\n        require(_weth != address(0), \"Unset weth address\");\n\n        setBaseURI(_baseURI);\n        setFee(_fee);\n        weth = _weth;\n    }\n\n    /* ~~~ ADMIN FUNCTIONS ~~~ */\n\n    /**\n        @notice Sets a new baseURI that is used in the construction\n                of the tokenURI for each NFT position. Admin/DAO only.\n        @param _baseURI The new base URI to use.\n     */\n    function setBaseURI(string memory _baseURI) public payable onlyOwner {\n        baseURI = _baseURI;\n\n        emit NewBaseURI(_baseURI);\n    }\n\n    /**\n        @notice Sets a new fee rate that is applied on exercise. The\n                fee has a precision of 1 decimal. e.g. 1000 = 100%,\n                100 = 10%, 1 = 0.1%. Admin/DAO only.\n        @param _fee The new fee rate to use.\n     */\n    function setFee(uint256 _fee) public payable onlyOwner {\n        require(_fee < 30, \"fee must be less than 3%\");\n\n        fee = _fee;\n\n        emit NewFee(_fee);\n    }\n\n    /*\n        ~~~ MAIN LOGIC FUNCTIONS ~~~\n\n        Standard lifecycle:\n            [1] fillOrder()\n            [2] exercise()\n            [3] withdraw()\n\n            * It is also possible to cancel() an order before fillOrder()\n    */\n\n    /**\n        @notice Fills an offchain order and settles it onchain. Mints two\n                NFTs that represent the long and short position for the order.\n        @param order The order to fill.\n        @param signature The signature for the order. Signature must recover to order.maker.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when filling a long call order.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256[] memory floorAssetTokenIds\n    ) public payable returns (uint256 positionId) {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check signature is valid using EIP-712\n        require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"Invalid signature\");\n\n        // check order is not cancelled\n        require(!cancelledOrders[orderHash], \"Order has been cancelled\");\n\n        // check msg.sender is allowed to fill the order\n        require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\n        // check duration is valid\n        require(order.duration < 10_000 days, \"Duration too long\");\n\n        // check order has not expired\n        require(block.timestamp < order.expiration, \"Order has expired\");\n\n        // check base asset exists\n        require(order.baseAsset.code.length > 0, \"baseAsset is not contract\");\n\n        // check floor asset token ids length is 0 unless the order type is call and side is long\n        order.isCall && order.isLong\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokens length\");\n\n        /*  ~~~ EFFECTS ~~~ */\n\n        // create long/short position for maker\n        _mint(order.maker, uint256(orderHash));\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n        _mint(msg.sender, positionId);\n\n        // save floorAssetTokenIds if filling a long call order\n        if (order.isLong && order.isCall) {\n            positionFloorAssetTokenIds[uint256(orderHash)] = floorAssetTokenIds;\n        }\n\n        // save the long position expiration\n        positionExpirations[order.isLong ? uint256(orderHash) : positionId] = block.timestamp + order.duration;\n\n        emit FilledOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer premium to whoever is short from whomever is long\n        if (order.isLong) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n        } else {\n            // handle the case where the user uses native ETH instead of WETH to pay the premium\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n        }\n\n        // filling short put: transfer strike from maker to contract\n        if (!order.isLong && !order.isCall) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, address(this), order.strike);\n            return positionId;\n        }\n\n        // filling long put: transfer strike from taker to contract\n        if (order.isLong && !order.isCall) {\n            // handle the case where the taker uses native ETH instead of WETH to deposit the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in exercise() works\n                // - because exercise() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            return positionId;\n        }\n\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n\n        // filling long call: transfer assets from taker to contract\n        if (order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n            return positionId;\n        }\n    }\n\n    /**\n        @notice Exercises a long order and also burns the long position NFT which \n                represents it.\n        @param order The order of the position to exercise.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when exercising a put order.\n     */\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check user owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        // check position is long\n        require(order.isLong, \"Can only exercise long positions\");\n\n        // check position has not expired\n        require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n\n        // check floor asset token ids length is 0 unless the position type is put\n        !order.isCall\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the long position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        // mark the position as exercised\n        exercisedPositions[uint256(orderHash)] = true;\n\n        emit ExercisedOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        } else {\n            // -- exercising a put option\n\n            // save the floor asset token ids to the short position\n            uint256 shortPositionId = uint256(hashOppositeOrder(order));\n            positionFloorAssetTokenIds[shortPositionId] = floorAssetTokenIds;\n\n            // transfer strike from putty to exerciser\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n\n            // transfer assets from exerciser to putty\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n        }\n    }\n\n    /**\n        @notice Withdraws the assets from a short order and also burns the short position \n                that represents it. The assets that are withdrawn are dependent on whether \n                the order is exercised or expired and if the order is a put or call.\n        @param order The order to withdraw.\n     */\n    function withdraw(Order memory order) public {\n        /* ~~~ CHECKS ~~~ */\n\n        // check order is short\n        require(!order.isLong, \"Must be short position\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check msg.sender owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        uint256 longPositionId = uint256(hashOppositeOrder(order));\n        bool isExercised = exercisedPositions[longPositionId];\n\n        // check long position has either been exercised or is expired\n        require(block.timestamp > positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the short position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        emit WithdrawOrder(orderHash, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer strike to owner if put is expired or call is exercised\n        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n            // send the fee to the admin/DAO if fee is greater than 0%\n            uint256 feeAmount = 0;\n            if (fee > 0) {\n                feeAmount = (order.strike * fee) / 1000;\n                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n            }\n\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n            return;\n        }\n\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n    }\n\n    /**\n        @notice Cancels an order which prevents it from being filled in the future.\n        @param order The order to cancel.\n     */\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n        emit CancelledOrder(orderHash, order);\n    }\n\n    /* ~~~ PERIPHERY LOGIC FUNCTIONS ~~~ */\n\n    /**\n        @notice Batch fills multiple orders.\n        @param orders The orders to fill.\n        @param signatures The signatures to use for each respective order.\n        @param floorAssetTokenIds The floorAssetTokenIds to use for each respective order.\n        @return positionIds The ids of the position NFT that the msg.sender receives.\n     */\n    function batchFillOrder(\n        Order[] memory orders,\n        bytes[] calldata signatures,\n        uint256[][] memory floorAssetTokenIds\n    ) public returns (uint256[] memory positionIds) {\n        require(orders.length == signatures.length, \"Length mismatch in input\");\n        require(signatures.length == floorAssetTokenIds.length, \"Length mismatch in input\");\n\n        positionIds = new uint256[](orders.length);\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            positionIds[i] = fillOrder(orders[i], signatures[i], floorAssetTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Accepts a counter offer for an order. It fills the counter offer, and then\n                cancels the original order that the counter offer was made for.\n        @dev There is no need for floorTokenIds here because there is no situation in which\n             it makes sense to have them when accepting counter offers. When accepting a counter \n             offer for a short call order, the complementary long call order already knows what \n             tokenIds are used in the short call so floorTokens should always be empty.\n        @param order The counter offer to accept.\n        @param signature The signature for the counter offer.\n        @param originalOrder The original order that the counter was made for.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n\n    /* ~~~ HELPER FUNCTIONS ~~~ */\n\n    /**\n        @notice Transfers an array of erc20s into the contract from an address.\n        @param assets The erc20 tokens and amounts to transfer in.\n        @param from Who to transfer the erc20 assets from.\n     */\n    function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            address token = assets[i].token;\n            uint256 tokenAmount = assets[i].tokenAmount;\n\n            require(token.code.length > 0, \"ERC20: Token is not contract\");\n            require(tokenAmount > 0, \"ERC20: Amount too small\");\n\n            ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721s into the contract from an address.\n        @param assets The erc721 tokens and token ids to transfer in.\n        @param from Who to transfer the erc721 assets from.\n     */\n    function _transferERC721sIn(ERC721Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(from, address(this), assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens into the contract from an address.\n        @param floorTokens The contract addresses of each erc721.\n        @param floorTokenIds The token id of each erc721.\n        @param from Who to transfer the floor tokens from.\n     */\n    function _transferFloorsIn(\n        address[] memory floorTokens,\n        uint256[] memory floorTokenIds,\n        address from\n    ) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc20 tokens to the msg.sender.\n        @param assets The erc20 tokens and amounts to send.\n     */\n    function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 tokens to the msg.sender.\n        @param assets The erc721 tokens and token ids to send.\n     */\n    function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens to the msg.sender.\n        @param floorTokens The contract addresses for each floor token.\n        @param floorTokenIds The token id of each floor token.\n     */\n    function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Checks whether or not an address exists in the whitelist.\n        @param whitelist The whitelist to check against.\n        @param target The target address to check.\n        @return If it exists in the whitelist or not.\n     */\n    function isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n        for (uint256 i = 0; i < whitelist.length; i++) {\n            if (target == whitelist[i]) return true;\n        }\n\n        return false;\n    }\n\n    /**\n        @notice Get the orderHash for a complementary short/long order - e.g for a long order,\n                this returns the hash of it's opposite short order.\n        @param order The order to find the complementary long/short hash for.\n        @return orderHash The hash of the opposite order.\n     */\n    function hashOppositeOrder(Order memory order) public view returns (bytes32 orderHash) {\n        // use decode/encode to get a copy instead of reference\n        Order memory oppositeOrder = abi.decode(abi.encode(order), (Order));\n\n        // get the opposite side of the order (short/long)\n        oppositeOrder.isLong = !order.isLong;\n        orderHash = hashOrder(oppositeOrder);\n    }\n\n    /* ~~~ EIP-712 HELPERS ~~~ */\n\n    /**\n        @notice Hashes an order based on the eip-712 encoding scheme.\n        @param order The order to hash.\n        @return orderHash The eip-712 compliant hash of the order.\n     */\n    function hashOrder(Order memory order) public view returns (bytes32 orderHash) {\n        orderHash = keccak256(\n            abi.encode(\n                ORDER_TYPE_HASH,\n                order.maker,\n                order.isCall,\n                order.isLong,\n                order.baseAsset,\n                order.strike,\n                order.premium,\n                order.duration,\n                order.expiration,\n                order.nonce,\n                keccak256(abi.encodePacked(order.whitelist)),\n                keccak256(abi.encodePacked(order.floorTokens)),\n                keccak256(encodeERC20Assets(order.erc20Assets)),\n                keccak256(encodeERC721Assets(order.erc721Assets))\n            )\n        );\n\n        orderHash = _hashTypedDataV4(orderHash);\n    }\n\n    /**\n        @notice Encodes an array of erc20 assets following the eip-712 encoding scheme.\n        @param arr Array of erc20 assets to hash.\n        @return encoded The eip-712 encoded array of erc20 assets.\n     */\n    function encodeERC20Assets(ERC20Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC20ASSET_TYPE_HASH, arr[i].token, arr[i].tokenAmount))\n            );\n        }\n    }\n\n    /**\n        @notice Encodes an array of erc721 assets following the eip-712 encoding scheme.\n        @param arr Array of erc721 assets to hash.\n        @return encoded The eip-712 encoded array of erc721 assets.\n     */\n    function encodeERC721Assets(ERC721Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC721ASSET_TYPE_HASH, arr[i].token, arr[i].tokenId))\n            );\n        }\n    }\n\n    /**\n        @return The domain seperator used when calculating the eip-712 hash.\n     */\n    function domainSeparatorV4() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /* ~~~ OVERRIDES ~~~ */\n\n    /**\n        @notice Gets the token URI for an NFT.\n        @param id The id of the position NFT.\n        @return The tokenURI of the position NFT.\n     */\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        require(_ownerOf[id] != address(0), \"URI query for NOT_MINTED token\");\n\n        return string.concat(baseURI, Strings.toString(id));\n    }\n}\n\n\n",
        "CodeNames": [
            "PuttyV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PuttyV2 contract",
                "Type": "Flashloan without fee",
                "Description": "The contract serves as a flashloan pool without fee. The malicious user could leverage PuttyV2 contract to flashloan without paying fee the assets to make profit.",
                "Repair": "Add nonReentrant to exercise and fillOrder adding a non-negligible gas overhead"
            },
            {
                "Location": "withdraw function in PuttyV2.sol",
                "Type": "Denial-of-Service",
                "Description": "The owner can transfer the ownership to a zero address, causing the fee transfer to the contract owner to always revert, resulting in no one being able to withdraw their strike amount from the contract.",
                "Repair": "Adopt a withdrawal pattern for retrieving owner fee"
            },
            {
                "Location": "withdraw function in PuttyV2.sol",
                "Type": "Fee change without user consent",
                "Description": "Fees can change between the time the order is filled and its terms are agreed upon and the withdrawal time, leading to a loss of the expected funds for the concerned users.",
                "Repair": "Store the fees in Order and verify that they are correct when the order is filled, so they are hardcoded in the struct"
            },
            {
                "Location": "PuttyV2.sol",
                "Type": "Fee deduction vulnerability",
                "Description": "Fee is being deducted when Put is expired and not when it is exercised, which is impacting the assets.",
                "Repair": "Update the if condition at PuttyV2.sol#L498 and add feeAmount calculation and deduction after put is exercised and strike is transferred at PuttyV2.sol#L451"
            },
            {
                "Location": "PuttyV2.sol",
                "Type": "ERC721 token transfer vulnerability",
                "Description": "Putty position tokens may be minted to non ERC721 receivers, which may lock the options positions and make them nontransferable.",
                "Repair": "Implement the require check in Solmate's ERC721#_safeMint in your own mint function or document the design decision to use _mint and the associated risk for end users"
            },
            {
                "Location": "PuttyV2.sol contract, lines 324-601",
                "Type": "Overlap between ERC721.transferFrom() and ERC20.transferFrom()",
                "Description": "ERC721 tokens transferred into the contract via fillOrder() can be permanently stuck in the contract as neither exercise() nor withdraw() will successfully transfer the tokens out of the contract.",
                "Repair": "Whitelist approved ERC721 and ERC20 token contracts and separate them into different whitelists for ERC20s and ERC721s. Ensure each contract is in the right category."
            },
            {
                "Location": "PuttyV2.sol contract, lines 435-437",
                "Type": "Zero strike call options can be systemically used to steal premium from the taker",
                "Description": "Malicious makers can create short call orders with zero strike value, receive the premium, wait for expiration, and recover their assets, effectively collecting the premium for free.",
                "Repair": "Check that strike is positive before transfer in all cases."
            },
            {
                "Location": "PuttyV2.sol contract",
                "Type": "Order duration can be set to 0 by malicious maker",
                "Description": "Malicious makers can set a minimum order duration as 0, causing the order to instantly expire after filling and forcing the taker to lose money in a meaningless transaction.",
                "Repair": "Enforce a minimum order duration of at least 15 minutes on filling."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC721} from \"./utils/mocks/MockERC721.sol\";\n\nimport {ERC721TokenReceiver} from \"../tokens/ERC721.sol\";\n\ncontract ERC721Recipient is ERC721TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    bytes public data;\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        bytes calldata _data\n    ) public virtual override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        data = _data;\n\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n\ncontract RevertingERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector)));\n    }\n}\n\ncontract WrongReturnDataERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC721Recipient {}\n\ncontract ERC721Test is DSTestPlus {\n    MockERC721 token;\n\n    function setUp() public {\n        token = new MockERC721(\"Token\", \"TKN\");\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1337);\n\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337);\n        token.burn(1337);\n\n        assertEq(token.balanceOf(address(0xBEEF)), 0);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(1337);\n    }\n\n    function testApprove() public {\n        token.mint(address(this), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0xBEEF));\n    }\n\n    function testApproveBurn() public {\n        token.mint(address(this), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n\n        token.burn(1337);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.getApproved(1337), address(0));\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(1337);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.approve(address(this), 1337);\n\n        token.transferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf() public {\n        token.mint(address(this), 1337);\n\n        token.transferFrom(address(this), address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.transferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient() public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), 1337);\n        assertBytesEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData() public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), 1337, \"testing 123\");\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), 1337);\n        assertBytesEq(recipient.data(), \"testing 123\");\n    }\n\n    function testSafeMintToEOA() public {\n        token.safeMint(address(0xBEEF), 1337);\n\n        assertEq(token.ownerOf(1337), address(address(0xBEEF)));\n        assertEq(token.balanceOf(address(address(0xBEEF))), 1);\n    }\n\n    function testSafeMintToERC721Recipient() public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), 1337);\n\n        assertEq(token.ownerOf(1337), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData() public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), 1337, \"testing 123\");\n\n        assertEq(token.ownerOf(1337), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.data(), \"testing 123\");\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337);\n    }\n\n    function testFailDoubleMint() public {\n        token.mint(address(0xBEEF), 1337);\n        token.mint(address(0xBEEF), 1337);\n    }\n\n    function testFailBurnUnMinted() public {\n        token.burn(1337);\n    }\n\n    function testFailDoubleBurn() public {\n        token.mint(address(0xBEEF), 1337);\n\n        token.burn(1337);\n        token.burn(1337);\n    }\n\n    function testFailApproveUnMinted() public {\n        token.approve(address(0xBEEF), 1337);\n    }\n\n    function testFailApproveUnAuthorized() public {\n        token.mint(address(0xCAFE), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromUnOwned() public {\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromWrongFrom() public {\n        token.mint(address(0xCAFE), 1337);\n\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromToZero() public {\n        token.mint(address(this), 1337);\n\n        token.transferFrom(address(this), address(0), 1337);\n    }\n\n    function testFailTransferFromNotOwner() public {\n        token.mint(address(0xFEED), 1337);\n\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailSafeTransferFromToNonERC721Recipient() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToNonERC721RecipientWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeTransferFromToRevertingERC721Recipient() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721RecipientWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnDataWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToNonERC721Recipient() public {\n        token.safeMint(address(new NonERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToNonERC721RecipientWithData() public {\n        token.safeMint(address(new NonERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToRevertingERC721Recipient() public {\n        token.safeMint(address(new RevertingERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToRevertingERC721RecipientWithData() public {\n        token.safeMint(address(new RevertingERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnData() public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnDataWithData() public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailBalanceOfZeroAddress() public view {\n        token.balanceOf(address(0));\n    }\n\n    function testFailOwnerOfUnminted() public view {\n        token.ownerOf(1337);\n    }\n\n    function testMetadata(string memory name, string memory symbol) public {\n        MockERC721 tkn = new MockERC721(name, symbol);\n\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n    }\n\n    function testMint(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.ownerOf(id), to);\n    }\n\n    function testBurn(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n        token.burn(id);\n\n        assertEq(token.balanceOf(to), 0);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(id);\n    }\n\n    function testApprove(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(address(this), id);\n\n        token.approve(to, id);\n\n        assertEq(token.getApproved(id), to);\n    }\n\n    function testApproveBurn(address to, uint256 id) public {\n        token.mint(address(this), id);\n\n        token.approve(address(to), id);\n\n        token.burn(id);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.getApproved(id), address(0));\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(id);\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testTransferFrom(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.approve(address(this), id);\n\n        token.transferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf(uint256 id, address to) public {\n        if (to == address(0) || to == address(this)) to = address(0xBEEF);\n\n        token.mint(address(this), id);\n\n        token.transferFrom(address(this), to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.transferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient(uint256 id) public {\n        address from = address(0xABCD);\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertBytesEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), id, data);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertBytesEq(recipient.data(), data);\n    }\n\n    function testSafeMintToEOA(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.safeMint(to, id);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n    }\n\n    function testSafeMintToERC721Recipient(uint256 id) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id, data);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.data(), data);\n    }\n\n    function testFailMintToZero(uint256 id) public {\n        token.mint(address(0), id);\n    }\n\n    function testFailDoubleMint(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n        token.mint(to, id);\n    }\n\n    function testFailBurnUnMinted(uint256 id) public {\n        token.burn(id);\n    }\n\n    function testFailDoubleBurn(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n\n        token.burn(id);\n        token.burn(id);\n    }\n\n    function testFailApproveUnMinted(uint256 id, address to) public {\n        token.approve(to, id);\n    }\n\n    function testFailApproveUnAuthorized(\n        address owner,\n        uint256 id,\n        address to\n    ) public {\n        if (owner == address(0) || owner == address(this)) owner = address(0xBEEF);\n\n        token.mint(owner, id);\n\n        token.approve(to, id);\n    }\n\n    function testFailTransferFromUnOwned(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailTransferFromWrongFrom(\n        address owner,\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        if (owner == address(0)) to = address(0xBEEF);\n        if (from == owner) revert();\n\n        token.mint(owner, id);\n\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailTransferFromToZero(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.transferFrom(address(this), address(0), id);\n    }\n\n    function testFailTransferFromNotOwner(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        if (from == address(this)) from = address(0xBEEF);\n\n        token.mint(from, id);\n\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailSafeTransferFromToNonERC721Recipient(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToNonERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), id, data);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721Recipient(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), id, data);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnData(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes calldata data)\n        public\n    {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToNonERC721Recipient(uint256 id) public {\n        token.safeMint(address(new NonERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToNonERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new NonERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToRevertingERC721Recipient(uint256 id) public {\n        token.safeMint(address(new RevertingERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToRevertingERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new RevertingERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnData(uint256 id) public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), id, data);\n    }\n\n    function testFailOwnerOfUnminted(uint256 id) public view {\n        token.ownerOf(id);\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC721.sol",
            "ERC721.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Creating a short put option order on an NFT that does not support ERC721",
                "Type": "Inability to exercise option",
                "Description": "An attacker can create a short put option on an NFT that does not support ERC721, like cryptopunk. When the user fulfills the order, the baseAsset will be transferred to the contract. However, since the NFT does not support ERC721, the user cannot exercise the option because the safeTransferFrom function call fails. The attacker can get premium and get back baseAsset after option expires.",
                "Repair": "Supporting exercising on NFTs that do not support ERC721 or adding a whitelist to NFTs in the order"
            }
        ]
    }
]