[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Use of Solidity version 0.8.13",
                "Type": "Solidity version vulnerability",
                "Description": "Solidity version 0.8.13 has two known issues applicable to PuttyV2.",
                "Repair": "Use recent Solidity version 0.8.15 which has the fix for these issues"
            },
            {
                "Location": "exercise() and withdraw() functions",
                "Type": "Malicious Token Contracts vulnerability",
                "Description": "Malicious Token Contracts May Lead To Locking Orders. An attacker as a maker may create an order and set one of these addresses to a malicious contract in the attackers control.",
                "Repair": "Consider whitelisting approved ERC20 token or ERC721 address contracts to prevent users setting malicious token contracts"
            },
            {
                "Location": "withdraw function",
                "Type": "Smart Contract Logic",
                "Description": "When the owner transfers the ownership to a zero address, the fee transfer to the contract owner always reverts, causing no one to withdraw their strike amount from the contract.",
                "Repair": "Adopt a withdrawal pattern for retrieving owner fee"
            },
            {
                "Location": "PuttyV2#fillOrder function",
                "Type": "Design flaw",
                "Description": "Zero strike call options will avoid paying system fee",
                "Repair": "Consider linking the fee to option premium as this is option value that cannot be easily manipulated and exactly corresponds to the trading volume of the system. Alternatively, document the design decision to use _mint and the associated risk for end users."
            },
            {
                "Location": "PuttyV2#fillOrder function",
                "Type": "ERC721 token transfer vulnerability",
                "Description": "Putty position tokens may be minted to non ERC721 receivers",
                "Repair": "Consider implementing the require check in Solmate's ERC721#_safeMint in your own mint function. Alternatively, document the design decision to use _mint and the associated risk for end users."
            },
            {
                "Location": "Functions for transferring ERC20s, ERC721s, and floors out",
                "Type": "Unbounded loops",
                "Description": "Unbounded loops may cause exercise()s and withdraw()s to fail.",
                "Repair": "Have an upper bound on the number of assets, or allow them to be transferred out one at a time, if necessary"
            },
            {
                "Location": "fillOrder() and exercise()",
                "Type": "Locked Ether",
                "Description": "Ether passed to the functions, when the non-Ether code paths are taken, is locked in the contract forever, and the sender gets nothing extra in return for it.",
                "Repair": "Add a require(0 == msg.value) for the above three conditions."
            },
            {
                "Location": "send the fee to the admin/DAO if fee is greater than 0%",
                "Type": "Token Transfer Revert",
                "Description": "Using such a token as a order.baseAsset for a rather small option strike and a low protocol fee rate can lead to rounding down to 0 and prevent asset withdrawals for those positions.",
                "Repair": "Add a simple check for zero-value token transfers."
            },
            {
                "Location": "cancel()",
                "Type": "Order Cancellation",
                "Description": "Order cancellation requires makers to call cancel(), inputting the order as a function parameter. This is the only cancellation method, and it can cause two issues.",
                "Repair": "Have an extra method to cancel all orders of a caller. This can be achieved using a 'minimum valid nonce' state variable, as a mapping from user address to nonce."
            },
            {
                "Location": "Maker creates an order with zero Order duration",
                "Type": "Order duration manipulation",
                "Description": "A malicious maker can set a minimum order duration as 0 which means order will instantly expire after filling. Taker will get only the withdraw option and that too with fees on strike price, thus forcing the taker to lose money in this meaningless transaction.",
                "Repair": "Enforce at least x days of duration"
            },
            {
                "Location": "acceptCounterOffer() function",
                "Type": "Double order filling",
                "Description": "When a user is attempting to accept a counter offer they call the function acceptCounterOffer() with both the originalOrder to be cancelled and the new order to fill. It is possible for an attacker (or any other user who happens to call fillOrder() at the same time) to fill the originalOrder before acceptCounterOffer() cancels it. The impact is that both originalOrder and order are filled.",
                "Repair": "Require that order can't be in the filled state on cancel"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/**\n\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557    \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d    \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551    \u255a\u2588\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2554\u255d\n    \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551     \u255a\u2588\u2588\u2554\u255d      \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u255d \n    \u2588\u2588\u2551     \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551      \u2588\u2588\u2551      \u2588\u2588\u2551        \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n    \u255a\u2550\u255d      \u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d      \u255a\u2550\u255d      \u255a\u2550\u255d         \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \n                                \n            _..._               \n          .'     '.      _       \n         /    .-\"\"-\\   _/ \\ \n       .-|   /:.   |  |   |   bussin\n       |  \\  |:.   /.-'-./\n       | .-'-;:__.'    =/\n       .'=  *=|     _.='\n      /   _.  |    ;        minister you satoshi\n     ;-.-'|    \\   |\n    /   | \\    _\\  _\\\n    \\__/'._;.  ==' ==\\\n             \\    \\   |\n             /    /   / \n             /-._/-._/\n      jgs    \\   `\\  \\\n              `-._/._/\n\n\n    this is a public good.\n    by out.eth and tamagoyaki\n    \n */\n\nimport \"./lib/IWETH.sol\";\n\nimport \"openzeppelin/utils/cryptography/SignatureChecker.sol\";\nimport \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport \"openzeppelin/utils/Strings.sol\";\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC721.sol\";\n\nimport \"./PuttyV2Nft.sol\";\n\n/**\n    @title PuttyV2\n    @author out.eth\n    @notice An otc erc721 and erc20 option market.\n */\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n    /* ~~~ TYPES ~~~ */\n\n    using SafeTransferLib for ERC20;\n\n    struct ERC20Asset {\n        address token;\n        uint256 tokenAmount;\n    }\n\n    struct ERC721Asset {\n        address token;\n        uint256 tokenId;\n    }\n\n    struct Order {\n        address maker;\n        bool isCall;\n        bool isLong;\n        address baseAsset;\n        uint256 strike;\n        uint256 premium;\n        uint256 duration;\n        uint256 expiration;\n        uint256 nonce;\n        address[] whitelist;\n        address[] floorTokens;\n        ERC20Asset[] erc20Assets;\n        ERC721Asset[] erc721Assets;\n    }\n\n    /* ~~~ STATE VARIABLES ~~~ */\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC721ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC721Asset(address token,uint256 tokenId)\"));\n\n    /**\n        @dev ERC20Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC20ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC20Asset(address token,uint256 tokenAmount)\"));\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ORDER_TYPE_HASH =\n        keccak256(\n            abi.encodePacked(\n                \"Order(\",\n                \"address maker,\",\n                \"bool isCall,\",\n                \"bool isLong,\",\n                \"address baseAsset,\",\n                \"uint256 strike,\",\n                \"uint256 premium,\",\n                \"uint256 duration,\",\n                \"uint256 expiration,\",\n                \"uint256 nonce,\",\n                \"address[] whitelist,\",\n                \"address[] floorTokens,\",\n                \"ERC20Asset[] erc20Assets,\",\n                \"ERC721Asset[] erc721Assets\",\n                \")\",\n                \"ERC20Asset(address token,uint256 tokenAmount)\",\n                \"ERC721Asset(address token,uint256 tokenId)\"\n            )\n        );\n\n    /**\n        @dev Contract address for Wrapped Ethereum.\n     */\n    address public immutable weth;\n\n    /**\n        @dev baseURI used to generate the tokenURI for PuttyV2 NFTs.\n    */\n    string public baseURI;\n\n    /**\n        @notice Fee rate that is applied on exercise.\n    */\n    uint256 public fee;\n\n    /**\n        @notice Whether or not an order has been cancelled. Maps \n                from orderHash to isCancelled.\n    */\n    mapping(bytes32 => bool) public cancelledOrders;\n\n    /**\n        @notice The current expiration timestamp of a position. Maps \n                from positionId to an expiration unix timestamp.\n    */\n    mapping(uint256 => uint256) public positionExpirations;\n\n    /**\n        @notice Whether or not a position has been exercised. Maps \n                from positionId to isExercised.\n    */\n    mapping(uint256 => bool) public exercisedPositions;\n\n    /**\n        @notice The floor asset token ids for a position. Maps from \n                positionId to floor asset token ids. This should only \n                be set for a long call position in `fillOrder`, or for \n                a short put position in `exercise`.\n    */\n    mapping(uint256 => uint256[]) public positionFloorAssetTokenIds;\n\n    /* ~~~ EVENTS ~~~ */\n\n    /**\n        @notice Emitted when a new base URI is set.\n        @param baseURI The new baseURI.\n     */\n    event NewBaseURI(string baseURI);\n\n    /**\n        @notice Emitted when a new fee is set.\n        @param fee The new fee.\n     */\n    event NewFee(uint256 fee);\n\n    /**\n        @notice Emitted when an order is filled.\n        @param orderHash The hash of the order that was filled.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was filled.\n     */\n    event FilledOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is exercised.\n        @param orderHash The hash of the order that was exercised.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was exercised.\n     */\n    event ExercisedOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is withdrawn.\n        @param orderHash The hash of the order that was withdrawn.\n        @param order The order that was withdrawn.\n     */\n    event WithdrawOrder(bytes32 indexed orderHash, Order order);\n\n    /**\n        @notice emitted When an order is cancelled.\n        @param orderHash The hash of the order that was cancelled.\n        @param order The order that was cancelled.\n     */\n    event CancelledOrder(bytes32 indexed orderHash, Order order);\n\n    constructor(\n        string memory _baseURI,\n        uint256 _fee,\n        address _weth\n    ) {\n        require(_weth != address(0), \"Unset weth address\");\n\n        setBaseURI(_baseURI);\n        setFee(_fee);\n        weth = _weth;\n    }\n\n    /* ~~~ ADMIN FUNCTIONS ~~~ */\n\n    /**\n        @notice Sets a new baseURI that is used in the construction\n                of the tokenURI for each NFT position. Admin/DAO only.\n        @param _baseURI The new base URI to use.\n     */\n    function setBaseURI(string memory _baseURI) public payable onlyOwner {\n        baseURI = _baseURI;\n\n        emit NewBaseURI(_baseURI);\n    }\n\n    /**\n        @notice Sets a new fee rate that is applied on exercise. The\n                fee has a precision of 1 decimal. e.g. 1000 = 100%,\n                100 = 10%, 1 = 0.1%. Admin/DAO only.\n        @param _fee The new fee rate to use.\n     */\n    function setFee(uint256 _fee) public payable onlyOwner {\n        require(_fee < 30, \"fee must be less than 3%\");\n\n        fee = _fee;\n\n        emit NewFee(_fee);\n    }\n\n    /*\n        ~~~ MAIN LOGIC FUNCTIONS ~~~\n\n        Standard lifecycle:\n            [1] fillOrder()\n            [2] exercise()\n            [3] withdraw()\n\n            * It is also possible to cancel() an order before fillOrder()\n    */\n\n    /**\n        @notice Fills an offchain order and settles it onchain. Mints two\n                NFTs that represent the long and short position for the order.\n        @param order The order to fill.\n        @param signature The signature for the order. Signature must recover to order.maker.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when filling a long call order.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256[] memory floorAssetTokenIds\n    ) public payable returns (uint256 positionId) {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check signature is valid using EIP-712\n        require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"Invalid signature\");\n\n        // check order is not cancelled\n        require(!cancelledOrders[orderHash], \"Order has been cancelled\");\n\n        // check msg.sender is allowed to fill the order\n        require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\n        // check duration is valid\n        require(order.duration < 10_000 days, \"Duration too long\");\n\n        // check order has not expired\n        require(block.timestamp < order.expiration, \"Order has expired\");\n\n        // check base asset exists\n        require(order.baseAsset.code.length > 0, \"baseAsset is not contract\");\n\n        // check floor asset token ids length is 0 unless the order type is call and side is long\n        order.isCall && order.isLong\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokens length\");\n\n        /*  ~~~ EFFECTS ~~~ */\n\n        // create long/short position for maker\n        _mint(order.maker, uint256(orderHash));\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n        _mint(msg.sender, positionId);\n\n        // save floorAssetTokenIds if filling a long call order\n        if (order.isLong && order.isCall) {\n            positionFloorAssetTokenIds[uint256(orderHash)] = floorAssetTokenIds;\n        }\n\n        // save the long position expiration\n        positionExpirations[order.isLong ? uint256(orderHash) : positionId] = block.timestamp + order.duration;\n\n        emit FilledOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer premium to whoever is short from whomever is long\n        if (order.isLong) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n        } else {\n            // handle the case where the user uses native ETH instead of WETH to pay the premium\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n        }\n\n        // filling short put: transfer strike from maker to contract\n        if (!order.isLong && !order.isCall) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, address(this), order.strike);\n            return positionId;\n        }\n\n        // filling long put: transfer strike from taker to contract\n        if (order.isLong && !order.isCall) {\n            // handle the case where the taker uses native ETH instead of WETH to deposit the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in exercise() works\n                // - because exercise() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            return positionId;\n        }\n\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n\n        // filling long call: transfer assets from taker to contract\n        if (order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n            return positionId;\n        }\n    }\n\n    /**\n        @notice Exercises a long order and also burns the long position NFT which \n                represents it.\n        @param order The order of the position to exercise.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when exercising a put order.\n     */\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check user owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        // check position is long\n        require(order.isLong, \"Can only exercise long positions\");\n\n        // check position has not expired\n        require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n\n        // check floor asset token ids length is 0 unless the position type is put\n        !order.isCall\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the long position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        // mark the position as exercised\n        exercisedPositions[uint256(orderHash)] = true;\n\n        emit ExercisedOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        } else {\n            // -- exercising a put option\n\n            // save the floor asset token ids to the short position\n            uint256 shortPositionId = uint256(hashOppositeOrder(order));\n            positionFloorAssetTokenIds[shortPositionId] = floorAssetTokenIds;\n\n            // transfer strike from putty to exerciser\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n\n            // transfer assets from exerciser to putty\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n        }\n    }\n\n    /**\n        @notice Withdraws the assets from a short order and also burns the short position \n                that represents it. The assets that are withdrawn are dependent on whether \n                the order is exercised or expired and if the order is a put or call.\n        @param order The order to withdraw.\n     */\n    function withdraw(Order memory order) public {\n        /* ~~~ CHECKS ~~~ */\n\n        // check order is short\n        require(!order.isLong, \"Must be short position\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check msg.sender owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        uint256 longPositionId = uint256(hashOppositeOrder(order));\n        bool isExercised = exercisedPositions[longPositionId];\n\n        // check long position has either been exercised or is expired\n        require(block.timestamp > positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the short position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        emit WithdrawOrder(orderHash, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer strike to owner if put is expired or call is exercised\n        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n            // send the fee to the admin/DAO if fee is greater than 0%\n            uint256 feeAmount = 0;\n            if (fee > 0) {\n                feeAmount = (order.strike * fee) / 1000;\n                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n            }\n\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n            return;\n        }\n\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n    }\n\n    /**\n        @notice Cancels an order which prevents it from being filled in the future.\n        @param order The order to cancel.\n     */\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n        emit CancelledOrder(orderHash, order);\n    }\n\n    /* ~~~ PERIPHERY LOGIC FUNCTIONS ~~~ */\n\n    /**\n        @notice Batch fills multiple orders.\n        @param orders The orders to fill.\n        @param signatures The signatures to use for each respective order.\n        @param floorAssetTokenIds The floorAssetTokenIds to use for each respective order.\n        @return positionIds The ids of the position NFT that the msg.sender receives.\n     */\n    function batchFillOrder(\n        Order[] memory orders,\n        bytes[] calldata signatures,\n        uint256[][] memory floorAssetTokenIds\n    ) public returns (uint256[] memory positionIds) {\n        require(orders.length == signatures.length, \"Length mismatch in input\");\n        require(signatures.length == floorAssetTokenIds.length, \"Length mismatch in input\");\n\n        positionIds = new uint256[](orders.length);\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            positionIds[i] = fillOrder(orders[i], signatures[i], floorAssetTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Accepts a counter offer for an order. It fills the counter offer, and then\n                cancels the original order that the counter offer was made for.\n        @dev There is no need for floorTokenIds here because there is no situation in which\n             it makes sense to have them when accepting counter offers. When accepting a counter \n             offer for a short call order, the complementary long call order already knows what \n             tokenIds are used in the short call so floorTokens should always be empty.\n        @param order The counter offer to accept.\n        @param signature The signature for the counter offer.\n        @param originalOrder The original order that the counter was made for.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n\n    /* ~~~ HELPER FUNCTIONS ~~~ */\n\n    /**\n        @notice Transfers an array of erc20s into the contract from an address.\n        @param assets The erc20 tokens and amounts to transfer in.\n        @param from Who to transfer the erc20 assets from.\n     */\n    function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            address token = assets[i].token;\n            uint256 tokenAmount = assets[i].tokenAmount;\n\n            require(token.code.length > 0, \"ERC20: Token is not contract\");\n            require(tokenAmount > 0, \"ERC20: Amount too small\");\n\n            ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721s into the contract from an address.\n        @param assets The erc721 tokens and token ids to transfer in.\n        @param from Who to transfer the erc721 assets from.\n     */\n    function _transferERC721sIn(ERC721Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(from, address(this), assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens into the contract from an address.\n        @param floorTokens The contract addresses of each erc721.\n        @param floorTokenIds The token id of each erc721.\n        @param from Who to transfer the floor tokens from.\n     */\n    function _transferFloorsIn(\n        address[] memory floorTokens,\n        uint256[] memory floorTokenIds,\n        address from\n    ) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc20 tokens to the msg.sender.\n        @param assets The erc20 tokens and amounts to send.\n     */\n    function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 tokens to the msg.sender.\n        @param assets The erc721 tokens and token ids to send.\n     */\n    function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens to the msg.sender.\n        @param floorTokens The contract addresses for each floor token.\n        @param floorTokenIds The token id of each floor token.\n     */\n    function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Checks whether or not an address exists in the whitelist.\n        @param whitelist The whitelist to check against.\n        @param target The target address to check.\n        @return If it exists in the whitelist or not.\n     */\n    function isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n        for (uint256 i = 0; i < whitelist.length; i++) {\n            if (target == whitelist[i]) return true;\n        }\n\n        return false;\n    }\n\n    /**\n        @notice Get the orderHash for a complementary short/long order - e.g for a long order,\n                this returns the hash of it's opposite short order.\n        @param order The order to find the complementary long/short hash for.\n        @return orderHash The hash of the opposite order.\n     */\n    function hashOppositeOrder(Order memory order) public view returns (bytes32 orderHash) {\n        // use decode/encode to get a copy instead of reference\n        Order memory oppositeOrder = abi.decode(abi.encode(order), (Order));\n\n        // get the opposite side of the order (short/long)\n        oppositeOrder.isLong = !order.isLong;\n        orderHash = hashOrder(oppositeOrder);\n    }\n\n    /* ~~~ EIP-712 HELPERS ~~~ */\n\n    /**\n        @notice Hashes an order based on the eip-712 encoding scheme.\n        @param order The order to hash.\n        @return orderHash The eip-712 compliant hash of the order.\n     */\n    function hashOrder(Order memory order) public view returns (bytes32 orderHash) {\n        orderHash = keccak256(\n            abi.encode(\n                ORDER_TYPE_HASH,\n                order.maker,\n                order.isCall,\n                order.isLong,\n                order.baseAsset,\n                order.strike,\n                order.premium,\n                order.duration,\n                order.expiration,\n                order.nonce,\n                keccak256(abi.encodePacked(order.whitelist)),\n                keccak256(abi.encodePacked(order.floorTokens)),\n                keccak256(encodeERC20Assets(order.erc20Assets)),\n                keccak256(encodeERC721Assets(order.erc721Assets))\n            )\n        );\n\n        orderHash = _hashTypedDataV4(orderHash);\n    }\n\n    /**\n        @notice Encodes an array of erc20 assets following the eip-712 encoding scheme.\n        @param arr Array of erc20 assets to hash.\n        @return encoded The eip-712 encoded array of erc20 assets.\n     */\n    function encodeERC20Assets(ERC20Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC20ASSET_TYPE_HASH, arr[i].token, arr[i].tokenAmount))\n            );\n        }\n    }\n\n    /**\n        @notice Encodes an array of erc721 assets following the eip-712 encoding scheme.\n        @param arr Array of erc721 assets to hash.\n        @return encoded The eip-712 encoded array of erc721 assets.\n     */\n    function encodeERC721Assets(ERC721Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC721ASSET_TYPE_HASH, arr[i].token, arr[i].tokenId))\n            );\n        }\n    }\n\n    /**\n        @return The domain seperator used when calculating the eip-712 hash.\n     */\n    function domainSeparatorV4() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /* ~~~ OVERRIDES ~~~ */\n\n    /**\n        @notice Gets the token URI for an NFT.\n        @param id The id of the position NFT.\n        @return The tokenURI of the position NFT.\n     */\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        require(_ownerOf[id] != address(0), \"URI query for NOT_MINTED token\");\n\n        return string.concat(baseURI, Strings.toString(id));\n    }\n}\n\n\n",
        "CodeNames": [
            "PuttyV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PuttyV2 contract, fillOrder function",
                "Type": "Flashloan without fee",
                "Description": "The contract serves as a flashloan pool without fee.",
                "Repair": "Add nonReentrant to exercise and fillOrder"
            },
            {
                "Location": "PuttyV2 contract, _transferERC20sIn function",
                "Type": "Impossible to exercise put option",
                "Description": "Put option sellers can prevent exercise by specifying zero amounts, or non-existant tokens.",
                "Repair": "Verify the asset amounts and addresses during fillOrder(), and allow exercise if the token no longer exists at that point in time"
            },
            {
                "Location": "PuttyV2 contract, fillOrder function",
                "Type": "Loss of assets due to non-empty floorTokens array",
                "Description": "Create a short call order with non-empty floor makes the option impossible to exercise and withdraw.",
                "Repair": "Prohibit non-empty order.floorTokens for short calls"
            },
            {
                "Location": "PuttyV2.sol, withdraw() function",
                "Type": "Fee deduction vulnerability",
                "Description": "Fee is being deducted when Put is expired and not when it is exercised, leading to unintended deduction from assets of Put Shorter and absence of fee deduction from strike when Put is exercised.",
                "Repair": "Update the if condition to check if the order is a call option and has been exercised before deducting the fee. Add feeAmount calculation and deduction after put is exercised and strike is transferred."
            },
            {
                "Location": "PuttyV2.sol contract, function for exercised put options",
                "Type": "Missing fee deduction",
                "Description": "The current protocol implementation is missing to deduct fees for exercised put options.",
                "Repair": "Charge fees for exercised put options"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC721} from \"./utils/mocks/MockERC721.sol\";\n\nimport {ERC721TokenReceiver} from \"../tokens/ERC721.sol\";\n\ncontract ERC721Recipient is ERC721TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    bytes public data;\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        bytes calldata _data\n    ) public virtual override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        data = _data;\n\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n\ncontract RevertingERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector)));\n    }\n}\n\ncontract WrongReturnDataERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC721Recipient {}\n\ncontract ERC721Test is DSTestPlus {\n    MockERC721 token;\n\n    function setUp() public {\n        token = new MockERC721(\"Token\", \"TKN\");\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1337);\n\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337);\n        token.burn(1337);\n\n        assertEq(token.balanceOf(address(0xBEEF)), 0);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(1337);\n    }\n\n    function testApprove() public {\n        token.mint(address(this), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0xBEEF));\n    }\n\n    function testApproveBurn() public {\n        token.mint(address(this), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n\n        token.burn(1337);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.getApproved(1337), address(0));\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(1337);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.approve(address(this), 1337);\n\n        token.transferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf() public {\n        token.mint(address(this), 1337);\n\n        token.transferFrom(address(this), address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.transferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient() public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), 1337);\n        assertBytesEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData() public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), 1337, \"testing 123\");\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), 1337);\n        assertBytesEq(recipient.data(), \"testing 123\");\n    }\n\n    function testSafeMintToEOA() public {\n        token.safeMint(address(0xBEEF), 1337);\n\n        assertEq(token.ownerOf(1337), address(address(0xBEEF)));\n        assertEq(token.balanceOf(address(address(0xBEEF))), 1);\n    }\n\n    function testSafeMintToERC721Recipient() public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), 1337);\n\n        assertEq(token.ownerOf(1337), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData() public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), 1337, \"testing 123\");\n\n        assertEq(token.ownerOf(1337), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.data(), \"testing 123\");\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337);\n    }\n\n    function testFailDoubleMint() public {\n        token.mint(address(0xBEEF), 1337);\n        token.mint(address(0xBEEF), 1337);\n    }\n\n    function testFailBurnUnMinted() public {\n        token.burn(1337);\n    }\n\n    function testFailDoubleBurn() public {\n        token.mint(address(0xBEEF), 1337);\n\n        token.burn(1337);\n        token.burn(1337);\n    }\n\n    function testFailApproveUnMinted() public {\n        token.approve(address(0xBEEF), 1337);\n    }\n\n    function testFailApproveUnAuthorized() public {\n        token.mint(address(0xCAFE), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromUnOwned() public {\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromWrongFrom() public {\n        token.mint(address(0xCAFE), 1337);\n\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromToZero() public {\n        token.mint(address(this), 1337);\n\n        token.transferFrom(address(this), address(0), 1337);\n    }\n\n    function testFailTransferFromNotOwner() public {\n        token.mint(address(0xFEED), 1337);\n\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailSafeTransferFromToNonERC721Recipient() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToNonERC721RecipientWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeTransferFromToRevertingERC721Recipient() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721RecipientWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnDataWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToNonERC721Recipient() public {\n        token.safeMint(address(new NonERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToNonERC721RecipientWithData() public {\n        token.safeMint(address(new NonERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToRevertingERC721Recipient() public {\n        token.safeMint(address(new RevertingERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToRevertingERC721RecipientWithData() public {\n        token.safeMint(address(new RevertingERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnData() public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnDataWithData() public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailBalanceOfZeroAddress() public view {\n        token.balanceOf(address(0));\n    }\n\n    function testFailOwnerOfUnminted() public view {\n        token.ownerOf(1337);\n    }\n\n    function testMetadata(string memory name, string memory symbol) public {\n        MockERC721 tkn = new MockERC721(name, symbol);\n\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n    }\n\n    function testMint(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.ownerOf(id), to);\n    }\n\n    function testBurn(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n        token.burn(id);\n\n        assertEq(token.balanceOf(to), 0);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(id);\n    }\n\n    function testApprove(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(address(this), id);\n\n        token.approve(to, id);\n\n        assertEq(token.getApproved(id), to);\n    }\n\n    function testApproveBurn(address to, uint256 id) public {\n        token.mint(address(this), id);\n\n        token.approve(address(to), id);\n\n        token.burn(id);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.getApproved(id), address(0));\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(id);\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testTransferFrom(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.approve(address(this), id);\n\n        token.transferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf(uint256 id, address to) public {\n        if (to == address(0) || to == address(this)) to = address(0xBEEF);\n\n        token.mint(address(this), id);\n\n        token.transferFrom(address(this), to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.transferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient(uint256 id) public {\n        address from = address(0xABCD);\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertBytesEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), id, data);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertBytesEq(recipient.data(), data);\n    }\n\n    function testSafeMintToEOA(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.safeMint(to, id);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n    }\n\n    function testSafeMintToERC721Recipient(uint256 id) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id, data);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.data(), data);\n    }\n\n    function testFailMintToZero(uint256 id) public {\n        token.mint(address(0), id);\n    }\n\n    function testFailDoubleMint(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n        token.mint(to, id);\n    }\n\n    function testFailBurnUnMinted(uint256 id) public {\n        token.burn(id);\n    }\n\n    function testFailDoubleBurn(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n\n        token.burn(id);\n        token.burn(id);\n    }\n\n    function testFailApproveUnMinted(uint256 id, address to) public {\n        token.approve(to, id);\n    }\n\n    function testFailApproveUnAuthorized(\n        address owner,\n        uint256 id,\n        address to\n    ) public {\n        if (owner == address(0) || owner == address(this)) owner = address(0xBEEF);\n\n        token.mint(owner, id);\n\n        token.approve(to, id);\n    }\n\n    function testFailTransferFromUnOwned(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailTransferFromWrongFrom(\n        address owner,\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        if (owner == address(0)) to = address(0xBEEF);\n        if (from == owner) revert();\n\n        token.mint(owner, id);\n\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailTransferFromToZero(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.transferFrom(address(this), address(0), id);\n    }\n\n    function testFailTransferFromNotOwner(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        if (from == address(this)) from = address(0xBEEF);\n\n        token.mint(from, id);\n\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailSafeTransferFromToNonERC721Recipient(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToNonERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), id, data);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721Recipient(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), id, data);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnData(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes calldata data)\n        public\n    {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToNonERC721Recipient(uint256 id) public {\n        token.safeMint(address(new NonERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToNonERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new NonERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToRevertingERC721Recipient(uint256 id) public {\n        token.safeMint(address(new RevertingERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToRevertingERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new RevertingERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnData(uint256 id) public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), id, data);\n    }\n\n    function testFailOwnerOfUnminted(uint256 id) public view {\n        token.ownerOf(id);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n\n",
        "CodeNames": [
            "ERC721.t.sol",
            "ERC721.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "short put option order on an NFT that does not support ERC721",
                "Type": "Smart Contract Logic",
                "Description": "An attacker can create a short put option order on an NFT that does not support ERC721, and the user can fulfill the order, but cannot exercise the option.",
                "Repair": "Add a whitelist to NFTs in the order or consider supporting exercising on NFTs that do not support ERC721"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/**\n\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557    \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d    \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551    \u255a\u2588\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2554\u255d\n    \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551     \u255a\u2588\u2588\u2554\u255d      \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u255d \n    \u2588\u2588\u2551     \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551      \u2588\u2588\u2551      \u2588\u2588\u2551        \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n    \u255a\u2550\u255d      \u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d      \u255a\u2550\u255d      \u255a\u2550\u255d         \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \n                                \n            _..._               \n          .'     '.      _       \n         /    .-\"\"-\\   _/ \\ \n       .-|   /:.   |  |   |   bussin\n       |  \\  |:.   /.-'-./\n       | .-'-;:__.'    =/\n       .'=  *=|     _.='\n      /   _.  |    ;        minister you satoshi\n     ;-.-'|    \\   |\n    /   | \\    _\\  _\\\n    \\__/'._;.  ==' ==\\\n             \\    \\   |\n             /    /   / \n             /-._/-._/\n      jgs    \\   `\\  \\\n              `-._/._/\n\n\n    this is a public good.\n    by out.eth and tamagoyaki\n    \n */\n\nimport \"./lib/IWETH.sol\";\n\nimport \"openzeppelin/utils/cryptography/SignatureChecker.sol\";\nimport \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport \"openzeppelin/utils/Strings.sol\";\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC721.sol\";\n\nimport \"./PuttyV2Nft.sol\";\n\n/**\n    @title PuttyV2\n    @author out.eth\n    @notice An otc erc721 and erc20 option market.\n */\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n    /* ~~~ TYPES ~~~ */\n\n    using SafeTransferLib for ERC20;\n\n    struct ERC20Asset {\n        address token;\n        uint256 tokenAmount;\n    }\n\n    struct ERC721Asset {\n        address token;\n        uint256 tokenId;\n    }\n\n    struct Order {\n        address maker;\n        bool isCall;\n        bool isLong;\n        address baseAsset;\n        uint256 strike;\n        uint256 premium;\n        uint256 duration;\n        uint256 expiration;\n        uint256 nonce;\n        address[] whitelist;\n        address[] floorTokens;\n        ERC20Asset[] erc20Assets;\n        ERC721Asset[] erc721Assets;\n    }\n\n    /* ~~~ STATE VARIABLES ~~~ */\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC721ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC721Asset(address token,uint256 tokenId)\"));\n\n    /**\n        @dev ERC20Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC20ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC20Asset(address token,uint256 tokenAmount)\"));\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ORDER_TYPE_HASH =\n        keccak256(\n            abi.encodePacked(\n                \"Order(\",\n                \"address maker,\",\n                \"bool isCall,\",\n                \"bool isLong,\",\n                \"address baseAsset,\",\n                \"uint256 strike,\",\n                \"uint256 premium,\",\n                \"uint256 duration,\",\n                \"uint256 expiration,\",\n                \"uint256 nonce,\",\n                \"address[] whitelist,\",\n                \"address[] floorTokens,\",\n                \"ERC20Asset[] erc20Assets,\",\n                \"ERC721Asset[] erc721Assets\",\n                \")\",\n                \"ERC20Asset(address token,uint256 tokenAmount)\",\n                \"ERC721Asset(address token,uint256 tokenId)\"\n            )\n        );\n\n    /**\n        @dev Contract address for Wrapped Ethereum.\n     */\n    address public immutable weth;\n\n    /**\n        @dev baseURI used to generate the tokenURI for PuttyV2 NFTs.\n    */\n    string public baseURI;\n\n    /**\n        @notice Fee rate that is applied on exercise.\n    */\n    uint256 public fee;\n\n    /**\n        @notice Whether or not an order has been cancelled. Maps \n                from orderHash to isCancelled.\n    */\n    mapping(bytes32 => bool) public cancelledOrders;\n\n    /**\n        @notice The current expiration timestamp of a position. Maps \n                from positionId to an expiration unix timestamp.\n    */\n    mapping(uint256 => uint256) public positionExpirations;\n\n    /**\n        @notice Whether or not a position has been exercised. Maps \n                from positionId to isExercised.\n    */\n    mapping(uint256 => bool) public exercisedPositions;\n\n    /**\n        @notice The floor asset token ids for a position. Maps from \n                positionId to floor asset token ids. This should only \n                be set for a long call position in `fillOrder`, or for \n                a short put position in `exercise`.\n    */\n    mapping(uint256 => uint256[]) public positionFloorAssetTokenIds;\n\n    /* ~~~ EVENTS ~~~ */\n\n    /**\n        @notice Emitted when a new base URI is set.\n        @param baseURI The new baseURI.\n     */\n    event NewBaseURI(string baseURI);\n\n    /**\n        @notice Emitted when a new fee is set.\n        @param fee The new fee.\n     */\n    event NewFee(uint256 fee);\n\n    /**\n        @notice Emitted when an order is filled.\n        @param orderHash The hash of the order that was filled.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was filled.\n     */\n    event FilledOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is exercised.\n        @param orderHash The hash of the order that was exercised.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was exercised.\n     */\n    event ExercisedOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is withdrawn.\n        @param orderHash The hash of the order that was withdrawn.\n        @param order The order that was withdrawn.\n     */\n    event WithdrawOrder(bytes32 indexed orderHash, Order order);\n\n    /**\n        @notice emitted When an order is cancelled.\n        @param orderHash The hash of the order that was cancelled.\n        @param order The order that was cancelled.\n     */\n    event CancelledOrder(bytes32 indexed orderHash, Order order);\n\n    constructor(\n        string memory _baseURI,\n        uint256 _fee,\n        address _weth\n    ) {\n        require(_weth != address(0), \"Unset weth address\");\n\n        setBaseURI(_baseURI);\n        setFee(_fee);\n        weth = _weth;\n    }\n\n    /* ~~~ ADMIN FUNCTIONS ~~~ */\n\n    /**\n        @notice Sets a new baseURI that is used in the construction\n                of the tokenURI for each NFT position. Admin/DAO only.\n        @param _baseURI The new base URI to use.\n     */\n    function setBaseURI(string memory _baseURI) public payable onlyOwner {\n        baseURI = _baseURI;\n\n        emit NewBaseURI(_baseURI);\n    }\n\n    /**\n        @notice Sets a new fee rate that is applied on exercise. The\n                fee has a precision of 1 decimal. e.g. 1000 = 100%,\n                100 = 10%, 1 = 0.1%. Admin/DAO only.\n        @param _fee The new fee rate to use.\n     */\n    function setFee(uint256 _fee) public payable onlyOwner {\n        require(_fee < 30, \"fee must be less than 3%\");\n\n        fee = _fee;\n\n        emit NewFee(_fee);\n    }\n\n    /*\n        ~~~ MAIN LOGIC FUNCTIONS ~~~\n\n        Standard lifecycle:\n            [1] fillOrder()\n            [2] exercise()\n            [3] withdraw()\n\n            * It is also possible to cancel() an order before fillOrder()\n    */\n\n    /**\n        @notice Fills an offchain order and settles it onchain. Mints two\n                NFTs that represent the long and short position for the order.\n        @param order The order to fill.\n        @param signature The signature for the order. Signature must recover to order.maker.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when filling a long call order.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256[] memory floorAssetTokenIds\n    ) public payable returns (uint256 positionId) {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check signature is valid using EIP-712\n        require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"Invalid signature\");\n\n        // check order is not cancelled\n        require(!cancelledOrders[orderHash], \"Order has been cancelled\");\n\n        // check msg.sender is allowed to fill the order\n        require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\n        // check duration is valid\n        require(order.duration < 10_000 days, \"Duration too long\");\n\n        // check order has not expired\n        require(block.timestamp < order.expiration, \"Order has expired\");\n\n        // check base asset exists\n        require(order.baseAsset.code.length > 0, \"baseAsset is not contract\");\n\n        // check floor asset token ids length is 0 unless the order type is call and side is long\n        order.isCall && order.isLong\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokens length\");\n\n        /*  ~~~ EFFECTS ~~~ */\n\n        // create long/short position for maker\n        _mint(order.maker, uint256(orderHash));\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n        _mint(msg.sender, positionId);\n\n        // save floorAssetTokenIds if filling a long call order\n        if (order.isLong && order.isCall) {\n            positionFloorAssetTokenIds[uint256(orderHash)] = floorAssetTokenIds;\n        }\n\n        // save the long position expiration\n        positionExpirations[order.isLong ? uint256(orderHash) : positionId] = block.timestamp + order.duration;\n\n        emit FilledOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer premium to whoever is short from whomever is long\n        if (order.isLong) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n        } else {\n            // handle the case where the user uses native ETH instead of WETH to pay the premium\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n        }\n\n        // filling short put: transfer strike from maker to contract\n        if (!order.isLong && !order.isCall) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, address(this), order.strike);\n            return positionId;\n        }\n\n        // filling long put: transfer strike from taker to contract\n        if (order.isLong && !order.isCall) {\n            // handle the case where the taker uses native ETH instead of WETH to deposit the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in exercise() works\n                // - because exercise() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            return positionId;\n        }\n\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n\n        // filling long call: transfer assets from taker to contract\n        if (order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n            return positionId;\n        }\n    }\n\n    /**\n        @notice Exercises a long order and also burns the long position NFT which \n                represents it.\n        @param order The order of the position to exercise.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when exercising a put order.\n     */\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check user owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        // check position is long\n        require(order.isLong, \"Can only exercise long positions\");\n\n        // check position has not expired\n        require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n\n        // check floor asset token ids length is 0 unless the position type is put\n        !order.isCall\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the long position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        // mark the position as exercised\n        exercisedPositions[uint256(orderHash)] = true;\n\n        emit ExercisedOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        } else {\n            // -- exercising a put option\n\n            // save the floor asset token ids to the short position\n            uint256 shortPositionId = uint256(hashOppositeOrder(order));\n            positionFloorAssetTokenIds[shortPositionId] = floorAssetTokenIds;\n\n            // transfer strike from putty to exerciser\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n\n            // transfer assets from exerciser to putty\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n        }\n    }\n\n    /**\n        @notice Withdraws the assets from a short order and also burns the short position \n                that represents it. The assets that are withdrawn are dependent on whether \n                the order is exercised or expired and if the order is a put or call.\n        @param order The order to withdraw.\n     */\n    function withdraw(Order memory order) public {\n        /* ~~~ CHECKS ~~~ */\n\n        // check order is short\n        require(!order.isLong, \"Must be short position\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check msg.sender owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        uint256 longPositionId = uint256(hashOppositeOrder(order));\n        bool isExercised = exercisedPositions[longPositionId];\n\n        // check long position has either been exercised or is expired\n        require(block.timestamp > positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the short position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        emit WithdrawOrder(orderHash, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer strike to owner if put is expired or call is exercised\n        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n            // send the fee to the admin/DAO if fee is greater than 0%\n            uint256 feeAmount = 0;\n            if (fee > 0) {\n                feeAmount = (order.strike * fee) / 1000;\n                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n            }\n\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n            return;\n        }\n\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n    }\n\n    /**\n        @notice Cancels an order which prevents it from being filled in the future.\n        @param order The order to cancel.\n     */\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n        emit CancelledOrder(orderHash, order);\n    }\n\n    /* ~~~ PERIPHERY LOGIC FUNCTIONS ~~~ */\n\n    /**\n        @notice Batch fills multiple orders.\n        @param orders The orders to fill.\n        @param signatures The signatures to use for each respective order.\n        @param floorAssetTokenIds The floorAssetTokenIds to use for each respective order.\n        @return positionIds The ids of the position NFT that the msg.sender receives.\n     */\n    function batchFillOrder(\n        Order[] memory orders,\n        bytes[] calldata signatures,\n        uint256[][] memory floorAssetTokenIds\n    ) public returns (uint256[] memory positionIds) {\n        require(orders.length == signatures.length, \"Length mismatch in input\");\n        require(signatures.length == floorAssetTokenIds.length, \"Length mismatch in input\");\n\n        positionIds = new uint256[](orders.length);\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            positionIds[i] = fillOrder(orders[i], signatures[i], floorAssetTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Accepts a counter offer for an order. It fills the counter offer, and then\n                cancels the original order that the counter offer was made for.\n        @dev There is no need for floorTokenIds here because there is no situation in which\n             it makes sense to have them when accepting counter offers. When accepting a counter \n             offer for a short call order, the complementary long call order already knows what \n             tokenIds are used in the short call so floorTokens should always be empty.\n        @param order The counter offer to accept.\n        @param signature The signature for the counter offer.\n        @param originalOrder The original order that the counter was made for.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n\n    /* ~~~ HELPER FUNCTIONS ~~~ */\n\n    /**\n        @notice Transfers an array of erc20s into the contract from an address.\n        @param assets The erc20 tokens and amounts to transfer in.\n        @param from Who to transfer the erc20 assets from.\n     */\n    function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            address token = assets[i].token;\n            uint256 tokenAmount = assets[i].tokenAmount;\n\n            require(token.code.length > 0, \"ERC20: Token is not contract\");\n            require(tokenAmount > 0, \"ERC20: Amount too small\");\n\n            ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721s into the contract from an address.\n        @param assets The erc721 tokens and token ids to transfer in.\n        @param from Who to transfer the erc721 assets from.\n     */\n    function _transferERC721sIn(ERC721Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(from, address(this), assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens into the contract from an address.\n        @param floorTokens The contract addresses of each erc721.\n        @param floorTokenIds The token id of each erc721.\n        @param from Who to transfer the floor tokens from.\n     */\n    function _transferFloorsIn(\n        address[] memory floorTokens,\n        uint256[] memory floorTokenIds,\n        address from\n    ) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc20 tokens to the msg.sender.\n        @param assets The erc20 tokens and amounts to send.\n     */\n    function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 tokens to the msg.sender.\n        @param assets The erc721 tokens and token ids to send.\n     */\n    function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens to the msg.sender.\n        @param floorTokens The contract addresses for each floor token.\n        @param floorTokenIds The token id of each floor token.\n     */\n    function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Checks whether or not an address exists in the whitelist.\n        @param whitelist The whitelist to check against.\n        @param target The target address to check.\n        @return If it exists in the whitelist or not.\n     */\n    function isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n        for (uint256 i = 0; i < whitelist.length; i++) {\n            if (target == whitelist[i]) return true;\n        }\n\n        return false;\n    }\n\n    /**\n        @notice Get the orderHash for a complementary short/long order - e.g for a long order,\n                this returns the hash of it's opposite short order.\n        @param order The order to find the complementary long/short hash for.\n        @return orderHash The hash of the opposite order.\n     */\n    function hashOppositeOrder(Order memory order) public view returns (bytes32 orderHash) {\n        // use decode/encode to get a copy instead of reference\n        Order memory oppositeOrder = abi.decode(abi.encode(order), (Order));\n\n        // get the opposite side of the order (short/long)\n        oppositeOrder.isLong = !order.isLong;\n        orderHash = hashOrder(oppositeOrder);\n    }\n\n    /* ~~~ EIP-712 HELPERS ~~~ */\n\n    /**\n        @notice Hashes an order based on the eip-712 encoding scheme.\n        @param order The order to hash.\n        @return orderHash The eip-712 compliant hash of the order.\n     */\n    function hashOrder(Order memory order) public view returns (bytes32 orderHash) {\n        orderHash = keccak256(\n            abi.encode(\n                ORDER_TYPE_HASH,\n                order.maker,\n                order.isCall,\n                order.isLong,\n                order.baseAsset,\n                order.strike,\n                order.premium,\n                order.duration,\n                order.expiration,\n                order.nonce,\n                keccak256(abi.encodePacked(order.whitelist)),\n                keccak256(abi.encodePacked(order.floorTokens)),\n                keccak256(encodeERC20Assets(order.erc20Assets)),\n                keccak256(encodeERC721Assets(order.erc721Assets))\n            )\n        );\n\n        orderHash = _hashTypedDataV4(orderHash);\n    }\n\n    /**\n        @notice Encodes an array of erc20 assets following the eip-712 encoding scheme.\n        @param arr Array of erc20 assets to hash.\n        @return encoded The eip-712 encoded array of erc20 assets.\n     */\n    function encodeERC20Assets(ERC20Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC20ASSET_TYPE_HASH, arr[i].token, arr[i].tokenAmount))\n            );\n        }\n    }\n\n    /**\n        @notice Encodes an array of erc721 assets following the eip-712 encoding scheme.\n        @param arr Array of erc721 assets to hash.\n        @return encoded The eip-712 encoded array of erc721 assets.\n     */\n    function encodeERC721Assets(ERC721Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC721ASSET_TYPE_HASH, arr[i].token, arr[i].tokenId))\n            );\n        }\n    }\n\n    /**\n        @return The domain seperator used when calculating the eip-712 hash.\n     */\n    function domainSeparatorV4() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /* ~~~ OVERRIDES ~~~ */\n\n    /**\n        @notice Gets the token URI for an NFT.\n        @param id The id of the position NFT.\n        @return The tokenURI of the position NFT.\n     */\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        require(_ownerOf[id] != address(0), \"URI query for NOT_MINTED token\");\n\n        return string.concat(baseURI, Strings.toString(id));\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\n\ncontract ERC20Test is DSTestPlus {\n    MockERC20 token;\n\n    bytes32 constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n        assertEq(token.decimals(), 18);\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1e18);\n\n        assertEq(token.totalSupply(), 1e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1e18);\n        token.burn(address(0xBEEF), 0.9e18);\n\n        assertEq(token.totalSupply(), 1e18 - 0.9e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 0.1e18);\n    }\n\n    function testApprove() public {\n        assertTrue(token.approve(address(0xBEEF), 1e18));\n\n        assertEq(token.allowance(address(this), address(0xBEEF)), 1e18);\n    }\n\n    function testTransfer() public {\n        token.mint(address(this), 1e18);\n\n        assertTrue(token.transfer(address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 1e18);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), 0);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testInfiniteApproveTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), type(uint256).max);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), type(uint256).max);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testPermit() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n\n        assertEq(token.allowance(owner, address(0xCAFE)), 1e18);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testFailTransferInsufficientBalance() public {\n        token.mint(address(this), 0.9e18);\n        token.transfer(address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromInsufficientAllowance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 0.9e18);\n\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 0.9e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 1e18);\n\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testFailPermitBadNonce() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 1, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testFailPermitBadDeadline() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp + 1, v, r, s);\n    }\n\n    function testFailPermitPastDeadline() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp - 1))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp - 1, v, r, s);\n    }\n\n    function testFailPermitReplay() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testMetadata(\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 tkn = new MockERC20(name, symbol, decimals);\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n        assertEq(tkn.decimals(), decimals);\n    }\n\n    function testMint(address from, uint256 amount) public {\n        token.mint(from, amount);\n\n        assertEq(token.totalSupply(), amount);\n        assertEq(token.balanceOf(from), amount);\n    }\n\n    function testBurn(\n        address from,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(from, mintAmount);\n        token.burn(from, burnAmount);\n\n        assertEq(token.totalSupply(), mintAmount - burnAmount);\n        assertEq(token.balanceOf(from), mintAmount - burnAmount);\n    }\n\n    function testApprove(address to, uint256 amount) public {\n        assertTrue(token.approve(to, amount));\n\n        assertEq(token.allowance(address(this), to), amount);\n    }\n\n    function testTransfer(address from, uint256 amount) public {\n        token.mint(address(this), amount);\n\n        assertTrue(token.transfer(from, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == from) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(from), amount);\n        }\n    }\n\n    function testTransferFrom(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = bound(amount, 0, approval);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        hevm.prank(from);\n        token.approve(address(this), approval);\n\n        assertTrue(token.transferFrom(from, to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        uint256 app = from == address(this) || approval == type(uint256).max ? approval : approval - amount;\n        assertEq(token.allowance(from, address(this)), app);\n\n        if (from == to) {\n            assertEq(token.balanceOf(from), amount);\n        } else {\n            assertEq(token.balanceOf(from), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testPermit(\n        uint248 privKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        uint256 privateKey = privKey;\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n\n        assertEq(token.allowance(owner, to), amount);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, mintAmount);\n        token.burn(to, burnAmount);\n    }\n\n    function testFailTransferInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), mintAmount);\n        token.transfer(to, sendAmount);\n    }\n\n    function testFailTransferFromInsufficientAllowance(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = bound(amount, approval + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        hevm.prank(from);\n        token.approve(address(this), approval);\n\n        token.transferFrom(from, to, amount);\n    }\n\n    function testFailTransferFromInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, mintAmount);\n\n        hevm.prank(from);\n        token.approve(address(this), sendAmount);\n\n        token.transferFrom(from, to, sendAmount);\n    }\n\n    function testFailPermitBadNonce(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint256 nonce\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n        if (nonce == 0) nonce = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, nonce, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testFailPermitBadDeadline(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline + 1, v, r, s);\n    }\n\n    function testFailPermitPastDeadline(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        deadline = bound(deadline, 0, block.timestamp - 1);\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testFailPermitReplay(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n}\n\ncontract ERC20Invariants is DSTestPlus, DSInvariantTest {\n    BalanceSum balanceSum;\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n        balanceSum = new BalanceSum(token);\n\n        addTargetContract(address(balanceSum));\n    }\n\n    function invariantBalanceSum() public {\n        assertEq(token.totalSupply(), balanceSum.sum());\n    }\n}\n\ncontract BalanceSum {\n    MockERC20 token;\n    uint256 public sum;\n\n    constructor(MockERC20 _token) {\n        token = _token;\n    }\n\n    function mint(address from, uint256 amount) public {\n        token.mint(from, amount);\n        sum += amount;\n    }\n\n    function burn(address from, uint256 amount) public {\n        token.burn(from, amount);\n        sum -= amount;\n    }\n\n    function approve(address to, uint256 amount) public {\n        token.approve(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        token.transferFrom(from, to, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        token.transfer(to, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC20.sol",
            "PuttyV2.sol",
            "ERC20.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ERC20.transferFrom() function call in PuttyV2.sol contract",
                "Type": "Zero strike call options can be systemically used to steal premium from the taker",
                "Description": "Malicious maker can create short call order with zero strike value, receive the premium, wait for expiry, and withdraw the assets, effectively collecting the premium for free.",
                "Repair": "Conditioning call's logic on 'order.strike > 0'"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC721} from \"./utils/mocks/MockERC721.sol\";\n\nimport {ERC721TokenReceiver} from \"../tokens/ERC721.sol\";\n\ncontract ERC721Recipient is ERC721TokenReceiver {\n    address public operator;\n    address public from;\n    uint256 public id;\n    bytes public data;\n\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        bytes calldata _data\n    ) public virtual override returns (bytes4) {\n        operator = _operator;\n        from = _from;\n        id = _id;\n        data = _data;\n\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n\ncontract RevertingERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        revert(string(abi.encodePacked(ERC721TokenReceiver.onERC721Received.selector)));\n    }\n}\n\ncontract WrongReturnDataERC721Recipient is ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return 0xCAFEBEEF;\n    }\n}\n\ncontract NonERC721Recipient {}\n\ncontract ERC721Test is DSTestPlus {\n    MockERC721 token;\n\n    function setUp() public {\n        token = new MockERC721(\"Token\", \"TKN\");\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1337);\n\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1337);\n        token.burn(1337);\n\n        assertEq(token.balanceOf(address(0xBEEF)), 0);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(1337);\n    }\n\n    function testApprove() public {\n        token.mint(address(this), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0xBEEF));\n    }\n\n    function testApproveBurn() public {\n        token.mint(address(this), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n\n        token.burn(1337);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.getApproved(1337), address(0));\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(1337);\n    }\n\n    function testApproveAll() public {\n        token.setApprovalForAll(address(0xBEEF), true);\n\n        assertTrue(token.isApprovedForAll(address(this), address(0xBEEF)));\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.approve(address(this), 1337);\n\n        token.transferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf() public {\n        token.mint(address(this), 1337);\n\n        token.transferFrom(address(this), address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.transferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(0xBEEF), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(0xBEEF));\n        assertEq(token.balanceOf(address(0xBEEF)), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient() public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), 1337);\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), 1337);\n        assertBytesEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData() public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, 1337);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), 1337, \"testing 123\");\n\n        assertEq(token.getApproved(1337), address(0));\n        assertEq(token.ownerOf(1337), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), 1337);\n        assertBytesEq(recipient.data(), \"testing 123\");\n    }\n\n    function testSafeMintToEOA() public {\n        token.safeMint(address(0xBEEF), 1337);\n\n        assertEq(token.ownerOf(1337), address(address(0xBEEF)));\n        assertEq(token.balanceOf(address(address(0xBEEF))), 1);\n    }\n\n    function testSafeMintToERC721Recipient() public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), 1337);\n\n        assertEq(token.ownerOf(1337), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData() public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), 1337, \"testing 123\");\n\n        assertEq(token.ownerOf(1337), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), 1337);\n        assertBytesEq(to.data(), \"testing 123\");\n    }\n\n    function testFailMintToZero() public {\n        token.mint(address(0), 1337);\n    }\n\n    function testFailDoubleMint() public {\n        token.mint(address(0xBEEF), 1337);\n        token.mint(address(0xBEEF), 1337);\n    }\n\n    function testFailBurnUnMinted() public {\n        token.burn(1337);\n    }\n\n    function testFailDoubleBurn() public {\n        token.mint(address(0xBEEF), 1337);\n\n        token.burn(1337);\n        token.burn(1337);\n    }\n\n    function testFailApproveUnMinted() public {\n        token.approve(address(0xBEEF), 1337);\n    }\n\n    function testFailApproveUnAuthorized() public {\n        token.mint(address(0xCAFE), 1337);\n\n        token.approve(address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromUnOwned() public {\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromWrongFrom() public {\n        token.mint(address(0xCAFE), 1337);\n\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailTransferFromToZero() public {\n        token.mint(address(this), 1337);\n\n        token.transferFrom(address(this), address(0), 1337);\n    }\n\n    function testFailTransferFromNotOwner() public {\n        token.mint(address(0xFEED), 1337);\n\n        token.transferFrom(address(0xFEED), address(0xBEEF), 1337);\n    }\n\n    function testFailSafeTransferFromToNonERC721Recipient() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToNonERC721RecipientWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeTransferFromToRevertingERC721Recipient() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721RecipientWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), 1337);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnDataWithData() public {\n        token.mint(address(this), 1337);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToNonERC721Recipient() public {\n        token.safeMint(address(new NonERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToNonERC721RecipientWithData() public {\n        token.safeMint(address(new NonERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToRevertingERC721Recipient() public {\n        token.safeMint(address(new RevertingERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToRevertingERC721RecipientWithData() public {\n        token.safeMint(address(new RevertingERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnData() public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), 1337);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnDataWithData() public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), 1337, \"testing 123\");\n    }\n\n    function testFailBalanceOfZeroAddress() public view {\n        token.balanceOf(address(0));\n    }\n\n    function testFailOwnerOfUnminted() public view {\n        token.ownerOf(1337);\n    }\n\n    function testMetadata(string memory name, string memory symbol) public {\n        MockERC721 tkn = new MockERC721(name, symbol);\n\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n    }\n\n    function testMint(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.ownerOf(id), to);\n    }\n\n    function testBurn(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n        token.burn(id);\n\n        assertEq(token.balanceOf(to), 0);\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(id);\n    }\n\n    function testApprove(address to, uint256 id) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(address(this), id);\n\n        token.approve(to, id);\n\n        assertEq(token.getApproved(id), to);\n    }\n\n    function testApproveBurn(address to, uint256 id) public {\n        token.mint(address(this), id);\n\n        token.approve(address(to), id);\n\n        token.burn(id);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.getApproved(id), address(0));\n\n        hevm.expectRevert(\"NOT_MINTED\");\n        token.ownerOf(id);\n    }\n\n    function testApproveAll(address to, bool approved) public {\n        token.setApprovalForAll(to, approved);\n\n        assertBoolEq(token.isApprovedForAll(address(this), to), approved);\n    }\n\n    function testTransferFrom(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.approve(address(this), id);\n\n        token.transferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testTransferFromSelf(uint256 id, address to) public {\n        if (to == address(0) || to == address(this)) to = address(0xBEEF);\n\n        token.mint(address(this), id);\n\n        token.transferFrom(address(this), to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(address(this)), 0);\n    }\n\n    function testTransferFromApproveAll(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.transferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToEOA(uint256 id, address to) public {\n        address from = address(0xABCD);\n\n        if (to == address(0) || to == from) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, to, id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), to);\n        assertEq(token.balanceOf(to), 1);\n        assertEq(token.balanceOf(from), 0);\n    }\n\n    function testSafeTransferFromToERC721Recipient(uint256 id) public {\n        address from = address(0xABCD);\n\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), id);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertBytesEq(recipient.data(), \"\");\n    }\n\n    function testSafeTransferFromToERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        address from = address(0xABCD);\n        ERC721Recipient recipient = new ERC721Recipient();\n\n        token.mint(from, id);\n\n        hevm.prank(from);\n        token.setApprovalForAll(address(this), true);\n\n        token.safeTransferFrom(from, address(recipient), id, data);\n\n        assertEq(token.getApproved(id), address(0));\n        assertEq(token.ownerOf(id), address(recipient));\n        assertEq(token.balanceOf(address(recipient)), 1);\n        assertEq(token.balanceOf(from), 0);\n\n        assertEq(recipient.operator(), address(this));\n        assertEq(recipient.from(), from);\n        assertEq(recipient.id(), id);\n        assertBytesEq(recipient.data(), data);\n    }\n\n    function testSafeMintToEOA(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        if (uint256(uint160(to)) <= 18 || to.code.length > 0) return;\n\n        token.safeMint(to, id);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n    }\n\n    function testSafeMintToERC721Recipient(uint256 id) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.data(), \"\");\n    }\n\n    function testSafeMintToERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        ERC721Recipient to = new ERC721Recipient();\n\n        token.safeMint(address(to), id, data);\n\n        assertEq(token.ownerOf(id), address(to));\n        assertEq(token.balanceOf(address(to)), 1);\n\n        assertEq(to.operator(), address(this));\n        assertEq(to.from(), address(0));\n        assertEq(to.id(), id);\n        assertBytesEq(to.data(), data);\n    }\n\n    function testFailMintToZero(uint256 id) public {\n        token.mint(address(0), id);\n    }\n\n    function testFailDoubleMint(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n        token.mint(to, id);\n    }\n\n    function testFailBurnUnMinted(uint256 id) public {\n        token.burn(id);\n    }\n\n    function testFailDoubleBurn(uint256 id, address to) public {\n        if (to == address(0)) to = address(0xBEEF);\n\n        token.mint(to, id);\n\n        token.burn(id);\n        token.burn(id);\n    }\n\n    function testFailApproveUnMinted(uint256 id, address to) public {\n        token.approve(to, id);\n    }\n\n    function testFailApproveUnAuthorized(\n        address owner,\n        uint256 id,\n        address to\n    ) public {\n        if (owner == address(0) || owner == address(this)) owner = address(0xBEEF);\n\n        token.mint(owner, id);\n\n        token.approve(to, id);\n    }\n\n    function testFailTransferFromUnOwned(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailTransferFromWrongFrom(\n        address owner,\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        if (owner == address(0)) to = address(0xBEEF);\n        if (from == owner) revert();\n\n        token.mint(owner, id);\n\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailTransferFromToZero(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.transferFrom(address(this), address(0), id);\n    }\n\n    function testFailTransferFromNotOwner(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        if (from == address(this)) from = address(0xBEEF);\n\n        token.mint(from, id);\n\n        token.transferFrom(from, to, id);\n    }\n\n    function testFailSafeTransferFromToNonERC721Recipient(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToNonERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new NonERC721Recipient()), id, data);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721Recipient(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToRevertingERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new RevertingERC721Recipient()), id, data);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnData(uint256 id) public {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), id);\n    }\n\n    function testFailSafeTransferFromToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes calldata data)\n        public\n    {\n        token.mint(address(this), id);\n\n        token.safeTransferFrom(address(this), address(new WrongReturnDataERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToNonERC721Recipient(uint256 id) public {\n        token.safeMint(address(new NonERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToNonERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new NonERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToRevertingERC721Recipient(uint256 id) public {\n        token.safeMint(address(new RevertingERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToRevertingERC721RecipientWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new RevertingERC721Recipient()), id, data);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnData(uint256 id) public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), id);\n    }\n\n    function testFailSafeMintToERC721RecipientWithWrongReturnDataWithData(uint256 id, bytes calldata data) public {\n        token.safeMint(address(new WrongReturnDataERC721Recipient()), id, data);\n    }\n\n    function testFailOwnerOfUnminted(uint256 id) public view {\n        token.ownerOf(id);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {DSInvariantTest} from \"./utils/DSInvariantTest.sol\";\n\nimport {MockERC20} from \"./utils/mocks/MockERC20.sol\";\n\ncontract ERC20Test is DSTestPlus {\n    MockERC20 token;\n\n    bytes32 constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n    }\n\n    function invariantMetadata() public {\n        assertEq(token.name(), \"Token\");\n        assertEq(token.symbol(), \"TKN\");\n        assertEq(token.decimals(), 18);\n    }\n\n    function testMint() public {\n        token.mint(address(0xBEEF), 1e18);\n\n        assertEq(token.totalSupply(), 1e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1e18);\n        token.burn(address(0xBEEF), 0.9e18);\n\n        assertEq(token.totalSupply(), 1e18 - 0.9e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 0.1e18);\n    }\n\n    function testApprove() public {\n        assertTrue(token.approve(address(0xBEEF), 1e18));\n\n        assertEq(token.allowance(address(this), address(0xBEEF)), 1e18);\n    }\n\n    function testTransfer() public {\n        token.mint(address(this), 1e18);\n\n        assertTrue(token.transfer(address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 1e18);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), 0);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testInfiniteApproveTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), type(uint256).max);\n\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), type(uint256).max);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testPermit() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n\n        assertEq(token.allowance(owner, address(0xCAFE)), 1e18);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testFailTransferInsufficientBalance() public {\n        token.mint(address(this), 0.9e18);\n        token.transfer(address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromInsufficientAllowance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 0.9e18);\n\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testFailTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 0.9e18);\n\n        hevm.prank(from);\n        token.approve(address(this), 1e18);\n\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testFailPermitBadNonce() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 1, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testFailPermitBadDeadline() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp + 1, v, r, s);\n    }\n\n    function testFailPermitPastDeadline() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp - 1))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp - 1, v, r, s);\n    }\n\n    function testFailPermitReplay() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testMetadata(\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public {\n        MockERC20 tkn = new MockERC20(name, symbol, decimals);\n        assertEq(tkn.name(), name);\n        assertEq(tkn.symbol(), symbol);\n        assertEq(tkn.decimals(), decimals);\n    }\n\n    function testMint(address from, uint256 amount) public {\n        token.mint(from, amount);\n\n        assertEq(token.totalSupply(), amount);\n        assertEq(token.balanceOf(from), amount);\n    }\n\n    function testBurn(\n        address from,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(from, mintAmount);\n        token.burn(from, burnAmount);\n\n        assertEq(token.totalSupply(), mintAmount - burnAmount);\n        assertEq(token.balanceOf(from), mintAmount - burnAmount);\n    }\n\n    function testApprove(address to, uint256 amount) public {\n        assertTrue(token.approve(to, amount));\n\n        assertEq(token.allowance(address(this), to), amount);\n    }\n\n    function testTransfer(address from, uint256 amount) public {\n        token.mint(address(this), amount);\n\n        assertTrue(token.transfer(from, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == from) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(from), amount);\n        }\n    }\n\n    function testTransferFrom(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = bound(amount, 0, approval);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        hevm.prank(from);\n        token.approve(address(this), approval);\n\n        assertTrue(token.transferFrom(from, to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        uint256 app = from == address(this) || approval == type(uint256).max ? approval : approval - amount;\n        assertEq(token.allowance(from, address(this)), app);\n\n        if (from == to) {\n            assertEq(token.balanceOf(from), amount);\n        } else {\n            assertEq(token.balanceOf(from), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testPermit(\n        uint248 privKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        uint256 privateKey = privKey;\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n\n        assertEq(token.allowance(owner, to), amount);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testFailBurnInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 burnAmount\n    ) public {\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, mintAmount);\n        token.burn(to, burnAmount);\n    }\n\n    function testFailTransferInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), mintAmount);\n        token.transfer(to, sendAmount);\n    }\n\n    function testFailTransferFromInsufficientAllowance(\n        address to,\n        uint256 approval,\n        uint256 amount\n    ) public {\n        amount = bound(amount, approval + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        hevm.prank(from);\n        token.approve(address(this), approval);\n\n        token.transferFrom(from, to, amount);\n    }\n\n    function testFailTransferFromInsufficientBalance(\n        address to,\n        uint256 mintAmount,\n        uint256 sendAmount\n    ) public {\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, mintAmount);\n\n        hevm.prank(from);\n        token.approve(address(this), sendAmount);\n\n        token.transferFrom(from, to, sendAmount);\n    }\n\n    function testFailPermitBadNonce(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint256 nonce\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n        if (nonce == 0) nonce = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, nonce, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testFailPermitBadDeadline(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline + 1, v, r, s);\n    }\n\n    function testFailPermitPastDeadline(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        deadline = bound(deadline, 0, block.timestamp - 1);\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testFailPermitReplay(\n        uint256 privateKey,\n        address to,\n        uint256 amount,\n        uint256 deadline\n    ) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = hevm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = hevm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n}\n\ncontract ERC20Invariants is DSTestPlus, DSInvariantTest {\n    BalanceSum balanceSum;\n    MockERC20 token;\n\n    function setUp() public {\n        token = new MockERC20(\"Token\", \"TKN\", 18);\n        balanceSum = new BalanceSum(token);\n\n        addTargetContract(address(balanceSum));\n    }\n\n    function invariantBalanceSum() public {\n        assertEq(token.totalSupply(), balanceSum.sum());\n    }\n}\n\ncontract BalanceSum {\n    MockERC20 token;\n    uint256 public sum;\n\n    constructor(MockERC20 _token) {\n        token = _token;\n    }\n\n    function mint(address from, uint256 amount) public {\n        token.mint(from, amount);\n        sum += amount;\n    }\n\n    function burn(address from, uint256 amount) public {\n        token.burn(from, amount);\n        sum -= amount;\n    }\n\n    function approve(address to, uint256 amount) public {\n        token.approve(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        token.transferFrom(from, to, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        token.transfer(to, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n/**\n\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557    \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d    \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551    \u255a\u2588\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2554\u255d\n    \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551     \u255a\u2588\u2588\u2554\u255d      \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u255d \n    \u2588\u2588\u2551     \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551      \u2588\u2588\u2551      \u2588\u2588\u2551        \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n    \u255a\u2550\u255d      \u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d      \u255a\u2550\u255d      \u255a\u2550\u255d         \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \n                                \n            _..._               \n          .'     '.      _       \n         /    .-\"\"-\\   _/ \\ \n       .-|   /:.   |  |   |   bussin\n       |  \\  |:.   /.-'-./\n       | .-'-;:__.'    =/\n       .'=  *=|     _.='\n      /   _.  |    ;        minister you satoshi\n     ;-.-'|    \\   |\n    /   | \\    _\\  _\\\n    \\__/'._;.  ==' ==\\\n             \\    \\   |\n             /    /   / \n             /-._/-._/\n      jgs    \\   `\\  \\\n              `-._/._/\n\n\n    this is a public good.\n    by out.eth and tamagoyaki\n    \n */\n\nimport \"./lib/IWETH.sol\";\n\nimport \"openzeppelin/utils/cryptography/SignatureChecker.sol\";\nimport \"openzeppelin/utils/cryptography/draft-EIP712.sol\";\nimport \"openzeppelin/utils/Strings.sol\";\nimport \"openzeppelin/access/Ownable.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"solmate/tokens/ERC721.sol\";\n\nimport \"./PuttyV2Nft.sol\";\n\n/**\n    @title PuttyV2\n    @author out.eth\n    @notice An otc erc721 and erc20 option market.\n */\ncontract PuttyV2 is PuttyV2Nft, EIP712(\"Putty\", \"2.0\"), ERC721TokenReceiver, Ownable {\n    /* ~~~ TYPES ~~~ */\n\n    using SafeTransferLib for ERC20;\n\n    struct ERC20Asset {\n        address token;\n        uint256 tokenAmount;\n    }\n\n    struct ERC721Asset {\n        address token;\n        uint256 tokenId;\n    }\n\n    struct Order {\n        address maker;\n        bool isCall;\n        bool isLong;\n        address baseAsset;\n        uint256 strike;\n        uint256 premium;\n        uint256 duration;\n        uint256 expiration;\n        uint256 nonce;\n        address[] whitelist;\n        address[] floorTokens;\n        ERC20Asset[] erc20Assets;\n        ERC721Asset[] erc721Assets;\n    }\n\n    /* ~~~ STATE VARIABLES ~~~ */\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC721ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC721Asset(address token,uint256 tokenId)\"));\n\n    /**\n        @dev ERC20Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ERC20ASSET_TYPE_HASH =\n        keccak256(abi.encodePacked(\"ERC20Asset(address token,uint256 tokenAmount)\"));\n\n    /**\n        @dev ERC721Asset type hash used for EIP-712 encoding.\n     */\n    bytes32 public constant ORDER_TYPE_HASH =\n        keccak256(\n            abi.encodePacked(\n                \"Order(\",\n                \"address maker,\",\n                \"bool isCall,\",\n                \"bool isLong,\",\n                \"address baseAsset,\",\n                \"uint256 strike,\",\n                \"uint256 premium,\",\n                \"uint256 duration,\",\n                \"uint256 expiration,\",\n                \"uint256 nonce,\",\n                \"address[] whitelist,\",\n                \"address[] floorTokens,\",\n                \"ERC20Asset[] erc20Assets,\",\n                \"ERC721Asset[] erc721Assets\",\n                \")\",\n                \"ERC20Asset(address token,uint256 tokenAmount)\",\n                \"ERC721Asset(address token,uint256 tokenId)\"\n            )\n        );\n\n    /**\n        @dev Contract address for Wrapped Ethereum.\n     */\n    address public immutable weth;\n\n    /**\n        @dev baseURI used to generate the tokenURI for PuttyV2 NFTs.\n    */\n    string public baseURI;\n\n    /**\n        @notice Fee rate that is applied on exercise.\n    */\n    uint256 public fee;\n\n    /**\n        @notice Whether or not an order has been cancelled. Maps \n                from orderHash to isCancelled.\n    */\n    mapping(bytes32 => bool) public cancelledOrders;\n\n    /**\n        @notice The current expiration timestamp of a position. Maps \n                from positionId to an expiration unix timestamp.\n    */\n    mapping(uint256 => uint256) public positionExpirations;\n\n    /**\n        @notice Whether or not a position has been exercised. Maps \n                from positionId to isExercised.\n    */\n    mapping(uint256 => bool) public exercisedPositions;\n\n    /**\n        @notice The floor asset token ids for a position. Maps from \n                positionId to floor asset token ids. This should only \n                be set for a long call position in `fillOrder`, or for \n                a short put position in `exercise`.\n    */\n    mapping(uint256 => uint256[]) public positionFloorAssetTokenIds;\n\n    /* ~~~ EVENTS ~~~ */\n\n    /**\n        @notice Emitted when a new base URI is set.\n        @param baseURI The new baseURI.\n     */\n    event NewBaseURI(string baseURI);\n\n    /**\n        @notice Emitted when a new fee is set.\n        @param fee The new fee.\n     */\n    event NewFee(uint256 fee);\n\n    /**\n        @notice Emitted when an order is filled.\n        @param orderHash The hash of the order that was filled.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was filled.\n     */\n    event FilledOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is exercised.\n        @param orderHash The hash of the order that was exercised.\n        @param floorAssetTokenIds The floor asset token ids that were used.\n        @param order The order that was exercised.\n     */\n    event ExercisedOrder(bytes32 indexed orderHash, uint256[] floorAssetTokenIds, Order order);\n\n    /**\n        @notice Emitted when an order is withdrawn.\n        @param orderHash The hash of the order that was withdrawn.\n        @param order The order that was withdrawn.\n     */\n    event WithdrawOrder(bytes32 indexed orderHash, Order order);\n\n    /**\n        @notice emitted When an order is cancelled.\n        @param orderHash The hash of the order that was cancelled.\n        @param order The order that was cancelled.\n     */\n    event CancelledOrder(bytes32 indexed orderHash, Order order);\n\n    constructor(\n        string memory _baseURI,\n        uint256 _fee,\n        address _weth\n    ) {\n        require(_weth != address(0), \"Unset weth address\");\n\n        setBaseURI(_baseURI);\n        setFee(_fee);\n        weth = _weth;\n    }\n\n    /* ~~~ ADMIN FUNCTIONS ~~~ */\n\n    /**\n        @notice Sets a new baseURI that is used in the construction\n                of the tokenURI for each NFT position. Admin/DAO only.\n        @param _baseURI The new base URI to use.\n     */\n    function setBaseURI(string memory _baseURI) public payable onlyOwner {\n        baseURI = _baseURI;\n\n        emit NewBaseURI(_baseURI);\n    }\n\n    /**\n        @notice Sets a new fee rate that is applied on exercise. The\n                fee has a precision of 1 decimal. e.g. 1000 = 100%,\n                100 = 10%, 1 = 0.1%. Admin/DAO only.\n        @param _fee The new fee rate to use.\n     */\n    function setFee(uint256 _fee) public payable onlyOwner {\n        require(_fee < 30, \"fee must be less than 3%\");\n\n        fee = _fee;\n\n        emit NewFee(_fee);\n    }\n\n    /*\n        ~~~ MAIN LOGIC FUNCTIONS ~~~\n\n        Standard lifecycle:\n            [1] fillOrder()\n            [2] exercise()\n            [3] withdraw()\n\n            * It is also possible to cancel() an order before fillOrder()\n    */\n\n    /**\n        @notice Fills an offchain order and settles it onchain. Mints two\n                NFTs that represent the long and short position for the order.\n        @param order The order to fill.\n        @param signature The signature for the order. Signature must recover to order.maker.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when filling a long call order.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function fillOrder(\n        Order memory order,\n        bytes calldata signature,\n        uint256[] memory floorAssetTokenIds\n    ) public payable returns (uint256 positionId) {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check signature is valid using EIP-712\n        require(SignatureChecker.isValidSignatureNow(order.maker, orderHash, signature), \"Invalid signature\");\n\n        // check order is not cancelled\n        require(!cancelledOrders[orderHash], \"Order has been cancelled\");\n\n        // check msg.sender is allowed to fill the order\n        require(order.whitelist.length == 0 || isWhitelisted(order.whitelist, msg.sender), \"Not whitelisted\");\n\n        // check duration is valid\n        require(order.duration < 10_000 days, \"Duration too long\");\n\n        // check order has not expired\n        require(block.timestamp < order.expiration, \"Order has expired\");\n\n        // check base asset exists\n        require(order.baseAsset.code.length > 0, \"baseAsset is not contract\");\n\n        // check floor asset token ids length is 0 unless the order type is call and side is long\n        order.isCall && order.isLong\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokens length\");\n\n        /*  ~~~ EFFECTS ~~~ */\n\n        // create long/short position for maker\n        _mint(order.maker, uint256(orderHash));\n\n        // create opposite long/short position for taker\n        bytes32 oppositeOrderHash = hashOppositeOrder(order);\n        positionId = uint256(oppositeOrderHash);\n        _mint(msg.sender, positionId);\n\n        // save floorAssetTokenIds if filling a long call order\n        if (order.isLong && order.isCall) {\n            positionFloorAssetTokenIds[uint256(orderHash)] = floorAssetTokenIds;\n        }\n\n        // save the long position expiration\n        positionExpirations[order.isLong ? uint256(orderHash) : positionId] = block.timestamp + order.duration;\n\n        emit FilledOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer premium to whoever is short from whomever is long\n        if (order.isLong) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, msg.sender, order.premium);\n        } else {\n            // handle the case where the user uses native ETH instead of WETH to pay the premium\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the premium\n                require(msg.value == order.premium, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH and send premium to maker\n                // converting to WETH instead of forwarding native ETH to the maker has two benefits;\n                // 1) active market makers will mostly be using WETH not native ETH\n                // 2) attack surface for re-entrancy is reduced\n                IWETH(weth).deposit{value: msg.value}();\n                IWETH(weth).transfer(order.maker, msg.value);\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, order.maker, order.premium);\n            }\n        }\n\n        // filling short put: transfer strike from maker to contract\n        if (!order.isLong && !order.isCall) {\n            ERC20(order.baseAsset).safeTransferFrom(order.maker, address(this), order.strike);\n            return positionId;\n        }\n\n        // filling long put: transfer strike from taker to contract\n        if (order.isLong && !order.isCall) {\n            // handle the case where the taker uses native ETH instead of WETH to deposit the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in exercise() works\n                // - because exercise() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            return positionId;\n        }\n\n        // filling short call: transfer assets from maker to contract\n        if (!order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, order.maker);\n            _transferERC721sIn(order.erc721Assets, order.maker);\n            return positionId;\n        }\n\n        // filling long call: transfer assets from taker to contract\n        if (order.isLong && order.isCall) {\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n            return positionId;\n        }\n    }\n\n    /**\n        @notice Exercises a long order and also burns the long position NFT which \n                represents it.\n        @param order The order of the position to exercise.\n        @param floorAssetTokenIds The floor asset token ids to use. Should only be set \n               when exercising a put order.\n     */\n    function exercise(Order memory order, uint256[] calldata floorAssetTokenIds) public payable {\n        /* ~~~ CHECKS ~~~ */\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check user owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        // check position is long\n        require(order.isLong, \"Can only exercise long positions\");\n\n        // check position has not expired\n        require(block.timestamp < positionExpirations[uint256(orderHash)], \"Position has expired\");\n\n        // check floor asset token ids length is 0 unless the position type is put\n        !order.isCall\n            ? require(floorAssetTokenIds.length == order.floorTokens.length, \"Wrong amount of floor tokenIds\")\n            : require(floorAssetTokenIds.length == 0, \"Invalid floor tokenIds length\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the long position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        // mark the position as exercised\n        exercisedPositions[uint256(orderHash)] = true;\n\n        emit ExercisedOrder(orderHash, floorAssetTokenIds, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        if (order.isCall) {\n            // -- exercising a call option\n\n            // transfer strike from exerciser to putty\n            // handle the case where the taker uses native ETH instead of WETH to pay the strike\n            if (weth == order.baseAsset && msg.value > 0) {\n                // check enough ETH was sent to cover the strike\n                require(msg.value == order.strike, \"Incorrect ETH amount sent\");\n\n                // convert ETH to WETH\n                // we convert the strike ETH to WETH so that the logic in withdraw() works\n                // - because withdraw() assumes an ERC20 interface on the base asset.\n                IWETH(weth).deposit{value: msg.value}();\n            } else {\n                ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n            }\n\n            // transfer assets from putty to exerciser\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[uint256(orderHash)]);\n        } else {\n            // -- exercising a put option\n\n            // save the floor asset token ids to the short position\n            uint256 shortPositionId = uint256(hashOppositeOrder(order));\n            positionFloorAssetTokenIds[shortPositionId] = floorAssetTokenIds;\n\n            // transfer strike from putty to exerciser\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike);\n\n            // transfer assets from exerciser to putty\n            _transferERC20sIn(order.erc20Assets, msg.sender);\n            _transferERC721sIn(order.erc721Assets, msg.sender);\n            _transferFloorsIn(order.floorTokens, floorAssetTokenIds, msg.sender);\n        }\n    }\n\n    /**\n        @notice Withdraws the assets from a short order and also burns the short position \n                that represents it. The assets that are withdrawn are dependent on whether \n                the order is exercised or expired and if the order is a put or call.\n        @param order The order to withdraw.\n     */\n    function withdraw(Order memory order) public {\n        /* ~~~ CHECKS ~~~ */\n\n        // check order is short\n        require(!order.isLong, \"Must be short position\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // check msg.sender owns the position\n        require(ownerOf(uint256(orderHash)) == msg.sender, \"Not owner\");\n\n        uint256 longPositionId = uint256(hashOppositeOrder(order));\n        bool isExercised = exercisedPositions[longPositionId];\n\n        // check long position has either been exercised or is expired\n        require(block.timestamp > positionExpirations[longPositionId] || isExercised, \"Must be exercised or expired\");\n\n        /* ~~~ EFFECTS ~~~ */\n\n        // send the short position to 0xdead.\n        // instead of doing a standard burn by sending to 0x000...000, sending\n        // to 0xdead ensures that the same position id cannot be minted again.\n        transferFrom(msg.sender, address(0xdead), uint256(orderHash));\n\n        emit WithdrawOrder(orderHash, order);\n\n        /* ~~~ INTERACTIONS ~~~ */\n\n        // transfer strike to owner if put is expired or call is exercised\n        if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n            // send the fee to the admin/DAO if fee is greater than 0%\n            uint256 feeAmount = 0;\n            if (fee > 0) {\n                feeAmount = (order.strike * fee) / 1000;\n                ERC20(order.baseAsset).safeTransfer(owner(), feeAmount);\n            }\n\n            ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n            return;\n        }\n\n        // transfer assets from putty to owner if put is exercised or call is expired\n        if ((order.isCall && !isExercised) || (!order.isCall && isExercised)) {\n            _transferERC20sOut(order.erc20Assets);\n            _transferERC721sOut(order.erc721Assets);\n\n            // for call options the floor token ids are saved in the long position in fillOrder(),\n            // and for put options the floor tokens ids are saved in the short position in exercise()\n            uint256 floorPositionId = order.isCall ? longPositionId : uint256(orderHash);\n            _transferFloorsOut(order.floorTokens, positionFloorAssetTokenIds[floorPositionId]);\n\n            return;\n        }\n    }\n\n    /**\n        @notice Cancels an order which prevents it from being filled in the future.\n        @param order The order to cancel.\n     */\n    function cancel(Order memory order) public {\n        require(msg.sender == order.maker, \"Not your order\");\n\n        bytes32 orderHash = hashOrder(order);\n\n        // mark the order as cancelled\n        cancelledOrders[orderHash] = true;\n\n        emit CancelledOrder(orderHash, order);\n    }\n\n    /* ~~~ PERIPHERY LOGIC FUNCTIONS ~~~ */\n\n    /**\n        @notice Batch fills multiple orders.\n        @param orders The orders to fill.\n        @param signatures The signatures to use for each respective order.\n        @param floorAssetTokenIds The floorAssetTokenIds to use for each respective order.\n        @return positionIds The ids of the position NFT that the msg.sender receives.\n     */\n    function batchFillOrder(\n        Order[] memory orders,\n        bytes[] calldata signatures,\n        uint256[][] memory floorAssetTokenIds\n    ) public returns (uint256[] memory positionIds) {\n        require(orders.length == signatures.length, \"Length mismatch in input\");\n        require(signatures.length == floorAssetTokenIds.length, \"Length mismatch in input\");\n\n        positionIds = new uint256[](orders.length);\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            positionIds[i] = fillOrder(orders[i], signatures[i], floorAssetTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Accepts a counter offer for an order. It fills the counter offer, and then\n                cancels the original order that the counter offer was made for.\n        @dev There is no need for floorTokenIds here because there is no situation in which\n             it makes sense to have them when accepting counter offers. When accepting a counter \n             offer for a short call order, the complementary long call order already knows what \n             tokenIds are used in the short call so floorTokens should always be empty.\n        @param order The counter offer to accept.\n        @param signature The signature for the counter offer.\n        @param originalOrder The original order that the counter was made for.\n        @return positionId The id of the position NFT that the msg.sender receives.\n     */\n    function acceptCounterOffer(\n        Order memory order,\n        bytes calldata signature,\n        Order memory originalOrder\n    ) public payable returns (uint256 positionId) {\n        // cancel the original order\n        cancel(originalOrder);\n\n        // accept the counter offer\n        uint256[] memory floorAssetTokenIds = new uint256[](0);\n        positionId = fillOrder(order, signature, floorAssetTokenIds);\n    }\n\n    /* ~~~ HELPER FUNCTIONS ~~~ */\n\n    /**\n        @notice Transfers an array of erc20s into the contract from an address.\n        @param assets The erc20 tokens and amounts to transfer in.\n        @param from Who to transfer the erc20 assets from.\n     */\n    function _transferERC20sIn(ERC20Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            address token = assets[i].token;\n            uint256 tokenAmount = assets[i].tokenAmount;\n\n            require(token.code.length > 0, \"ERC20: Token is not contract\");\n            require(tokenAmount > 0, \"ERC20: Amount too small\");\n\n            ERC20(token).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721s into the contract from an address.\n        @param assets The erc721 tokens and token ids to transfer in.\n        @param from Who to transfer the erc721 assets from.\n     */\n    function _transferERC721sIn(ERC721Asset[] memory assets, address from) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(from, address(this), assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens into the contract from an address.\n        @param floorTokens The contract addresses of each erc721.\n        @param floorTokenIds The token id of each erc721.\n        @param from Who to transfer the floor tokens from.\n     */\n    function _transferFloorsIn(\n        address[] memory floorTokens,\n        uint256[] memory floorTokenIds,\n        address from\n    ) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(from, address(this), floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc20 tokens to the msg.sender.\n        @param assets The erc20 tokens and amounts to send.\n     */\n    function _transferERC20sOut(ERC20Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC20(assets[i].token).safeTransfer(msg.sender, assets[i].tokenAmount);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 tokens to the msg.sender.\n        @param assets The erc721 tokens and token ids to send.\n     */\n    function _transferERC721sOut(ERC721Asset[] memory assets) internal {\n        for (uint256 i = 0; i < assets.length; i++) {\n            ERC721(assets[i].token).safeTransferFrom(address(this), msg.sender, assets[i].tokenId);\n        }\n    }\n\n    /**\n        @notice Transfers an array of erc721 floor tokens to the msg.sender.\n        @param floorTokens The contract addresses for each floor token.\n        @param floorTokenIds The token id of each floor token.\n     */\n    function _transferFloorsOut(address[] memory floorTokens, uint256[] memory floorTokenIds) internal {\n        for (uint256 i = 0; i < floorTokens.length; i++) {\n            ERC721(floorTokens[i]).safeTransferFrom(address(this), msg.sender, floorTokenIds[i]);\n        }\n    }\n\n    /**\n        @notice Checks whether or not an address exists in the whitelist.\n        @param whitelist The whitelist to check against.\n        @param target The target address to check.\n        @return If it exists in the whitelist or not.\n     */\n    function isWhitelisted(address[] memory whitelist, address target) public pure returns (bool) {\n        for (uint256 i = 0; i < whitelist.length; i++) {\n            if (target == whitelist[i]) return true;\n        }\n\n        return false;\n    }\n\n    /**\n        @notice Get the orderHash for a complementary short/long order - e.g for a long order,\n                this returns the hash of it's opposite short order.\n        @param order The order to find the complementary long/short hash for.\n        @return orderHash The hash of the opposite order.\n     */\n    function hashOppositeOrder(Order memory order) public view returns (bytes32 orderHash) {\n        // use decode/encode to get a copy instead of reference\n        Order memory oppositeOrder = abi.decode(abi.encode(order), (Order));\n\n        // get the opposite side of the order (short/long)\n        oppositeOrder.isLong = !order.isLong;\n        orderHash = hashOrder(oppositeOrder);\n    }\n\n    /* ~~~ EIP-712 HELPERS ~~~ */\n\n    /**\n        @notice Hashes an order based on the eip-712 encoding scheme.\n        @param order The order to hash.\n        @return orderHash The eip-712 compliant hash of the order.\n     */\n    function hashOrder(Order memory order) public view returns (bytes32 orderHash) {\n        orderHash = keccak256(\n            abi.encode(\n                ORDER_TYPE_HASH,\n                order.maker,\n                order.isCall,\n                order.isLong,\n                order.baseAsset,\n                order.strike,\n                order.premium,\n                order.duration,\n                order.expiration,\n                order.nonce,\n                keccak256(abi.encodePacked(order.whitelist)),\n                keccak256(abi.encodePacked(order.floorTokens)),\n                keccak256(encodeERC20Assets(order.erc20Assets)),\n                keccak256(encodeERC721Assets(order.erc721Assets))\n            )\n        );\n\n        orderHash = _hashTypedDataV4(orderHash);\n    }\n\n    /**\n        @notice Encodes an array of erc20 assets following the eip-712 encoding scheme.\n        @param arr Array of erc20 assets to hash.\n        @return encoded The eip-712 encoded array of erc20 assets.\n     */\n    function encodeERC20Assets(ERC20Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC20ASSET_TYPE_HASH, arr[i].token, arr[i].tokenAmount))\n            );\n        }\n    }\n\n    /**\n        @notice Encodes an array of erc721 assets following the eip-712 encoding scheme.\n        @param arr Array of erc721 assets to hash.\n        @return encoded The eip-712 encoded array of erc721 assets.\n     */\n    function encodeERC721Assets(ERC721Asset[] memory arr) public pure returns (bytes memory encoded) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            encoded = abi.encodePacked(\n                encoded,\n                keccak256(abi.encode(ERC721ASSET_TYPE_HASH, arr[i].token, arr[i].tokenId))\n            );\n        }\n    }\n\n    /**\n        @return The domain seperator used when calculating the eip-712 hash.\n     */\n    function domainSeparatorV4() public view returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /* ~~~ OVERRIDES ~~~ */\n\n    /**\n        @notice Gets the token URI for an NFT.\n        @param id The id of the position NFT.\n        @return The tokenURI of the position NFT.\n     */\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        require(_ownerOf[id] != address(0), \"URI query for NOT_MINTED token\");\n\n        return string.concat(baseURI, Strings.toString(id));\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC721.sol",
            "ERC721.t.sol",
            "ERC20.t.sol",
            "ERC20.sol",
            "PuttyV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ERC721.transferFrom() and ERC20.transferFrom() function calls in PuttyV2.sol contract",
                "Type": "Overlap between ERC721.transferFrom() and ERC20.transferFrom() allows order.erc20Assets or order.baseAsset to be ERC721 rather than ERC20",
                "Description": "ERC721 tokens transferred into the contract via fillOrder() will be permanently stuck in the contract as neither exercise() nor withdraw() will successfully transfer the tokens out of the contract.",
                "Repair": "Whitelisting approved ERC721 and ERC20 token contracts and separating them into different whitelists for ERC20s and ERC721s"
            }
        ]
    }
]