[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "depositEther transaction",
                "Type": "Frontrunning",
                "Description": "A malicious validator can frontrun depositEther transaction for its pubKey and deposit 1 ether for different withdrawal credential, thereby setting withdrawal credit before deposit of 32 ether by contract and thereby when 32 deposit ether are deposited, the withdrawal credential is also what was set before rather than the one being sent in depositEther transaction.",
                "Repair": "N/A"
            },
            {
                "Location": "ETH staking balance",
                "Type": "Slashing penalty",
                "Description": "The main risk in ETH 2.0 POS staking is the slashing penalty, in that case the frxETH will not be pegged and the validator cannot maintain a minimum 32 ETH staking balance.",
                "Repair": "Add mechanism to ensure frxETH is pegged via burning if case the ETH got slashed"
            },
            {
                "Location": "recoverERC20 function",
                "Type": "Non-conforming ERC20 tokens",
                "Description": "There are tokens that do not return a value on success, which will cause the call to revert, even when the transfer would have been successful. This means that those tokens will be stuck forever and not be recoverable.",
                "Repair": "Use OpenZeppelin's safeTransfer"
            },
            {
                "Location": "deposit() and redeem() functions",
                "Type": "Yield Stealing",
                "Description": "Malicious users can steal yields from innocent users by picking special timing to deposit() and redeem().",
                "Repair": "Release the lastRewardAmount immediately or only allow users to redeem yields received after 1 rewards cycle after the deposit"
            },
            {
                "Location": "removeValidator() and removeMinter() functions",
                "Type": "Unbounded Loop",
                "Description": "There is an unbounded loop in removeValidator() and removeMinter() functions such that if the validators or minters_array array gets sufficiently large, this function call will fail due to exceeding the gas limit.",
                "Repair": "Designate one minter as a 'pre-minter' that has a batch of tokens minted to it beforehand, then auxiliary contracts can connect to that instead of ERC20PermitPermissionedMint.sol instead"
            },
            {
                "Location": "recoverEther function and moveWithheldETH function",
                "Type": "Incorrect accounting",
                "Description": "recoverEther and moveWithheldETH functions do not update currentWithheldETH and send withheld ETH back to the frxETHMinter contract itself, leading to incorrect accounting and duplication of accounting for the ETHs which have been already converted to the frxETH tokens.",
                "Repair": "Update currentWithheldETH in recoverEther function and add a non-feedback payable empty function to receive special ETH without increasing the frxeth supply"
            },
            {
                "Location": "depositEther function",
                "Type": "Out of gas",
                "Description": "depositEther function always iterates over all deposits that are possible with the current balance, leading to out of gas error when a lot of ETH was deposited into the contract or it was not called in a long time.",
                "Repair": "Specify an upper limit for the number of deposits such that progress is possible"
            },
            {
                "Location": "depositEther() function",
                "Type": "DoS",
                "Description": "If 1 validators is used before, the whole deposit function will revert, causing DoS. And in the next rewards cycle, lastRewardAmount will be linearly added to storedTotalAssets, their sum is the return value of totalAssets(). Temporarily the depositEther() function will be inaccessible. Until the governance calls the registry to pop the wrong validator.",
                "Repair": "Use try/catch to skip the wrong validator"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ============================== sfrxETH =============================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Nader Ghazvini: https://github.com/amirnader-ghazvini \n\n// Reviewer(s) / Contributor(s)\n// Sam Kazemian: https://github.com/samkazemian\n// Dennett: https://github.com/denett\n// Travis Moore: https://github.com/FortisFortuna\n// Jamie Turley: https://github.com/jyturley\n\nimport { ERC20, ERC4626, xERC4626 } from \"ERC4626/xERC4626.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Vault token for staked frxETH\n/// @notice Is a vault that takes frxETH and gives you sfrxETH erc20 tokens\n/** @dev Exchange rate between frxETH and sfrxETH floats, you can convert your sfrxETH for more frxETH over time.\n    Exchange rate increases as the frax msig mints new frxETH corresponding to the staking yield and drops it into the vault (sfrxETH contract).\n    There is a short time period, \u201ccycles\u201d which the exchange rate increases linearly over. This is to prevent gaming the exchange rate (MEV).\n    The cycles are constant length, but calling syncRewards slightly into a would-be cycle keeps the same would-be endpoint (so cycle ends are every X seconds).\n    Someone must call syncRewards, which queues any new frxETH in the contract to be added to the redeemable amount.\n    sfrxETH adheres to ERC-4626 vault specs \n    Mint vs Deposit\n    mint() - deposit targeting a specific number of sfrxETH out\n    deposit() - deposit knowing a specific number of frxETH in */\ncontract sfrxETH is xERC4626, ReentrancyGuard {\n    /* ========== CONSTRUCTOR ========== */\n    constructor(ERC20 _underlying, uint32 _rewardsCycleLength)\n        ERC4626(_underlying, \"Staked Frax Ether\", \"sfrxETH\")\n        xERC4626(_rewardsCycleLength)\n    {}\n\n    /// @notice Syncs rewards if applicable beforehand. Noop if otherwise \n    function beforeWithdraw(uint256 assets, uint256 shares) internal override {\n        super.beforeWithdraw(assets, shares); // call xERC4626's beforeWithdraw first\n        if (block.timestamp >= rewardsCycleEnd) { syncRewards(); } \n    }\n\n    /// @notice How much frxETH is 1E18 sfrxETH worth. Price is in ETH, not USD\n    function pricePerShare() public view returns (uint256) {\n        return convertToAssets(1e18);\n    }\n\n    /// @notice Approve and deposit() in one transaction\n    function depositWithSignature(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant returns (uint256 shares) {\n        uint256 amount = approveMax ? type(uint256).max : assets;\n        asset.permit(msg.sender, address(this), amount, deadline, v, r, s);\n        return (deposit(assets, receiver));\n    }\n\n    /// @notice Approve and mint() in one transaction\n    /// @dev Similar to the deposit method, but you give it the number of shares you want instead.\n    function mintWithSignature(\n        uint256 shares,\n        address receiver,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant returns (uint256 assets) {\n        uint256 amount = approveMax ? type(uint256).max : previewMint(shares);\n        asset.permit(msg.sender, address(this), amount, deadline, v, r, s);\n        return (mint(shares, receiver));\n    }\n\n}\n\n\n",
        "CodeNames": [
            "sfrxETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "mintWithSignature() function in sfrxETH contracts",
                "Type": "Volatile previewMint() result",
                "Description": "The result of previewMint() changes with the state of the contract, which causes the value of amount to be volatile in the mintWithSignature function when approveMax is false.",
                "Repair": "Modify the smart contract to prevent the return value of previewMint() from changing while the transaction is waiting to be included in a block"
            },
            {
                "Location": "sfrxETH.beforeWithdraw function",
                "Type": "Wrong accounting logic",
                "Description": "The assets have not been transferred out yet, meaning asset.balanceOf(address(this)) still has the old value. On the other hand, storedTotalAssets was already updated. Therefore, the nextRewards calculation will be inflated by the amount for which the withdrawal was requested. This has severe consequences: During the following reward period, lastRewardAmount is too high, which means that too many rewards are paid out to users who want to withdraw. A user could exploit this to steal the assets of other users. When syncRewards() is called the next time, it is possible that the nextRewards calculation underflows because lastRewardAmount  asset.balanceOf(address(this)). This is very bad because syncRewards() will be called in every withdrawal (after the rewardsCycleEnd) and none of them will succeed because of the underflow.",
                "Repair": "Call syncRewards() before decrementing storedTotalAssets"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { DepositContract } from \"../src/DepositContract.sol\";\nimport { frxETHMinter, OperatorRegistry } from \"../src/frxETHMinter.sol\";\nimport { frxETH } from \"../src/frxETH.sol\";\nimport { sfrxETH, ERC20 } from \"../src/sfrxETH.sol\";\n\ncontract frxETHMinterTest is Test {\n    frxETH frxETHToken;\n    sfrxETH sfrxETHToken;\n    frxETHMinter minter;\n\n    address constant DEPOSIT_CONTRACT_ADDRESS = 0x00000000219ab540356cBB839Cbe05303d7705Fa;\n    address constant FRAX_COMPTROLLER = 0xB1748C79709f4Ba2Dd82834B8c82D4a505003f27;\n    address constant FRAX_TIMELOCK = 0x8412ebf45bAC1B340BbE8F318b928C466c4E39CA;\n    bytes[5] pubKeys;\n    bytes[5] sigs;\n    bytes32[5] ddRoots;\n    bytes[5] withdrawalCreds;\n\n    uint32 constant REWARDS_CYCLE_LENGTH = 1000;\n\n    function setUp() public {\n        // Make sure you are forking mainnet first\n        require(block.chainid == 1, 'Need to fork ETH mainnet for this test');\n        \n        // Set some .env variables\n        // Must be done at compile time due to .env loading)\n        pubKeys = [vm.envBytes(\"VALIDATOR_TEST_PUBKEY1\"), vm.envBytes(\"VALIDATOR_TEST_PUBKEY2\"), vm.envBytes(\"VALIDATOR_TEST_PUBKEY3\"), vm.envBytes(\"VALIDATOR_TEST_PUBKEY4\"), vm.envBytes(\"VALIDATOR_TEST_PUBKEY5\")];\n        sigs = [vm.envBytes(\"VALIDATOR_TEST_SIG1\"), vm.envBytes(\"VALIDATOR_TEST_SIG2\"), vm.envBytes(\"VALIDATOR_TEST_SIG3\"), vm.envBytes(\"VALIDATOR_TEST_SIG4\"), vm.envBytes(\"VALIDATOR_TEST_SIG5\")];\n        ddRoots = [vm.envBytes32(\"VALIDATOR_TEST_DDROOT1\"), vm.envBytes32(\"VALIDATOR_TEST_DDROOT2\"), vm.envBytes32(\"VALIDATOR_TEST_DDROOT3\"), vm.envBytes32(\"VALIDATOR_TEST_DDROOT4\"), vm.envBytes32(\"VALIDATOR_TEST_DDROOT5\")];\n        withdrawalCreds = [vm.envBytes(\"VALIDATOR_TEST_WITHDRAWAL_CREDENTIALS1\"), vm.envBytes(\"VALIDATOR_TEST_WITHDRAWAL_CREDENTIALS2\"), vm.envBytes(\"VALIDATOR_TEST_WITHDRAWAL_CREDENTIALS3\"), vm.envBytes(\"VALIDATOR_TEST_WITHDRAWAL_CREDENTIALS4\"), vm.envBytes(\"VALIDATOR_TEST_WITHDRAWAL_CREDENTIALS5\")];\n\n        // Instantiate the new contracts\n        frxETHToken = new frxETH(FRAX_COMPTROLLER, FRAX_TIMELOCK);\n        sfrxETHToken = new sfrxETH(ERC20(address(frxETHToken)), REWARDS_CYCLE_LENGTH);\n        minter = new frxETHMinter(DEPOSIT_CONTRACT_ADDRESS, address(frxETHToken), address(sfrxETHToken), FRAX_COMPTROLLER, FRAX_TIMELOCK, withdrawalCreds[1]);\n        \n        // Add the new frxETHMinter as a minter for frxETH\n        vm.startPrank(FRAX_COMPTROLLER);\n        frxETHToken.addMinter(address(minter));\n        vm.stopPrank();\n    }\n    \n    function testAddKey() public {\n        vm.startPrank(FRAX_COMPTROLLER);\n        \n        // Add a validator\n        minter.addValidator(OperatorRegistry.Validator(pubKeys[0], sigs[0], ddRoots[0]));\n\n        vm.stopPrank();\n    }\n\n    function testBatchAdd() public {\n        vm.startPrank(FRAX_COMPTROLLER);\n\n        // Add two validators to an array\n        OperatorRegistry.Validator[] memory validators = new OperatorRegistry.Validator[](2);\n        validators[0] = (OperatorRegistry.Validator(pubKeys[0], sigs[0], ddRoots[0]));\n        validators[1] = (OperatorRegistry.Validator(pubKeys[1], sigs[1], ddRoots[1]));\n\n        // Prep the emit for the 1st validator to be checked\n        vm.expectEmit(false, false, false, true);\n        emit ValidatorAdded(pubKeys[0], withdrawalCreds[0]);\n        \n        // Prep the emit for the 2nd validator to be checked\n        vm.expectEmit(false, false, false, true);\n        emit ValidatorAdded(pubKeys[1], withdrawalCreds[1]);\n\n        // Add both validators\n        minter.addValidators(validators);\n\n        vm.stopPrank();\n    }\n\n    function testSwapValidator() public {\n        vm.startPrank(FRAX_COMPTROLLER);\n\n        // Add three validators to an array\n        OperatorRegistry.Validator[] memory validators = new OperatorRegistry.Validator[](3);\n        validators[0] = (OperatorRegistry.Validator(pubKeys[0], sigs[0], ddRoots[0]));\n        validators[1] = (OperatorRegistry.Validator(pubKeys[1], sigs[1], ddRoots[1]));\n        validators[2] = (OperatorRegistry.Validator(pubKeys[2], sigs[2], ddRoots[2]));\n\n        // Add all 3 validators\n        minter.addValidators(validators);\n\n        // Swap the 0th validator with the 2nd one\n        vm.expectEmit(true, true, true, true);\n        emit ValidatorsSwapped(pubKeys[0], pubKeys[2], 0, 2);\n        minter.swapValidator(0, 2);\n\n        // Check the array itself too\n        (bytes memory pubKeyNew0, , , ) = minter.getValidator(0);\n        (bytes memory pubKeyNew2, , , ) = minter.getValidator(2);\n        assertEq(pubKeyNew0, pubKeys[2]);\n        assertEq(pubKeyNew2, pubKeys[0]);\n\n        vm.stopPrank();\n    }\n\n    function testPopValidators() public {\n        vm.startPrank(FRAX_COMPTROLLER);\n\n        // Add three validators to an array\n        OperatorRegistry.Validator[] memory validators = new OperatorRegistry.Validator[](3);\n        validators[0] = (OperatorRegistry.Validator(pubKeys[0], sigs[0], ddRoots[0]));\n        validators[1] = (OperatorRegistry.Validator(pubKeys[1], sigs[1], ddRoots[1]));\n        validators[2] = (OperatorRegistry.Validator(pubKeys[2], sigs[2], ddRoots[2]));\n\n        // Add all 3 validators\n        minter.addValidators(validators);\n\n        // Pop two of them off\n        vm.expectEmit(true, false, false, true);\n        emit ValidatorsPopped(2);\n        minter.popValidators(2);\n\n        // Check the array itself too\n        uint256 new_length = minter.numValidators();\n        assertEq(new_length, 1);\n\n        vm.stopPrank();\n    }\n\n    function testRemoveValidatorDontCareAboutOrder() public {\n        vm.startPrank(FRAX_COMPTROLLER);\n\n        // Add five validators to an array\n        OperatorRegistry.Validator[] memory validators = new OperatorRegistry.Validator[](5);\n        validators[0] = (OperatorRegistry.Validator(pubKeys[0], sigs[0], ddRoots[0]));\n        validators[1] = (OperatorRegistry.Validator(pubKeys[1], sigs[1], ddRoots[1]));\n        validators[2] = (OperatorRegistry.Validator(pubKeys[2], sigs[2], ddRoots[2]));\n        validators[3] = (OperatorRegistry.Validator(pubKeys[3], sigs[3], ddRoots[3]));\n        validators[4] = (OperatorRegistry.Validator(pubKeys[4], sigs[4], ddRoots[4]));\n\n        // Add all 5 validators\n        minter.addValidators(validators);\n\n        // Get the info for the last validator (will be used later for a check)\n        (bytes memory valOld4PubKey, , , ) = minter.getValidator(4);\n\n        // Remove the validator at index 2, using the swap and pop method\n        vm.expectEmit(false, false, false, true);\n        emit ValidatorRemoved(pubKeys[2], 2, true);\n        minter.removeValidator(2, true);\n\n        // Check the array length to make sure it was reduced by 1\n        uint256 new_length = minter.numValidators();\n        assertEq(new_length, 4);\n\n        // Check the array itself too\n        // Validator at index 2 should be the one that used to be at the end (index 4)\n        (bytes memory valNew2PubKey, , , ) = minter.getValidator(2);\n        assertEq(valNew2PubKey, valOld4PubKey);\n\n        vm.stopPrank();\n    }\n\n    function testRemoveValidatorKeepOrdering() public {\n        vm.startPrank(FRAX_COMPTROLLER);\n\n        // Add five validators to an array\n        OperatorRegistry.Validator[] memory validators = new OperatorRegistry.Validator[](5);\n        validators[0] = (OperatorRegistry.Validator(pubKeys[0], sigs[0], ddRoots[0]));\n        validators[1] = (OperatorRegistry.Validator(pubKeys[1], sigs[1], ddRoots[1]));\n        validators[2] = (OperatorRegistry.Validator(pubKeys[2], sigs[2], ddRoots[2]));\n        validators[3] = (OperatorRegistry.Validator(pubKeys[3], sigs[3], ddRoots[3]));\n        validators[4] = (OperatorRegistry.Validator(pubKeys[4], sigs[4], ddRoots[4]));\n\n        // Add all 5 validators\n        minter.addValidators(validators);\n\n        // Get the info for the 3rd and 4th validators (will be used later for a check)\n        (bytes memory valOld3PubKey, , , ) = minter.getValidator(3);\n        (bytes memory valOld4PubKey, , , ) = minter.getValidator(4);\n\n        // Remove the validator at index 2, using the gassy loop method\n        // This preserves the ordering\n        vm.expectEmit(false, false, false, true);\n        emit ValidatorRemoved(pubKeys[2], 2, false);\n        minter.removeValidator(2, false);\n\n        // Check the array length to make sure it was reduced by 1\n        uint256 new_length = minter.numValidators();\n        assertEq(new_length, 4);\n\n        // Check the array itself too\n        // Validator at index 3 should now be at index 2\n        // Validator at index 4 should now be at index 3\n        (bytes memory valNew2PubKey, , , ) = minter.getValidator(2);\n        (bytes memory valNew3PubKey, , , ) = minter.getValidator(3);\n        assertEq(valNew2PubKey, valOld3PubKey);\n        assertEq(valNew3PubKey, valOld4PubKey);\n\n        vm.stopPrank();\n    }\n\n    function testSubmitAndDepositEther() public {\n        vm.startPrank(FRAX_COMPTROLLER);\n        \n        // Add a validator\n        minter.addValidator(OperatorRegistry.Validator(pubKeys[0], sigs[0], ddRoots[0]));\n\n        // Give the comptroller 320 ETH\n        vm.deal(FRAX_COMPTROLLER, 320 ether);\n\n        // Deposit 16 ETH for frxETH\n        vm.expectEmit(true, true, false, true);\n        emit TokenMinterMinted(address(minter), FRAX_COMPTROLLER, 16 ether);\n        vm.expectEmit(true, true, false, true);\n        emit ETHSubmitted(FRAX_COMPTROLLER, FRAX_COMPTROLLER, 16 ether, 0);\n        minter.submit{ value: 16 ether }();\n\n        // Deposit 15 ETH for frxETH, pure send (tests receive fallback)\n        vm.expectEmit(true, true, false, true);\n        emit TokenMinterMinted(address(minter), FRAX_COMPTROLLER, 15 ether);\n        vm.expectEmit(true, true, false, true);\n        emit ETHSubmitted(FRAX_COMPTROLLER, FRAX_COMPTROLLER, 15 ether, 0);\n        address(minter).call{ value: 15 ether }(\"\");\n\n        // Try having the validator deposit.\n        // Should fail due to lack of ETH\n        vm.expectRevert(\"Not enough ETH in contract\");\n        minter.depositEther();\n\n        // Deposit last 1 ETH for frxETH, making the total 32.\n        // Uses submitAndGive as an alternate method. Timelock will get the frxETH but the validator doesn't care\n        vm.expectEmit(true, true, false, true);\n        emit TokenMinterMinted(address(minter), FRAX_TIMELOCK, 1 ether);\n        vm.expectEmit(true, true, false, true);\n        emit ETHSubmitted(FRAX_COMPTROLLER, FRAX_TIMELOCK, 1 ether, 0);\n        minter.submitAndGive{ value: 1 ether }(FRAX_TIMELOCK);\n        \n        // Move the 32 ETH to the validator\n        minter.depositEther();\n\n        // Try having the validator deposit another 32 ETH.\n        // Should fail due to lack of ETH\n        vm.expectRevert(\"Not enough ETH in contract\");\n        minter.depositEther();\n\n        // Deposit 32 ETH for frxETH\n        minter.submit{ value: 32 ether }();\n\n        // Try having the validator deposit another 32 ETH.\n        // Should fail due to lack of a free validator\n        vm.expectRevert(\"Validator stack is empty\");\n        minter.depositEther();\n\n        // Pause submits\n        minter.togglePauseSubmits();\n\n        // Try submitting while paused (should fail)\n        vm.expectRevert(\"Submit is paused\");\n        minter.submit{ value: 1 ether }();\n\n        // Unpause submits\n        minter.togglePauseSubmits();\n\n        // Pause validator ETH deposits\n        minter.togglePauseDepositEther();\n\n        // Try submitting while paused (should fail)\n        vm.expectRevert(\"Depositing ETH is paused\");\n        minter.depositEther();\n\n        // Unpause validator ETH deposits\n        minter.togglePauseDepositEther();\n\n        // Add another validator\n        minter.addValidator(OperatorRegistry.Validator(pubKeys[1], sigs[1], ddRoots[1]));\n\n        // Should finally work again\n        minter.depositEther();\n\n        vm.stopPrank();\n    }\n\n    function testWithheldEth() public {\n        vm.startPrank(FRAX_COMPTROLLER);\n        \n        // Add a validator\n        minter.addValidator(OperatorRegistry.Validator(pubKeys[0], sigs[0], ddRoots[0]));\n\n        // Give the comptroller 320 ETH\n        vm.deal(FRAX_COMPTROLLER, 320 ether);\n\n        // Set the withhold ratio to 50% (5e5)\n        minter.setWithholdRatio(500000);\n\n        // Deposit 32 ETH for frxETH\n        vm.expectEmit(true, true, false, true);\n        emit TokenMinterMinted(address(minter), FRAX_COMPTROLLER, 32 ether);\n        vm.expectEmit(true, true, false, true);\n        emit ETHSubmitted(FRAX_COMPTROLLER, FRAX_COMPTROLLER, 32 ether, 16 ether);\n        minter.submit{ value: 32 ether }();\n\n        // Check that 16 ether was withheld\n        assertEq(minter.currentWithheldETH(), 16 ether);\n\n        // Try having the validator deposit.\n        // Should fail due to lack of ETH because half of it was withheld\n        vm.expectRevert(\"Not enough ETH in contract\");\n        minter.depositEther();\n\n        // Deposit another 32 ETH for frxETH. \n        // 16 ETH will be withheld and the other 16 ETH will be available for the validator\n        vm.expectEmit(true, true, false, true);\n        emit TokenMinterMinted(address(minter), FRAX_COMPTROLLER, 32 ether);\n        vm.expectEmit(true, true, false, true);\n        emit ETHSubmitted(FRAX_COMPTROLLER, FRAX_COMPTROLLER, 32 ether, 16 ether);\n        minter.submit{ value: 32 ether }();\n        \n        // Move the 32 ETH to the validator. Should work now because 16 + 16 = 32\n        minter.depositEther();\n\n        // Set the withhold ratio back to 0\n        minter.setWithholdRatio(0);\n\n        // Deposit 32 ETH for frxETH\n        vm.expectEmit(true, true, false, true);\n        emit TokenMinterMinted(address(minter), FRAX_COMPTROLLER, 32 ether);\n        vm.expectEmit(true, true, false, true);\n        emit ETHSubmitted(FRAX_COMPTROLLER, FRAX_COMPTROLLER, 32 ether, 0);\n        minter.submit{ value: 32 ether }();\n\n        // Add another validator\n        minter.addValidator(OperatorRegistry.Validator(pubKeys[1], sigs[1], ddRoots[1]));\n\n        // Move the 32 ETH to the validator. Should work immediately\n        minter.depositEther();\n\n        vm.stopPrank();\n    }\n\n    function testRecoverEther() public {\n        vm.startPrank(FRAX_COMPTROLLER);\n\n        // Note the starting ETH balance of the comptroller\n        uint256 starting_eth = FRAX_COMPTROLLER.balance;\n\n        // Give minter 10 eth\n        vm.deal(address(minter), 10 ether);\n\n        // Recover 5 ETH \n        vm.expectEmit(false, false, false, true);\n        emit EmergencyEtherRecovered(5 ether);\n        minter.recoverEther(5 ether);\n\n        // Make sure the FRAX_COMPTROLLER got 5 ether back\n        assertEq(FRAX_COMPTROLLER.balance, starting_eth + (5 ether));\n\n        vm.stopPrank();\n    }\n\n    function testRecoverERC20() public {\n        vm.startPrank(FRAX_COMPTROLLER);\n\n        // Note the starting ETH balance of the comptroller\n        uint256 starting_frxETH = frxETHToken.balanceOf(FRAX_COMPTROLLER);\n\n        // Deposit 5 ETH for frxETH first\n        vm.expectEmit(true, true, true, true);\n        emit TokenMinterMinted(address(minter), FRAX_COMPTROLLER, 5 ether);\n        minter.submit{ value: 5 ether }();\n\n        // Throw the newly minted frxETH into the minter \"by accident\"\n        frxETHToken.transfer(address(minter), 5 ether);\n\n        // Get the intermediate frxETH balance of the comptroller\n        uint256 intermediate_frxETH = frxETHToken.balanceOf(FRAX_COMPTROLLER);\n\n        // Make sure you are back to where you started from, frxETH balance wise\n        assertEq(starting_frxETH, intermediate_frxETH);\n\n        // Recover 5 frxETH \n        vm.expectEmit(false, false, false, true);\n        emit EmergencyERC20Recovered(address(frxETHToken), 5 ether);\n        minter.recoverERC20(address(frxETHToken), 5 ether);\n\n        // Get the ending frxETH balance of the comptroller\n        uint256 ending_frxETH = frxETHToken.balanceOf(FRAX_COMPTROLLER);\n\n        // Make sure the FRAX_COMPTROLLER got 5 frxETH back\n        assertEq(ending_frxETH, starting_frxETH + (5 ether));\n\n        vm.stopPrank();\n    }\n\n    event EmergencyEtherRecovered(uint256 amount);\n    event EmergencyERC20Recovered(address tokenAddress, uint256 tokenAmount);\n    event ETHSubmitted(address indexed sender, address indexed recipient, uint256 sent_amount, uint256 withheld_amt);\n    event TokenMinterMinted(address indexed sender, address indexed to, uint256 amount);\n    event ValidatorAdded(bytes pubKey, bytes withdrawalCredential);\n    event ValidatorRemoved(bytes pubKey, uint256 remove_idx, bool dont_care_about_ordering);\n    event ValidatorsSwapped(bytes from_pubKey, bytes to_pubKey, uint256 from_idx, uint256 to_idx);\n    event ValidatorsPopped(uint256 times);\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ========================= OperatorRegistry =========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Justin Moore: https://github.com/0xJM\n\n// Reviewer(s) / Contributor(s)\n// Travis Moore: https://github.com/FortisFortuna\n// Dennis: https://github.com/denett\n\nimport \"./Utils/Owned.sol\";\n\n/// @title Keeps track of validators used for ETH 2.0 staking\n/// @notice A permissioned owner can add and removed them at will\ncontract OperatorRegistry is Owned {\n\n    struct Validator {\n        bytes pubKey;\n        bytes signature;\n        bytes32 depositDataRoot;\n    }\n\n    Validator[] validators; // Array of unused / undeposited validators that can be used at a future time\n    bytes curr_withdrawal_pubkey; // Pubkey for ETH 2.0 withdrawal creds. If you change it, you must empty the validators array\n    address public timelock_address;\n\n    constructor(address _owner, address _timelock_address, bytes memory _withdrawal_pubkey) Owned(_owner) {\n        timelock_address = _timelock_address;\n        curr_withdrawal_pubkey = _withdrawal_pubkey;\n    }\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    /// @notice Add a new validator\n    /** @dev You should verify offchain that the validator is indeed valid before adding it\n        Reason we don't do that here is for gas */\n    function addValidator(Validator calldata validator) public onlyByOwnGov {\n        validators.push(validator);\n        emit ValidatorAdded(validator.pubKey, curr_withdrawal_pubkey);\n    }\n\n    /// @notice Add multiple new validators in one function call\n    /** @dev You should verify offchain that the validators are indeed valid before adding them\n        Reason we don't do that here is for gas */\n    function addValidators(Validator[] calldata validatorArray) external onlyByOwnGov {\n        uint arrayLength = validatorArray.length;\n        for (uint256 i = 0; i < arrayLength; ++i) {\n            addValidator(validatorArray[i]);\n        }\n    }\n\n    /// @notice Swap the location of one validator with another\n    function swapValidator(uint256 from_idx, uint256 to_idx) public onlyByOwnGov {\n        // Get the original values\n        Validator memory fromVal = validators[from_idx];\n        Validator memory toVal = validators[to_idx];\n\n        // Set the swapped values\n        validators[to_idx] = fromVal;\n        validators[from_idx] = toVal;\n\n        emit ValidatorsSwapped(fromVal.pubKey, toVal.pubKey, from_idx, to_idx);\n    }\n\n    /// @notice Remove validators from the end of the validators array, in case they were added in error\n    function popValidators(uint256 times) public onlyByOwnGov {\n        // Loop through and remove validator entries at the end\n        for (uint256 i = 0; i < times; ++i) {\n            validators.pop();\n        }\n\n        emit ValidatorsPopped(times);\n    }\n\n    /** @notice Remove a validator from the array. If dont_care_about_ordering is true,  \n        a swap and pop will occur instead of a more gassy loop */ \n    function removeValidator(uint256 remove_idx, bool dont_care_about_ordering) public onlyByOwnGov {\n        // Get the pubkey for the validator to remove (for informational purposes)\n        bytes memory removed_pubkey = validators[remove_idx].pubKey;\n\n        // Less gassy to swap and pop\n        if (dont_care_about_ordering){\n            // Swap the (validator to remove) with the (last validator in the array)\n            swapValidator(remove_idx, validators.length - 1);\n\n            // Pop off the validator to remove, which is now at the end of the array\n            validators.pop();\n        }\n        // More gassy, loop\n        else {\n            // Save the original validators\n            Validator[] memory original_validators = validators;\n\n            // Clear the original validators list\n            delete validators;\n\n            // Fill the new validators array with all except the value to remove\n            for (uint256 i = 0; i < original_validators.length; ++i) {\n                if (i != remove_idx) {\n                    validators.push(original_validators[i]);\n                }\n            }\n        }\n\n        emit ValidatorRemoved(removed_pubkey, remove_idx, dont_care_about_ordering);\n    }\n\n    // Internal\n    /// @dev Remove the last validator from the validators array and return its information\n    function getNextValidator()\n        internal\n        returns (\n            bytes memory pubKey,\n            bytes memory withdrawalCredentials,\n            bytes memory signature,\n            bytes32 depositDataRoot\n        )\n    {\n        // Make sure there are free validators available\n        uint numVals = numValidators();\n        require(numVals != 0, \"Validator stack is empty\");\n\n        // Pop the last validator off the array\n        Validator memory popped = validators[numVals - 1];\n        validators.pop();\n\n        // Return the validator's information\n        pubKey = popped.pubKey;\n        withdrawalCredentials = curr_withdrawal_pubkey;\n        signature = popped.signature;\n        depositDataRoot = popped.depositDataRoot;\n    }\n\n    /// @notice Return the information of the i'th validator in the registry\n    function getValidator(uint i) \n        view\n        external\n        returns (\n            bytes memory pubKey,\n            bytes memory withdrawalCredentials,\n            bytes memory signature,\n            bytes32 depositDataRoot\n        )\n    {\n        Validator memory v = validators[i];\n\n        // Return the validator's information\n        pubKey = v.pubKey;\n        withdrawalCredentials = curr_withdrawal_pubkey;\n        signature = v.signature;\n        depositDataRoot = v.depositDataRoot;\n    }\n\n    /// @notice Returns a Validator struct of the given inputs to make formatting addValidator inputs easier\n    function getValidatorStruct(\n        bytes memory pubKey, \n        bytes memory signature, \n        bytes32 depositDataRoot\n    ) external pure returns (Validator memory) {\n        return Validator(pubKey, signature, depositDataRoot);\n    }\n\n    /// @notice Requires empty validator stack as changing withdrawal creds invalidates signature\n    /// @dev May need to call clearValidatorArray() first\n    function setWithdrawalCredential(bytes memory _new_withdrawal_pubkey) external onlyByOwnGov {\n        require(numValidators() == 0, \"Clear validator array first\");\n        curr_withdrawal_pubkey = _new_withdrawal_pubkey;\n\n        emit WithdrawalCredentialSet(_new_withdrawal_pubkey);\n    }\n\n    /// @notice Empties the validator array\n    /// @dev Need to do this before setWithdrawalCredential()\n    function clearValidatorArray() external onlyByOwnGov {\n        delete validators;\n\n        emit ValidatorArrayCleared();\n    }\n\n    /// @notice Returns the number of validators\n    function numValidators() public view returns (uint256) {\n        return validators.length;\n    }\n\n    /// @notice Set the timelock contract\n    function setTimelock(address _timelock_address) external onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\");\n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    event TimelockChanged(address timelock_address);\n    event WithdrawalCredentialSet(bytes _withdrawalCredential);\n    event ValidatorAdded(bytes pubKey, bytes withdrawalCredential);\n    event ValidatorArrayCleared();\n    event ValidatorRemoved(bytes pubKey, uint256 remove_idx, bool dont_care_about_ordering);\n    event ValidatorsPopped(uint256 times);\n    event ValidatorsSwapped(bytes from_pubKey, bytes to_pubKey, uint256 from_idx, uint256 to_idx);\n    event KeysCleared();\n}\n\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"../Utils/Owned.sol\";\n\n/// @title Parent contract for frxETH.sol\n/** @notice Combines Openzeppelin's ERC20Permit and ERC20Burnable with Synthetix's Owned. \n    Also includes a list of authorized minters */\n/// @dev frxETH adheres to EIP-712/EIP-2612 and can use permits\ncontract ERC20PermitPermissionedMint is ERC20Permit, ERC20Burnable, Owned {\n    // Core\n    address public timelock_address;\n\n    // Minters\n    address[] public minters_array; // Allowed to mint\n    mapping(address => bool) public minters; // Mapping is also used for faster verification\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _creator_address,\n        address _timelock_address,\n        string memory _name,\n        string memory _symbol\n    ) \n    ERC20(_name, _symbol)\n    ERC20Permit(_name) \n    Owned(_creator_address)\n    {\n      timelock_address = _timelock_address;\n    }\n\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyByOwnGov() {\n        require(msg.sender == timelock_address || msg.sender == owner, \"Not owner or timelock\");\n        _;\n    }\n\n    modifier onlyMinters() {\n       require(minters[msg.sender] == true, \"Only minters\");\n        _;\n    } \n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // Used by minters when user redeems\n    function minter_burn_from(address b_address, uint256 b_amount) public onlyMinters {\n        super.burnFrom(b_address, b_amount);\n        emit TokenMinterBurned(b_address, msg.sender, b_amount);\n    }\n\n    // This function is what other minters will call to mint new tokens \n    function minter_mint(address m_address, uint256 m_amount) public onlyMinters {\n        super._mint(m_address, m_amount);\n        emit TokenMinterMinted(msg.sender, m_address, m_amount);\n    }\n\n    // Adds whitelisted minters \n    function addMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n\n        require(minters[minter_address] == false, \"Address already exists\");\n        minters[minter_address] = true; \n        minters_array.push(minter_address);\n\n        emit MinterAdded(minter_address);\n    }\n\n    // Remove a minter \n    function removeMinter(address minter_address) public onlyByOwnGov {\n        require(minter_address != address(0), \"Zero address detected\");\n        require(minters[minter_address] == true, \"Address nonexistant\");\n        \n        // Delete from the mapping\n        delete minters[minter_address];\n\n        // 'Delete' from the array by setting the address to 0x0\n        for (uint i = 0; i < minters_array.length; i++){ \n            if (minters_array[i] == minter_address) {\n                minters_array[i] = address(0); // This will leave a null in the array and keep the indices the same\n                break;\n            }\n        }\n\n        emit MinterRemoved(minter_address);\n    }\n\n    function setTimelock(address _timelock_address) public onlyByOwnGov {\n        require(_timelock_address != address(0), \"Zero address detected\"); \n        timelock_address = _timelock_address;\n        emit TimelockChanged(_timelock_address);\n    }\n\n    /* ========== EVENTS ========== */\n    \n    event TokenMinterBurned(address indexed from, address indexed to, uint256 amount);\n    event TokenMinterMinted(address indexed from, address indexed to, uint256 amount);\n    event MinterAdded(address minter_address);\n    event MinterRemoved(address minter_address);\n    event TimelockChanged(address timelock_address);\n}\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ============================ frxETHMinter ==========================\n// ====================================================================\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author(s)\n// Jack Corddry: https://github.com/corddry\n// Justin Moore: https://github.com/0xJM\n\n// Reviewer(s) / Contributor(s)\n// Travis Moore: https://github.com/FortisFortuna\n// Dennis: https://github.com/denett\n// Jamie Turley: https://github.com/jyturley\n\nimport { frxETH } from \"./frxETH.sol\";\nimport { IsfrxETH } from \"./IsfrxETH.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport { IDepositContract } from \"./DepositContract.sol\";\nimport \"./OperatorRegistry.sol\";\n\n/// @title Authorized minter contract for frxETH\n/// @notice Accepts user-supplied ETH and converts it to frxETH (submit()), and also optionally inline stakes it for sfrxETH (submitAndDeposit())\n/** @dev Has permission to mint frxETH. \n    Once +32 ETH has accumulated, adds it to a validator, which then deposits it for ETH 2.0 staking (depositEther())\n    Withhold ratio refers to what percentage of ETH this contract keeps whenever a user makes a deposit. 0% is kept initially */\ncontract frxETHMinter is OperatorRegistry, ReentrancyGuard {    \n    uint256 public constant DEPOSIT_SIZE = 32 ether; // ETH 2.0 minimum deposit size\n    uint256 public constant RATIO_PRECISION = 1e6; // 1,000,000 \n\n    uint256 public withholdRatio; // What we keep and don't deposit whenever someone submit()'s ETH\n    uint256 public currentWithheldETH; // Needed for internal tracking\n    mapping(bytes => bool) public activeValidators; // Tracks validators (via their pubkeys) that already have 32 ETH in them\n\n    IDepositContract public immutable depositContract; // ETH 2.0 deposit contract\n    frxETH public immutable frxETHToken;\n    IsfrxETH public immutable sfrxETHToken;\n\n    bool public submitPaused;\n    bool public depositEtherPaused;\n\n    constructor(\n        address depositContractAddress, \n        address frxETHAddress, \n        address sfrxETHAddress, \n        address _owner, \n        address _timelock_address,\n        bytes memory _withdrawalCredential\n    ) OperatorRegistry(_owner, _timelock_address, _withdrawalCredential) {\n        depositContract = IDepositContract(depositContractAddress);\n        frxETHToken = frxETH(frxETHAddress);\n        sfrxETHToken = IsfrxETH(sfrxETHAddress);\n        withholdRatio = 0; // No ETH is withheld initially\n        currentWithheldETH = 0;\n    }\n\n    /// @notice Mint frxETH and deposit it to receive sfrxETH in one transaction\n    /** @dev Could try using EIP-712 / EIP-2612 here in the future if you replace this contract,\n        but you might run into msg.sender vs tx.origin issues with the ERC4626 */\n    function submitAndDeposit(address recipient) external payable returns (uint256 shares) {\n        // Give the frxETH to this contract after it is generated\n        _submit(address(this));\n\n        // Approve frxETH to sfrxETH for staking\n        frxETHToken.approve(address(sfrxETHToken), msg.value);\n\n        // Deposit the frxETH and give the generated sfrxETH to the final recipient\n        uint256 sfrxeth_recieved = sfrxETHToken.deposit(msg.value, recipient);\n        require(sfrxeth_recieved > 0, 'No sfrxETH was returned');\n\n        return sfrxeth_recieved;\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds. Internal portion\n    function _submit(address recipient) internal nonReentrant {\n        // Initial pause and value checks\n        require(!submitPaused, \"Submit is paused\");\n        require(msg.value != 0, \"Cannot submit 0\");\n\n        // Give the sender frxETH\n        frxETHToken.minter_mint(recipient, msg.value);\n\n        // Track the amount of ETH that we are keeping\n        uint256 withheld_amt = 0;\n        if (withholdRatio != 0) {\n            withheld_amt = (msg.value * withholdRatio) / RATIO_PRECISION;\n            currentWithheldETH += withheld_amt;\n        }\n\n        emit ETHSubmitted(msg.sender, recipient, msg.value, withheld_amt);\n    }\n\n    /// @notice Mint frxETH to the sender depending on the ETH value sent\n    function submit() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Mint frxETH to the recipient using sender's funds\n    function submitAndGive(address recipient) external payable {\n        _submit(recipient);\n    }\n\n    /// @notice Fallback to minting frxETH to the sender\n    receive() external payable {\n        _submit(msg.sender);\n    }\n\n    /// @notice Deposit batches of ETH to the ETH 2.0 deposit contract\n    /// @dev Usually a bot will call this periodically\n    function depositEther() external nonReentrant {\n        // Initial pause check\n        require(!depositEtherPaused, \"Depositing ETH is paused\");\n\n        // See how many deposits can be made. Truncation desired.\n        uint256 numDeposits = (address(this).balance - currentWithheldETH) / DEPOSIT_SIZE;\n        require(numDeposits > 0, \"Not enough ETH in contract\");\n\n        // Give each deposit chunk to an empty validator\n        for (uint256 i = 0; i < numDeposits; ++i) {\n            // Get validator information\n            (\n                bytes memory pubKey,\n                bytes memory withdrawalCredential,\n                bytes memory signature,\n                bytes32 depositDataRoot\n            ) = getNextValidator(); // Will revert if there are not enough free validators\n\n            // Make sure the validator hasn't been deposited into already, to prevent stranding an extra 32 eth\n            // until withdrawals are allowed\n            require(!activeValidators[pubKey], \"Validator already has 32 ETH\");\n\n            // Deposit the ether in the ETH 2.0 deposit contract\n            depositContract.deposit{value: DEPOSIT_SIZE}(\n                pubKey,\n                withdrawalCredential,\n                signature,\n                depositDataRoot\n            );\n\n            // Set the validator as used so it won't get an extra 32 ETH\n            activeValidators[pubKey] = true;\n\n            emit DepositSent(pubKey, withdrawalCredential);\n        }\n    }\n\n    /// @param newRatio of ETH that is sent to deposit contract vs withheld, 1e6 precision\n    /// @notice An input of 1e6 results in 100% of Eth deposited, 0% withheld\n    function setWithholdRatio(uint256 newRatio) external onlyByOwnGov {\n        require (newRatio <= RATIO_PRECISION, \"Ratio cannot surpass 100%\");\n        withholdRatio = newRatio;\n        emit WithholdRatioSet(newRatio);\n    }\n\n    /// @notice Give the withheld ETH to the \"to\" address\n    function moveWithheldETH(address payable to, uint256 amount) external onlyByOwnGov {\n        require(amount <= currentWithheldETH, \"Not enough withheld ETH in contract\");\n        currentWithheldETH -= amount;\n\n        (bool success,) = payable(to).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit WithheldETHMoved(to, amount);\n    }\n\n    /// @notice Toggle allowing submites\n    function togglePauseSubmits() external onlyByOwnGov {\n        submitPaused = !submitPaused;\n\n        emit SubmitPaused(submitPaused);\n    }\n\n    /// @notice Toggle allowing depositing ETH to validators\n    function togglePauseDepositEther() external onlyByOwnGov {\n        depositEtherPaused = !depositEtherPaused;\n\n        emit DepositEtherPaused(depositEtherPaused);\n    }\n\n    /// @notice For emergencies if something gets stuck\n    function recoverEther(uint256 amount) external onlyByOwnGov {\n        (bool success,) = address(owner).call{ value: amount }(\"\");\n        require(success, \"Invalid transfer\");\n\n        emit EmergencyEtherRecovered(amount);\n    }\n\n    /// @notice For emergencies if someone accidentally sent some ERC20 tokens here\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\n        require(IERC20(tokenAddress).transfer(owner, tokenAmount), \"recoverERC20: Transfer failed\");\n\n        emit EmergencyERC20Recovered(tokenAddress, tokenAmount);\n    }\n\n    event EmergencyEtherRecovered(uint256 amount);\n    event EmergencyERC20Recovered(address tokenAddress, uint256 tokenAmount);\n    event ETHSubmitted(address indexed sender, address indexed recipient, uint256 sent_amount, uint256 withheld_amt);\n    event DepositEtherPaused(bool new_status);\n    event DepositSent(bytes indexed pubKey, bytes withdrawalCredential);\n    event SubmitPaused(bool new_status);\n    event WithheldETHMoved(address indexed to, uint256 amount);\n    event WithholdRatioSet(uint256 newRatio);\n}\n\n\n",
        "CodeNames": [
            "frxETHMinter.t.sol",
            "OperatorRegistry.sol",
            "ERC20PermitPermissionedMint.sol",
            "frxETHMinter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "admin privileges in frxETHMinter.sol, ERC20PermitPermissionedMint.sol, and OperatorRegistry.sol",
                "Type": "Centralization risk",
                "Description": "Admin can add or remove validator from OperatorRegistry.sol, set minter address or remove minter address in frxETH.sol, minter set by admin can mint or burn any amount of frxETH token, set ETE deduction ratio, withdraw any amount of ETH or ERC20 token in frcETHMinter.sol. Without significant redesign it is not possible to avoid the admin being able to rug pull the protocol.",
                "Repair": "Set all admin functions behind either a timelocked DAO or at least a timelocked multisig contract"
            }
        ]
    }
]