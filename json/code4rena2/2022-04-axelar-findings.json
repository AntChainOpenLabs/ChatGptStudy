[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';\n\nimport { BurnableMintableCappedERC20 } from './BurnableMintableCappedERC20.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\nimport { TokenDeployer } from './TokenDeployer.sol';\n\nabstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n    error NotSelf();\n    error InvalidCodeHash();\n    error SetupFailed();\n    error InvalidAmount();\n    error TokenDoesNotExist(string symbol);\n    error TokenAlreadyExists(string symbol);\n    error TokenDeployFailed(string symbol);\n    error TokenContractDoesNotExist(address token);\n    error BurnFailed(string symbol);\n    error MintFailed(string symbol);\n    error TokenIsFrozen(string symbol);\n\n    enum Role {\n        Admin,\n        Owner,\n        Operator\n    }\n\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION =\n        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    // AUDIT: constants should be literal and their derivation should be in comments\n    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');\n\n    uint8 internal constant OLD_KEY_RETENTION = 16;\n\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address tokenDeployerImplementation) {\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string memory destinationChain,\n        string memory destinationAddress,\n        string memory symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string memory destinationChain,\n        string memory destinationContractAddress,\n        bytes memory payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string memory destinationChain,\n        string memory destinationContractAddress,\n        bytes memory payload,\n        string memory symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(\n            msg.sender,\n            destinationChain,\n            destinationContractAddress,\n            keccak256(payload),\n            payload,\n            symbol,\n            amount\n        );\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return\n            getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            msg.sender,\n            payloadHash,\n            symbol,\n            amount\n        );\n        valid = getBool(key);\n        if (valid) {\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function allTokensFrozen() public view override returns (bool) {\n        return getBool(KEY_ALL_TOKENS_FROZEN);\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    function tokenFrozen(string memory symbol) public view override returns (bool) {\n        return getBool(_getFreezeTokenKey(symbol));\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    /// @dev Returns the current `adminEpoch`.\n    function adminEpoch() external view override returns (uint256) {\n        return _adminEpoch();\n    }\n\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getAdminThreshold(epoch);\n    }\n\n    /// @dev Returns the array of admins within a given `adminEpoch`.\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\n        uint256 adminCount = _getAdminCount(epoch);\n        results = new address[](adminCount);\n\n        for (uint256 i; i < adminCount; i++) {\n            results[i] = _getAdmin(epoch, i);\n        }\n    }\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function freezeToken(string memory symbol) external override onlyAdmin {\n        _setBool(_getFreezeTokenKey(symbol), true);\n\n        emit TokenFrozen(symbol);\n    }\n\n    function unfreezeToken(string memory symbol) external override onlyAdmin {\n        _setBool(_getFreezeTokenKey(symbol), false);\n\n        emit TokenUnfrozen(symbol);\n    }\n\n    function freezeAllTokens() external override onlyAdmin {\n        _setBool(KEY_ALL_TOKENS_FROZEN, true);\n\n        emit AllTokensFrozen();\n    }\n\n    function unfreezeAllTokens() external override onlyAdmin {\n        _setBool(KEY_ALL_TOKENS_FROZEN, false);\n\n        emit AllTokensUnfrozen();\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyAdmin {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length > 0) {\n            (bool success, ) = newImplementation.delegatecall(\n                abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)\n            );\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* Internal Functions *|\n    \\**********************/\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n        bool burnSuccess;\n\n        if (tokenType == TokenType.External) {\n            _checkTokenStatus(symbol);\n\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        if (tokenType == TokenType.InternalBurnableFrom) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20BurnFrom.burnFrom.selector, sender, amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        burnSuccess = _callERC20Token(\n            tokenAddress,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                sender,\n                BurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n                amount\n            )\n        );\n\n        if (!burnSuccess) revert BurnFailed(symbol);\n\n        BurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n    }\n\n    function _deployToken(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 cap,\n        address tokenAddress\n    ) internal {\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(TokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified addressed.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            _checkTokenStatus(symbol);\n\n            bool success = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, account, amount)\n            );\n\n            if (!success) revert MintFailed(symbol);\n        } else {\n            BurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnToken(string memory symbol, bytes32 salt) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            _checkTokenStatus(symbol);\n\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(\n                    IERC20.transfer.selector,\n                    address(this),\n                    IERC20(tokenAddress).balanceOf(address(depositHandler))\n                )\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool))))\n                revert BurnFailed(symbol);\n\n            depositHandler.destroy(address(this));\n        } else {\n            BurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function _approveContractCall(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    ) internal {\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function _approveContractCallWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    ) internal {\n        _setContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount\n        );\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash\n                )\n            );\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    function _checkTokenStatus(string memory symbol) internal view {\n        if (getBool(_getFreezeTokenKey(symbol)) || getBool(KEY_ALL_TOKENS_FROZEN)) revert TokenIsFrozen(symbol);\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash),\n            true\n        );\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(\n                commandId,\n                sourceChain,\n                sourceAddress,\n                contractAddress,\n                payloadHash,\n                symbol,\n                amount\n            ),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n}\n\n\n",
        "CodeNames": [
            "AxelarGateway.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "callContractWithToken() function in AxelarGateway.sol",
                "Type": "Loss of Funds",
                "Description": "Cross-chain smart contract calls can revert but source chain tokens remain burnt and are not refunded, causing users of the Axelar Network to lose funds.",
                "Repair": "Re-mint and refund tokens in case of contract call failure on the destination chain"
            },
            {
                "Location": "AxelarGateway.sol#L384-L389",
                "Type": "User's funds can get lost",
                "Description": "When transferring tokens to other chain, the tokens in the source chain are burned if they are external they will be transferred to the AxelarGateway, otherwise they will be burned. In the target chain the same amount of tokens will be minted for the user if it is external it will be transferred to him from the AxelarGateway, otherwise it will be minted to him. But there is a problem if the AxelarGateway doesn't have the needed amount of token for some reason, the _callERC20Token with the transfer function selector will fail and return false, which will make the _mintToken function revert. Because it reverted, the user won't get his funds on the destination chain, although he payed the needed amount in the source chain.",
                "Repair": "Check if the AxelarGateway has the needed amount of token before transferring, and call the callContractWithToken function with the source chain as the destination chain in order to return the user his funds if the transfer fails"
            },
            {
                "Location": "AxelarGateway.sol#L284-L334",
                "Type": "Unsupported fee-on-transfer tokens",
                "Description": "When tokenAddress is fee-on-transfer tokens, in the _burnTokenFrom function, the actual amount of tokens received by the contract will be less than the amount.",
                "Repair": "Get the received amount by calculating the difference of token balance (using balanceOf) before and after the transferFrom"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\nimport { IERC20 } from './interfaces/IERC20.sol';\nimport { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';\n\nimport { BurnableMintableCappedERC20 } from './BurnableMintableCappedERC20.sol';\nimport { DepositHandler } from './DepositHandler.sol';\nimport { AdminMultisigBase } from './AdminMultisigBase.sol';\nimport { TokenDeployer } from './TokenDeployer.sol';\n\nabstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {\n    error NotSelf();\n    error InvalidCodeHash();\n    error SetupFailed();\n    error InvalidAmount();\n    error TokenDoesNotExist(string symbol);\n    error TokenAlreadyExists(string symbol);\n    error TokenDeployFailed(string symbol);\n    error TokenContractDoesNotExist(address token);\n    error BurnFailed(string symbol);\n    error MintFailed(string symbol);\n    error TokenIsFrozen(string symbol);\n\n    enum Role {\n        Admin,\n        Owner,\n        Operator\n    }\n\n    enum TokenType {\n        InternalBurnable,\n        InternalBurnableFrom,\n        External\n    }\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION =\n        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    // AUDIT: slot names should be prefixed with some standard string\n    // AUDIT: constants should be literal and their derivation should be in comments\n    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');\n\n    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');\n    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');\n    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');\n    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');\n    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');\n\n    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');\n    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');\n    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');\n    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');\n    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');\n    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');\n\n    uint8 internal constant OLD_KEY_RETENTION = 16;\n\n    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;\n\n    constructor(address tokenDeployerImplementation) {\n        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) revert NotSelf();\n\n        _;\n    }\n\n    /******************\\\n    |* Public Methods *|\n    \\******************/\n\n    function sendToken(\n        string memory destinationChain,\n        string memory destinationAddress,\n        string memory symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);\n    }\n\n    function callContract(\n        string memory destinationChain,\n        string memory destinationContractAddress,\n        bytes memory payload\n    ) external {\n        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);\n    }\n\n    function callContractWithToken(\n        string memory destinationChain,\n        string memory destinationContractAddress,\n        bytes memory payload,\n        string memory symbol,\n        uint256 amount\n    ) external {\n        _burnTokenFrom(msg.sender, symbol, amount);\n        emit ContractCallWithToken(\n            msg.sender,\n            destinationChain,\n            destinationContractAddress,\n            keccak256(payload),\n            payload,\n            symbol,\n            amount\n        );\n    }\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view override returns (bool) {\n        return\n            getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));\n    }\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) external view override returns (bool) {\n        return\n            getBool(\n                _getIsContractCallApprovedWithMintKey(\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    function validateContractCall(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes32 payloadHash\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);\n        valid = getBool(key);\n        if (valid) _setBool(key, false);\n    }\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) external override returns (bool valid) {\n        bytes32 key = _getIsContractCallApprovedWithMintKey(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            msg.sender,\n            payloadHash,\n            symbol,\n            amount\n        );\n        valid = getBool(key);\n        if (valid) {\n            _setBool(key, false);\n            _mintToken(symbol, msg.sender, amount);\n        }\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function allTokensFrozen() public view override returns (bool) {\n        return getBool(KEY_ALL_TOKENS_FROZEN);\n    }\n\n    function implementation() public view override returns (address) {\n        return getAddress(KEY_IMPLEMENTATION);\n    }\n\n    function tokenAddresses(string memory symbol) public view override returns (address) {\n        return getAddress(_getTokenAddressKey(symbol));\n    }\n\n    function tokenFrozen(string memory symbol) public view override returns (bool) {\n        return getBool(_getFreezeTokenKey(symbol));\n    }\n\n    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {\n        return getBool(_getIsCommandExecutedKey(commandId));\n    }\n\n    /// @dev Returns the current `adminEpoch`.\n    function adminEpoch() external view override returns (uint256) {\n        return _adminEpoch();\n    }\n\n    /// @dev Returns the admin threshold for a given `adminEpoch`.\n    function adminThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getAdminThreshold(epoch);\n    }\n\n    /// @dev Returns the array of admins within a given `adminEpoch`.\n    function admins(uint256 epoch) external view override returns (address[] memory results) {\n        uint256 adminCount = _getAdminCount(epoch);\n        results = new address[](adminCount);\n\n        for (uint256 i; i < adminCount; i++) {\n            results[i] = _getAdmin(epoch, i);\n        }\n    }\n\n    /*******************\\\n    |* Admin Functions *|\n    \\*******************/\n\n    function freezeToken(string memory symbol) external override onlyAdmin {\n        _setBool(_getFreezeTokenKey(symbol), true);\n\n        emit TokenFrozen(symbol);\n    }\n\n    function unfreezeToken(string memory symbol) external override onlyAdmin {\n        _setBool(_getFreezeTokenKey(symbol), false);\n\n        emit TokenUnfrozen(symbol);\n    }\n\n    function freezeAllTokens() external override onlyAdmin {\n        _setBool(KEY_ALL_TOKENS_FROZEN, true);\n\n        emit AllTokensFrozen();\n    }\n\n    function unfreezeAllTokens() external override onlyAdmin {\n        _setBool(KEY_ALL_TOKENS_FROZEN, false);\n\n        emit AllTokensUnfrozen();\n    }\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external override onlyAdmin {\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)\n        //        if `upgrade` is entered within the context of _this_ implementation itself.\n        if (setupParams.length > 0) {\n            (bool success, ) = newImplementation.delegatecall(\n                abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)\n            );\n\n            if (!success) revert SetupFailed();\n        }\n\n        _setImplementation(newImplementation);\n    }\n\n    /**********************\\\n    |* Internal Functions *|\n    \\**********************/\n\n    function _burnTokenFrom(\n        address sender,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n        if (amount == 0) revert InvalidAmount();\n\n        TokenType tokenType = _getTokenType(symbol);\n        bool burnSuccess;\n\n        if (tokenType == TokenType.External) {\n            _checkTokenStatus(symbol);\n\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        if (tokenType == TokenType.InternalBurnableFrom) {\n            burnSuccess = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20BurnFrom.burnFrom.selector, sender, amount)\n            );\n\n            if (!burnSuccess) revert BurnFailed(symbol);\n\n            return;\n        }\n\n        burnSuccess = _callERC20Token(\n            tokenAddress,\n            abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                sender,\n                BurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),\n                amount\n            )\n        );\n\n        if (!burnSuccess) revert BurnFailed(symbol);\n\n        BurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));\n    }\n\n    function _deployToken(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 cap,\n        address tokenAddress\n    ) internal {\n        // Ensure that this symbol has not been taken.\n        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);\n\n        if (tokenAddress == address(0)) {\n            // If token address is no specified, it indicates a request to deploy one.\n            bytes32 salt = keccak256(abi.encodePacked(symbol));\n\n            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(\n                abi.encodeWithSelector(TokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)\n            );\n\n            if (!success) revert TokenDeployFailed(symbol);\n\n            tokenAddress = abi.decode(data, (address));\n\n            _setTokenType(symbol, TokenType.InternalBurnableFrom);\n        } else {\n            // If token address is specified, ensure that there is a contact at the specified addressed.\n            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);\n\n            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.\n            _setTokenType(symbol, TokenType.External);\n        }\n\n        _setTokenAddress(symbol, tokenAddress);\n\n        emit TokenDeployed(symbol, tokenAddress);\n    }\n\n    function _mintToken(\n        string memory symbol,\n        address account,\n        uint256 amount\n    ) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            _checkTokenStatus(symbol);\n\n            bool success = _callERC20Token(\n                tokenAddress,\n                abi.encodeWithSelector(IERC20.transfer.selector, account, amount)\n            );\n\n            if (!success) revert MintFailed(symbol);\n        } else {\n            BurnableMintableCappedERC20(tokenAddress).mint(account, amount);\n        }\n    }\n\n    function _burnToken(string memory symbol, bytes32 salt) internal {\n        address tokenAddress = tokenAddresses(symbol);\n\n        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);\n\n        if (_getTokenType(symbol) == TokenType.External) {\n            _checkTokenStatus(symbol);\n\n            DepositHandler depositHandler = new DepositHandler{ salt: salt }();\n\n            (bool success, bytes memory returnData) = depositHandler.execute(\n                tokenAddress,\n                abi.encodeWithSelector(\n                    IERC20.transfer.selector,\n                    address(this),\n                    IERC20(tokenAddress).balanceOf(address(depositHandler))\n                )\n            );\n\n            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool))))\n                revert BurnFailed(symbol);\n\n            depositHandler.destroy(address(this));\n        } else {\n            BurnableMintableCappedERC20(tokenAddress).burn(salt);\n        }\n    }\n\n    function _approveContractCall(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    ) internal {\n        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);\n        emit ContractCallApproved(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function _approveContractCallWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    ) internal {\n        _setContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount\n        );\n        emit ContractCallApprovedWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));\n    }\n\n    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));\n    }\n\n    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));\n    }\n\n    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));\n    }\n\n    function _getIsContractCallApprovedKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash\n                )\n            );\n    }\n\n    function _getIsContractCallApprovedWithMintKey(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,\n                    commandId,\n                    sourceChain,\n                    sourceAddress,\n                    contractAddress,\n                    payloadHash,\n                    symbol,\n                    amount\n                )\n            );\n    }\n\n    /********************\\\n    |* Internal Methods *|\n    \\********************/\n\n    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {\n        (bool success, bytes memory returnData) = tokenAddress.call(callData);\n        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n    }\n\n    /********************\\\n    |* Internal Getters *|\n    \\********************/\n\n    function _getTokenType(string memory symbol) internal view returns (TokenType) {\n        return TokenType(getUint(_getTokenTypeKey(symbol)));\n    }\n\n    function _checkTokenStatus(string memory symbol) internal view {\n        if (getBool(_getFreezeTokenKey(symbol)) || getBool(KEY_ALL_TOKENS_FROZEN)) revert TokenIsFrozen(symbol);\n    }\n\n    /********************\\\n    |* Internal Setters *|\n    \\********************/\n\n    function _setTokenType(string memory symbol, TokenType tokenType) internal {\n        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));\n    }\n\n    function _setTokenAddress(string memory symbol, address tokenAddress) internal {\n        _setAddress(_getTokenAddressKey(symbol), tokenAddress);\n    }\n\n    function _setCommandExecuted(bytes32 commandId, bool executed) internal {\n        _setBool(_getIsCommandExecutedKey(commandId), executed);\n    }\n\n    function _setContractCallApproved(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash),\n            true\n        );\n    }\n\n    function _setContractCallApprovedWithMint(\n        bytes32 commandId,\n        string memory sourceChain,\n        string memory sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string memory symbol,\n        uint256 amount\n    ) internal {\n        _setBool(\n            _getIsContractCallApprovedWithMintKey(\n                commandId,\n                sourceChain,\n                sourceAddress,\n                contractAddress,\n                payloadHash,\n                symbol,\n                amount\n            ),\n            true\n        );\n    }\n\n    function _setImplementation(address newImplementation) internal {\n        _setAddress(KEY_IMPLEMENTATION, newImplementation);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGateway } from './interfaces/IAxelarGateway.sol';\n\nimport { EternalStorage } from './EternalStorage.sol';\n\ncontract AxelarGatewayProxy is EternalStorage {\n    error SetupFailed();\n\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\n    bytes32 internal constant KEY_IMPLEMENTATION =\n        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\n\n    constructor(address gatewayImplementation, bytes memory params) {\n        _setAddress(KEY_IMPLEMENTATION, gatewayImplementation);\n\n        (bool success, ) = gatewayImplementation.delegatecall(\n            abi.encodeWithSelector(IAxelarGateway.setup.selector, params)\n        );\n\n        if (!success) revert SetupFailed();\n    }\n\n    function setup(bytes calldata params) external {}\n\n    fallback() external payable {\n        address implementation = getAddress(KEY_IMPLEMENTATION);\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {\n        revert('NO_ETHER');\n    }\n}\n\n\n",
        "CodeNames": [
            "AxelarGateway.sol",
            "AxelarGatewayProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AxelarGateway.sol#L545-L548, AxelarGatewayProxy.sol#L16-L24",
                "Type": "Low level call returns true if the address doesn't exist",
                "Description": "The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.",
                "Repair": "Check before any low-level call that the address actually exists, for example before the low level call in the callERC20 function you can check that the address is a contract by checking its code size"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGatewayMultisig } from './interfaces/IAxelarGatewayMultisig.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { AxelarGateway } from './AxelarGateway.sol';\n\ncontract AxelarGatewayMultisig is IAxelarGatewayMultisig, AxelarGateway {\n    error InvalidAddress();\n    error InvalidOwners();\n    error InvalidOwnerThreshold();\n    error DuplicateOwner(address owner);\n    error InvalidOperators();\n    error InvalidOperatorThreshold();\n    error DuplicateOperator(address operator);\n    error NotProxy();\n    error InvalidChainId();\n    error MalformedSigners();\n    error InvalidCommands();\n\n    // AUDIT: slot names should be prefixed with some standard string\n    // AUDIT: constants should be literal and their derivation should be in comments\n    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');\n\n    bytes32 internal constant PREFIX_OWNER = keccak256('owner');\n    bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count');\n    bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold');\n    bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner');\n\n    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');\n\n    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');\n    bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count');\n    bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold');\n    bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator');\n\n    constructor(address tokenDeployer) AxelarGateway(tokenDeployer) {}\n\n    function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {\n        for (uint256 i; i < accounts.length - 1; ++i) {\n            if (accounts[i] >= accounts[i + 1]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /************************\\\n    |* Owners Functionality *|\n    \\************************/\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getOwnerKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OWNER, epoch, index));\n    }\n\n    function _getOwnerCountKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OWNER_COUNT, epoch));\n    }\n\n    function _getOwnerThresholdKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OWNER_THRESHOLD, epoch));\n    }\n\n    function _getIsOwnerKey(uint256 epoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_OWNER, epoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _ownerEpoch() internal view returns (uint256) {\n        return getUint(KEY_OWNER_EPOCH);\n    }\n\n    function _getOwner(uint256 epoch, uint256 index) internal view returns (address) {\n        return getAddress(_getOwnerKey(epoch, index));\n    }\n\n    function _getOwnerCount(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOwnerCountKey(epoch));\n    }\n\n    function _getOwnerThreshold(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOwnerThresholdKey(epoch));\n    }\n\n    function _isOwner(uint256 epoch, address account) internal view returns (bool) {\n        return getBool(_getIsOwnerKey(epoch, account));\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are owners within the last `OLD_KEY_RETENTION + 1` owner epochs (excluding the current one).\n    function _areValidPreviousOwners(address[] memory accounts) internal view returns (bool) {\n        uint256 epoch = _ownerEpoch();\n        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);\n        uint256 lowerBoundOwnerEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);\n\n        --epoch;\n        while (epoch > lowerBoundOwnerEpoch) {\n            if (_areValidOwnersInEpoch(epoch--, accounts)) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are owners in the `ownerEpoch`.\n    function _areValidOwnersInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {\n        uint256 threshold = _getOwnerThreshold(epoch);\n        uint256 validSignerCount;\n\n        for (uint256 i; i < accounts.length; i++) {\n            if (_isOwner(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns the current `ownerEpoch`.\n    function ownerEpoch() external view override returns (uint256) {\n        return _ownerEpoch();\n    }\n\n    /// @dev Returns the threshold for a given `ownerEpoch`.\n    function ownerThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getOwnerThreshold(epoch);\n    }\n\n    /// @dev Returns the array of owners within a given `ownerEpoch`.\n    function owners(uint256 epoch) public view override returns (address[] memory results) {\n        uint256 ownerCount = _getOwnerCount(epoch);\n        results = new address[](ownerCount);\n\n        for (uint256 i; i < ownerCount; i++) {\n            results[i] = _getOwner(epoch, i);\n        }\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setOwnerEpoch(uint256 epoch) internal {\n        _setUint(KEY_OWNER_EPOCH, epoch);\n    }\n\n    function _setOwner(\n        uint256 epoch,\n        uint256 index,\n        address account\n    ) internal {\n        if (account == address(0)) revert InvalidAddress();\n\n        _setAddress(_getOwnerKey(epoch, index), account);\n    }\n\n    function _setOwnerCount(uint256 epoch, uint256 ownerCount) internal {\n        _setUint(_getOwnerCountKey(epoch), ownerCount);\n    }\n\n    function _setOwners(\n        uint256 epoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 accountLength = accounts.length;\n\n        if (accountLength < threshold) revert InvalidOwners();\n\n        if (threshold == uint256(0)) revert InvalidOwnerThreshold();\n\n        _setOwnerThreshold(epoch, threshold);\n        _setOwnerCount(epoch, accountLength);\n\n        for (uint256 i; i < accountLength; i++) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an owner for this ownerEpoch.\n            if (_isOwner(epoch, account)) revert DuplicateOwner(account);\n\n            // Set this account as the i-th owner in this ownerEpoch (needed to we can get all the owners for `owners`).\n            _setOwner(epoch, i, account);\n            _setIsOwner(epoch, account, true);\n        }\n    }\n\n    function _setOwnerThreshold(uint256 epoch, uint256 threshold) internal {\n        _setUint(_getOwnerThresholdKey(epoch), threshold);\n    }\n\n    function _setIsOwner(\n        uint256 epoch,\n        address account,\n        bool isOwner\n    ) internal {\n        _setBool(_getIsOwnerKey(epoch, account), isOwner);\n    }\n\n    /**************************\\\n    |* Operator Functionality *|\n    \\**************************/\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getOperatorKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR, epoch, index));\n    }\n\n    function _getOperatorCountKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR_COUNT, epoch));\n    }\n\n    function _getOperatorThresholdKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR_THRESHOLD, epoch));\n    }\n\n    function _getIsOperatorKey(uint256 epoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_OPERATOR, epoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _operatorEpoch() internal view returns (uint256) {\n        return getUint(KEY_OPERATOR_EPOCH);\n    }\n\n    function _getOperator(uint256 epoch, uint256 index) internal view returns (address) {\n        return getAddress(_getOperatorKey(epoch, index));\n    }\n\n    function _getOperatorCount(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOperatorCountKey(epoch));\n    }\n\n    function _getOperatorThreshold(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOperatorThresholdKey(epoch));\n    }\n\n    function _isOperator(uint256 epoch, address account) internal view returns (bool) {\n        return getBool(_getIsOperatorKey(epoch, account));\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the same `operatorEpoch`, within the last `OLD_KEY_RETENTION + 1` operator epochs.\n    function _areValidRecentOperators(address[] memory accounts) internal view returns (bool) {\n        uint256 epoch = _operatorEpoch();\n        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);\n        uint256 lowerBoundOperatorEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);\n\n        while (epoch > lowerBoundOperatorEpoch) {\n            if (_areValidOperatorsInEpoch(epoch--, accounts)) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the `operatorEpoch`.\n    function _areValidOperatorsInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {\n        uint256 threshold = _getOperatorThreshold(epoch);\n        uint256 validSignerCount;\n\n        for (uint256 i; i < accounts.length; i++) {\n            if (_isOperator(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns the current `operatorEpoch`.\n    function operatorEpoch() external view override returns (uint256) {\n        return _operatorEpoch();\n    }\n\n    /// @dev Returns the threshold for a given `operatorEpoch`.\n    function operatorThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getOperatorThreshold(epoch);\n    }\n\n    /// @dev Returns the array of operators within a given `operatorEpoch`.\n    function operators(uint256 epoch) public view override returns (address[] memory results) {\n        uint256 operatorCount = _getOperatorCount(epoch);\n        results = new address[](operatorCount);\n\n        for (uint256 i; i < operatorCount; i++) {\n            results[i] = _getOperator(epoch, i);\n        }\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setOperatorEpoch(uint256 epoch) internal {\n        _setUint(KEY_OPERATOR_EPOCH, epoch);\n    }\n\n    function _setOperator(\n        uint256 epoch,\n        uint256 index,\n        address account\n    ) internal {\n        _setAddress(_getOperatorKey(epoch, index), account);\n    }\n\n    function _setOperatorCount(uint256 epoch, uint256 operatorCount) internal {\n        _setUint(_getOperatorCountKey(epoch), operatorCount);\n    }\n\n    function _setOperators(\n        uint256 epoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 accountLength = accounts.length;\n\n        if (accountLength < threshold) revert InvalidOperators();\n\n        if (threshold == uint256(0)) revert InvalidOperatorThreshold();\n\n        _setOperatorThreshold(epoch, threshold);\n        _setOperatorCount(epoch, accountLength);\n\n        for (uint256 i; i < accountLength; i++) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an operator for this operatorEpoch.\n            if (_isOperator(epoch, account)) revert DuplicateOperator(account);\n\n            if (account == address(0)) revert InvalidAddress();\n\n            // Set this account as the i-th operator in this operatorEpoch (needed to we can get all the operators for `operators`).\n            _setOperator(epoch, i, account);\n            _setIsOperator(epoch, account, true);\n        }\n    }\n\n    function _setOperatorThreshold(uint256 epoch, uint256 threshold) internal {\n        _setUint(_getOperatorThresholdKey(epoch), threshold);\n    }\n\n    function _setIsOperator(\n        uint256 epoch,\n        address account,\n        bool isOperator\n    ) internal {\n        _setBool(_getIsOperatorKey(epoch, account), isOperator);\n    }\n\n    /**********************\\\n    |* Self Functionality *|\n    \\**********************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddr) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address)\n        );\n\n        _deployToken(name, symbol, decimals, cap, tokenAddr);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        _burnToken(symbol, salt);\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _approveContractCall(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _approveContractCallWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOwnership(bytes calldata params, bytes32) external onlySelf {\n        (address[] memory newOwners, uint256 newThreshold) = abi.decode(params, (address[], uint256));\n\n        uint256 epoch = _ownerEpoch();\n\n        emit OwnershipTransferred(owners(epoch), _getOwnerThreshold(epoch), newOwners, newThreshold);\n\n        _setOwnerEpoch(++epoch);\n        _setOwners(epoch, newOwners, newThreshold);\n    }\n\n    function transferOperatorship(bytes calldata params, bytes32) external onlySelf {\n        (address[] memory newOperators, uint256 newThreshold) = abi.decode(params, (address[], uint256));\n\n        uint256 epoch = _operatorEpoch();\n\n        emit OperatorshipTransferred(operators(epoch), _getOperatorThreshold(epoch), newOperators, newThreshold);\n\n        _setOperatorEpoch(++epoch);\n        _setOperators(epoch, newOperators, newThreshold);\n    }\n\n    /**************************\\\n    |* External Functionality *|\n    \\**************************/\n\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (\n            address[] memory adminAddresses,\n            uint256 newAdminThreshold,\n            address[] memory ownerAddresses,\n            uint256 newOwnerThreshold,\n            address[] memory operatorAddresses,\n            uint256 newOperatorThreshold\n        ) = abi.decode(params, (address[], uint256, address[], uint256, address[], uint256));\n\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\n        _setAdminEpoch(newAdminEpoch);\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\n\n        uint256 newOwnerEpoch = _ownerEpoch() + uint256(1);\n        _setOwnerEpoch(newOwnerEpoch);\n        _setOwners(newOwnerEpoch, ownerAddresses, newOwnerThreshold);\n\n        uint256 newOperatorEpoch = _operatorEpoch() + uint256(1);\n        _setOperatorEpoch(newOperatorEpoch);\n        _setOperators(newOperatorEpoch, operatorAddresses, newOperatorThreshold);\n\n        emit OwnershipTransferred(new address[](uint256(0)), uint256(0), ownerAddresses, newOwnerThreshold);\n        emit OperatorshipTransferred(new address[](uint256(0)), uint256(0), operatorAddresses, newOperatorThreshold);\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[]));\n\n        _execute(data, signatures);\n    }\n\n    function _execute(bytes memory data, bytes[] memory signatures) internal {\n        uint256 signatureCount = signatures.length;\n\n        address[] memory signers = new address[](signatureCount);\n\n        for (uint256 i; i < signatureCount; i++) {\n            signers[i] = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), signatures[i]);\n        }\n\n        (\n            uint256 chainId,\n            Role signersRole,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params\n        ) = abi.decode(data, (uint256, Role, bytes32[], string[], bytes[]));\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        if (!_isSortedAscAndContainsNoDuplicate(signers)) revert MalformedSigners();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        bool areValidCurrentOwners;\n        bool areValidRecentOwners;\n        bool areValidRecentOperators;\n\n        if (signersRole == Role.Owner) {\n            areValidCurrentOwners = _areValidOwnersInEpoch(_ownerEpoch(), signers);\n            areValidRecentOwners = areValidCurrentOwners || _areValidPreviousOwners(signers);\n        } else if (signersRole == Role.Operator) {\n            areValidRecentOperators = _areValidRecentOperators(signers);\n        }\n\n        for (uint256 i; i < commandsLength; i++) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                if (!areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {\n                if (!areValidCurrentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.transferOwnership.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!areValidCurrentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n            _setCommandExecuted(commandId, success);\n\n            if (success) {\n                emit Executed(commandId);\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "AxelarGatewayMultisig.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AxelarGatewayMultisig.sol#L484, AxelarGatewayMultisig.sol#L490, AxelarGatewayMultisig.sol#L529",
                "Type": "_execute can potentially reorder a batch of commands while executing",
                "Description": "Since this is important, we quote it again instead of referring to our other bug report on a different, yet related bug. The context within which a command is executed is extremely important. AxelarGatewayMultisig.execute() takes a signed batch of commands. Each command has a corresponding commandID. This is guaranteed to be unique from the Axelar network. execute intentionally allows retrying a commandID if the command failed to be processed; this is because commands are state dependent, and someone might submit command 2 before command 1 causing it to fail.",
                "Repair": "Make execute nonReentrant, add an ever increasing nonce to signatures to prevent replay"
            }
        ]
    }
]