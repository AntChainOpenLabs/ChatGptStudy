[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IReferralFeePool.sol\";\n\ncontract ReferralFeePoolV0 is IReferralFeePool {\n    IMochiEngine public immutable engine;\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    uint256 public rewards;\n\n    mapping(address => uint256) public reward;\n\n    constructor(address _engine, address _uniswap) {\n        engine = IMochiEngine(_engine);\n        uniswapRouter = IUniswapV2Router02(_uniswap);\n    }\n\n    function addReward(address _recipient) external override {\n        uint256 newReward = engine.usdm().balanceOf(address(this)) - rewards;\n        reward[_recipient] += newReward;\n        rewards += newReward;\n    }\n\n    function claimRewardAsMochi() external {\n        IUSDM usdm = engine.usdm();\n        address[] memory path = new address[](2);\n        path[0] = address(usdm);\n        path[1] = uniswapRouter.WETH();\n        path[2] = address(engine.mochi());\n        usdm.approve(address(uniswapRouter), reward[msg.sender]);\n        // we are going to ingore the slippages here\n        uniswapRouter.swapExactTokensForTokens(\n            reward[msg.sender],\n            1,\n            path,\n            address(this),\n            type(uint256).max\n        );\n        engine.mochi().transfer(\n            msg.sender,\n            engine.mochi().balanceOf(address(this))\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "ReferralFeePoolV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ReferralFeePoolV0.sol#L28-L48",
                "Type": "MEV searcher vulnerability",
                "Description": "The 'claimRewardAsMochi' function in 'ReferralFeePoolV0' ignores slippage, making it vulnerable to MEV searchers who can swap assets with no slippage control and cause users to be sandwiched.",
                "Repair": "Add 'minReceivedAmount' as a parameter to 'claimRewardAsMochi' function and have the front-end calculate the min amount with the current price"
            },
            {
                "Location": "claimRewardAsMochi() function in ReferralFeePoolV0.sol",
                "Type": "reward draining",
                "Description": "Function 'claimRewardAsMochi' in 'ReferralFeePoolV0.sol' did not reduce user reward balance, allowing referrer to claim the same reward repeatedly and thus draining the fee pool.",
                "Repair": "Add the following lines: rewards -= reward[msg.sender]; reward[msg.sender] = 0;"
            },
            {
                "Location": "ReferralFeePoolV0.sol#claimRewardAsMochi() function",
                "Type": "Array Out of Bounds Exception",
                "Description": "In ReferralFeePoolV0.sol#claimRewardAsMochi(), path is defined as an array of length 2 while it should be length 3. As a result, at L33, an out-of-bound exception will be thrown and revert the transaction.",
                "Repair": "Define path as an array of length 3 instead of 2"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    /// storage variables\n    uint256 public override deposits;\n    uint256 public override debts;\n    int256 public override claimable;\n\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\n    ///E.g. If the stability fees are 10% for a year\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\n\n    /// result\n    uint256 public liquidated;\n\n    mapping(uint256 => Detail) public override details;\n    mapping(uint256 => uint256) public lastDeposit;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n\n    modifier wait(uint256 _id) {\n        require(\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\n            \"!wait\"\n        );\n        accrueDebt(_id);\n        _;\n    }\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function initialize(address _asset) external override initializer {\n        asset = IERC20(_asset);\n        debtIndex = 1e18;\n        lastAccrued = block.timestamp;\n    }\n\n    function liveDebtIndex() public view override returns (uint256 index) {\n        return\n            engine.mochiProfile().calculateFeeIndex(\n                address(asset),\n                debtIndex,\n                lastAccrued\n            );\n    }\n\n    function status(uint256 _id) public view override returns (Status) {\n        return details[_id].status;\n    }\n\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        require(details[_id].status != Status.Invalid, \"invalid\");\n        uint256 newIndex = liveDebtIndex();\n        return (details[_id].debt * newIndex) / details[_id].debtIndex;\n    }\n\n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function increase(\n        uint256 _id,\n        uint256 _deposits,\n        uint256 _borrows,\n        address _referrer,\n        bytes memory _data\n    ) external {\n        if (_id == type(uint256).max) {\n            // mint if _id is -1\n            _id = mint(msg.sender, _referrer);\n        }\n        if (_deposits > 0) {\n            deposit(_id, _deposits);\n        }\n        if (_borrows > 0) {\n            borrow(_id, _borrows, _data);\n        }\n    }\n\n    function decrease(\n        uint256 _id,\n        uint256 _withdraws,\n        uint256 _repays,\n        bytes memory _data\n    ) external {\n        if (_repays > 0) {\n            repay(_id, _repays);\n        }\n        if (_withdraws > 0) {\n            withdraw(_id, _withdraws, _data);\n        }\n    }\n\n    function mint(address _recipient, address _referrer)\n        public\n        returns (uint256 id)\n    {\n        id = engine.nft().mint(address(asset), _recipient);\n        details[id].debtIndex = liveDebtIndex();\n        details[id].status = Status.Idle;\n        details[id].referrer = _referrer;\n    }\n\n    /// anyone can deposit collateral to given id\n    /// it will even allow depositing to liquidated vault so becareful when depositing\n    function deposit(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        // should it be able to deposit if invalid?\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        require(\n            details[_id].status == Status.Idle ||\n                details[_id].status == Status.Collaterized ||\n                details[_id].status == Status.Active,\n            \"!depositable\"\n        );\n        lastDeposit[_id] = block.timestamp;\n        deposits += _amount;\n        details[_id].collateral += _amount;\n        if (details[_id].status == Status.Idle) {\n            details[_id].status = Status.Collaterized;\n        }\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// should only be able to withdraw if status is not liquidatable\n    function withdraw(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override wait(_id) {\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        require(\n            !_liquidatable(\n                details[_id].collateral - _amount,\n                price,\n                details[_id].debt\n            ),\n            \"!healthy\"\n        );\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = (details[_id].collateral - _amount)\n            .multiply(cf)\n            .multiply(price);\n        require(details[_id].debt <= maxMinted, \">cf\");\n        deposits -= _amount;\n        details[_id].collateral -= _amount;\n        if (details[_id].collateral == 0) {\n            details[_id].status = Status.Idle;\n        }\n        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n\n    /// someone sends usdm to this address and repays the debt\n    /// will payback the leftover usdm\n    function repay(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        if (_amount > details[_id].debt) {\n            _amount = details[_id].debt;\n        }\n        require(_amount > 0, \"zero\");\n        if (debts < _amount) {\n            // safe gaurd to some underflows\n            debts = 0;\n        } else {\n            debts -= _amount;\n        }\n        details[_id].debt -= _amount;\n        if (details[_id].debt == 0) {\n            details[_id].status = Status.Collaterized;\n        }\n        engine.usdm().transferFrom(msg.sender, address(this), _amount);\n        engine.usdm().burn(_amount);\n    }\n\n    function liquidate(\n        uint256 _id,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external override updateDebt(_id) {\n        require(msg.sender == address(engine.liquidator()), \"!liquidator\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        float memory price = engine.cssr().getPrice(address(asset));\n        require(\n            _liquidatable(details[_id].collateral, price, currentDebt(_id)),\n            \"healthy\"\n        );\n\n        debts -= _usdm;\n\n        details[_id].collateral -= _collateral;\n        details[_id].debt -= _usdm;\n\n        asset.cheapTransfer(msg.sender, _collateral);\n    }\n\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\n    /// @notice should return false if _collateral * liquidationLimit < _debt\n    function _liquidatable(\n        uint256 _collateral,\n        float memory _price,\n        uint256 _debt\n    ) internal view returns (bool) {\n        float memory lf = engine.mochiProfile().liquidationFactor(\n            address(asset)\n        );\n        // when debt is lower than liquidation value, it can be liquidated\n        return _collateral.multiply(lf) < _debt.divide(_price);\n    }\n\n    function liquidatable(uint256 _id) external view returns (bool) {\n        float memory price = engine.cssr().getPrice(address(asset));\n        return _liquidatable(details[_id].collateral, price, currentDebt(_id));\n    }\n\n    function claim() external updateDebt(type(uint256).max) {\n        require(claimable > 0, \"!claimable\");\n        // reserving 25% to prevent potential risks\n        uint256 toClaim = (uint256(claimable) * 75) / 100;\n        mintFeeToPool(toClaim, address(0));\n    }\n\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\n        claimable -= int256(_amount);\n        if (address(0) != _referrer) {\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\n            engine.referralFeePool().addReward(_referrer);\n        } else {\n            engine.minter().mint(address(engine.treasury()), _amount);\n        }\n    }\n\n    // Flash Loan\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(asset), \"!supported\");\n        return asset.balanceOf(address(this));\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(asset), \"!supported\");\n        return (_amount * 1337) / 1000000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(asset), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        asset.cheapTransfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        asset.cheapTransferFrom(address(_receiver), address(this), _amount);\n        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MochiVault.mint",
                "Type": "CDP overwrite vulnerability",
                "Description": "Changing the 'engine.nft' address in 'MochiVault' can allow overwriting existing collateralized debt positions (CDPs), leading to incorrect tracking of debt and bad debt.",
                "Repair": "Disallow setting a new NFT address or ensure that the new NFT's IDs start at the old NFT's IDs"
            },
            {
                "Location": "MochiVault.sol L242-L249",
                "Type": "Incorrect debt tracking vulnerability",
                "Description": "The contract's debt in 'MochiVault' is inconsistent with the total sum of all users' debt, leading to bias that increases over time and can break the vault at the end.",
                "Repair": "Ensure that 'increasingDebt' is used consistently and accurately tracks the contract's debt"
            },
            {
                "Location": "MochiVault.sol",
                "Type": "inconsistent variable calculation",
                "Description": "The value of the global variable 'debts' in the contract 'MochiVault.sol' is calculated in an inconsistent way.",
                "Repair": "Replace 'debts += _amount;' with 'debts += totalDebt'"
            },
            {
                "Location": "deposit() function in MochiVault.sol",
                "Type": "wait period extension",
                "Description": "A malicious user can call this function with amount = 0, which would reset the amount of time the owner has to wait before they can withdraw their collateral from their position.",
                "Repair": "Add 'require(amount > 0, 'zero')' at the start of the function"
            },
            {
                "Location": "deposit() function in MochiVault.sol",
                "Type": "griefing attack",
                "Description": "Every time you deposit some assets in the vault, then 'lastDeposit[_id]' is set to 'block.timestamp'. The modifier 'wait()' checks this value and makes sure you cannot withdraw for 'delay()' blocks. Knowing this delay you can do a griefing attack.",
                "Repair": "Update deposit function to allow only NFT owner to deposit"
            },
            {
                "Location": "triggerLiquidation() function in MochiVault.sol",
                "Type": "Escape liquidation by creating a dust amount position",
                "Description": "A malicious user can create a dust amount position and trigger the liquidation by themselves, potentially escaping liquidation.",
                "Repair": "Make liquidated positions unable to be used for depositing and borrowing again"
            },
            {
                "Location": "MochiVault.borrow function",
                "Type": "Unexpected Behavior",
                "Description": "Borrow function in MochiVault will borrow to max cf when trying to borrow cf instead of revert with 'cf' as specified in the supplied test. The difference in behavior may cause user to borrow at dangerous collateral level, and receive less than the amount requested.",
                "Repair": "Revert with 'cf' as specified in the supplied test when trying to borrow cf instead of borrowing to max cf"
            },
            {
                "Location": "MochiVault.accrueDebt function",
                "Type": "Inaccurate Debt Accrual",
                "Description": "The total debt of a system depends on who performs the accruals which should ideally not be the case.",
                "Repair": "Don't use the discounts or track the weighted average discount across all users that is subtracted from the increased total debt each time"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./vault/MochiVaultFactory.sol\";\nimport \"./assets/usdm.sol\";\nimport \"./interfaces/IMochiEngine.sol\";\n\ncontract MochiEngine is IMochiEngine {\n    // immutable values\n    IMochiVaultFactory public immutable override vaultFactory;\n    // mutable values\n    IMochi public override mochi;\n    IVMochi public override vMochi;\n    address public override governance;\n    address public override treasury;\n    address public override operationWallet;\n    IUSDM public override usdm;\n    IMinter public override minter;\n    ICSSRRouter public override cssr;\n    IMochiProfile public override mochiProfile;\n    IDiscountProfile public override discountProfile;\n    ILiquidator public override liquidator;\n    IFeePool public override feePool;\n    IReferralFeePool public override referralFeePool;\n    IMochiNFT public override nft;\n\n    constructor(address _governance) {\n        governance = _governance;\n        vaultFactory = IMochiVaultFactory(new MochiVaultFactory(address(this)));\n        operationWallet = msg.sender;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == governance, \"!gov\");\n        _;\n    }\n\n    function changeMochi(address _mochi) external onlyGov {\n        mochi = IMochi(_mochi);\n    }\n\n    function changeVMochi(address _vmochi) external onlyGov {\n        vMochi = IVMochi(_vmochi);\n    }\n\n    function changeUSDM(address _usdm) external onlyGov {\n        usdm = IUSDM(_usdm);\n    }\n\n    function changeMinter(address _minter) external onlyGov {\n        minter = IMinter(_minter);\n    }\n\n    function changeGovernance(address _governance) external onlyGov {\n        governance = _governance;\n    }\n\n    function changeTreasury(address _treasury) external onlyGov {\n        treasury = _treasury;\n    }\n\n    function changeOperationWallet(address _operation) external onlyGov {\n        operationWallet = _operation;\n    }\n\n    function changeCSSR(address _cssr) external onlyGov {\n        cssr = ICSSRRouter(_cssr);\n    }\n\n    function changeProfile(address _profile) external onlyGov {\n        mochiProfile = IMochiProfile(_profile);\n    }\n\n    function changeDiscountProfile(address _profile) external onlyGov {\n        discountProfile = IDiscountProfile(_profile);\n    }\n\n    function changeLiquidator(address _liquidator) external onlyGov {\n        liquidator = ILiquidator(_liquidator);\n    }\n\n    function changeFeePool(address _feePool) external onlyGov {\n        feePool = IFeePool(_feePool);\n    }\n\n    function changeReferralFeePool(address _referralFeePool) external onlyGov {\n        referralFeePool = IReferralFeePool(_referralFeePool);\n    }\n\n    function changeNFT(address _nft) external onlyGov {\n        nft = IMochiNFT(_nft);\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiEngine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MochiEngine.sol#L91-L93",
                "Type": "NFT contract change vulnerability",
                "Description": "The 'MochiEngine' allows the operator to change the NFT contract, which can cause all vaults to point to a different NFT address, making it impossible for users to access their positions and breaking the entire protocol.",
                "Repair": "Remove the function that allows changing the NFT contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@mochifi/library/contracts/Beacon.sol\";\nimport \"@mochifi/library/contracts/BeaconProxyDeployer.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IMochiVaultFactory.sol\";\n\ncontract MochiVaultFactory is IMochiVaultFactory {\n    IMochiEngine public immutable engine;\n    Beacon public immutable beacon;\n    address public template;\n\n    constructor(address _engine) {\n        beacon = new Beacon(address(0));\n        engine = IMochiEngine(_engine);\n    }\n\n    function updateTemplate(address _newTemplate) external override {\n        require(msg.sender == engine.governance(), \"!gov\");\n        address(beacon).call(abi.encode(_newTemplate));\n        template = _newTemplate;\n    }\n\n    function deployVault(address _asset)\n        external\n        override\n        returns (IMochiVault)\n    {\n        bytes memory initCode = abi.encodeWithSelector(\n            bytes4(keccak256(\"initialize(address)\")),\n            _asset\n        );\n        return\n            IMochiVault(BeaconProxyDeployer.deploy(address(beacon), initCode));\n    }\n\n    function getVault(address _asset)\n        external\n        view\n        override\n        returns (IMochiVault)\n    {\n        bytes memory initCode = abi.encodeWithSelector(\n            bytes4(keccak256(\"initialize(address)\")),\n            _asset\n        );\n        return\n            IMochiVault(\n                BeaconProxyDeployer.calculateAddress(\n                    address(this),\n                    address(beacon),\n                    initCode\n                )\n            );\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiVaultFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MochiVaultFactory.sol#L26-L37",
                "Type": "Unrestricted function call vulnerability",
                "Description": "The 'vaultFactory' in 'MochiVaultFactory' has no permission control, allowing anyone to create a vault and potentially cause the protocol to recognize the random vault as a valid one.",
                "Repair": "Add a check that only allows the 'engine' to trigger the 'deployVault' function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMochi.sol\";\nimport \"@mochifi/vmochi/contracts/interfaces/IVMochi.sol\";\n\ncontract VestedRewardPool {\n    IMochi public immutable mochi;\n    IVMochi public immutable vMochi;\n\n    uint256 public mochiUnderManagement;\n\n    mapping(address => Vesting) public vesting;\n\n    struct Vesting {\n        uint256 vested;\n        uint256 ends;\n        uint256 claimable;\n    }\n\n    modifier checkClaimable(address recipient) {\n        if (vesting[recipient].ends < block.timestamp) {\n            vesting[recipient].claimable += vesting[recipient].vested;\n            vesting[recipient].vested = 0;\n            vesting[recipient].ends = 0;\n        }\n        _;\n    }\n\n    constructor(address _mochi, address _vmochi) {\n        mochi = IMochi(_mochi);\n        vMochi = IVMochi(_vmochi);\n    }\n\n    function vest(address _recipient) external checkClaimable(_recipient) {\n        uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;\n        uint256 weightedEnd = (vesting[_recipient].vested *\n            vesting[_recipient].ends +\n            amount *\n            (block.timestamp + 90 days)) /\n            (vesting[_recipient].vested + amount);\n        vesting[_recipient].vested += amount;\n        vesting[_recipient].ends = weightedEnd;\n        mochiUnderManagement += amount;\n    }\n\n    function claim() external checkClaimable(msg.sender) {\n        mochi.transfer(msg.sender, vesting[msg.sender].claimable);\n        mochiUnderManagement -= vesting[msg.sender].claimable;\n        vesting[msg.sender].claimable = 0;\n    }\n\n    function lock(uint256 _amount) external checkClaimable(msg.sender) {\n        mochi.approve(address(vMochi), _amount);\n        (, uint256 end) = vMochi.locked(msg.sender);\n        if (end >= block.timestamp + 90 days) {\n            vMochi.depositFor(msg.sender, _amount);\n        } else {\n            revert(\"lock should be longer than 90 days\");\n        }\n        vesting[msg.sender].vested -= _amount;\n        mochiUnderManagement -= _amount;\n    }\n\n    function forceClaim(uint256 _amount) external checkClaimable(msg.sender) {\n        mochi.transfer(msg.sender, _amount / 2);\n        mochi.transfer(address(vMochi), _amount / 2);\n        vesting[msg.sender].vested -= _amount;\n        mochiUnderManagement -= _amount;\n    }\n}\n\n\n",
        "CodeNames": [
            "VestedRewardPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VestedRewardPool.sol#L36-L46, VestedRewardPool.sol#L54-L64",
                "Type": "Frontrunning vulnerability",
                "Description": "The 'vest()' and 'lock()' functions in 'VestedRewardPool' do not utilize 'safeTransferFrom()', making it possible for attackers to frontrun a call and steal a recipient's vested tokens.",
                "Repair": "Create a single externally facing function which calls 'safeTransferFrom()', 'vest()', and 'lock()' in a single transaction"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/ICurveVotingEscrow.sol\";\n\ncontract MochiTreasuryV0 {\n    IMochiEngine public immutable engine;\n\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    IERC20 public immutable crv;\n    ICurveVotingEscrow public immutable veCrv;\n    bool public lockCrv;\n    uint256 public operationShare;\n    uint256 public veCRVShare;\n\n    constructor(\n        address _engine,\n        address _uniswap,\n        address _crv,\n        address _veCrv\n    ) {\n        engine = IMochiEngine(_engine);\n        uniswapRouter = IUniswapV2Router02(_uniswap);\n        crv = IERC20(_crv);\n        veCrv = ICurveVotingEscrow(_veCrv);\n        lockCrv = false;\n    }\n\n    receive() external payable {}\n\n    function withdrawCRV() external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        crv.transfer(msg.sender, crv.balanceOf(address(this)));\n    }\n\n    function withdrawLock() external {\n        veCrv.withdraw();\n    }\n\n    function veCRVInitialize() external {\n        require(lockCrv, \"!lock\");\n        updateFee();\n        _buyCRV();\n        veCrv.create_lock(\n            crv.balanceOf(address(this)),\n            block.timestamp + 90 days\n        );\n    }\n\n    function toggleLocking() external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        lockCrv = !lockCrv;\n    }\n\n    function updateFee() public {\n        uint256 updatedFee = engine.usdm().balanceOf(address(this)) -\n            operationShare -\n            veCRVShare;\n        operationShare += updatedFee / 2;\n        veCRVShare += updatedFee / 2;\n    }\n\n    function claimOperationCost() external {\n        updateFee();\n        engine.usdm().transfer(engine.operationWallet(), operationShare);\n        operationShare = 0;\n    }\n\n    function veCRVlock() external {\n        require(lockCrv, \"!lock\");\n        updateFee();\n        _buyCRV();\n        _lockCRV();\n        veCRVShare = 0;\n    }\n\n    function _buyCRV() internal {\n        IUSDM usdm = engine.usdm();\n        address[] memory path = new address[](2);\n        path[0] = address(usdm);\n        path[1] = address(crv);\n        usdm.approve(address(uniswapRouter), veCRVShare);\n        uniswapRouter.swapExactTokensForTokens(\n            veCRVShare,\n            1,\n            path,\n            address(this),\n            type(uint256).max\n        );\n    }\n\n    function _lockCRV() internal {\n        crv.approve(address(veCrv), crv.balanceOf(address(this)));\n        veCrv.increase_amount(crv.balanceOf(address(this)));\n        veCrv.increase_unlock_time(block.timestamp + 90 days);\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiTreasuryV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MochiTreasuryV0.sol#L73-L94",
                "Type": "Sandwich attack vulnerability",
                "Description": "The 'veCRVlock' function in 'MochiTreasury' is permissionless, allowing attackers to launch a sandwich attack with flashloan to steal the funds in the treasury.",
                "Repair": "Add 'onlyOwner' modifier to the 'veCRVlock' function"
            },
            {
                "Location": "MochiTreasuryV0.sol",
                "Type": "unusable contract",
                "Description": "'MochiTreasuryV0.sol' interacts with Curve's voting escrow contract to lock tokens for 90 days, where it can be later withdrawn by the governance role. However, 'VotingEscrow.vy' does not allow contracts to call certain functions.",
                "Repair": "Update the contract to potentially use another escrow service that enables 'msg.sender' to be a contract or replace the escrow functionality with an internal contract which holds 'usdm' tokens instead"
            },
            {
                "Location": "MochiTreasuryV0.withdrawLock() function",
                "Type": "Unexpected Behavior",
                "Description": "withdrawLock() does not prevent users from calling this function when locking has been toggled. As a result, withdraws may be made unexpectedly.",
                "Repair": "Add require(lockCrv, '!lock') to withdrawLock() to ensure this function is not called unexpectedly"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/IFeePool.sol\";\nimport \"../interfaces/IUSDM.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract FeePoolV0 is IFeePool {\n    IMochiEngine public immutable engine;\n\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    address public crvVoterRewardPool;\n\n    uint256 public treasuryRatio;\n\n    uint256 public vMochiRatio;\n\n    uint256 public mochiShare;\n\n    uint256 public treasuryShare;\n\n    constructor(address _engine, address _uniswap) {\n        engine = IMochiEngine(_engine);\n        uniswapRouter = IUniswapV2Router02(_uniswap);\n        treasuryRatio = 20e16;\n        vMochiRatio = 80e16;\n    }\n\n    function updateReserve() external override {\n        uint256 newReserve = engine.usdm().balanceOf(address(this)) -\n            mochiShare -\n            treasuryShare;\n        treasuryShare += (newReserve * treasuryRatio) / 1e18;\n        mochiShare = engine.usdm().balanceOf(address(this)) - treasuryShare;\n    }\n\n    function changecrvVoterRewardPool(address _pool) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        crvVoterRewardPool = _pool;\n    }\n\n    function changeTreasuryRatio(uint256 _ratio) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        treasuryRatio = _ratio;\n    }\n\n    function changevMochiRatio(uint256 _ratio) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        vMochiRatio = _ratio;\n    }\n\n    // this will open up arb oppertunity for Mochi\n    // so we will not reward the caller, caller can benefit from flashbot\n    // should decide which market we should use UniV2?V3? BalancerV2?\n    function distributeMochi() external {\n        // buy Mochi with mochiShare\n        _buyMochi();\n        _shareMochi();\n    }\n\n    function _buyMochi() internal {\n        IUSDM usdm = engine.usdm();\n        address[] memory path = new address[](2);\n        path[0] = address(usdm);\n        path[1] = address(engine.mochi());\n        usdm.approve(address(uniswapRouter), mochiShare);\n        uniswapRouter.swapExactTokensForTokens(\n            mochiShare,\n            1,\n            path,\n            address(this),\n            type(uint256).max\n        );\n    }\n\n    function _shareMochi() internal {\n        IMochi mochi = engine.mochi();\n        uint256 mochiBalance = mochi.balanceOf(address(this));\n        // send Mochi to vMochi Vault\n        mochi.transfer(\n            address(engine.vMochi()),\n            (mochiBalance * vMochiRatio) / 1e18\n        );\n        // send Mochi to veCRV Holders\n        mochi.transfer(\n            crvVoterRewardPool,\n            (mochiBalance * (1e18 - vMochiRatio)) / 1e18\n        );\n        // flush mochiShare\n        mochiShare = 0;\n        treasuryShare = 0;\n    }\n\n    function sendToTreasury() external {\n        engine.usdm().transfer(engine.treasury(), treasuryShare);\n        treasuryShare = 0;\n    }\n}\n\n\n",
        "CodeNames": [
            "FeePoolV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "distributeMochi() function in FeePoolV0.sol",
                "Type": "sandwich attack",
                "Description": "An attacker can launch a sandwich attack with flashloan to steal the funds.",
                "Repair": "Calculate a min return based on TWAP and check the slippage"
            },
            {
                "Location": "FeePoolV0.sol L94",
                "Type": "TreasuryShare overwritten",
                "Description": "When distributeMochi() is called to distribute mochi tokens to veCRV holders, both mochiShare and treasuryShare are flushed from the contract when there are still usdm tokens in the contract.",
                "Repair": "Remove the line where treasuryShare is flushed"
            },
            {
                "Location": "FeePoolV0.sol#distributeMochi() function",
                "Type": "Unexpected Behavior",
                "Description": "distributeMochi() will unexpectedly flush treasuryShare, causing the protocol fee cannot be properly accounted for and collected.",
                "Repair": "Change the code to flush mochiShare instead of treasuryShare"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./Create2BeaconMaker.sol\";\nlibrary BeaconProxyDeployer {\n    function deploy(address beacon, bytes memory initializationCalldata)\n        internal\n        returns (address result)\n    {\n        bytes memory createCode =\n            abi.encodePacked(\n                type(Create2BeaconMaker).creationCode,\n                abi.encode(address(beacon), initializationCalldata)\n            );\n        bytes32 salt = bytes32(0);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function calculateAddress(\n        address deployer,\n        address beacon,\n        bytes memory initializationCalldata\n    ) internal view returns (address addr) {\n        bytes memory createCode =\n            abi.encodePacked(\n                type(Create2BeaconMaker).creationCode,\n                abi.encode(address(beacon), initializationCalldata)\n            );\n\n        bytes32 salt = bytes32(0);\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(createCode);\n        addr = address( // derive the target deployment address.\n            uint160( // downcast to match the address type.\n                uint256( // cast to uint to truncate upper digits.\n                    keccak256( // compute CREATE2 hash using 4 inputs.\n                        abi.encodePacked( // pack all inputs to the hash together.\n                            bytes1(0xff), // pass in the control character.\n                            deployer, // pass in the address of this contract.\n                            salt, // pass in the salt from above.\n                            initCodeHash // pass in hash of contract creation code.\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "BeaconProxyDeployer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BeaconProxyDeployer.deploy() function in BeaconProxyDeployer.sol",
                "Type": "improper validation",
                "Description": "The function does not revert properly if there is a failed contract deployment or revert from the 'create2' opcode as it does not properly check the returned address for bytecode.",
                "Repair": "Update 'iszero(result)' to 'iszero(extcodesize(result))'"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@mochifi/library/contracts/Float.sol\";\nimport \"@mochifi/library/contracts/BeaconProxyDeployer.sol\";\nimport \"../interfaces/ILiquidator.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract DutchAuctionLiquidator is ILiquidator {\n    using Float for uint256;\n    IMochiEngine public immutable engine;\n\n    uint256 public constant DURATION = 2 days / 15;\n\n    struct Auction {\n        uint256 nftId;\n        address vault;\n        uint256 startedAt;\n        uint256 boughtAt;\n        uint256 collateral;\n        uint256 debt;\n    }\n\n    mapping(uint256 => Auction) public auctions;\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function auctionId(address asset, uint256 nftId)\n        public\n        pure\n        returns (uint256)\n    {\n        return uint256(keccak256(abi.encodePacked(asset, nftId)));\n    }\n\n    function price(uint256 _auctionId) external view returns (uint256) {\n        Auction memory auction = auctions[_auctionId];\n        return auction.debt + currentLiquidationFee(_auctionId);\n    }\n\n    function currentLiquidationFee(uint256 _auctionId)\n        public\n        view\n        returns (uint256 liquidationFee)\n    {\n        Auction memory auction = auctions[_auctionId];\n        liquidationFee = auction\n            .debt\n            .multiply(\n                engine.mochiProfile().liquidationFee(\n                    address(IMochiVault(auction.vault).asset())\n                )\n            )\n            .multiply(\n                float({\n                    numerator: auction.startedAt + DURATION > block.number\n                        ? auction.startedAt + DURATION - block.number\n                        : 0,\n                    denominator: DURATION\n                })\n            );\n    }\n\n    function triggerLiquidation(address _asset, uint256 _nftId)\n        external\n        override\n    {\n        IMochiVault vault = engine.vaultFactory().getVault(_asset);\n        Auction storage auction = auctions[auctionId(_asset, _nftId)];\n        require(auction.startedAt == 0 || auction.boughtAt != 0, \"on going\");\n        uint256 debt = vault.currentDebt(_nftId);\n        (, uint256 collateral, , , ) = vault.details(_nftId);\n\n        vault.liquidate(_nftId, collateral, debt);\n\n        auction.nftId = _nftId;\n        auction.vault = address(vault);\n        auction.startedAt = block.number;\n        auction.boughtAt = 0;\n        auction.collateral = collateral;\n        auction.debt = debt;\n\n        uint256 liquidationFee = debt.multiply(\n            engine.mochiProfile().liquidationFee(address(_asset))\n        );\n        emit Triggered(auctionId(_asset, _nftId), debt + liquidationFee);\n    }\n\n    function settleLiquidation(\n        uint256 _auctionId,\n        uint256 _collateral,\n        uint256 _repaid\n    ) internal {\n        Auction storage auction = auctions[_auctionId];\n        require(auction.boughtAt == 0, \"liquidated\");\n        IMochiVault vault = IMochiVault(auction.vault);\n        //repay the debt first\n        engine.usdm().transferFrom(msg.sender, address(this), _repaid);\n        engine.usdm().burn(_repaid);\n        IERC20 asset = vault.asset();\n        auction.boughtAt = block.number;\n        asset.transfer(msg.sender, _collateral);\n        //transfer liquidation fee to feePool\n        uint256 liquidationFee = currentLiquidationFee(_auctionId);\n        engine.usdm().transferFrom(\n            msg.sender,\n            address(engine.feePool()),\n            liquidationFee\n        );\n\n        emit Settled(_auctionId, _repaid + liquidationFee);\n    }\n\n    function buy(uint256 _auctionId) external {\n        Auction memory auction = auctions[_auctionId];\n        require(auction.startedAt != 0 && auction.boughtAt == 0, \"!on going\");\n        settleLiquidation(_auctionId, auction.collateral, auction.debt);\n    }\n}\n\n\n",
        "CodeNames": [
            "DutchAuctionLiquidator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "transfer() and transferFrom() calls in DutchAuctionLiquidator.sol",
                "Type": "unchecked transfer calls",
                "Description": "ERC20 'transfer' and 'transferFrom' calls normally return 'true' on a successful transfer.",
                "Repair": "Use 'cheapTransfer' and 'cheapTransferFrom' functions from the mochifi cheapERC20 library"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@mochifi/library/contracts/Float.sol\";\nimport \"../interfaces/IGovernanceOwned.sol\";\nimport \"../interfaces/ICSSRAdapter.sol\";\n\ncontract ChainlinkAdapterEth is ICSSRAdapter {\n    IGovernanceOwned public immutable owned;\n\n    mapping(address => AggregatorV3Interface) public feed;\n\n    modifier onlyGov() {\n        require(msg.sender == owned.governance(), \"!gov\");\n        _;\n    }\n\n    constructor(address _owned) {\n        owned = IGovernanceOwned(_owned);\n    }\n\n    function update(address _asset, bytes calldata _data)\n        external\n        override\n        returns (float memory)\n    {\n        return getPrice(_asset);\n    }\n\n    function setFeed(address[] calldata _assets, address[] calldata _feeds) external onlyGov {\n        for(uint256 i = 0; i<_assets.length; i++) {\n            feed[_assets[i]] = AggregatorV3Interface(_feeds[i]);\n        }\n    }\n\n    function support(address _asset) external view override returns (bool) {\n        return address(feed[_asset]) != address(0);\n    }\n\n    function getPrice(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        (, int256 price, , , ) = feed[_asset].latestRoundData();\n        uint256 decimalSum = feed[_asset].decimals() +\n            IERC20Metadata(_asset).decimals();\n        if (decimalSum > 18) {\n            return\n                float({\n                    numerator: uint256(price),\n                    denominator: 10**(decimalSum - 18)\n                });\n        } else {\n            return\n                float({\n                    numerator: uint256(price) * 10**(18 - decimalSum),\n                    denominator: 1\n                });\n        }\n    }\n\n    function getLiquidity(address _asset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        revert(\"chainlink adapter does not support liquidity\");\n    }\n}\n\n\n",
        "CodeNames": [
            "ChainlinkAdapter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ChainlinkAdapter.sol L49",
                "Type": "Chainlink stale data",
                "Description": "If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle, consumers of this contract may continue using outdated stale or incorrect data.",
                "Repair": "Add checks to ensure the latestRoundData() is not stale or incorrect"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMochiProfile.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\n///@notice this is where policies including some math is registered will be able to swap the profile when current profile is not suitable\n///@dev this profile is built with https://docs.google.com/spreadsheets/d/1T2WKpwj5QmueR7O8R9AXNbnHLc-rJ_-8DLdRI2eJZqA\ncontract MochiProfileV0 is IMochiProfile {\n    using Float for float;\n    using Float for uint256;\n    IMochiEngine public immutable engine;\n\n    uint256 public override liquidityRequirement;\n\n    uint256 public override minimumDebt;\n\n    mapping(address => AssetClass) internal _assetClass;\n\n    mapping(address => uint256) public override creditCap;\n\n    uint256 public immutable secPerYear;\n\n    uint256 public override delay;\n\n    constructor(address _engine) {\n        secPerYear = 31536000;\n        engine = IMochiEngine(_engine);\n\n        liquidityRequirement = 1000000e18; // 1million dollar\n        minimumDebt = 1000e18;\n        delay = 3 minutes;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == engine.governance(), \"!gov\");\n        _;\n    }\n\n    function assetClass(address _asset)\n        public\n        view\n        override\n        returns (AssetClass)\n    {\n        return _assetClass[_asset];\n    }\n\n    function changeLiquidityRequirement(uint256 _requirement)\n        external\n        override\n        onlyGov\n    {\n        liquidityRequirement = _requirement;\n    }\n\n    function registerAsset(address _asset) external {\n        uint256 liq = engine.cssr().getLiquidity(_asset);\n        require(liq >= liquidityRequirement, \"<liquidity\");\n        _register(_asset, AssetClass.Sigma);\n    }\n\n    function registerAssetByGov(\n        address[] calldata _asset,\n        AssetClass[] calldata _classes\n    ) external onlyGov {\n        for (uint256 i = 0; i < _asset.length; i++) {\n            _register(_asset[i], _classes[i]);\n            engine.vaultFactory().deployVault(_asset[i]);\n        }\n    }\n\n    function _register(address _asset, AssetClass _class) internal {\n        _assetClass[_asset] = _class;\n    }\n\n    function changeMinimumDebt(uint256 _debt) external override onlyGov {\n        minimumDebt = _debt;\n    }\n\n    function changeAssetClass(\n        address[] calldata _assets,\n        AssetClass[] calldata _classes\n    ) external override onlyGov {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _assetClass[_assets[i]] = _classes[i];\n        }\n    }\n\n    function changeCreditCap(\n        address[] calldata _assets,\n        uint256[] calldata _caps\n    ) external onlyGov {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            creditCap[_assets[i]] = _caps[i];\n        }\n    }\n\n    function setDelay(uint256 _delay) external onlyGov {\n        delay = _delay;\n    }\n\n    ///@notice The Collateral Factor at which the users vault will be liquidated\n    function liquidationFactor(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 95, denominator: 100});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 85, denominator: 100});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 80, denominator: 100});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 75, denominator: 100});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 65, denominator: 100});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 40, denominator: 100});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function riskFactor(address _asset) public view returns (uint256) {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return 1;\n        } else if (class == AssetClass.Alpha) {\n            return 2;\n        } else if (class == AssetClass.Gamma) {\n            return 3;\n        } else if (class == AssetClass.Delta) {\n            return 4;\n        } else if (class == AssetClass.Zeta) {\n            return 5;\n        } else if (class == AssetClass.Sigma) {\n            return 6;\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function maxCollateralFactor(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 90, denominator: 100});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 80, denominator: 100});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 75, denominator: 100});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 65, denominator: 100});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 55, denominator: 100});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 45, denominator: 100});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function baseFee() public pure returns (float memory) {\n        return float({numerator: 5, denominator: 1000});\n    }\n\n    function liquidationFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 45, denominator: 1000});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 100, denominator: 1000});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 125, denominator: 1000});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 150, denominator: 1000});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 175, denominator: 1000});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 200, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function keeperFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 5, denominator: 1000});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 10, denominator: 1000});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 15, denominator: 1000});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 20, denominator: 1000});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 25, denominator: 1000});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 30, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function maxFee(AssetClass _class) public pure returns (float memory) {\n        if (_class == AssetClass.Stable) {\n            return float({numerator: 10, denominator: 1000});\n        } else if (_class == AssetClass.Alpha) {\n            return float({numerator: 15, denominator: 1000});\n        } else if (_class == AssetClass.Gamma) {\n            return float({numerator: 20, denominator: 1000});\n        } else if (_class == AssetClass.Delta) {\n            return float({numerator: 21, denominator: 1000});\n        } else if (_class == AssetClass.Zeta) {\n            return float({numerator: 22, denominator: 1000});\n        } else if (_class == AssetClass.Sigma) {\n            return float({numerator: 23, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function stabilityFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        float memory base = baseFee();\n        AssetClass class = assetClass(_asset);\n        float memory max = maxFee(class);\n        float memory u = utilizationRatio(_asset);\n        if (u.gt(float({numerator: 1, denominator: 1}))) {\n            return max;\n        }\n        return base.add(max.sub(base).mul(u));\n    }\n\n    function calculateFeeIndex(\n        address _asset,\n        uint256 _currentIndex,\n        uint256 _lastAccrued\n    ) external view override returns (uint256) {\n        float memory feePerYear = stabilityFee(_asset);\n        uint256 timePassed = block.timestamp - _lastAccrued;\n        float memory feeAccumulated = feePerYear.mul(\n            float({numerator: timePassed, denominator: secPerYear})\n        );\n        return _currentIndex + _currentIndex.multiply(feeAccumulated);\n    }\n\n    ///@dev returns utilization ratio scaled with 1e18\n    function utilizationRatio(address _asset)\n        public\n        view\n        override\n        returns (float memory ratio)\n    {\n        IMochiVault vault = engine.vaultFactory().getVault(_asset);\n        uint256 debts = vault.debts();\n        uint256 cap = creditCap[_asset];\n        return float({numerator: debts, denominator: cap});\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiProfileV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "registerAsset() function in MochiProfileV0.sol",
                "Type": "Overwriting assetClass value",
                "Description": "Assuming the liquidity for the asset is sufficient, registerAsset() will reset the _assetClass of an already registered asset to AssetClass.Sigma, leading to the entire vault behaving differently.",
                "Repair": "Add a check to ensure the asset being registered does not already exist"
            },
            {
                "Location": "MochiProfileV0 contract, liquidationFactor function",
                "Type": "Collateral/Liquidation Factor Mismatch",
                "Description": "The liquidation factor for the Sigma type is less than the collateral factor, which means that taking the maximum loan can immediately lead to liquidations without a safety buffer.",
                "Repair": "Increase the liquidation factor or decrease the collateral factor for the Sigma type to ensure a safety buffer between them"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    /// storage variables\n    uint256 public override deposits;\n    uint256 public override debts;\n    int256 public override claimable;\n\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\n    ///E.g. If the stability fees are 10% for a year\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\n\n    /// result\n    uint256 public liquidated;\n\n    mapping(uint256 => Detail) public override details;\n    mapping(uint256 => uint256) public lastDeposit;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n\n    modifier wait(uint256 _id) {\n        require(\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\n            \"!wait\"\n        );\n        accrueDebt(_id);\n        _;\n    }\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function initialize(address _asset) external override initializer {\n        asset = IERC20(_asset);\n        debtIndex = 1e18;\n        lastAccrued = block.timestamp;\n    }\n\n    function liveDebtIndex() public view override returns (uint256 index) {\n        return\n            engine.mochiProfile().calculateFeeIndex(\n                address(asset),\n                debtIndex,\n                lastAccrued\n            );\n    }\n\n    function status(uint256 _id) public view override returns (Status) {\n        return details[_id].status;\n    }\n\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        require(details[_id].status != Status.Invalid, \"invalid\");\n        uint256 newIndex = liveDebtIndex();\n        return (details[_id].debt * newIndex) / details[_id].debtIndex;\n    }\n\n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function increase(\n        uint256 _id,\n        uint256 _deposits,\n        uint256 _borrows,\n        address _referrer,\n        bytes memory _data\n    ) external {\n        if (_id == type(uint256).max) {\n            // mint if _id is -1\n            _id = mint(msg.sender, _referrer);\n        }\n        if (_deposits > 0) {\n            deposit(_id, _deposits);\n        }\n        if (_borrows > 0) {\n            borrow(_id, _borrows, _data);\n        }\n    }\n\n    function decrease(\n        uint256 _id,\n        uint256 _withdraws,\n        uint256 _repays,\n        bytes memory _data\n    ) external {\n        if (_repays > 0) {\n            repay(_id, _repays);\n        }\n        if (_withdraws > 0) {\n            withdraw(_id, _withdraws, _data);\n        }\n    }\n\n    function mint(address _recipient, address _referrer)\n        public\n        returns (uint256 id)\n    {\n        id = engine.nft().mint(address(asset), _recipient);\n        details[id].debtIndex = liveDebtIndex();\n        details[id].status = Status.Idle;\n        details[id].referrer = _referrer;\n    }\n\n    /// anyone can deposit collateral to given id\n    /// it will even allow depositing to liquidated vault so becareful when depositing\n    function deposit(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        // should it be able to deposit if invalid?\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        require(\n            details[_id].status == Status.Idle ||\n                details[_id].status == Status.Collaterized ||\n                details[_id].status == Status.Active,\n            \"!depositable\"\n        );\n        lastDeposit[_id] = block.timestamp;\n        deposits += _amount;\n        details[_id].collateral += _amount;\n        if (details[_id].status == Status.Idle) {\n            details[_id].status = Status.Collaterized;\n        }\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// should only be able to withdraw if status is not liquidatable\n    function withdraw(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override wait(_id) {\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        require(\n            !_liquidatable(\n                details[_id].collateral - _amount,\n                price,\n                details[_id].debt\n            ),\n            \"!healthy\"\n        );\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = (details[_id].collateral - _amount)\n            .multiply(cf)\n            .multiply(price);\n        require(details[_id].debt <= maxMinted, \">cf\");\n        deposits -= _amount;\n        details[_id].collateral -= _amount;\n        if (details[_id].collateral == 0) {\n            details[_id].status = Status.Idle;\n        }\n        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n\n    /// someone sends usdm to this address and repays the debt\n    /// will payback the leftover usdm\n    function repay(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        if (_amount > details[_id].debt) {\n            _amount = details[_id].debt;\n        }\n        require(_amount > 0, \"zero\");\n        if (debts < _amount) {\n            // safe gaurd to some underflows\n            debts = 0;\n        } else {\n            debts -= _amount;\n        }\n        details[_id].debt -= _amount;\n        if (details[_id].debt == 0) {\n            details[_id].status = Status.Collaterized;\n        }\n        engine.usdm().transferFrom(msg.sender, address(this), _amount);\n        engine.usdm().burn(_amount);\n    }\n\n    function liquidate(\n        uint256 _id,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external override updateDebt(_id) {\n        require(msg.sender == address(engine.liquidator()), \"!liquidator\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        float memory price = engine.cssr().getPrice(address(asset));\n        require(\n            _liquidatable(details[_id].collateral, price, currentDebt(_id)),\n            \"healthy\"\n        );\n\n        debts -= _usdm;\n\n        details[_id].collateral -= _collateral;\n        details[_id].debt -= _usdm;\n\n        asset.cheapTransfer(msg.sender, _collateral);\n    }\n\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\n    /// @notice should return false if _collateral * liquidationLimit < _debt\n    function _liquidatable(\n        uint256 _collateral,\n        float memory _price,\n        uint256 _debt\n    ) internal view returns (bool) {\n        float memory lf = engine.mochiProfile().liquidationFactor(\n            address(asset)\n        );\n        // when debt is lower than liquidation value, it can be liquidated\n        return _collateral.multiply(lf) < _debt.divide(_price);\n    }\n\n    function liquidatable(uint256 _id) external view returns (bool) {\n        float memory price = engine.cssr().getPrice(address(asset));\n        return _liquidatable(details[_id].collateral, price, currentDebt(_id));\n    }\n\n    function claim() external updateDebt(type(uint256).max) {\n        require(claimable > 0, \"!claimable\");\n        // reserving 25% to prevent potential risks\n        uint256 toClaim = (uint256(claimable) * 75) / 100;\n        mintFeeToPool(toClaim, address(0));\n    }\n\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\n        claimable -= int256(_amount);\n        if (address(0) != _referrer) {\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\n            engine.referralFeePool().addReward(_referrer);\n        } else {\n            engine.minter().mint(address(engine.treasury()), _amount);\n        }\n    }\n\n    // Flash Loan\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(asset), \"!supported\");\n        return asset.balanceOf(address(this));\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(asset), \"!supported\");\n        return (_amount * 1337) / 1000000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(asset), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        asset.cheapTransfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        asset.cheapTransferFrom(address(_receiver), address(this), _amount);\n        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@mochifi/library/contracts/Float.sol\";\nimport \"@mochifi/library/contracts/BeaconProxyDeployer.sol\";\nimport \"../interfaces/ILiquidator.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract DutchAuctionLiquidator is ILiquidator {\n    using Float for uint256;\n    IMochiEngine public immutable engine;\n\n    uint256 public constant DURATION = 2 days / 15;\n\n    struct Auction {\n        uint256 nftId;\n        address vault;\n        uint256 startedAt;\n        uint256 boughtAt;\n        uint256 collateral;\n        uint256 debt;\n    }\n\n    mapping(uint256 => Auction) public auctions;\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function auctionId(address asset, uint256 nftId)\n        public\n        pure\n        returns (uint256)\n    {\n        return uint256(keccak256(abi.encodePacked(asset, nftId)));\n    }\n\n    function price(uint256 _auctionId) external view returns (uint256) {\n        Auction memory auction = auctions[_auctionId];\n        return auction.debt + currentLiquidationFee(_auctionId);\n    }\n\n    function currentLiquidationFee(uint256 _auctionId)\n        public\n        view\n        returns (uint256 liquidationFee)\n    {\n        Auction memory auction = auctions[_auctionId];\n        liquidationFee = auction\n            .debt\n            .multiply(\n                engine.mochiProfile().liquidationFee(\n                    address(IMochiVault(auction.vault).asset())\n                )\n            )\n            .multiply(\n                float({\n                    numerator: auction.startedAt + DURATION > block.number\n                        ? auction.startedAt + DURATION - block.number\n                        : 0,\n                    denominator: DURATION\n                })\n            );\n    }\n\n    function triggerLiquidation(address _asset, uint256 _nftId)\n        external\n        override\n    {\n        IMochiVault vault = engine.vaultFactory().getVault(_asset);\n        Auction storage auction = auctions[auctionId(_asset, _nftId)];\n        require(auction.startedAt == 0 || auction.boughtAt != 0, \"on going\");\n        uint256 debt = vault.currentDebt(_nftId);\n        (, uint256 collateral, , , ) = vault.details(_nftId);\n\n        vault.liquidate(_nftId, collateral, debt);\n\n        auction.nftId = _nftId;\n        auction.vault = address(vault);\n        auction.startedAt = block.number;\n        auction.boughtAt = 0;\n        auction.collateral = collateral;\n        auction.debt = debt;\n\n        uint256 liquidationFee = debt.multiply(\n            engine.mochiProfile().liquidationFee(address(_asset))\n        );\n        emit Triggered(auctionId(_asset, _nftId), debt + liquidationFee);\n    }\n\n    function settleLiquidation(\n        uint256 _auctionId,\n        uint256 _collateral,\n        uint256 _repaid\n    ) internal {\n        Auction storage auction = auctions[_auctionId];\n        require(auction.boughtAt == 0, \"liquidated\");\n        IMochiVault vault = IMochiVault(auction.vault);\n        //repay the debt first\n        engine.usdm().transferFrom(msg.sender, address(this), _repaid);\n        engine.usdm().burn(_repaid);\n        IERC20 asset = vault.asset();\n        auction.boughtAt = block.number;\n        asset.transfer(msg.sender, _collateral);\n        //transfer liquidation fee to feePool\n        uint256 liquidationFee = currentLiquidationFee(_auctionId);\n        engine.usdm().transferFrom(\n            msg.sender,\n            address(engine.feePool()),\n            liquidationFee\n        );\n\n        emit Settled(_auctionId, _repaid + liquidationFee);\n    }\n\n    function buy(uint256 _auctionId) external {\n        Auction memory auction = auctions[_auctionId];\n        require(auction.startedAt != 0 && auction.boughtAt == 0, \"!on going\");\n        settleLiquidation(_auctionId, auction.collateral, auction.debt);\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiVault.sol",
            "DutchAuctionLiquidator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "triggerLiquidation() function in DutchAuctionLiquidator.sol and liquidate() function in MochiVault.sol",
                "Type": "Liquidation not working with non-zero discounts",
                "Description": "Any discount profile that actually discounts the debt of the position will result in all liquidations erroring out due to an underflow, since liquidate() function will error due to an underflow.",
                "Repair": "Change 'details[_id].debt -= _usdm;' to 'details[_id].debt = 0;' in the liquidate() function"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "UniswapV2/SushiwapLPAdapter.update function",
                "Type": "Infinite Recursion",
                "Description": "The update function retrieves the underlying from the LP token pair (_asset) but then calls router.update(_asset, _proof) which is the LP token itself again. This will end up with the router calling this function again recursively.",
                "Repair": "Call router.update(underlying, _proof) instead of router.update(_asset, _proof)"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@mochifi/library/contracts/UniswapV2Library.sol\";\nimport \"@mochifi/library/contracts/SushiswapV2Library.sol\";\nimport \"../interfaces/ICSSRRouter.sol\";\nimport \"../interfaces/ICSSRAdapter.sol\";\nimport \"../interfaces/IUniswapV2CSSR.sol\";\nimport \"../interfaces/IGovernanceOwned.sol\";\n\ncontract UniswapV2TokenAdapter is ICSSRAdapter {\n    IGovernanceOwned public immutable owned;\n    ICSSRRouter public immutable cssrRouter;\n    IUniswapV2CSSR public immutable uniswapCSSR;\n    IUniswapV2CSSR public immutable sushiCSSR;\n\n    address[] public keyCurrency;\n    uint256 public minimumLiquidity;\n    mapping(address => bool) public isKeyCurrency;\n\n    modifier onlyGov() {\n        require(msg.sender == owned.governance(), \"!gov\");\n        _;\n    }\n\n    constructor(\n        address _owned,\n        address _router,\n        address _uniCSSR,\n        address _sushiCSSR\n    ) {\n        owned = IGovernanceOwned(_owned);\n        cssrRouter = ICSSRRouter(_router);\n        uniswapCSSR = IUniswapV2CSSR(_uniCSSR);\n        sushiCSSR = IUniswapV2CSSR(_sushiCSSR);\n    }\n\n    function addKeyCurrency(address _currency) external onlyGov {\n        keyCurrency.push(_currency);\n        isKeyCurrency[_currency] = true;\n    }\n\n    function removeKeyCurrency(uint256 _idx, address _currency)\n        external\n        onlyGov\n    {\n        require(keyCurrency[_idx] == _currency, \"!match\");\n        keyCurrency[_idx] = keyCurrency[keyCurrency.length - 1];\n        keyCurrency.pop();\n        isKeyCurrency[_currency] = false;\n    }\n\n    function setMinimumLiquidity(uint256 _liquidity)\n        external\n        onlyGov\n    {\n        minimumLiquidity = _liquidity;\n    }\n\n    function support(address _asset) external view override returns (bool) {\n        // check if liquidity passes the minimum\n        for (uint256 i = 0; i < keyCurrency.length; i++) {\n            if (aboveLiquidity(_asset, keyCurrency[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function update(address _asset, bytes memory _data)\n        external\n        override\n        returns (float memory)\n    {\n        (uint256 cssrType, bytes memory data) = abi.decode(_data, (uint256, bytes));\n        if(cssrType == 0){\n            (\n                address p,\n                bytes memory bd,\n                bytes memory ap,\n                bytes memory rp,\n                bytes memory pp0,\n                bytes memory pp1\n            ) = abi.decode(data, (address, bytes, bytes, bytes, bytes, bytes));\n            require(isKeyCurrency[p], \"!keyCurrency\");\n            (, uint256 bn, ) = uniswapCSSR.saveState(bd);\n            address pair = UniswapV2Library.pairFor(\n                uniswapCSSR.uniswapFactory(),\n                _asset,\n                p\n            );\n            uniswapCSSR.saveReserve(bn, pair, ap, rp, pp0, pp1);\n        } else if(cssrType == 1){\n            (\n                address p,\n                bytes memory bd,\n                bytes memory ap,\n                bytes memory rp,\n                bytes memory pp0,\n                bytes memory pp1\n            ) = abi.decode(data, (address, bytes, bytes, bytes, bytes, bytes));\n            require(isKeyCurrency[p], \"!keyCurrency\");\n            (, uint256 bn, ) = sushiCSSR.saveState(bd);\n            address pair = SushiswapV2Library.pairFor(\n                sushiCSSR.uniswapFactory(),\n                _asset,\n                p\n            );\n            sushiCSSR.saveReserve(bn, pair, ap, rp, pp0, pp1);\n        } else {\n            revert(\"!supported type\");\n        }\n        return getPrice(_asset);\n    }\n\n    function getPriceRaw(address _asset)\n        public\n        view\n        returns (uint256 sumPrice, uint256 sumLiquidity)\n    {\n        for (uint256 i = 0; i < keyCurrency.length; i++) {\n            address key = keyCurrency[i];\n            float memory currencyPrice = cssrRouter.getPrice(key);\n            if (_asset == key) {\n                continue;\n            }\n            try uniswapCSSR.getLiquidity(_asset, key) returns (uint256 liq) {\n                uint256 liquidityValue = convertToValue(liq, currencyPrice);\n                if (liquidityValue >= minimumLiquidity) {\n                    sumLiquidity += liquidityValue;\n                    sumPrice +=\n                        convertToValue(\n                            uniswapCSSR.getExchangeRatio(_asset, key),\n                            currencyPrice\n                        ) *\n                        liquidityValue;\n                }\n            } catch {\n            }\n            try sushiCSSR.getLiquidity(_asset, key) returns (uint256 liq) {\n                uint256 liq = sushiCSSR.getLiquidity(_asset,key);\n                uint256 liquidityValue = convertToValue(liq, currencyPrice);\n                if (liquidityValue >= minimumLiquidity) {\n                    sumLiquidity += liquidityValue;\n                    sumPrice +=\n                        convertToValue(\n                            sushiCSSR.getExchangeRatio(_asset, key),\n                            currencyPrice\n                        ) *\n                        liquidityValue;\n                }\n            } catch {\n            }\n        }\n    }\n\n    function getPrice(address _asset)\n        public\n        view\n        override\n        returns (float memory price)\n    {\n        (uint256 sumPrice, uint256 sumLiquidity) = getPriceRaw(_asset);\n        require(sumLiquidity > 0, \"!updated\");\n        return float({numerator: sumPrice / 2**112, denominator: sumLiquidity});\n    }\n\n    function getLiquidity(address _asset)\n        external\n        view\n        override\n        returns (uint256 sum)\n    {\n        for (uint256 i = 0; i < keyCurrency.length; i++) {\n            address key = keyCurrency[i];\n            float memory currencyPrice = cssrRouter.getPrice(key);\n            if (_asset == key) {\n                continue;\n            }\n            try uniswapCSSR.getLiquidity(_asset, key) returns (uint256 liq) {\n                uint256 liquidityValue = convertToValue(liq, currencyPrice);\n                if (liquidityValue >= minimumLiquidity) {\n                    sum += liquidityValue;\n                }\n            } catch {\n            }\n            try sushiCSSR.getLiquidity(_asset, key) returns (uint256 liq) {\n                uint256 liquidityValue = convertToValue(liq, currencyPrice);\n                if (liquidityValue >= minimumLiquidity) {\n                    sum += liquidityValue;\n                }\n            } catch {\n            }\n        }\n    }\n\n    function aboveLiquidity(address _asset, address _pairedWith)\n        public\n        view\n        returns (bool)\n    {\n        try uniswapCSSR.getLiquidity(_asset, _pairedWith) returns (\n            uint256 liq\n        ) {\n            float memory price = cssrRouter.getPrice(_pairedWith);\n            return convertToValue(liq, price) >= minimumLiquidity;\n        } catch {\n            try sushiCSSR.getLiquidity(_asset, _pairedWith) returns (\n                uint256 liq\n            ) {\n                float memory price = cssrRouter.getPrice(_pairedWith);\n                return convertToValue(liq, price) >= minimumLiquidity;\n            } catch {\n                return false;\n            }\n        }\n    }\n\n    function convertToValue(uint256 _amount, float memory _price)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_amount * _price.numerator) / _price.denominator;\n    }\n}\n\n\n",
        "CodeNames": [
            "UniswapV2TokenAdapter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "UniswapV2TokenAdapter.supports function",
                "Type": "Unsupported Asset",
                "Description": "The UniswapV2TokenAdapter does not support Sushiswap-only assets.",
                "Repair": "Compare the Sushiswap liquidity against the minimum liquidity threshold if the UniswapV2 liquidity is less than the minimum liquidity"
            }
        ]
    }
]