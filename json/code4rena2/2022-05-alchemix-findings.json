[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport {\n    IllegalArgument,\n    IllegalState,\n    Unauthorized,\n    UnsupportedOperation\n} from \"../../base/Errors.sol\";\n\nimport {Mutex} from \"../../base/Mutex.sol\";\n\nimport {LibFuse} from \"../../libraries/LibFuse.sol\";\nimport {SafeERC20} from \"../../libraries/SafeERC20.sol\";\n\nimport {ICERC20} from \"../../interfaces/external/compound/ICERC20.sol\";\nimport {ITokenAdapter} from \"../../interfaces/ITokenAdapter.sol\";\nimport {IWETH9} from \"../../interfaces/external/IWETH9.sol\";\n\nstruct InitializationParams {\n    address alchemist;\n    address token;\n    address underlyingToken;\n}\n\ncontract FuseTokenAdapterV1 is ITokenAdapter, Mutex {\n    string public override version = \"1.0.0\";\n\n    address public immutable alchemist;\n    address public immutable override token;\n    address public immutable override underlyingToken;\n\n    /// @dev Fuse error code for a noop.\n    uint256 private constant NO_ERROR = 0;\n\n    /// @dev Scalar for all fixed point numbers returned by Fuse.\n    uint256 private constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @notice An error used when a call to Fuse fails.\n    ///\n    /// @param code The error code.\n    error FuseError(uint256 code);\n\n    constructor(InitializationParams memory params) {\n        alchemist       = params.alchemist;\n        token           = params.token;\n        underlyingToken = params.underlyingToken;\n    }\n\n    /// @dev Checks that the message sender is the alchemist that the adapter is bound to.\n    modifier onlyAlchemist() {\n        if (msg.sender != alchemist) {\n            revert Unauthorized(\"Not alchemist\");\n        }\n        _;\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function price() external view returns (uint256) {\n        return LibFuse.viewExchangeRate(ICERC20(token));\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function wrap(\n        uint256 amount,\n        address recipient\n    ) external onlyAlchemist returns (uint256) {\n        SafeERC20.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        SafeERC20.safeApprove(underlyingToken, token, amount);\n\n        uint256 startingBalance = IERC20(token).balanceOf(address(this));\n\n        uint256 error;\n        if ((error = ICERC20(token).mint(amount)) != NO_ERROR) {\n            revert FuseError(error);\n        }\n\n        uint256 endingBalance = IERC20(token).balanceOf(address(this));\n        uint256 mintedAmount = endingBalance - startingBalance;\n\n        SafeERC20.safeTransfer(token, recipient, mintedAmount);\n\n        return mintedAmount;\n    }\n\n    // @inheritdoc ITokenAdapter\n    function unwrap(\n        uint256 amount,\n        address recipient\n    ) external lock onlyAlchemist returns (uint256) {\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), amount);\n\n        uint256 startingBalance = IERC20(underlyingToken).balanceOf(address(this));\n\n        uint256 error;\n        if ((error = ICERC20(token).redeem(amount)) != NO_ERROR) {\n            revert FuseError(error);\n        }\n\n        uint256 endingBalance = IERC20(underlyingToken).balanceOf(address(this));\n        uint256 redeemedAmount = endingBalance - startingBalance;\n\n        SafeERC20.safeTransfer(underlyingToken, recipient, redeemedAmount);\n\n        return redeemedAmount;\n    }\n}\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {stdCheats} from \"forge-std/stdlib.sol\";\n\nimport {\n    FuseTokenAdapterV1,\n    InitializationParams as AdapterInitializationParams\n} from \"../adapters/fuse/FuseTokenAdapterV1.sol\";\n\nimport {ICERC20} from \"../interfaces/external/compound/ICERC20.sol\";\n\nimport {SafeERC20} from \"../libraries/SafeERC20.sol\";\nimport {LibFuse} from \"../libraries/LibFuse.sol\";\n\ncontract FuseTokenAdapterV1Test is DSTestPlus, stdCheats {\n    uint256 constant BPS = 10000;\n    ICERC20 constant fDAI = ICERC20(0x7e9cE3CAa9910cc048590801e64174957Ed41d43);\n\n    IERC20 underlyingToken;\n    FuseTokenAdapterV1 adapter;\n\n    function setUp() external {\n        underlyingToken = IERC20(fDAI.underlying());\n\n        adapter = new FuseTokenAdapterV1(AdapterInitializationParams({\n            alchemist:       address(this),\n            token:           address(fDAI),\n            underlyingToken: address(fDAI.underlying())\n        }));\n    }\n\n    function testRoundTrip() external {\n        tip(address(underlyingToken), address(this), 1e18);\n\n        SafeERC20.safeApprove(address(underlyingToken), address(adapter), 1e18);\n        uint256 wrapped = adapter.wrap(1e18, address(this));\n\n        uint256 underlyingValue = wrapped * adapter.price() / 10**SafeERC20.expectDecimals(address(fDAI));\n        assertGt(underlyingValue, 1e18 * 9900 / BPS /* 1% slippage */);\n\n        SafeERC20.safeApprove(adapter.token(), address(adapter), wrapped);\n        uint256 unwrapped = adapter.unwrap(wrapped, address(0xbeef));\n\n        assertEq(underlyingToken.balanceOf(address(0xbeef)), unwrapped);\n        assertEq(fDAI.balanceOf(address(this)), 0);\n        assertEq(fDAI.balanceOf(address(adapter)), 0);\n    }\n\n    function testRoundTrip(uint256 amount) external {\n        hevm.assume(\n            amount >= 10**SafeERC20.expectDecimals(adapter.underlyingToken()) && \n            amount < type(uint96).max\n        );\n        \n        tip(address(underlyingToken), address(this), amount);\n\n        SafeERC20.safeApprove(address(underlyingToken), address(adapter), amount);\n        uint256 wrapped = adapter.wrap(amount, address(this));\n\n        uint256 underlyingValue = wrapped * adapter.price() / 10**SafeERC20.expectDecimals(address(fDAI));\n        assertGt(underlyingValue, amount * 9900 / BPS /* 1% slippage */);\n        \n        SafeERC20.safeApprove(adapter.token(), address(adapter), wrapped);\n        uint256 unwrapped = adapter.unwrap(wrapped, address(0xbeef));\n\n        assertEq(underlyingToken.balanceOf(address(0xbeef)), unwrapped);\n        assertEq(fDAI.balanceOf(address(this)), 0);\n        assertEq(fDAI.balanceOf(address(adapter)), 0);\n    }\n}\n\n",
        "CodeNames": [
            "FuseTokenAdapterV1.sol",
            "FuseTokenAdapterV1.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "wrap() and unwrap() functions in FuseTokenAdapterV1.sol",
                "Type": "DoS",
                "Description": "The wrap() and unwrap() functions in FuseTokenAdapterV1.sol have a wrong check that can cause a DoS vulnerability.",
                "Repair": "Change the lines of code to check if the returned value from mint() and redeem() functions is equal to the amount parameter"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\nimport {IALCXSource} from \"./interfaces/IALCXSource.sol\";\n\n/// @title A wrapper for single-sided ALCX staking\ncontract gALCX is ERC20 {\n\n    IERC20 public alcx = IERC20(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\n    IALCXSource public pools = IALCXSource(0xAB8e74017a8Cc7c15FFcCd726603790d26d7DeCa);\n    uint public poolId = 1;\n    uint public constant exchangeRatePrecision = 1e18;\n    uint public exchangeRate = exchangeRatePrecision;\n    address public owner;\n\n    event ExchangeRateChange(uint _exchangeRate);\n    event Stake(address _from, uint _gAmount, uint _amount);\n    event Unstake(address _from, uint _gAmount, uint _amount);\n\n    /// @param _name The token name\n    /// @param _symbol The token symbol\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        owner = msg.sender;\n        reApprove();\n    }\n\n    // OWNERSHIP\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /// @notice Transfer contract ownership\n    /// @param _owner The new owner address\n    function transferOwnership(address _owner) external onlyOwner {\n        owner = _owner;\n    }\n\n    /// @notice Set a new staking pool address and migrate funds there\n    /// @param _pools The new pool address\n    /// @param _poolId The new pool id\n    function migrateSource(address _pools, uint _poolId) external onlyOwner {\n        // Withdraw ALCX\n        bumpExchangeRate();\n\n        uint poolBalance = pools.getStakeTotalDeposited(address(this), poolId);\n        pools.withdraw(poolId, poolBalance);\n        // Update staking pool address and id\n        pools = IALCXSource(_pools);\n        poolId = _poolId;\n        // Deposit ALCX\n        uint balance = alcx.balanceOf(address(this));\n        reApprove();\n        pools.deposit(poolId, balance);\n    }\n\n    /// @notice Approve the staking pool to move funds in this address, can be called by anyone\n    function reApprove() public {\n        bool success = alcx.approve(address(pools), type(uint).max);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Claim and autocompound rewards\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance > 0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n            emit ExchangeRateChange(exchangeRate);\n            // Restake\n            pools.deposit(poolId, balance);\n        }\n    }\n\n    /// @notice Deposit new funds into the staking pool\n    /// @param amount The amount of ALCX to deposit\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n        emit Stake(msg.sender, gAmount, amount);\n    }\n\n    /// @notice Withdraw funds from the staking pool\n    /// @param gAmount the amount of gALCX to withdraw\n    function unstake(uint gAmount) external {\n        bumpExchangeRate();\n        uint amount = gAmount * exchangeRate / exchangeRatePrecision;\n        _burn(msg.sender, gAmount);\n        // Withdraw ALCX and send to user\n        pools.withdraw(poolId, amount);\n        bool success = alcx.transfer(msg.sender, amount); // Should return true or revert, but doesn't hurt\n        require(success, \"Transfer failed\"); \n        emit Unstake(msg.sender, gAmount, amount);\n    }\n}\n\n",
        "CodeNames": [
            "gALCX.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "gALCX.sol",
                "Type": "DoS",
                "Description": "An attacker can make the gALCX contract unusable when totalSupply is 0.",
                "Repair": "Add handling when totalSupply is 0 but alcx.balanceOf(address(this)) is more than 0"
            },
            {
                "Location": "gALCX.sol#L93-L94, gALCX.sol#L15, gALCX.sol#L69-L76, gALCX.sol#L85-L93",
                "Type": "Depression of new gALCX token denomination",
                "Description": "An attacker can become the first depositor for a recently created gALCX contract, providing a tiny amount of ALCX tokens by calling stake(1). Then the attacker can directly transfer, for example, 10^6 * 1e18 of ALCX to the gALCX contract and run bumpExchangeRate(), effectively setting the cost of 1 gALCX to be 10^6 * 1e18 of ALCX. The attacker will still own 100% of the gALCX's ALCX pool being the only depositor.",
                "Repair": "Require a minimum deposit value or require the first depositor to freeze a big enough initial amount of liquidity."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\n/// @notice Initially, the contract deployer is given both the admin and minter role. This allows them to pre-mine\n///         tokens, transfer admin to a timelock contract, and lastly, grant the staking pools the minter role. After\n///         this is done, the deployer must revoke their admin role and minter role.\ncontract AlchemicTokenV2Base is ERC20Upgradeable, AccessControlUpgradeable, IERC3156FlashLender, ReentrancyGuardUpgradeable {\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping(address => uint256) public mintCeiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping(address => uint256) public totalMinted;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  function __AlchemicTokenV2Base_init() internal {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    uint256 total = amount + totalMinted[msg.sender];\n    if (total > mintCeiling[msg.sender]) {\n      revert IllegalState();\n    }\n\n    totalMinted[msg.sender] = total;\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    mintCeiling[minter] = maximum;\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) external onlyWhitelisted {\n    totalMinted[msg.sender] = totalMinted[msg.sender] - amount;\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {CrossChainCanonicalBase} from \"./CrossChainCanonicalBase.sol\";\nimport {AlchemicTokenV2Base} from \"./AlchemicTokenV2Base.sol\";\n\ncontract CrossChainCanonicalAlchemicTokenV2 is CrossChainCanonicalBase, AlchemicTokenV2Base {\n  function initialize(\n      string memory name, \n      string memory symbol, \n      address[] memory _bridgeTokens\n  ) public initializer {\n    __CrossChainCanonicalBase_init(\n      name,\n      symbol,\n      msg.sender,\n      _bridgeTokens\n    );\n    __AlchemicTokenV2Base_init();\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport {ERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState} from \"./base/Errors.sol\";\n\nimport {TokenUtils} from \"./libraries/TokenUtils.sol\";\n\ncontract CrossChainCanonicalBase is ERC20PermitUpgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable {\n\n    // Constants for various precisions\n    uint256 private constant FEE_PRECISION = 1e6; // Okay to use constant declarations since compiler does not reserve a storage slot\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Swap fee numerators, denominator of FEE_PRECISION\n    mapping(address => uint256[2]) public swapFees;\n    mapping(address => bool) public feeExempt;\n\n    // Acceptable old tokens\n    address[] public bridgeTokensArray; // Used for external UIs\n    mapping(address => bool) public bridgeTokens; // Used for the logic checks\n\n    // Administrative booleans\n    bool public exchangesPaused; // Pause old token exchanges in case of an emergency\n    mapping(address => bool) public bridgeTokenEnabled;\n\n    /* ========== MODIFIERS ========== */\n\n    modifier validBridgeToken(address tokenAddress) {\n        if (!bridgeTokenEnabled[tokenAddress]) {\n            revert IllegalState();\n        }\n        _;\n    }\n\n    /* ========== INITIALIZER ========== */\n\n    function __CrossChainCanonicalBase_init(\n        string memory _name,\n        string memory _symbol,\n        address _creatorAddress,\n        address[] memory _bridgeTokens\n    ) internal {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __EIP712_init_unchained(_name, \"1\");\n        __ERC20_init_unchained(_name, _symbol);\n        __ERC20Permit_init_unchained(_name);\n        __ReentrancyGuard_init_unchained(); // Note: this is called here but not in AlchemicTokenV2Base. Careful if inheriting that without this\n        _transferOwnership(_creatorAddress);\n\n        // Initialize the starting old tokens\n        for (uint256 i = 0; i < _bridgeTokens.length; i++){ \n            // Mark as accepted\n            bridgeTokens[_bridgeTokens[i]] = true;\n\n            // Add to the array\n            bridgeTokensArray.push(_bridgeTokens[i]);\n\n            // Set a small swap fee initially of 0.04%\n            swapFees[_bridgeTokens[i]] = [400, 400];\n\n            // Make sure swapping is on\n            bridgeTokenEnabled[_bridgeTokens[i]] = true;\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    // Helpful for UIs\n    function allBridgeTokens() external view returns (address[] memory) {\n        return bridgeTokensArray;\n    }\n\n    function _isFeeExempt(address targetAddress) internal view returns (bool) {\n        return feeExempt[targetAddress];\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Exchange old tokens for these canonical tokens\n    function exchangeOldForCanonical(address bridgeTokenAddress, uint256 tokenAmount) external nonReentrant validBridgeToken(bridgeTokenAddress) returns (uint256 canonicalTokensOut) {\n        if (exchangesPaused) {\n            revert IllegalState();\n        }\n\n        if (!bridgeTokenEnabled[bridgeTokenAddress]) {\n            revert IllegalState();\n        }\n\n        // Pull in the old tokens\n        TokenUtils.safeTransferFrom(bridgeTokenAddress, msg.sender, address(this), tokenAmount);\n\n        // Handle the fee, if applicable\n        canonicalTokensOut = tokenAmount;\n        if (!_isFeeExempt(msg.sender)) {\n            canonicalTokensOut -= ((canonicalTokensOut * swapFees[bridgeTokenAddress][0]) / FEE_PRECISION);\n        }\n\n        // Mint canonical tokens and give it to the sender\n        super._mint(msg.sender, canonicalTokensOut);\n    }\n\n    // Exchange canonical tokens for old tokens\n    function exchangeCanonicalForOld(address bridgeTokenAddress, uint256 tokenAmount) external nonReentrant validBridgeToken(bridgeTokenAddress) returns (uint256 bridgeTokensOut) {\n        if (exchangesPaused) {\n            revert IllegalState();\n        }\n\n        if (!bridgeTokenEnabled[bridgeTokenAddress]) {\n            revert IllegalState();\n        }\n\n        // Burn the canonical tokens\n        super._burn(msg.sender, tokenAmount);\n\n        // Handle the fee, if applicable\n        bridgeTokensOut = tokenAmount;\n        if (!_isFeeExempt(msg.sender)) {\n            bridgeTokensOut -= ((bridgeTokensOut * swapFees[bridgeTokenAddress][1]) / FEE_PRECISION);\n        }\n\n        // Give old tokens to the sender\n        TokenUtils.safeTransfer(bridgeTokenAddress, msg.sender, bridgeTokensOut);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS, BUT CUSTODIAN CAN CALL TOO ========== */\n\n    function toggleExchanges() external onlyOwner {\n        exchangesPaused = !exchangesPaused;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function addBridgeToken(address bridgeTokenAddress) external onlyOwner {\n        // Make sure the token is not already present\n        for (uint i = 0; i < bridgeTokensArray.length; i++){ \n            if (bridgeTokensArray[i] == bridgeTokenAddress) {\n                revert IllegalState();\n            }\n        }\n\n        // Add the old token\n        bridgeTokensArray.push(bridgeTokenAddress);\n\n        // Turn swapping on\n        bridgeTokenEnabled[bridgeTokenAddress] = true;\n\n        emit BridgeTokenAdded(bridgeTokenAddress);\n    }\n\n    function toggleBridgeToken(address bridgeTokenAddress, bool enabled) external onlyOwner {\n        // Toggle swapping\n        bridgeTokenEnabled[bridgeTokenAddress] = enabled;\n\n        emit BridgeTokenToggled(bridgeTokenAddress, enabled);\n    }\n\n    function setSwapFees(address bridgeTokenAddress, uint256 _bridgeToCanonical, uint256 _canonicalToOld) external onlyOwner {\n        swapFees[bridgeTokenAddress] = [_bridgeToCanonical, _canonicalToOld];\n\n        emit SwapFeeSet(bridgeTokenAddress, _bridgeToCanonical, _canonicalToOld);\n    }\n\n    function toggleFeesForAddress(address targetAddress) external onlyOwner {\n        feeExempt[targetAddress] = !feeExempt[targetAddress];\n    }\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        if (tokenAddress == address(this)) {\n            revert IllegalArgument();\n        }\n\n        if (bridgeTokenEnabled[tokenAddress]) {\n            revert IllegalState();\n        }\n\n        TokenUtils.safeTransfer(address(tokenAddress), msg.sender, tokenAmount);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event BridgeTokenAdded(address indexed bridgeTokenAddress);\n    event BridgeTokenToggled(address indexed bridgeTokenAddress, bool state);\n    event SwapFeeSet(address indexed bridgeTokenAddress, uint bridgeToCanonical, uint canonicalToOld);\n}\n\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./base/Errors.sol\";\n\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./interfaces/transmuter/ITransmuterV2.sol\";\nimport \"./interfaces/transmuter/ITransmuterBuffer.sol\";\n\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/LiquidityMath.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Tick.sol\";\nimport \"./libraries/TokenUtils.sol\";\n\n/// @title TransmuterV2\n///\n/// @notice A contract which facilitates the exchange of synthetic assets for their underlying\n//          asset. This contract guarantees that synthetic assets are exchanged exactly 1:1\n//          for the underlying asset.\ncontract TransmuterV2 is ITransmuterV2, Initializable, ReentrancyGuardUpgradeable, AccessControlUpgradeable {\n  using FixedPointMath for FixedPointMath.Number;\n  using Tick for Tick.Cache;\n\n  struct Account {\n    // The total number of unexchanged tokens that an account has deposited into the system\n    uint256 unexchangedBalance;\n    // The total number of exchanged tokens that an account has had credited\n    uint256 exchangedBalance;\n    // The tick that the account has had their deposit associated in\n    uint256 occupiedTick;\n  }\n\n  struct UpdateAccountParams {\n    // The owner address whose account will be modified\n    address owner;\n    // The amount to change the account's unexchanged balance by\n    int256 unexchangedDelta;\n    // The amount to change the account's exchanged balance by\n    int256 exchangedDelta;\n  }\n\n  struct ExchangeCache {\n    // The total number of unexchanged tokens that exist at the start of the exchange call\n    uint256 totalUnexchanged;\n    // The tick which has been satisfied up to at the start of the exchange call\n    uint256 satisfiedTick;\n    // The head of the active ticks queue at the start of the exchange call\n    uint256 ticksHead;\n  }\n\n  struct ExchangeState {\n    // The position in the buffer of current tick which is being examined\n    uint256 examineTick;\n    // The total number of unexchanged tokens that currently exist in the system for the current distribution step\n    uint256 totalUnexchanged;\n    // The tick which has been satisfied up to, inclusive\n    uint256 satisfiedTick;\n    // The amount of tokens to distribute for the current step\n    uint256 distributeAmount;\n    // The accumulated weight to write at the new tick after the exchange is completed\n    FixedPointMath.Number accumulatedWeight;\n    // Reserved for the maximum weight of the current distribution step\n    FixedPointMath.Number maximumWeight;\n    // Reserved for the dusted weight of the current distribution step\n    FixedPointMath.Number dustedWeight;\n  }\n\n  struct UpdateAccountCache {\n    // The total number of unexchanged tokens that the account held at the start of the update call\n    uint256 unexchangedBalance;\n    // The total number of exchanged tokens that the account held at the start of the update call\n    uint256 exchangedBalance;\n    // The tick that the account's deposit occupies at the start of the update call\n    uint256 occupiedTick;\n    // The total number of unexchanged tokens that exist at the start of the update call\n    uint256 totalUnexchanged;\n    // The current tick that is being written to\n    uint256 currentTick;\n  }\n\n  struct UpdateAccountState {\n    // The updated unexchanged balance of the account being updated\n    uint256 unexchangedBalance;\n    // The updated exchanged balance of the account being updated\n    uint256 exchangedBalance;\n    // The updated total unexchanged balance\n    uint256 totalUnexchanged;\n  }\n\n  address public constant ZERO_ADDRESS = address(0);\n\n  /// @dev The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n  /// @dev The identitifer of the sentinel role\n  bytes32 public constant SENTINEL = keccak256(\"SENTINEL\");\n\n  /// @inheritdoc ITransmuterV2\n  string public constant override version = \"2.2.0\";\n\n  /// @dev the synthetic token to be transmuted\n  address public syntheticToken;\n\n  /// @dev the underlying token to be received\n  address public override underlyingToken;\n\n  /// @dev The total amount of unexchanged tokens which are held by all accounts.\n  uint256 public totalUnexchanged;\n\n  /// @dev The total amount of tokens which are in the auxiliary buffer.\n  uint256 public totalBuffered;\n\n  /// @dev A mapping specifying all of the accounts.\n  mapping(address => Account) private accounts;\n\n  // @dev The tick buffer which stores all of the tick information along with the tick that is\n  //      currently being written to. The \"current\" tick is the tick at the buffer write position.\n  Tick.Cache private ticks;\n\n  // The tick which has been satisfied up to, inclusive.\n  uint256 private satisfiedTick;\n\n  /// @dev contract pause state\n  bool public isPaused;\n\n  /// @dev the source of the exchanged collateral\n  address public buffer;\n\n  /// @dev The address of the external whitelist contract.\n  address public override whitelist;\n\n  /// @dev The amount of decimal places needed to normalize collateral to debtToken\n  uint256 public override conversionFactor;\n\n  constructor() initializer {}\n\n  function initialize(\n    address _syntheticToken,\n    address _underlyingToken,\n    address _buffer,\n    address _whitelist\n  ) external initializer {\n    _setupRole(ADMIN, msg.sender);\n    _setRoleAdmin(ADMIN, ADMIN);\n    _setRoleAdmin(SENTINEL, ADMIN);\n\n    syntheticToken = _syntheticToken;\n    underlyingToken = _underlyingToken;\n    uint8 debtTokenDecimals = TokenUtils.expectDecimals(syntheticToken);\n    uint8 underlyingTokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n    conversionFactor = 10**(debtTokenDecimals - underlyingTokenDecimals);\n    buffer = _buffer;\n    // Push a blank tick to function as a sentinel value in the active ticks queue.\n    ticks.next();\n\n    isPaused = false;\n    whitelist = _whitelist;\n  }\n\n  /// @dev A modifier which checks if caller is an alchemist.\n  modifier onlyBuffer() {\n    if (msg.sender != buffer) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if caller is a sentinel or admin.\n  modifier onlySentinelOrAdmin() {\n    if (!hasRole(SENTINEL, msg.sender) && !hasRole(ADMIN, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if caller is a sentinel.\n  modifier notPaused() {\n    if (isPaused) {\n      revert IllegalState();\n    }\n    _;\n  }\n\n  function _onlyAdmin() internal view {\n    if (!hasRole(ADMIN, msg.sender)) {\n      revert Unauthorized();\n    }\n  }\n\n  function setCollateralSource(address _newCollateralSource) external {\n    _onlyAdmin();\n    buffer = _newCollateralSource;\n  }\n\n  function setPause(bool pauseState) external onlySentinelOrAdmin {\n    isPaused = pauseState;\n    emit Paused(isPaused);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function deposit(uint256 amount, address owner) external override nonReentrant {\n    _onlyWhitelisted();\n    _updateAccount(\n      UpdateAccountParams({\n        owner: owner,\n        unexchangedDelta: SafeCast.toInt256(amount),\n        exchangedDelta: 0\n      })\n    );\n    TokenUtils.safeTransferFrom(syntheticToken, msg.sender, address(this), amount);\n    emit Deposit(msg.sender, owner, amount);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function withdraw(uint256 amount, address recipient) external override nonReentrant {\n    _onlyWhitelisted();\n    _updateAccount(\n      UpdateAccountParams({ \n        owner: msg.sender,\n        unexchangedDelta: -SafeCast.toInt256(amount),\n        exchangedDelta: 0\n      })\n    );\n    TokenUtils.safeTransfer(syntheticToken, recipient, amount);\n    emit Withdraw(msg.sender, recipient, amount);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function claim(uint256 amount, address recipient) external override nonReentrant {\n    _onlyWhitelisted();\n    _updateAccount(\n      UpdateAccountParams({\n        owner: msg.sender,\n        unexchangedDelta: 0,\n        exchangedDelta: -SafeCast.toInt256(_normalizeUnderlyingTokensToDebt(amount))\n      })\n    );\n    TokenUtils.safeBurn(syntheticToken, _normalizeUnderlyingTokensToDebt(amount));\n    ITransmuterBuffer(buffer).withdraw(underlyingToken, amount, msg.sender);\n    emit Claim(msg.sender, recipient, amount);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function exchange(uint256 amount) external override nonReentrant onlyBuffer notPaused {\n    uint256 normaizedAmount = _normalizeUnderlyingTokensToDebt(amount);\n\n    if (totalUnexchanged == 0) {\n      totalBuffered += normaizedAmount;\n      emit Exchange(msg.sender, amount);\n      return;\n    }\n\n    // Push a storage reference to the current tick.\n    Tick.Info storage current = ticks.current();\n\n    ExchangeCache memory cache = ExchangeCache({\n      totalUnexchanged: totalUnexchanged,\n      satisfiedTick: satisfiedTick,\n      ticksHead: ticks.head\n    });\n\n    ExchangeState memory state = ExchangeState({\n      examineTick: cache.ticksHead,\n      totalUnexchanged: cache.totalUnexchanged,\n      satisfiedTick: cache.satisfiedTick,\n      distributeAmount: normaizedAmount,\n      accumulatedWeight: current.accumulatedWeight,\n      maximumWeight: FixedPointMath.encode(0),\n      dustedWeight: FixedPointMath.encode(0)\n    });\n\n    // Distribute the buffered tokens as part of the exchange.\n    state.distributeAmount += totalBuffered;\n    totalBuffered = 0;\n\n    // Push a storage reference to the next tick to write to.\n    Tick.Info storage next = ticks.next();\n\n    // Only iterate through the active ticks queue when it is not empty.\n    while (state.examineTick != 0) {\n      // Check if there is anything left to distribute.\n      if (state.distributeAmount == 0) {\n        break;\n      }\n\n      Tick.Info storage examineTickData = ticks.get(state.examineTick);\n\n      // Add the weight for the distribution step to the accumulated weight.\n      state.accumulatedWeight = state.accumulatedWeight.add(\n        FixedPointMath.rational(state.distributeAmount, state.totalUnexchanged)\n      );\n\n      // Clear the distribute amount.\n      state.distributeAmount = 0;\n\n      // Calculate the current maximum weight in the system.\n      state.maximumWeight = state.accumulatedWeight.sub(examineTickData.accumulatedWeight);\n\n      // Check if there exists at least one account which is completely satisfied..\n      if (state.maximumWeight.n < FixedPointMath.ONE) {\n        break;\n      }\n\n      // Calculate how much weight of the distributed weight is dust.\n      state.dustedWeight = FixedPointMath.Number(state.maximumWeight.n - FixedPointMath.ONE);\n\n      // Calculate how many tokens to distribute in the next step. These are tokens from any tokens which\n      // were over allocated to accounts occupying the tick with the maximum weight.\n      state.distributeAmount = LiquidityMath.calculateProduct(examineTickData.totalBalance, state.dustedWeight);\n\n      // Remove the tokens which were completely exchanged from the total unexchanged balance.\n      state.totalUnexchanged -= examineTickData.totalBalance;\n\n      // Write that all ticks up to and including the examined tick have been satisfied.\n      state.satisfiedTick = state.examineTick;\n\n      // Visit the next active tick. This is equivalent to popping the head of the active ticks queue.\n      state.examineTick = examineTickData.next;\n    }\n\n    // Write the accumulated weight to the next tick.\n    next.accumulatedWeight = state.accumulatedWeight;\n\n    if (cache.totalUnexchanged != state.totalUnexchanged) {\n      totalUnexchanged = state.totalUnexchanged;\n    }\n\n    if (cache.satisfiedTick != state.satisfiedTick) {\n      satisfiedTick = state.satisfiedTick;\n    }\n\n    if (cache.ticksHead != state.examineTick) {\n      ticks.head = state.examineTick;\n    }\n\n    if (state.distributeAmount > 0) {\n      totalBuffered += state.distributeAmount;\n    }\n\n    emit Exchange(msg.sender, amount);\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function getUnexchangedBalance(address owner) external view override returns (uint256 unexchangedBalance) {\n    Account storage account = accounts[owner];\n\n    if (account.occupiedTick <= satisfiedTick) {\n      return 0;\n    }\n\n    unexchangedBalance = account.unexchangedBalance;\n\n    uint256 exchanged = LiquidityMath.calculateProduct(\n      unexchangedBalance,\n      ticks.getWeight(account.occupiedTick, ticks.position)\n    );\n\n    unexchangedBalance -= exchanged;\n\n    return unexchangedBalance;\n  }\n\n  /// @inheritdoc ITransmuterV2\n  function getExchangedBalance(address owner) external view override returns (uint256 exchangedBalance) {\n    return _getExchangedBalance(owner);\n  }\n\n  function getClaimableBalance(address owner) external view override returns (uint256 claimableBalance) {\n    return _normalizeDebtTokensToUnderlying(_getExchangedBalance(owner));\n  }\n\n  /// @dev Updates an account.\n  ///\n  /// @param params The call parameters.\n  function _updateAccount(UpdateAccountParams memory params) internal {\n    Account storage account = accounts[params.owner];\n\n    UpdateAccountCache memory cache = UpdateAccountCache({\n      unexchangedBalance: account.unexchangedBalance,\n      exchangedBalance: account.exchangedBalance,\n      occupiedTick: account.occupiedTick,\n      totalUnexchanged: totalUnexchanged,\n      currentTick: ticks.position\n    });\n\n    UpdateAccountState memory state = UpdateAccountState({\n      unexchangedBalance: cache.unexchangedBalance,\n      exchangedBalance: cache.exchangedBalance,\n      totalUnexchanged: cache.totalUnexchanged\n    });\n\n    // Updating an account is broken down into five steps:\n    // 1). Synchronize the account if it previously occupied a satisfied tick\n    // 2). Update the account balances to account for exchanged tokens, if any\n    // 3). Apply the deltas to the account balances\n    // 4). Update the previously occupied and or current tick's liquidity\n    // 5). Commit changes to the account and global state when needed\n\n    // Step one:\n    // ---------\n    // Check if the tick that the account was occupying previously was satisfied. If it was, we acknowledge\n    // that all of the tokens were exchanged.\n    if (state.unexchangedBalance > 0 && satisfiedTick >= cache.occupiedTick) {\n      state.unexchangedBalance = 0;\n      state.exchangedBalance += cache.unexchangedBalance;\n    }\n\n    // Step Two:\n    // ---------\n    // Calculate how many tokens were exchanged since the last update.\n    if (state.unexchangedBalance > 0) {\n      uint256 exchanged = LiquidityMath.calculateProduct(\n        state.unexchangedBalance,\n        ticks.getWeight(cache.occupiedTick, cache.currentTick)\n      );\n\n      state.totalUnexchanged -= exchanged;\n      state.unexchangedBalance -= exchanged;\n      state.exchangedBalance += exchanged;\n    }\n\n    // Step Three:\n    // -----------\n    // Apply the unexchanged and exchanged deltas to the state.\n    state.totalUnexchanged = LiquidityMath.addDelta(state.totalUnexchanged, params.unexchangedDelta);\n    state.unexchangedBalance = LiquidityMath.addDelta(state.unexchangedBalance, params.unexchangedDelta);\n    state.exchangedBalance = LiquidityMath.addDelta(state.exchangedBalance, params.exchangedDelta);\n\n    // Step Four:\n    // ----------\n    // The following is a truth table relating various values which in combinations specify which logic branches\n    // need to be executed in order to update liquidity in the previously occupied and or current tick.\n    //\n    // Some states are not obtainable and are just discarded by setting all the branches to false.\n    //\n    // | P | C | M | Modify Liquidity | Add Liquidity | Subtract Liquidity |\n    // |---|---|---|------------------|---------------|--------------------|\n    // | F | F | F | F                | F             | F                  |\n    // | F | F | T | F                | F             | F                  |\n    // | F | T | F | F                | T             | F                  |\n    // | F | T | T | F                | T             | F                  |\n    // | T | F | F | F                | F             | T                  |\n    // | T | F | T | F                | F             | T                  |\n    // | T | T | F | T                | F             | F                  |\n    // | T | T | T | F                | T             | T                  |\n    //\n    // | Branch             | Reduction |\n    // |--------------------|-----------|\n    // | Modify Liquidity   | PCM'      |\n    // | Add Liquidity      | P'C + CM  |\n    // | Subtract Liquidity | PC' + PM  |\n\n    bool previouslyActive = cache.unexchangedBalance > 0;\n    bool currentlyActive = state.unexchangedBalance > 0;\n    bool migrate = cache.occupiedTick != cache.currentTick;\n\n    bool modifyLiquidity = previouslyActive && currentlyActive && !migrate;\n\n    if (modifyLiquidity) {\n      Tick.Info storage tick = ticks.get(cache.occupiedTick);\n\n      // Consolidate writes to save gas.\n      uint256 totalBalance = tick.totalBalance;\n      totalBalance -= cache.unexchangedBalance;\n      totalBalance += state.unexchangedBalance;\n      tick.totalBalance = totalBalance;\n    } else {\n      bool addLiquidity = (!previouslyActive && currentlyActive) || (currentlyActive && migrate);\n      bool subLiquidity = (previouslyActive && !currentlyActive) || (previouslyActive && migrate);\n\n      if (addLiquidity) {\n        Tick.Info storage tick = ticks.get(cache.currentTick);\n\n        if (tick.totalBalance == 0) {\n          ticks.addLast(cache.currentTick);\n        }\n\n        tick.totalBalance += state.unexchangedBalance;\n      }\n\n      if (subLiquidity) {\n        Tick.Info storage tick = ticks.get(cache.occupiedTick);\n        tick.totalBalance -= cache.unexchangedBalance;\n\n        if (tick.totalBalance == 0) {\n          ticks.remove(cache.occupiedTick);\n        }\n      }\n    }\n\n    // Step Five:\n    // ----------\n    // Commit the changes to the account.\n    if (cache.unexchangedBalance != state.unexchangedBalance) {\n      account.unexchangedBalance = state.unexchangedBalance;\n    }\n\n    if (cache.exchangedBalance != state.exchangedBalance) {\n      account.exchangedBalance = state.exchangedBalance;\n    }\n\n    if (cache.totalUnexchanged != state.totalUnexchanged) {\n      totalUnexchanged = state.totalUnexchanged;\n    }\n\n    if (cache.occupiedTick != cache.currentTick) {\n      account.occupiedTick = cache.currentTick;\n    }\n  }\n\n  /// @dev Checks the whitelist for msg.sender.\n  ///\n  /// @notice Reverts if msg.sender is not in the whitelist.\n  function _onlyWhitelisted() internal view {\n    // Check if the message sender is an EOA. In the future, this potentially may break. It is important that\n    // functions which rely on the whitelist not be explicitly vulnerable in the situation where this no longer\n    // holds true.\n    if (tx.origin != msg.sender) {\n      // Only check the whitelist for calls from contracts.\n      if (!IWhitelist(whitelist).isWhitelisted(msg.sender)) {\n        revert Unauthorized();\n      }\n    }\n  }\n\n  /// @dev Normalize `amount` of `underlyingToken` to a value which is comparable to units of the debt token.\n  ///\n  /// @param amount          The amount of the debt token.\n  ///\n  /// @return The normalized amount.\n  function _normalizeUnderlyingTokensToDebt(uint256 amount) internal view returns (uint256) {\n    return amount * conversionFactor;\n  }\n\n  /// @dev Normalize `amount` of the debt token to a value which is comparable to units of `underlyingToken`.\n  ///\n  /// @dev This operation will result in truncation of some of the least significant digits of `amount`. This\n  ///      truncation amount will be the least significant N digits where N is the difference in decimals between\n  ///      the debt token and the underlying token.\n  ///\n  /// @param amount          The amount of the debt token.\n  ///\n  /// @return The normalized amount.\n  function _normalizeDebtTokensToUnderlying(uint256 amount) internal view returns (uint256) {\n    return amount / conversionFactor;\n  }\n\n  function _getExchangedBalance(address owner) internal view returns (uint256 exchangedBalance) {\n    Account storage account = accounts[owner];\n\n    if (account.occupiedTick <= satisfiedTick) {\n      exchangedBalance = account.exchangedBalance;\n      exchangedBalance += account.unexchangedBalance;\n      return exchangedBalance;\n    }\n\n    exchangedBalance = account.exchangedBalance;\n\n    uint256 exchanged = LiquidityMath.calculateProduct(\n      account.unexchangedBalance,\n      ticks.getWeight(account.occupiedTick, ticks.position)\n    );\n\n    exchangedBalance += exchanged;\n\n    return exchangedBalance;\n  }\n}\n\n\n",
        "CodeNames": [
            "AlchemicTokenV2Base.sol",
            "CrossChainCanonicalAlchemicTokenV2.sol",
            "CrossChainCanonicalBase.sol",
            "TransmuterV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AlchemicTokenV2Base.sol, CrossChainCanonicalBase.sol, CrossChainCanonicalAlchemicTokenV2.sol, and TransmuterV2.sol",
                "Type": "Storage Slot Collision",
                "Description": "None of the intended upgradeable contracts in the code base contain storage gap.",
                "Repair": "Add appropriate storage gap at the end of upgradeable contracts"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.11;\n\nimport {IllegalState} from \"../../base/Errors.sol\";\n\nimport \"../../interfaces/ITokenAdapter.sol\";\nimport \"../../interfaces/external/yearn/IYearnVaultV2.sol\";\n\nimport \"../../libraries/TokenUtils.sol\";\n\n/// @title  YearnTokenAdapter\n/// @author Alchemix Finance\ncontract YearnTokenAdapter is ITokenAdapter {\n    uint256 private constant MAXIMUM_SLIPPAGE = 10000;\n    string public constant override version = \"2.1.0\";\n\n    address public immutable override token;\n    address public immutable override underlyingToken;\n\n    constructor(address _token, address _underlyingToken) {\n        token = _token;\n        underlyingToken = _underlyingToken;\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function price() external view override returns (uint256) {\n        return IYearnVaultV2(token).pricePerShare();\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function wrap(uint256 amount, address recipient) external override returns (uint256) {\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        TokenUtils.safeApprove(underlyingToken, token, amount);\n\n        return IYearnVaultV2(token).deposit(amount, recipient);\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function unwrap(uint256 amount, address recipient) external override returns (uint256) {\n        TokenUtils.safeTransferFrom(token, msg.sender, address(this), amount);\n\n        uint256 balanceBefore = TokenUtils.safeBalanceOf(token, address(this));\n\n        uint256 amountWithdrawn = IYearnVaultV2(token).withdraw(amount, recipient, MAXIMUM_SLIPPAGE);\n\n        uint256 balanceAfter = TokenUtils.safeBalanceOf(token, address(this));\n\n        // If the Yearn vault did not burn all of the shares then revert. This is critical in mathematical operations\n        // performed by the system because the system always expects that all of the tokens were unwrapped. In Yearn,\n        // this sometimes does not happen in cases where strategies cannot withdraw all of the requested tokens (an\n        // example strategy where this can occur is with Compound and AAVE where funds may not be accessible because\n        // they were lent out).\n        if (balanceBefore - balanceAfter != amount) {\n            revert IllegalState();\n        }\n\n        return amountWithdrawn;\n    }\n}\n\n",
        "CodeNames": [
            "YearnTokenAdapter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "YearnTokenAdapter.sol",
                "Type": "Loss of Funds",
                "Description": "YearnTokenAdapter allows slippage of 100% when withdrawing from the vault which will cause a loss of funds.",
                "Repair": "Allow the user to specify the slippage value themselves"
            },
            {
                "Location": "YearnTokenAdapter.sol#L30-L32",
                "Type": "Incorrect Calculation",
                "Description": "Lido adapter incorrectly calculates the price of the underlying token.",
                "Repair": "Consider approving zero before doing so for the amount."
            },
            {
                "Location": "YearnTokenAdapter.sol#L30-L32",
                "Type": "Approval Race Condition",
                "Description": "YearnTokenAdapter's wrap can become stuck as it uses one step approval for an arbitrary underlying.",
                "Repair": "Approve zero before doing so for the amount."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {Unauthorized, IllegalState, IllegalArgument} from \"./base/Errors.sol\";\n\nimport \"./base/Multicall.sol\";\nimport \"./base/Mutex.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/IERC20Minimal.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/IAlchemicToken.sol\";\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Sets.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./libraries/Limiters.sol\";\n\n/// @title  AlchemistV2\n/// @author Alchemix Finance\ncontract AlchemistV2 is IAlchemistV2, Initializable, Multicall, Mutex {\n    using Limiters for Limiters.LinearGrowthLimiter;\n    using Sets for Sets.AddressSet;\n\n    /// @notice A user account.\n    struct Account {\n        // A signed value which represents the current amount of debt or credit that the account has accrued.\n        // Positive values indicate debt, negative values indicate credit.\n        int256 debt;\n        // The share balances for each yield token.\n        mapping(address => uint256) balances;\n        // The last values recorded for accrued weights for each yield token.\n        mapping(address => uint256) lastAccruedWeights;\n        // The set of yield tokens that the account has deposited into the system.\n        Sets.AddressSet depositedTokens;\n        // The allowances for mints.\n        mapping(address => uint256) mintAllowances;\n        // The allowances for withdrawals.\n        mapping(address => mapping(address => uint256)) withdrawAllowances;\n    }\n\n    /// @notice The number of basis points there are to represent exactly 100%.\n    uint256 public constant BPS = 10000;\n\n    /// @notice The scalar used for conversion of integral numbers to fixed point numbers. Fixed point numbers in this\n    ///         implementation have 18 decimals of resolution, meaning that 1 is represented as 1e18, 0.5 is\n    ///         represented as 5e17, and 2 is represented as 2e18.\n    uint256 public constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @inheritdoc IAlchemistV2Immutables\n    string public constant override version = \"2.2.6\";\n\n    /// @inheritdoc IAlchemistV2Immutables\n    address public override debtToken;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override admin;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override pendingAdmin;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override sentinels;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override keepers;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override transmuter;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override minimumCollateralization;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override protocolFee;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override protocolFeeReceiver;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override whitelist;\n\n    /// @dev A linear growth function that limits the amount of debt-token minted.\n    Limiters.LinearGrowthLimiter private _mintingLimiter;\n\n    // @dev The repay limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _repayLimiters;\n\n    // @dev The liquidation limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _liquidationLimiters;\n\n    /// @dev Accounts mapped by the address that owns them.\n    mapping(address => Account) private _accounts;\n\n    /// @dev Underlying token parameters mapped by token address.\n    mapping(address => UnderlyingTokenParams) private _underlyingTokens;\n\n    /// @dev Yield token parameters mapped by token address.\n    mapping(address => YieldTokenParams) private _yieldTokens;\n\n    /// @dev An iterable set of the underlying tokens that are supported by the system.\n    Sets.AddressSet private _supportedUnderlyingTokens;\n\n    /// @dev An iterable set of the yield tokens that are supported by the system.\n    Sets.AddressSet private _supportedYieldTokens;\n\n    constructor() initializer {}\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToYieldTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToUnderlyingTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedUnderlyingTokens() external view override returns (address[] memory) {\n        return _supportedUnderlyingTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedYieldTokens() external view override returns (address[] memory) {\n        return _supportedYieldTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedUnderlyingToken(address underlyingToken) external view override returns (bool) {\n        return _supportedUnderlyingTokens.contains(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedYieldToken(address yieldToken) external view override returns (bool) {\n        return _supportedYieldTokens.contains(yieldToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function accounts(address owner)\n        external view override\n        returns (\n            int256 debt,\n            address[] memory depositedTokens\n        )\n    {\n        Account storage account = _accounts[owner];\n\n        return (\n            _calculateUnrealizedDebt(owner),\n            account.depositedTokens.values\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function positions(address owner, address yieldToken)\n        external view override\n        returns (\n            uint256 shares,\n            uint256 lastAccruedWeight\n        )\n    {\n        Account storage account = _accounts[owner];\n        return (account.balances[yieldToken], account.lastAccruedWeights[yieldToken]);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function mintAllowance(address owner, address spender)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.mintAllowances[spender];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function withdrawAllowance(address owner, address spender, address yieldToken)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.withdrawAllowances[spender][yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokenParameters(address underlyingToken)\n        external view override\n        returns (UnderlyingTokenParams memory)\n    {\n        return _underlyingTokens[underlyingToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokenParameters(address yieldToken)\n        external view override\n        returns (YieldTokenParams memory)\n    {\n        return _yieldTokens[yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getMintLimitInfo()\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        return (\n            _mintingLimiter.get(),\n            _mintingLimiter.rate,\n            _mintingLimiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getRepayLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getLiquidationLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function initialize(InitializationParams memory params) external initializer {\n        _checkArgument(params.protocolFee <= BPS);\n\n        debtToken                = params.debtToken;\n        admin                    = params.admin;\n        transmuter               = params.transmuter;\n        minimumCollateralization = params.minimumCollateralization;\n        protocolFee              = params.protocolFee;\n        protocolFeeReceiver      = params.protocolFeeReceiver;\n        whitelist                = params.whitelist;\n\n        _mintingLimiter = Limiters.createLinearGrowthLimiter(\n            params.mintingLimitMaximum,\n            params.mintingLimitBlocks,\n            params.mintingLimitMinimum\n        );\n\n        emit AdminUpdated(admin);\n        emit TransmuterUpdated(transmuter);\n        emit MinimumCollateralizationUpdated(minimumCollateralization);\n        emit ProtocolFeeUpdated(protocolFee);\n        emit ProtocolFeeReceiverUpdated(protocolFeeReceiver);\n        emit MintingLimitUpdated(params.mintingLimitMaximum, params.mintingLimitBlocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setPendingAdmin(address value) external override {\n        _onlyAdmin();\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function acceptAdmin() external override {\n        _checkState(pendingAdmin != address(0));\n\n        if (msg.sender != pendingAdmin) {\n            revert Unauthorized();\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setSentinel(address sentinel, bool flag) external override {\n        _onlyAdmin();\n        sentinels[sentinel] = flag;\n        emit SentinelSet(sentinel, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setKeeper(address keeper, bool flag) external override {\n        _onlyAdmin();\n        keepers[keeper] = flag;\n        emit KeeperSet(keeper, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addUnderlyingToken(address underlyingToken, UnderlyingTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkState(!_supportedUnderlyingTokens.contains(underlyingToken));\n\n        uint8 tokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n        uint8 debtTokenDecimals = TokenUtils.expectDecimals(debtToken);\n\n        _checkArgument(tokenDecimals <= debtTokenDecimals);\n\n        _underlyingTokens[underlyingToken] = UnderlyingTokenParams({\n            decimals:         tokenDecimals,\n            conversionFactor: 10**(debtTokenDecimals - tokenDecimals),\n            enabled:          false\n        });\n\n        _repayLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.repayLimitMaximum,\n            config.repayLimitBlocks,\n            config.repayLimitMinimum\n        );\n\n        _liquidationLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.liquidationLimitMaximum,\n            config.liquidationLimitBlocks,\n            config.liquidationLimitMinimum\n        );\n\n        _supportedUnderlyingTokens.add(underlyingToken);\n\n        emit AddUnderlyingToken(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addYieldToken(address yieldToken, YieldTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkArgument(config.maximumLoss <= BPS);\n        _checkArgument(config.creditUnlockBlocks > 0);\n\n        _checkState(!_supportedYieldTokens.contains(yieldToken));\n\n        ITokenAdapter adapter = ITokenAdapter(config.adapter);\n\n        _checkState(yieldToken == adapter.token());\n        _checkSupportedUnderlyingToken(adapter.underlyingToken());\n\n        _yieldTokens[yieldToken] = YieldTokenParams({\n            decimals:              TokenUtils.expectDecimals(yieldToken),\n            underlyingToken:       adapter.underlyingToken(),\n            adapter:               config.adapter,\n            maximumLoss:           config.maximumLoss,\n            maximumExpectedValue:  config.maximumExpectedValue,\n            creditUnlockRate:      FIXED_POINT_SCALAR / config.creditUnlockBlocks,\n            activeBalance:         0,\n            harvestableBalance:    0,\n            totalShares:           0,\n            expectedValue:         0,\n            accruedWeight:         0,\n            pendingCredit:         0,\n            distributedCredit:     0,\n            lastDistributionBlock: 0,\n            enabled:               false\n        });\n\n        _supportedYieldTokens.add(yieldToken);\n\n        TokenUtils.safeApprove(yieldToken, config.adapter, type(uint256).max);\n        TokenUtils.safeApprove(adapter.underlyingToken(), config.adapter, type(uint256).max);\n\n        emit AddYieldToken(yieldToken);\n        emit TokenAdapterUpdated(yieldToken, config.adapter);\n        emit MaximumLossUpdated(yieldToken, config.maximumLoss);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setUnderlyingTokenEnabled(address underlyingToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _underlyingTokens[underlyingToken].enabled = enabled;\n        emit UnderlyingTokenEnabled(underlyingToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setYieldTokenEnabled(address yieldToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].enabled = enabled;\n        emit YieldTokenEnabled(yieldToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureRepayLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _repayLimiters[underlyingToken].update();\n        _repayLimiters[underlyingToken].configure(maximum, blocks);\n        emit RepayLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureLiquidationLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _liquidationLimiters[underlyingToken].update();\n        _liquidationLimiters[underlyingToken].configure(maximum, blocks);\n        emit LiquidationLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTransmuter(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        transmuter = value;\n        emit TransmuterUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMinimumCollateralization(uint256 value) external override {\n        _onlyAdmin();\n        minimumCollateralization = value;\n        emit MinimumCollateralizationUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFee(uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        protocolFee = value;\n        emit ProtocolFeeUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFeeReceiver(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        protocolFeeReceiver = value;\n        emit ProtocolFeeReceiverUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureMintingLimit(uint256 maximum, uint256 rate) external override {\n        _onlyAdmin();\n        _mintingLimiter.update();\n        _mintingLimiter.configure(maximum, rate);\n        emit MintingLimitUpdated(maximum, rate);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureCreditUnlockRate(address yieldToken, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkArgument(blocks > 0);\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].creditUnlockRate = FIXED_POINT_SCALAR / blocks;\n        emit CreditUnlockRateUpdated(yieldToken, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTokenAdapter(address yieldToken, address adapter) external override {\n        _onlyAdmin();\n        _checkState(yieldToken == ITokenAdapter(adapter).token());\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].adapter = adapter;\n        TokenUtils.safeApprove(yieldToken, adapter, type(uint256).max);\n        TokenUtils.safeApprove(ITokenAdapter(adapter).underlyingToken(), adapter, type(uint256).max);\n        emit TokenAdapterUpdated(yieldToken, adapter);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumExpectedValue(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].maximumExpectedValue = value;\n        emit MaximumExpectedValueUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumLoss(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        _checkSupportedYieldToken(yieldToken);\n\n        _yieldTokens[yieldToken].maximumLoss = value;\n\n        emit MaximumLossUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function snap(address yieldToken) external override lock {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n\n        uint256 expectedValue = _convertYieldTokensToUnderlying(yieldToken, _yieldTokens[yieldToken].activeBalance);\n\n        _yieldTokens[yieldToken].expectedValue = expectedValue;\n\n        emit Snap(yieldToken, expectedValue);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function sweepTokens(address rewardToken, uint256 amount) external override lock {\n        _onlyAdmin();\n\n        if (_supportedYieldTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        if (_supportedUnderlyingTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        TokenUtils.safeTransfer(rewardToken, admin, amount);\n\n        emit SweepTokens(rewardToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveMint(address spender, uint256 amount) external override {\n        _onlyWhitelisted();\n        _approveMint(msg.sender, spender, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveWithdraw(address spender, address yieldToken, uint256 shares) external override {\n        _onlyWhitelisted();\n        _checkSupportedYieldToken(yieldToken);\n        _approveWithdraw(msg.sender, spender, yieldToken, shares);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function poke(address owner) external override lock {\n        _onlyWhitelisted();\n        _preemptivelyHarvestDeposited(owner);\n        _distributeUnlockedCreditDeposited(owner);\n        _poke(owner);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Deposit the yield tokens to the recipient.\n        uint256 shares = _deposit(yieldToken, amount, recipient);\n\n        // Transfer tokens from the message sender now that the internal storage updates have been committed.\n        TokenUtils.safeTransferFrom(yieldToken, msg.sender, address(this), amount);\n\n        return shares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function depositUnderlying(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Before depositing, the underlying tokens must be wrapped into yield tokens.\n        uint256 amountYieldTokens = _wrap(yieldToken, amount, minimumAmountOut);\n\n        // Deposit the yield-tokens to the recipient.\n        return _deposit(yieldToken, amountYieldTokens, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdraw(\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Preemptively try and decrease the withdrawal allowance. This will save gas when the allowance is not\n        // sufficient for the withdrawal.\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlying(\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlyingFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mint(uint256 amount, address recipient) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Mint tokens from the message sender's account to the recipient.\n        _mint(msg.sender, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mintFrom(\n        address owner,\n        uint256 amount,\n        address recipient\n    ) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Preemptively try and decrease the minting allowance. This will save gas when the allowance is not sufficient\n        // for the mint.\n        _decreaseMintAllowance(owner, msg.sender, amount);\n\n        // Mint tokens from the owner's account to the recipient.\n        _mint(owner, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function burn(uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, decrease the debt of the recipient by the number of tokens burned.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Limit how much debt can be repaid up to the current amount of debt that the account has. This prevents\n        // situations where the user may be trying to repay their entire debt, but it decreases since they send the\n        // transaction and causes a revert because burning can never decrease the debt below zero.\n        //\n        // Casts here are safe because it is asserted that debt is greater than zero.\n        uint256 credit = amount > uint256(debt) ? uint256(debt) : amount;\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Burn the tokens from the message sender.\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, credit);\n\n        emit Burn(msg.sender, credit, recipient);\n\n        return credit;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function repay(address underlyingToken, uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account and decrease the amount of debt incurred.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the amount of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Determine the maximum amount of underlying tokens that can be repaid.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero so a noop is not possible\n        // beyond this point. Casting the debt to an unsigned integer is also safe because `debt` is greater than zero.\n        uint256 maximumAmount = _normalizeDebtTokensToUnderlying(underlyingToken, uint256(debt));\n\n        // Limit the number of underlying tokens to repay up to the maximum allowed.\n        uint256 actualAmount = amount > maximumAmount ? maximumAmount : amount;\n\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token repay limit has not been breached.\n        uint256 currentRepayLimit = limiter.get();\n        if (actualAmount > currentRepayLimit) {\n          revert RepayLimitExceeded(underlyingToken, actualAmount, currentRepayLimit);\n        }\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, actualAmount);\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Decrease the amount of the underlying token which is globally available to be repaid.\n        limiter.decrease(actualAmount);\n\n        // Transfer the repaid tokens to the transmuter.\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, transmuter, actualAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, actualAmount);\n\n        emit Repay(msg.sender, underlyingToken, actualAmount, recipient);\n\n        return actualAmount;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function liquidate(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(shares > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        _checkSupportedYieldToken(yieldToken);\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n        _checkLoss(yieldToken);\n\n        // Calculate the unrealized debt.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 unrealizedDebt;\n        _checkState((unrealizedDebt = _calculateUnrealizedDebt(msg.sender)) > 0);\n\n        // Determine the maximum amount of shares that can be liquidated from the unrealized debt.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero. Casting the debt to an\n        // unsigned integer is also safe for this reason.\n        uint256 maximumShares = _convertUnderlyingTokensToShares(\n          yieldToken,\n          _normalizeDebtTokensToUnderlying(underlyingToken, uint256(unrealizedDebt))\n        );\n\n        // Limit the number of shares to liquidate up to the maximum allowed.\n        uint256 actualShares = shares > maximumShares ? maximumShares : shares;\n\n        // Unwrap the yield tokens that the shares are worth.\n        uint256 amountYieldTokens      = _convertSharesToYieldTokens(yieldToken, actualShares);\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, amountYieldTokens, address(this), minimumAmountOut);\n\n        // Again, perform another noop check. It is possible that the amount of underlying tokens that were received by\n        // unwrapping the yield tokens was zero because the amount of yield tokens to unwrap was too small.\n        _checkState(amountUnderlyingTokens > 0);\n\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token liquidation limit has not been breached.\n        uint256 liquidationLimit = limiter.get();\n        if (amountUnderlyingTokens > liquidationLimit) {\n          revert LiquidationLimitExceeded(underlyingToken, amountUnderlyingTokens, liquidationLimit);\n        }\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system. This is required for `_sync` to function correctly.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(msg.sender);\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n\n        // Update the message sender's account, proactively burn shares, decrease the amount of debt incurred, and then\n        // decrease the value of the token that the system is expected to hold.\n        _poke(msg.sender, yieldToken);\n        _burnShares(msg.sender, yieldToken, actualShares);\n        _updateDebt(msg.sender, -SafeCast.toInt256(credit));\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Decrease the amount of the underlying token which is globally available to be liquidated.\n        limiter.decrease(amountUnderlyingTokens);\n\n        // Transfer the liquidated tokens to the transmuter.\n        TokenUtils.safeTransfer(underlyingToken, transmuter, amountUnderlyingTokens);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, amountUnderlyingTokens);\n\n        emit Liquidate(msg.sender, yieldToken, underlyingToken, actualShares);\n\n        return actualShares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function donate(address yieldToken, uint256 amount) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount != 0);\n\n        // Distribute any unlocked credit so that the accrued weight is up to date.\n        _distributeUnlockedCredit(yieldToken);\n\n        // Update the message sender's account. This will assure that any credit that was earned is not overridden.\n        _poke(msg.sender);\n\n        uint256 shares = _yieldTokens[yieldToken].totalShares - _accounts[msg.sender].balances[yieldToken];\n\n        _yieldTokens[yieldToken].accruedWeight += amount * FIXED_POINT_SCALAR / shares;\n        _accounts[msg.sender].lastAccruedWeights[yieldToken] = _yieldTokens[yieldToken].accruedWeight;\n\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, amount);\n\n        emit Donate(msg.sender, yieldToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function harvest(address yieldToken, uint256 minimumAmountOut) external override lock {\n        _onlyKeeper();\n        _checkSupportedYieldToken(yieldToken);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        // Buffer any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to be harvested during this call.\n        _preemptivelyHarvest(yieldToken);\n\n        // Load and proactively clear the amount of harvestable tokens so that future calls do not rely on stale data.\n        // Because we cannot call an external unwrap until the amount of harvestable tokens has been calculated,\n        // clearing this data immediately prevents any potential reentrancy attacks which would use stale harvest\n        // buffer values.\n        uint256 harvestableAmount = yieldTokenParams.harvestableBalance;\n        yieldTokenParams.harvestableBalance = 0;\n\n        // Check that the harvest will not be a no-op.\n        _checkState(harvestableAmount != 0);\n\n        address underlyingToken = yieldTokenParams.underlyingToken;\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, harvestableAmount, address(this), minimumAmountOut);\n\n        // Calculate how much of the unwrapped underlying tokens will be allocated for fees and distributed to users.\n        uint256 feeAmount = amountUnderlyingTokens * protocolFee / BPS;\n        uint256 distributeAmount = amountUnderlyingTokens - feeAmount;\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, distributeAmount);\n\n        // Distribute credit to all of the users who hold shares of the yield token.\n        _distributeCredit(yieldToken, credit);\n\n        // Transfer the tokens to the fee receiver and transmuter.\n        TokenUtils.safeTransfer(underlyingToken, protocolFeeReceiver, feeAmount);\n        TokenUtils.safeTransfer(underlyingToken, transmuter, distributeAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, distributeAmount);\n\n        emit Harvest(yieldToken, minimumAmountOut, amountUnderlyingTokens);\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator.\n    ///\n    /// @dev `msg.sender` must be the administrator or this call will revert with an {Unauthorized} error.\n    function _onlyAdmin() internal view {\n        if (msg.sender != admin) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator or a sentinel.\n    ///\n    /// @dev `msg.sender` must be either the administrator or a sentinel or this call will revert with an\n    ///      {Unauthorized} error.\n    function _onlySentinelOrAdmin() internal view {\n        // Check if the message sender is the administrator.\n        if (msg.sender == admin) {\n            return;\n        }\n\n        // Check if the message sender is a sentinel. After this check we can revert since we know that it is neither\n        // the administrator or a sentinel.\n        if (!sentinels[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is a keeper.\n    ///\n    /// @dev `msg.sender` must be a keeper or this call will revert with an {Unauthorized} error.\n    function _onlyKeeper() internal view {\n        if (!keepers[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Preemptively harvests all of the yield tokens that have been deposited into an account.\n    ///\n    /// @param owner The address which owns the account.\n    function _preemptivelyHarvestDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _preemptivelyHarvest(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Preemptively harvests `yieldToken`.\n    ///\n    /// @dev This will earmark yield tokens to be harvested at a future time when the current value of the token is\n    ///      greater than the expected value. The purpose of this function is to synchronize the balance of the yield\n    ///      token which is held by users versus tokens which will be seized by the protocol.\n    ///\n    /// @param yieldToken The address of the yield token to preemptively harvest.\n    function _preemptivelyHarvest(address yieldToken) internal {\n        uint256 activeBalance = _yieldTokens[yieldToken].activeBalance;\n        if (activeBalance == 0) {\n            return;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = _yieldTokens[yieldToken].expectedValue;\n        if (currentValue <= expectedValue) {\n            return;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n            return;\n        }\n        _yieldTokens[yieldToken].activeBalance -= harvestable;\n        _yieldTokens[yieldToken].harvestableBalance += harvestable;\n    }\n\n    /// @dev Checks if a yield token is enabled.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkYieldTokenEnabled(address yieldToken) internal view {\n        if (!_yieldTokens[yieldToken].enabled) {\n          revert TokenDisabled(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an underlying token is enabled.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    function _checkUnderlyingTokenEnabled(address underlyingToken) internal view {\n        if (!_underlyingTokens[underlyingToken].enabled) {\n          revert TokenDisabled(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported yield token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param yieldToken The address to check.\n    function _checkSupportedYieldToken(address yieldToken) internal view {\n        if (!_supportedYieldTokens.contains(yieldToken)) {\n            revert UnsupportedToken(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported underlying token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param underlyingToken The address to check.\n    function _checkSupportedUnderlyingToken(address underlyingToken) internal view {\n        if (!_supportedUnderlyingTokens.contains(underlyingToken)) {\n            revert UnsupportedToken(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if `amount` of debt tokens can be minted.\n    ///\n    /// @dev `amount` must be less than the current minting limit or this call will revert with a\n    ///      {MintingLimitExceeded} error.\n    ///\n    /// @param amount The amount to check.\n    function _checkMintingLimit(uint256 amount) internal view {\n        uint256 limit = _mintingLimiter.get();\n        if (amount > limit) {\n            revert MintingLimitExceeded(amount, limit);\n        }\n    }\n\n    /// @dev Checks if the current loss of `yieldToken` has exceeded its maximum acceptable loss.\n    ///\n    /// @dev The loss that `yieldToken` has incurred must be less than its maximum accepted value or this call will\n    ///      revert with a {LossExceeded} error.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkLoss(address yieldToken) internal view {\n        uint256 loss = _loss(yieldToken);\n        uint256 maximumLoss = _yieldTokens[yieldToken].maximumLoss;\n        if (loss > maximumLoss) {\n            revert LossExceeded(yieldToken, loss, maximumLoss);\n        }\n    }\n\n    /// @dev Deposits `amount` yield tokens into the account of `recipient`.\n    ///\n    /// @dev Emits a {Deposit} event.\n    ///\n    /// @param yieldToken The address of the yield token to deposit.\n    /// @param amount     The amount of yield tokens to deposit.\n    /// @param recipient  The recipient of the yield tokens.\n    ///\n    /// @return The number of shares minted to `recipient`.\n    function _deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) internal returns (uint256) {\n        _checkArgument(amount > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        // Check that the yield token and it's underlying token are enabled. Disabling the yield token and or the\n        // underlying token prevents the system from holding more of the disabled yield token or underlying token.\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Check to assure that the token has not experienced a sudden unexpected loss. This prevents users from being\n        // able to deposit funds and then have them siphoned if the price recovers.\n        _checkLoss(yieldToken);\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to eventually be harvested.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, proactively issue shares for the deposited tokens to the recipient, and then\n        // increase the value of the token that the system is expected to hold.\n        _poke(recipient, yieldToken);\n        uint256 shares = _issueSharesForAmount(recipient, yieldToken, amount);\n        _sync(yieldToken, amount, _uadd);\n\n        // Check that the maximum expected value has not been breached.\n        uint256 maximumExpectedValue = yieldTokenParams.maximumExpectedValue;\n        if (yieldTokenParams.expectedValue > maximumExpectedValue) {\n          revert ExpectedValueExceeded(yieldToken, amount, maximumExpectedValue);\n        }\n\n        emit Deposit(msg.sender, yieldToken, amount, recipient);\n\n        return shares;\n    }\n\n    /// @dev Withdraw `yieldToken` from the account owned by `owner` by burning shares and receiving yield tokens of\n    ///      equivalent value.\n    ///\n    /// @dev Emits a {Withdraw} event.\n    ///\n    /// @param yieldToken The address of the yield token to withdraw.\n    /// @param owner      The address of the account owner to withdraw from.\n    /// @param shares     The number of shares to burn.\n    /// @param recipient  The recipient of the withdrawn shares. This parameter is only used for logging.\n    ///\n    /// @return The amount of yield tokens that the burned shares were exchanged for.\n    function _withdraw(\n        address yieldToken,\n        address owner,\n        uint256 shares,\n        address recipient\n    ) internal returns (uint256) {\n        // Buffers any harvestable yield tokens that the owner of the account has deposited. This will properly\n        // synchronize the balance of all the tokens held by the owner so that the validation check properly\n        // computes the total value of the tokens held by the owner.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n\n        // Update the owner's account, burn shares from the owner's account, and then decrease the value of the token\n        // that the system is expected to hold.\n        _poke(owner);\n        _burnShares(owner, yieldToken, shares);\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Valid the owner's account to assure that the collateralization invariant is still held.\n        _validate(owner);\n\n        emit Withdraw(owner, yieldToken, shares, recipient);\n\n        return amountYieldTokens;\n    }\n\n    /// @dev Mints debt tokens to `recipient` using the account owned by `owner`.\n    ///\n    /// @dev Emits a {Mint} event.\n    ///\n    /// @param owner     The owner of the account to mint from.\n    /// @param amount    The amount to mint.\n    /// @param recipient The recipient of the minted debt tokens.\n    function _mint(address owner, uint256 amount, address recipient) internal {\n        // Check that the system will allow for the specified amount to be minted.\n        _checkMintingLimit(amount);\n\n        // Preemptively harvest all tokens that the user has deposited into the system. This allows the debt to be\n        // properly calculated before the account is validated.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        // Update the owner's account, increase their debt by the amount of tokens to mint, and then finally validate\n        // their account to assure that the collateralization invariant is still held.\n        _poke(owner);\n        _updateDebt(owner, SafeCast.toInt256(amount));\n        _validate(owner);\n\n        // Decrease the global amount of mintable debt tokens.\n        _mintingLimiter.decrease(amount);\n\n        // Mint the debt tokens to the recipient.\n        TokenUtils.safeMint(debtToken, recipient, amount);\n\n        emit Mint(owner, amount, recipient);\n    }\n\n    /// @dev Synchronizes the active balance and expected value of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount to add or subtract from the debt.\n    /// @param operation  The mathematical operation to perform for the update. Either one of {_uadd} or {_usub}.\n    function _sync(\n        address yieldToken,\n        uint256 amount,\n        function(uint256, uint256) internal pure returns (uint256) operation\n    ) internal {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, amount);\n        uint256 updatedActiveBalance   = operation(yieldTokenParams.activeBalance, amount);\n        uint256 updatedExpectedValue   = operation(yieldTokenParams.expectedValue, amountUnderlyingTokens);\n\n        _yieldTokens[yieldToken].activeBalance = updatedActiveBalance;\n        _yieldTokens[yieldToken].expectedValue = updatedExpectedValue;\n    }\n\n    /// @dev Gets the amount of loss that `yieldToken` has incurred measured in basis points. When the expected\n    ///      underlying value is less than the actual value, this will return zero.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The loss in basis points.\n    function _loss(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, yieldTokenParams.activeBalance);\n        uint256 expectedUnderlyingValue = yieldTokenParams.expectedValue;\n\n        return expectedUnderlyingValue > amountUnderlyingTokens\n            ? ((expectedUnderlyingValue - amountUnderlyingTokens) * BPS) / expectedUnderlyingValue\n            : 0;\n    }\n\n    /// @dev Distributes `amount` credit to all depositors of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token to distribute credit for.\n    /// @param amount     The amount of credit to distribute in debt tokens.\n    function _distributeCredit(address yieldToken, uint256 amount) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit     = yieldTokenParams.pendingCredit;\n        uint256 distributedCredit = yieldTokenParams.distributedCredit;\n        uint256 unlockedCredit    = _calculateUnlockedCredit(yieldToken);\n        uint256 lockedCredit      = pendingCredit - (distributedCredit + unlockedCredit);\n\n        // Distribute any unlocked credit before overriding it.\n        if (unlockedCredit > 0) {\n            yieldTokenParams.accruedWeight += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        }\n\n        yieldTokenParams.pendingCredit         = amount + lockedCredit;\n        yieldTokenParams.distributedCredit     = 0;\n        yieldTokenParams.lastDistributionBlock = block.number;\n    }\n\n    /// @dev Distributes unlocked credit for all of the yield tokens that have been deposited into the account owned\n    ///      by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _distributeUnlockedCreditDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _distributeUnlockedCredit(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Distributes unlocked credit of `yieldToken` to all depositors.\n    ///\n    /// @param yieldToken The address of the yield token to distribute unlocked credit for.\n    function _distributeUnlockedCredit(address yieldToken) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);\n        if (unlockedCredit == 0) {\n            return;\n        }\n\n        yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        yieldTokenParams.distributedCredit += unlockedCredit;\n    }\n\n    /// @dev Wraps `amount` of an underlying token into its `yieldToken`.\n    ///\n    /// @param yieldToken       The address of the yield token to wrap the underlying tokens into.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of yield tokens that are expected to be received from the operation.\n    ///\n    /// @return The amount of yield tokens that resulted from the operation.\n    function _wrap(\n        address yieldToken,\n        uint256 amount,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        uint256 wrappedShares = adapter.wrap(amount, address(this));\n        if (wrappedShares < minimumAmountOut) {\n            revert SlippageExceeded(wrappedShares, minimumAmountOut);\n        }\n\n        return wrappedShares;\n    }\n\n    /// @dev Unwraps `amount` of `yieldToken` into its underlying token.\n    ///\n    /// @param yieldToken       The address of the yield token to unwrap.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be received from the\n    ///                         operation.\n    ///\n    /// @return The amount of underlying tokens that resulted from the operation.\n    function _unwrap(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        ITokenAdapter adapter = ITokenAdapter(_yieldTokens[yieldToken].adapter);\n        uint256 amountUnwrapped = adapter.unwrap(amount, recipient);\n        if (amountUnwrapped < minimumAmountOut) {\n            revert SlippageExceeded(amountUnwrapped, minimumAmountOut);\n        }\n        return amountUnwrapped;\n    }\n\n    /// @dev Synchronizes the state for all of the tokens deposited in the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _poke(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _poke(owner, depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Synchronizes the state of `yieldToken` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param yieldToken The address of the yield token to synchronize the state for.\n    function _poke(address owner, address yieldToken) internal {\n        Account storage account = _accounts[owner];\n\n        uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n        uint256 lastAccruedWeight    = account.lastAccruedWeights[yieldToken];\n\n        if (currentAccruedWeight == lastAccruedWeight) {\n            return;\n        }\n\n        uint256 balance          = account.balances[yieldToken];\n        uint256 unrealizedCredit = (currentAccruedWeight - lastAccruedWeight) * balance / FIXED_POINT_SCALAR;\n\n        account.debt                           -= SafeCast.toInt256(unrealizedCredit);\n        account.lastAccruedWeights[yieldToken]  = currentAccruedWeight;\n    }\n\n    /// @dev Increases the debt by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner     The address of the account owner.\n    /// @param amount    The amount to increase the debt by.\n    function _updateDebt(address owner, int256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.debt += amount;\n    }\n\n    /// @dev Set the mint allowance for `spender` to `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to set the mint allowance to.\n    function _approveMint(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] = amount;\n        emit ApproveMint(owner, spender, amount);\n    }\n\n    /// @dev Decrease the mint allowance for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to decrease the mint allowance by.\n    function _decreaseMintAllowance(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] -= amount;\n    }\n\n    /// @dev Set the withdraw allowance of `yieldToken` for `spender` to `shares` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to set the withdraw allowance for.\n    /// @param shares     The amount of shares to set the withdraw allowance to.\n    function _approveWithdraw(address owner, address spender, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] = shares;\n        emit ApproveWithdraw(owner, spender, yieldToken, shares);\n    }\n\n    /// @dev Decrease the withdraw allowance of `yieldToken` for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to decrease the withdraw allowance for.\n    /// @param amount     The amount of shares to decrease the withdraw allowance by.\n    function _decreaseWithdrawAllowance(address owner, address spender, address yieldToken, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] -= amount;\n    }\n\n    /// @dev Checks that the account owned by `owner` is properly collateralized.\n    ///\n    /// @dev If the account is undercollateralized then this will revert with an {Undercollateralized} error.\n    ///\n    /// @param owner The address of the account owner.\n    function _validate(address owner) internal view {\n        int256 debt = _accounts[owner].debt;\n        if (debt <= 0) {\n            return;\n        }\n\n        uint256 collateralization = _totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n\n        if (collateralization < minimumCollateralization) {\n            revert Undercollateralized();\n        }\n    }\n\n    /// @dev Gets the total value of the deposit collateral measured in debt tokens of the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The total value.\n    function _totalValue(address owner) internal view returns (uint256) {\n        uint256 totalValue = 0;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken             = depositedTokens.values[i];\n            address underlyingToken        = _yieldTokens[yieldToken].underlyingToken;\n            uint256 shares                 = _accounts[owner].balances[yieldToken];\n            uint256 amountUnderlyingTokens = _convertSharesToUnderlyingTokens(yieldToken, shares);\n\n            totalValue += _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n        }\n\n        return totalValue;\n    }\n\n    /// @dev Issues shares of `yieldToken` for `amount` of its underlying token to `recipient`.\n    ///\n    /// IMPORTANT: `amount` must never be 0.\n    ///\n    /// @param recipient  The address of the recipient.\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of the underlying token.\n    ///\n    /// @return The amount of shares issued to `recipient`.\n    function _issueSharesForAmount(\n        address recipient,\n        address yieldToken,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 shares = _convertYieldTokensToShares(yieldToken, amount);\n\n        if (_accounts[recipient].balances[yieldToken] == 0) {\n          _accounts[recipient].depositedTokens.add(yieldToken);\n        }\n\n        _accounts[recipient].balances[yieldToken] += shares;\n        _yieldTokens[yieldToken].totalShares += shares;\n\n        return shares;\n    }\n\n    /// @dev Burns `share` shares of `yieldToken` from the account owned by `owner`.\n    ///\n    /// @param owner      The address of the owner.\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares to burn.\n    function _burnShares(address owner, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n\n        account.balances[yieldToken] -= shares;\n        _yieldTokens[yieldToken].totalShares -= shares;\n\n        if (account.balances[yieldToken] == 0) {\n            account.depositedTokens.remove(yieldToken);\n        }\n    }\n\n    /// @dev Gets the amount of debt that the account owned by `owner` will have after an update occurs.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The amount of debt that the account owned by `owner` will have after an update.\n    function _calculateUnrealizedDebt(address owner) internal view returns (int256) {\n        int256 debt = _accounts[owner].debt;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken = depositedTokens.values[i];\n\n            uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n            uint256 lastAccruedWeight    = _accounts[owner].lastAccruedWeights[yieldToken];\n            uint256 unlockedCredit       = _calculateUnlockedCredit(yieldToken);\n\n            currentAccruedWeight += unlockedCredit > 0\n                ? unlockedCredit * FIXED_POINT_SCALAR / _yieldTokens[yieldToken].totalShares\n                : 0;\n\n            if (currentAccruedWeight == lastAccruedWeight) {\n                continue;\n            }\n\n            uint256 balance = _accounts[owner].balances[yieldToken];\n            uint256 unrealizedCredit = ((currentAccruedWeight - lastAccruedWeight) * balance) / FIXED_POINT_SCALAR;\n\n            debt -= SafeCast.toInt256(unrealizedCredit);\n        }\n\n        return debt;\n    }\n\n    /// @dev Gets the virtual active balance of `yieldToken`.\n    ///\n    /// @dev The virtual active balance is the active balance minus any harvestable tokens which have yet to be realized.\n    ///\n    /// @param yieldToken The address of the yield token to get the virtual active balance of.\n    ///\n    /// @return The virtual active balance.\n    function _calculateUnrealizedActiveBalance(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 activeBalance = yieldTokenParams.activeBalance;\n        if (activeBalance == 0) {\n          return activeBalance;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = yieldTokenParams.expectedValue;\n        if (currentValue <= expectedValue) {\n          return activeBalance;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n          return activeBalance;\n        }\n\n        return activeBalance - harvestable;\n    }\n\n    /// @dev Calculates the amount of unlocked credit for `yieldToken` that is available for distribution.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The amount of unlocked credit available.\n    function _calculateUnlockedCredit(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit = yieldTokenParams.pendingCredit;\n        if (pendingCredit == 0) {\n            return 0;\n        }\n\n        uint256 creditUnlockRate      = yieldTokenParams.creditUnlockRate;\n        uint256 distributedCredit     = yieldTokenParams.distributedCredit;\n        uint256 lastDistributionBlock = yieldTokenParams.lastDistributionBlock;\n\n        uint256 percentUnlocked = (block.number - lastDistributionBlock) * creditUnlockRate;\n\n        return percentUnlocked < FIXED_POINT_SCALAR\n            ? (pendingCredit * percentUnlocked / FIXED_POINT_SCALAR) - distributedCredit\n            : pendingCredit - distributedCredit;\n    }\n\n    /// @dev Gets the amount of shares that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The number of shares.\n    function _convertYieldTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        if (_yieldTokens[yieldToken].totalShares == 0) {\n            return amount;\n        }\n        return amount * _yieldTokens[yieldToken].totalShares / _calculateUnrealizedActiveBalance(yieldToken);\n    }\n\n    /// @dev Gets the amount of yield tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertSharesToYieldTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 totalShares = _yieldTokens[yieldToken].totalShares;\n        if (totalShares == 0) {\n          return shares;\n        }\n        return (shares * _calculateUnrealizedActiveBalance(yieldToken)) / totalShares;\n    }\n\n    /// @dev Gets the amount of underlying tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertSharesToUnderlyingTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n        return _convertYieldTokensToUnderlying(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Gets the amount of an underlying token that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertYieldTokensToUnderlying(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * adapter.price() / 10**yieldTokenParams.decimals;\n    }\n\n    /// @dev Gets the amount of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertUnderlyingTokensToYield(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * 10**yieldTokenParams.decimals / adapter.price();\n    }\n\n    /// @dev Gets the amount of shares of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of shares.\n    function _convertUnderlyingTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertUnderlyingTokensToYield(yieldToken, amount);\n        return _convertYieldTokensToShares(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Normalize `amount` of `underlyingToken` to a value which is comparable to units of the debt token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeUnderlyingTokensToDebt(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount * _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Normalize `amount` of the debt token to a value which is comparable to units of `underlyingToken`.\n    ///\n    /// @dev This operation will result in truncation of some of the least significant digits of `amount`. This\n    ///      truncation amount will be the least significant N digits where N is the difference in decimals between\n    ///      the debt token and the underlying token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeDebtTokensToUnderlying(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount / _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Checks the whitelist for msg.sender.\n    ///\n    /// Reverts if msg.sender is not in the whitelist.\n    function _onlyWhitelisted() internal view {\n        // Check if the message sender is an EOA. In the future, this potentially may break. It is important that functions\n        // which rely on the whitelist not be explicitly vulnerable in the situation where this no longer holds true.\n        if (tx.origin == msg.sender) {\n          return;\n        }\n\n        // Only check the whitelist for calls from contracts.\n        if (!IWhitelist(whitelist).isWhitelisted(msg.sender)) {\n          revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalArgument} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkArgument(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalArgument();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalState} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkState(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalState();\n        }\n    }\n\n    /// @dev Adds two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z The result.\n    function _uadd(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x + y; }\n\n    /// @dev Subtracts two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z the result.\n    function _usub(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x - y; }\n}\n\n\npragma solidity ^0.8.11;\n\nimport {IllegalArgument} from \"../base/Errors.sol\";\n\n/// @title  Functions\n/// @author Alchemix Finance\nlibrary Limiters {\n    using Limiters for LinearGrowthLimiter;\n\n    /// @dev A maximum cooldown to avoid malicious governance bricking the contract.\n    /// @dev 1 day @ 12 sec / block\n    uint256 constant public MAX_COOLDOWN_BLOCKS = 7200;\n\n    /// @dev The scalar used to convert integral types to fixed point numbers.\n    uint256 constant public FIXED_POINT_SCALAR = 1e18;\n\n    /// @dev The configuration and state of a linear growth function (LGF).\n    struct LinearGrowthLimiter {\n        uint256 maximum;        /// The maximum limit of the function.\n        uint256 rate;           /// The rate at which the function increases back to its maximum.\n        uint256 lastValue;      /// The most recently saved value of the function.\n        uint256 lastBlock;      /// The block that `lastValue` was recorded.\n        uint256 minLimit;       /// A minimum limit to avoid malicious governance bricking the contract\n    }\n\n    /// @dev Instantiates a new linear growth function.\n    ///\n    /// @param maximum The maximum value for the LGF.\n    /// @param blocks  The number of blocks that determins the rate of the LGF.\n    ///\n    /// @return The LGF struct.\n    function createLinearGrowthLimiter(uint256 maximum, uint256 blocks, uint256 _minLimit) internal view returns (LinearGrowthLimiter memory) {\n        if (blocks > MAX_COOLDOWN_BLOCKS) {\n            revert IllegalArgument();\n        }\n\n        if (maximum < _minLimit) {\n            revert IllegalArgument();\n        }\n\n        return LinearGrowthLimiter({\n            maximum: maximum,\n            rate: maximum * FIXED_POINT_SCALAR / blocks,\n            lastValue: maximum,\n            lastBlock: block.number,\n            minLimit: _minLimit\n        });\n    }\n\n    /// @dev Configure an LGF.\n    ///\n    /// @param self    The LGF to configure.\n    /// @param maximum The maximum value of the LFG.\n    /// @param blocks  The number of recovery blocks of the LGF.\n    function configure(LinearGrowthLimiter storage self, uint256 maximum, uint256 blocks) internal {\n        if (blocks > MAX_COOLDOWN_BLOCKS) {\n            revert IllegalArgument();\n        }\n\n        if (maximum < self.minLimit) {\n            revert IllegalArgument();\n        }\n\n        if (self.lastValue > maximum) {\n            self.lastValue = maximum;\n        }\n\n        self.maximum = maximum;\n        self.rate = maximum * FIXED_POINT_SCALAR / blocks;\n    }\n\n    /// @dev Updates the state of an LGF by updating `lastValue` and `lastBlock`.\n    ///\n    /// @param self the LGF to update.\n    function update(LinearGrowthLimiter storage self) internal {\n        self.lastValue = self.get();\n        self.lastBlock = block.number;\n    }\n\n    /// @dev Decrease the value of the linear growth limiter.\n    ///\n    /// @param self   The linear growth limiter.\n    /// @param amount The amount to decrease `lastValue`.\n    function decrease(LinearGrowthLimiter storage self, uint256 amount) internal {\n        uint256 value = self.get();\n        self.lastValue = value - amount;\n        self.lastBlock = block.number;\n    }\n\n    /// @dev Get the current value of the linear growth limiter.\n    ///\n    /// @return The current value.\n    function get(LinearGrowthLimiter storage self) internal view returns (uint256) {\n        uint256 elapsed = block.number - self.lastBlock;\n        if (elapsed == 0) {\n            return self.lastValue;\n        }\n        uint256 delta = elapsed * self.rate / FIXED_POINT_SCALAR;\n        uint256 value = self.lastValue + delta;\n        return value > self.maximum ? self.maximum : value;\n    }\n}\n\n",
        "CodeNames": [
            "AlchemistV2.sol",
            "Limiters.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AlchemistV2.sol#L676-L683, AlchemistV2.sol#L704, Limiters.sol#L84",
                "Type": "Smart Contract Griefing",
                "Description": "An attacker can repeatedly call mint followed by burn after depositing some collateral with deposit. If this is appropriately sized and timed, it can cause the mint call to fail for another user due to the check that is called during mint.",
                "Repair": "Add an additional method to the Limiters library that can increment the mint limit and call it during a burn call in the AlchemistV2 contract."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\nimport {IAlchemistV2} from \"./interfaces/IAlchemistV2.sol\";\nimport {IAaveFlashLoanReceiver} from \"./interfaces/IAaveFlashLoanReceiver.sol\";\nimport {IAaveLendingPool} from \"./interfaces/IAaveLendingPool.sol\";\nimport {IWhitelist} from \"./interfaces/IWhitelist.sol\";\n\n/// @title A zapper for leveraged deposits into the Alchemist\nabstract contract AutoleverageBase is IAaveFlashLoanReceiver {\n\n    IWhitelist constant whitelist = IWhitelist(0xA3dfCcbad1333DC69997Da28C961FF8B2879e653);\n    IAaveLendingPool constant flashLender = IAaveLendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n\n    struct Details {\n        address pool;\n        int128 poolInputIndex;\n        int128 poolOutputIndex;\n        address alchemist;\n        address yieldToken;\n        address recipient;\n        uint256 targetDebt;\n    }\n\n    /// @notice When the msg.sender is not whitelisted\n    error Unauthorized(address sender);\n\n    /// @notice When we're passed invalid parameters\n    error IllegalArgument(string reason);\n    \n    /// @notice When the yieldToken has no underlyingToken in the alchemist\n    error UnsupportedYieldToken(address yieldToken);\n\n    /// @notice When the collateral is insufficient to mint targetDebt\n    error MintFailure();\n\n    /// @notice When the helper contract ends up with too few or too many tokens\n    error InexactTokens(uint256 currentBalance, uint256 repayAmount);\n\n    /// @notice Either convert received eth to weth, or transfer ERC20 from the msg.sender to this contract\n    /// @param underlyingToken The ERC20 desired to transfer\n    /// @param collateralInitial The amount of tokens taken from the user\n    function _transferTokensToSelf(address underlyingToken, uint256 collateralInitial) internal virtual;\n\n    /// @notice Convert received eth to weth, or do nothing\n    /// @param amountOut The amount received from the curve swap\n    function _maybeConvertCurveOutput(uint256 amountOut) internal virtual;\n\n    /// @notice Swap on curve using the supplied params\n    /// @param poolAddress Curve pool address\n    /// @param debtToken The alAsset debt token address\n    /// @param i Curve swap param\n    /// @param j Curve swap param\n    /// @param minAmountOut Minimum amount received from swap\n    /// @return amountOut The actual amount received from swap\n    function _curveSwap(address poolAddress, address debtToken, int128 i, int128 j, uint256 minAmountOut) internal virtual returns (uint256 amountOut);\n\n    /// @notice Approve a contract to spend tokens\n    function approve(address token, address spender) internal {\n        IERC20(token).approve(spender, type(uint256).max);\n    }\n\n    /// @notice Transfer tokens from msg.sender here, then call flashloan which calls callback\n    /// @dev Must have targetDebt > collateralTotal - collateralInitial, otherwise flashloan payback will fail\n    /// @param pool The address of the curve pool to swap on\n    /// @param poolInputIndex The `i` param for the curve swap\n    /// @param poolOutputIndex The `j` param for the curve swap\n    /// @param alchemist The alchemist to deposit and mint from\n    /// @param yieldToken The yieldToken to convert deposits into\n    /// @param collateralInitial The amount of tokens that will be taken from the user\n    /// @param collateralTotal The amount of tokens that will be deposited as collateral for the user\n    /// @param targetDebt The amount of debt that the user will incur\n    function autoleverage(\n        address pool,\n        int128 poolInputIndex,\n        int128 poolOutputIndex,\n        address alchemist,\n        address yieldToken,\n        uint256 collateralInitial,\n        uint256 collateralTotal,\n        uint256 targetDebt\n    ) external payable {\n        // Gate on EOA or whitelisted\n        if (!(tx.origin == msg.sender || whitelist.isWhitelisted(msg.sender))) revert Unauthorized(msg.sender);\n\n        // Get underlying token from alchemist\n        address underlyingToken = IAlchemistV2(alchemist).getYieldTokenParameters(yieldToken).underlyingToken;\n        if (underlyingToken == address(0)) revert UnsupportedYieldToken(yieldToken);\n\n        _transferTokensToSelf(underlyingToken, collateralInitial);\n\n        // Take out flashloan\n        address[] memory assets = new address[](1);\n        assets[0] = underlyingToken;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = collateralTotal - collateralInitial;\n        uint256[] memory modes = new uint256[](1);\n        modes[0] = 0;\n\n        bytes memory params = abi.encode(Details({\n            pool: pool,\n            poolInputIndex: poolInputIndex,\n            poolOutputIndex: poolOutputIndex,\n            alchemist: alchemist,\n            yieldToken: yieldToken,\n            recipient: msg.sender,\n            targetDebt: targetDebt\n        }));\n\n        flashLender.flashLoan(\n            address(this),\n            assets,\n            amounts,\n            modes,\n            address(0), // onBehalfOf, not used here\n            params, // params, passed to callback func to decode as struct\n            0 // referralCode\n        );\n    }\n\n    /// @notice Flashloan callback receiver, will be called by IAaveLendingPool.flashloan()\n    /// @dev Never call this function directly\n    /// @param assets An array of length 1, pointing to the ERC20 received in the flashloan\n    /// @param amounts An array of length 1, with the ERC20 amount received in the flashloan\n    /// @param premiums An array of length 1, with the flashloan fee. We will pay back amounts[0] + premiums[0] to the flashloan provider\n    /// @param initiator Points to who initiated the flashloan\n    /// @param params ABI-encoded `Details` struct containing many details about desired functionality\n    /// @return success Always true unless reverts, required by Aave flashloan\n    function executeOperation(\n        address[] calldata assets,\n        uint[] calldata amounts,\n        uint[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external returns (bool) {\n        // Only called by flashLender\n        if (msg.sender != address(flashLender)) revert Unauthorized(msg.sender);\n        if (initiator != address(this)) revert IllegalArgument(\"flashloan initiator must be self\");\n        Details memory details = abi.decode(params, (Details));\n        uint256 repayAmount = amounts[0] + premiums[0];\n\n        uint256 collateralBalance = IERC20(assets[0]).balanceOf(address(this));\n\n        // Deposit into recipient's account\n        approve(assets[0], details.alchemist);\n        IAlchemistV2(details.alchemist).depositUnderlying(details.yieldToken, collateralBalance, details.recipient, 0);\n\n        // Mint from recipient's account\n        try IAlchemistV2(details.alchemist).mintFrom(details.recipient, details.targetDebt, address(this)) {\n\n        } catch {\n            revert MintFailure();\n        }\n\n        {\n            address debtToken = IAlchemistV2(details.alchemist).debtToken();\n            uint256 amountOut = _curveSwap(\n                details.pool, \n                debtToken, \n                details.poolInputIndex, \n                details.poolOutputIndex, \n                repayAmount\n            );\n\n            _maybeConvertCurveOutput(amountOut);\n\n\n            // Deposit excess assets into the alchemist on behalf of the user\n            uint256 excessCollateral = amountOut - repayAmount;\n            if (excessCollateral > 0) {\n                IAlchemistV2(details.alchemist).depositUnderlying(details.yieldToken, excessCollateral, details.recipient, 0);\n            }\n        }\n\n        // Approve the LendingPool contract allowance to *pull* the owed amount\n        approve(assets[0], address(flashLender));\n        uint256 balance = IERC20(assets[0]).balanceOf(address(this));\n        if (balance != repayAmount) {\n            revert InexactTokens(balance, repayAmount);\n        }\n\n        return true;\n    }\n\n}\n\n",
        "CodeNames": [
            "AutoleverageBase.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AutoleverageBase.sol",
                "Type": "Approval control",
                "Description": "Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.",
                "Repair": "Update the approve() function to handle tokens like USDT where the approval is not set to 0 initially"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\n\nimport {IERC3156FlashBorrower} from \"./interfaces/IERC3156FlashBorrower.sol\";\nimport {IERC3156FlashLender} from \"./interfaces/IERC3156FlashLender.sol\";\n\n/// @title  AlchemicTokenV2\n/// @author Alchemix Finance\n///\n/// @notice This is the contract for version two alchemic tokens.\n/// @notice Initially, the contract deployer is given both the admin and minter role. This allows them to pre-mine\n///         tokens, transfer admin to a timelock contract, and lastly, grant the staking pools the minter role. After\n///         this is done, the deployer must revoke their admin role and minter role.\ncontract AlchemicTokenV2Base is ERC20Upgradeable, AccessControlUpgradeable, IERC3156FlashLender, ReentrancyGuardUpgradeable {\n  /// @notice The identifier of the role which maintains other roles.\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN\");\n\n  /// @notice The identifier of the role which allows accounts to mint tokens.\n  bytes32 public constant SENTINEL_ROLE = keccak256(\"SENTINEL\");\n\n  /// @notice The expected return value from a flash mint receiver\n  bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n  /// @notice The maximum number of basis points needed to represent 100%.\n  uint256 public constant BPS = 10000;\n\n  /// @notice A set of addresses which are whitelisted for minting new tokens.\n  mapping(address => bool) public whitelisted;\n\n  /// @notice A set of addresses which are paused from minting new tokens.\n  mapping(address => bool) public paused;\n\n  /// @notice The amount that each address is permitted to mint.\n  mapping(address => uint256) public mintCeiling;\n\n  /// @notice The amount of tokens that each address has already minted.\n  mapping(address => uint256) public totalMinted;\n\n  /// @notice Fee for flash minting\n  uint256 public flashMintFee;\n\n  /// @notice Max flash mint amount\n  uint256 public maxFlashLoanAmount;\n\n  /// @notice An event which is emitted when a minter is paused from minting.\n  ///\n  /// @param minter The address of the minter which was paused.\n  /// @param state  A flag indicating if the alchemist is paused or unpaused.\n  event Paused(address minter, bool state);\n\n  /// @notice An event which is emitted when the flash mint fee is updated.\n  ///\n  /// @param fee The new flash mint fee.\n  event SetFlashMintFee(uint256 fee);\n\n  function __AlchemicTokenV2Base_init() internal {\n    _setupRole(ADMIN_ROLE, msg.sender);\n    _setupRole(SENTINEL_ROLE, msg.sender);\n    _setRoleAdmin(SENTINEL_ROLE, ADMIN_ROLE);\n    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n  }\n\n  /// @dev A modifier which checks that the caller has the admin role.\n  modifier onlyAdmin() {\n    if (!hasRole(ADMIN_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks that the caller has the sentinel role.\n  modifier onlySentinel() {\n    if(!hasRole(SENTINEL_ROLE, msg.sender)) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @dev A modifier which checks if whitelisted for minting.\n  modifier onlyWhitelisted() {\n    if(!whitelisted[msg.sender]) {\n      revert Unauthorized();\n    }\n    _;\n  }\n\n  /// @notice Sets the flash minting fee.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param newFee The new flash mint fee.\n  function setFlashFee(uint256 newFee) external onlyAdmin {\n    flashMintFee = newFee;\n    emit SetFlashMintFee(flashMintFee);\n  }\n\n  /// @notice Mints tokens to `a recipient.`\n  ///\n  /// @notice This function reverts if `msg.sender` is not whitelisted.\n  /// @notice This function reverts if `msg.sender` is paused.\n  /// @notice This function reverts if `msg.sender` has exceeded their mintable ceiling.\n  ///\n  /// @param recipient The address to mint the tokens to.\n  /// @param amount    The amount of tokens to mint.\n  function mint(address recipient, uint256 amount) external onlyWhitelisted {\n    if (paused[msg.sender]) {\n      revert IllegalState();\n    }\n\n    uint256 total = amount + totalMinted[msg.sender];\n    if (total > mintCeiling[msg.sender]) {\n      revert IllegalState();\n    }\n\n    totalMinted[msg.sender] = total;\n\n    _mint(recipient, amount);\n  }\n\n  /// @notice Sets `minter` as whitelisted to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter The account to permit to mint.\n  /// @param state  A flag indicating if the minter should be able to mint.\n  function setWhitelist(address minter, bool state) external onlyAdmin {\n    whitelisted[minter] = state;\n  }\n\n  /// @notice Sets `sentinel` as a sentinel.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param sentinel The address to set as a sentinel.\n  function setSentinel(address sentinel) external onlyAdmin {\n    _setupRole(SENTINEL_ROLE, sentinel);\n  }\n\n  /// @notice Sets the maximum amount of tokens that `minter` is allowed to mint.\n  ///\n  /// @notice This function reverts if `msg.sender` is not an admin.\n  ///\n  /// @param minter  The address of the minter.\n  /// @param maximum The maximum amount of tokens that the minter is allowed to mint.\n  function setCeiling(address minter, uint256 maximum) external onlyAdmin {\n    mintCeiling[minter] = maximum;\n  }\n\n  /// @notice Pauses `minter` from minting tokens.\n  ///\n  /// @notice This function reverts if `msg.sender` is not a sentinel.\n  ///\n  /// @param minter The address to set as paused or unpaused.\n  /// @param state  A flag indicating if the minter should be paused or unpaused.\n  function pauseMinter(address minter, bool state) external onlySentinel {\n    paused[minter] = state;\n    emit Paused(minter, state);\n  }\n\n  /// @notice Burns `amount` tokens from `msg.sender`.\n  ///\n  /// @param amount The amount of tokens to be burned.\n  function burn(uint256 amount) external {\n    _burn(msg.sender, amount);\n  }\n\n  /// @dev Destroys `amount` tokens from `account`, deducting from the caller's allowance.\n  ///\n  /// @param account The address the burn tokens from.\n  /// @param amount  The amount of tokens to burn.\n  function burnFrom(address account, uint256 amount) external {\n    uint256 newAllowance = allowance(account, msg.sender) - amount;\n\n    _approve(account, msg.sender, newAllowance);\n    _burn(account, amount);\n  }\n\n  /// @notice Lowers the number of tokens which the `msg.sender` has minted.\n  ///\n  /// @notice This reverts if the `msg.sender` is not whitelisted.\n  ///\n  /// @param amount The amount to lower the minted amount by.\n  function lowerHasMinted(uint256 amount) external onlyWhitelisted {\n    totalMinted[msg.sender] = totalMinted[msg.sender] - amount;\n  }\n\n  /// @notice Adjusts the maximum flashloan amount.\n  ///\n  /// @param _maxFlashLoanAmount The maximum flashloan amount.\n  function setMaxFlashLoan(uint _maxFlashLoanAmount) external onlyAdmin {\n    maxFlashLoanAmount = _maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the maximum amount to be flash loaned of a token.\n  ///\n  /// @param token The address of the token.\n  ///\n  /// @return The maximum amount of `token` that can be flashed loaned.\n  function maxFlashLoan(address token) public view override returns (uint256) {\n    if (token != address(this)) {\n      return 0;\n    }\n    return maxFlashLoanAmount;\n  }\n\n  /// @notice Gets the flash loan fee of `amount` of `token`.\n  ///\n  /// @param token  The address of the token.`\n  /// @param amount The amount of `token` to flash mint.\n  ///\n  /// @return The flash loan fee.\n  function flashFee(address token, uint256 amount) public view override returns (uint256) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n    return amount * flashMintFee / BPS;\n  }\n\n  /// @notice Performs a flash mint (called flash loan to confirm with ERC3156 standard).\n  ///\n  /// @param receiver The address which will receive the flash minted tokens.\n  /// @param token    The address of the token to flash mint.\n  /// @param amount   How much to flash mint.\n  /// @param data     ABI encoded data to pass to the receiver.\n  ///\n  /// @return If the flash loan was successful.\n  function flashLoan(\n    IERC3156FlashBorrower receiver,\n    address token,\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant returns (bool) {\n    if (token != address(this)) {\n      revert IllegalArgument();\n    }\n\n    if (amount > maxFlashLoan(token)) {\n      revert IllegalArgument();\n    }\n\n    uint256 fee = flashFee(token, amount);\n\n    _mint(address(receiver), amount);\n\n    if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS) {\n      revert IllegalState();\n    }\n\n    _burn(address(receiver), amount + fee); // Will throw error if not enough to burn\n\n    return true;\n  }\n}\n\n\n",
        "CodeNames": [
            "AlchemicTokenV2Base.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AlchemicTokenV2Base.sol",
                "Type": "Minting control",
                "Description": "An alchemist/user can mint more than their allotted amount of AlTokens by calling lowerHasMinted() before they reach their minting cap.",
                "Repair": "Change the permissioning on lowerHasMinted() to be restricted to a higher permissioned role like onlySentinel(), or deprecate this function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {stdCheats} from \"forge-std/stdlib.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {ThreePoolAssetManagerUser} from \"./utils/users/ThreePoolAssetManagerUser.sol\";\n\nimport {\n    ThreePoolAssetManager,\n    ThreePoolAsset,\n    MetaPoolAsset,\n    SLIPPAGE_PRECISION,\n    CURVE_PRECISION,\n    InitializationParams as ManagerInitializationParams\n} from \"../ThreePoolAssetManager.sol\";\n\nimport {ITransmuterBuffer} from \"../interfaces/ITransmuterBuffer.sol\";\nimport {IERC20TokenReceiver} from \"../interfaces/IERC20TokenReceiver.sol\";\nimport {IConvexBooster} from \"../interfaces/external/convex/IConvexBooster.sol\";\nimport {IConvexRewards} from \"../interfaces/external/convex/IConvexRewards.sol\";\nimport {IConvexToken} from \"../interfaces/external/convex/IConvexToken.sol\";\nimport {IStableMetaPool} from \"../interfaces/external/curve/IStableMetaPool.sol\";\nimport {IStableSwap3Pool} from \"../interfaces/external/curve/IStableSwap3Pool.sol\";\n\ncontract ThreePoolAssetManagerTest is DSTestPlus, stdCheats {\n    ITransmuterBuffer constant transmuterBuffer = ITransmuterBuffer(0x1EEd2DbeB9fc23Ab483F447F38F289cA15f79Bac);\n    address constant transmuterBufferAdmin = address(0x9e2b6378ee8ad2A4A95Fe481d63CAba8FB0EBBF9);\n    IERC20 constant crv = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    IStableSwap3Pool constant threePool = IStableSwap3Pool(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\n    IStableMetaPool constant metaPool =  IStableMetaPool(0x43b4FdFD4Ff969587185cDB6f0BD875c5Fc83f8c);\n    IConvexToken constant cvx = IConvexToken(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    IConvexBooster constant convexBooster = IConvexBooster(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    IConvexRewards constant convexRewards = IConvexRewards(0x02E2151D4F351881017ABdF2DD2b51150841d5B3);\n\n    ThreePoolAssetManager manager;\n    IERC20 dai;\n    IERC20 usdc;\n    IERC20 usdt;\n    IERC20 alUSD;\n    IERC20 threePoolToken;\n\n    function setUp() external {\n        manager = new ThreePoolAssetManager(ManagerInitializationParams({\n            admin:             address(this),\n            operator:          address(this),\n            rewardReceiver:    address(0xbeef),\n            transmuterBuffer:  address(transmuterBuffer),\n            curveToken:        crv,\n            threePool:         threePool,\n            metaPool:          metaPool,\n            threePoolSlippage: SLIPPAGE_PRECISION - 30, // 30 bps, 0.3%\n            metaPoolSlippage:  SLIPPAGE_PRECISION - 30, // 30 bps, 0.3%\n            convexToken:       cvx,\n            convexBooster:     convexBooster,\n            convexRewards:     convexRewards,\n            convexPoolId:      36\n        }));\n\n        dai            = manager.getTokenForThreePoolAsset(ThreePoolAsset.DAI);\n        usdc           = manager.getTokenForThreePoolAsset(ThreePoolAsset.USDC);\n        usdt           = manager.getTokenForThreePoolAsset(ThreePoolAsset.USDT);\n        alUSD          = manager.getTokenForMetaPoolAsset(MetaPoolAsset.ALUSD);\n        threePoolToken = manager.getTokenForMetaPoolAsset(MetaPoolAsset.THREE_POOL);\n    }\n\n    function testCalculateRebalanceAlUSD() external {\n        tip(address(alUSD), address(manager), type(uint96).max);\n        tip(address(metaPool), address(manager), type(uint96).max);\n\n        (uint256 delta, bool add) = manager.calculateRebalance(\n            MetaPoolAsset.ALUSD,\n            ThreePoolAsset.DAI,\n            1.0e18\n        );\n\n        if (add) {\n            manager.mintMetaPoolTokens(MetaPoolAsset.ALUSD, delta);\n        } else {\n            uint256[2] memory amounts;\n            amounts[uint256(MetaPoolAsset.ALUSD)] = delta;\n\n            uint256 burnAmount = metaPool.calc_token_amount(amounts, false);\n            manager.burnMetaPoolTokens(MetaPoolAsset.ALUSD, burnAmount);\n        }\n\n        assertApproxEq(1.0e18, manager.exchangeRate(ThreePoolAsset.DAI), 0.0001e18);\n    }\n\n    function testCalculateRebalance3Pool() external {\n        tip(address(threePoolToken), address(manager), type(uint96).max);\n        tip(address(metaPool), address(manager), type(uint96).max);\n\n        (uint256 delta, bool add) = manager.calculateRebalance(\n            MetaPoolAsset.THREE_POOL,\n            ThreePoolAsset.DAI,\n            1.0e18\n        );\n\n        if (add) {\n            manager.mintMetaPoolTokens(MetaPoolAsset.THREE_POOL, delta);\n        } else {\n            uint256[2] memory amounts;\n            amounts[uint256(MetaPoolAsset.THREE_POOL)] = delta;\n\n            uint256 burnAmount = metaPool.calc_token_amount(amounts, false);\n            manager.burnMetaPoolTokens(MetaPoolAsset.THREE_POOL, burnAmount);\n        }\n\n        assertApproxEq(1.0e18, manager.exchangeRate(ThreePoolAsset.DAI), 0.0001e18);\n    }\n\n    function testSetPendingAdmin() external {\n        manager.setPendingAdmin(address(0xdead));\n        assertEq(manager.pendingAdmin(), address(0xdead));\n    }\n\n    function testFailSetPendingAdminSenderNotAdmin() external {\n        hevm.prank(address(0xdead));\n        manager.setPendingAdmin(address(0xbeef));\n    }\n\n    function testAcceptAdmin() external {\n        ThreePoolAssetManagerUser pendingAdmin = new ThreePoolAssetManagerUser(manager);\n\n        manager.setPendingAdmin(address(pendingAdmin));\n        pendingAdmin.acceptAdmin();\n\n        assertEq(manager.pendingAdmin(), address(0));\n        assertEq(manager.admin(), address(pendingAdmin));\n    }\n\n    function testFailAcceptTimelockNotPendingAdmin() external {\n        ThreePoolAssetManagerUser pendingAdmin = new ThreePoolAssetManagerUser(manager);\n\n        manager.setPendingAdmin(address(pendingAdmin));\n\n        hevm.prank(address(0xdead));\n        manager.acceptAdmin();\n    }\n\n    function testFailAcceptAdminPendingAdminUnset() external {\n        manager.acceptAdmin();\n    }\n\n    function testSetRewardReceiver() external {\n        manager.setRewardReceiver(address(0xdead));\n        assertEq(manager.rewardReceiver(), address(0xdead));\n    }\n\n    function testFailSetRewardReceiverSenderNotAdmin() external {\n        hevm.prank(address(0xdead));\n        manager.setRewardReceiver(address(0xbeef));\n    }\n\n    function testSetTransmuterBuffer() external {\n        manager.setTransmuterBuffer(address(0xdead));\n        assertEq(manager.transmuterBuffer(), address(0xdead));\n    }\n\n    function testFailSetTransmuterBufferSenderNotAdmin() external {\n        hevm.prank(address(0xdead));\n        manager.setTransmuterBuffer(address(0xbeef));\n    }\n\n    function testSetThreePoolSlippage() external {\n        manager.setThreePoolSlippage(1e4);\n        assertEq(manager.threePoolSlippage(), 1e4);\n    }\n\n    function testSetThreePoolSlippage(uint256 value) external {\n        value = bound(value, 0, SLIPPAGE_PRECISION);\n        manager.setThreePoolSlippage(value);\n\n        assertEq(manager.threePoolSlippage(), value);\n    }\n\n    function testFailSetThreePoolSlippageSenderNotAdmin() external {\n        hevm.prank(address(0xdead));\n        manager.setThreePoolSlippage(1e4);\n    }\n\n    function testSetMetaPoolSlippage() external {\n        manager.setMetaPoolSlippage(1e4);\n        assertEq(manager.metaPoolSlippage(), 1e4);\n    }\n\n    function testSetMetaPoolSlippage(uint256 value) external {\n        value = bound(value, 0, SLIPPAGE_PRECISION);\n        manager.setMetaPoolSlippage(value);\n\n        assertEq(manager.metaPoolSlippage(), value);\n    }\n\n    function testFailSetMetaPoolSlippageSenderNotAdmin() external {\n        hevm.prank(address(0xdead));\n        manager.setMetaPoolSlippage(1e4);\n    }\n\n    function testMintThreePoolTokensMultipleAssets() external {\n        tip(address(dai), address(manager), 1e18);\n        tip(address(usdc), address(manager), 1e6);\n\n        uint256[3] memory amounts;\n        amounts[uint256(ThreePoolAsset.DAI)]  = 1e18;\n        amounts[uint256(ThreePoolAsset.USDC)] = 1e6;\n\n        uint256 expectedOutput = 2e18 * CURVE_PRECISION / threePool.get_virtual_price();\n        uint256 minted         = manager.mintThreePoolTokens(amounts);\n\n        assertEq(dai.balanceOf(address(manager)), 0);\n        assertEq(usdc.balanceOf(address(manager)), 0);\n        assertEq(threePoolToken.balanceOf(address(manager)), minted);\n        assertGt(minted, expectedOutput * manager.threePoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testMintThreePoolTokensMultipleAssetSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n\n        uint256[3] memory amounts;\n        manager.mintThreePoolTokens(amounts);\n    }\n\n    function testMintThreePoolTokensWithDAI() external {\n        tip(address(dai), address(manager), 1e18);\n\n        uint256 expectedOutput = 1e18 * CURVE_PRECISION / threePool.get_virtual_price();\n        uint256 minted         = manager.mintThreePoolTokens(ThreePoolAsset.DAI, 1e18);\n\n        assertEq(dai.balanceOf(address(manager)), 0);\n        assertEq(threePoolToken.balanceOf(address(manager)), minted);\n        assertGt(minted, expectedOutput * manager.threePoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testMintThreePoolTokensWithUSDC() external {\n        tip(address(usdc), address(manager), 1e6);\n\n        uint256 expectedOutput = 1e18 * CURVE_PRECISION / threePool.get_virtual_price();\n        uint256 minted         = manager.mintThreePoolTokens(ThreePoolAsset.USDC, 1e6);\n\n        assertEq(usdc.balanceOf(address(manager)), 0);\n        assertEq(threePoolToken.balanceOf(address(manager)), minted);\n        assertGt(minted, expectedOutput * manager.threePoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testMintThreePoolTokensWithUSDT() external {\n        tip(address(usdt), address(manager), 1e6);\n\n        uint256 expectedOutput = 1e18 * CURVE_PRECISION / threePool.get_virtual_price();\n        uint256 minted         = manager.mintThreePoolTokens(ThreePoolAsset.USDT, 1e6);\n\n        assertEq(usdt.balanceOf(address(manager)), 0);\n        assertEq(threePoolToken.balanceOf(address(manager)), minted);\n        assertGt(minted, expectedOutput * manager.threePoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testMintThreePoolTokensSingleAssetSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.mintThreePoolTokens(ThreePoolAsset.DAI, 0);\n    }\n\n    function testBurnThreePoolTokensIntoDAI() external {\n        tip(address(threePoolToken), address(manager), 1e18);\n\n        uint256 expectedOutput = 1e18 * threePool.get_virtual_price() / CURVE_PRECISION;\n        uint256 withdrawn      = manager.burnThreePoolTokens(ThreePoolAsset.DAI, 1e18);\n\n        assertEq(threePoolToken.balanceOf(address(manager)), 0);\n        assertEq(dai.balanceOf(address(manager)), withdrawn);\n        assertGt(withdrawn, expectedOutput * manager.threePoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testBurnThreePoolTokensIntoUSDC() external {\n        tip(address(threePoolToken), address(manager), 1e18);\n\n        uint256 expectedOutput = 1e6 * threePool.get_virtual_price() / CURVE_PRECISION;\n        uint256 withdrawn      = manager.burnThreePoolTokens(ThreePoolAsset.USDC, 1e18);\n\n        assertEq(threePoolToken.balanceOf(address(manager)), 0);\n        assertEq(usdc.balanceOf(address(manager)), withdrawn);\n        assertGt(withdrawn, expectedOutput * manager.threePoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testBurnThreePoolTokensIntoUSDT() external {\n        tip(address(threePoolToken), address(manager), 1e18);\n\n        uint256 expectedOutput = 1e6 * threePool.get_virtual_price() / CURVE_PRECISION;\n        uint256 withdrawn      = manager.burnThreePoolTokens(ThreePoolAsset.USDT, 1e18);\n\n        assertEq(threePoolToken.balanceOf(address(manager)), 0);\n        assertEq(usdt.balanceOf(address(manager)), withdrawn);\n        assertGt(withdrawn, expectedOutput * manager.threePoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testBurnThreePoolTokensSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.burnThreePoolTokens(ThreePoolAsset.DAI, 0);\n    }\n\n    function testMintMetaPoolTokensMultipleAssets() external {\n        tip(address(alUSD), address(manager), 1e18);\n        tip(address(threePoolToken), address(manager), 1e18);\n\n        uint256[2] memory amounts;\n        amounts[uint256(MetaPoolAsset.ALUSD)]      = 1e18;\n        amounts[uint256(MetaPoolAsset.THREE_POOL)] = 1e18;\n\n        uint256 expectedOutput = 2e18 * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minted         = manager.mintMetaPoolTokens(amounts);\n\n        assertEq(threePoolToken.balanceOf(address(manager)), 0);\n        assertEq(metaPool.balanceOf(address(manager)), minted);\n        assertGt(minted, expectedOutput * manager.metaPoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testMintMetaPoolTokensMultipleAssetsSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n\n        uint256[2] memory amounts;\n        manager.mintMetaPoolTokens(amounts);\n    }\n\n    function testMintMetaPoolTokensSingleAsset() external {\n        tip(address(threePoolToken), address(manager), 1e18);\n\n        uint256 expectedOutput = 1e18 * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minted         = manager.mintMetaPoolTokens(MetaPoolAsset.THREE_POOL, 1e18);\n\n        assertEq(threePoolToken.balanceOf(address(manager)), 0);\n        assertEq(metaPool.balanceOf(address(manager)), minted);\n        assertGt(minted, expectedOutput * manager.metaPoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testMintMetaPoolTokensSingleAssetSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.mintMetaPoolTokens(MetaPoolAsset.THREE_POOL, 0);\n    }\n\n    function testBurnMetaPoolTokens() external {\n        tip(address(metaPool), address(manager), 1e18);\n\n        uint256 expectedOutput = 1e18 * metaPool.get_virtual_price() / CURVE_PRECISION;\n        uint256 withdrawn      = manager.burnMetaPoolTokens(MetaPoolAsset.ALUSD, 1e18);\n\n        assertEq(metaPool.balanceOf(address(manager)), 0);\n        assertEq(alUSD.balanceOf(address(manager)), withdrawn);\n        assertGt(withdrawn, expectedOutput * manager.metaPoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testBurnMetaPoolTokensSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.burnMetaPoolTokens(MetaPoolAsset.ALUSD, 0);\n    }\n\n    function testDepositMetaPoolTokens() external {\n        tip(address(metaPool), address(manager), 1e18);\n\n        assertTrue(manager.depositMetaPoolTokens(1e18));\n        assertEq(convexRewards.balanceOf(address(manager)), 1e18);\n    }\n\n    function testDepositMetaPoolTokensSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.depositMetaPoolTokens(0);\n    }\n\n    function testWithdrawMetaPoolTokens() external {\n        tip(address(metaPool), address(manager), 1e18);\n\n        manager.depositMetaPoolTokens(1e18);\n\n        assertTrue(manager.withdrawMetaPoolTokens(1e18));\n\n        assertEq(convexRewards.balanceOf(address(manager)), 0);\n        assertEq(metaPool.balanceOf(address(manager)), 1e18);\n    }\n\n    function testWithdrawMetaPoolTokensSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.withdrawMetaPoolTokens(0);\n    }\n\n    function testClaimRewards() external {\n        tip(address(metaPool), address(manager), 1e18);\n\n        manager.depositMetaPoolTokens(1e18);\n\n        hevm.warp(block.timestamp + 86400);\n\n        (uint256 earnedCurve, uint256 earnedConvex) = manager.claimableRewards();\n\n        assertTrue(manager.claimRewards());\n        assertEq(crv.balanceOf(manager.rewardReceiver()), earnedCurve);\n        assertEq(cvx.balanceOf(manager.rewardReceiver()), earnedConvex);\n    }\n\n    function testClaimRewardsSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.claimRewards();\n    }\n\n    function testFlushMultipleAssets() external {\n        tip(address(dai), address(manager), 1e18);\n\n        uint256[3] memory amounts;\n        amounts[uint256(ThreePoolAsset.DAI)] = 1e18;\n\n        uint256 minted = manager.flush(amounts);\n\n        assertEq(dai.balanceOf(address(manager)), 0);\n        assertEq(metaPool.balanceOf(address(manager)), 0);\n        assertEq(convexRewards.balanceOf(address(manager)), minted);\n    }\n\n    function testFlushMultipleAssetsSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.flush(ThreePoolAsset.DAI, 1e18);\n    }\n\n    function testFlushSingleAsset() external {\n        tip(address(dai), address(manager), 1e18);\n\n        manager.setThreePoolSlippage(0);\n        manager.setMetaPoolSlippage(0);\n\n        uint256 minted = manager.flush(ThreePoolAsset.DAI, 1e18);\n\n        assertEq(dai.balanceOf(address(manager)), 0);\n        assertEq(metaPool.balanceOf(address(manager)), 0);\n        assertEq(convexRewards.balanceOf(address(manager)), minted);\n    }\n\n    function testFlushSingleAssetSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.flush(ThreePoolAsset.DAI, 1e18);\n    }\n\n    function testRecall() external {\n        tip(address(metaPool), address(manager), 1e18);\n\n        manager.depositMetaPoolTokens(1e18);\n\n        manager.setThreePoolSlippage(0);\n        manager.setMetaPoolSlippage(0);\n\n        uint256 withdrawn = manager.recall(ThreePoolAsset.DAI, 1e18);\n\n        assertEq(dai.balanceOf(address(manager)), withdrawn);\n        assertEq(metaPool.balanceOf(address(manager)), 0);\n        assertEq(convexRewards.balanceOf(address(manager)), 0);\n    }\n\n    function testRecallSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.recall(ThreePoolAsset.DAI, 1e18);\n    }\n\n    function testReclaimThreePoolAsset() external {\n        tip(address(dai), address(manager), 1e18);\n\n        hevm.prank(transmuterBufferAdmin);\n        transmuterBuffer.setSource(address(manager), true);\n\n        hevm.expectCall(\n            manager.transmuterBuffer(),\n            abi.encodeWithSelector(\n                IERC20TokenReceiver.onERC20Received.selector,\n                address(dai),\n                1e18\n            )\n        );\n\n        manager.reclaimThreePoolAsset(ThreePoolAsset.DAI, 1e18);\n    }\n\n    function testFailReclaimThreePoolAssetSenderNotAdmin() external {\n        tip(address(dai), address(manager), 1e18);\n\n        hevm.prank(address(0xdead));\n        manager.reclaimThreePoolAsset(ThreePoolAsset.DAI, 1e18);\n    }\n\n    function testSweep() external {\n        tip(address(dai), address(manager), 1e18);\n\n        manager.sweep(address(dai), 1e18);\n\n        assertEq(dai.balanceOf(address(manager)), 0e18);\n        assertEq(dai.balanceOf(manager.admin()), 1e18);\n    }\n\n    function testFailSweepSenderNotAdmin() external {\n        tip(address(dai), address(manager), 1e18);\n\n        hevm.prank(address(0xdead));\n        manager.sweep(address(dai), 1e18);\n    }\n}\n\ncontract MockTransmuterBuffer is IERC20TokenReceiver {\n    function onERC20Received(address token, uint256 amount) external { }\n}\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\nimport {Multicall} from \"./base/Multicall.sol\";\nimport {Mutex} from \"./base/Mutex.sol\";\n\nimport {IERC20TokenReceiver} from \"./interfaces/IERC20TokenReceiver.sol\";\nimport {IConvexBooster} from \"./interfaces/external/convex/IConvexBooster.sol\";\nimport {IConvexRewards} from \"./interfaces/external/convex/IConvexRewards.sol\";\nimport {IConvexToken} from \"./interfaces/external/convex/IConvexToken.sol\";\n\nimport {\n    IStableMetaPool,\n    N_COINS as NUM_META_COINS\n} from \"./interfaces/external/curve/IStableMetaPool.sol\";\n\nimport {\n    IStableSwap3Pool,\n    N_COINS as NUM_STABLE_COINS\n} from \"./interfaces/external/curve/IStableSwap3Pool.sol\";\n\nimport {SafeERC20} from \"./libraries/SafeERC20.sol\";\n\n/// @notice A struct used to define initialization parameters. This is not included\n///         in the contract to prevent naming collisions.\nstruct InitializationParams {\n    address admin;\n    address operator;\n    address rewardReceiver;\n    address transmuterBuffer;\n    IERC20 curveToken;\n    IStableSwap3Pool threePool;\n    IStableMetaPool metaPool;\n    uint256 threePoolSlippage;\n    uint256 metaPoolSlippage;\n    IConvexToken convexToken;\n    IConvexBooster convexBooster;\n    IConvexRewards convexRewards;\n    uint256 convexPoolId;\n}\n\n/// @dev The amount of precision that slippage parameters have.\nuint256 constant SLIPPAGE_PRECISION = 1e4;\n\n/// @dev The amount of precision that curve pools use for price calculations.\nuint256 constant CURVE_PRECISION = 1e18;\n\n/// @notice Enumerations for 3pool assets.\n///\n/// @dev Do not change the order of these fields.\nenum ThreePoolAsset {\n    DAI, USDC, USDT\n}\n\n/// @notice Enumerations for meta pool assets.\n///\n/// @dev Do not change the order of these fields.\nenum MetaPoolAsset {\n    ALUSD, THREE_POOL\n}\n\n/// @title  ThreePoolAssetManager\n/// @author Alchemix Finance\ncontract ThreePoolAssetManager is Multicall, Mutex, IERC20TokenReceiver {\n    /// @notice Emitted when the admin is updated.\n    ///\n    /// @param admin The admin.\n    event AdminUpdated(address admin);\n\n    /// @notice Emitted when the pending admin is updated.\n    ///\n    /// @param pendingAdmin The pending admin.\n    event PendingAdminUpdated(address pendingAdmin);\n\n    /// @notice Emitted when the operator is updated.\n    ///\n    /// @param operator The operator.\n    event OperatorUpdated(address operator);\n\n    /// @notice Emitted when the reward receiver is updated.\n    ///\n    /// @param rewardReceiver The reward receiver.\n    event RewardReceiverUpdated(address rewardReceiver);\n\n    /// @notice Emitted when the transmuter buffer is updated.\n    ///\n    /// @param transmuterBuffer The transmuter buffer.\n    event TransmuterBufferUpdated(address transmuterBuffer);\n\n    /// @notice Emitted when the 3pool slippage is updated.\n    ///\n    /// @param threePoolSlippage The 3pool slippage.\n    event ThreePoolSlippageUpdated(uint256 threePoolSlippage);\n\n    /// @notice Emitted when the meta pool slippage is updated.\n    ///\n    /// @param metaPoolSlippage The meta pool slippage.\n    event MetaPoolSlippageUpdated(uint256 metaPoolSlippage);\n\n    /// @notice Emitted when 3pool tokens are minted.\n    ///\n    /// @param amounts               The amounts of each 3pool asset used to mint liquidity.\n    /// @param mintedThreePoolTokens The amount of 3pool tokens minted.\n    event MintThreePoolTokens(uint256[NUM_STABLE_COINS] amounts, uint256 mintedThreePoolTokens);\n\n    /// @notice Emitted when 3pool tokens are minted.\n    ///\n    /// @param asset                 The 3pool asset used to mint 3pool tokens.\n    /// @param amount                The amount of the asset used to mint 3pool tokens.\n    /// @param mintedThreePoolTokens The amount of 3pool tokens minted.\n    event MintThreePoolTokens(ThreePoolAsset asset, uint256 amount, uint256 mintedThreePoolTokens);\n\n    /// @notice Emitted when 3pool tokens are burned.\n    ///\n    /// @param asset     The 3pool asset that was received.\n    /// @param amount    The amount of 3pool tokens that were burned.\n    /// @param withdrawn The amount of the 3pool asset that was withdrawn.\n    event BurnThreePoolTokens(ThreePoolAsset asset, uint256 amount, uint256 withdrawn);\n\n    /// @notice Emitted when meta pool tokens are minted.\n    ///\n    /// @param amounts               The amounts of each meta pool asset used to mint liquidity.\n    /// @param mintedThreePoolTokens The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(uint256[NUM_META_COINS] amounts, uint256 mintedThreePoolTokens);\n\n    /// @notice Emitted when meta tokens are minted.\n    ///\n    /// @param asset  The asset used to mint meta pool tokens.\n    /// @param amount The amount of the asset used to mint meta pool tokens.\n    /// @param minted The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 minted);\n\n    /// @notice Emitted when meta pool tokens are burned.\n    ///\n    /// @param asset     The meta pool asset that was received.\n    /// @param amount    The amount of meta pool tokens that were burned.\n    /// @param withdrawn The amount of the asset that was withdrawn.\n    event BurnMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 withdrawn);\n\n    /// @notice Emitted when meta pool tokens are deposited into convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were deposited.\n    /// @param success If the operation was successful.\n    event DepositMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when meta pool tokens are withdrawn from convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were withdrawn.\n    /// @param success If the operation was successful.\n    event WithdrawMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when convex rewards are claimed.\n    ///\n    /// @param success      If the operation was successful.\n    /// @param amountCurve  The amount of curve tokens sent to the reward recipient.\n    /// @param amountConvex The amount of convex tokens sent to the reward recipient.\n    event ClaimRewards(bool success, uint256 amountCurve, uint256 amountConvex);\n\n    /// @notice Emitted when 3pool assets are sent to the transmuter buffer.\n    ///\n    /// @param asset  The 3pool asset that was reclaimed.\n    /// @param amount The amount of the asset that was reclaimed.\n    event ReclaimThreePoolAsset(ThreePoolAsset asset, uint256 amount);\n\n    /// @notice The admin.\n    address public admin;\n\n    /// @notice The current pending admin.\n    address public pendingAdmin;\n\n    /// @notice The operator.\n    address public operator;\n\n    // @notice The reward receiver.\n    address public rewardReceiver;\n\n    /// @notice The transmuter buffer.\n    address public transmuterBuffer;\n\n    /// @notice The curve token.\n    IERC20 public immutable curveToken;\n\n    /// @notice The 3pool contract.\n    IStableSwap3Pool public immutable threePool;\n\n    /// @notice The meta pool contract.\n    IStableMetaPool public immutable metaPool;\n\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\n    ///         from the stable swap pool. In units of basis points.\n    uint256 public threePoolSlippage;\n\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\n    ///         from the meta pool. In units of basis points.\n    uint256 public metaPoolSlippage;\n\n    /// @notice The convex token.\n    IConvexToken public immutable convexToken;\n\n    /// @notice The convex booster contract.\n    IConvexBooster public immutable convexBooster;\n\n    /// @notice The convex rewards contract.\n    IConvexRewards public immutable convexRewards;\n\n    /// @notice The convex pool identifier.\n    uint256 public immutable convexPoolId;\n\n    /// @dev A cache of the tokens that the stable swap pool supports.\n    IERC20[NUM_STABLE_COINS] private _threePoolAssetCache;\n\n    /// @dev A cache of the tokens that the meta pool supports.\n    IERC20[NUM_META_COINS] private _metaPoolAssetCache;\n\n    /// @dev A modifier which reverts if the message sender is not the admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) {\n            revert Unauthorized(\"Not admin\");\n        }\n        _;\n    }\n\n    /// @dev A modifier which reverts if the message sender is not the operator.\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert Unauthorized(\"Not operator\");\n        }\n        _;\n    }\n\n    constructor(InitializationParams memory params) {\n        admin             = params.admin;\n        operator          = params.operator;\n        rewardReceiver    = params.rewardReceiver;\n        transmuterBuffer  = params.transmuterBuffer;\n        curveToken        = params.curveToken;\n        threePool         = params.threePool;\n        metaPool          = params.metaPool;\n        threePoolSlippage = params.threePoolSlippage;\n        metaPoolSlippage  = params.metaPoolSlippage;\n        convexToken       = params.convexToken;\n        convexBooster     = params.convexBooster;\n        convexRewards     = params.convexRewards;\n        convexPoolId      = params.convexPoolId;\n\n        for (uint256 i = 0; i < NUM_STABLE_COINS; i++) {\n            _threePoolAssetCache[i] = params.threePool.coins(i);\n        }\n\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\n        }\n\n        emit AdminUpdated(admin);\n        emit OperatorUpdated(operator);\n        emit RewardReceiverUpdated(rewardReceiver);\n        emit TransmuterBufferUpdated(transmuterBuffer);\n        emit ThreePoolSlippageUpdated(threePoolSlippage);\n        emit MetaPoolSlippageUpdated(metaPoolSlippage);\n    }\n\n    /// @notice Gets the amount of meta pool tokens that this contract has in reserves.\n    ///\n    /// @return The reserves.\n    function metaPoolReserves() external view returns (uint256) {\n        return metaPool.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of a 3pool asset that this contract has in reserves.\n    ///\n    /// @param asset The 3pool asset.\n    ///\n    /// @return The reserves.\n    function threePoolAssetReserves(ThreePoolAsset asset) external view returns (uint256) {\n        IERC20 token = getTokenForThreePoolAsset(asset);\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of a meta pool asset that this contract has in reserves.\n    ///\n    /// @param asset The meta pool asset.\n    ///\n    /// @return The reserves.\n    function metaPoolAssetReserves(MetaPoolAsset asset) external view returns (uint256) {\n        IERC20 token = getTokenForMetaPoolAsset(asset);\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of a 3pool asset that one alUSD is worth.\n    ///\n    /// @param asset The 3pool asset.\n    ///\n    /// @return The amount of the underying.\n    function exchangeRate(ThreePoolAsset asset) public view returns (uint256) {\n        IERC20 alUSD = getTokenForMetaPoolAsset(MetaPoolAsset.ALUSD);\n\n        uint256[NUM_META_COINS] memory metaBalances = metaPool.get_balances();\n        uint256 amountThreePool = metaPool.get_dy(\n            int128(uint128(uint256(MetaPoolAsset.ALUSD))),\n            int128(uint128(uint256(MetaPoolAsset.THREE_POOL))),\n            10**SafeERC20.expectDecimals(address(alUSD)),\n            metaBalances\n        );\n\n        return threePool.calc_withdraw_one_coin(amountThreePool, int128(uint128(uint256(asset))));\n    }\n\n    /// @dev Struct used to declare local variables for the calculate rebalance function.\n    struct CalculateRebalanceLocalVars {\n        uint256 minimum;\n        uint256 maximum;\n        uint256 minimumDistance;\n        uint256 minimizedBalance;\n        uint256 startingBalance;\n    }\n\n    /// @notice Calculates how much alUSD or 3pool needs to be added or removed from the metapool\n    ///         to reach a target exchange rate for a specified 3pool asset.\n    ///\n    /// @param rebalanceAsset      The meta pool asset to use to rebalance the pool.\n    /// @param targetExchangeAsset The 3pool asset to balance the price relative to.\n    /// @param targetExchangeRate  The target exchange rate.\n    ///\n    /// @return delta The amount of alUSD or 3pool that needs to be added or removed from the pool.\n    /// @return add   If the alUSD or 3pool needs to be removed or added.\n    function calculateRebalance(\n        MetaPoolAsset rebalanceAsset,\n        ThreePoolAsset targetExchangeAsset,\n        uint256 targetExchangeRate\n    ) public view returns (uint256 delta, bool add) {\n        uint256 decimals;\n        {\n            IERC20 alUSD = getTokenForMetaPoolAsset(MetaPoolAsset.ALUSD);\n            decimals     = SafeERC20.expectDecimals(address(alUSD));\n        }\n\n        uint256[NUM_META_COINS] memory startingBalances = metaPool.get_balances();\n        uint256[NUM_META_COINS] memory currentBalances  = [startingBalances[0], startingBalances[1]];\n\n        CalculateRebalanceLocalVars memory v;\n        v.minimum          = 0;\n        v.maximum          = type(uint96).max;\n        v.minimumDistance  = type(uint256).max;\n        v.minimizedBalance = type(uint256).max;\n        v.startingBalance  = startingBalances[uint256(rebalanceAsset)];\n\n        uint256 previousBalance;\n\n        for (uint256 i = 0; i < 256; i++) {\n            uint256 examineBalance;\n            if ((examineBalance = (v.maximum + v.minimum) / 2) == previousBalance) break;\n\n            currentBalances[uint256(rebalanceAsset)] = examineBalance;\n\n            uint256 amountThreePool = metaPool.get_dy(\n                int128(uint128(uint256(MetaPoolAsset.ALUSD))),\n                int128(uint128(uint256(MetaPoolAsset.THREE_POOL))),\n                10**decimals,\n                currentBalances\n            );\n\n            uint256 exchangeRate = threePool.calc_withdraw_one_coin(\n                amountThreePool,\n                int128(uint128(uint256(targetExchangeAsset)))\n            );\n\n            uint256 distance = abs(exchangeRate, targetExchangeRate);\n\n            if (distance < v.minimumDistance) {\n                v.minimumDistance  = distance;\n                v.minimizedBalance = examineBalance;\n            } else if(distance == v.minimumDistance) {\n                uint256 examineDelta = abs(examineBalance, v.startingBalance);\n                uint256 currentDelta = abs(v.minimizedBalance, v.startingBalance);\n                v.minimizedBalance = currentDelta > examineDelta ? examineBalance : v.minimizedBalance;\n            }\n\n            if (exchangeRate > targetExchangeRate) {\n                if (rebalanceAsset == MetaPoolAsset.ALUSD) {\n                    v.minimum = examineBalance;\n                } else {\n                    v.maximum = examineBalance;\n                }\n            } else {\n                if (rebalanceAsset == MetaPoolAsset.ALUSD) {\n                    v.maximum = examineBalance;\n                } else {\n                    v.minimum = examineBalance;\n                }\n            }\n\n            previousBalance = examineBalance;\n        }\n\n        return v.minimizedBalance > v.startingBalance\n            ? (v.minimizedBalance - v.startingBalance, true)\n            : (v.startingBalance - v.minimizedBalance, false);\n    }\n\n    /// @notice Gets the amount of curve tokens and convex tokens that can be claimed.\n    ///\n    /// @return amountCurve  The amount of curve tokens available.\n    /// @return amountConvex The amount of convex tokens available.\n    function claimableRewards() public view returns (uint256 amountCurve, uint256 amountConvex) {\n        amountCurve  = convexRewards.earned(address(this));\n        amountConvex = _getEarnedConvex(amountCurve);\n    }\n\n    /// @notice Gets the ERC20 token associated with a 3pool asset.\n    ///\n    /// @param asset The asset to get the token for.\n    ///\n    /// @return The token.\n    function getTokenForThreePoolAsset(ThreePoolAsset asset) public view returns (IERC20) {\n        uint256 index = uint256(asset);\n        if (index >= NUM_STABLE_COINS) {\n            revert IllegalArgument(\"Asset index out of bounds\");\n        }\n        return _threePoolAssetCache[index];\n    }\n\n    /// @notice Gets the ERC20 token associated with a meta pool asset.\n    ///\n    /// @param asset The asset to get the token for.\n    ///\n    /// @return The token.\n    function getTokenForMetaPoolAsset(MetaPoolAsset asset) public view returns (IERC20) {\n        uint256 index = uint256(asset);\n        if (index >= NUM_META_COINS) {\n            revert IllegalArgument(\"Asset index out of bounds\");\n        }\n        return _metaPoolAssetCache[index];\n    }\n\n    /// @notice Begins the 2-step process of setting the administrator.\n    ///\n    /// The caller must be the admin. Setting the pending timelock to the zero address will stop\n    /// the process of setting a new timelock.\n    ///\n    /// @param value The value to set the pending timelock to.\n    function setPendingAdmin(address value) external onlyAdmin {\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @notice Completes the 2-step process of setting the administrator.\n    ///\n    /// The pending admin must be set and the caller must be the pending admin. After this function\n    /// is successfully executed, the admin will be set to the pending admin and the pending admin\n    /// will be reset.\n    function acceptAdmin() external {\n        if (pendingAdmin == address(0)) {\n            revert IllegalState(\"Pending admin unset\");\n        }\n\n        if (pendingAdmin != msg.sender) {\n            revert Unauthorized(\"Not pending admin\");\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @notice Sets the operator.\n    ///\n    /// The caller must be the admin.\n    ///\n    /// @param value The value to set the admin to.\n    function setOperator(address value) external onlyAdmin {\n        operator = value;\n        emit OperatorUpdated(value);\n    }\n\n    /// @notice Sets the reward receiver.\n    ///\n    /// @param value The value to set the reward receiver to.\n    function setRewardReceiver(address value) external onlyAdmin {\n        rewardReceiver = value;\n        emit RewardReceiverUpdated(value);\n    }\n\n    /// @notice Sets the transmuter buffer.\n    ///\n    /// @param value The value to set the transmuter buffer to.\n    function setTransmuterBuffer(address value) external onlyAdmin {\n        transmuterBuffer = value;\n        emit TransmuterBufferUpdated(value);\n    }\n\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing 3pool\n    ///         assets. The slippage has a resolution of 6 decimals.\n    ///\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\n    /// fine adjustment in a short time window.\n    ///\n    /// @param value The value to set the slippage to.\n    function setThreePoolSlippage(uint256 value) external onlyOperator {\n        if (value > SLIPPAGE_PRECISION) {\n            revert IllegalArgument(\"Slippage not in range\");\n        }\n        threePoolSlippage = value;\n        emit ThreePoolSlippageUpdated(value);\n    }\n\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing meta pool\n    ///         assets. The slippage has a resolution of 6 decimals.\n    ///\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\n    /// fine adjustment in a short time window.\n    ///\n    /// @param value The value to set the slippage to.\n    function setMetaPoolSlippage(uint256 value) external onlyOperator {\n        if (value > SLIPPAGE_PRECISION) {\n            revert IllegalArgument(\"Slippage not in range\");\n        }\n        metaPoolSlippage = value;\n        emit MetaPoolSlippageUpdated(value);\n    }\n\n    /// @notice Mints 3pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of 3pool tokens minted.\n    function mintThreePoolTokens(\n        uint256[NUM_STABLE_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintThreePoolTokens(amounts);\n    }\n\n    /// @notice Mints 3pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the 3pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of 3pool tokens minted.\n    function mintThreePoolTokens(\n        ThreePoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintThreePoolTokens(asset, amount);\n    }\n\n    /// @notice Burns 3pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of 3pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function burnThreePoolTokens(\n        ThreePoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 withdrawn) {\n        return _burnThreePoolTokens(asset, amount);\n    }\n\n    /// @notice Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(amounts);\n    }\n\n    /// @notice Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 withdrawn) {\n        return _burnMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function depositMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _depositMetaPoolTokens(amount);\n    }\n\n    /// @notice Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function withdrawMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _withdrawMetaPoolTokens(amount);\n    }\n\n    /// @notice Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function claimRewards() external lock onlyOperator returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @notice Flushes three pool assets into convex by minting 3pool tokens from the assets,\n    ///         minting meta pool tokens using the 3pool tokens, and then depositing the meta pool\n    ///         tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param amounts The amounts of the 3pool assets to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        uint256[NUM_STABLE_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedThreePoolTokens = _mintThreePoolTokens(amounts);\n\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(\n            MetaPoolAsset.THREE_POOL,\n            mintedThreePoolTokens\n        );\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Flushes a three pool asset into convex by minting 3pool tokens using the asset,\n    ///         minting meta pool tokens using the 3pool tokens, and then depositing the meta pool\n    ///         tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param asset  The 3pool asset to flush.\n    /// @param amount The amount of the 3pool asset to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        ThreePoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedThreePoolTokens = _mintThreePoolTokens(asset, amount);\n\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(\n            MetaPoolAsset.THREE_POOL,\n            mintedThreePoolTokens\n        );\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Recalls a three pool asset into reserves by withdrawing meta pool tokens from\n    ///         convex, burning the meta pool tokens for 3pool tokens, and then burning the 3pool\n    ///         tokens for an asset.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param asset  The 3pool asset to recall.\n    /// @param amount The amount of the meta pool tokens to withdraw from convex and burn.\n    ///\n    /// @return The amount of the 3pool asset recalled.\n    function recall(\n        ThreePoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256) {\n        if (!_withdrawMetaPoolTokens(amount)) {\n            revert IllegalState(\"Withdraw from convex failed\");\n        }\n        uint256 withdrawnThreePoolTokens = _burnMetaPoolTokens(MetaPoolAsset.THREE_POOL, amount);\n        return _burnThreePoolTokens(asset, withdrawnThreePoolTokens);\n    }\n\n    /// @notice Reclaims a three pool asset to the transmuter buffer.\n    ///\n    /// @param asset  The 3pool asset to reclaim.\n    /// @param amount The amount to reclaim.\n    function reclaimThreePoolAsset(ThreePoolAsset asset, uint256 amount) public lock onlyAdmin {\n        IERC20 token = getTokenForThreePoolAsset(asset);\n        SafeERC20.safeTransfer(address(token), transmuterBuffer, amount);\n\n        IERC20TokenReceiver(transmuterBuffer).onERC20Received(address(token), amount);\n\n        emit ReclaimThreePoolAsset(asset, amount);\n    }\n\n    /// @notice Sweeps a token out of the contract to the admin.\n    ///\n    /// @param token  The token to sweep.\n    /// @param amount The amount of the token to sweep.\n    function sweep(address token, uint256 amount) external lock onlyAdmin {\n        SafeERC20.safeTransfer(address(token), msg.sender, amount);\n    }\n\n    /// @inheritdoc IERC20TokenReceiver\n    ///\n    /// @dev This function is required in order to receive tokens from the conduit.\n    function onERC20Received(address token, uint256 value) external { /* noop */ }\n\n    /// @dev Gets the amount of convex that will be minted for an amount of curve tokens.\n    ///\n    /// @param amountCurve The amount of curve tokens.\n    ///\n    /// @return The amount of convex tokens.\n    function _getEarnedConvex(uint256 amountCurve) internal view returns (uint256) {\n        uint256 supply      = convexToken.totalSupply();\n        uint256 cliff       = supply / convexToken.reductionPerCliff();\n        uint256 totalCliffs = convexToken.totalCliffs();\n\n        if (cliff >= totalCliffs) return 0;\n\n        uint256 reduction = totalCliffs - cliff;\n        uint256 earned    = amountCurve * reduction / totalCliffs;\n\n        uint256 available = convexToken.maxSupply() - supply;\n        return earned > available ? available : earned;\n    }\n\n    /// @dev Mints 3pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of 3pool tokens minted.\n    function _mintThreePoolTokens(\n        uint256[NUM_STABLE_COINS] calldata amounts\n    ) internal returns (uint256 minted) {\n        IERC20[NUM_STABLE_COINS] memory tokens = _threePoolAssetCache;\n\n        IERC20 threePoolToken = getTokenForMetaPoolAsset(MetaPoolAsset.THREE_POOL);\n\n        uint256 threePoolDecimals = SafeERC20.expectDecimals(address(threePoolToken));\n        uint256 normalizedTotal   = 0;\n\n        for (uint256 i = 0; i < NUM_STABLE_COINS; i++) {\n            if (amounts[i] == 0) continue;\n\n            uint256 tokenDecimals   = SafeERC20.expectDecimals(address(tokens[i]));\n            uint256 missingDecimals = threePoolDecimals - tokenDecimals;\n\n            normalizedTotal += amounts[i] * 10**missingDecimals;\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(tokens[i]), address(threePool), 0);\n            SafeERC20.safeApprove(address(tokens[i]), address(threePool), amounts[i]);\n        }\n\n        // Calculate what the normalized value of the tokens is.\n        uint256 expectedOutput = normalizedTotal * CURVE_PRECISION / threePool.get_virtual_price();\n\n        // Calculate the minimum amount of 3pool lp tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one 3pool lp token.\n        uint256 minimumMintAmount = expectedOutput * threePoolSlippage / SLIPPAGE_PRECISION;\n\n        // Record the amount of 3pool lp tokens that we start with before adding liquidity\n        // so that we can determine how many we minted.\n        uint256 startingBalance = threePoolToken.balanceOf(address(this));\n\n        // Add the liquidity to the pool.\n        threePool.add_liquidity(amounts, minimumMintAmount);\n\n        // Calculate how many 3pool lp tokens were minted.\n        minted = threePoolToken.balanceOf(address(this)) - startingBalance;\n\n        emit MintThreePoolTokens(amounts, minted);\n    }\n\n    /// @dev Mints 3pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the 3pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of 3pool tokens minted.\n    function _mintThreePoolTokens(\n        ThreePoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 minted) {\n        IERC20 token          = getTokenForThreePoolAsset(asset);\n        IERC20 threePoolToken = getTokenForMetaPoolAsset(MetaPoolAsset.THREE_POOL);\n\n        uint256 threePoolDecimals = SafeERC20.expectDecimals(address(threePoolToken));\n        uint256 missingDecimals   = threePoolDecimals - SafeERC20.expectDecimals(address(token));\n\n        uint256[NUM_STABLE_COINS] memory amounts;\n        amounts[uint256(asset)] = amount;\n\n        // Calculate the minimum amount of 3pool lp tokens that we are expecting out when\n        // adding single sided liquidity. This value is based off the optimistic assumption that\n        // one of each token is approximately equal to one 3pool lp token.\n        uint256 normalizedAmount  = amount * 10**missingDecimals;\n        uint256 expectedOutput    = normalizedAmount * CURVE_PRECISION / threePool.get_virtual_price();\n        uint256 minimumMintAmount = expectedOutput * threePoolSlippage / SLIPPAGE_PRECISION;\n\n        // Record the amount of 3pool lp tokens that we start with before adding liquidity\n        // so that we can determine how many we minted.\n        uint256 startingBalance = threePoolToken.balanceOf(address(this));\n\n        // For assets like USDT, the approval must be first set to zero before updating it.\n        SafeERC20.safeApprove(address(token), address(threePool), 0);\n        SafeERC20.safeApprove(address(token), address(threePool), amount);\n\n        // Add the liquidity to the pool.\n        threePool.add_liquidity(amounts, minimumMintAmount);\n\n        // Calculate how many 3pool lp tokens were minted.\n        minted = threePoolToken.balanceOf(address(this)) - startingBalance;\n\n        emit MintThreePoolTokens(asset, amount, minted);\n    }\n\n    /// @dev Burns 3pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of 3pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function _burnThreePoolTokens(\n        ThreePoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 withdrawn) {\n        IERC20 token          = getTokenForThreePoolAsset(asset);\n        IERC20 threePoolToken = getTokenForMetaPoolAsset(MetaPoolAsset.THREE_POOL);\n\n        uint256 index = uint256(asset);\n\n        uint256 threePoolDecimals = SafeERC20.expectDecimals(address(threePoolToken));\n        uint256 missingDecimals   = threePoolDecimals - SafeERC20.expectDecimals(address(token));\n\n        // Calculate the minimum amount of underlying tokens that we are expecting out when\n        // removing single sided liquidity. This value is based off the optimistic assumption that\n        // one of each token is approximately equal to one 3pool lp token.\n        uint256 normalizedAmount = amount * threePoolSlippage / SLIPPAGE_PRECISION;\n        uint256 expectedOutput   = normalizedAmount * threePool.get_virtual_price() / CURVE_PRECISION;\n        uint256 minimumAmountOut = expectedOutput / 10**missingDecimals;\n\n        // Record the amount of underlying tokens that we start with before removing liquidity\n        // so that we can determine how many we withdrew from the pool.\n        uint256 startingBalance = token.balanceOf(address(this));\n\n        SafeERC20.safeApprove(address(threePoolToken), address(threePool), 0);\n        SafeERC20.safeApprove(address(threePoolToken), address(threePool), amount);\n\n        // Remove the liquidity from the pool.\n        threePool.remove_liquidity_one_coin(amount, int128(uint128(index)), minimumAmountOut);\n\n        // Calculate how many underlying tokens that were withdrawn.\n        withdrawn = token.balanceOf(address(this)) - startingBalance;\n\n        emit BurnThreePoolTokens(asset, amount, withdrawn);\n    }\n\n    /// @dev Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function _mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) internal returns (uint256 minted) {\n        IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            if (amounts[i] == 0) continue;\n\n            total += amounts[i];\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), 0);\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), amounts[i]);\n        }\n\n        // Calculate the minimum amount of 3pool lp tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one 3pool lp token.\n        uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity(amounts, minimumMintAmount);\n\n        emit MintMetaPoolTokens(amounts, minted);\n    }\n\n    /// @dev Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function _mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 minted) {\n        IERC20 token = getTokenForMetaPoolAsset(asset);\n\n        uint256[NUM_META_COINS] memory amounts;\n        amounts[uint256(asset)] = amount;\n\n        // Calculate the minimum amount of 3pool lp tokens that we are expecting out when\n        // adding single sided liquidity. This value is based off the optimistic assumption that\n        uint256 minimumMintAmount = amount * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // For assets like USDT, the approval must be first set to zero before updating it.\n        SafeERC20.safeApprove(address(token), address(metaPool), 0);\n        SafeERC20.safeApprove(address(token), address(metaPool), amount);\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity(amounts, minimumMintAmount);\n\n        emit MintMetaPoolTokens(asset, amount, minted);\n    }\n\n    /// @dev Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function _burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 withdrawn) {\n        uint256 index = uint256(asset);\n\n        // Calculate the minimum amount of the meta pool asset that we are expecting out when\n        // removing single sided liquidity. This value is based off the optimistic assumption that\n        // one of each token is approximately equal to one meta pool lp token.\n        uint256 expectedOutput   = amount * metaPool.get_virtual_price() / CURVE_PRECISION;\n        uint256 minimumAmountOut = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Remove the liquidity from the pool.\n        withdrawn = metaPool.remove_liquidity_one_coin(\n            amount,\n            int128(uint128(index)),\n            minimumAmountOut\n        );\n\n        emit BurnMetaPoolTokens(asset, amount, withdrawn);\n    }\n\n    /// @dev Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function _depositMetaPoolTokens(uint256 amount) internal returns (bool success) {\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), 0);\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), amount);\n\n        success = convexBooster.deposit(convexPoolId, amount, true /* always stake into rewards */);\n\n        emit DepositMetaPoolTokens(amount, success);\n    }\n\n    /// @dev Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function _withdrawMetaPoolTokens(uint256 amount) internal returns (bool success) {\n        success = convexRewards.withdrawAndUnwrap(amount, false /* never claim */);\n        emit WithdrawMetaPoolTokens(amount, success);\n    }\n\n    /// @dev Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function _claimRewards() internal returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @dev Gets the minimum of two integers.\n    ///\n    /// @param x The first integer.\n    /// @param y The second integer.\n    ///\n    /// @return The minimum value.\n    function min(uint256 x , uint256 y) private pure returns (uint256) {\n        return x > y ? y : x;\n    }\n\n    /// @dev Gets the absolute value of the difference of two integers.\n    ///\n    /// @param x The first integer.\n    /// @param y The second integer.\n    ///\n    /// @return The absolute value.\n    function abs(uint256 x , uint256 y) private pure returns (uint256) {\n        return x > y ? x - y : y - x;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport {IllegalArgument, IllegalState, Unauthorized} from \"./base/Errors.sol\";\nimport {Multicall} from \"./base/Multicall.sol\";\nimport {Mutex} from \"./base/Mutex.sol\";\n\nimport {IERC20TokenReceiver} from \"./interfaces/IERC20TokenReceiver.sol\";\nimport {IWETH9} from \"./interfaces/external/IWETH9.sol\";\nimport {IConvexBooster} from \"./interfaces/external/convex/IConvexBooster.sol\";\nimport {IConvexRewards} from \"./interfaces/external/convex/IConvexRewards.sol\";\nimport {IConvexToken} from \"./interfaces/external/convex/IConvexToken.sol\";\n\nimport {\n    IEthStableMetaPool,\n    N_COINS as NUM_META_COINS\n} from \"./interfaces/external/curve/IEthStableMetaPool.sol\";\n\nimport {SafeERC20} from \"./libraries/SafeERC20.sol\";\n\n/// @notice A struct used to define initialization parameters. This is not included\n///         in the contract to prevent naming collisions.\nstruct InitializationParams {\n    address admin;\n    address operator;\n    address rewardReceiver;\n    address transmuterBuffer;\n    IWETH9 weth;\n    IERC20 curveToken;\n    IEthStableMetaPool metaPool;\n    uint256 metaPoolSlippage;\n    IConvexToken convexToken;\n    IConvexBooster convexBooster;\n    IConvexRewards convexRewards;\n    uint256 convexPoolId;\n}\n\n/// @dev The amount of precision that slippage parameters have.\nuint256 constant SLIPPAGE_PRECISION = 1e4;\n\n/// @dev The amount of precision that curve pools use for price calculations.\nuint256 constant CURVE_PRECISION = 1e18;\n\n/// @notice Enumerations for meta pool assets.\n///\n/// @dev Do not change the order of these fields.\nenum MetaPoolAsset {\n    ETH, ALETH\n}\n\n/// @title  EthAssetManager\n/// @author Alchemix Finance\ncontract EthAssetManager is Multicall, Mutex, IERC20TokenReceiver {\n    /// @notice Emitted when the admin is updated.\n    ///\n    /// @param admin The admin.\n    event AdminUpdated(address admin);\n\n    /// @notice Emitted when the pending admin is updated.\n    ///\n    /// @param pendingAdmin The pending admin.\n    event PendingAdminUpdated(address pendingAdmin);\n\n    /// @notice Emitted when the operator is updated.\n    ///\n    /// @param operator The operator.\n    event OperatorUpdated(address operator);\n\n    /// @notice Emitted when the reward receiver is updated.\n    ///\n    /// @param rewardReceiver The reward receiver.\n    event RewardReceiverUpdated(address rewardReceiver);\n\n    /// @notice Emitted when the transmuter buffer is updated.\n    ///\n    /// @param transmuterBuffer The transmuter buffer.\n    event TransmuterBufferUpdated(address transmuterBuffer);\n\n    /// @notice Emitted when the meta pool slippage is updated.\n    ///\n    /// @param metaPoolSlippage The meta pool slippage.\n    event MetaPoolSlippageUpdated(uint256 metaPoolSlippage);\n\n    /// @notice Emitted when meta pool tokens are minted.\n    ///\n    /// @param amounts               The amounts of each meta pool asset used to mint liquidity.\n    /// @param mintedThreePoolTokens The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(uint256[NUM_META_COINS] amounts, uint256 mintedThreePoolTokens);\n\n    /// @notice Emitted when meta tokens are minted.\n    ///\n    /// @param asset  The asset used to mint meta pool tokens.\n    /// @param amount The amount of the asset used to mint meta pool tokens.\n    /// @param minted The amount of meta pool tokens minted.\n    event MintMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 minted);\n\n    /// @notice Emitted when meta pool tokens are burned.\n    ///\n    /// @param asset     The meta pool asset that was received.\n    /// @param amount    The amount of meta pool tokens that were burned.\n    /// @param withdrawn The amount of the asset that was withdrawn.\n    event BurnMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 withdrawn);\n\n    /// @notice Emitted when meta pool tokens are deposited into convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were deposited.\n    /// @param success If the operation was successful.\n    event DepositMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when meta pool tokens are withdrawn from convex.\n    ///\n    /// @param amount  The amount of meta pool tokens that were withdrawn.\n    /// @param success If the operation was successful.\n    event WithdrawMetaPoolTokens(uint256 amount, bool success);\n\n    /// @notice Emitted when convex rewards are claimed.\n    ///\n    /// @param success      If the operation was successful.\n    /// @param amountCurve  The amount of curve tokens sent to the reward recipient.\n    /// @param amountConvex The amount of convex tokens sent to the reward recipient.\n    event ClaimRewards(bool success, uint256 amountCurve, uint256 amountConvex);\n\n    /// @notice Emitted when ethereum is sent to the transmuter buffer.\n    ///\n    /// @param amount The amount of ethereum that was reclaimed.\n    event ReclaimEth(uint256 amount);\n\n    /// @notice Emitted when a token is swept to the admin.\n    ///\n    /// @param token  The token that was swept.\n    /// @param amount The amount of the token that was swept.\n    event SweepToken(address token, uint256 amount);\n\n    /// @notice Emitted when ethereum is swept to the admin.\n    ///\n    /// @param amount The amount of the token that was swept.\n    event SweepEth(uint256 amount);\n\n    /// @notice The admin.\n    address public admin;\n\n    /// @notice The current pending admin.\n    address public pendingAdmin;\n\n    /// @notice The operator.\n    address public operator;\n\n    // @notice The reward receiver.\n    address public rewardReceiver;\n\n    /// @notice The transmuter buffer.\n    address public transmuterBuffer;\n\n    /// @notice The wrapped ethereum token.\n    IWETH9 public weth;\n\n    /// @notice The curve token.\n    IERC20 public immutable curveToken;\n\n    /// @notice The meta pool contract.\n    IEthStableMetaPool public immutable metaPool;\n\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\n    ///         from the meta pool. In units of basis points.\n    uint256 public metaPoolSlippage;\n\n    /// @notice The convex token.\n    IConvexToken public immutable convexToken;\n\n    /// @notice The convex booster contract.\n    IConvexBooster public immutable convexBooster;\n\n    /// @notice The convex rewards contract.\n    IConvexRewards public immutable convexRewards;\n\n    /// @notice The convex pool identifier.\n    uint256 public immutable convexPoolId;\n\n    /// @dev A cache of the tokens that the meta pool supports.\n    IERC20[NUM_META_COINS] private _metaPoolAssetCache;\n\n    /// @dev A modifier which reverts if the message sender is not the admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) {\n            revert Unauthorized(\"Not admin\");\n        }\n        _;\n    }\n\n    /// @dev A modifier which reverts if the message sender is not the operator.\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert Unauthorized(\"Not operator\");\n        }\n        _;\n    }\n\n    constructor(InitializationParams memory params) {\n        admin            = params.admin;\n        operator         = params.operator;\n        rewardReceiver   = params.rewardReceiver;\n        transmuterBuffer = params.transmuterBuffer;\n        weth             = params.weth;\n        curveToken       = params.curveToken;\n        metaPool         = params.metaPool;\n        metaPoolSlippage = params.metaPoolSlippage;\n        convexToken      = params.convexToken;\n        convexBooster    = params.convexBooster;\n        convexRewards    = params.convexRewards;\n        convexPoolId     = params.convexPoolId;\n\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\n            if (_metaPoolAssetCache[i] == IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\n                _metaPoolAssetCache[i] = weth;\n            }\n        }\n\n        emit AdminUpdated(admin);\n        emit OperatorUpdated(operator);\n        emit RewardReceiverUpdated(rewardReceiver);\n        emit TransmuterBufferUpdated(transmuterBuffer);\n        emit MetaPoolSlippageUpdated(metaPoolSlippage);\n    }\n\n    receive() external payable { }\n\n    /// @notice Gets the amount of meta pool tokens that this contract has in reserves.\n    ///\n    /// @return The reserves.\n    function metaPoolReserves() external view returns (uint256) {\n        return metaPool.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of a meta pool asset that this contract has in reserves.\n    ///\n    /// @param asset The meta pool asset.\n    ///\n    /// @return The reserves.\n    function metaPoolAssetReserves(MetaPoolAsset asset) external view returns (uint256) {\n        IERC20 token = getTokenForMetaPoolAsset(asset);\n        if (asset == MetaPoolAsset.ETH) {\n            return address(this).balance + token.balanceOf(address(this));\n        }\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Gets the amount of ethereum that one alETH is worth.\n    ///\n    /// @return The amount of the underlying token.\n    function exchangeRate() public view returns (uint256) {\n        IERC20 alETH = getTokenForMetaPoolAsset(MetaPoolAsset.ALETH);\n\n        uint256[NUM_META_COINS] memory metaBalances = metaPool.get_balances();\n        return metaPool.get_dy(\n            int128(uint128(uint256(MetaPoolAsset.ALETH))),\n            int128(uint128(uint256(MetaPoolAsset.ETH))),\n            10**SafeERC20.expectDecimals(address(alETH)),\n            metaBalances\n        );\n    }\n\n    /// @notice Gets the amount of curve tokens and convex tokens that can be claimed.\n    ///\n    /// @return amountCurve  The amount of curve tokens available.\n    /// @return amountConvex The amount of convex tokens available.\n    function claimableRewards() public view returns (uint256 amountCurve, uint256 amountConvex) {\n        amountCurve  = convexRewards.earned(address(this));\n        amountConvex = _getEarnedConvex(amountCurve);\n    }\n\n    /// @notice Gets the ERC20 token associated with a meta pool asset.\n    ///\n    /// @param asset The asset to get the token for.\n    ///\n    /// @return The token.\n    function getTokenForMetaPoolAsset(MetaPoolAsset asset) public view returns (IERC20) {\n        uint256 index = uint256(asset);\n        if (index >= NUM_META_COINS) {\n            revert IllegalArgument(\"Asset index out of bounds\");\n        }\n        return _metaPoolAssetCache[index];\n    }\n\n    /// @notice Begins the 2-step process of setting the administrator.\n    ///\n    /// The caller must be the admin. Setting the pending timelock to the zero address will stop\n    /// the process of setting a new timelock.\n    ///\n    /// @param value The value to set the pending timelock to.\n    function setPendingAdmin(address value) external onlyAdmin {\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @notice Completes the 2-step process of setting the administrator.\n    ///\n    /// The pending admin must be set and the caller must be the pending admin. After this function\n    /// is successfully executed, the admin will be set to the pending admin and the pending admin\n    /// will be reset.\n    function acceptAdmin() external {\n        if (pendingAdmin == address(0)) {\n            revert IllegalState(\"Pending admin unset\");\n        }\n\n        if (pendingAdmin != msg.sender) {\n            revert Unauthorized(\"Not pending admin\");\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @notice Sets the operator.\n    ///\n    /// The caller must be the admin.\n    ///\n    /// @param value The value to set the admin to.\n    function setOperator(address value) external onlyAdmin {\n        operator = value;\n        emit OperatorUpdated(value);\n    }\n\n    /// @notice Sets the reward receiver.\n    ///\n    /// @param value The value to set the reward receiver to.\n    function setRewardReceiver(address value) external onlyAdmin {\n        rewardReceiver = value;\n        emit RewardReceiverUpdated(value);\n    }\n\n    /// @notice Sets the transmuter buffer.\n    ///\n    /// @param value The value to set the transmuter buffer to.\n    function setTransmuterBuffer(address value) external onlyAdmin {\n        transmuterBuffer = value;\n        emit TransmuterBufferUpdated(value);\n    }\n\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing meta pool\n    ///         assets. The slippage has a resolution of 6 decimals.\n    ///\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\n    /// fine adjustment in a short time window.\n    ///\n    /// @param value The value to set the slippage to.\n    function setMetaPoolSlippage(uint256 value) external onlyOperator {\n        if (value > SLIPPAGE_PRECISION) {\n            revert IllegalArgument(\"Slippage not in range\");\n        }\n        metaPoolSlippage = value;\n        emit MetaPoolSlippageUpdated(value);\n    }\n\n    /// @notice Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(amounts);\n    }\n\n    /// @notice Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 minted) {\n        return _mintMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256 withdrawn) {\n        return _burnMetaPoolTokens(asset, amount);\n    }\n\n    /// @notice Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function depositMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _depositMetaPoolTokens(amount);\n    }\n\n    /// @notice Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function withdrawMetaPoolTokens(\n        uint256 amount\n    ) external lock onlyOperator returns (bool success) {\n        return _withdrawMetaPoolTokens(amount);\n    }\n\n    /// @notice Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function claimRewards() external lock onlyOperator returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @notice Flushes meta pool assets into convex by minting meta pool tokens using the assets,\n    ///         and then depositing the meta pool tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param amounts The amounts of the meta pool assets to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        uint256[NUM_META_COINS] calldata amounts\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(amounts);\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Flushes a meta pool asset into convex by minting meta pool tokens using the asset,\n    ///         and then depositing the meta pool tokens into convex.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param asset  The meta pool asset to flush.\n    /// @param amount The amount of the meta pool asset to flush.\n    ///\n    /// @return The amount of meta pool tokens deposited into convex.\n    function flush(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) external lock onlyOperator returns (uint256) {\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(asset, amount);\n\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\n            revert IllegalState(\"Deposit into convex failed\");\n        }\n\n        return mintedMetaPoolTokens;\n    }\n\n    /// @notice Recalls ethereum into reserves by withdrawing meta pool tokens from convex and\n    ///         burning the meta pool tokens for ethereum.\n    ///\n    /// This function is provided for ease of use.\n    ///\n    /// @param amount The amount of the meta pool tokens to withdraw from convex and burn.\n    ///\n    /// @return The amount of ethereum recalled.\n    function recall(uint256 amount) external lock onlyOperator returns (uint256) {\n        if (!_withdrawMetaPoolTokens(amount)) {\n            revert IllegalState(\"Withdraw from convex failed\");\n        }\n        return _burnMetaPoolTokens(MetaPoolAsset.ETH, amount);\n    }\n\n    /// @notice Reclaims a three pool asset to the transmuter buffer.\n    ///\n    /// @param amount The amount of ethereum to reclaim.\n    function reclaimEth(uint256 amount) public lock onlyAdmin {\n        uint256 balance;\n        if (amount > (balance = weth.balanceOf(address(this)))) weth.deposit{value: amount - balance}();\n\n        SafeERC20.safeTransfer(address(weth), transmuterBuffer, amount);\n\n        IERC20TokenReceiver(transmuterBuffer).onERC20Received(address(weth), amount);\n\n        emit ReclaimEth(amount);\n    }\n\n    /// @notice Sweeps a token out of the contract to the admin.\n    ///\n    /// @param token  The token to sweep.\n    /// @param amount The amount of the token to sweep.\n    function sweepToken(address token, uint256 amount) external lock onlyAdmin {\n        SafeERC20.safeTransfer(address(token), msg.sender, amount);\n        emit SweepToken(token, amount);\n    }\n\n    /// @notice Sweeps ethereum out of the contract to the admin.\n    ///\n    /// @param amount The amount of ethereum to sweep.\n    ///\n    /// @return result The result from the call to transfer ethereum.\n    function sweepEth(\n        uint256 amount\n    ) external lock onlyAdmin returns (bytes memory result) {\n        (bool success, bytes memory result) = admin.call{value: amount}(new bytes(0));\n        if (!success) {\n            revert IllegalState(\"Transfer failed\");\n        }\n\n        emit SweepEth(amount);\n\n        return result;\n    }\n\n    /// @inheritdoc IERC20TokenReceiver\n    ///\n    /// @dev This function is required in order to receive tokens from the conduit.\n    function onERC20Received(address token, uint256 value) external { /* noop */ }\n\n    /// @dev Gets the amount of convex that will be minted for an amount of curve tokens.\n    ///\n    /// @param amountCurve The amount of curve tokens.\n    ///\n    /// @return The amount of convex tokens.\n    function _getEarnedConvex(uint256 amountCurve) internal view returns (uint256) {\n        uint256 supply      = convexToken.totalSupply();\n        uint256 cliff       = supply / convexToken.reductionPerCliff();\n        uint256 totalCliffs = convexToken.totalCliffs();\n\n        if (cliff >= totalCliffs) return 0;\n\n        uint256 reduction = totalCliffs - cliff;\n        uint256 earned    = amountCurve * reduction / totalCliffs;\n\n        uint256 available = convexToken.maxSupply() - supply;\n        return earned > available ? available : earned;\n    }\n\n    /// @dev Mints meta pool tokens with a combination of assets.\n    ///\n    /// @param amounts The amounts of the assets to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function _mintMetaPoolTokens(\n        uint256[NUM_META_COINS] calldata amounts\n    ) internal returns (uint256 minted) {\n        IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;\n\n        uint256 total = 0;\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\n            // Skip over approving WETH since we are directly swapping ETH.\n            if (i == uint256(MetaPoolAsset.ETH)) continue;\n\n            if (amounts[i] == 0) continue;\n\n            total += amounts[i];\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), 0);\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), amounts[i]);\n        }\n\n        // Calculate the minimum amount of meta pool tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one meta pool token.\n        uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        uint256 value = amounts[uint256(MetaPoolAsset.ETH)];\n\n        // Ensure that the contract has the amount of ethereum required.\n        if (value > address(this).balance) weth.withdraw(value - address(this).balance);\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity{value: value}(amounts, minimumMintAmount);\n\n        emit MintMetaPoolTokens(amounts, minted);\n    }\n\n    /// @dev Mints meta pool tokens with an asset.\n    ///\n    /// @param asset  The asset to deposit into the meta pool.\n    /// @param amount The amount of the asset to deposit.\n    ///\n    /// @return minted The number of meta pool tokens minted.\n    function _mintMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 minted) {\n        uint256[NUM_META_COINS] memory amounts;\n        amounts[uint256(asset)] = amount;\n\n        // Calculate the minimum amount of meta pool tokens that we are expecting out when\n        // adding liquidity for all of the assets. This value is based off the optimistic\n        // assumption that one of each token is approximately equal to one meta pool token.\n        uint256 minimumMintAmount = amount * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Set an approval if not working with ethereum.\n        if (asset != MetaPoolAsset.ETH) {\n            IERC20 token = getTokenForMetaPoolAsset(asset);\n\n            // For assets like USDT, the approval must be first set to zero before updating it.\n            SafeERC20.safeApprove(address(token), address(metaPool), 0);\n            SafeERC20.safeApprove(address(token), address(metaPool), amount);\n        }\n\n        uint256 value = asset == MetaPoolAsset.ETH\n            ? amounts[uint256(MetaPoolAsset.ETH)]\n            : 0;\n\n        // Ensure that the contract has the amount of ethereum required.\n        if (value > address(this).balance) weth.withdraw(value - address(this).balance);\n\n        // Add the liquidity to the pool.\n        minted = metaPool.add_liquidity{value: value}(amounts, minimumMintAmount);\n\n        emit MintMetaPoolTokens(asset, amount, minted);\n    }\n\n    /// @dev Burns meta pool tokens to withdraw an asset.\n    ///\n    /// @param asset  The asset to withdraw.\n    /// @param amount The amount of meta pool tokens to burn.\n    ///\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\n    function _burnMetaPoolTokens(\n        MetaPoolAsset asset,\n        uint256 amount\n    ) internal returns (uint256 withdrawn) {\n        uint256 index = uint256(asset);\n\n        // Calculate the minimum amount of the meta pool asset that we are expecting out when\n        // removing single sided liquidity. This value is based off the optimistic assumption that\n        // one of each token is approximately equal to one meta pool lp token.\n        uint256 expectedOutput   = amount * metaPool.get_virtual_price() / CURVE_PRECISION;\n        uint256 minimumAmountOut = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\n\n        // Remove the liquidity from the pool.\n        withdrawn = metaPool.remove_liquidity_one_coin(\n            amount,\n            int128(uint128(index)),\n            minimumAmountOut\n        );\n\n        emit BurnMetaPoolTokens(asset, amount, withdrawn);\n    }\n\n    /// @dev Deposits and stakes meta pool tokens into convex.\n    ///\n    /// @param amount The amount of meta pool tokens to deposit.\n    ///\n    /// @return success If the tokens were successfully deposited.\n    function _depositMetaPoolTokens(uint256 amount) internal returns (bool success) {\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), 0);\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), amount);\n\n        success = convexBooster.deposit(convexPoolId, amount, true /* always stake into rewards */);\n\n        emit DepositMetaPoolTokens(amount, success);\n    }\n\n    /// @dev Withdraws and unwraps meta pool tokens from convex.\n    ///\n    /// @param amount The amount of meta pool tokens to withdraw.\n    ///\n    /// @return success If the tokens were successfully withdrawn.\n    function _withdrawMetaPoolTokens(uint256 amount) internal returns (bool success) {\n        success = convexRewards.withdrawAndUnwrap(amount, false /* never claim */);\n        emit WithdrawMetaPoolTokens(amount, success);\n    }\n\n    /// @dev Claims convex, curve, and auxiliary rewards.\n    ///\n    /// @return success If the claim was successful.\n    function _claimRewards() internal returns (bool success) {\n        success = convexRewards.getReward();\n\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\n        uint256 convexBalance = convexToken.balanceOf(address(this));\n\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\n\n        emit ClaimRewards(success, curveBalance, convexBalance);\n    }\n\n    /// @dev Gets the minimum of two integers.\n    ///\n    /// @param x The first integer.\n    /// @param y The second integer.\n    ///\n    /// @return The minimum value.\n    function min(uint256 x , uint256 y) private pure returns (uint256) {\n        return x > y ? y : x;\n    }\n\n    /// @dev Gets the absolute value of the difference of two integers.\n    ///\n    /// @param x The first integer.\n    /// @param y The second integer.\n    ///\n    /// @return The absolute value.\n    function abs(uint256 x , uint256 y) private pure returns (uint256) {\n        return x > y ? x - y : y - x;\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {stdCheats} from \"forge-std/stdlib.sol\";\nimport {console} from \"forge-std/console.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\n\nimport {DSTestPlus} from \"./utils/DSTestPlus.sol\";\nimport {EthAssetManagerUser} from \"./utils/users/EthAssetManagerUser.sol\";\n\nimport {\n    EthAssetManager,\n    MetaPoolAsset,\n    SLIPPAGE_PRECISION,\n    CURVE_PRECISION,\n    InitializationParams as ManagerInitializationParams\n} from \"../EthAssetManager.sol\";\n\nimport {ITransmuterBuffer} from \"../interfaces/ITransmuterBuffer.sol\";\nimport {IERC20TokenReceiver} from \"../interfaces/IERC20TokenReceiver.sol\";\nimport {IWETH9} from \"../interfaces/external/IWETH9.sol\";\nimport {IConvexBooster} from \"../interfaces/external/convex/IConvexBooster.sol\";\nimport {IConvexRewards} from \"../interfaces/external/convex/IConvexRewards.sol\";\nimport {IConvexToken} from \"../interfaces/external/convex/IConvexToken.sol\";\nimport {IEthStableMetaPool} from \"../interfaces/external/curve/IEthStableMetaPool.sol\";\n\ncontract EthAssetManagerTest is DSTestPlus, stdCheats {\n    ITransmuterBuffer constant transmuterBuffer = ITransmuterBuffer(0xbc2FB245594a68c927C930FBE2d00680A8C90B9e);\n    address constant transmuterBufferAdmin = address(0x9e2b6378ee8ad2A4A95Fe481d63CAba8FB0EBBF9);\n    IERC20 constant crv = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    IEthStableMetaPool constant metaPool = IEthStableMetaPool(0xC4C319E2D4d66CcA4464C0c2B32c9Bd23ebe784e);\n    IConvexToken constant cvx = IConvexToken(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    IConvexBooster constant convexBooster = IConvexBooster(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    IConvexRewards constant convexRewards = IConvexRewards(0x48Bc302d8295FeA1f8c3e7F57D4dDC9981FEE410);\n    IWETH9 constant weth = IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    EthAssetManager manager;\n    IERC20 alETH;\n\n    function setUp() external {\n        manager = new EthAssetManager(ManagerInitializationParams({\n            admin:             address(this),\n            operator:          address(this),\n            rewardReceiver:    address(0xbeef),\n            transmuterBuffer:  address(transmuterBuffer),\n            weth:              weth,\n            curveToken:        crv,\n            metaPool:          metaPool,\n            metaPoolSlippage:  SLIPPAGE_PRECISION - 30, // 30 bps, 0.3%\n            convexToken:       cvx,\n            convexBooster:     convexBooster,\n            convexRewards:     convexRewards,\n            convexPoolId:      49\n        }));\n\n        alETH = manager.getTokenForMetaPoolAsset(MetaPoolAsset.ALETH);\n    }\n\n    receive() external payable {}\n\n    function testSetPendingAdmin() external {\n        manager.setPendingAdmin(address(0xdead));\n        assertEq(manager.pendingAdmin(), address(0xdead));\n    }\n\n    function testFailSetPendingAdminSenderNotAdmin() external {\n        hevm.prank(address(0xdead));\n        manager.setPendingAdmin(address(0xbeef));\n    }\n\n    function testAcceptAdmin() external {\n        EthAssetManagerUser pendingAdmin = new EthAssetManagerUser(manager);\n\n        manager.setPendingAdmin(address(pendingAdmin));\n        pendingAdmin.acceptAdmin();\n\n        assertEq(manager.pendingAdmin(), address(0));\n        assertEq(manager.admin(), address(pendingAdmin));\n    }\n\n    function testFailAcceptAdminNotPendingAdmin() external {\n        EthAssetManagerUser pendingAdmin = new EthAssetManagerUser(manager);\n\n        manager.setPendingAdmin(address(pendingAdmin));\n\n        hevm.prank(address(0xdead));\n        manager.acceptAdmin();\n    }\n\n    function testFailAcceptAdminPendingAdminUnset() external {\n        manager.acceptAdmin();\n    }\n\n    function testSetRewardReceiver() external {\n        manager.setRewardReceiver(address(0xdead));\n        assertEq(manager.rewardReceiver(), address(0xdead));\n    }\n\n    function testFailSetRewardReceiverSenderNotAdmin() external {\n        hevm.prank(address(0xdead));\n        manager.setRewardReceiver(address(0xbeef));\n    }\n\n    function testSetTransmuterBuffer() external {\n        manager.setTransmuterBuffer(address(0xdead));\n        assertEq(manager.transmuterBuffer(), address(0xdead));\n    }\n\n    function testFailSetTransmuterBufferSenderNotAdmin() external {\n        hevm.prank(address(0xdead));\n        manager.setTransmuterBuffer(address(0xbeef));\n    }\n\n    function testSetMetaPoolSlippage() external {\n        manager.setMetaPoolSlippage(1e4);\n        assertEq(manager.metaPoolSlippage(), 1e4);\n    }\n\n    function testSetMetaPoolSlippage(uint256 value) external {\n        value = bound(value, 0, SLIPPAGE_PRECISION);\n        manager.setMetaPoolSlippage(value);\n\n        assertEq(manager.metaPoolSlippage(), value);\n    }\n\n    function testFailSetMetaPoolSlippageSenderNotAdmin() external {\n        hevm.prank(address(0xdead));\n        manager.setMetaPoolSlippage(1e4);\n    }\n\n    function testMintMetaPoolTokensMultipleAssets() external {\n        tip(address(weth), address(manager), 1e18);\n        tip(address(alETH), address(manager), 1e18);\n\n        uint256[2] memory amounts;\n        amounts[uint256(MetaPoolAsset.ETH)]   = 1e18;\n        amounts[uint256(MetaPoolAsset.ALETH)] = 1e18;\n\n        uint256 expectedOutput = 2e18 * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minted         = manager.mintMetaPoolTokens(amounts);\n\n        assertEq(address(manager).balance, 0);\n        assertEq(weth.balanceOf(address(manager)), 0);\n        assertEq(metaPool.balanceOf(address(manager)), minted);\n        assertGt(minted, expectedOutput * manager.metaPoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testMintMetaPoolTokensMultipleAssetsETH() external {\n        hevm.deal(address(manager), 1e18);\n\n        uint256[2] memory amounts;\n        amounts[uint256(MetaPoolAsset.ETH)] = 1e18;\n\n        uint256 expectedOutput = 1e18 * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minted         = manager.mintMetaPoolTokens(amounts);\n\n        assertEq(address(manager).balance, 0);\n        assertEq(metaPool.balanceOf(address(manager)), minted);\n        assertGt(minted, expectedOutput * manager.metaPoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testMintMetaPoolTokensMultipleAssetsWETH() external {\n        tip(address(weth), address(manager), 1e18);\n\n        uint256[2] memory amounts;\n        amounts[uint256(MetaPoolAsset.ETH)] = 1e18;\n\n        uint256 expectedOutput = 1e18 * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minted         = manager.mintMetaPoolTokens(amounts);\n\n        assertEq(address(manager).balance, 0);\n        assertEq(metaPool.balanceOf(address(manager)), minted);\n        assertGt(minted, expectedOutput * manager.metaPoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testMintMetaPoolTokensMultipleAssetsSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n\n        uint256[2] memory amounts;\n        manager.mintMetaPoolTokens(amounts);\n    }\n\n    function testMintMetaPoolTokensWETH() external {\n        tip(address(weth), address(manager), 1e18);\n\n        uint256 expectedOutput = 1e18 * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minted         = manager.mintMetaPoolTokens(MetaPoolAsset.ETH, 1e18);\n\n        assertEq(weth.balanceOf(address(manager)), 0);\n        assertEq(metaPool.balanceOf(address(manager)), minted);\n        assertGt(minted, expectedOutput * manager.metaPoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testMintMetaPoolTokensETH() external {\n        hevm.deal(address(manager), 1e18);\n\n        uint256 expectedOutput = 1e18 * CURVE_PRECISION / metaPool.get_virtual_price();\n        uint256 minted         = manager.mintMetaPoolTokens(MetaPoolAsset.ETH, 1e18);\n\n        assertEq(address(manager).balance, 0);\n        assertEq(metaPool.balanceOf(address(manager)), minted);\n        assertGt(minted, expectedOutput * manager.metaPoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testMintMetaPoolTokensSingleAssetSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.mintMetaPoolTokens(MetaPoolAsset.ETH, 0);\n    }\n\n    function testBurnMetaPoolTokens() external {\n        tip(address(metaPool), address(manager), 1e18);\n\n        uint256 expectedOutput = 1e18 * metaPool.get_virtual_price() / CURVE_PRECISION;\n        uint256 withdrawn      = manager.burnMetaPoolTokens(MetaPoolAsset.ALETH, 1e18);\n\n        assertEq(metaPool.balanceOf(address(manager)), 0);\n        assertEq(alETH.balanceOf(address(manager)), withdrawn);\n        assertGt(withdrawn, expectedOutput * manager.metaPoolSlippage() / SLIPPAGE_PRECISION);\n    }\n\n    function testBurnMetaPoolTokensSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.burnMetaPoolTokens(MetaPoolAsset.ETH, 0);\n    }\n\n    function testDepositMetaPoolTokens() external {\n        tip(address(metaPool), address(manager), 1e18);\n\n        assertTrue(manager.depositMetaPoolTokens(1e18));\n        assertEq(convexRewards.balanceOf(address(manager)), 1e18);\n    }\n\n    function testDepositMetaPoolTokensSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.depositMetaPoolTokens(0);\n    }\n\n    function testWithdrawMetaPoolTokens() external {\n        tip(address(metaPool), address(manager), 1e18);\n\n        manager.depositMetaPoolTokens(1e18);\n\n        assertTrue(manager.withdrawMetaPoolTokens(1e18));\n\n        assertEq(convexRewards.balanceOf(address(manager)), 0);\n        assertEq(metaPool.balanceOf(address(manager)), 1e18);\n    }\n\n    function testWithdrawMetaPoolTokensSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.withdrawMetaPoolTokens(0);\n    }\n\n    function testClaimRewards() external {\n        tip(address(metaPool), address(manager), 1e18);\n\n        manager.depositMetaPoolTokens(1e18);\n\n        hevm.warp(block.timestamp + 86400);\n\n        (uint256 earnedCurve, uint256 earnedConvex) = manager.claimableRewards();\n\n        assertTrue(manager.claimRewards());\n        assertEq(crv.balanceOf(manager.rewardReceiver()), earnedCurve);\n        assertEq(cvx.balanceOf(manager.rewardReceiver()), earnedConvex);\n    }\n\n    function testClaimRewardsSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.claimRewards();\n    }\n\n    function testFlushMultipleAssets() external {\n        hevm.deal(address(manager), 1e18);\n\n        tip(address(weth), address(manager), 1e18);\n        tip(address(alETH), address(manager), 1e18);\n\n        uint256[2] memory amounts;\n        amounts[uint256(MetaPoolAsset.ETH)]   = 2e18;\n        amounts[uint256(MetaPoolAsset.ALETH)] = 1e18;\n\n        uint256 minted = manager.flush(amounts);\n\n        assertEq(address(manager).balance, 0);\n        assertEq(weth.balanceOf(address(manager)), 0);\n        assertEq(alETH.balanceOf(address(manager)), 0);\n        assertEq(metaPool.balanceOf(address(manager)), 0);\n        assertEq(convexRewards.balanceOf(address(manager)), minted);\n    }\n\n    function testFlushMultipleAssetsSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.flush(MetaPoolAsset.ETH, 1e18);\n    }\n\n    function testFlushETH() external {\n        hevm.deal(address(manager), 1e18);\n\n        manager.setMetaPoolSlippage(0);\n\n        uint256 minted = manager.flush(MetaPoolAsset.ETH, 1e18);\n\n        assertEq(address(manager).balance, 0);\n        assertEq(metaPool.balanceOf(address(manager)), 0);\n        assertEq(convexRewards.balanceOf(address(manager)), minted);\n    }\n\n    function testFlushWETH() external {\n        tip(address(weth), address(manager), 1e18);\n\n        manager.setMetaPoolSlippage(0);\n\n        uint256 minted = manager.flush(MetaPoolAsset.ETH, 1e18);\n\n        assertEq(weth.balanceOf(address(manager)), 0);\n        assertEq(metaPool.balanceOf(address(manager)), 0);\n        assertEq(convexRewards.balanceOf(address(manager)), minted);\n    }\n\n    function testFlushSingleAssetSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.flush(MetaPoolAsset.ETH, 1e18);\n    }\n\n    function testRecall() external {\n        tip(address(metaPool), address(manager), 1e18);\n\n        manager.depositMetaPoolTokens(1e18);\n\n        manager.setMetaPoolSlippage(0);\n\n        uint256 withdrawn = manager.recall(1e18);\n\n        assertEq(address(manager).balance, withdrawn);\n        assertEq(metaPool.balanceOf(address(manager)), 0);\n        assertEq(convexRewards.balanceOf(address(manager)), 0);\n    }\n\n    function testRecallSenderNotOperator() external {\n        hevm.prank(address(0xdead));\n        expectUnauthorizedError(\"Not operator\");\n        manager.recall(1e18);\n    }\n\n    function testReclaimETH() external {\n        hevm.deal(address(manager), 1e18);\n        tip(address(weth), address(manager), 1e18);\n\n        hevm.prank(transmuterBufferAdmin);\n        transmuterBuffer.setSource(address(manager), true);\n\n        hevm.expectCall(\n            manager.transmuterBuffer(),\n            abi.encodeWithSelector(\n                IERC20TokenReceiver.onERC20Received.selector,\n                address(weth),\n                2e18\n            )\n        );\n\n        manager.reclaimEth(2e18);\n    }\n\n    function testFailReclaimETHSenderNotAdmin() external {\n        tip(address(weth), address(manager), 1e18);\n\n        hevm.prank(address(0xdead));\n        manager.reclaimEth(1e18);\n    }\n\n    function testSweepToken() external {\n        tip(address(weth), address(manager), 1e18);\n\n        manager.sweepToken(address(weth), 1e18);\n\n        assertEq(weth.balanceOf(address(manager)), 0e18);\n        assertEq(weth.balanceOf(manager.admin()), 1e18);\n    }\n\n    function testFailSweepTokenSenderNotAdmin() external {\n        tip(address(weth), address(manager), 1e18);\n\n        hevm.prank(address(0xdead));\n        manager.sweepToken(address(weth), 1e18);\n    }\n\n    function testSweepETH() external {\n        EthAssetManagerUser admin = new EthAssetManagerUser(manager);\n\n        manager.setPendingAdmin(address(admin));\n        admin.acceptAdmin();\n\n        hevm.deal(address(manager), 1e18);\n\n        hevm.prank(address(admin));\n        manager.sweepEth(1e18);\n\n        assertEq(address(manager).balance, 0);\n        assertEq(address(admin).balance, 1e18);\n    }\n\n    function testFailSweepSenderNotAdmin() external {\n        hevm.deal(address(manager), 1e18);\n\n        hevm.prank(address(0xdead));\n        manager.sweepEth(1e18);\n    }\n}\n\n",
        "CodeNames": [
            "ThreePoolAssetManager.t.sol",
            "ThreePoolAssetManager.sol",
            "EthAssetManager.sol",
            "EthAssetManager.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "EthAssetManager.sol and ThreePoolAssetManager.sol",
                "Type": "Decimal handling",
                "Description": "Both contracts treat meta assets as if they have fixed decimals of 18. Minting logic breaks when it's not the case. However, meta tokens decimals aren't controlled.",
                "Repair": "Control the decimals at the construction time or add the meta token decimals to calculations similarly to stables"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./base/Errors.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/transmuter/ITransmuterBuffer.sol\";\nimport \"./interfaces/transmuter/ITransmuterV2.sol\";\n\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/LiquidityMath.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\n\n/// @title  ITransmuterBuffer\n/// @author Alchemix Finance\n///\n/// @notice An interface contract to buffer funds between the Alchemist and the Transmuter\ncontract TransmuterBuffer is ITransmuterBuffer, AccessControl, Initializable {\n    using SafeMath for uint256;\n    using FixedPointMath for FixedPointMath.Number;\n\n    /// @notice The identifier of the role which maintains other roles.\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    /// @notice The identifier of the keeper role.\n    bytes32 public constant KEEPER = keccak256(\"KEEPER\");\n\n    /// @inheritdoc ITransmuterBuffer\n    string public constant override version = \"2.2.0\";\n\n    /// @notice The alchemist address.\n    address public alchemist;\n\n    /// @notice The public transmuter address for each address.\n    mapping(address => address) public transmuter;\n\n    /// @notice The flowRate for each address.\n    mapping(address => uint256) public flowRate;\n\n    /// @notice The last update timestamp gor the flowRate for each address.\n    mapping(address => uint256) public lastFlowrateUpdate;\n\n    /// @notice The amount of flow available per ERC20.\n    mapping(address => uint256) public flowAvailable;\n\n    /// @notice The yieldTokens of each underlying supported by the Alchemist.\n    mapping(address => address[]) public _yieldTokens;\n\n    /// @notice The total amount of an underlying token that has been exchanged into the transmuter, and has not been claimed.\n    mapping(address => uint256) public currentExchanged;\n\n    /// @notice The underlying-tokens registered in the TransmuterBuffer.\n    address[] public registeredUnderlyings;\n\n    /// @notice The debt-token used by the TransmuterBuffer.\n    address public debtToken;\n\n    /// @notice A mapping of weighting schemas to be used in actions taken on the Alchemist (burn, deposit).\n    mapping(address => Weighting) public weightings;\n\n    /// @dev A mapping of addresses to denote permissioned sources of funds\n    mapping(address => bool) public sources;\n\n    /// @dev A mapping of addresses to their respective AMOs.\n    mapping(address => address) public amos;\n\n    /// @dev A mapping of underlying tokens to divert to the AMO.\n    mapping(address => bool) public divertToAmo;\n\n    constructor() initializer {}\n\n    /// @dev Initialize the contract\n    ///\n    /// @param _admin     The governing address of the buffer.\n    /// @param _debtToken The debt token minted by the Alchemist and accepted by the Transmuter.\n    function initialize(address _admin, address _debtToken) external initializer {\n        _setupRole(ADMIN, _admin);\n        _setRoleAdmin(ADMIN, ADMIN);\n        _setRoleAdmin(KEEPER, ADMIN);\n        debtToken = _debtToken;\n    }\n\n    /// @dev Only allows the transmuter to call the modified function\n    ///\n    /// Reverts if the caller is not a correct transmuter.\n    ///\n    /// @param underlyingToken the underlying token associated with the transmuter.\n    modifier onlyTransmuter(address underlyingToken) {\n        if (msg.sender != transmuter[underlyingToken]) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @dev Only allows a governance-permissioned source to call the modified function\n    ///\n    /// Reverts if the caller is not a permissioned source.\n    modifier onlySource() {\n        if (!sources[msg.sender]) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @dev Only calls from the admin address are authorized to pass.\n    modifier onlyAdmin() {\n        if (!hasRole(ADMIN, msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @dev Only calls from a keeper address are authorized to pass.\n    modifier onlyKeeper() {\n        if (!hasRole(KEEPER, msg.sender)) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getWeight(address weightToken, address token)\n        external\n        view\n        override\n        returns (uint256 weight)\n    {\n        return weightings[weightToken].weights[token];\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getAvailableFlow(address underlyingToken)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // total amount of collateral that the buffer controls in the alchemist\n        uint256 totalUnderlyingBuffered = getTotalUnderlyingBuffered(\n            underlyingToken\n        );\n\n        if (totalUnderlyingBuffered < flowAvailable[underlyingToken]) {\n            return totalUnderlyingBuffered;\n        } else {\n            return flowAvailable[underlyingToken];\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getTotalCredit() public view override returns (uint256 credit) {\n        (int256 debt, ) = IAlchemistV2(alchemist).accounts(address(this));\n        credit = debt >= 0 ? 0 : SafeCast.toUint256(-debt);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function getTotalUnderlyingBuffered(address underlyingToken)\n        public\n        view\n        override\n        returns (uint256 totalBuffered)\n    {\n        totalBuffered = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        for (uint256 i = 0; i < _yieldTokens[underlyingToken].length; i++) {\n            totalBuffered += _getTotalBuffered(_yieldTokens[underlyingToken][i]);\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setWeights(\n        address weightToken,\n        address[] memory tokens,\n        uint256[] memory weights\n    ) external override onlyAdmin {\n        Weighting storage weighting = weightings[weightToken];\n        delete weighting.tokens;\n        weighting.totalWeight = 0;\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address yieldToken = tokens[i];\n\n            // For any weightToken that is not the debtToken, we want to verify that the yield-tokens being\n            // set for the weight schema accept said weightToken as collateral.\n            //\n            // We don't want to do this check on the debtToken because it is only used in the burnCredit() function\n            // and we want to be able to burn credit to any yield-token in the Alchemist.\n            if (weightToken != debtToken) {\n                IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist)\n                    .getYieldTokenParameters(yieldToken);\n                address underlyingToken = ITokenAdapter(params.adapter)\n                    .underlyingToken();\n\n                if (weightToken != underlyingToken) {\n                    revert IllegalState();\n                }\n            }\n\n            weighting.tokens.push(yieldToken);\n            weighting.weights[yieldToken] = weights[i];\n            weighting.totalWeight += weights[i];\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setSource(address source, bool flag) external override onlyAdmin {\n        if (sources[source] == flag) {\n            revert IllegalArgument();\n        }\n        sources[source] = flag;\n        emit SetSource(source, flag);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setTransmuter(address underlyingToken, address newTransmuter) external override onlyAdmin {\n        if (ITransmuterV2(newTransmuter).underlyingToken() != underlyingToken) {\n            revert IllegalArgument();\n        }\n        transmuter[underlyingToken] = newTransmuter;\n        emit SetTransmuter(underlyingToken, newTransmuter);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setAlchemist(address _alchemist) external override onlyAdmin {\n        sources[alchemist] = false;\n        sources[_alchemist] = true;\n\n        if (alchemist != address(0)) {\n            for (uint256 i = 0; i < registeredUnderlyings.length; i++) {\n                TokenUtils.safeApprove(registeredUnderlyings[i], alchemist, 0);\n            }\n            TokenUtils.safeApprove(debtToken, alchemist, 0);\n        }\n\n        alchemist = _alchemist;\n        for (uint256 i = 0; i < registeredUnderlyings.length; i++) {\n            TokenUtils.safeApprove(registeredUnderlyings[i], alchemist, type(uint256).max);\n        }\n        TokenUtils.safeApprove(debtToken, alchemist, type(uint256).max);\n\n        emit SetAlchemist(alchemist);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setAmo(address underlyingToken, address amo) external override onlyAdmin {\n        amos[underlyingToken] = amo;\n        emit SetAmo(underlyingToken, amo);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setDivertToAmo(address underlyingToken, bool divert) external override onlyAdmin {\n        divertToAmo[underlyingToken] = divert;\n        emit SetDivertToAmo(underlyingToken, divert);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function registerAsset(\n        address underlyingToken,\n        address _transmuter\n    ) external override onlyAdmin {\n        if (!IAlchemistV2(alchemist).isSupportedUnderlyingToken(underlyingToken)) {\n            revert IllegalState();\n        }\n\n        // only add to the array if not already contained in it\n        for (uint256 i = 0; i < registeredUnderlyings.length; i++) {\n            if (registeredUnderlyings[i] == underlyingToken) {\n                revert IllegalState();\n            }\n        }\n\n        if (ITransmuterV2(_transmuter).underlyingToken() != underlyingToken) {\n            revert IllegalArgument();\n        }\n\n        transmuter[underlyingToken] = _transmuter;\n        registeredUnderlyings.push(underlyingToken);\n        TokenUtils.safeApprove(underlyingToken, alchemist, type(uint256).max);\n        emit RegisterAsset(underlyingToken, _transmuter);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function setFlowRate(address underlyingToken, uint256 _flowRate)\n        external\n        override\n        onlyAdmin\n    {\n        _exchange(underlyingToken);\n\n        flowRate[underlyingToken] = _flowRate;\n        emit SetFlowRate(underlyingToken, _flowRate);\n    }\n\n    /// @inheritdoc IERC20TokenReceiver\n    function onERC20Received(address underlyingToken, uint256 amount)\n        external\n        override\n        onlySource\n    {\n        if (divertToAmo[underlyingToken]) {\n            _flushToAmo(underlyingToken, amount);\n        } else {\n            _updateFlow(underlyingToken);\n\n            // total amount of collateral that the buffer controls in the alchemist\n            uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n\n            // if there is not enough locally buffered collateral to meet the flow rate, exchange only the exchanged amount\n            if (localBalance < flowAvailable[underlyingToken]) {\n                currentExchanged[underlyingToken] += amount;\n                ITransmuterV2(transmuter[underlyingToken]).exchange(amount);\n            } else {\n                uint256 exchangeable = flowAvailable[underlyingToken] - currentExchanged[underlyingToken];\n                currentExchanged[underlyingToken] += exchangeable;\n                ITransmuterV2(transmuter[underlyingToken]).exchange(exchangeable);\n            }\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function exchange(address underlyingToken) external override onlyKeeper {\n        _exchange(underlyingToken);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function flushToAmo(address underlyingToken, uint256 amount) external override onlyKeeper {\n        if (divertToAmo[underlyingToken]) {\n            _flushToAmo(underlyingToken, amount);\n        } else {\n            revert IllegalState();\n        }\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function withdraw(\n        address underlyingToken,\n        uint256 amount,\n        address recipient\n    ) external override onlyTransmuter(underlyingToken) {\n        if (amount > flowAvailable[underlyingToken]) {\n            revert IllegalArgument();\n        }\n\n        uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        if (amount > localBalance) {\n            revert IllegalArgument();\n        }\n\n        flowAvailable[underlyingToken] -= amount;\n        currentExchanged[underlyingToken] -= amount;\n\n        TokenUtils.safeTransfer(underlyingToken, recipient, amount);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function withdrawFromAlchemist(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override onlyKeeper {\n        IAlchemistV2(alchemist).withdrawUnderlying(yieldToken, shares, address(this), minimumAmountOut);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function refreshStrategies() public override {\n        address[] memory supportedYieldTokens = IAlchemistV2(alchemist)\n            .getSupportedYieldTokens();\n        address[] memory supportedUnderlyingTokens = IAlchemistV2(alchemist)\n            .getSupportedUnderlyingTokens();\n\n        if (registeredUnderlyings.length != supportedUnderlyingTokens.length) {\n            revert IllegalState();\n        }\n\n        // clear current strats\n        for (uint256 j = 0; j < registeredUnderlyings.length; j++) {\n            delete _yieldTokens[registeredUnderlyings[j]];\n        }\n\n        uint256 numYTokens = supportedYieldTokens.length;\n        for (uint256 i = 0; i < numYTokens; i++) {\n            address yieldToken = supportedYieldTokens[i];\n\n            IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist)\n                .getYieldTokenParameters(yieldToken);\n            if (params.enabled) {\n                _yieldTokens[params.underlyingToken].push(yieldToken);\n            }\n        }\n        emit RefreshStrategies();\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function burnCredit() external override onlyKeeper {\n        IAlchemistV2(alchemist).poke(address(this));\n        uint256 credit = getTotalCredit();\n        if (credit == 0) {\n            revert IllegalState();\n        }\n        IAlchemistV2(alchemist).mint(credit, address(this));\n\n        _alchemistAction(credit, debtToken, _alchemistDonate);\n    }\n\n    /// @inheritdoc ITransmuterBuffer\n    function depositFunds(address underlyingToken, uint256 amount)\n        external\n        override\n        onlyKeeper\n    {\n        if (amount == 0) {\n            revert IllegalArgument();\n        }\n        uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        if (localBalance < amount) {\n            revert IllegalArgument();\n        }\n        _updateFlow(underlyingToken);\n        \n        // Don't deposit exchanged funds into the Alchemist.\n        // Doing so puts those funds at risk, and could lead to users being unable to claim\n        // their transmuted funds in the event of a vault loss.\n        if (localBalance - amount < currentExchanged[underlyingToken]) {\n            revert IllegalState();\n        }\n        _alchemistAction(amount, underlyingToken, _alchemistDeposit);\n    }\n\n    /// @dev Gets the total value of the yield tokens in units of underlying tokens that this contract holds.\n    ///\n    /// @param yieldToken The address of the target yield token.\n    function _getTotalBuffered(address yieldToken)\n        internal\n        view\n        returns (uint256)\n    {\n        (uint256 balance, ) = IAlchemistV2(alchemist).positions(address(this), yieldToken);\n        IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist)\n            .getYieldTokenParameters(yieldToken);\n        uint256 tokensPerShare = IAlchemistV2(alchemist)\n            .getUnderlyingTokensPerShare(yieldToken);\n        return (balance * tokensPerShare) / 10**params.decimals;\n    }\n\n    /// @dev Updates the available flow for a give underlying token\n    ///\n    /// @param underlyingToken the underlying token whos flow is being updated\n    function _updateFlow(address underlyingToken) internal returns (uint256) {\n        // additional flow to be allocated based on flow rate\n        uint256 marginalFlow = (block.timestamp -\n            lastFlowrateUpdate[underlyingToken]) * flowRate[underlyingToken];\n        flowAvailable[underlyingToken] += marginalFlow;\n        lastFlowrateUpdate[underlyingToken] = block.timestamp;\n        return marginalFlow;\n    }\n\n    /// @notice Runs an action on the Alchemist according to a given weighting schema.\n    ///\n    /// This function gets a weighting schema defined under the `weightToken` key, and calls the target action\n    /// with a weighted value of `amount` and the associated token.\n    ///\n    /// @param amount       The amount of funds to use in the action.\n    /// @param weightToken  The key of the weighting schema to be used for the action.\n    /// @param action       The action to be taken.\n    function _alchemistAction(\n        uint256 amount,\n        address weightToken,\n        function(address, uint256) action\n    ) internal {\n        IAlchemistV2(alchemist).poke(address(this));\n\n        Weighting storage weighting = weightings[weightToken];\n        for (uint256 j = 0; j < weighting.tokens.length; j++) {\n            address token = weighting.tokens[j];\n            uint256 actionAmt = (amount * weighting.weights[token]) / weighting.totalWeight;\n            action(token, actionAmt);\n        }\n    }\n\n    /// @notice Donate credit weight to a target yield-token by burning debt-tokens.\n    ///\n    /// @param token    The target yield-token.\n    /// @param amount      The amount of debt-tokens to burn.\n    function _alchemistDonate(address token, uint256 amount) internal {\n        IAlchemistV2(alchemist).donate(token, amount);\n    }\n\n    /// @notice Deposits funds into the Alchemist.\n    ///\n    /// @param token  The yield-token to deposit.\n    /// @param amount The amount to deposit.\n    function _alchemistDeposit(address token, uint256 amount) internal {\n        IAlchemistV2(alchemist).depositUnderlying(\n            token,\n            amount,\n            address(this),\n            0\n        );\n    }\n\n    /// @notice Withdraws funds from the Alchemist.\n    ///\n    /// @param token            The yield-token to withdraw.\n    /// @param amountUnderlying The amount of underlying to withdraw.\n    function _alchemistWithdraw(address token, uint256 amountUnderlying) internal {\n        uint8 decimals = TokenUtils.expectDecimals(token);\n        uint256 pricePerShare = IAlchemistV2(alchemist).getUnderlyingTokensPerShare(token);\n        uint256 wantShares = amountUnderlying * 10**decimals / pricePerShare;\n        (uint256 availableShares, uint256 lastAccruedWeight) = IAlchemistV2(alchemist).positions(address(this), token);\n        if (wantShares > availableShares) {\n            wantShares = availableShares;\n        }\n        // Allow 1% slippage\n        uint256 minimumAmountOut = amountUnderlying - amountUnderlying * 100 / 10000;\n        if (wantShares > 0) {\n            IAlchemistV2(alchemist).withdrawUnderlying(token, wantShares, address(this), minimumAmountOut);\n        }\n    }\n\n    /// @notice Pull necessary funds from the Alchemist and exchange them.\n    ///\n    /// @param underlyingToken The underlying-token to exchange.\n    function _exchange(address underlyingToken) internal {\n        _updateFlow(underlyingToken);\n\n        uint256 totalUnderlyingBuffered = getTotalUnderlyingBuffered(underlyingToken);\n        uint256 initialLocalBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        uint256 want = 0;\n        // Here we assume the invariant underlyingToken.balanceOf(address(this)) >= currentExchanged[underlyingToken].\n        if (totalUnderlyingBuffered < flowAvailable[underlyingToken]) {\n            // Pull the rest of the funds from the Alchemist.\n            want = totalUnderlyingBuffered - initialLocalBalance;\n        } else if (initialLocalBalance < flowAvailable[underlyingToken]) {\n            // totalUnderlyingBuffered > flowAvailable so we have funds available to pull.\n            want = flowAvailable[underlyingToken] - initialLocalBalance;\n        }\n\n        if (want > 0) {\n            _alchemistAction(want, underlyingToken, _alchemistWithdraw);\n        }\n\n        uint256 localBalance = TokenUtils.safeBalanceOf(underlyingToken, address(this));\n        uint256 exchangeDelta = 0;\n        if (localBalance > flowAvailable[underlyingToken]) {\n            exchangeDelta = flowAvailable[underlyingToken] - currentExchanged[underlyingToken];\n        } else {\n            exchangeDelta = localBalance - currentExchanged[underlyingToken];\n        }\n\n        if (exchangeDelta > 0) {\n            currentExchanged[underlyingToken] += exchangeDelta;\n            ITransmuterV2(transmuter[underlyingToken]).exchange(exchangeDelta);\n        }\n    }\n\n    /// @notice Flush funds to the amo.\n    ///\n    /// @param underlyingToken The underlyingToken to flush.\n    /// @param amount          The amount to flush.\n    function _flushToAmo(address underlyingToken, uint256 amount) internal {\n        TokenUtils.safeTransfer(underlyingToken, amos[underlyingToken], amount);\n        IERC20TokenReceiver(amos[underlyingToken]).onERC20Received(underlyingToken, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "TransmuterBuffer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TransmuterBuffer contract",
                "Type": "Array manipulation",
                "Description": "registerAsset misuse can permanently disable TransmuterBuffer and break the system",
                "Repair": "Introduce a function to remove the underlying or delete the array so it can be reconstructed with a sequence of registerAsset calls"
            },
            {
                "Location": "TransmuterBuffer contract",
                "Type": "Slippage",
                "Description": "TransmuterBuffer.sol calls depositUnderlying with no slippage bounds",
                "Repair": "Implement a slippage calculation similar to _alchemistWithdraw to protect against it"
            },
            {
                "Location": "TransmuterBuffer.sol#L230-L232",
                "Type": "Operational Mistake",
                "Description": "TransmuterBuffer's setAlchemist will freeze deposited funds.",
                "Repair": "Require that all exposure to the old Alchemist is closed."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {Unauthorized, IllegalState, IllegalArgument} from \"./base/Errors.sol\";\n\nimport \"./base/Multicall.sol\";\nimport \"./base/Mutex.sol\";\n\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/IERC20Minimal.sol\";\nimport \"./interfaces/IERC20TokenReceiver.sol\";\nimport \"./interfaces/ITokenAdapter.sol\";\nimport \"./interfaces/IAlchemicToken.sol\";\nimport \"./interfaces/IWhitelist.sol\";\n\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/Sets.sol\";\nimport \"./libraries/TokenUtils.sol\";\nimport \"./libraries/Limiters.sol\";\n\n/// @title  AlchemistV2\n/// @author Alchemix Finance\ncontract AlchemistV2 is IAlchemistV2, Initializable, Multicall, Mutex {\n    using Limiters for Limiters.LinearGrowthLimiter;\n    using Sets for Sets.AddressSet;\n\n    /// @notice A user account.\n    struct Account {\n        // A signed value which represents the current amount of debt or credit that the account has accrued.\n        // Positive values indicate debt, negative values indicate credit.\n        int256 debt;\n        // The share balances for each yield token.\n        mapping(address => uint256) balances;\n        // The last values recorded for accrued weights for each yield token.\n        mapping(address => uint256) lastAccruedWeights;\n        // The set of yield tokens that the account has deposited into the system.\n        Sets.AddressSet depositedTokens;\n        // The allowances for mints.\n        mapping(address => uint256) mintAllowances;\n        // The allowances for withdrawals.\n        mapping(address => mapping(address => uint256)) withdrawAllowances;\n    }\n\n    /// @notice The number of basis points there are to represent exactly 100%.\n    uint256 public constant BPS = 10000;\n\n    /// @notice The scalar used for conversion of integral numbers to fixed point numbers. Fixed point numbers in this\n    ///         implementation have 18 decimals of resolution, meaning that 1 is represented as 1e18, 0.5 is\n    ///         represented as 5e17, and 2 is represented as 2e18.\n    uint256 public constant FIXED_POINT_SCALAR = 1e18;\n\n    /// @inheritdoc IAlchemistV2Immutables\n    string public constant override version = \"2.2.6\";\n\n    /// @inheritdoc IAlchemistV2Immutables\n    address public override debtToken;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override admin;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override pendingAdmin;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override sentinels;\n\n    /// @inheritdoc IAlchemistV2State\n    mapping(address => bool) public override keepers;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override transmuter;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override minimumCollateralization;\n\n    /// @inheritdoc IAlchemistV2State\n    uint256 public override protocolFee;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override protocolFeeReceiver;\n\n    /// @inheritdoc IAlchemistV2State\n    address public override whitelist;\n\n    /// @dev A linear growth function that limits the amount of debt-token minted.\n    Limiters.LinearGrowthLimiter private _mintingLimiter;\n\n    // @dev The repay limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _repayLimiters;\n\n    // @dev The liquidation limiters for each underlying token.\n    mapping(address => Limiters.LinearGrowthLimiter) private _liquidationLimiters;\n\n    /// @dev Accounts mapped by the address that owns them.\n    mapping(address => Account) private _accounts;\n\n    /// @dev Underlying token parameters mapped by token address.\n    mapping(address => UnderlyingTokenParams) private _underlyingTokens;\n\n    /// @dev Yield token parameters mapped by token address.\n    mapping(address => YieldTokenParams) private _yieldTokens;\n\n    /// @dev An iterable set of the underlying tokens that are supported by the system.\n    Sets.AddressSet private _supportedUnderlyingTokens;\n\n    /// @dev An iterable set of the yield tokens that are supported by the system.\n    Sets.AddressSet private _supportedYieldTokens;\n\n    constructor() initializer {}\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToYieldTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokensPerShare(address yieldToken) external view override returns (uint256) {\n        return _convertSharesToUnderlyingTokens(yieldToken, 10**_yieldTokens[yieldToken].decimals);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedUnderlyingTokens() external view override returns (address[] memory) {\n        return _supportedUnderlyingTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getSupportedYieldTokens() external view override returns (address[] memory) {\n        return _supportedYieldTokens.values;\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedUnderlyingToken(address underlyingToken) external view override returns (bool) {\n        return _supportedUnderlyingTokens.contains(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function isSupportedYieldToken(address yieldToken) external view override returns (bool) {\n        return _supportedYieldTokens.contains(yieldToken);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function accounts(address owner)\n        external view override\n        returns (\n            int256 debt,\n            address[] memory depositedTokens\n        )\n    {\n        Account storage account = _accounts[owner];\n\n        return (\n            _calculateUnrealizedDebt(owner),\n            account.depositedTokens.values\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function positions(address owner, address yieldToken)\n        external view override\n        returns (\n            uint256 shares,\n            uint256 lastAccruedWeight\n        )\n    {\n        Account storage account = _accounts[owner];\n        return (account.balances[yieldToken], account.lastAccruedWeights[yieldToken]);\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function mintAllowance(address owner, address spender)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.mintAllowances[spender];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function withdrawAllowance(address owner, address spender, address yieldToken)\n        external view override\n        returns (uint256)\n    {\n        Account storage account = _accounts[owner];\n        return account.withdrawAllowances[spender][yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getUnderlyingTokenParameters(address underlyingToken)\n        external view override\n        returns (UnderlyingTokenParams memory)\n    {\n        return _underlyingTokens[underlyingToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getYieldTokenParameters(address yieldToken)\n        external view override\n        returns (YieldTokenParams memory)\n    {\n        return _yieldTokens[yieldToken];\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getMintLimitInfo()\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        return (\n            _mintingLimiter.get(),\n            _mintingLimiter.rate,\n            _mintingLimiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getRepayLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2State\n    function getLiquidationLimitInfo(address underlyingToken)\n        external view override\n        returns (\n            uint256 currentLimit,\n            uint256 rate,\n            uint256 maximum\n        )\n    {\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n        return (\n            limiter.get(),\n            limiter.rate,\n            limiter.maximum\n        );\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function initialize(InitializationParams memory params) external initializer {\n        _checkArgument(params.protocolFee <= BPS);\n\n        debtToken                = params.debtToken;\n        admin                    = params.admin;\n        transmuter               = params.transmuter;\n        minimumCollateralization = params.minimumCollateralization;\n        protocolFee              = params.protocolFee;\n        protocolFeeReceiver      = params.protocolFeeReceiver;\n        whitelist                = params.whitelist;\n\n        _mintingLimiter = Limiters.createLinearGrowthLimiter(\n            params.mintingLimitMaximum,\n            params.mintingLimitBlocks,\n            params.mintingLimitMinimum\n        );\n\n        emit AdminUpdated(admin);\n        emit TransmuterUpdated(transmuter);\n        emit MinimumCollateralizationUpdated(minimumCollateralization);\n        emit ProtocolFeeUpdated(protocolFee);\n        emit ProtocolFeeReceiverUpdated(protocolFeeReceiver);\n        emit MintingLimitUpdated(params.mintingLimitMaximum, params.mintingLimitBlocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setPendingAdmin(address value) external override {\n        _onlyAdmin();\n        pendingAdmin = value;\n        emit PendingAdminUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function acceptAdmin() external override {\n        _checkState(pendingAdmin != address(0));\n\n        if (msg.sender != pendingAdmin) {\n            revert Unauthorized();\n        }\n\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n\n        emit AdminUpdated(admin);\n        emit PendingAdminUpdated(address(0));\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setSentinel(address sentinel, bool flag) external override {\n        _onlyAdmin();\n        sentinels[sentinel] = flag;\n        emit SentinelSet(sentinel, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setKeeper(address keeper, bool flag) external override {\n        _onlyAdmin();\n        keepers[keeper] = flag;\n        emit KeeperSet(keeper, flag);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addUnderlyingToken(address underlyingToken, UnderlyingTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkState(!_supportedUnderlyingTokens.contains(underlyingToken));\n\n        uint8 tokenDecimals = TokenUtils.expectDecimals(underlyingToken);\n        uint8 debtTokenDecimals = TokenUtils.expectDecimals(debtToken);\n\n        _checkArgument(tokenDecimals <= debtTokenDecimals);\n\n        _underlyingTokens[underlyingToken] = UnderlyingTokenParams({\n            decimals:         tokenDecimals,\n            conversionFactor: 10**(debtTokenDecimals - tokenDecimals),\n            enabled:          false\n        });\n\n        _repayLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.repayLimitMaximum,\n            config.repayLimitBlocks,\n            config.repayLimitMinimum\n        );\n\n        _liquidationLimiters[underlyingToken] = Limiters.createLinearGrowthLimiter(\n            config.liquidationLimitMaximum,\n            config.liquidationLimitBlocks,\n            config.liquidationLimitMinimum\n        );\n\n        _supportedUnderlyingTokens.add(underlyingToken);\n\n        emit AddUnderlyingToken(underlyingToken);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function addYieldToken(address yieldToken, YieldTokenConfig calldata config) external override lock {\n        _onlyAdmin();\n        _checkArgument(config.maximumLoss <= BPS);\n        _checkArgument(config.creditUnlockBlocks > 0);\n\n        _checkState(!_supportedYieldTokens.contains(yieldToken));\n\n        ITokenAdapter adapter = ITokenAdapter(config.adapter);\n\n        _checkState(yieldToken == adapter.token());\n        _checkSupportedUnderlyingToken(adapter.underlyingToken());\n\n        _yieldTokens[yieldToken] = YieldTokenParams({\n            decimals:              TokenUtils.expectDecimals(yieldToken),\n            underlyingToken:       adapter.underlyingToken(),\n            adapter:               config.adapter,\n            maximumLoss:           config.maximumLoss,\n            maximumExpectedValue:  config.maximumExpectedValue,\n            creditUnlockRate:      FIXED_POINT_SCALAR / config.creditUnlockBlocks,\n            activeBalance:         0,\n            harvestableBalance:    0,\n            totalShares:           0,\n            expectedValue:         0,\n            accruedWeight:         0,\n            pendingCredit:         0,\n            distributedCredit:     0,\n            lastDistributionBlock: 0,\n            enabled:               false\n        });\n\n        _supportedYieldTokens.add(yieldToken);\n\n        TokenUtils.safeApprove(yieldToken, config.adapter, type(uint256).max);\n        TokenUtils.safeApprove(adapter.underlyingToken(), config.adapter, type(uint256).max);\n\n        emit AddYieldToken(yieldToken);\n        emit TokenAdapterUpdated(yieldToken, config.adapter);\n        emit MaximumLossUpdated(yieldToken, config.maximumLoss);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setUnderlyingTokenEnabled(address underlyingToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _underlyingTokens[underlyingToken].enabled = enabled;\n        emit UnderlyingTokenEnabled(underlyingToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setYieldTokenEnabled(address yieldToken, bool enabled) external override {\n        _onlySentinelOrAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].enabled = enabled;\n        emit YieldTokenEnabled(yieldToken, enabled);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureRepayLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _repayLimiters[underlyingToken].update();\n        _repayLimiters[underlyingToken].configure(maximum, blocks);\n        emit RepayLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureLiquidationLimit(address underlyingToken, uint256 maximum, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _liquidationLimiters[underlyingToken].update();\n        _liquidationLimiters[underlyingToken].configure(maximum, blocks);\n        emit LiquidationLimitUpdated(underlyingToken, maximum, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTransmuter(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        transmuter = value;\n        emit TransmuterUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMinimumCollateralization(uint256 value) external override {\n        _onlyAdmin();\n        minimumCollateralization = value;\n        emit MinimumCollateralizationUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFee(uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        protocolFee = value;\n        emit ProtocolFeeUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setProtocolFeeReceiver(address value) external override {\n        _onlyAdmin();\n        _checkArgument(value != address(0));\n        protocolFeeReceiver = value;\n        emit ProtocolFeeReceiverUpdated(value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureMintingLimit(uint256 maximum, uint256 rate) external override {\n        _onlyAdmin();\n        _mintingLimiter.update();\n        _mintingLimiter.configure(maximum, rate);\n        emit MintingLimitUpdated(maximum, rate);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function configureCreditUnlockRate(address yieldToken, uint256 blocks) external override {\n        _onlyAdmin();\n        _checkArgument(blocks > 0);\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].creditUnlockRate = FIXED_POINT_SCALAR / blocks;\n        emit CreditUnlockRateUpdated(yieldToken, blocks);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setTokenAdapter(address yieldToken, address adapter) external override {\n        _onlyAdmin();\n        _checkState(yieldToken == ITokenAdapter(adapter).token());\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].adapter = adapter;\n        TokenUtils.safeApprove(yieldToken, adapter, type(uint256).max);\n        TokenUtils.safeApprove(ITokenAdapter(adapter).underlyingToken(), adapter, type(uint256).max);\n        emit TokenAdapterUpdated(yieldToken, adapter);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumExpectedValue(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n        _yieldTokens[yieldToken].maximumExpectedValue = value;\n        emit MaximumExpectedValueUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function setMaximumLoss(address yieldToken, uint256 value) external override {\n        _onlyAdmin();\n        _checkArgument(value <= BPS);\n        _checkSupportedYieldToken(yieldToken);\n\n        _yieldTokens[yieldToken].maximumLoss = value;\n\n        emit MaximumLossUpdated(yieldToken, value);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function snap(address yieldToken) external override lock {\n        _onlyAdmin();\n        _checkSupportedYieldToken(yieldToken);\n\n        uint256 expectedValue = _convertYieldTokensToUnderlying(yieldToken, _yieldTokens[yieldToken].activeBalance);\n\n        _yieldTokens[yieldToken].expectedValue = expectedValue;\n\n        emit Snap(yieldToken, expectedValue);\n    }\n\n    /// @inheritdoc IAlchemistV2AdminActions\n    function sweepTokens(address rewardToken, uint256 amount) external override lock {\n        _onlyAdmin();\n\n        if (_supportedYieldTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        if (_supportedUnderlyingTokens.contains(rewardToken)) {\n            revert UnsupportedToken(rewardToken);\n        }\n\n        TokenUtils.safeTransfer(rewardToken, admin, amount);\n\n        emit SweepTokens(rewardToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveMint(address spender, uint256 amount) external override {\n        _onlyWhitelisted();\n        _approveMint(msg.sender, spender, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function approveWithdraw(address spender, address yieldToken, uint256 shares) external override {\n        _onlyWhitelisted();\n        _checkSupportedYieldToken(yieldToken);\n        _approveWithdraw(msg.sender, spender, yieldToken, shares);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function poke(address owner) external override lock {\n        _onlyWhitelisted();\n        _preemptivelyHarvestDeposited(owner);\n        _distributeUnlockedCreditDeposited(owner);\n        _poke(owner);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Deposit the yield tokens to the recipient.\n        uint256 shares = _deposit(yieldToken, amount, recipient);\n\n        // Transfer tokens from the message sender now that the internal storage updates have been committed.\n        TokenUtils.safeTransferFrom(yieldToken, msg.sender, address(this), amount);\n\n        return shares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function depositUnderlying(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Before depositing, the underlying tokens must be wrapped into yield tokens.\n        uint256 amountYieldTokens = _wrap(yieldToken, amount, minimumAmountOut);\n\n        // Deposit the yield-tokens to the recipient.\n        return _deposit(yieldToken, amountYieldTokens, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdraw(\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n        _checkArgument(recipient != address(0));\n        _checkSupportedYieldToken(yieldToken);\n\n        // Preemptively try and decrease the withdrawal allowance. This will save gas when the allowance is not\n        // sufficient for the withdrawal.\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        // Withdraw the shares from the system.\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        // Transfer the yield tokens to the recipient.\n        TokenUtils.safeTransfer(yieldToken, recipient, amountYieldTokens);\n\n        return amountYieldTokens;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlying(\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, msg.sender, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function withdrawUnderlyingFrom(\n        address owner,\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedYieldToken(yieldToken);\n\n        _checkLoss(yieldToken);\n\n        _decreaseWithdrawAllowance(owner, msg.sender, yieldToken, shares);\n\n        uint256 amountYieldTokens = _withdraw(yieldToken, owner, shares, recipient);\n\n        return _unwrap(yieldToken, amountYieldTokens, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mint(uint256 amount, address recipient) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Mint tokens from the message sender's account to the recipient.\n        _mint(msg.sender, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function mintFrom(\n        address owner,\n        uint256 amount,\n        address recipient\n    ) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Preemptively try and decrease the minting allowance. This will save gas when the allowance is not sufficient\n        // for the mint.\n        _decreaseMintAllowance(owner, msg.sender, amount);\n\n        // Mint tokens from the owner's account to the recipient.\n        _mint(owner, amount, recipient);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function burn(uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, decrease the debt of the recipient by the number of tokens burned.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Limit how much debt can be repaid up to the current amount of debt that the account has. This prevents\n        // situations where the user may be trying to repay their entire debt, but it decreases since they send the\n        // transaction and causes a revert because burning can never decrease the debt below zero.\n        //\n        // Casts here are safe because it is asserted that debt is greater than zero.\n        uint256 credit = amount > uint256(debt) ? uint256(debt) : amount;\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Burn the tokens from the message sender.\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, credit);\n\n        emit Burn(msg.sender, credit, recipient);\n\n        return credit;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function repay(address underlyingToken, uint256 amount, address recipient) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(amount > 0);\n        _checkArgument(recipient != address(0));\n\n        _checkSupportedUnderlyingToken(underlyingToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account and decrease the amount of debt incurred.\n        _poke(recipient);\n\n        // Check that the debt is greater than zero.\n        //\n        // It is possible that the amount of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 debt;\n        _checkState((debt = _accounts[recipient].debt) > 0);\n\n        // Determine the maximum amount of underlying tokens that can be repaid.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero so a noop is not possible\n        // beyond this point. Casting the debt to an unsigned integer is also safe because `debt` is greater than zero.\n        uint256 maximumAmount = _normalizeDebtTokensToUnderlying(underlyingToken, uint256(debt));\n\n        // Limit the number of underlying tokens to repay up to the maximum allowed.\n        uint256 actualAmount = amount > maximumAmount ? maximumAmount : amount;\n\n        Limiters.LinearGrowthLimiter storage limiter = _repayLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token repay limit has not been breached.\n        uint256 currentRepayLimit = limiter.get();\n        if (actualAmount > currentRepayLimit) {\n          revert RepayLimitExceeded(underlyingToken, actualAmount, currentRepayLimit);\n        }\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, actualAmount);\n\n        // Update the recipient's debt.\n        _updateDebt(recipient, -SafeCast.toInt256(credit));\n\n        // Decrease the amount of the underlying token which is globally available to be repaid.\n        limiter.decrease(actualAmount);\n\n        // Transfer the repaid tokens to the transmuter.\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, transmuter, actualAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, actualAmount);\n\n        emit Repay(msg.sender, underlyingToken, actualAmount, recipient);\n\n        return actualAmount;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function liquidate(\n        address yieldToken,\n        uint256 shares,\n        uint256 minimumAmountOut\n    ) external override lock returns (uint256) {\n        _onlyWhitelisted();\n\n        _checkArgument(shares > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        _checkSupportedYieldToken(yieldToken);\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n        _checkLoss(yieldToken);\n\n        // Calculate the unrealized debt.\n        //\n        // It is possible that the number of debt which is repayable is equal to or less than zero after realizing the\n        // credit that was earned since the last update. We do not want to perform a noop so we need to check that the\n        // amount of debt to repay is greater than zero.\n        int256 unrealizedDebt;\n        _checkState((unrealizedDebt = _calculateUnrealizedDebt(msg.sender)) > 0);\n\n        // Determine the maximum amount of shares that can be liquidated from the unrealized debt.\n        //\n        // It is implied that this value is greater than zero because `debt` is greater than zero. Casting the debt to an\n        // unsigned integer is also safe for this reason.\n        uint256 maximumShares = _convertUnderlyingTokensToShares(\n          yieldToken,\n          _normalizeDebtTokensToUnderlying(underlyingToken, uint256(unrealizedDebt))\n        );\n\n        // Limit the number of shares to liquidate up to the maximum allowed.\n        uint256 actualShares = shares > maximumShares ? maximumShares : shares;\n\n        // Unwrap the yield tokens that the shares are worth.\n        uint256 amountYieldTokens      = _convertSharesToYieldTokens(yieldToken, actualShares);\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, amountYieldTokens, address(this), minimumAmountOut);\n\n        // Again, perform another noop check. It is possible that the amount of underlying tokens that were received by\n        // unwrapping the yield tokens was zero because the amount of yield tokens to unwrap was too small.\n        _checkState(amountUnderlyingTokens > 0);\n\n        Limiters.LinearGrowthLimiter storage limiter = _liquidationLimiters[underlyingToken];\n\n        // Check to make sure that the underlying token liquidation limit has not been breached.\n        uint256 liquidationLimit = limiter.get();\n        if (amountUnderlyingTokens > liquidationLimit) {\n          revert LiquidationLimitExceeded(underlyingToken, amountUnderlyingTokens, liquidationLimit);\n        }\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system. This is required for `_sync` to function correctly.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(msg.sender);\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n\n        // Update the message sender's account, proactively burn shares, decrease the amount of debt incurred, and then\n        // decrease the value of the token that the system is expected to hold.\n        _poke(msg.sender, yieldToken);\n        _burnShares(msg.sender, yieldToken, actualShares);\n        _updateDebt(msg.sender, -SafeCast.toInt256(credit));\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Decrease the amount of the underlying token which is globally available to be liquidated.\n        limiter.decrease(amountUnderlyingTokens);\n\n        // Transfer the liquidated tokens to the transmuter.\n        TokenUtils.safeTransfer(underlyingToken, transmuter, amountUnderlyingTokens);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, amountUnderlyingTokens);\n\n        emit Liquidate(msg.sender, yieldToken, underlyingToken, actualShares);\n\n        return actualShares;\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function donate(address yieldToken, uint256 amount) external override lock {\n        _onlyWhitelisted();\n        _checkArgument(amount != 0);\n\n        // Distribute any unlocked credit so that the accrued weight is up to date.\n        _distributeUnlockedCredit(yieldToken);\n\n        // Update the message sender's account. This will assure that any credit that was earned is not overridden.\n        _poke(msg.sender);\n\n        uint256 shares = _yieldTokens[yieldToken].totalShares - _accounts[msg.sender].balances[yieldToken];\n\n        _yieldTokens[yieldToken].accruedWeight += amount * FIXED_POINT_SCALAR / shares;\n        _accounts[msg.sender].lastAccruedWeights[yieldToken] = _yieldTokens[yieldToken].accruedWeight;\n\n        TokenUtils.safeBurnFrom(debtToken, msg.sender, amount);\n\n        emit Donate(msg.sender, yieldToken, amount);\n    }\n\n    /// @inheritdoc IAlchemistV2Actions\n    function harvest(address yieldToken, uint256 minimumAmountOut) external override lock {\n        _onlyKeeper();\n        _checkSupportedYieldToken(yieldToken);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        // Buffer any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to be harvested during this call.\n        _preemptivelyHarvest(yieldToken);\n\n        // Load and proactively clear the amount of harvestable tokens so that future calls do not rely on stale data.\n        // Because we cannot call an external unwrap until the amount of harvestable tokens has been calculated,\n        // clearing this data immediately prevents any potential reentrancy attacks which would use stale harvest\n        // buffer values.\n        uint256 harvestableAmount = yieldTokenParams.harvestableBalance;\n        yieldTokenParams.harvestableBalance = 0;\n\n        // Check that the harvest will not be a no-op.\n        _checkState(harvestableAmount != 0);\n\n        address underlyingToken = yieldTokenParams.underlyingToken;\n        uint256 amountUnderlyingTokens = _unwrap(yieldToken, harvestableAmount, address(this), minimumAmountOut);\n\n        // Calculate how much of the unwrapped underlying tokens will be allocated for fees and distributed to users.\n        uint256 feeAmount = amountUnderlyingTokens * protocolFee / BPS;\n        uint256 distributeAmount = amountUnderlyingTokens - feeAmount;\n\n        uint256 credit = _normalizeUnderlyingTokensToDebt(underlyingToken, distributeAmount);\n\n        // Distribute credit to all of the users who hold shares of the yield token.\n        _distributeCredit(yieldToken, credit);\n\n        // Transfer the tokens to the fee receiver and transmuter.\n        TokenUtils.safeTransfer(underlyingToken, protocolFeeReceiver, feeAmount);\n        TokenUtils.safeTransfer(underlyingToken, transmuter, distributeAmount);\n\n        // Inform the transmuter that it has received tokens.\n        IERC20TokenReceiver(transmuter).onERC20Received(underlyingToken, distributeAmount);\n\n        emit Harvest(yieldToken, minimumAmountOut, amountUnderlyingTokens);\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator.\n    ///\n    /// @dev `msg.sender` must be the administrator or this call will revert with an {Unauthorized} error.\n    function _onlyAdmin() internal view {\n        if (msg.sender != admin) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is the administrator or a sentinel.\n    ///\n    /// @dev `msg.sender` must be either the administrator or a sentinel or this call will revert with an\n    ///      {Unauthorized} error.\n    function _onlySentinelOrAdmin() internal view {\n        // Check if the message sender is the administrator.\n        if (msg.sender == admin) {\n            return;\n        }\n\n        // Check if the message sender is a sentinel. After this check we can revert since we know that it is neither\n        // the administrator or a sentinel.\n        if (!sentinels[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks that the `msg.sender` is a keeper.\n    ///\n    /// @dev `msg.sender` must be a keeper or this call will revert with an {Unauthorized} error.\n    function _onlyKeeper() internal view {\n        if (!keepers[msg.sender]) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @dev Preemptively harvests all of the yield tokens that have been deposited into an account.\n    ///\n    /// @param owner The address which owns the account.\n    function _preemptivelyHarvestDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _preemptivelyHarvest(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Preemptively harvests `yieldToken`.\n    ///\n    /// @dev This will earmark yield tokens to be harvested at a future time when the current value of the token is\n    ///      greater than the expected value. The purpose of this function is to synchronize the balance of the yield\n    ///      token which is held by users versus tokens which will be seized by the protocol.\n    ///\n    /// @param yieldToken The address of the yield token to preemptively harvest.\n    function _preemptivelyHarvest(address yieldToken) internal {\n        uint256 activeBalance = _yieldTokens[yieldToken].activeBalance;\n        if (activeBalance == 0) {\n            return;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = _yieldTokens[yieldToken].expectedValue;\n        if (currentValue <= expectedValue) {\n            return;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n            return;\n        }\n        _yieldTokens[yieldToken].activeBalance -= harvestable;\n        _yieldTokens[yieldToken].harvestableBalance += harvestable;\n    }\n\n    /// @dev Checks if a yield token is enabled.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkYieldTokenEnabled(address yieldToken) internal view {\n        if (!_yieldTokens[yieldToken].enabled) {\n          revert TokenDisabled(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an underlying token is enabled.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    function _checkUnderlyingTokenEnabled(address underlyingToken) internal view {\n        if (!_underlyingTokens[underlyingToken].enabled) {\n          revert TokenDisabled(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported yield token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param yieldToken The address to check.\n    function _checkSupportedYieldToken(address yieldToken) internal view {\n        if (!_supportedYieldTokens.contains(yieldToken)) {\n            revert UnsupportedToken(yieldToken);\n        }\n    }\n\n    /// @dev Checks if an address is a supported underlying token.\n    ///\n    /// If the address is not a supported yield token, this function will revert using a {UnsupportedToken} error.\n    ///\n    /// @param underlyingToken The address to check.\n    function _checkSupportedUnderlyingToken(address underlyingToken) internal view {\n        if (!_supportedUnderlyingTokens.contains(underlyingToken)) {\n            revert UnsupportedToken(underlyingToken);\n        }\n    }\n\n    /// @dev Checks if `amount` of debt tokens can be minted.\n    ///\n    /// @dev `amount` must be less than the current minting limit or this call will revert with a\n    ///      {MintingLimitExceeded} error.\n    ///\n    /// @param amount The amount to check.\n    function _checkMintingLimit(uint256 amount) internal view {\n        uint256 limit = _mintingLimiter.get();\n        if (amount > limit) {\n            revert MintingLimitExceeded(amount, limit);\n        }\n    }\n\n    /// @dev Checks if the current loss of `yieldToken` has exceeded its maximum acceptable loss.\n    ///\n    /// @dev The loss that `yieldToken` has incurred must be less than its maximum accepted value or this call will\n    ///      revert with a {LossExceeded} error.\n    ///\n    /// @param yieldToken The address of the yield token.\n    function _checkLoss(address yieldToken) internal view {\n        uint256 loss = _loss(yieldToken);\n        uint256 maximumLoss = _yieldTokens[yieldToken].maximumLoss;\n        if (loss > maximumLoss) {\n            revert LossExceeded(yieldToken, loss, maximumLoss);\n        }\n    }\n\n    /// @dev Deposits `amount` yield tokens into the account of `recipient`.\n    ///\n    /// @dev Emits a {Deposit} event.\n    ///\n    /// @param yieldToken The address of the yield token to deposit.\n    /// @param amount     The amount of yield tokens to deposit.\n    /// @param recipient  The recipient of the yield tokens.\n    ///\n    /// @return The number of shares minted to `recipient`.\n    function _deposit(\n        address yieldToken,\n        uint256 amount,\n        address recipient\n    ) internal returns (uint256) {\n        _checkArgument(amount > 0);\n\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        // Check that the yield token and it's underlying token are enabled. Disabling the yield token and or the\n        // underlying token prevents the system from holding more of the disabled yield token or underlying token.\n        _checkYieldTokenEnabled(yieldToken);\n        _checkUnderlyingTokenEnabled(underlyingToken);\n\n        // Check to assure that the token has not experienced a sudden unexpected loss. This prevents users from being\n        // able to deposit funds and then have them siphoned if the price recovers.\n        _checkLoss(yieldToken);\n\n        // Buffers any harvestable yield tokens. This will properly synchronize the balance which is held by users\n        // and the balance which is held by the system to eventually be harvested.\n        _preemptivelyHarvest(yieldToken);\n\n        // Distribute unlocked credit to depositors.\n        _distributeUnlockedCreditDeposited(recipient);\n\n        // Update the recipient's account, proactively issue shares for the deposited tokens to the recipient, and then\n        // increase the value of the token that the system is expected to hold.\n        _poke(recipient, yieldToken);\n        uint256 shares = _issueSharesForAmount(recipient, yieldToken, amount);\n        _sync(yieldToken, amount, _uadd);\n\n        // Check that the maximum expected value has not been breached.\n        uint256 maximumExpectedValue = yieldTokenParams.maximumExpectedValue;\n        if (yieldTokenParams.expectedValue > maximumExpectedValue) {\n          revert ExpectedValueExceeded(yieldToken, amount, maximumExpectedValue);\n        }\n\n        emit Deposit(msg.sender, yieldToken, amount, recipient);\n\n        return shares;\n    }\n\n    /// @dev Withdraw `yieldToken` from the account owned by `owner` by burning shares and receiving yield tokens of\n    ///      equivalent value.\n    ///\n    /// @dev Emits a {Withdraw} event.\n    ///\n    /// @param yieldToken The address of the yield token to withdraw.\n    /// @param owner      The address of the account owner to withdraw from.\n    /// @param shares     The number of shares to burn.\n    /// @param recipient  The recipient of the withdrawn shares. This parameter is only used for logging.\n    ///\n    /// @return The amount of yield tokens that the burned shares were exchanged for.\n    function _withdraw(\n        address yieldToken,\n        address owner,\n        uint256 shares,\n        address recipient\n    ) internal returns (uint256) {\n        // Buffers any harvestable yield tokens that the owner of the account has deposited. This will properly\n        // synchronize the balance of all the tokens held by the owner so that the validation check properly\n        // computes the total value of the tokens held by the owner.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n\n        // Update the owner's account, burn shares from the owner's account, and then decrease the value of the token\n        // that the system is expected to hold.\n        _poke(owner);\n        _burnShares(owner, yieldToken, shares);\n        _sync(yieldToken, amountYieldTokens, _usub);\n\n        // Valid the owner's account to assure that the collateralization invariant is still held.\n        _validate(owner);\n\n        emit Withdraw(owner, yieldToken, shares, recipient);\n\n        return amountYieldTokens;\n    }\n\n    /// @dev Mints debt tokens to `recipient` using the account owned by `owner`.\n    ///\n    /// @dev Emits a {Mint} event.\n    ///\n    /// @param owner     The owner of the account to mint from.\n    /// @param amount    The amount to mint.\n    /// @param recipient The recipient of the minted debt tokens.\n    function _mint(address owner, uint256 amount, address recipient) internal {\n        // Check that the system will allow for the specified amount to be minted.\n        _checkMintingLimit(amount);\n\n        // Preemptively harvest all tokens that the user has deposited into the system. This allows the debt to be\n        // properly calculated before the account is validated.\n        _preemptivelyHarvestDeposited(owner);\n\n        // Distribute unlocked credit for all of the tokens that the user has deposited into the system. This updates\n        // the accrued weights so that the debt is properly calculated before the account is validated.\n        _distributeUnlockedCreditDeposited(owner);\n\n        // Update the owner's account, increase their debt by the amount of tokens to mint, and then finally validate\n        // their account to assure that the collateralization invariant is still held.\n        _poke(owner);\n        _updateDebt(owner, SafeCast.toInt256(amount));\n        _validate(owner);\n\n        // Decrease the global amount of mintable debt tokens.\n        _mintingLimiter.decrease(amount);\n\n        // Mint the debt tokens to the recipient.\n        TokenUtils.safeMint(debtToken, recipient, amount);\n\n        emit Mint(owner, amount, recipient);\n    }\n\n    /// @dev Synchronizes the active balance and expected value of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount to add or subtract from the debt.\n    /// @param operation  The mathematical operation to perform for the update. Either one of {_uadd} or {_usub}.\n    function _sync(\n        address yieldToken,\n        uint256 amount,\n        function(uint256, uint256) internal pure returns (uint256) operation\n    ) internal {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, amount);\n        uint256 updatedActiveBalance   = operation(yieldTokenParams.activeBalance, amount);\n        uint256 updatedExpectedValue   = operation(yieldTokenParams.expectedValue, amountUnderlyingTokens);\n\n        _yieldTokens[yieldToken].activeBalance = updatedActiveBalance;\n        _yieldTokens[yieldToken].expectedValue = updatedExpectedValue;\n    }\n\n    /// @dev Gets the amount of loss that `yieldToken` has incurred measured in basis points. When the expected\n    ///      underlying value is less than the actual value, this will return zero.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The loss in basis points.\n    function _loss(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams memory yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 amountUnderlyingTokens = _convertYieldTokensToUnderlying(yieldToken, yieldTokenParams.activeBalance);\n        uint256 expectedUnderlyingValue = yieldTokenParams.expectedValue;\n\n        return expectedUnderlyingValue > amountUnderlyingTokens\n            ? ((expectedUnderlyingValue - amountUnderlyingTokens) * BPS) / expectedUnderlyingValue\n            : 0;\n    }\n\n    /// @dev Distributes `amount` credit to all depositors of `yieldToken`.\n    ///\n    /// @param yieldToken The address of the yield token to distribute credit for.\n    /// @param amount     The amount of credit to distribute in debt tokens.\n    function _distributeCredit(address yieldToken, uint256 amount) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit     = yieldTokenParams.pendingCredit;\n        uint256 distributedCredit = yieldTokenParams.distributedCredit;\n        uint256 unlockedCredit    = _calculateUnlockedCredit(yieldToken);\n        uint256 lockedCredit      = pendingCredit - (distributedCredit + unlockedCredit);\n\n        // Distribute any unlocked credit before overriding it.\n        if (unlockedCredit > 0) {\n            yieldTokenParams.accruedWeight += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        }\n\n        yieldTokenParams.pendingCredit         = amount + lockedCredit;\n        yieldTokenParams.distributedCredit     = 0;\n        yieldTokenParams.lastDistributionBlock = block.number;\n    }\n\n    /// @dev Distributes unlocked credit for all of the yield tokens that have been deposited into the account owned\n    ///      by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _distributeUnlockedCreditDeposited(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _distributeUnlockedCredit(depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Distributes unlocked credit of `yieldToken` to all depositors.\n    ///\n    /// @param yieldToken The address of the yield token to distribute unlocked credit for.\n    function _distributeUnlockedCredit(address yieldToken) internal {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);\n        if (unlockedCredit == 0) {\n            return;\n        }\n\n        yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;\n        yieldTokenParams.distributedCredit += unlockedCredit;\n    }\n\n    /// @dev Wraps `amount` of an underlying token into its `yieldToken`.\n    ///\n    /// @param yieldToken       The address of the yield token to wrap the underlying tokens into.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of yield tokens that are expected to be received from the operation.\n    ///\n    /// @return The amount of yield tokens that resulted from the operation.\n    function _wrap(\n        address yieldToken,\n        uint256 amount,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        address underlyingToken = yieldTokenParams.underlyingToken;\n\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n        uint256 wrappedShares = adapter.wrap(amount, address(this));\n        if (wrappedShares < minimumAmountOut) {\n            revert SlippageExceeded(wrappedShares, minimumAmountOut);\n        }\n\n        return wrappedShares;\n    }\n\n    /// @dev Unwraps `amount` of `yieldToken` into its underlying token.\n    ///\n    /// @param yieldToken       The address of the yield token to unwrap.\n    /// @param amount           The amount of the underlying token to wrap.\n    /// @param minimumAmountOut The minimum amount of underlying tokens that are expected to be received from the\n    ///                         operation.\n    ///\n    /// @return The amount of underlying tokens that resulted from the operation.\n    function _unwrap(\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) internal returns (uint256) {\n        ITokenAdapter adapter = ITokenAdapter(_yieldTokens[yieldToken].adapter);\n        uint256 amountUnwrapped = adapter.unwrap(amount, recipient);\n        if (amountUnwrapped < minimumAmountOut) {\n            revert SlippageExceeded(amountUnwrapped, minimumAmountOut);\n        }\n        return amountUnwrapped;\n    }\n\n    /// @dev Synchronizes the state for all of the tokens deposited in the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    function _poke(address owner) internal {\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            _poke(owner, depositedTokens.values[i]);\n        }\n    }\n\n    /// @dev Synchronizes the state of `yieldToken` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param yieldToken The address of the yield token to synchronize the state for.\n    function _poke(address owner, address yieldToken) internal {\n        Account storage account = _accounts[owner];\n\n        uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n        uint256 lastAccruedWeight    = account.lastAccruedWeights[yieldToken];\n\n        if (currentAccruedWeight == lastAccruedWeight) {\n            return;\n        }\n\n        uint256 balance          = account.balances[yieldToken];\n        uint256 unrealizedCredit = (currentAccruedWeight - lastAccruedWeight) * balance / FIXED_POINT_SCALAR;\n\n        account.debt                           -= SafeCast.toInt256(unrealizedCredit);\n        account.lastAccruedWeights[yieldToken]  = currentAccruedWeight;\n    }\n\n    /// @dev Increases the debt by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner     The address of the account owner.\n    /// @param amount    The amount to increase the debt by.\n    function _updateDebt(address owner, int256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.debt += amount;\n    }\n\n    /// @dev Set the mint allowance for `spender` to `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to set the mint allowance to.\n    function _approveMint(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] = amount;\n        emit ApproveMint(owner, spender, amount);\n    }\n\n    /// @dev Decrease the mint allowance for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner   The address of the account owner.\n    /// @param spender The address of the spender.\n    /// @param amount  The amount of debt tokens to decrease the mint allowance by.\n    function _decreaseMintAllowance(address owner, address spender, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.mintAllowances[spender] -= amount;\n    }\n\n    /// @dev Set the withdraw allowance of `yieldToken` for `spender` to `shares` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to set the withdraw allowance for.\n    /// @param shares     The amount of shares to set the withdraw allowance to.\n    function _approveWithdraw(address owner, address spender, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] = shares;\n        emit ApproveWithdraw(owner, spender, yieldToken, shares);\n    }\n\n    /// @dev Decrease the withdraw allowance of `yieldToken` for `spender` by `amount` for the account owned by `owner`.\n    ///\n    /// @param owner      The address of the account owner.\n    /// @param spender    The address of the spender.\n    /// @param yieldToken The address of the yield token to decrease the withdraw allowance for.\n    /// @param amount     The amount of shares to decrease the withdraw allowance by.\n    function _decreaseWithdrawAllowance(address owner, address spender, address yieldToken, uint256 amount) internal {\n        Account storage account = _accounts[owner];\n        account.withdrawAllowances[spender][yieldToken] -= amount;\n    }\n\n    /// @dev Checks that the account owned by `owner` is properly collateralized.\n    ///\n    /// @dev If the account is undercollateralized then this will revert with an {Undercollateralized} error.\n    ///\n    /// @param owner The address of the account owner.\n    function _validate(address owner) internal view {\n        int256 debt = _accounts[owner].debt;\n        if (debt <= 0) {\n            return;\n        }\n\n        uint256 collateralization = _totalValue(owner) * FIXED_POINT_SCALAR / uint256(debt);\n\n        if (collateralization < minimumCollateralization) {\n            revert Undercollateralized();\n        }\n    }\n\n    /// @dev Gets the total value of the deposit collateral measured in debt tokens of the account owned by `owner`.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The total value.\n    function _totalValue(address owner) internal view returns (uint256) {\n        uint256 totalValue = 0;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken             = depositedTokens.values[i];\n            address underlyingToken        = _yieldTokens[yieldToken].underlyingToken;\n            uint256 shares                 = _accounts[owner].balances[yieldToken];\n            uint256 amountUnderlyingTokens = _convertSharesToUnderlyingTokens(yieldToken, shares);\n\n            totalValue += _normalizeUnderlyingTokensToDebt(underlyingToken, amountUnderlyingTokens);\n        }\n\n        return totalValue;\n    }\n\n    /// @dev Issues shares of `yieldToken` for `amount` of its underlying token to `recipient`.\n    ///\n    /// IMPORTANT: `amount` must never be 0.\n    ///\n    /// @param recipient  The address of the recipient.\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of the underlying token.\n    ///\n    /// @return The amount of shares issued to `recipient`.\n    function _issueSharesForAmount(\n        address recipient,\n        address yieldToken,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 shares = _convertYieldTokensToShares(yieldToken, amount);\n\n        if (_accounts[recipient].balances[yieldToken] == 0) {\n          _accounts[recipient].depositedTokens.add(yieldToken);\n        }\n\n        _accounts[recipient].balances[yieldToken] += shares;\n        _yieldTokens[yieldToken].totalShares += shares;\n\n        return shares;\n    }\n\n    /// @dev Burns `share` shares of `yieldToken` from the account owned by `owner`.\n    ///\n    /// @param owner      The address of the owner.\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares to burn.\n    function _burnShares(address owner, address yieldToken, uint256 shares) internal {\n        Account storage account = _accounts[owner];\n\n        account.balances[yieldToken] -= shares;\n        _yieldTokens[yieldToken].totalShares -= shares;\n\n        if (account.balances[yieldToken] == 0) {\n            account.depositedTokens.remove(yieldToken);\n        }\n    }\n\n    /// @dev Gets the amount of debt that the account owned by `owner` will have after an update occurs.\n    ///\n    /// @param owner The address of the account owner.\n    ///\n    /// @return The amount of debt that the account owned by `owner` will have after an update.\n    function _calculateUnrealizedDebt(address owner) internal view returns (int256) {\n        int256 debt = _accounts[owner].debt;\n\n        Sets.AddressSet storage depositedTokens = _accounts[owner].depositedTokens;\n        for (uint256 i = 0; i < depositedTokens.values.length; i++) {\n            address yieldToken = depositedTokens.values[i];\n\n            uint256 currentAccruedWeight = _yieldTokens[yieldToken].accruedWeight;\n            uint256 lastAccruedWeight    = _accounts[owner].lastAccruedWeights[yieldToken];\n            uint256 unlockedCredit       = _calculateUnlockedCredit(yieldToken);\n\n            currentAccruedWeight += unlockedCredit > 0\n                ? unlockedCredit * FIXED_POINT_SCALAR / _yieldTokens[yieldToken].totalShares\n                : 0;\n\n            if (currentAccruedWeight == lastAccruedWeight) {\n                continue;\n            }\n\n            uint256 balance = _accounts[owner].balances[yieldToken];\n            uint256 unrealizedCredit = ((currentAccruedWeight - lastAccruedWeight) * balance) / FIXED_POINT_SCALAR;\n\n            debt -= SafeCast.toInt256(unrealizedCredit);\n        }\n\n        return debt;\n    }\n\n    /// @dev Gets the virtual active balance of `yieldToken`.\n    ///\n    /// @dev The virtual active balance is the active balance minus any harvestable tokens which have yet to be realized.\n    ///\n    /// @param yieldToken The address of the yield token to get the virtual active balance of.\n    ///\n    /// @return The virtual active balance.\n    function _calculateUnrealizedActiveBalance(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 activeBalance = yieldTokenParams.activeBalance;\n        if (activeBalance == 0) {\n          return activeBalance;\n        }\n\n        uint256 currentValue = _convertYieldTokensToUnderlying(yieldToken, activeBalance);\n        uint256 expectedValue = yieldTokenParams.expectedValue;\n        if (currentValue <= expectedValue) {\n          return activeBalance;\n        }\n\n        uint256 harvestable = _convertUnderlyingTokensToYield(yieldToken, currentValue - expectedValue);\n        if (harvestable == 0) {\n          return activeBalance;\n        }\n\n        return activeBalance - harvestable;\n    }\n\n    /// @dev Calculates the amount of unlocked credit for `yieldToken` that is available for distribution.\n    ///\n    /// @param yieldToken The address of the yield token.\n    ///\n    /// @return The amount of unlocked credit available.\n    function _calculateUnlockedCredit(address yieldToken) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n\n        uint256 pendingCredit = yieldTokenParams.pendingCredit;\n        if (pendingCredit == 0) {\n            return 0;\n        }\n\n        uint256 creditUnlockRate      = yieldTokenParams.creditUnlockRate;\n        uint256 distributedCredit     = yieldTokenParams.distributedCredit;\n        uint256 lastDistributionBlock = yieldTokenParams.lastDistributionBlock;\n\n        uint256 percentUnlocked = (block.number - lastDistributionBlock) * creditUnlockRate;\n\n        return percentUnlocked < FIXED_POINT_SCALAR\n            ? (pendingCredit * percentUnlocked / FIXED_POINT_SCALAR) - distributedCredit\n            : pendingCredit - distributedCredit;\n    }\n\n    /// @dev Gets the amount of shares that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The number of shares.\n    function _convertYieldTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        if (_yieldTokens[yieldToken].totalShares == 0) {\n            return amount;\n        }\n        return amount * _yieldTokens[yieldToken].totalShares / _calculateUnrealizedActiveBalance(yieldToken);\n    }\n\n    /// @dev Gets the amount of yield tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertSharesToYieldTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 totalShares = _yieldTokens[yieldToken].totalShares;\n        if (totalShares == 0) {\n          return shares;\n        }\n        return (shares * _calculateUnrealizedActiveBalance(yieldToken)) / totalShares;\n    }\n\n    /// @dev Gets the amount of underlying tokens that `shares` shares of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param shares     The amount of shares.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertSharesToUnderlyingTokens(address yieldToken, uint256 shares) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertSharesToYieldTokens(yieldToken, shares);\n        return _convertYieldTokensToUnderlying(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Gets the amount of an underlying token that `amount` of `yieldToken` is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of yield tokens.\n    ///\n    /// @return The amount of underlying tokens.\n    function _convertYieldTokensToUnderlying(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * adapter.price() / 10**yieldTokenParams.decimals;\n    }\n\n    /// @dev Gets the amount of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of yield tokens.\n    function _convertUnderlyingTokensToYield(address yieldToken, uint256 amount) internal view returns (uint256) {\n        YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];\n        ITokenAdapter adapter = ITokenAdapter(yieldTokenParams.adapter);\n        return amount * 10**yieldTokenParams.decimals / adapter.price();\n    }\n\n    /// @dev Gets the amount of shares of `yieldToken` that `amount` of its underlying token is exchangeable for.\n    ///\n    /// @param yieldToken The address of the yield token.\n    /// @param amount     The amount of underlying tokens.\n    ///\n    /// @return The amount of shares.\n    function _convertUnderlyingTokensToShares(address yieldToken, uint256 amount) internal view returns (uint256) {\n        uint256 amountYieldTokens = _convertUnderlyingTokensToYield(yieldToken, amount);\n        return _convertYieldTokensToShares(yieldToken, amountYieldTokens);\n    }\n\n    /// @dev Normalize `amount` of `underlyingToken` to a value which is comparable to units of the debt token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeUnderlyingTokensToDebt(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount * _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Normalize `amount` of the debt token to a value which is comparable to units of `underlyingToken`.\n    ///\n    /// @dev This operation will result in truncation of some of the least significant digits of `amount`. This\n    ///      truncation amount will be the least significant N digits where N is the difference in decimals between\n    ///      the debt token and the underlying token.\n    ///\n    /// @param underlyingToken The address of the underlying token.\n    /// @param amount          The amount of the debt token.\n    ///\n    /// @return The normalized amount.\n    function _normalizeDebtTokensToUnderlying(address underlyingToken, uint256 amount) internal view returns (uint256) {\n        return amount / _underlyingTokens[underlyingToken].conversionFactor;\n    }\n\n    /// @dev Checks the whitelist for msg.sender.\n    ///\n    /// Reverts if msg.sender is not in the whitelist.\n    function _onlyWhitelisted() internal view {\n        // Check if the message sender is an EOA. In the future, this potentially may break. It is important that functions\n        // which rely on the whitelist not be explicitly vulnerable in the situation where this no longer holds true.\n        if (tx.origin == msg.sender) {\n          return;\n        }\n\n        // Only check the whitelist for calls from contracts.\n        if (!IWhitelist(whitelist).isWhitelisted(msg.sender)) {\n          revert Unauthorized();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalArgument} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkArgument(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalArgument();\n        }\n    }\n\n    /// @dev Checks an expression and reverts with an {IllegalState} error if the expression is {false}.\n    ///\n    /// @param expression The expression to check.\n    function _checkState(bool expression) internal pure {\n        if (!expression) {\n            revert IllegalState();\n        }\n    }\n\n    /// @dev Adds two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z The result.\n    function _uadd(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x + y; }\n\n    /// @dev Subtracts two unsigned 256 bit integers together and returns the result.\n    ///\n    /// @dev This operation is checked and will fail if the result overflows.\n    ///\n    /// @param x The first operand.\n    /// @param y The second operand.\n    ///\n    /// @return z the result.\n    function _usub(uint256 x, uint256 y) internal pure returns (uint256 z) { z = x - y; }\n}\n\n\n",
        "CodeNames": [
            "AlchemistV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AlchemistV2 contract",
                "Type": "Division by zero",
                "Description": "If totalShares for a token falls to zero while there is pendingCredit, the contract will become stuck.",
                "Repair": "Prevent totalShares from over becoming zero once it is set. That is enforce a user to leave at least 1 unit if they are the last user to withdraw. Alternatively, transfer the first 1000 shares to a 'burn' account when the first user deposits. When the last user withdraws, transfer all pending credit to this user and set the required variables to zero to replicate the state before any users have deposited."
            },
            {
                "Location": "AlchemistV2.sol#L1679-L1682, AlchemistV2.sol#L743-L786",
                "Type": "Flawed Design",
                "Description": "Debt can be repaid with a depegged underlyingToken, which can be exploited by arbitrageurs and drives the market price of alToken to match the worst depegged underlyingToken.",
                "Repair": "Update the repay() function and change to market buy using the underlyingToken to alToken and then burn() the alToken to reduce debt."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TransmuterBuffer's _alchemistWithdraw function",
                "Type": "Uncontrolled Slippage",
                "Description": "The hard-coded 1% slippage in _alchemistWithdraw can cause user fund loss or exchange functionality unavailability. The function argument with a default value of 1% can provide more flexibility and control over slippage.",
                "Repair": "Add a function argument with a default value of 1% to allow the slippage to be tuned when needed"
            }
        ]
    }
]