[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Multiple locations in the codebase",
                "Type": "Smart Contract Vulnerability",
                "Description": "The smart contract is vulnerable to various attacks such as liquidations on bogus Oracle prices, stealing InsuranceFund deposits, sandwich attacks during liquidation, reentrancy during initialization, and inability to transfer ownership of Swap.vy.",
                "Repair": "Add non-zero Oracle price check, possibly add an additional Oracle feed information usage to control that the price is fresh. Set quoteAssetLimit in _reducePosition to prevent sandwich attacks. Upgrade @openzeppelin/contracts to version 4.4.1 or higher. Add a check that the AMM can't be set multiple times to prevent ownership transfer vulnerability."
            },
            {
                "Location": "function settleFunding(uint256 _fundingRound) external",
                "Type": "Reentrancy",
                "Description": "The function settleFunding() can be reentered by an attacker, allowing them to manipulate the state of the contract and potentially steal funds.",
                "Repair": "Use the checks-effects-interactions pattern to ensure that external calls are made after state changes have been made"
            },
            {
                "Location": "function whitelistAmm(address _amm) external onlyGovernance",
                "Type": "Incorrect Access Control",
                "Description": "The function whitelistAmm() allows the Governance protocol to whitelist AMM.sol contracts, but it is possible to add the same AMM twice, potentially allowing users to trade while insolvent or incorrectly liquidating solvent users.",
                "Repair": "Add a check to ensure that the AMM being added is not already in the list"
            },
            {
                "Location": "function withdraw(uint _shares) external",
                "Type": "Front-running",
                "Description": "Users are able to front-run bad debt settlements to avoid insurance costs by withdrawing their shares before the bad debt is settled.",
                "Repair": "Make withdrawals a two-step process with an expiry time and recharge time to prevent constant pending withdrawals"
            },
            {
                "Location": "function getUnderlyingPrice(address underlying) external view returns (uint256)",
                "Type": "Arbitrary Code Execution",
                "Description": "The function getUnderlyingPrice() divides the chainlink price by 100, assuming that the answer for the underlying is in 8 decimals but then wants to reduce it for 6 decimals to match USDC. However, arbitrary underlying tokens are used and the chainlink oracles can have different decimals.",
                "Repair": "Use the on-chain reported decimals when dividing the chainlink price"
            },
            {
                "Location": "function deposit(uint256 _amount) external",
                "Type": "Economic",
                "Description": "After debt seizure from InsuranceFund, a user can dilute all past participants by depositing a small amount of vUSD and receiving an exponentially larger number of shares than other participants.",
                "Repair": "Keep track of the total amount ever contributed by users, and use that for calculations, or make staking 1 vUSD = 1 share if the pool total is below the total number of shares"
            },
            {
                "Location": "function processWithdrawals(uint256 _maxIterations) external",
                "Type": "Denial of Service",
                "Description": "Blocking of the VUSD withdrawals is possible if the reserve token doesn't support zero value transfers, as VUSD withdraw queue position can be modified in the processWithdrawals function only, but it will fail every time on the zero amount entry, as there is no way to skip it, so anything else after this zero entry will not be processed.",
                "Repair": "Add a zero amount check to prevent zero value transfers from blocking the VUSD withdraw queue"
            },
            {
                "Location": "withdrawals are queued in an array and processed sequentially in a for loop",
                "Type": "DoS",
                "Description": "USDC blacklisted accounts can DoS the withdrawal system.",
                "Repair": "Implement 2-step withdrawals or skip blacklisted users in a processWithdrawals loop"
            },
            {
                "Location": "Usage of an incorrect version of Ownable library",
                "Type": "Incorrect library usage",
                "Description": "Usage of an incorrect version of Ownable library can potentially malfunction all onlyOwner functions.",
                "Repair": "Use the upgradeable version of Ownable library and add __Ownable_init() at the beginning of the initializer"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { HubbleBase } from \"./legos/HubbleBase.sol\";\nimport {\n    ERC20Detailed,\n    IClearingHouse,\n    IInsuranceFund,\n    IOracle,\n    IRegistry,\n    IMarginAccount,\n    IERC20FlexibleSupply\n} from \"./Interfaces.sol\";\n\n/**\n* @title This contract is used for posting margin (collateral), realizing PnL etc.\n* @notice Most notable operations include addMargin, removeMargin and liquidations\n*/\ncontract MarginAccount is IMarginAccount, HubbleBase {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    // Hubble vUSD is necessitated to be the first whitelisted collateral\n    uint constant VUSD_IDX = 0;\n\n    // used for all usd based values\n    uint constant PRECISION = 1e6;\n\n    error NOT_LIQUIDATABLE(IMarginAccount.LiquidationStatus);\n\n    /**\n    * @dev This is only used to group variables to avoid a solidity stack too deep error\n    *   incentivePerDollar How many $ liquidator gets for each $ they repay e.g. they might get $1.05 for every $1 liquidation. >= PRECISION\n    *   repayAble The maximum debt that can be settled for an account undergoing a liquidation\n    *   priceCollateral Most recent oracle price (chainlink) of the collateral that is being seized for an account undergoing a liquidation\n    *   decimals Decimals for the collateral being seized\n    */\n    struct LiquidationBuffer {\n        LiquidationStatus status;\n        uint8 decimals;\n        uint incentivePerDollar;\n        uint repayAble;\n        uint priceCollateral;\n    }\n\n    /* ****************** */\n    /*       Storage      */\n    /* ****************** */\n\n    IClearingHouse public clearingHouse;\n    IOracle public oracle;\n    IInsuranceFund public insuranceFund;\n    IERC20FlexibleSupply public vusd;\n    uint public credit;\n\n    /// @notice Array of supported collateral\n    Collateral[] public supportedCollateral;\n\n    /**\n    * @notice How many $ liquidator gets for each $ they repay e.g. they might get $1.05 for every $1 liquidation\n    * @dev In the above scenario, this value will be %0.05 i.e. 5 cents incentive per dollar repayed\n    */\n    uint public liquidationIncentive;\n\n    /**\n    * @notice Maps index in supportedCollateral => trader => balance\n    * @dev equivalent to margin(uint idx, address user)\n    */\n    mapping(uint => mapping(address => int)) override public margin;\n\n    uint256[50] private __gap;\n\n    /* ****************** */\n    /*       Events       */\n    /* ****************** */\n\n    /// @notice Emitted when user adds margin for any of the supported collaterals\n    event MarginAdded(address indexed trader, uint256 indexed idx, uint amount, uint256 timestamp);\n\n    /// @notice Emitted when user removes margin for any of the supported collaterals\n    event MarginRemoved(address indexed trader, uint256 indexed idx, uint256 amount, uint256 timestamp);\n\n    /**\n    * @notice Mutates trader's vUSD balance\n    * @param trader Account who is realizing PnL\n    * @param realizedPnl Increase or decrease trader's vUSD balace by. +ve/-ve value means vUSD is added/removed respectively from trader's margin\n    */\n    event PnLRealized(address indexed trader, int256 realizedPnl, uint256 timestamp);\n\n    /**\n    * @notice Emitted when a trader's margin account is liquidated i.e. their vUSD debt is repayed in exchange for their collateral\n    * @param trader Trader whose margin account was liquidated\n    * @param idx Index of the collateral that was seized during the liquidation\n    * @param seizeAmount Amount of the collateral that was seized during the liquidation\n    * @param repayAmount The debt that was repayed\n    */\n    event MarginAccountLiquidated(address indexed trader, uint indexed idx, uint seizeAmount, uint repayAmount, uint256 timestamp);\n\n    /**\n    * @notice Emitted when funds from insurance fund are tasked to settle system's bad debt\n    * @param trader Account for which the bad debt was settled\n    * @param seized Collateral amounts that were seized\n    * @param repayAmount Debt that was settled. it's exactly equal to -vUSD when vUSD < 0\n    */\n    event SettledBadDebt(address indexed trader, uint[] seized, uint repayAmount, uint256 timestamp);\n\n    modifier onlyClearingHouse() {\n        require(_msgSender() == address(clearingHouse), \"Only clearingHouse\");\n        _;\n    }\n\n    constructor(address _trustedForwarder) HubbleBase(_trustedForwarder) {}\n\n    function initialize(\n        address _governance,\n        address _vusd\n    ) external initializer {\n        _setGovernace(_governance);\n        _addCollateral(_vusd, PRECISION); // weight = 1 * PRECISION\n        vusd = IERC20FlexibleSupply(_vusd);\n    }\n\n    /* ****************** */\n    /*       Margin       */\n    /* ****************** */\n\n    /**\n    * @notice Post margin\n    * @param idx Index of the supported collateral\n    * @param amount Amount to deposit (scaled same as the asset)\n    */\n    function addMargin(uint idx, uint amount) override external whenNotPaused {\n        addMarginFor(idx, amount, _msgSender());\n    }\n\n    /**\n    * @notice Post margin for another account\n    * @param idx Index of the supported collateral\n    * @param amount Amount to deposit (scaled same as the asset)\n    * @param to Account to post margin for\n    */\n    function addMarginFor(uint idx, uint amount, address to) override public whenNotPaused {\n        require(amount > 0, \"Add non-zero margin\");\n        // will revert for idx >= supportedCollateral.length\n        if (idx == VUSD_IDX) {\n            _transferInVusd(_msgSender(), amount);\n        } else {\n            supportedCollateral[idx].token.safeTransferFrom(_msgSender(), address(this), amount);\n        }\n        margin[idx][to] += amount.toInt256();\n        emit MarginAdded(to, idx, amount, _blockTimestamp());\n    }\n\n    /**\n    * @notice Withdraw margin.\n    *   Collateral can not be withdrawn if vUSD balance is < 0.\n    * @dev If the contract has insufficient vUSD balance, a loan is taken from the vUSD contract.\n    * @param idx Index of the supported collateral\n    * @param amount Amount to withdraw (scaled same as the asset)\n    */\n    function removeMargin(uint idx, uint256 amount) override external whenNotPaused {\n        address trader = _msgSender();\n\n        // credit funding payments\n        clearingHouse.updatePositions(trader);\n\n        require(margin[VUSD_IDX][trader] >= 0, \"Cannot remove margin when vusd balance is negative\");\n        require(margin[idx][trader] >= amount.toInt256(), \"Insufficient balance\");\n\n        margin[idx][trader] -= amount.toInt256();\n\n        // Check minimum margin requirement after withdrawal\n        require(clearingHouse.isAboveMinAllowableMargin(trader), \"MA.removeMargin.Below_MM\");\n\n        if (idx == VUSD_IDX) {\n            _transferOutVusd(trader, amount);\n        } else {\n            supportedCollateral[idx].token.safeTransfer(trader, amount);\n        }\n        emit MarginRemoved(trader, idx, amount, _blockTimestamp());\n    }\n\n    /**\n    * @notice Invoked to realize PnL, credit/debit funding payments, pay trade and liquidation fee\n    * @dev Will only make a change to VUSD balance.\n    *   only clearingHouse is authorized to call.\n    * @param trader Account to realize PnL for\n    * @param realizedPnl Amount to credit/debit\n    */\n    function realizePnL(address trader, int256 realizedPnl)\n        override\n        external\n        onlyClearingHouse\n    {\n        // -ve PnL will reduce balance\n        if (realizedPnl != 0) {\n            margin[VUSD_IDX][trader] += realizedPnl;\n            emit PnLRealized(trader, realizedPnl, _blockTimestamp());\n        }\n    }\n\n    function transferOutVusd(address recipient, uint amount)\n        override\n        external\n        onlyClearingHouse\n    {\n        _transferOutVusd(recipient, amount);\n    }\n\n    /* ****************** */\n    /*    Liquidations    */\n    /* ****************** */\n\n    /**\n    * @notice Determines if a trader's margin account can be liquidated now\n    * @param trader Account to check liquidation status for\n    * @param includeFunding whether to include funding payments before checking liquidation status\n    * @return _isLiquidatable Whether the account can be liquidated; reason if not\n    * @return repayAmount Trader's debt i.e. the max amount that they can be liquidated for\n    * @return incentivePerDollar How many $ liquidator gets for each $ they repay\n    *   e.g. they might get $1.05 for every $1 that is repayed.\n    */\n    function isLiquidatable(address trader, bool includeFunding)\n        override\n        public\n        view\n        returns(IMarginAccount.LiquidationStatus _isLiquidatable, uint repayAmount, uint incentivePerDollar)\n    {\n        int vusdBal = margin[VUSD_IDX][trader];\n        if (includeFunding) {\n            vusdBal -= clearingHouse.getTotalFunding(trader);\n        }\n        if (vusdBal >= 0) { // nothing to liquidate\n            return (IMarginAccount.LiquidationStatus.NO_DEBT, 0, 0);\n        }\n\n        (uint256 notionalPosition,) = clearingHouse.getTotalNotionalPositionAndUnrealizedPnl(trader);\n        if (notionalPosition != 0) { // Liquidate positions before liquidating margin account\n            return (IMarginAccount.LiquidationStatus.OPEN_POSITIONS, 0, 0);\n        }\n\n        (int256 weighted, int256 spot) = weightedAndSpotCollateral(trader);\n        if (weighted >= 0) {\n            return (IMarginAccount.LiquidationStatus.ABOVE_THRESHOLD, 0, 0);\n        }\n\n        // _isLiquidatable = IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE;\n        repayAmount = (-vusdBal).toUint256();\n        incentivePerDollar = PRECISION; // get atleast $1 worth of collateral for every $1 paid\n\n        if (spot > 0) {\n            /**\n                Liquidation scenario B, where Cw < |vUSD| < Cusd\n                => Cw - |vUSD| < 0\n                => Cw + vUSD (=weighted) < 0; since vUSD < 0\n                Max possible liquidationIncentive (for repaying |vUSD|) is Cusd\n            */\n            incentivePerDollar += _min(\n                liquidationIncentive, // incentivePerDollar = PRECISION + liquidationIncentive <= 1.1\n                // divide up all the extra dollars in proportion to repay amount\n                // note that spot value here is inclusive of the -ve vUSD value\n                spot.toUint256() * PRECISION / repayAmount\n            );\n        } /* else {\n            Since the protocol is already in deficit we don't have any money to give out as liquidationIncentive\n            Liquidation scenario C, where Cusd <= |vUSD|\n            => Cusd - |vUSD| <= 0\n            => Cusd + vUSD (=spot) <= 0; since vUSD < 0\n\n            @todo consider providing some incentive from insurance fund to execute a liquidation in this scenario.\n            That fee is basically provided so that insurance fund has to settle a lower bad debt and seize lesser amount of assets.\n            (because seized assets then need to sold/auctioned off, so that's extra work)\n        } */\n    }\n\n    /**\n    * @notice Liquidate a trader while mentioning the exact repay amount while capping \"slippage\" on the seized collateral\n    *   This maybe be considered as a \"swapExactInput\" operation.\n    *   It's required that trader has no open positions.\n    * @param trader Account to liquidate\n    * @param repay Amount to repay\n    * @param idx Index of the collateral to seize\n    * @param minSeizeAmount Min collateral output amount\n    */\n    function liquidateExactRepay(address trader, uint repay, uint idx, uint minSeizeAmount) external whenNotPaused {\n        clearingHouse.updatePositions(trader); // credits/debits funding\n        LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idx);\n        if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n            revert NOT_LIQUIDATABLE(buffer.status);\n        }\n        _liquidateExactRepay(buffer, trader, repay, idx, minSeizeAmount);\n    }\n\n    /**\n    * @notice Liquidate a trader while mentioning the exact collateral amount to be seized while capping \"slippage\" on the repay amount.\n    *   This maybe be considered as a \"swapExactOutput\" operation.\n    *   It's required that trader has no open positions.\n    * @param trader Account to liquidate\n    * @param maxRepay Max vUSD input amount\n    * @param idx Index of the collateral to seize\n    * @param seize Exact collateral amount desired to be seized\n    */\n    function liquidateExactSeize(address trader, uint maxRepay, uint idx, uint seize) external whenNotPaused {\n        clearingHouse.updatePositions(trader); // credits/debits funding\n        LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idx);\n        if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n            revert NOT_LIQUIDATABLE(buffer.status);\n        }\n        _liquidateExactSeize(buffer, trader, maxRepay, idx, seize);\n    }\n\n    /**\n    * @notice Either seize all available collateral\n    *   OR settle debt completely with (most likely) left over collateral.\n    *   It's required that trader has no open positions.\n    *   Seized collateral at it's current oracle price should be acceptable to the liquidator.\n    * @param trader Account to liquidate\n    * @param maxRepay Max vUSD input amount\n    * @param idxs Indices of the collateral to seize\n    */\n    function liquidateFlexible(address trader, uint maxRepay, uint[] calldata idxs) external whenNotPaused {\n        clearingHouse.updatePositions(trader); // credits/debits funding\n        uint repayed;\n        for (uint i = 0; i < idxs.length; i++) {\n            LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idxs[i]);\n            // revert only if trader has open positions, otherwise fail silently\n            if (buffer.status == IMarginAccount.LiquidationStatus.OPEN_POSITIONS) {\n                revert NOT_LIQUIDATABLE(buffer.status);\n            }\n            if (buffer.status != IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n                break;\n            }\n            repayed = _liquidateFlexible(trader, maxRepay, idxs[i]);\n            maxRepay -= repayed;\n        }\n    }\n\n    /**\n    * @notice Invoke a bad debt settlement using the insurance fund.\n    *   It's required that trader has no open positions when settling bad debt.\n    * @dev Debt is said to be bad when the spot value of user's collateral is not enough to cover their -ve vUSD balance\n    *   Since there are no open positions, debit/credit funding payments is not required.\n    * @param trader Account for which the bad debt needs to be settled\n    */\n    function settleBadDebt(address trader) external whenNotPaused {\n        (uint256 notionalPosition,) = clearingHouse.getTotalNotionalPositionAndUnrealizedPnl(trader);\n        require(notionalPosition == 0, \"Liquidate positions before settling bad debt\");\n\n        // The spot value of their collateral minus their vUSD obligation is a negative value\n        require(getSpotCollateralValue(trader) < 0, \"Above bad debt threshold\");\n\n        int vusdBal = margin[VUSD_IDX][trader];\n\n        // this check is not strictly required because getSpotCollateralValue(trader) < 0 is a stronger assertion\n        require(vusdBal < 0, \"Nothing to repay\");\n\n        uint badDebt = (-vusdBal).toUint256();\n        Collateral[] memory assets = supportedCollateral;\n\n        // This pulls the obligation\n        insuranceFund.seizeBadDebt(badDebt);\n        margin[VUSD_IDX][trader] = 0;\n\n        // Insurance fund gets all the available collateral\n        uint[] memory seized = new uint[](assets.length);\n        for (uint i = 1 /* skip vusd */; i < assets.length; i++) {\n            int amount = margin[i][trader];\n            if (amount > 0) {\n                margin[i][trader] = 0;\n                assets[i].token.safeTransfer(address(insuranceFund), amount.toUint256());\n                seized[i] = amount.toUint256();\n            }\n        }\n        emit SettledBadDebt(trader, seized, badDebt, _blockTimestamp());\n    }\n\n    /* ********************* */\n    /* Liquidations Internal */\n    /* ********************* */\n\n    /**\n    * @dev This function wil either seize all available collateral of type idx\n    * OR settle debt completely with (most likely) left over collateral\n    * @return Debt repayed <= repayble i.e. user's max debt\n    */\n    function _liquidateFlexible(address trader, uint maxRepay, uint idx) internal whenNotPaused returns(uint /* repayed */) {\n        LiquidationBuffer memory buffer = _getLiquidationInfo(trader, idx);\n\n        // Q. Can user's margin cover the entire debt?\n        uint repay = _seizeToRepay(buffer, margin[idx][trader].toUint256());\n\n        // A.1 Yes, it can cover the entire debt. Settle repayAble\n        if (repay >= buffer.repayAble) {\n            _liquidateExactRepay(\n                buffer,\n                trader,\n                buffer.repayAble, // exact repay amount\n                idx,\n                0 // minSeizeAmount=0 implies accept whatever the oracle price is\n            );\n            return buffer.repayAble; // repayed exactly repayAble and 0 is left to repay now\n        }\n\n        // A.2 No, collateral can not cover the entire debt. Seize all of it.\n        return _liquidateExactSeize(\n            buffer,\n            trader,\n            maxRepay,\n            idx,\n            margin[idx][trader].toUint256()\n        );\n    }\n\n    function _liquidateExactRepay(\n        LiquidationBuffer memory buffer,\n        address trader,\n        uint repay,\n        uint idx,\n        uint minSeizeAmount\n    )\n        internal\n        returns (uint seized)\n    {\n        // determine the seizable collateral amount on the basis of the most recent chainlink price feed\n        seized = _min(\n            _scaleDecimals(repay * buffer.incentivePerDollar, buffer.decimals - 6) / buffer.priceCollateral,\n            // can't seize more than available\n            // this also protects the liquidator in the scenario that they were front-run and only a small seize isn't worth it for them\n            margin[idx][trader].toUint256()\n        );\n        require(seized >= minSeizeAmount, \"Not seizing enough\");\n        _executeLiquidation(trader, repay, idx, seized, buffer.repayAble);\n    }\n\n    function _liquidateExactSeize(\n        LiquidationBuffer memory buffer,\n        address trader,\n        uint maxRepay,\n        uint idx,\n        uint seize\n    )\n        internal\n        returns (uint repay)\n    {\n        repay = _seizeToRepay(buffer, seize);\n        require(repay <= maxRepay, \"Need to repay more to seize that much\");\n        _executeLiquidation(trader, repay, idx, seize, buffer.repayAble);\n    }\n\n    /**\n    * @dev reverts if margin account is not liquidatable\n    */\n    function _getLiquidationInfo(address trader, uint idx) internal view returns (LiquidationBuffer memory buffer) {\n        require(idx > VUSD_IDX && idx < supportedCollateral.length, \"collateral not seizable\");\n        (buffer.status, buffer.repayAble, buffer.incentivePerDollar) = isLiquidatable(trader, false);\n        if (buffer.status == IMarginAccount.LiquidationStatus.IS_LIQUIDATABLE) {\n            Collateral memory coll = supportedCollateral[idx];\n            buffer.priceCollateral = oracle.getUnderlyingPrice(address(coll.token)).toUint256();\n            buffer.decimals = coll.decimals;\n        }\n    }\n\n    /**\n    * @dev Peform the actual liquidation.\n    *   1. Pull the repay amount from liquidator's account and credit trader's VUSD margin\n    *   2. Debit the seize amount and transfer to liquidator\n    * @return The debt that is leftover to be paid\n    */\n    function _executeLiquidation(address trader, uint repay, uint idx, uint seize, uint repayAble)\n        internal\n        returns (uint /* left over repayable */)\n    {\n        if (repay == 0 || seize == 0) { // provides more flexibility, so prefer not reverting\n            return repayAble;\n        }\n\n        _transferInVusd(_msgSender(), repay);\n        margin[VUSD_IDX][trader] += repay.toInt256();\n\n        margin[idx][trader] -= seize.toInt256();\n        supportedCollateral[idx].token.safeTransfer(_msgSender(), seize);\n\n        emit MarginAccountLiquidated(trader, idx, seize, repay, _blockTimestamp());\n        return repayAble - repay; // will ensure that the liquidator isn't repaying more than user's debt (and seizing a bigger amount of their collateral)\n    }\n\n    function _seizeToRepay(LiquidationBuffer memory buffer, uint seize) internal pure returns (uint repay) {\n        repay = seize * buffer.priceCollateral / (10 ** buffer.decimals);\n        if (buffer.incentivePerDollar > 0) {\n            repay = repay * PRECISION / buffer.incentivePerDollar;\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    function getSpotCollateralValue(address trader) override public view returns(int256 spot) {\n        (,spot) = weightedAndSpotCollateral(trader);\n    }\n\n    function getNormalizedMargin(address trader) override public view returns(int256 weighted) {\n        (weighted,) = weightedAndSpotCollateral(trader);\n    }\n\n    function weightedAndSpotCollateral(address trader)\n        public\n        view\n        returns (int256 weighted, int256 spot)\n    {\n        Collateral[] memory assets = supportedCollateral;\n        Collateral memory _collateral;\n\n        for (uint i = 0; i < assets.length; i++) {\n            _collateral = assets[i];\n\n            int numerator = margin[i][trader] * oracle.getUnderlyingPrice(address(assets[i].token));\n            uint denomDecimals = _collateral.decimals;\n\n            spot += (numerator / int(10 ** denomDecimals));\n            weighted += (numerator * _collateral.weight.toInt256() / int(10 ** (denomDecimals + 6)));\n        }\n    }\n\n    /* ****************** */\n    /*     UI Helpers     */\n    /* ****************** */\n\n    function supportedAssets() external view override returns (Collateral[] memory) {\n        return supportedCollateral;\n    }\n\n    function supportedAssetsLen() override external view returns (uint) {\n        return supportedCollateral.length;\n    }\n\n    /* ****************** */\n    /*    Misc Internal   */\n    /* ****************** */\n\n    function _addCollateral(address _coin, uint _weight) internal {\n        require(_weight <= PRECISION, \"weight > 1e6\");\n\n        Collateral[] memory _collaterals = supportedCollateral;\n        for (uint i = 0; i < _collaterals.length; i++) {\n            require(address(_collaterals[i].token) != _coin, \"collateral exists\");\n        }\n        supportedCollateral.push(\n            Collateral({\n                token: IERC20(_coin),\n                weight: _weight,\n                decimals: ERC20Detailed(_coin).decimals() // will fail if .decimals() is not defined on the contract\n            })\n        );\n    }\n\n    function _scaleDecimals(uint256 amount, uint8 decimals) internal pure returns(uint256) {\n        return amount * (10 ** decimals);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function _transferInVusd(address from, uint amount) internal {\n        IERC20(address(vusd)).safeTransferFrom(from, address(this), amount);\n        if (credit > 0) {\n            uint toBurn = Math.min(vusd.balanceOf(address(this)), credit);\n            credit -= toBurn;\n            vusd.burn(toBurn);\n        }\n    }\n\n    function _transferOutVusd(address recipient, uint amount) internal {\n        uint bal = vusd.balanceOf(address(this));\n        if (bal < amount) {\n            // Say there are 2 traders, Alice and Bob.\n            // Alice has a profitable position and realizes their PnL in form of vusd margin.\n            // But bob has not yet realized their -ve PnL.\n            // In that case we'll take a credit from vusd contract, which will eventually be returned when Bob pays their debt back.\n            uint _credit = amount - bal;\n            credit += _credit;\n            vusd.mint(address(this), _credit);\n        }\n        IERC20(address(vusd)).safeTransfer(recipient, amount);\n    }\n\n    /* ****************** */\n    /*     Governance     */\n    /* ****************** */\n\n    function syncDeps(address _registry, uint _liquidationIncentive) public onlyGovernance {\n        // protecting against setting a very high liquidation incentive. Max 10%\n        require(_liquidationIncentive <= PRECISION / 10, \"MA.syncDeps.LI_GT_10_percent\");\n        IRegistry registry = IRegistry(_registry);\n        require(registry.marginAccount() == address(this), \"Incorrect setup\");\n\n        clearingHouse = IClearingHouse(registry.clearingHouse());\n        oracle = IOracle(registry.oracle());\n        insuranceFund = IInsuranceFund(registry.insuranceFund());\n        liquidationIncentive = _liquidationIncentive;\n    }\n\n    function whitelistCollateral(address _coin, uint _weight) external onlyGovernance {\n        _addCollateral(_coin, _weight);\n    }\n\n    // function to change weight of an asset\n    function changeCollateralWeight(uint idx, uint _weight) external onlyGovernance {\n        require(_weight <= PRECISION, \"weight > 1e6\");\n        require(idx < supportedCollateral.length, \"Collateral not supported\");\n        supportedCollateral[idx].weight = _weight;\n    }\n}\n\n\n",
        "CodeNames": [
            "MarginAccount.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MarginAccount.sol",
                "Type": "Assets locked forever",
                "Description": "Assets transferred to the InsuranceFund will be locked forever.",
                "Repair": "Have a way for governance to sweep tokens to swap them"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\nimport { IRegistry } from \"./Interfaces.sol\";\n\ncontract InsuranceFund is VanillaGovernable, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    uint8 constant DECIMALS = 6;\n    uint constant PRECISION = 10 ** DECIMALS;\n\n    IERC20 public vusd;\n    address public marginAccount;\n    uint public pendingObligation;\n\n    uint256[50] private __gap;\n\n    event FundsAdded(address indexed insurer, uint amount, uint timestamp);\n    event FundsWithdrawn(address indexed insurer, uint amount, uint timestamp);\n    event BadDebtAccumulated(uint amount, uint timestamp);\n\n    modifier onlyMarginAccount() {\n        require(msg.sender == address(marginAccount), \"IF.only_margin_account\");\n        _;\n    }\n\n    function initialize(address _governance) external {\n        __ERC20_init(\"Hubble-Insurance-Fund\", \"HIF\"); // has initializer modifier\n        _setGovernace(_governance);\n    }\n\n    function deposit(uint _amount) external {\n        settlePendingObligation();\n        // we want to protect new LPs, when the insurance fund is in deficit\n        require(pendingObligation == 0, \"IF.deposit.pending_obligations\");\n\n        uint _pool = balance();\n        uint _totalSupply = totalSupply();\n        if (_totalSupply == 0 && _pool > 0) { // trading fee accumulated while there were no IF LPs\n            vusd.safeTransfer(governance, _pool);\n            _pool = 0;\n        }\n\n        vusd.safeTransferFrom(msg.sender, address(this), _amount);\n        uint shares = 0;\n        if (_pool == 0) {\n            shares = _amount;\n        } else {\n            shares = _amount * _totalSupply / _pool;\n        }\n        _mint(msg.sender, shares);\n        emit FundsAdded(msg.sender, _amount, block.timestamp);\n    }\n\n    function withdraw(uint _shares) external {\n        settlePendingObligation();\n        require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");\n        uint amount = balance() * _shares / totalSupply();\n        _burn(msg.sender, _shares);\n        vusd.safeTransfer(msg.sender, amount);\n        emit FundsWithdrawn(msg.sender, amount, block.timestamp);\n    }\n\n    function seizeBadDebt(uint amount) external onlyMarginAccount {\n        pendingObligation += amount;\n        emit BadDebtAccumulated(amount, block.timestamp);\n        settlePendingObligation();\n    }\n\n    function settlePendingObligation() public {\n        if (pendingObligation > 0) {\n            uint toTransfer = Math.min(vusd.balanceOf(address(this)), pendingObligation);\n            if (toTransfer > 0) {\n                pendingObligation -= toTransfer;\n                vusd.safeTransfer(marginAccount, toTransfer);\n            }\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    /**\n    * @notice Just a vanity function\n    */\n    function pricePerShare() external view returns (uint) {\n        uint _totalSupply = totalSupply();\n        uint _balance = balance();\n        _balance -= Math.min(_balance, pendingObligation);\n        if (_totalSupply == 0 || _balance == 0) {\n            return PRECISION;\n        }\n        return _balance * PRECISION / _totalSupply;\n    }\n\n    function balance() public view returns (uint) {\n        return vusd.balanceOf(address(this));\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return DECIMALS;\n    }\n\n    /* ****************** */\n    /*   onlyGovernance   */\n    /* ****************** */\n\n    function syncDeps(IRegistry _registry) public onlyGovernance {\n        vusd = IERC20(_registry.vusd());\n        marginAccount = _registry.marginAccount();\n    }\n}\n\n\n",
        "CodeNames": [
            "InsuranceFund.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "InsuranceFund.sol",
                "Type": "Change of contract address",
                "Description": "The Governance address can call InsuranceFund.sol#syncDeps() to change the contract address of vusd anytime. However, in some edge cases, it can result in users' loss of funds.",
                "Repair": "Consider making vusd unchangeable or add a check to ensure that the balance remains the same after changing the contract address"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ERC20PresetMinterPauserUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\n\ncontract VUSD is VanillaGovernable, ERC20PresetMinterPauserUpgradeable {\n    using SafeERC20 for IERC20;\n\n    struct Withdrawal {\n        address usr;\n        uint amount;\n    }\n\n    /// @notice vUSD is backed 1:1 with reserveToken (USDC)\n    IERC20 public immutable reserveToken;\n\n    Withdrawal[] public withdrawals;\n\n    /// @dev withdrawals will start processing at withdrawals[start]\n    uint public start;\n\n    /// @dev Constrained by block gas limit\n    uint public maxWithdrawalProcesses;\n\n    uint256[50] private __gap;\n\n    constructor(address _reserveToken) {\n        require(_reserveToken != address(0), \"vUSD: null _reserveToken\");\n        reserveToken = IERC20(_reserveToken);\n    }\n\n    function init(address _governance) external {\n        super.initialize(\"Hubble USD\", \"hUSD\"); // has initializer modifier\n        _setGovernace(_governance);\n        maxWithdrawalProcesses = 100;\n    }\n\n    function mintWithReserve(address to, uint amount) external {\n        reserveToken.safeTransferFrom(msg.sender, address(this), amount);\n        _mint(to, amount);\n    }\n\n    function withdraw(uint amount) external {\n        burn(amount);\n        withdrawals.push(Withdrawal(msg.sender, amount));\n    }\n\n    function processWithdrawals() external {\n        uint reserve = reserveToken.balanceOf(address(this));\n        require(reserve >= withdrawals[start].amount, 'Cannot process withdrawals at this time: Not enough balance');\n        uint i = start;\n        while (i < withdrawals.length && (i - start) <= maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n            reserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\n            reserve -= withdrawal.amount;\n            i += 1;\n        }\n        start = i;\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return 6;\n    }\n\n    function setMaxWithdrawalProcesses(uint _maxWithdrawalProcesses) external onlyGovernance {\n        maxWithdrawalProcesses = _maxWithdrawalProcesses;\n    }\n}\n\n\n",
        "CodeNames": [
            "VUSD.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VUSD.sol",
                "Type": "Two governance models",
                "Description": "The contract uses two governance models, one looks hidden, which can hide or raise suspicion about a rogue pool, thus damaging the user's trust.",
                "Repair": "Unify governance in only one, VanillaGovernable or role based"
            },
            {
                "Location": "VUSD.sol",
                "Type": "Denial of service",
                "Description": "An attacker can push to withdrawals enormous amount of withdrawals with amount = 0, which can lead to various malfunctions and lock funds.",
                "Repair": "Set a minimum amount of withdrawal or clear the queue after processing withdrawals"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { HubbleBase } from \"./legos/HubbleBase.sol\";\nimport { IAMM, IInsuranceFund, IMarginAccount, IClearingHouse } from \"./Interfaces.sol\";\nimport { VUSD } from \"./VUSD.sol\";\n\ncontract ClearingHouse is IClearingHouse, HubbleBase {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    uint256 constant PRECISION = 1e6;\n\n    int256 override public maintenanceMargin;\n    uint override public tradeFee;\n    uint override public liquidationPenalty;\n    int256 public minAllowableMargin;\n\n    VUSD public vusd;\n    IInsuranceFund public insuranceFund;\n    IMarginAccount public marginAccount;\n    IAMM[] override public amms;\n\n    uint256[50] private __gap;\n\n    event PositionModified(address indexed trader, uint indexed idx, int256 baseAsset, uint quoteAsset, uint256 timestamp);\n    event PositionLiquidated(address indexed trader, uint indexed idx, int256 baseAsset, uint256 quoteAsset, uint256 timestamp);\n    event MarketAdded(uint indexed idx, address indexed amm);\n\n    constructor(address _trustedForwarder) HubbleBase(_trustedForwarder) {}\n\n    function initialize(\n        address _governance,\n        address _insuranceFund,\n        address _marginAccount,\n        address _vusd,\n        int256 _maintenanceMargin,\n        int256 _minAllowableMargin,\n        uint _tradeFee,\n        uint _liquidationPenalty\n    ) external initializer {\n        _setGovernace(_governance);\n\n        insuranceFund = IInsuranceFund(_insuranceFund);\n        marginAccount = IMarginAccount(_marginAccount);\n        vusd = VUSD(_vusd);\n\n        require(_maintenanceMargin > 0, \"_maintenanceMargin < 0\");\n        maintenanceMargin = _maintenanceMargin;\n        minAllowableMargin = _minAllowableMargin;\n        tradeFee = _tradeFee;\n        liquidationPenalty = _liquidationPenalty;\n    }\n\n    /**\n    * @notice Open/Modify/Close Position\n    * @param idx AMM index\n    * @param baseAssetQuantity Quantity of the base asset to Long (baseAssetQuantity > 0) or Short (baseAssetQuantity < 0)\n    * @param quoteAssetLimit Rate at which the trade is executed in the AMM. Used to cap slippage.\n    */\n    function openPosition(uint idx, int256 baseAssetQuantity, uint quoteAssetLimit) override external whenNotPaused {\n        _openPosition(_msgSender(), idx, baseAssetQuantity, quoteAssetLimit);\n    }\n\n    function closePosition(uint idx, uint quoteAssetLimit) override external whenNotPaused {\n        address trader = _msgSender();\n        (int256 size,,) = amms[idx].positions(trader);\n        _openPosition(trader, idx, -size, quoteAssetLimit);\n    }\n\n    function _openPosition(address trader, uint idx, int256 baseAssetQuantity, uint quoteAssetLimit) internal {\n        require(baseAssetQuantity != 0, \"CH: baseAssetQuantity == 0\");\n\n        updatePositions(trader); // adjust funding payments\n\n        (int realizedPnl, uint quoteAsset, bool isPositionIncreased) = amms[idx].openPosition(trader, baseAssetQuantity, quoteAssetLimit);\n        uint _tradeFee = _chargeFeeAndRealizePnL(trader, realizedPnl, quoteAsset, false /* isLiquidation */);\n        marginAccount.transferOutVusd(address(insuranceFund), _tradeFee);\n\n        if (isPositionIncreased) {\n            require(isAboveMinAllowableMargin(trader), \"CH: Below Minimum Allowable Margin\");\n        }\n        emit PositionModified(trader, idx, baseAssetQuantity, quoteAsset, _blockTimestamp());\n    }\n\n    /**\n    * @notice Add liquidity to the amm. The free margin from margin account is utilized for the same\n    *   The liquidity can be provided on leverage.\n    * @param idx Index of the AMM\n    * @param baseAssetQuantity Amount of the asset to add to AMM. Equivalent amount of USD side is automatically added.\n    *   This means that user is actually adding 2 * baseAssetQuantity * markPrice.\n    * @param minDToken Min amount of dTokens to receive. Used to cap slippage.\n    */\n    function addLiquidity(uint idx, uint256 baseAssetQuantity, uint minDToken) override external whenNotPaused {\n        address maker = _msgSender();\n        updatePositions(maker);\n        amms[idx].addLiquidity(maker, baseAssetQuantity, minDToken);\n        require(isAboveMinAllowableMargin(maker), \"CH: Below Minimum Allowable Margin\");\n    }\n\n    /**\n    * @notice Remove liquidity from the amm.\n    * @param idx Index of the AMM\n    * @param dToken Measure of the liquidity to remove.\n    * @param minQuoteValue Min amount of USD to remove.\n    * @param minBaseValue Min amount of base to remove.\n    *   Both the above params enable capping slippage in either direction.\n    */\n    function removeLiquidity(uint idx, uint256 dToken, uint minQuoteValue, uint minBaseValue) override external whenNotPaused {\n        address maker = _msgSender();\n        updatePositions(maker);\n        (int256 realizedPnl,) = amms[idx].removeLiquidity(maker, dToken, minQuoteValue, minBaseValue);\n        marginAccount.realizePnL(maker, realizedPnl);\n    }\n\n    function updatePositions(address trader) override public whenNotPaused {\n        require(address(trader) != address(0), 'CH: 0x0 trader Address');\n        int256 fundingPayment;\n        for (uint i = 0; i < amms.length; i++) {\n            fundingPayment += amms[i].updatePosition(trader);\n        }\n        // -ve fundingPayment means trader should receive funds\n        marginAccount.realizePnL(trader, -fundingPayment);\n    }\n\n    function settleFunding() override external whenNotPaused {\n        for (uint i = 0; i < amms.length; i++) {\n            amms[i].settleFunding();\n        }\n    }\n\n    /* ****************** */\n    /*    Liquidations    */\n    /* ****************** */\n\n    function liquidate(address trader) override external whenNotPaused {\n        updatePositions(trader);\n        if (isMaker(trader)) {\n            _liquidateMaker(trader);\n        } else {\n            _liquidateTaker(trader);\n        }\n    }\n\n    function liquidateMaker(address maker) override public whenNotPaused {\n        updatePositions(maker);\n        _liquidateMaker(maker);\n    }\n\n    function liquidateTaker(address trader) override public whenNotPaused {\n        require(!isMaker(trader), 'CH: Remove Liquidity First');\n        updatePositions(trader);\n        _liquidateTaker(trader);\n    }\n\n    /* ********************* */\n    /* Liquidations Internal */\n    /* ********************* */\n\n    function _liquidateMaker(address maker) internal {\n        require(\n            _calcMarginFraction(maker, false) < maintenanceMargin,\n            \"CH: Above Maintenance Margin\"\n        );\n        int256 realizedPnl;\n        uint quoteAsset;\n        for (uint i = 0; i < amms.length; i++) {\n            (,, uint dToken,,,,) = amms[i].makers(maker);\n            // @todo put checks on slippage\n            (int256 _realizedPnl, uint _quote) = amms[i].removeLiquidity(maker, dToken, 0, 0);\n            realizedPnl += _realizedPnl;\n            quoteAsset += _quote;\n        }\n\n        _disperseLiquidationFee(\n            _chargeFeeAndRealizePnL(\n                maker,\n                realizedPnl,\n                2 * quoteAsset,  // total liquidity value = 2 * quote value\n                true // isLiquidation\n            )\n        );\n    }\n\n    function _liquidateTaker(address trader) internal {\n        require(_calcMarginFraction(trader, false /* check funding payments again */) < maintenanceMargin, \"Above Maintenance Margin\");\n        int realizedPnl;\n        uint quoteAsset;\n        int256 size;\n        IAMM _amm;\n        for (uint i = 0; i < amms.length; i++) { // liquidate all positions\n            _amm = amms[i];\n            (size,,) = _amm.positions(trader);\n            if (size != 0) {\n                (int _realizedPnl, uint _quoteAsset) = _amm.liquidatePosition(trader);\n                realizedPnl += _realizedPnl;\n                quoteAsset += _quoteAsset;\n                emit PositionLiquidated(trader, i, size, _quoteAsset, _blockTimestamp());\n            }\n        }\n\n        _disperseLiquidationFee(\n            _chargeFeeAndRealizePnL(trader, realizedPnl, quoteAsset, true /* isLiquidation */)\n        );\n    }\n\n    function _disperseLiquidationFee(uint liquidationFee) internal {\n        if (liquidationFee > 0) {\n            uint toInsurance = liquidationFee / 2;\n            marginAccount.transferOutVusd(address(insuranceFund), toInsurance);\n            marginAccount.transferOutVusd(_msgSender(), liquidationFee - toInsurance);\n        }\n    }\n\n    function _chargeFeeAndRealizePnL(\n        address trader,\n        int realizedPnl,\n        uint quoteAsset,\n        bool isLiquidation\n    )\n        internal\n        returns (uint fee)\n    {\n        fee = isLiquidation ? _calculateLiquidationPenalty(quoteAsset) : _calculateTradeFee(quoteAsset);\n        int256 marginCharge = realizedPnl - fee.toInt256();\n        if (marginCharge != 0) {\n            marginAccount.realizePnL(trader, marginCharge);\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    function isAboveMaintenanceMargin(address trader) override external view returns(bool) {\n        return getMarginFraction(trader) >= maintenanceMargin;\n    }\n\n    function isAboveMinAllowableMargin(address trader) override public view returns(bool) {\n        return getMarginFraction(trader) >= minAllowableMargin;\n    }\n\n    function getMarginFraction(address trader) override public view returns(int256) {\n        return _calcMarginFraction(trader, true /* includeFundingPayments */);\n    }\n\n    function isMaker(address trader) override public view returns(bool) {\n        for (uint i = 0; i < amms.length; i++) {\n            (,, uint dToken,,,,) = amms[i].makers(trader);\n            if (dToken > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getTotalFunding(address trader) override public view returns(int256 totalFunding) {\n        int256 takerFundingPayment;\n        int256 makerFundingPayment;\n        for (uint i = 0; i < amms.length; i++) {\n            (takerFundingPayment, makerFundingPayment,,) = amms[i].getPendingFundingPayment(trader);\n            totalFunding += (takerFundingPayment + makerFundingPayment);\n        }\n    }\n\n    function getTotalNotionalPositionAndUnrealizedPnl(address trader)\n        override\n        public\n        view\n        returns(uint256 notionalPosition, int256 unrealizedPnl)\n    {\n        uint256 _notionalPosition;\n        int256 _unrealizedPnl;\n        for (uint i = 0; i < amms.length; i++) {\n            (_notionalPosition, _unrealizedPnl,,) = amms[i].getNotionalPositionAndUnrealizedPnl(trader);\n            notionalPosition += _notionalPosition;\n            unrealizedPnl += _unrealizedPnl;\n        }\n    }\n\n    function getNotionalPositionAndMargin(address trader, bool includeFundingPayments)\n        override\n        public\n        view\n        returns(uint256 notionalPosition, int256 margin)\n    {\n        int256 unrealizedPnl;\n        (notionalPosition, unrealizedPnl) = getTotalNotionalPositionAndUnrealizedPnl(trader);\n        margin = marginAccount.getNormalizedMargin(trader);\n        margin += unrealizedPnl;\n        if (includeFundingPayments) {\n            margin -= getTotalFunding(trader); // -ve fundingPayment means trader should receive funds\n        }\n    }\n\n    function getAmmsLength() override external view returns(uint) {\n        return amms.length;\n    }\n\n    function getAMMs() external view returns (IAMM[] memory) {\n        return amms;\n    }\n\n    /* ****************** */\n    /*   Internal View    */\n    /* ****************** */\n\n    function _calculateTradeFee(uint quoteAsset) internal view returns (uint) {\n        return quoteAsset * tradeFee / PRECISION;\n    }\n\n    function _calculateLiquidationPenalty(uint quoteAsset) internal view returns (uint) {\n        return quoteAsset * liquidationPenalty / PRECISION;\n    }\n\n    function _calcMarginFraction(address trader, bool includeFundingPayments) internal view returns(int256) {\n        (uint256 notionalPosition, int256 margin) = getNotionalPositionAndMargin(trader, includeFundingPayments);\n        return _getMarginFraction(margin, notionalPosition);\n    }\n\n    /* ****************** */\n    /*        Pure        */\n    /* ****************** */\n\n    function _getMarginFraction(int256 accountValue, uint notionalPosition) private pure returns(int256) {\n        if (notionalPosition == 0) {\n            return type(int256).max;\n        }\n        return accountValue * PRECISION.toInt256() / notionalPosition.toInt256();\n    }\n\n    /* ****************** */\n    /*     Governance     */\n    /* ****************** */\n\n    function whitelistAmm(address _amm) external onlyGovernance {\n        emit MarketAdded(amms.length, _amm);\n        amms.push(IAMM(_amm));\n    }\n\n    function setParams(\n        int _maintenanceMargin,\n        int _minAllowableMargin,\n        uint _tradeFee,\n        uint _liquidationPenality\n    ) external onlyGovernance {\n        tradeFee = _tradeFee;\n        liquidationPenalty = _liquidationPenality;\n        maintenanceMargin = _maintenanceMargin;\n        minAllowableMargin = _minAllowableMargin;\n    }\n}\n\n\n",
        "CodeNames": [
            "ClearingHouse.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ClearingHouse.sol",
                "Type": "Margin calculation error",
                "Description": "If an VAMM that has different precision is whitelisted, then margin requirements checks become invalid, which can lead to various malfunctions and liquidation of valid positions.",
                "Repair": "Remove decimals related hard coding, adding decimals variables and scaling VAMM returned results accordingly"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { HubbleBase } from \"./legos/HubbleBase.sol\";\nimport { IAMM, IInsuranceFund, IMarginAccount, IClearingHouse } from \"./Interfaces.sol\";\nimport { VUSD } from \"./VUSD.sol\";\n\ncontract ClearingHouse is IClearingHouse, HubbleBase {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    uint256 constant PRECISION = 1e6;\n\n    int256 override public maintenanceMargin;\n    uint override public tradeFee;\n    uint override public liquidationPenalty;\n    int256 public minAllowableMargin;\n\n    VUSD public vusd;\n    IInsuranceFund public insuranceFund;\n    IMarginAccount public marginAccount;\n    IAMM[] override public amms;\n\n    uint256[50] private __gap;\n\n    event PositionModified(address indexed trader, uint indexed idx, int256 baseAsset, uint quoteAsset, uint256 timestamp);\n    event PositionLiquidated(address indexed trader, uint indexed idx, int256 baseAsset, uint256 quoteAsset, uint256 timestamp);\n    event MarketAdded(uint indexed idx, address indexed amm);\n\n    constructor(address _trustedForwarder) HubbleBase(_trustedForwarder) {}\n\n    function initialize(\n        address _governance,\n        address _insuranceFund,\n        address _marginAccount,\n        address _vusd,\n        int256 _maintenanceMargin,\n        int256 _minAllowableMargin,\n        uint _tradeFee,\n        uint _liquidationPenalty\n    ) external initializer {\n        _setGovernace(_governance);\n\n        insuranceFund = IInsuranceFund(_insuranceFund);\n        marginAccount = IMarginAccount(_marginAccount);\n        vusd = VUSD(_vusd);\n\n        require(_maintenanceMargin > 0, \"_maintenanceMargin < 0\");\n        maintenanceMargin = _maintenanceMargin;\n        minAllowableMargin = _minAllowableMargin;\n        tradeFee = _tradeFee;\n        liquidationPenalty = _liquidationPenalty;\n    }\n\n    /**\n    * @notice Open/Modify/Close Position\n    * @param idx AMM index\n    * @param baseAssetQuantity Quantity of the base asset to Long (baseAssetQuantity > 0) or Short (baseAssetQuantity < 0)\n    * @param quoteAssetLimit Rate at which the trade is executed in the AMM. Used to cap slippage.\n    */\n    function openPosition(uint idx, int256 baseAssetQuantity, uint quoteAssetLimit) override external whenNotPaused {\n        _openPosition(_msgSender(), idx, baseAssetQuantity, quoteAssetLimit);\n    }\n\n    function closePosition(uint idx, uint quoteAssetLimit) override external whenNotPaused {\n        address trader = _msgSender();\n        (int256 size,,) = amms[idx].positions(trader);\n        _openPosition(trader, idx, -size, quoteAssetLimit);\n    }\n\n    function _openPosition(address trader, uint idx, int256 baseAssetQuantity, uint quoteAssetLimit) internal {\n        require(baseAssetQuantity != 0, \"CH: baseAssetQuantity == 0\");\n\n        updatePositions(trader); // adjust funding payments\n\n        (int realizedPnl, uint quoteAsset, bool isPositionIncreased) = amms[idx].openPosition(trader, baseAssetQuantity, quoteAssetLimit);\n        uint _tradeFee = _chargeFeeAndRealizePnL(trader, realizedPnl, quoteAsset, false /* isLiquidation */);\n        marginAccount.transferOutVusd(address(insuranceFund), _tradeFee);\n\n        if (isPositionIncreased) {\n            require(isAboveMinAllowableMargin(trader), \"CH: Below Minimum Allowable Margin\");\n        }\n        emit PositionModified(trader, idx, baseAssetQuantity, quoteAsset, _blockTimestamp());\n    }\n\n    /**\n    * @notice Add liquidity to the amm. The free margin from margin account is utilized for the same\n    *   The liquidity can be provided on leverage.\n    * @param idx Index of the AMM\n    * @param baseAssetQuantity Amount of the asset to add to AMM. Equivalent amount of USD side is automatically added.\n    *   This means that user is actually adding 2 * baseAssetQuantity * markPrice.\n    * @param minDToken Min amount of dTokens to receive. Used to cap slippage.\n    */\n    function addLiquidity(uint idx, uint256 baseAssetQuantity, uint minDToken) override external whenNotPaused {\n        address maker = _msgSender();\n        updatePositions(maker);\n        amms[idx].addLiquidity(maker, baseAssetQuantity, minDToken);\n        require(isAboveMinAllowableMargin(maker), \"CH: Below Minimum Allowable Margin\");\n    }\n\n    /**\n    * @notice Remove liquidity from the amm.\n    * @param idx Index of the AMM\n    * @param dToken Measure of the liquidity to remove.\n    * @param minQuoteValue Min amount of USD to remove.\n    * @param minBaseValue Min amount of base to remove.\n    *   Both the above params enable capping slippage in either direction.\n    */\n    function removeLiquidity(uint idx, uint256 dToken, uint minQuoteValue, uint minBaseValue) override external whenNotPaused {\n        address maker = _msgSender();\n        updatePositions(maker);\n        (int256 realizedPnl,) = amms[idx].removeLiquidity(maker, dToken, minQuoteValue, minBaseValue);\n        marginAccount.realizePnL(maker, realizedPnl);\n    }\n\n    function updatePositions(address trader) override public whenNotPaused {\n        require(address(trader) != address(0), 'CH: 0x0 trader Address');\n        int256 fundingPayment;\n        for (uint i = 0; i < amms.length; i++) {\n            fundingPayment += amms[i].updatePosition(trader);\n        }\n        // -ve fundingPayment means trader should receive funds\n        marginAccount.realizePnL(trader, -fundingPayment);\n    }\n\n    function settleFunding() override external whenNotPaused {\n        for (uint i = 0; i < amms.length; i++) {\n            amms[i].settleFunding();\n        }\n    }\n\n    /* ****************** */\n    /*    Liquidations    */\n    /* ****************** */\n\n    function liquidate(address trader) override external whenNotPaused {\n        updatePositions(trader);\n        if (isMaker(trader)) {\n            _liquidateMaker(trader);\n        } else {\n            _liquidateTaker(trader);\n        }\n    }\n\n    function liquidateMaker(address maker) override public whenNotPaused {\n        updatePositions(maker);\n        _liquidateMaker(maker);\n    }\n\n    function liquidateTaker(address trader) override public whenNotPaused {\n        require(!isMaker(trader), 'CH: Remove Liquidity First');\n        updatePositions(trader);\n        _liquidateTaker(trader);\n    }\n\n    /* ********************* */\n    /* Liquidations Internal */\n    /* ********************* */\n\n    function _liquidateMaker(address maker) internal {\n        require(\n            _calcMarginFraction(maker, false) < maintenanceMargin,\n            \"CH: Above Maintenance Margin\"\n        );\n        int256 realizedPnl;\n        uint quoteAsset;\n        for (uint i = 0; i < amms.length; i++) {\n            (,, uint dToken,,,,) = amms[i].makers(maker);\n            // @todo put checks on slippage\n            (int256 _realizedPnl, uint _quote) = amms[i].removeLiquidity(maker, dToken, 0, 0);\n            realizedPnl += _realizedPnl;\n            quoteAsset += _quote;\n        }\n\n        _disperseLiquidationFee(\n            _chargeFeeAndRealizePnL(\n                maker,\n                realizedPnl,\n                2 * quoteAsset,  // total liquidity value = 2 * quote value\n                true // isLiquidation\n            )\n        );\n    }\n\n    function _liquidateTaker(address trader) internal {\n        require(_calcMarginFraction(trader, false /* check funding payments again */) < maintenanceMargin, \"Above Maintenance Margin\");\n        int realizedPnl;\n        uint quoteAsset;\n        int256 size;\n        IAMM _amm;\n        for (uint i = 0; i < amms.length; i++) { // liquidate all positions\n            _amm = amms[i];\n            (size,,) = _amm.positions(trader);\n            if (size != 0) {\n                (int _realizedPnl, uint _quoteAsset) = _amm.liquidatePosition(trader);\n                realizedPnl += _realizedPnl;\n                quoteAsset += _quoteAsset;\n                emit PositionLiquidated(trader, i, size, _quoteAsset, _blockTimestamp());\n            }\n        }\n\n        _disperseLiquidationFee(\n            _chargeFeeAndRealizePnL(trader, realizedPnl, quoteAsset, true /* isLiquidation */)\n        );\n    }\n\n    function _disperseLiquidationFee(uint liquidationFee) internal {\n        if (liquidationFee > 0) {\n            uint toInsurance = liquidationFee / 2;\n            marginAccount.transferOutVusd(address(insuranceFund), toInsurance);\n            marginAccount.transferOutVusd(_msgSender(), liquidationFee - toInsurance);\n        }\n    }\n\n    function _chargeFeeAndRealizePnL(\n        address trader,\n        int realizedPnl,\n        uint quoteAsset,\n        bool isLiquidation\n    )\n        internal\n        returns (uint fee)\n    {\n        fee = isLiquidation ? _calculateLiquidationPenalty(quoteAsset) : _calculateTradeFee(quoteAsset);\n        int256 marginCharge = realizedPnl - fee.toInt256();\n        if (marginCharge != 0) {\n            marginAccount.realizePnL(trader, marginCharge);\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    function isAboveMaintenanceMargin(address trader) override external view returns(bool) {\n        return getMarginFraction(trader) >= maintenanceMargin;\n    }\n\n    function isAboveMinAllowableMargin(address trader) override public view returns(bool) {\n        return getMarginFraction(trader) >= minAllowableMargin;\n    }\n\n    function getMarginFraction(address trader) override public view returns(int256) {\n        return _calcMarginFraction(trader, true /* includeFundingPayments */);\n    }\n\n    function isMaker(address trader) override public view returns(bool) {\n        for (uint i = 0; i < amms.length; i++) {\n            (,, uint dToken,,,,) = amms[i].makers(trader);\n            if (dToken > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getTotalFunding(address trader) override public view returns(int256 totalFunding) {\n        int256 takerFundingPayment;\n        int256 makerFundingPayment;\n        for (uint i = 0; i < amms.length; i++) {\n            (takerFundingPayment, makerFundingPayment,,) = amms[i].getPendingFundingPayment(trader);\n            totalFunding += (takerFundingPayment + makerFundingPayment);\n        }\n    }\n\n    function getTotalNotionalPositionAndUnrealizedPnl(address trader)\n        override\n        public\n        view\n        returns(uint256 notionalPosition, int256 unrealizedPnl)\n    {\n        uint256 _notionalPosition;\n        int256 _unrealizedPnl;\n        for (uint i = 0; i < amms.length; i++) {\n            (_notionalPosition, _unrealizedPnl,,) = amms[i].getNotionalPositionAndUnrealizedPnl(trader);\n            notionalPosition += _notionalPosition;\n            unrealizedPnl += _unrealizedPnl;\n        }\n    }\n\n    function getNotionalPositionAndMargin(address trader, bool includeFundingPayments)\n        override\n        public\n        view\n        returns(uint256 notionalPosition, int256 margin)\n    {\n        int256 unrealizedPnl;\n        (notionalPosition, unrealizedPnl) = getTotalNotionalPositionAndUnrealizedPnl(trader);\n        margin = marginAccount.getNormalizedMargin(trader);\n        margin += unrealizedPnl;\n        if (includeFundingPayments) {\n            margin -= getTotalFunding(trader); // -ve fundingPayment means trader should receive funds\n        }\n    }\n\n    function getAmmsLength() override external view returns(uint) {\n        return amms.length;\n    }\n\n    function getAMMs() external view returns (IAMM[] memory) {\n        return amms;\n    }\n\n    /* ****************** */\n    /*   Internal View    */\n    /* ****************** */\n\n    function _calculateTradeFee(uint quoteAsset) internal view returns (uint) {\n        return quoteAsset * tradeFee / PRECISION;\n    }\n\n    function _calculateLiquidationPenalty(uint quoteAsset) internal view returns (uint) {\n        return quoteAsset * liquidationPenalty / PRECISION;\n    }\n\n    function _calcMarginFraction(address trader, bool includeFundingPayments) internal view returns(int256) {\n        (uint256 notionalPosition, int256 margin) = getNotionalPositionAndMargin(trader, includeFundingPayments);\n        return _getMarginFraction(margin, notionalPosition);\n    }\n\n    /* ****************** */\n    /*        Pure        */\n    /* ****************** */\n\n    function _getMarginFraction(int256 accountValue, uint notionalPosition) private pure returns(int256) {\n        if (notionalPosition == 0) {\n            return type(int256).max;\n        }\n        return accountValue * PRECISION.toInt256() / notionalPosition.toInt256();\n    }\n\n    /* ****************** */\n    /*     Governance     */\n    /* ****************** */\n\n    function whitelistAmm(address _amm) external onlyGovernance {\n        emit MarketAdded(amms.length, _amm);\n        amms.push(IAMM(_amm));\n    }\n\n    function setParams(\n        int _maintenanceMargin,\n        int _minAllowableMargin,\n        uint _tradeFee,\n        uint _liquidationPenality\n    ) external onlyGovernance {\n        tradeFee = _tradeFee;\n        liquidationPenalty = _liquidationPenality;\n        maintenanceMargin = _maintenanceMargin;\n        minAllowableMargin = _minAllowableMargin;\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Governable } from \"./legos/Governable.sol\";\nimport { ERC20Detailed, IOracle, IRegistry, IVAMM, IAMM } from \"./Interfaces.sol\";\n\ncontract AMM is IAMM, Governable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    uint256 public constant spotPriceTwapInterval = 1 hours;\n    uint256 public constant fundingPeriod = 1 hours;\n    int256 constant BASE_PRECISION = 1e18;\n\n    // System-wide config\n\n    IOracle public oracle;\n    address public clearingHouse;\n\n    // AMM config\n\n    IVAMM override public vamm;\n    address override public underlyingAsset;\n    string public name;\n\n    uint256 public fundingBufferPeriod;\n    uint256 public nextFundingTime;\n    int256 public fundingRate;\n    int256 public cumulativePremiumFraction;\n    int256 public cumulativePremiumPerDtoken;\n    int256 public posAccumulator;\n\n    uint256 public longOpenInterestNotional;\n    uint256 public shortOpenInterestNotional;\n\n    enum Side { LONG, SHORT }\n    struct Position {\n        int256 size;\n        uint256 openNotional;\n        int256 lastPremiumFraction;\n    }\n    mapping(address => Position) override public positions;\n\n    struct Maker {\n        uint vUSD;\n        uint vAsset;\n        uint dToken;\n        int pos; // position\n        int posAccumulator; // value of global.posAccumulator until which pos has been updated\n        int lastPremiumFraction;\n        int lastPremiumPerDtoken;\n    }\n    mapping(address => Maker) override public makers;\n\n    struct ReserveSnapshot {\n        uint256 lastPrice;\n        uint256 timestamp;\n        uint256 blockNumber;\n    }\n    ReserveSnapshot[] public reserveSnapshots;\n\n    /**\n    * @dev We do not deliberately have a Pause state. There is only a master-level pause at clearingHouse level\n    */\n    enum AMMState { Inactive, Ignition, Active }\n    AMMState public ammState;\n\n    uint256[50] private __gap;\n\n    // Events\n\n    event PositionChanged(address indexed trader, int256 size, uint256 openNotional, int256 realizedPnl);\n    event FundingRateUpdated(int256 premiumFraction, int256 rate, uint256 underlyingPrice, uint256 timestamp, uint256 blockNumber);\n    event FundingPaid(address indexed trader, int256 takerPosSize, int256 takerFundingPayment, int256 makerFundingPayment, int256 latestCumulativePremiumFraction, int256 latestPremiumPerDtoken);\n    event Swap(int256 baseAsset, uint256 quoteAsset, uint256 lastPrice, uint256 openInterestNotional);\n    event LiquidityAdded(address indexed maker, uint dToken, uint baseAsset, uint quoteAsset, uint timestamp);\n    event LiquidityRemoved(address indexed maker, uint dToken, uint baseAsset, uint quoteAsset, uint timestamp, int256 realizedPnl);\n\n    modifier onlyClearingHouse() {\n        require(msg.sender == clearingHouse, \"Only clearingHouse\");\n        _;\n    }\n\n    modifier onlyVamm() {\n        require(msg.sender == address(vamm), \"Only VAMM\");\n        _;\n    }\n\n    function initialize(\n        address _registry,\n        address _underlyingAsset,\n        string memory _name,\n        address _vamm,\n        address _governance\n    ) external initializer {\n        _setGovernace(_governance);\n\n        vamm = IVAMM(_vamm);\n        underlyingAsset = _underlyingAsset;\n        name = _name;\n        fundingBufferPeriod = 15 minutes;\n\n        syncDeps(_registry);\n    }\n\n    /**\n    * @dev baseAssetQuantity != 0 has been validated in clearingHouse._openPosition()\n    */\n    function openPosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        override\n        external\n        onlyClearingHouse\n        returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased)\n    {\n        require(ammState == AMMState.Active, \"AMM.openPosition.not_active\");\n        Position memory position = positions[trader];\n        bool isNewPosition = position.size == 0 ? true : false;\n        Side side = baseAssetQuantity > 0 ? Side.LONG : Side.SHORT;\n        if (isNewPosition || (position.size > 0 ? Side.LONG : Side.SHORT) == side) {\n            // realizedPnl = 0;\n            quoteAsset = _increasePosition(trader, baseAssetQuantity, quoteAssetLimit);\n            isPositionIncreased = true;\n        } else {\n            (realizedPnl, quoteAsset, isPositionIncreased) = _openReversePosition(trader, baseAssetQuantity, quoteAssetLimit);\n        }\n        _emitPositionChanged(trader, realizedPnl);\n    }\n\n    function liquidatePosition(address trader)\n        override\n        external\n        onlyClearingHouse\n        returns (int realizedPnl, uint quoteAsset)\n    {\n        // don't need an ammState check because there should be no active positions\n        Position memory position = positions[trader];\n        bool isLongPosition = position.size > 0 ? true : false;\n        // sending market orders can fk the trader. @todo put some safe guards around price of liquidations\n        if (isLongPosition) {\n            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, 0);\n        } else {\n            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, type(uint).max);\n        }\n        _emitPositionChanged(trader, realizedPnl);\n    }\n\n    function updatePosition(address trader)\n        override\n        external\n        onlyClearingHouse\n        returns(int256 fundingPayment)\n    {\n        if (ammState != AMMState.Active) return 0;\n        (\n            int256 takerFundingPayment,\n            int256 makerFundingPayment,\n            int256 latestCumulativePremiumFraction,\n            int256 latestPremiumPerDtoken\n        ) = getPendingFundingPayment(trader);\n\n        Position storage position = positions[trader];\n        position.lastPremiumFraction = latestCumulativePremiumFraction;\n\n        Maker storage maker = makers[trader];\n        maker.lastPremiumFraction = latestCumulativePremiumFraction;\n        maker.lastPremiumPerDtoken = latestPremiumPerDtoken;\n\n        emit FundingPaid(trader, position.size, takerFundingPayment, makerFundingPayment, latestCumulativePremiumFraction, latestPremiumPerDtoken);\n\n        // +: trader paid, -: trader received\n        fundingPayment = takerFundingPayment + makerFundingPayment;\n        if (fundingPayment < 0) {\n            fundingPayment -= fundingPayment / 1e3; // receivers charged 0.1% to account for rounding-offs\n        }\n    }\n\n    function addLiquidity(address maker, uint baseAssetQuantity, uint minDToken)\n        override\n        external\n        onlyClearingHouse\n    {\n        require(ammState != AMMState.Inactive, \"AMM.addLiquidity.amm_inactive\");\n        uint quoteAsset;\n        uint baseAssetBal = vamm.balances(1);\n        if (baseAssetBal == 0) {\n            quoteAsset = baseAssetQuantity * vamm.price_scale() / 1e30;\n        } else {\n            quoteAsset = baseAssetQuantity * vamm.balances(0) / baseAssetBal;\n        }\n\n        uint _dToken = vamm.add_liquidity([quoteAsset, baseAssetQuantity], minDToken);\n\n        // updates\n        Maker storage _maker = makers[maker];\n        if (_maker.dToken > 0) { // Maker only accumulates position when they had non-zero liquidity\n            _maker.pos += (posAccumulator - _maker.posAccumulator) * _maker.dToken.toInt256() / 1e18;\n        }\n        _maker.vUSD += quoteAsset;\n        _maker.vAsset += baseAssetQuantity;\n        _maker.dToken += _dToken;\n        _maker.posAccumulator = posAccumulator;\n        emit LiquidityAdded(maker, _dToken, baseAssetQuantity, quoteAsset, _blockTimestamp());\n    }\n\n    function removeLiquidity(address maker, uint amount, uint minQuote, uint minBase)\n        override\n        external\n        onlyClearingHouse\n        returns (int256 /* realizedPnl */, uint /* quoteAsset */)\n    {\n        Maker memory _maker = makers[maker];\n        if (_maker.dToken == 0) {\n            return (0,0);\n        }\n\n        Position memory _taker = positions[maker];\n        // amount <= _maker.dToken will be asserted when updating maker.dToken\n        (\n            int256 makerPosition,\n            uint256 totalOpenNotional,\n            int256 feeAdjustedPnl,\n            uint[2] memory dBalances\n        ) = vamm.remove_liquidity(\n            amount,\n            [minQuote /* minimum QuoteAsset amount */, minBase /* minimum BaseAsset amount */],\n            _maker.vUSD,\n            _maker.vAsset,\n            _maker.dToken,\n            _taker.size,\n            _taker.openNotional\n        );\n\n        {\n            // update maker info\n            Maker storage __maker = makers[maker];\n            uint diff = _maker.dToken - amount;\n\n            if (diff == 0) {\n                __maker.pos = 0;\n                __maker.vAsset = 0;\n                __maker.vUSD = 0;\n                __maker.dToken = 0;\n            } else {\n                // muitiply by diff because a taker position will also be opened while removing liquidity and its funding payment is calculated seperately\n                __maker.pos = _maker.pos + (posAccumulator - _maker.posAccumulator) * diff.toInt256() / 1e18;\n                __maker.vAsset = _maker.vAsset * diff / _maker.dToken;\n                __maker.vUSD = _maker.vUSD * diff / _maker.dToken;\n                __maker.dToken = diff;\n            }\n            __maker.posAccumulator = posAccumulator;\n        }\n\n        int256 realizedPnl = feeAdjustedPnl;\n        {\n            if (makerPosition != 0) {\n                // translate impermanent position to a permanent one\n                Position storage position = positions[maker];\n                if (makerPosition * position.size < 0) { // reducing or reversing position\n                    uint newNotional = getCloseQuote(position.size + makerPosition);\n                    int256 reducePositionPnl = _getPnlWhileReducingPosition(position.size, position.openNotional, makerPosition, newNotional);\n                    realizedPnl += reducePositionPnl;\n                }\n                position.openNotional = totalOpenNotional;\n                position.size += makerPosition;\n\n                // update long and short open interest notional\n                if (makerPosition > 0) {\n                    longOpenInterestNotional += makerPosition.toUint256();\n                } else {\n                    shortOpenInterestNotional += (-makerPosition).toUint256();\n                }\n            }\n        }\n\n        emit LiquidityRemoved(maker, amount, dBalances[1] /** baseAsset */,\n            dBalances[0] /** quoteAsset */, _blockTimestamp(), realizedPnl);\n        return (realizedPnl, dBalances[0]);\n    }\n\n\n    function getOpenNotionalWhileReducingPosition(\n        int256 positionSize,\n        uint256 newNotionalPosition,\n        int256 unrealizedPnl,\n        int256 baseAssetQuantity\n    )\n        override\n        public\n        pure\n        returns(uint256 remainOpenNotional, int realizedPnl)\n    {\n        require(abs(positionSize) >= abs(baseAssetQuantity), \"AMM.ONLY_REDUCE_POS\");\n        bool isLongPosition = positionSize > 0 ? true : false;\n\n        realizedPnl = unrealizedPnl * abs(baseAssetQuantity) / abs(positionSize);\n        int256 unrealizedPnlAfter = unrealizedPnl - realizedPnl;\n\n        /**\n        * We need to determine the openNotional value of the reduced position now.\n        * We know notionalPosition and unrealizedPnlAfter (unrealizedPnl times the ratio of open position)\n        * notionalPosition = notionalPosition - quoteAsset (exchangedQuoteAssetAmount)\n        * calculate openNotional (it's different depends on long or short side)\n        * long: unrealizedPnl = notionalPosition - openNotional => openNotional = notionalPosition - unrealizedPnl\n        * short: unrealizedPnl = openNotional - notionalPosition => openNotional = notionalPosition + unrealizedPnl\n        */\n        if (isLongPosition) {\n            /**\n            * Let baseAssetQuantity = Q, position.size = size, by definition of _reducePosition, abs(size) >= abs(Q)\n            * quoteAsset = notionalPosition * Q / size\n            * unrealizedPnlAfter = unrealizedPnl - realizedPnl = unrealizedPnl - unrealizedPnl * Q / size\n            * remainOpenNotional = notionalPosition - notionalPosition * Q / size - unrealizedPnl + unrealizedPnl * Q / size\n            * => remainOpenNotional = notionalPosition(size-Q)/size - unrealizedPnl(size-Q)/size\n            * => remainOpenNotional = (notionalPosition - unrealizedPnl) * (size-Q)/size\n            * Since notionalPosition includes the PnL component, notionalPosition >= unrealizedPnl and size >= Q\n            * Hence remainOpenNotional >= 0\n            */\n            remainOpenNotional = (newNotionalPosition.toInt256() - unrealizedPnlAfter).toUint256();  // will assert that remainOpenNotional >= 0\n        } else {\n            /**\n            * Let baseAssetQuantity = Q, position.size = size, by definition of _reducePosition, abs(size) >= abs(Q)\n            * quoteAsset = notionalPosition * Q / size\n            * unrealizedPnlAfter = unrealizedPnl - realizedPnl = unrealizedPnl - unrealizedPnl * Q / size\n            * remainOpenNotional = notionalPosition - notionalPosition * Q / size + unrealizedPnl - unrealizedPnl * Q / size\n            * => remainOpenNotional = notionalPosition(size-Q)/size + unrealizedPnl(size-Q)/size\n            * => remainOpenNotional = (notionalPosition + unrealizedPnl) * (size-Q)/size\n            * => In AMM.sol, unrealizedPnl = position.openNotional - notionalPosition\n            * => notionalPosition + unrealizedPnl >= 0\n            * Hence remainOpenNotional >= 0\n            */\n            remainOpenNotional = (newNotionalPosition.toInt256() + unrealizedPnlAfter).toUint256();  // will assert that remainOpenNotional >= 0\n        }\n    }\n\n    /**\n     * @notice update funding rate\n     * @dev only allow to update while reaching `nextFundingTime`\n     */\n    function settleFunding()\n        override\n        external\n        onlyClearingHouse\n    {\n        if (ammState != AMMState.Active) return;\n        require(_blockTimestamp() >= nextFundingTime, \"settle funding too early\");\n\n        // premium = twapMarketPrice - twapIndexPrice\n        // timeFraction = fundingPeriod(1 hour) / 1 day\n        // premiumFraction = premium * timeFraction\n        int256 underlyingPrice = getUnderlyingTwapPrice(spotPriceTwapInterval);\n        int256 premium = getTwapPrice(spotPriceTwapInterval) - underlyingPrice;\n        int256 premiumFraction = (premium * int256(fundingPeriod)) / 1 days;\n\n        // update funding rate = premiumFraction / twapIndexPrice\n        _updateFundingRate(premiumFraction, underlyingPrice);\n\n        int256 premiumPerDtoken = posAccumulator * premiumFraction;\n\n        // makers pay slightly more to account for rounding off\n        premiumPerDtoken = (premiumPerDtoken / BASE_PRECISION) + 1;\n\n        cumulativePremiumFraction += premiumFraction;\n        cumulativePremiumPerDtoken += premiumPerDtoken;\n\n        // Updates for next funding event\n        // in order to prevent multiple funding settlement during very short time after network congestion\n        uint256 minNextValidFundingTime = _blockTimestamp() + fundingBufferPeriod;\n\n        // floor((nextFundingTime + fundingPeriod) / 3600) * 3600\n        uint256 nextFundingTimeOnHourStart = ((nextFundingTime + fundingPeriod) / 1 hours) * 1 hours;\n\n        // max(nextFundingTimeOnHourStart, minNextValidFundingTime)\n        nextFundingTime = nextFundingTimeOnHourStart > minNextValidFundingTime\n            ? nextFundingTimeOnHourStart\n            : minNextValidFundingTime;\n    }\n\n    // View\n\n    function getSnapshotLen() external view returns (uint256) {\n        return reserveSnapshots.length;\n    }\n\n    function getUnderlyingTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {\n        return oracle.getUnderlyingTwapPrice(underlyingAsset, _intervalInSeconds);\n    }\n\n    function getTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {\n        return int256(_calcTwap(_intervalInSeconds));\n    }\n\n    function getNotionalPositionAndUnrealizedPnl(address trader)\n        override\n        external\n        view\n        returns(uint256 notionalPosition, int256 unrealizedPnl, int256 size, uint256 openNotional)\n    {\n        Position memory _taker = positions[trader];\n        Maker memory _maker = makers[trader];\n\n        (notionalPosition, size, unrealizedPnl, openNotional) = vamm.get_notional(\n            _maker.dToken,\n            _maker.vUSD,\n            _maker.vAsset,\n            _taker.size,\n            _taker.openNotional\n        );\n    }\n\n    function getPendingFundingPayment(address trader)\n        override\n        public\n        view\n        returns(\n            int256 takerFundingPayment,\n            int256 makerFundingPayment,\n            int256 latestCumulativePremiumFraction,\n            int256 latestPremiumPerDtoken\n        )\n    {\n        latestCumulativePremiumFraction = cumulativePremiumFraction;\n        Position memory taker = positions[trader];\n\n        takerFundingPayment = (latestCumulativePremiumFraction - taker.lastPremiumFraction)\n            * taker.size\n            / BASE_PRECISION;\n\n        // Maker funding payment\n        latestPremiumPerDtoken = cumulativePremiumPerDtoken;\n\n        Maker memory maker = makers[trader];\n        int256 dToken = maker.dToken.toInt256();\n        if (dToken > 0) {\n            int256 cpf = latestCumulativePremiumFraction - maker.lastPremiumFraction;\n            makerFundingPayment = (\n                maker.pos * cpf +\n                (\n                    latestPremiumPerDtoken\n                    - maker.lastPremiumPerDtoken\n                    - maker.posAccumulator * cpf / BASE_PRECISION\n                ) * dToken\n            ) / BASE_PRECISION;\n        }\n    }\n\n    function getCloseQuote(int256 baseAssetQuantity) override public view returns(uint256 quoteAssetQuantity) {\n        if (baseAssetQuantity > 0) {\n            return vamm.get_dy(1, 0, baseAssetQuantity.toUint256());\n        } else if (baseAssetQuantity < 0) {\n            return vamm.get_dx(0, 1, (-baseAssetQuantity).toUint256());\n        }\n        return 0;\n    }\n\n    function getTakerNotionalPositionAndUnrealizedPnl(address trader) override public view returns(uint takerNotionalPosition, int256 unrealizedPnl) {\n        Position memory position = positions[trader];\n        if (position.size > 0) {\n            takerNotionalPosition = vamm.get_dy(1, 0, position.size.toUint256());\n            unrealizedPnl = takerNotionalPosition.toInt256() - position.openNotional.toInt256();\n        } else if (position.size < 0) {\n            takerNotionalPosition = vamm.get_dx(0, 1, (-position.size).toUint256());\n            unrealizedPnl = position.openNotional.toInt256() - takerNotionalPosition.toInt256();\n        }\n    }\n\n    function lastPrice() external view returns(uint256) {\n        return vamm.last_prices() / 1e12;\n    }\n\n    function openInterestNotional() public view returns (uint256) {\n        return longOpenInterestNotional + shortOpenInterestNotional;\n    }\n\n    // internal\n\n    /**\n    * @dev Go long on an asset\n    * @param baseAssetQuantity Exact base asset quantity to go long\n    * @param max_dx Maximum amount of quote asset to be used while longing baseAssetQuantity. Lower means longing at a lower price (desirable).\n    * @return quoteAssetQuantity quote asset utilised. quoteAssetQuantity / baseAssetQuantity was the average rate.\n      quoteAssetQuantity <= max_dx\n    */\n    function _long(int256 baseAssetQuantity, uint max_dx) internal returns (uint256 quoteAssetQuantity) {\n        require(baseAssetQuantity > 0, \"VAMM._long: baseAssetQuantity is <= 0\");\n\n        uint _lastPrice;\n        (quoteAssetQuantity, _lastPrice) = vamm.exchangeExactOut(\n            0, // sell quote asset\n            1, // purchase base asset\n            baseAssetQuantity.toUint256(), // long exactly. Note that statement asserts that baseAssetQuantity >= 0\n            max_dx\n        ); // 6 decimals precision\n\n        _addReserveSnapshot(_lastPrice);\n        // since maker position will be opposite of the trade\n        posAccumulator -= baseAssetQuantity * 1e18 / vamm.totalSupply().toInt256();\n        emit Swap(baseAssetQuantity, quoteAssetQuantity, _lastPrice, openInterestNotional());\n    }\n\n    /**\n    * @dev Go short on an asset\n    * @param baseAssetQuantity Exact base asset quantity to short\n    * @param min_dy Minimum amount of quote asset to be used while shorting baseAssetQuantity. Higher means shorting at a higher price (desirable).\n    * @return quoteAssetQuantity quote asset utilised. quoteAssetQuantity / baseAssetQuantity was the average short rate.\n      quoteAssetQuantity >= min_dy.\n    */\n    function _short(int256 baseAssetQuantity, uint min_dy) internal returns (uint256 quoteAssetQuantity) {\n        require(baseAssetQuantity < 0, \"VAMM._short: baseAssetQuantity is >= 0\");\n\n        uint _lastPrice;\n        (quoteAssetQuantity, _lastPrice) = vamm.exchange(\n            1, // sell base asset\n            0, // get quote asset\n            (-baseAssetQuantity).toUint256(), // short exactly. Note that statement asserts that baseAssetQuantity <= 0\n            min_dy\n        );\n\n        _addReserveSnapshot(_lastPrice);\n        // since maker position will be opposite of the trade\n        posAccumulator -= baseAssetQuantity * 1e18 / vamm.totalSupply().toInt256();\n        emit Swap(baseAssetQuantity, quoteAssetQuantity, _lastPrice, openInterestNotional());\n    }\n\n    function _emitPositionChanged(address trader, int256 realizedPnl) internal {\n        Position memory position = positions[trader];\n        emit PositionChanged(trader, position.size, position.openNotional, realizedPnl);\n    }\n\n    // @dev check takerPosition != 0 before calling\n    function _getPnlWhileReducingPosition(\n        int256 takerPosition,\n        uint takerOpenNotional,\n        int256 makerPosition,\n        uint newNotional\n    ) internal pure returns (int256 pnlToBeRealized) {\n        /**\n            makerNotional = newNotional * makerPos / totalPos\n            if (side remains same)\n                reducedOpenNotional = takerOpenNotional * makerPos / takerPos\n                pnl = makerNotional - reducedOpenNotional\n            else (reverse position)\n                closedPositionNotional = newNotional * takerPos / totalPos\n                pnl = closePositionNotional - takerOpenNotional\n         */\n\n        uint totalPosition = abs(makerPosition + takerPosition).toUint256();\n        if (abs(takerPosition) > abs(makerPosition)) { // taker position side remains same\n            uint reducedOpenNotional = takerOpenNotional * abs(makerPosition).toUint256() / abs(takerPosition).toUint256();\n            uint makerNotional = newNotional * abs(makerPosition).toUint256() / totalPosition;\n            pnlToBeRealized = _getPnlToBeRealized(takerPosition, makerNotional, reducedOpenNotional);\n        } else { // taker position side changes\n            // @todo handle case when totalPosition = 0\n            uint closedPositionNotional = newNotional * abs(takerPosition).toUint256() / totalPosition;\n            pnlToBeRealized = _getPnlToBeRealized(takerPosition, closedPositionNotional, takerOpenNotional);\n        }\n    }\n\n    function _getPnlToBeRealized(int256 takerPosition, uint notionalPosition, uint openNotional) internal pure returns (int256 pnlToBeRealized) {\n        if (takerPosition > 0) {\n            pnlToBeRealized = notionalPosition.toInt256() - openNotional.toInt256();\n        } else {\n            pnlToBeRealized = openNotional.toInt256() - notionalPosition.toInt256();\n        }\n    }\n\n    function _increasePosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        internal\n        returns(uint quoteAsset)\n    {\n        if (baseAssetQuantity > 0) { // Long - purchase baseAssetQuantity\n            longOpenInterestNotional += baseAssetQuantity.toUint256();\n            quoteAsset = _long(baseAssetQuantity, quoteAssetLimit);\n        } else { // Short - sell baseAssetQuantity\n            shortOpenInterestNotional += (-baseAssetQuantity).toUint256();\n            quoteAsset = _short(baseAssetQuantity, quoteAssetLimit);\n        }\n        positions[trader].size += baseAssetQuantity; // -ve baseAssetQuantity will increase short position\n        positions[trader].openNotional += quoteAsset;\n    }\n\n    function _openReversePosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        internal\n        returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased)\n    {\n        Position memory position = positions[trader];\n        if (abs(position.size) >= abs(baseAssetQuantity)) {\n            (realizedPnl, quoteAsset) = _reducePosition(trader, baseAssetQuantity, quoteAssetLimit);\n        } else {\n            uint closedRatio = (quoteAssetLimit * abs(position.size).toUint256()) / abs(baseAssetQuantity).toUint256();\n            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, closedRatio);\n\n            // this is required because the user might pass a very less value (slippage-prone) while shorting\n            if (quoteAssetLimit >= quoteAsset) {\n                quoteAssetLimit -= quoteAsset;\n            }\n            quoteAsset += _increasePosition(trader, baseAssetQuantity + position.size, quoteAssetLimit);\n            isPositionIncreased = true;\n        }\n    }\n\n    /**\n    * @dev validate that baseAssetQuantity <= position.size should be performed before the call to _reducePosition\n    */\n    function _reducePosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        internal\n        returns (int realizedPnl, uint256 quoteAsset)\n    {\n        (, int256 unrealizedPnl) = getTakerNotionalPositionAndUnrealizedPnl(trader);\n\n        Position storage position = positions[trader]; // storage because there are updates at the end\n        bool isLongPosition = position.size > 0 ? true : false;\n\n        if (isLongPosition) {\n            longOpenInterestNotional -= (-baseAssetQuantity).toUint256();\n            quoteAsset = _short(baseAssetQuantity, quoteAssetLimit);\n        } else {\n            shortOpenInterestNotional -= baseAssetQuantity.toUint256();\n            quoteAsset = _long(baseAssetQuantity, quoteAssetLimit);\n        }\n        uint256 notionalPosition = getCloseQuote(position.size + baseAssetQuantity);\n        (position.openNotional, realizedPnl) = getOpenNotionalWhileReducingPosition(position.size, notionalPosition, unrealizedPnl, baseAssetQuantity);\n        position.size += baseAssetQuantity;\n    }\n\n    function _addReserveSnapshot(uint256 price)\n        internal\n    {\n        uint256 currentBlock = block.number;\n        uint256 blockTimestamp = _blockTimestamp();\n\n        if (reserveSnapshots.length == 0) {\n            reserveSnapshots.push(\n                ReserveSnapshot(price, blockTimestamp, currentBlock)\n            );\n            return;\n        }\n\n        ReserveSnapshot storage latestSnapshot = reserveSnapshots[reserveSnapshots.length - 1];\n        // update values in snapshot if in the same block\n        if (currentBlock == latestSnapshot.blockNumber) {\n            latestSnapshot.lastPrice = price;\n        } else {\n            reserveSnapshots.push(\n                ReserveSnapshot(price, blockTimestamp, currentBlock)\n            );\n        }\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    function _calcTwap(uint256 _intervalInSeconds)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshotIndex = reserveSnapshots.length - 1;\n        uint256 currentPrice = reserveSnapshots[snapshotIndex].lastPrice;\n        if (_intervalInSeconds == 0) {\n            return currentPrice;\n        }\n\n        uint256 baseTimestamp = _blockTimestamp() - _intervalInSeconds;\n        ReserveSnapshot memory currentSnapshot = reserveSnapshots[snapshotIndex];\n        // return the latest snapshot price directly\n        // if only one snapshot or the timestamp of latest snapshot is earlier than asking for\n        if (reserveSnapshots.length == 1 || currentSnapshot.timestamp <= baseTimestamp) {\n            return currentPrice;\n        }\n\n        uint256 previousTimestamp = currentSnapshot.timestamp;\n        uint256 period = _blockTimestamp() - previousTimestamp;\n        uint256 weightedPrice = currentPrice * period;\n        while (true) {\n            // if snapshot history is too short\n            if (snapshotIndex == 0) {\n                return weightedPrice / period;\n            }\n\n            snapshotIndex = snapshotIndex - 1;\n            currentSnapshot = reserveSnapshots[snapshotIndex];\n            currentPrice = reserveSnapshots[snapshotIndex].lastPrice;\n\n            // check if current round timestamp is earlier than target timestamp\n            if (currentSnapshot.timestamp <= baseTimestamp) {\n                // weighted time period will be (target timestamp - previous timestamp). For example,\n                // now is 1000, _interval is 100, then target timestamp is 900. If timestamp of current round is 970,\n                // and timestamp of NEXT round is 880, then the weighted time period will be (970 - 900) = 70,\n                // instead of (970 - 880)\n                weightedPrice = weightedPrice + (currentPrice * (previousTimestamp - baseTimestamp));\n                break;\n            }\n\n            uint256 timeFraction = previousTimestamp - currentSnapshot.timestamp;\n            weightedPrice = weightedPrice + (currentPrice * timeFraction);\n            period = period + timeFraction;\n            previousTimestamp = currentSnapshot.timestamp;\n        }\n        return weightedPrice / _intervalInSeconds;\n    }\n\n    function _updateFundingRate(\n        int256 _premiumFraction,\n        int256 _underlyingPrice\n    ) internal {\n        fundingRate = _premiumFraction * 1e6 / _underlyingPrice;\n        emit FundingRateUpdated(_premiumFraction, fundingRate, _underlyingPrice.toUint256(), _blockTimestamp(), block.number);\n    }\n\n    // Pure\n\n    function abs(int x) private pure returns (int) {\n        return x >= 0 ? x : -x;\n    }\n\n    // Governance\n\n    function setAmmState(AMMState _state) external onlyGovernance {\n        require(ammState != _state, \"AMM.setAmmState.sameState\");\n        ammState = _state;\n        if (_state == AMMState.Active) {\n            nextFundingTime = ((_blockTimestamp() + fundingPeriod) / 1 hours) * 1 hours;\n        }\n    }\n\n    function syncDeps(address _registry) public onlyGovernance {\n        IRegistry registry = IRegistry(_registry);\n        clearingHouse = registry.clearingHouse();\n        oracle = IOracle(registry.oracle());\n    }\n\n    function setFundingBufferPeriod(uint _fundingBufferPeriod) external onlyGovernance {\n        fundingBufferPeriod = _fundingBufferPeriod;\n    }\n}\n\n\n",
        "CodeNames": [
            "ClearingHouse.sol",
            "AMM.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "settleFunding function in ClearingHouse.sol and AMM.sol",
                "Type": "Gas Limit Exceeded",
                "Description": "settleFunding will exceed block gas with more markets and activity.",
                "Repair": "Allow users to settle funding per market or using an array of markets opposed to all markets at once"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { Governable } from \"./legos/Governable.sol\";\nimport { ERC20Detailed, IOracle, IRegistry, IVAMM, IAMM } from \"./Interfaces.sol\";\n\ncontract AMM is IAMM, Governable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    uint256 public constant spotPriceTwapInterval = 1 hours;\n    uint256 public constant fundingPeriod = 1 hours;\n    int256 constant BASE_PRECISION = 1e18;\n\n    // System-wide config\n\n    IOracle public oracle;\n    address public clearingHouse;\n\n    // AMM config\n\n    IVAMM override public vamm;\n    address override public underlyingAsset;\n    string public name;\n\n    uint256 public fundingBufferPeriod;\n    uint256 public nextFundingTime;\n    int256 public fundingRate;\n    int256 public cumulativePremiumFraction;\n    int256 public cumulativePremiumPerDtoken;\n    int256 public posAccumulator;\n\n    uint256 public longOpenInterestNotional;\n    uint256 public shortOpenInterestNotional;\n\n    enum Side { LONG, SHORT }\n    struct Position {\n        int256 size;\n        uint256 openNotional;\n        int256 lastPremiumFraction;\n    }\n    mapping(address => Position) override public positions;\n\n    struct Maker {\n        uint vUSD;\n        uint vAsset;\n        uint dToken;\n        int pos; // position\n        int posAccumulator; // value of global.posAccumulator until which pos has been updated\n        int lastPremiumFraction;\n        int lastPremiumPerDtoken;\n    }\n    mapping(address => Maker) override public makers;\n\n    struct ReserveSnapshot {\n        uint256 lastPrice;\n        uint256 timestamp;\n        uint256 blockNumber;\n    }\n    ReserveSnapshot[] public reserveSnapshots;\n\n    /**\n    * @dev We do not deliberately have a Pause state. There is only a master-level pause at clearingHouse level\n    */\n    enum AMMState { Inactive, Ignition, Active }\n    AMMState public ammState;\n\n    uint256[50] private __gap;\n\n    // Events\n\n    event PositionChanged(address indexed trader, int256 size, uint256 openNotional, int256 realizedPnl);\n    event FundingRateUpdated(int256 premiumFraction, int256 rate, uint256 underlyingPrice, uint256 timestamp, uint256 blockNumber);\n    event FundingPaid(address indexed trader, int256 takerPosSize, int256 takerFundingPayment, int256 makerFundingPayment, int256 latestCumulativePremiumFraction, int256 latestPremiumPerDtoken);\n    event Swap(int256 baseAsset, uint256 quoteAsset, uint256 lastPrice, uint256 openInterestNotional);\n    event LiquidityAdded(address indexed maker, uint dToken, uint baseAsset, uint quoteAsset, uint timestamp);\n    event LiquidityRemoved(address indexed maker, uint dToken, uint baseAsset, uint quoteAsset, uint timestamp, int256 realizedPnl);\n\n    modifier onlyClearingHouse() {\n        require(msg.sender == clearingHouse, \"Only clearingHouse\");\n        _;\n    }\n\n    modifier onlyVamm() {\n        require(msg.sender == address(vamm), \"Only VAMM\");\n        _;\n    }\n\n    function initialize(\n        address _registry,\n        address _underlyingAsset,\n        string memory _name,\n        address _vamm,\n        address _governance\n    ) external initializer {\n        _setGovernace(_governance);\n\n        vamm = IVAMM(_vamm);\n        underlyingAsset = _underlyingAsset;\n        name = _name;\n        fundingBufferPeriod = 15 minutes;\n\n        syncDeps(_registry);\n    }\n\n    /**\n    * @dev baseAssetQuantity != 0 has been validated in clearingHouse._openPosition()\n    */\n    function openPosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        override\n        external\n        onlyClearingHouse\n        returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased)\n    {\n        require(ammState == AMMState.Active, \"AMM.openPosition.not_active\");\n        Position memory position = positions[trader];\n        bool isNewPosition = position.size == 0 ? true : false;\n        Side side = baseAssetQuantity > 0 ? Side.LONG : Side.SHORT;\n        if (isNewPosition || (position.size > 0 ? Side.LONG : Side.SHORT) == side) {\n            // realizedPnl = 0;\n            quoteAsset = _increasePosition(trader, baseAssetQuantity, quoteAssetLimit);\n            isPositionIncreased = true;\n        } else {\n            (realizedPnl, quoteAsset, isPositionIncreased) = _openReversePosition(trader, baseAssetQuantity, quoteAssetLimit);\n        }\n        _emitPositionChanged(trader, realizedPnl);\n    }\n\n    function liquidatePosition(address trader)\n        override\n        external\n        onlyClearingHouse\n        returns (int realizedPnl, uint quoteAsset)\n    {\n        // don't need an ammState check because there should be no active positions\n        Position memory position = positions[trader];\n        bool isLongPosition = position.size > 0 ? true : false;\n        // sending market orders can fk the trader. @todo put some safe guards around price of liquidations\n        if (isLongPosition) {\n            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, 0);\n        } else {\n            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, type(uint).max);\n        }\n        _emitPositionChanged(trader, realizedPnl);\n    }\n\n    function updatePosition(address trader)\n        override\n        external\n        onlyClearingHouse\n        returns(int256 fundingPayment)\n    {\n        if (ammState != AMMState.Active) return 0;\n        (\n            int256 takerFundingPayment,\n            int256 makerFundingPayment,\n            int256 latestCumulativePremiumFraction,\n            int256 latestPremiumPerDtoken\n        ) = getPendingFundingPayment(trader);\n\n        Position storage position = positions[trader];\n        position.lastPremiumFraction = latestCumulativePremiumFraction;\n\n        Maker storage maker = makers[trader];\n        maker.lastPremiumFraction = latestCumulativePremiumFraction;\n        maker.lastPremiumPerDtoken = latestPremiumPerDtoken;\n\n        emit FundingPaid(trader, position.size, takerFundingPayment, makerFundingPayment, latestCumulativePremiumFraction, latestPremiumPerDtoken);\n\n        // +: trader paid, -: trader received\n        fundingPayment = takerFundingPayment + makerFundingPayment;\n        if (fundingPayment < 0) {\n            fundingPayment -= fundingPayment / 1e3; // receivers charged 0.1% to account for rounding-offs\n        }\n    }\n\n    function addLiquidity(address maker, uint baseAssetQuantity, uint minDToken)\n        override\n        external\n        onlyClearingHouse\n    {\n        require(ammState != AMMState.Inactive, \"AMM.addLiquidity.amm_inactive\");\n        uint quoteAsset;\n        uint baseAssetBal = vamm.balances(1);\n        if (baseAssetBal == 0) {\n            quoteAsset = baseAssetQuantity * vamm.price_scale() / 1e30;\n        } else {\n            quoteAsset = baseAssetQuantity * vamm.balances(0) / baseAssetBal;\n        }\n\n        uint _dToken = vamm.add_liquidity([quoteAsset, baseAssetQuantity], minDToken);\n\n        // updates\n        Maker storage _maker = makers[maker];\n        if (_maker.dToken > 0) { // Maker only accumulates position when they had non-zero liquidity\n            _maker.pos += (posAccumulator - _maker.posAccumulator) * _maker.dToken.toInt256() / 1e18;\n        }\n        _maker.vUSD += quoteAsset;\n        _maker.vAsset += baseAssetQuantity;\n        _maker.dToken += _dToken;\n        _maker.posAccumulator = posAccumulator;\n        emit LiquidityAdded(maker, _dToken, baseAssetQuantity, quoteAsset, _blockTimestamp());\n    }\n\n    function removeLiquidity(address maker, uint amount, uint minQuote, uint minBase)\n        override\n        external\n        onlyClearingHouse\n        returns (int256 /* realizedPnl */, uint /* quoteAsset */)\n    {\n        Maker memory _maker = makers[maker];\n        if (_maker.dToken == 0) {\n            return (0,0);\n        }\n\n        Position memory _taker = positions[maker];\n        // amount <= _maker.dToken will be asserted when updating maker.dToken\n        (\n            int256 makerPosition,\n            uint256 totalOpenNotional,\n            int256 feeAdjustedPnl,\n            uint[2] memory dBalances\n        ) = vamm.remove_liquidity(\n            amount,\n            [minQuote /* minimum QuoteAsset amount */, minBase /* minimum BaseAsset amount */],\n            _maker.vUSD,\n            _maker.vAsset,\n            _maker.dToken,\n            _taker.size,\n            _taker.openNotional\n        );\n\n        {\n            // update maker info\n            Maker storage __maker = makers[maker];\n            uint diff = _maker.dToken - amount;\n\n            if (diff == 0) {\n                __maker.pos = 0;\n                __maker.vAsset = 0;\n                __maker.vUSD = 0;\n                __maker.dToken = 0;\n            } else {\n                // muitiply by diff because a taker position will also be opened while removing liquidity and its funding payment is calculated seperately\n                __maker.pos = _maker.pos + (posAccumulator - _maker.posAccumulator) * diff.toInt256() / 1e18;\n                __maker.vAsset = _maker.vAsset * diff / _maker.dToken;\n                __maker.vUSD = _maker.vUSD * diff / _maker.dToken;\n                __maker.dToken = diff;\n            }\n            __maker.posAccumulator = posAccumulator;\n        }\n\n        int256 realizedPnl = feeAdjustedPnl;\n        {\n            if (makerPosition != 0) {\n                // translate impermanent position to a permanent one\n                Position storage position = positions[maker];\n                if (makerPosition * position.size < 0) { // reducing or reversing position\n                    uint newNotional = getCloseQuote(position.size + makerPosition);\n                    int256 reducePositionPnl = _getPnlWhileReducingPosition(position.size, position.openNotional, makerPosition, newNotional);\n                    realizedPnl += reducePositionPnl;\n                }\n                position.openNotional = totalOpenNotional;\n                position.size += makerPosition;\n\n                // update long and short open interest notional\n                if (makerPosition > 0) {\n                    longOpenInterestNotional += makerPosition.toUint256();\n                } else {\n                    shortOpenInterestNotional += (-makerPosition).toUint256();\n                }\n            }\n        }\n\n        emit LiquidityRemoved(maker, amount, dBalances[1] /** baseAsset */,\n            dBalances[0] /** quoteAsset */, _blockTimestamp(), realizedPnl);\n        return (realizedPnl, dBalances[0]);\n    }\n\n\n    function getOpenNotionalWhileReducingPosition(\n        int256 positionSize,\n        uint256 newNotionalPosition,\n        int256 unrealizedPnl,\n        int256 baseAssetQuantity\n    )\n        override\n        public\n        pure\n        returns(uint256 remainOpenNotional, int realizedPnl)\n    {\n        require(abs(positionSize) >= abs(baseAssetQuantity), \"AMM.ONLY_REDUCE_POS\");\n        bool isLongPosition = positionSize > 0 ? true : false;\n\n        realizedPnl = unrealizedPnl * abs(baseAssetQuantity) / abs(positionSize);\n        int256 unrealizedPnlAfter = unrealizedPnl - realizedPnl;\n\n        /**\n        * We need to determine the openNotional value of the reduced position now.\n        * We know notionalPosition and unrealizedPnlAfter (unrealizedPnl times the ratio of open position)\n        * notionalPosition = notionalPosition - quoteAsset (exchangedQuoteAssetAmount)\n        * calculate openNotional (it's different depends on long or short side)\n        * long: unrealizedPnl = notionalPosition - openNotional => openNotional = notionalPosition - unrealizedPnl\n        * short: unrealizedPnl = openNotional - notionalPosition => openNotional = notionalPosition + unrealizedPnl\n        */\n        if (isLongPosition) {\n            /**\n            * Let baseAssetQuantity = Q, position.size = size, by definition of _reducePosition, abs(size) >= abs(Q)\n            * quoteAsset = notionalPosition * Q / size\n            * unrealizedPnlAfter = unrealizedPnl - realizedPnl = unrealizedPnl - unrealizedPnl * Q / size\n            * remainOpenNotional = notionalPosition - notionalPosition * Q / size - unrealizedPnl + unrealizedPnl * Q / size\n            * => remainOpenNotional = notionalPosition(size-Q)/size - unrealizedPnl(size-Q)/size\n            * => remainOpenNotional = (notionalPosition - unrealizedPnl) * (size-Q)/size\n            * Since notionalPosition includes the PnL component, notionalPosition >= unrealizedPnl and size >= Q\n            * Hence remainOpenNotional >= 0\n            */\n            remainOpenNotional = (newNotionalPosition.toInt256() - unrealizedPnlAfter).toUint256();  // will assert that remainOpenNotional >= 0\n        } else {\n            /**\n            * Let baseAssetQuantity = Q, position.size = size, by definition of _reducePosition, abs(size) >= abs(Q)\n            * quoteAsset = notionalPosition * Q / size\n            * unrealizedPnlAfter = unrealizedPnl - realizedPnl = unrealizedPnl - unrealizedPnl * Q / size\n            * remainOpenNotional = notionalPosition - notionalPosition * Q / size + unrealizedPnl - unrealizedPnl * Q / size\n            * => remainOpenNotional = notionalPosition(size-Q)/size + unrealizedPnl(size-Q)/size\n            * => remainOpenNotional = (notionalPosition + unrealizedPnl) * (size-Q)/size\n            * => In AMM.sol, unrealizedPnl = position.openNotional - notionalPosition\n            * => notionalPosition + unrealizedPnl >= 0\n            * Hence remainOpenNotional >= 0\n            */\n            remainOpenNotional = (newNotionalPosition.toInt256() + unrealizedPnlAfter).toUint256();  // will assert that remainOpenNotional >= 0\n        }\n    }\n\n    /**\n     * @notice update funding rate\n     * @dev only allow to update while reaching `nextFundingTime`\n     */\n    function settleFunding()\n        override\n        external\n        onlyClearingHouse\n    {\n        if (ammState != AMMState.Active) return;\n        require(_blockTimestamp() >= nextFundingTime, \"settle funding too early\");\n\n        // premium = twapMarketPrice - twapIndexPrice\n        // timeFraction = fundingPeriod(1 hour) / 1 day\n        // premiumFraction = premium * timeFraction\n        int256 underlyingPrice = getUnderlyingTwapPrice(spotPriceTwapInterval);\n        int256 premium = getTwapPrice(spotPriceTwapInterval) - underlyingPrice;\n        int256 premiumFraction = (premium * int256(fundingPeriod)) / 1 days;\n\n        // update funding rate = premiumFraction / twapIndexPrice\n        _updateFundingRate(premiumFraction, underlyingPrice);\n\n        int256 premiumPerDtoken = posAccumulator * premiumFraction;\n\n        // makers pay slightly more to account for rounding off\n        premiumPerDtoken = (premiumPerDtoken / BASE_PRECISION) + 1;\n\n        cumulativePremiumFraction += premiumFraction;\n        cumulativePremiumPerDtoken += premiumPerDtoken;\n\n        // Updates for next funding event\n        // in order to prevent multiple funding settlement during very short time after network congestion\n        uint256 minNextValidFundingTime = _blockTimestamp() + fundingBufferPeriod;\n\n        // floor((nextFundingTime + fundingPeriod) / 3600) * 3600\n        uint256 nextFundingTimeOnHourStart = ((nextFundingTime + fundingPeriod) / 1 hours) * 1 hours;\n\n        // max(nextFundingTimeOnHourStart, minNextValidFundingTime)\n        nextFundingTime = nextFundingTimeOnHourStart > minNextValidFundingTime\n            ? nextFundingTimeOnHourStart\n            : minNextValidFundingTime;\n    }\n\n    // View\n\n    function getSnapshotLen() external view returns (uint256) {\n        return reserveSnapshots.length;\n    }\n\n    function getUnderlyingTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {\n        return oracle.getUnderlyingTwapPrice(underlyingAsset, _intervalInSeconds);\n    }\n\n    function getTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {\n        return int256(_calcTwap(_intervalInSeconds));\n    }\n\n    function getNotionalPositionAndUnrealizedPnl(address trader)\n        override\n        external\n        view\n        returns(uint256 notionalPosition, int256 unrealizedPnl, int256 size, uint256 openNotional)\n    {\n        Position memory _taker = positions[trader];\n        Maker memory _maker = makers[trader];\n\n        (notionalPosition, size, unrealizedPnl, openNotional) = vamm.get_notional(\n            _maker.dToken,\n            _maker.vUSD,\n            _maker.vAsset,\n            _taker.size,\n            _taker.openNotional\n        );\n    }\n\n    function getPendingFundingPayment(address trader)\n        override\n        public\n        view\n        returns(\n            int256 takerFundingPayment,\n            int256 makerFundingPayment,\n            int256 latestCumulativePremiumFraction,\n            int256 latestPremiumPerDtoken\n        )\n    {\n        latestCumulativePremiumFraction = cumulativePremiumFraction;\n        Position memory taker = positions[trader];\n\n        takerFundingPayment = (latestCumulativePremiumFraction - taker.lastPremiumFraction)\n            * taker.size\n            / BASE_PRECISION;\n\n        // Maker funding payment\n        latestPremiumPerDtoken = cumulativePremiumPerDtoken;\n\n        Maker memory maker = makers[trader];\n        int256 dToken = maker.dToken.toInt256();\n        if (dToken > 0) {\n            int256 cpf = latestCumulativePremiumFraction - maker.lastPremiumFraction;\n            makerFundingPayment = (\n                maker.pos * cpf +\n                (\n                    latestPremiumPerDtoken\n                    - maker.lastPremiumPerDtoken\n                    - maker.posAccumulator * cpf / BASE_PRECISION\n                ) * dToken\n            ) / BASE_PRECISION;\n        }\n    }\n\n    function getCloseQuote(int256 baseAssetQuantity) override public view returns(uint256 quoteAssetQuantity) {\n        if (baseAssetQuantity > 0) {\n            return vamm.get_dy(1, 0, baseAssetQuantity.toUint256());\n        } else if (baseAssetQuantity < 0) {\n            return vamm.get_dx(0, 1, (-baseAssetQuantity).toUint256());\n        }\n        return 0;\n    }\n\n    function getTakerNotionalPositionAndUnrealizedPnl(address trader) override public view returns(uint takerNotionalPosition, int256 unrealizedPnl) {\n        Position memory position = positions[trader];\n        if (position.size > 0) {\n            takerNotionalPosition = vamm.get_dy(1, 0, position.size.toUint256());\n            unrealizedPnl = takerNotionalPosition.toInt256() - position.openNotional.toInt256();\n        } else if (position.size < 0) {\n            takerNotionalPosition = vamm.get_dx(0, 1, (-position.size).toUint256());\n            unrealizedPnl = position.openNotional.toInt256() - takerNotionalPosition.toInt256();\n        }\n    }\n\n    function lastPrice() external view returns(uint256) {\n        return vamm.last_prices() / 1e12;\n    }\n\n    function openInterestNotional() public view returns (uint256) {\n        return longOpenInterestNotional + shortOpenInterestNotional;\n    }\n\n    // internal\n\n    /**\n    * @dev Go long on an asset\n    * @param baseAssetQuantity Exact base asset quantity to go long\n    * @param max_dx Maximum amount of quote asset to be used while longing baseAssetQuantity. Lower means longing at a lower price (desirable).\n    * @return quoteAssetQuantity quote asset utilised. quoteAssetQuantity / baseAssetQuantity was the average rate.\n      quoteAssetQuantity <= max_dx\n    */\n    function _long(int256 baseAssetQuantity, uint max_dx) internal returns (uint256 quoteAssetQuantity) {\n        require(baseAssetQuantity > 0, \"VAMM._long: baseAssetQuantity is <= 0\");\n\n        uint _lastPrice;\n        (quoteAssetQuantity, _lastPrice) = vamm.exchangeExactOut(\n            0, // sell quote asset\n            1, // purchase base asset\n            baseAssetQuantity.toUint256(), // long exactly. Note that statement asserts that baseAssetQuantity >= 0\n            max_dx\n        ); // 6 decimals precision\n\n        _addReserveSnapshot(_lastPrice);\n        // since maker position will be opposite of the trade\n        posAccumulator -= baseAssetQuantity * 1e18 / vamm.totalSupply().toInt256();\n        emit Swap(baseAssetQuantity, quoteAssetQuantity, _lastPrice, openInterestNotional());\n    }\n\n    /**\n    * @dev Go short on an asset\n    * @param baseAssetQuantity Exact base asset quantity to short\n    * @param min_dy Minimum amount of quote asset to be used while shorting baseAssetQuantity. Higher means shorting at a higher price (desirable).\n    * @return quoteAssetQuantity quote asset utilised. quoteAssetQuantity / baseAssetQuantity was the average short rate.\n      quoteAssetQuantity >= min_dy.\n    */\n    function _short(int256 baseAssetQuantity, uint min_dy) internal returns (uint256 quoteAssetQuantity) {\n        require(baseAssetQuantity < 0, \"VAMM._short: baseAssetQuantity is >= 0\");\n\n        uint _lastPrice;\n        (quoteAssetQuantity, _lastPrice) = vamm.exchange(\n            1, // sell base asset\n            0, // get quote asset\n            (-baseAssetQuantity).toUint256(), // short exactly. Note that statement asserts that baseAssetQuantity <= 0\n            min_dy\n        );\n\n        _addReserveSnapshot(_lastPrice);\n        // since maker position will be opposite of the trade\n        posAccumulator -= baseAssetQuantity * 1e18 / vamm.totalSupply().toInt256();\n        emit Swap(baseAssetQuantity, quoteAssetQuantity, _lastPrice, openInterestNotional());\n    }\n\n    function _emitPositionChanged(address trader, int256 realizedPnl) internal {\n        Position memory position = positions[trader];\n        emit PositionChanged(trader, position.size, position.openNotional, realizedPnl);\n    }\n\n    // @dev check takerPosition != 0 before calling\n    function _getPnlWhileReducingPosition(\n        int256 takerPosition,\n        uint takerOpenNotional,\n        int256 makerPosition,\n        uint newNotional\n    ) internal pure returns (int256 pnlToBeRealized) {\n        /**\n            makerNotional = newNotional * makerPos / totalPos\n            if (side remains same)\n                reducedOpenNotional = takerOpenNotional * makerPos / takerPos\n                pnl = makerNotional - reducedOpenNotional\n            else (reverse position)\n                closedPositionNotional = newNotional * takerPos / totalPos\n                pnl = closePositionNotional - takerOpenNotional\n         */\n\n        uint totalPosition = abs(makerPosition + takerPosition).toUint256();\n        if (abs(takerPosition) > abs(makerPosition)) { // taker position side remains same\n            uint reducedOpenNotional = takerOpenNotional * abs(makerPosition).toUint256() / abs(takerPosition).toUint256();\n            uint makerNotional = newNotional * abs(makerPosition).toUint256() / totalPosition;\n            pnlToBeRealized = _getPnlToBeRealized(takerPosition, makerNotional, reducedOpenNotional);\n        } else { // taker position side changes\n            // @todo handle case when totalPosition = 0\n            uint closedPositionNotional = newNotional * abs(takerPosition).toUint256() / totalPosition;\n            pnlToBeRealized = _getPnlToBeRealized(takerPosition, closedPositionNotional, takerOpenNotional);\n        }\n    }\n\n    function _getPnlToBeRealized(int256 takerPosition, uint notionalPosition, uint openNotional) internal pure returns (int256 pnlToBeRealized) {\n        if (takerPosition > 0) {\n            pnlToBeRealized = notionalPosition.toInt256() - openNotional.toInt256();\n        } else {\n            pnlToBeRealized = openNotional.toInt256() - notionalPosition.toInt256();\n        }\n    }\n\n    function _increasePosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        internal\n        returns(uint quoteAsset)\n    {\n        if (baseAssetQuantity > 0) { // Long - purchase baseAssetQuantity\n            longOpenInterestNotional += baseAssetQuantity.toUint256();\n            quoteAsset = _long(baseAssetQuantity, quoteAssetLimit);\n        } else { // Short - sell baseAssetQuantity\n            shortOpenInterestNotional += (-baseAssetQuantity).toUint256();\n            quoteAsset = _short(baseAssetQuantity, quoteAssetLimit);\n        }\n        positions[trader].size += baseAssetQuantity; // -ve baseAssetQuantity will increase short position\n        positions[trader].openNotional += quoteAsset;\n    }\n\n    function _openReversePosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        internal\n        returns (int realizedPnl, uint quoteAsset, bool isPositionIncreased)\n    {\n        Position memory position = positions[trader];\n        if (abs(position.size) >= abs(baseAssetQuantity)) {\n            (realizedPnl, quoteAsset) = _reducePosition(trader, baseAssetQuantity, quoteAssetLimit);\n        } else {\n            uint closedRatio = (quoteAssetLimit * abs(position.size).toUint256()) / abs(baseAssetQuantity).toUint256();\n            (realizedPnl, quoteAsset) = _reducePosition(trader, -position.size, closedRatio);\n\n            // this is required because the user might pass a very less value (slippage-prone) while shorting\n            if (quoteAssetLimit >= quoteAsset) {\n                quoteAssetLimit -= quoteAsset;\n            }\n            quoteAsset += _increasePosition(trader, baseAssetQuantity + position.size, quoteAssetLimit);\n            isPositionIncreased = true;\n        }\n    }\n\n    /**\n    * @dev validate that baseAssetQuantity <= position.size should be performed before the call to _reducePosition\n    */\n    function _reducePosition(address trader, int256 baseAssetQuantity, uint quoteAssetLimit)\n        internal\n        returns (int realizedPnl, uint256 quoteAsset)\n    {\n        (, int256 unrealizedPnl) = getTakerNotionalPositionAndUnrealizedPnl(trader);\n\n        Position storage position = positions[trader]; // storage because there are updates at the end\n        bool isLongPosition = position.size > 0 ? true : false;\n\n        if (isLongPosition) {\n            longOpenInterestNotional -= (-baseAssetQuantity).toUint256();\n            quoteAsset = _short(baseAssetQuantity, quoteAssetLimit);\n        } else {\n            shortOpenInterestNotional -= baseAssetQuantity.toUint256();\n            quoteAsset = _long(baseAssetQuantity, quoteAssetLimit);\n        }\n        uint256 notionalPosition = getCloseQuote(position.size + baseAssetQuantity);\n        (position.openNotional, realizedPnl) = getOpenNotionalWhileReducingPosition(position.size, notionalPosition, unrealizedPnl, baseAssetQuantity);\n        position.size += baseAssetQuantity;\n    }\n\n    function _addReserveSnapshot(uint256 price)\n        internal\n    {\n        uint256 currentBlock = block.number;\n        uint256 blockTimestamp = _blockTimestamp();\n\n        if (reserveSnapshots.length == 0) {\n            reserveSnapshots.push(\n                ReserveSnapshot(price, blockTimestamp, currentBlock)\n            );\n            return;\n        }\n\n        ReserveSnapshot storage latestSnapshot = reserveSnapshots[reserveSnapshots.length - 1];\n        // update values in snapshot if in the same block\n        if (currentBlock == latestSnapshot.blockNumber) {\n            latestSnapshot.lastPrice = price;\n        } else {\n            reserveSnapshots.push(\n                ReserveSnapshot(price, blockTimestamp, currentBlock)\n            );\n        }\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    function _calcTwap(uint256 _intervalInSeconds)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 snapshotIndex = reserveSnapshots.length - 1;\n        uint256 currentPrice = reserveSnapshots[snapshotIndex].lastPrice;\n        if (_intervalInSeconds == 0) {\n            return currentPrice;\n        }\n\n        uint256 baseTimestamp = _blockTimestamp() - _intervalInSeconds;\n        ReserveSnapshot memory currentSnapshot = reserveSnapshots[snapshotIndex];\n        // return the latest snapshot price directly\n        // if only one snapshot or the timestamp of latest snapshot is earlier than asking for\n        if (reserveSnapshots.length == 1 || currentSnapshot.timestamp <= baseTimestamp) {\n            return currentPrice;\n        }\n\n        uint256 previousTimestamp = currentSnapshot.timestamp;\n        uint256 period = _blockTimestamp() - previousTimestamp;\n        uint256 weightedPrice = currentPrice * period;\n        while (true) {\n            // if snapshot history is too short\n            if (snapshotIndex == 0) {\n                return weightedPrice / period;\n            }\n\n            snapshotIndex = snapshotIndex - 1;\n            currentSnapshot = reserveSnapshots[snapshotIndex];\n            currentPrice = reserveSnapshots[snapshotIndex].lastPrice;\n\n            // check if current round timestamp is earlier than target timestamp\n            if (currentSnapshot.timestamp <= baseTimestamp) {\n                // weighted time period will be (target timestamp - previous timestamp). For example,\n                // now is 1000, _interval is 100, then target timestamp is 900. If timestamp of current round is 970,\n                // and timestamp of NEXT round is 880, then the weighted time period will be (970 - 900) = 70,\n                // instead of (970 - 880)\n                weightedPrice = weightedPrice + (currentPrice * (previousTimestamp - baseTimestamp));\n                break;\n            }\n\n            uint256 timeFraction = previousTimestamp - currentSnapshot.timestamp;\n            weightedPrice = weightedPrice + (currentPrice * timeFraction);\n            period = period + timeFraction;\n            previousTimestamp = currentSnapshot.timestamp;\n        }\n        return weightedPrice / _intervalInSeconds;\n    }\n\n    function _updateFundingRate(\n        int256 _premiumFraction,\n        int256 _underlyingPrice\n    ) internal {\n        fundingRate = _premiumFraction * 1e6 / _underlyingPrice;\n        emit FundingRateUpdated(_premiumFraction, fundingRate, _underlyingPrice.toUint256(), _blockTimestamp(), block.number);\n    }\n\n    // Pure\n\n    function abs(int x) private pure returns (int) {\n        return x >= 0 ? x : -x;\n    }\n\n    // Governance\n\n    function setAmmState(AMMState _state) external onlyGovernance {\n        require(ammState != _state, \"AMM.setAmmState.sameState\");\n        ammState = _state;\n        if (_state == AMMState.Active) {\n            nextFundingTime = ((_blockTimestamp() + fundingPeriod) / 1 hours) * 1 hours;\n        }\n    }\n\n    function syncDeps(address _registry) public onlyGovernance {\n        IRegistry registry = IRegistry(_registry);\n        clearingHouse = registry.clearingHouse();\n        oracle = IOracle(registry.oracle());\n    }\n\n    function setFundingBufferPeriod(uint _fundingBufferPeriod) external onlyGovernance {\n        fundingBufferPeriod = _fundingBufferPeriod;\n    }\n}\n\n\n",
        "CodeNames": [
            "AMM.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AMM.sol",
                "Type": "Initialization restriction",
                "Description": "AMM Cannot Be initialize() Except By Governance.",
                "Repair": "Add the steps manually to initialize() or call initialize() from the governance address"
            }
        ]
    }
]