[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {FixedPriceFactory, FixedPrice} from \"src/minters/FixedPriceFactory.sol\";\n\ncontract FixedPriceBaseTest is EscherTest {\n    FixedPrice.Sale public fixedSale;\n    FixedPriceFactory public fixedSales;\n\n    function setUp() public virtual override {\n        super.setUp();\n        fixedSales = new FixedPriceFactory();\n        fixedSale = FixedPrice.Sale({\n            currentId: uint48(0),\n            finalId: uint48(10),\n            edition: address(edition),\n            price: uint96(uint256(1 ether)),\n            saleReceiver: payable(address(69)),\n            startTime: uint96(block.timestamp)\n        });\n    }\n}\n\ncontract FactoryTest is FixedPriceBaseTest {\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(fixedSales.feeReceiver()), address(this));\n        fixedSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(fixedSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        fixedSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(fixedSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        fixedSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        fixedSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        fixedSales.createFixedSale(fixedSale);\n    }\n\n    function test_CreateSale() public {\n        fixedSales.createFixedSale(fixedSale);\n    }\n}\n\ncontract FixedPriceImplementationTest is FixedPriceBaseTest {\n    FixedPrice public implementation;\n\n    function setUp() public override {\n        super.setUp();\n        implementation = FixedPrice(fixedSales.implementation());\n    }\n\n    function test_RevertsWhenInitialized_Initialize() public {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        implementation.initialize(fixedSale);\n    }\n\n    function test_RevertsWhenInitialized_Buy() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.buy{value: 0}(0);\n    }\n\n    function test_RevertsWhenInitialized_TransferOwnership() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.transferOwnership(address(1));\n        assertEq(implementation.owner(), address(0));\n    }\n\n    function test_RevertsWhenInitialized_Cancel() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.cancel();\n    }\n}\n\ncontract FixedPriceTest is FixedPriceBaseTest {\n    FixedPrice public sale;\n    event End(FixedPrice.Sale _saleInfo);\n\n    mapping(uint256 => address) ownersOf;\n    uint256 startId;\n    uint256 finalId;\n    uint256 currentId;\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_Buy() public {\n        // make the fixed price sale\n        sale = FixedPrice(fixedSales.createFixedSale(fixedSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooMany_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"TOO MANY\");\n        sale.buy{value: 11 ether}(11);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsTooMuchValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 2 ether}(1);\n    }\n\n    function test_WhenMintsOut_Buy() public {\n        test_Buy();\n        uint256 cached_balance = address(this).balance - 9 ether;\n\n        // set sale state to be emitted\n        fixedSale.currentId = uint48(10);\n        vm.expectEmit(true, true, false, true);\n        emit End(fixedSale);\n        sale.buy{value: 9 ether}(9);\n        assertEq(address(69).balance, 9.5 ether);\n        assertEq(address(this).balance - cached_balance, 0.5 ether);\n    }\n\n    function test_RevertsWhenMintedOut_Buy() public {\n        test_WhenMintsOut_Buy();\n\n        vm.expectRevert();\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwnership() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.transferOwnership(address(1));\n        assertEq(sale.owner(), fixedSale.saleReceiver);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        fixedSale.startTime = uint96(block.timestamp + 1);\n        // make the fixed price sale\n        sale = FixedPrice(fixedSales.createFixedSale(fixedSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        vm.prank(address(69));\n        sale.cancel();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// store nextId and remainingSupply, where nextId increases and remainingSupply decreases to 0\n    /// avoids strict equality of current == final\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint96 price;\n        address payable saleReceiver;\n        // slot 3\n        uint96 startTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(0, 0, address(0), type(uint96).max, payable(0), type(uint96).max);\n    }\n\n    /// @notice Owner can cancel current sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        Sale memory sale_ = sale;\n        IEscher721 nft = IEscher721(sale_.edition);\n        require(block.timestamp >= sale_.startTime, \"TOO SOON\");\n        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n        uint48 newId = uint48(_amount) + sale_.currentId;\n        require(newId <= sale_.finalId, \"TOO MANY\");\n\n        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, _amount, msg.value, sale);\n\n        if (newId == sale_.finalId) _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(_sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice cancel a fixed price sale\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    /// @notice Owner can cancel current sale\n    /// @param _sale the sale info\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        selfdestruct(_sale.saleReceiver);\n    }\n}\n\n\n",
        "CodeNames": [
            "FixedPrice.t.sol",
            "FixedPrice.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FixedPrice.sol contract, cancel function",
                "Type": "Inconsistency in fees",
                "Description": "Fees are deducted even when the seller cancels before the sale start time, which could lead to loss of funds.",
                "Repair": "Revise the cancel function to remove the deduction of fees when the seller cancels before the sale start time"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {FixedPriceFactory, FixedPrice} from \"src/minters/FixedPriceFactory.sol\";\n\ncontract FixedPriceBaseTest is EscherTest {\n    FixedPrice.Sale public fixedSale;\n    FixedPriceFactory public fixedSales;\n\n    function setUp() public virtual override {\n        super.setUp();\n        fixedSales = new FixedPriceFactory();\n        fixedSale = FixedPrice.Sale({\n            currentId: uint48(0),\n            finalId: uint48(10),\n            edition: address(edition),\n            price: uint96(uint256(1 ether)),\n            saleReceiver: payable(address(69)),\n            startTime: uint96(block.timestamp)\n        });\n    }\n}\n\ncontract FactoryTest is FixedPriceBaseTest {\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(fixedSales.feeReceiver()), address(this));\n        fixedSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(fixedSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        fixedSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(fixedSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        fixedSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        fixedSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        fixedSales.createFixedSale(fixedSale);\n    }\n\n    function test_CreateSale() public {\n        fixedSales.createFixedSale(fixedSale);\n    }\n}\n\ncontract FixedPriceImplementationTest is FixedPriceBaseTest {\n    FixedPrice public implementation;\n\n    function setUp() public override {\n        super.setUp();\n        implementation = FixedPrice(fixedSales.implementation());\n    }\n\n    function test_RevertsWhenInitialized_Initialize() public {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        implementation.initialize(fixedSale);\n    }\n\n    function test_RevertsWhenInitialized_Buy() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.buy{value: 0}(0);\n    }\n\n    function test_RevertsWhenInitialized_TransferOwnership() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.transferOwnership(address(1));\n        assertEq(implementation.owner(), address(0));\n    }\n\n    function test_RevertsWhenInitialized_Cancel() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.cancel();\n    }\n}\n\ncontract FixedPriceTest is FixedPriceBaseTest {\n    FixedPrice public sale;\n    event End(FixedPrice.Sale _saleInfo);\n\n    mapping(uint256 => address) ownersOf;\n    uint256 startId;\n    uint256 finalId;\n    uint256 currentId;\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_Buy() public {\n        // make the fixed price sale\n        sale = FixedPrice(fixedSales.createFixedSale(fixedSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooMany_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"TOO MANY\");\n        sale.buy{value: 11 ether}(11);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsTooMuchValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 2 ether}(1);\n    }\n\n    function test_WhenMintsOut_Buy() public {\n        test_Buy();\n        uint256 cached_balance = address(this).balance - 9 ether;\n\n        // set sale state to be emitted\n        fixedSale.currentId = uint48(10);\n        vm.expectEmit(true, true, false, true);\n        emit End(fixedSale);\n        sale.buy{value: 9 ether}(9);\n        assertEq(address(69).balance, 9.5 ether);\n        assertEq(address(this).balance - cached_balance, 0.5 ether);\n    }\n\n    function test_RevertsWhenMintedOut_Buy() public {\n        test_WhenMintsOut_Buy();\n\n        vm.expectRevert();\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwnership() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.transferOwnership(address(1));\n        assertEq(sale.owner(), fixedSale.saleReceiver);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        fixedSale.startTime = uint96(block.timestamp + 1);\n        // make the fixed price sale\n        sale = FixedPrice(fixedSales.createFixedSale(fixedSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        vm.prank(address(69));\n        sale.cancel();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract OpenEdition is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint72 price;\n        uint24 currentId;\n        address edition;\n        // slot 2\n        uint96 startTime;\n        address payable saleReceiver;\n        // slot 3\n        uint96 endTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(\n            type(uint72).max,\n            type(uint24).max,\n            address(0),\n            type(uint96).max,\n            payable(0),\n            type(uint96).max\n        );\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint24 amount = uint24(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        require(block.timestamp < temp.endTime, \"TOO LATE\");\n        require(amount * sale.price == msg.value, \"WRONG PRICE\");\n        uint24 newId = amount + temp.currentId;\n\n        for (uint24 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice finish an open edition and payout the artist\n    function finalize() public {\n        Sale memory temp = sale;\n        require(block.timestamp >= temp.endTime, \"TOO SOON\");\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        _end(temp);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice how much time is left in the sale\n    function timeLeft() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? sale.endTime - block.timestamp : 0;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    function available() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? type(uint24).max : 0;\n    }\n\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        selfdestruct(_sale.saleReceiver);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {OpenEditionFactory, OpenEdition} from \"src/minters/OpenEditionFactory.sol\";\n\ncontract OpenEditionBase is EscherTest {\n    OpenEditionFactory public openSales;\n    OpenEdition.Sale public openSale;\n\n    function setUp() public virtual override {\n        super.setUp();\n        openSales = new OpenEditionFactory();\n        openSale = OpenEdition.Sale({\n            price: uint72(uint256(1 ether)),\n            currentId: uint24(1),\n            edition: address(edition),\n            startTime: uint96(block.timestamp),\n            saleReceiver: payable(address(69)),\n            endTime: uint96(block.timestamp + 1 days)\n        });\n    }\n}\n\ncontract OpenEditionFactoryTest is OpenEditionBase {\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(openSales.feeReceiver()), address(this));\n        openSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(openSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        openSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(openSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        openSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        openSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        openSales.createOpenEdition(openSale);\n    }\n\n    function test_CreateSale() public {\n        openSales.createOpenEdition(openSale);\n    }\n}\n\ncontract OpenEditionImplementation is OpenEditionBase {\n    OpenEdition public implementation;\n\n    function setUp() public override {\n        super.setUp();\n        implementation = OpenEdition(openSales.implementation());\n    }\n\n    function test_RevertsWhenInitialized_Initialize() public {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        implementation.initialize(openSale);\n    }\n\n    function test_RevertsWhenInitialized_Buy() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.buy{value: 0}(0);\n    }\n\n    function test_RevertsWhenInitialized_TransferOwnership() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.transferOwnership(address(1));\n        assertEq(implementation.owner(), address(0));\n    }\n\n    function test_RevertsWhenInitialized_Cancel() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.cancel();\n    }\n\n    function test_RevertsWhenInitialized_Finalize() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.finalize();\n    }\n}\n\ncontract OpenEditionTest is OpenEditionBase {\n    OpenEdition public sale;\n    event End(OpenEdition.Sale _saleInfo);\n\n    function test_Buy() public {\n        sale = OpenEdition(openSales.createOpenEdition(openSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsTooMuchValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 2 ether}(1);\n    }\n\n    function test_RevertsWhenEnded_Buy() public {\n        test_Buy();\n        vm.warp(openSale.endTime);\n\n        vm.expectRevert(\"TOO LATE\");\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_RevertsWhenNotEnded_Finalize() public {\n        test_Buy();\n        vm.warp(openSale.endTime - 1);\n\n        vm.expectRevert(\"TOO SOON\");\n        sale.finalize();\n    }\n\n    function test_WhenEnded_Finalize() public {\n        test_Buy();\n        vm.warp(openSale.endTime);\n\n        sale.finalize();\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwnership() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.transferOwnership(address(1));\n        assertEq(sale.owner(), openSale.saleReceiver);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        openSale.startTime = uint96(block.timestamp + 1);\n        sale = OpenEdition(openSales.createOpenEdition(openSale));\n\n        vm.prank(address(69));\n        sale.cancel();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// store nextId and remainingSupply, where nextId increases and remainingSupply decreases to 0\n    /// avoids strict equality of current == final\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint96 price;\n        address payable saleReceiver;\n        // slot 3\n        uint96 startTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(0, 0, address(0), type(uint96).max, payable(0), type(uint96).max);\n    }\n\n    /// @notice Owner can cancel current sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        Sale memory sale_ = sale;\n        IEscher721 nft = IEscher721(sale_.edition);\n        require(block.timestamp >= sale_.startTime, \"TOO SOON\");\n        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n        uint48 newId = uint48(_amount) + sale_.currentId;\n        require(newId <= sale_.finalId, \"TOO MANY\");\n\n        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, _amount, msg.value, sale);\n\n        if (newId == sale_.finalId) _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(_sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice cancel a fixed price sale\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    /// @notice Owner can cancel current sale\n    /// @param _sale the sale info\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        selfdestruct(_sale.saleReceiver);\n    }\n}\n\n\n",
        "CodeNames": [
            "FixedPrice.t.sol",
            "OpenEdition.sol",
            "OpenEdition.t.sol",
            "FixedPrice.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FixedPrice.sol and OpenEdition.sol contracts, _end function",
                "Type": "selfdestruct may cause the funds to be lost",
                "Description": "If a transaction is executed after the contract is destroyed with selfdestruct, the transaction does not revert and any value sent along with the transaction will be stored in the contract, causing loss of funds.",
                "Repair": "Do not use selfdestruct and instead use modified state to represent that the contract has completed the sale"
            },
            {
                "Location": "selfdestruct() function in FixedPrice.sol and OpenEdition.sol contracts",
                "Type": "Obsolete Functionality",
                "Description": "The selfdestruct() function will not be available after EIP-4758 and using it in the contracts can break their logic.",
                "Repair": "Update the contracts to avoid using selfdestruct() function and use alternative methods for contract destruction"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {LPDA} from \"./LPDA.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {Clones} from \"openzeppelin/proxy/Clones.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\n\ncontract LPDAFactory is Ownable {\n    using Clones for address;\n\n    address payable public feeReceiver;\n    address public immutable implementation;\n\n    event NewLPDAContract(\n        address indexed _creator,\n        address indexed _edition,\n        address indexed _saleContract,\n        LPDA.Sale _saleInfo\n    );\n\n    constructor() Ownable() {\n        implementation = address(new LPDA());\n        feeReceiver = payable(msg.sender);\n    }\n\n    /// @notice create a fixed sale proxy contract\n    /// @param sale the sale info\n    function createLPDASale(LPDA.Sale calldata sale) external returns (address clone) {\n        require(IEscher721(sale.edition).hasRole(bytes32(0x00), msg.sender), \"NOT AUTHORIZED\");\n        require(sale.saleReceiver != address(0), \"INVALID SALE RECEIVER\");\n        require(sale.startTime >= block.timestamp, \"INVALID START TIME\");\n        require(sale.endTime > sale.startTime, \"INVALID END TIME\");\n        require(sale.finalId > sale.currentId, \"INVALID FINAL ID\");\n        require(sale.startPrice > 0, \"INVALID START PRICE\");\n        require(sale.dropPerSecond > 0, \"INVALID DROP PER SECOND\");\n\n        clone = implementation.clone();\n        LPDA(clone).initialize(sale);\n\n        emit NewLPDAContract(msg.sender, sale.edition, clone, sale);\n    }\n\n    /// @notice set the fee receiver for fixed price editions\n    /// @param fees the address to receive fees\n    function setFeeReceiver(address payable fees) public onlyOwner {\n        feeReceiver = fees;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {FixedPrice} from \"./FixedPrice.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {Clones} from \"openzeppelin/proxy/Clones.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\n\ncontract FixedPriceFactory is Ownable {\n    using Clones for address;\n\n    address payable public feeReceiver;\n    address public immutable implementation;\n\n    event NewFixedPriceContract(\n        address indexed creator,\n        address indexed edition,\n        address indexed saleContract,\n        FixedPrice.Sale saleInfo\n    );\n\n    constructor() Ownable() {\n        implementation = address(new FixedPrice());\n        feeReceiver = payable(msg.sender);\n    }\n\n    /// @notice create a fixed sale proxy contract\n    /// @param _sale the sale info\n    function createFixedSale(FixedPrice.Sale calldata _sale) external returns (address clone) {\n        require(IEscher721(_sale.edition).hasRole(bytes32(0x00), msg.sender), \"NOT AUTHORIZED\");\n        require(_sale.startTime >= block.timestamp, \"START TIME IN PAST\");\n        require(_sale.finalId > _sale.currentId, \"FINAL ID BEFORE CURRENT\");\n\n        clone = implementation.clone();\n        FixedPrice(clone).initialize(_sale);\n\n        emit NewFixedPriceContract(msg.sender, _sale.edition, clone, _sale);\n    }\n\n    /// @notice set the fee receiver for fixed price editions\n    /// @param fees the address to receive fees\n    function setFeeReceiver(address payable fees) public onlyOwner {\n        feeReceiver = fees;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {OpenEdition} from \"./OpenEdition.sol\";\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {Clones} from \"openzeppelin/proxy/Clones.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\n\ncontract OpenEditionFactory is Ownable {\n    using Clones for address;\n\n    address payable public feeReceiver;\n    address public immutable implementation;\n\n    event NewOpenEditionContract(\n        address indexed creator,\n        address indexed edition,\n        address indexed saleContract,\n        OpenEdition.Sale saleInfo\n    );\n\n    constructor() Ownable() {\n        implementation = address(new OpenEdition());\n        feeReceiver = payable(msg.sender);\n    }\n\n    /// @notice create a fixed sale proxy contract\n    /// @param sale the sale info\n    function createOpenEdition(OpenEdition.Sale calldata sale) external returns (address clone) {\n        require(IEscher721(sale.edition).hasRole(bytes32(0x00), msg.sender), \"NOT AUTHORIZED\");\n        require(sale.startTime >= block.timestamp, \"START TIME IN PAST\");\n        require(sale.endTime > sale.startTime, \"END TIME BEFORE START\");\n\n        clone = implementation.clone();\n        OpenEdition(clone).initialize(sale);\n\n        emit NewOpenEditionContract(msg.sender, sale.edition, clone, sale);\n    }\n\n    /// @notice set the fee receiver for fixed price editions\n    /// @param fees the address to receive fees\n    function setFeeReceiver(address payable fees) public onlyOwner {\n        feeReceiver = fees;\n    }\n}\n\n\n",
        "CodeNames": [
            "LPDAFactory.sol",
            "FixedPriceFactory.sol",
            "OpenEditionFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FixedPriceFactory.sol#L29, LPDAFactory.sol#L29, OpenEditionFactory.sol#L29",
                "Type": "Incorrect edition validation",
                "Description": "Malicious creators can create fake contracts that implemented IEscher721 and fake buyers to get free earnings. Sales contracts can be created by any creator and the sale data is filled with the one provided by the creator. The protocol does not validate the sale.edition provided by the creator and malicious creators can effectively use their fake contract address that implemented IEscher721. In the worst case, buyers will not get anything after their payments.",
                "Repair": "Track all the deployed Escher721 contracts in the Escher721Factory.sol and validate the sale.edition before creating sales contracts."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {LPDAFactory, LPDA} from \"src/minters/LPDAFactory.sol\";\n\ncontract LPDABase is EscherTest {\n    LPDAFactory public lpdaSales;\n    LPDA.Sale public lpdaSale;\n\n    function setUp() public virtual override {\n        super.setUp();\n        lpdaSales = new LPDAFactory();\n        // set up a LPDA Sale\n        lpdaSale = LPDA.Sale({\n            currentId: uint48(0),\n            finalId: uint48(10),\n            edition: address(edition),\n            startPrice: uint80(uint256(1 ether)),\n            finalPrice: uint80(uint256(0.1 ether)),\n            dropPerSecond: uint80(uint256(0.1 ether) / 1 days),\n            startTime: uint96(block.timestamp),\n            saleReceiver: payable(address(69)),\n            endTime: uint96(block.timestamp + 1 days)\n        });\n    }\n}\n\ncontract LPDAFactoryTest is LPDABase {\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(lpdaSales.feeReceiver()), address(this));\n        lpdaSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(lpdaSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        lpdaSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(lpdaSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        lpdaSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        lpdaSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        lpdaSales.createLPDASale(lpdaSale);\n    }\n\n    function test_CreateSale() public {\n        lpdaSales.createLPDASale(lpdaSale);\n    }\n}\n\ncontract LPDATest is LPDABase {\n    LPDA public sale;\n    event End(LPDA.Sale _saleInfo);\n\n    function test_Buy() public {\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        // authorize the lpda sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        //lets buy an NFT\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsWhenEnded_Buy() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime);\n\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_SellsOut_Buy() public {\n        test_Buy();\n\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_RevertsWhenSoldOut_Buy() public {\n        test_SellsOut_Buy();\n\n        vm.expectRevert(\"TOO MANY\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        lpdaSale.startTime = uint96(block.timestamp + 1);\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n\n        vm.prank(address(69));\n        sale.cancel();\n    }\n\n    function test_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime + 1);\n        sale.refund();\n    }\n\n    function test_WhenNotOver_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime - 1);\n        sale.refund();\n    }\n\n    function test_RevertsWhenNoRefund_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime + 1);\n        vm.expectRevert(\"NOTHING TO REFUND\");\n        vm.prank(address(69));\n        sale.refund();\n    }\n\n    function test_RevertsWhenAlreadyRefunded_Refund() public {\n        test_Refund();\n\n        vm.expectRevert(\"NOTHING TO REFUND\");\n        sale.refund();\n    }\n\n    function test_LPDA() public {\n        // make the lpda sales contract\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        // authorize the lpda sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        //lets buy an NFT\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n\n        vm.warp(block.timestamp + 1 days);\n        assertApproxEqRel(sale.getPrice(), 0.9 ether, lpdaSale.dropPerSecond);\n\n        // buy the rest\n        // this will auto end the sale\n        sale.buy{value: uint256((0.9 ether + lpdaSale.dropPerSecond) * 9)}(9);\n\n        vm.warp(block.timestamp + 2 days);\n\n        // now lets get a refund\n        uint256 bal = address(this).balance;\n        sale.refund();\n        assertApproxEqRel(address(this).balance, bal + 0.1 ether, lpdaSale.dropPerSecond);\n    }\n}\n\n\n",
        "CodeNames": [
            "LPDA.sol",
            "LPDA.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LPDA.sol line 81-88",
                "Type": "Stealing refunds",
                "Description": "The saleReceiver or feeReceiver can steal buyers over payments after the sale has ended. Buyers can mitigate this by continuously calling refund() as the price lowers but that would incur a high gas cost.",
                "Repair": "Don't allow buying 0 NFTs or don't allow buying if newId == finalId since the sale has ended"
            },
            {
                "Location": "LPDA contract's getPrice function",
                "Type": "Integer Underflow",
                "Description": "The LPDA contract's getPrice function can underflow the price due to bad settings and potentially brick the contract. This will eventually lead to a loss of funds because currently the only way to end a sale and transfer funds to the sale and fee receiver is to buy the complete set of NFTs in the sale.",
                "Repair": "Add a validation in the LPDAFactory.createLPDASale function to ensure that the given duration and drop per second settings can't underflow the price."
            },
            {
                "Location": "LPDA.sol contract, buy() function",
                "Type": "NFT mintable after auction deadline expires",
                "Description": "The buy() function on the LPDA.sol contract is not validating if the auction is still running, allowing a purchase to be made after the stipulated time.",
                "Repair": "Add a require statement to validate if the purchase is being made within the endTime"
            },
            {
                "Location": "buy() function in LPDA.sol",
                "Type": "Front-running",
                "Description": "Buyers can manipulate the buy() function in LPDA.sol by front-running other buyers and minting NFTs at higher prices, resulting in the seller receiving the lowest amount of revenue and some buyers minting nothing.",
                "Repair": "Refactor the affected code line to include a check for the difference between newId and temp.finalId, and adjust the amountSold and amount variables accordingly"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract OpenEdition is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint72 price;\n        uint24 currentId;\n        address edition;\n        // slot 2\n        uint96 startTime;\n        address payable saleReceiver;\n        // slot 3\n        uint96 endTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(\n            type(uint72).max,\n            type(uint24).max,\n            address(0),\n            type(uint96).max,\n            payable(0),\n            type(uint96).max\n        );\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint24 amount = uint24(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        require(block.timestamp < temp.endTime, \"TOO LATE\");\n        require(amount * sale.price == msg.value, \"WRONG PRICE\");\n        uint24 newId = amount + temp.currentId;\n\n        for (uint24 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice finish an open edition and payout the artist\n    function finalize() public {\n        Sale memory temp = sale;\n        require(block.timestamp >= temp.endTime, \"TOO SOON\");\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        _end(temp);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice how much time is left in the sale\n    function timeLeft() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? sale.endTime - block.timestamp : 0;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    function available() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? type(uint24).max : 0;\n    }\n\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        selfdestruct(_sale.saleReceiver);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// store nextId and remainingSupply, where nextId increases and remainingSupply decreases to 0\n    /// avoids strict equality of current == final\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint96 price;\n        address payable saleReceiver;\n        // slot 3\n        uint96 startTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(0, 0, address(0), type(uint96).max, payable(0), type(uint96).max);\n    }\n\n    /// @notice Owner can cancel current sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        Sale memory sale_ = sale;\n        IEscher721 nft = IEscher721(sale_.edition);\n        require(block.timestamp >= sale_.startTime, \"TOO SOON\");\n        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n        uint48 newId = uint48(_amount) + sale_.currentId;\n        require(newId <= sale_.finalId, \"TOO MANY\");\n\n        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, _amount, msg.value, sale);\n\n        if (newId == sale_.finalId) _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(_sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice cancel a fixed price sale\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    /// @notice Owner can cancel current sale\n    /// @param _sale the sale info\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        selfdestruct(_sale.saleReceiver);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {FixedPriceFactory, FixedPrice} from \"src/minters/FixedPriceFactory.sol\";\n\ncontract FixedPriceBaseTest is EscherTest {\n    FixedPrice.Sale public fixedSale;\n    FixedPriceFactory public fixedSales;\n\n    function setUp() public virtual override {\n        super.setUp();\n        fixedSales = new FixedPriceFactory();\n        fixedSale = FixedPrice.Sale({\n            currentId: uint48(0),\n            finalId: uint48(10),\n            edition: address(edition),\n            price: uint96(uint256(1 ether)),\n            saleReceiver: payable(address(69)),\n            startTime: uint96(block.timestamp)\n        });\n    }\n}\n\ncontract FactoryTest is FixedPriceBaseTest {\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(fixedSales.feeReceiver()), address(this));\n        fixedSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(fixedSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        fixedSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(fixedSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        fixedSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        fixedSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        fixedSales.createFixedSale(fixedSale);\n    }\n\n    function test_CreateSale() public {\n        fixedSales.createFixedSale(fixedSale);\n    }\n}\n\ncontract FixedPriceImplementationTest is FixedPriceBaseTest {\n    FixedPrice public implementation;\n\n    function setUp() public override {\n        super.setUp();\n        implementation = FixedPrice(fixedSales.implementation());\n    }\n\n    function test_RevertsWhenInitialized_Initialize() public {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        implementation.initialize(fixedSale);\n    }\n\n    function test_RevertsWhenInitialized_Buy() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.buy{value: 0}(0);\n    }\n\n    function test_RevertsWhenInitialized_TransferOwnership() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.transferOwnership(address(1));\n        assertEq(implementation.owner(), address(0));\n    }\n\n    function test_RevertsWhenInitialized_Cancel() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.cancel();\n    }\n}\n\ncontract FixedPriceTest is FixedPriceBaseTest {\n    FixedPrice public sale;\n    event End(FixedPrice.Sale _saleInfo);\n\n    mapping(uint256 => address) ownersOf;\n    uint256 startId;\n    uint256 finalId;\n    uint256 currentId;\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_Buy() public {\n        // make the fixed price sale\n        sale = FixedPrice(fixedSales.createFixedSale(fixedSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooMany_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"TOO MANY\");\n        sale.buy{value: 11 ether}(11);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsTooMuchValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 2 ether}(1);\n    }\n\n    function test_WhenMintsOut_Buy() public {\n        test_Buy();\n        uint256 cached_balance = address(this).balance - 9 ether;\n\n        // set sale state to be emitted\n        fixedSale.currentId = uint48(10);\n        vm.expectEmit(true, true, false, true);\n        emit End(fixedSale);\n        sale.buy{value: 9 ether}(9);\n        assertEq(address(69).balance, 9.5 ether);\n        assertEq(address(this).balance - cached_balance, 0.5 ether);\n    }\n\n    function test_RevertsWhenMintedOut_Buy() public {\n        test_WhenMintsOut_Buy();\n\n        vm.expectRevert();\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwnership() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.transferOwnership(address(1));\n        assertEq(sale.owner(), fixedSale.saleReceiver);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        fixedSale.startTime = uint96(block.timestamp + 1);\n        // make the fixed price sale\n        sale = FixedPrice(fixedSales.createFixedSale(fixedSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        vm.prank(address(69));\n        sale.cancel();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {OpenEditionFactory, OpenEdition} from \"src/minters/OpenEditionFactory.sol\";\n\ncontract OpenEditionBase is EscherTest {\n    OpenEditionFactory public openSales;\n    OpenEdition.Sale public openSale;\n\n    function setUp() public virtual override {\n        super.setUp();\n        openSales = new OpenEditionFactory();\n        openSale = OpenEdition.Sale({\n            price: uint72(uint256(1 ether)),\n            currentId: uint24(1),\n            edition: address(edition),\n            startTime: uint96(block.timestamp),\n            saleReceiver: payable(address(69)),\n            endTime: uint96(block.timestamp + 1 days)\n        });\n    }\n}\n\ncontract OpenEditionFactoryTest is OpenEditionBase {\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(openSales.feeReceiver()), address(this));\n        openSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(openSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        openSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(openSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        openSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        openSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        openSales.createOpenEdition(openSale);\n    }\n\n    function test_CreateSale() public {\n        openSales.createOpenEdition(openSale);\n    }\n}\n\ncontract OpenEditionImplementation is OpenEditionBase {\n    OpenEdition public implementation;\n\n    function setUp() public override {\n        super.setUp();\n        implementation = OpenEdition(openSales.implementation());\n    }\n\n    function test_RevertsWhenInitialized_Initialize() public {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        implementation.initialize(openSale);\n    }\n\n    function test_RevertsWhenInitialized_Buy() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.buy{value: 0}(0);\n    }\n\n    function test_RevertsWhenInitialized_TransferOwnership() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.transferOwnership(address(1));\n        assertEq(implementation.owner(), address(0));\n    }\n\n    function test_RevertsWhenInitialized_Cancel() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.cancel();\n    }\n\n    function test_RevertsWhenInitialized_Finalize() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.finalize();\n    }\n}\n\ncontract OpenEditionTest is OpenEditionBase {\n    OpenEdition public sale;\n    event End(OpenEdition.Sale _saleInfo);\n\n    function test_Buy() public {\n        sale = OpenEdition(openSales.createOpenEdition(openSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsTooMuchValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 2 ether}(1);\n    }\n\n    function test_RevertsWhenEnded_Buy() public {\n        test_Buy();\n        vm.warp(openSale.endTime);\n\n        vm.expectRevert(\"TOO LATE\");\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_RevertsWhenNotEnded_Finalize() public {\n        test_Buy();\n        vm.warp(openSale.endTime - 1);\n\n        vm.expectRevert(\"TOO SOON\");\n        sale.finalize();\n    }\n\n    function test_WhenEnded_Finalize() public {\n        test_Buy();\n        vm.warp(openSale.endTime);\n\n        sale.finalize();\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwnership() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.transferOwnership(address(1));\n        assertEq(sale.owner(), openSale.saleReceiver);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        openSale.startTime = uint96(block.timestamp + 1);\n        sale = OpenEdition(openSales.createOpenEdition(openSale));\n\n        vm.prank(address(69));\n        sale.cancel();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {LPDAFactory, LPDA} from \"src/minters/LPDAFactory.sol\";\n\ncontract LPDABase is EscherTest {\n    LPDAFactory public lpdaSales;\n    LPDA.Sale public lpdaSale;\n\n    function setUp() public virtual override {\n        super.setUp();\n        lpdaSales = new LPDAFactory();\n        // set up a LPDA Sale\n        lpdaSale = LPDA.Sale({\n            currentId: uint48(0),\n            finalId: uint48(10),\n            edition: address(edition),\n            startPrice: uint80(uint256(1 ether)),\n            finalPrice: uint80(uint256(0.1 ether)),\n            dropPerSecond: uint80(uint256(0.1 ether) / 1 days),\n            startTime: uint96(block.timestamp),\n            saleReceiver: payable(address(69)),\n            endTime: uint96(block.timestamp + 1 days)\n        });\n    }\n}\n\ncontract LPDAFactoryTest is LPDABase {\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(lpdaSales.feeReceiver()), address(this));\n        lpdaSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(lpdaSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        lpdaSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(lpdaSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        lpdaSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        lpdaSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        lpdaSales.createLPDASale(lpdaSale);\n    }\n\n    function test_CreateSale() public {\n        lpdaSales.createLPDASale(lpdaSale);\n    }\n}\n\ncontract LPDATest is LPDABase {\n    LPDA public sale;\n    event End(LPDA.Sale _saleInfo);\n\n    function test_Buy() public {\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        // authorize the lpda sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        //lets buy an NFT\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsWhenEnded_Buy() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime);\n\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_SellsOut_Buy() public {\n        test_Buy();\n\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_RevertsWhenSoldOut_Buy() public {\n        test_SellsOut_Buy();\n\n        vm.expectRevert(\"TOO MANY\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        lpdaSale.startTime = uint96(block.timestamp + 1);\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n\n        vm.prank(address(69));\n        sale.cancel();\n    }\n\n    function test_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime + 1);\n        sale.refund();\n    }\n\n    function test_WhenNotOver_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime - 1);\n        sale.refund();\n    }\n\n    function test_RevertsWhenNoRefund_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime + 1);\n        vm.expectRevert(\"NOTHING TO REFUND\");\n        vm.prank(address(69));\n        sale.refund();\n    }\n\n    function test_RevertsWhenAlreadyRefunded_Refund() public {\n        test_Refund();\n\n        vm.expectRevert(\"NOTHING TO REFUND\");\n        sale.refund();\n    }\n\n    function test_LPDA() public {\n        // make the lpda sales contract\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        // authorize the lpda sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        //lets buy an NFT\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n\n        vm.warp(block.timestamp + 1 days);\n        assertApproxEqRel(sale.getPrice(), 0.9 ether, lpdaSale.dropPerSecond);\n\n        // buy the rest\n        // this will auto end the sale\n        sale.buy{value: uint256((0.9 ether + lpdaSale.dropPerSecond) * 9)}(9);\n\n        vm.warp(block.timestamp + 2 days);\n\n        // now lets get a refund\n        uint256 bal = address(this).balance;\n        sale.refund();\n        assertApproxEqRel(address(this).balance, bal + 0.1 ether, lpdaSale.dropPerSecond);\n    }\n}\n\n\n",
        "CodeNames": [
            "OpenEdition.sol",
            "LPDA.sol",
            "FixedPrice.sol",
            "FixedPrice.t.sol",
            "OpenEdition.t.sol",
            "LPDA.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FixedPrice.sol, OpenEdition.sol, LPDA.sol",
                "Type": "Token minting vulnerability",
                "Description": "If an external entity mints any of the token ids involved in the sale, then the buy procedure will fail since it will try to mint an already existing id. This can be the creator manually minting a token or another similar contract that creates a sale.",
                "Repair": "Mint tokens to the sale contract, reserve a range of tokens to a particular minter, or have a single minter role at a given time"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {FixedPriceFactory, FixedPrice} from \"src/minters/FixedPriceFactory.sol\";\n\ncontract FixedPriceBaseTest is EscherTest {\n    FixedPrice.Sale public fixedSale;\n    FixedPriceFactory public fixedSales;\n\n    function setUp() public virtual override {\n        super.setUp();\n        fixedSales = new FixedPriceFactory();\n        fixedSale = FixedPrice.Sale({\n            currentId: uint48(0),\n            finalId: uint48(10),\n            edition: address(edition),\n            price: uint96(uint256(1 ether)),\n            saleReceiver: payable(address(69)),\n            startTime: uint96(block.timestamp)\n        });\n    }\n}\n\ncontract FactoryTest is FixedPriceBaseTest {\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(fixedSales.feeReceiver()), address(this));\n        fixedSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(fixedSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        fixedSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(fixedSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        fixedSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        fixedSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        fixedSales.createFixedSale(fixedSale);\n    }\n\n    function test_CreateSale() public {\n        fixedSales.createFixedSale(fixedSale);\n    }\n}\n\ncontract FixedPriceImplementationTest is FixedPriceBaseTest {\n    FixedPrice public implementation;\n\n    function setUp() public override {\n        super.setUp();\n        implementation = FixedPrice(fixedSales.implementation());\n    }\n\n    function test_RevertsWhenInitialized_Initialize() public {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        implementation.initialize(fixedSale);\n    }\n\n    function test_RevertsWhenInitialized_Buy() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.buy{value: 0}(0);\n    }\n\n    function test_RevertsWhenInitialized_TransferOwnership() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.transferOwnership(address(1));\n        assertEq(implementation.owner(), address(0));\n    }\n\n    function test_RevertsWhenInitialized_Cancel() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.cancel();\n    }\n}\n\ncontract FixedPriceTest is FixedPriceBaseTest {\n    FixedPrice public sale;\n    event End(FixedPrice.Sale _saleInfo);\n\n    mapping(uint256 => address) ownersOf;\n    uint256 startId;\n    uint256 finalId;\n    uint256 currentId;\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_Buy() public {\n        // make the fixed price sale\n        sale = FixedPrice(fixedSales.createFixedSale(fixedSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooMany_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"TOO MANY\");\n        sale.buy{value: 11 ether}(11);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsTooMuchValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 2 ether}(1);\n    }\n\n    function test_WhenMintsOut_Buy() public {\n        test_Buy();\n        uint256 cached_balance = address(this).balance - 9 ether;\n\n        // set sale state to be emitted\n        fixedSale.currentId = uint48(10);\n        vm.expectEmit(true, true, false, true);\n        emit End(fixedSale);\n        sale.buy{value: 9 ether}(9);\n        assertEq(address(69).balance, 9.5 ether);\n        assertEq(address(this).balance - cached_balance, 0.5 ether);\n    }\n\n    function test_RevertsWhenMintedOut_Buy() public {\n        test_WhenMintsOut_Buy();\n\n        vm.expectRevert();\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwnership() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.transferOwnership(address(1));\n        assertEq(sale.owner(), fixedSale.saleReceiver);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        fixedSale.startTime = uint96(block.timestamp + 1);\n        // make the fixed price sale\n        sale = FixedPrice(fixedSales.createFixedSale(fixedSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        vm.prank(address(69));\n        sale.cancel();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {LPDAFactory, LPDA} from \"src/minters/LPDAFactory.sol\";\n\ncontract LPDABase is EscherTest {\n    LPDAFactory public lpdaSales;\n    LPDA.Sale public lpdaSale;\n\n    function setUp() public virtual override {\n        super.setUp();\n        lpdaSales = new LPDAFactory();\n        // set up a LPDA Sale\n        lpdaSale = LPDA.Sale({\n            currentId: uint48(0),\n            finalId: uint48(10),\n            edition: address(edition),\n            startPrice: uint80(uint256(1 ether)),\n            finalPrice: uint80(uint256(0.1 ether)),\n            dropPerSecond: uint80(uint256(0.1 ether) / 1 days),\n            startTime: uint96(block.timestamp),\n            saleReceiver: payable(address(69)),\n            endTime: uint96(block.timestamp + 1 days)\n        });\n    }\n}\n\ncontract LPDAFactoryTest is LPDABase {\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(lpdaSales.feeReceiver()), address(this));\n        lpdaSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(lpdaSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        lpdaSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(lpdaSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        lpdaSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        lpdaSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        lpdaSales.createLPDASale(lpdaSale);\n    }\n\n    function test_CreateSale() public {\n        lpdaSales.createLPDASale(lpdaSale);\n    }\n}\n\ncontract LPDATest is LPDABase {\n    LPDA public sale;\n    event End(LPDA.Sale _saleInfo);\n\n    function test_Buy() public {\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        // authorize the lpda sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        //lets buy an NFT\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsWhenEnded_Buy() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime);\n\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_SellsOut_Buy() public {\n        test_Buy();\n\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_RevertsWhenSoldOut_Buy() public {\n        test_SellsOut_Buy();\n\n        vm.expectRevert(\"TOO MANY\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        lpdaSale.startTime = uint96(block.timestamp + 1);\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n\n        vm.prank(address(69));\n        sale.cancel();\n    }\n\n    function test_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime + 1);\n        sale.refund();\n    }\n\n    function test_WhenNotOver_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime - 1);\n        sale.refund();\n    }\n\n    function test_RevertsWhenNoRefund_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime + 1);\n        vm.expectRevert(\"NOTHING TO REFUND\");\n        vm.prank(address(69));\n        sale.refund();\n    }\n\n    function test_RevertsWhenAlreadyRefunded_Refund() public {\n        test_Refund();\n\n        vm.expectRevert(\"NOTHING TO REFUND\");\n        sale.refund();\n    }\n\n    function test_LPDA() public {\n        // make the lpda sales contract\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        // authorize the lpda sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        //lets buy an NFT\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n\n        vm.warp(block.timestamp + 1 days);\n        assertApproxEqRel(sale.getPrice(), 0.9 ether, lpdaSale.dropPerSecond);\n\n        // buy the rest\n        // this will auto end the sale\n        sale.buy{value: uint256((0.9 ether + lpdaSale.dropPerSecond) * 9)}(9);\n\n        vm.warp(block.timestamp + 2 days);\n\n        // now lets get a refund\n        uint256 bal = address(this).balance;\n        sale.refund();\n        assertApproxEqRel(address(this).balance, bal + 0.1 ether, lpdaSale.dropPerSecond);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// store nextId and remainingSupply, where nextId increases and remainingSupply decreases to 0\n    /// avoids strict equality of current == final\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint96 price;\n        address payable saleReceiver;\n        // slot 3\n        uint96 startTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(0, 0, address(0), type(uint96).max, payable(0), type(uint96).max);\n    }\n\n    /// @notice Owner can cancel current sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        Sale memory sale_ = sale;\n        IEscher721 nft = IEscher721(sale_.edition);\n        require(block.timestamp >= sale_.startTime, \"TOO SOON\");\n        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n        uint48 newId = uint48(_amount) + sale_.currentId;\n        require(newId <= sale_.finalId, \"TOO MANY\");\n\n        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, _amount, msg.value, sale);\n\n        if (newId == sale_.finalId) _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(_sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice cancel a fixed price sale\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    /// @notice Owner can cancel current sale\n    /// @param _sale the sale info\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        selfdestruct(_sale.saleReceiver);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}\n\n\n",
        "CodeNames": [
            "FixedPrice.t.sol",
            "LPDA.t.sol",
            "FixedPrice.sol",
            "LPDA.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "buy() function in FixedPrice.sol and LPDA.sol contracts",
                "Type": "Funds Stuck",
                "Description": "If all NFTs do not get sold, the ETH collected from the partial sale of the NFT batch can get stuck inside the contract and there is no function to recover it.",
                "Repair": "Add a function to claim the ETH collected from already successful NFT sales or modify the contracts to avoid the issue of funds getting stuck"
            },
            {
                "Location": "LPDA.sol and FixedPrice.sol contracts",
                "Type": "Unsafe downcasting operation",
                "Description": "The downcasting in LPDA.sol and FixedPrice.sol is damaging because it truncated user's fund. If the price goes above uint80, it will be wrongly truncated to uint80 for price.",
                "Repair": "Handle downcasting and use safe casting library to make sure the downcast does not provide an unexpected truncate value"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {EscherTest} from \"./utils/EscherTest.sol\";\n\ncontract Escher721Test is EscherTest {\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_UpdateURIDelegate() public {\n        edition.updateURIDelegate(address(0));\n    }\n\n    function test_RevertsWhenNotCreator_UpdateURIDelegate() public {\n        vm.prank(address(69));\n        vm.expectRevert();\n        edition.updateURIDelegate(address(0));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ITokenUriDelegate} from \"./interfaces/ITokenUriDelegate.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {ERC721Upgradeable} from \"openzeppelin-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport {ERC2981Upgradeable} from \"openzeppelin-upgradeable/token/common/ERC2981Upgradeable.sol\";\nimport {AccessControlUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlUpgradeable.sol\";\n\ncontract Escher721 is\n    Initializable,\n    ERC721Upgradeable,\n    AccessControlUpgradeable,\n    ERC2981Upgradeable\n{\n    /// @notice The role to update the URI delegate\n    bytes32 public constant URI_SETTER_ROLE = keccak256(\"URI_SETTER_ROLE\");\n    /// @notice The role to mint editionized art work\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    /// @notice The URI delegate address\n    address public tokenUriDelegate;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {}\n\n    /// @notice initialize the proxy contract\n    /// @param _creator the initial admin for the contract\n    /// @param _uri the address of the token URI delegate\n    /// @param _name the name of this contract\n    /// @param _symbol the symbol of this contract\n    function initialize(\n        address _creator,\n        address _uri,\n        string memory _name,\n        string memory _symbol\n    ) public initializer {\n        __ERC721_init(_name, _symbol);\n        __AccessControl_init();\n\n        tokenUriDelegate = _uri;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _creator);\n        _grantRole(MINTER_ROLE, _creator);\n        _grantRole(URI_SETTER_ROLE, _creator);\n    }\n\n    /// @notice mint a token\n    /// @param to who to mint the token to\n    /// @param tokenId the token ID to mint\n    function mint(address to, uint256 tokenId) public virtual onlyRole(MINTER_ROLE) {\n        _mint(to, tokenId);\n    }\n\n    /// @notice update the URI delegate contract\n    /// @param _uriDelegate The new tokenURIDelegate address\n    function updateURIDelegate(address _uriDelegate) public onlyRole(URI_SETTER_ROLE) {\n        tokenUriDelegate = _uriDelegate;\n    }\n\n    /// @notice set the default royalty for a contract\n    /// @param receiver the address who receives royalties\n    /// @param feeNumerator the royalty percentage\n    function setDefaultRoyalty(\n        address receiver,\n        uint96 feeNumerator\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _setDefaultRoyalty(receiver, feeNumerator);\n    }\n\n    /// @notice resets default royalties\n    function resetDefaultRoyalty() public onlyRole(DEFAULT_ADMIN_ROLE) {\n        _deleteDefaultRoyalty();\n    }\n\n    /// @notice Getter for the token URI\n    /// @param _tokenId the token ID to get the URI for\n    function tokenURI(\n        uint256 _tokenId\n    ) public view override(ERC721Upgradeable) returns (string memory) {\n        return ITokenUriDelegate(tokenUriDelegate).tokenURI(_tokenId);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable, ERC2981Upgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    // The following functions are overrides required by Solidity.\n    function _burn(uint256 tokenId) internal override(ERC721Upgradeable) {\n        super._burn(tokenId);\n    }\n}\n\n\n",
        "CodeNames": [
            "Escher721.t.sol",
            "Escher721.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Escher721 contract",
                "Type": "Missing Function",
                "Description": "The Escher721 contract does not have a setTokenRoyalty function that can be called by the artist, which contradicts the documentation.",
                "Repair": "Add a function to the Escher721 contract that exposes the internal _setTokenRoyalty function to the artist"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "EscherERC721.sol contracts",
                "Type": "Role-Based Access Control",
                "Description": "Ownership of EscherERC721.sol contracts can be changed, thus creator roles become useless, allowing a non-creator admin to create sales and operate as if he/she was a creator.",
                "Repair": "Override the grantRole() function of AccessControlUpgradeable.sol to disable the granting of roles after initialization, and store the created editions in a mapping to prevent problems like these"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract OpenEdition is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint72 price;\n        uint24 currentId;\n        address edition;\n        // slot 2\n        uint96 startTime;\n        address payable saleReceiver;\n        // slot 3\n        uint96 endTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(\n            type(uint72).max,\n            type(uint24).max,\n            address(0),\n            type(uint96).max,\n            payable(0),\n            type(uint96).max\n        );\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint24 amount = uint24(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        require(block.timestamp < temp.endTime, \"TOO LATE\");\n        require(amount * sale.price == msg.value, \"WRONG PRICE\");\n        uint24 newId = amount + temp.currentId;\n\n        for (uint24 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice finish an open edition and payout the artist\n    function finalize() public {\n        Sale memory temp = sale;\n        require(block.timestamp >= temp.endTime, \"TOO SOON\");\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        _end(temp);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice how much time is left in the sale\n    function timeLeft() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? sale.endTime - block.timestamp : 0;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    function available() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? type(uint24).max : 0;\n    }\n\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        selfdestruct(_sale.saleReceiver);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// store nextId and remainingSupply, where nextId increases and remainingSupply decreases to 0\n    /// avoids strict equality of current == final\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint96 price;\n        address payable saleReceiver;\n        // slot 3\n        uint96 startTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(0, 0, address(0), type(uint96).max, payable(0), type(uint96).max);\n    }\n\n    /// @notice Owner can cancel current sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        Sale memory sale_ = sale;\n        IEscher721 nft = IEscher721(sale_.edition);\n        require(block.timestamp >= sale_.startTime, \"TOO SOON\");\n        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n        uint48 newId = uint48(_amount) + sale_.currentId;\n        require(newId <= sale_.finalId, \"TOO MANY\");\n\n        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, _amount, msg.value, sale);\n\n        if (newId == sale_.finalId) _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(_sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice cancel a fixed price sale\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    /// @notice Owner can cancel current sale\n    /// @param _sale the sale info\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        selfdestruct(_sale.saleReceiver);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {FixedPriceFactory, FixedPrice} from \"src/minters/FixedPriceFactory.sol\";\n\ncontract FixedPriceBaseTest is EscherTest {\n    FixedPrice.Sale public fixedSale;\n    FixedPriceFactory public fixedSales;\n\n    function setUp() public virtual override {\n        super.setUp();\n        fixedSales = new FixedPriceFactory();\n        fixedSale = FixedPrice.Sale({\n            currentId: uint48(0),\n            finalId: uint48(10),\n            edition: address(edition),\n            price: uint96(uint256(1 ether)),\n            saleReceiver: payable(address(69)),\n            startTime: uint96(block.timestamp)\n        });\n    }\n}\n\ncontract FactoryTest is FixedPriceBaseTest {\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(fixedSales.feeReceiver()), address(this));\n        fixedSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(fixedSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        fixedSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(fixedSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        fixedSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        fixedSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        fixedSales.createFixedSale(fixedSale);\n    }\n\n    function test_CreateSale() public {\n        fixedSales.createFixedSale(fixedSale);\n    }\n}\n\ncontract FixedPriceImplementationTest is FixedPriceBaseTest {\n    FixedPrice public implementation;\n\n    function setUp() public override {\n        super.setUp();\n        implementation = FixedPrice(fixedSales.implementation());\n    }\n\n    function test_RevertsWhenInitialized_Initialize() public {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        implementation.initialize(fixedSale);\n    }\n\n    function test_RevertsWhenInitialized_Buy() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.buy{value: 0}(0);\n    }\n\n    function test_RevertsWhenInitialized_TransferOwnership() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.transferOwnership(address(1));\n        assertEq(implementation.owner(), address(0));\n    }\n\n    function test_RevertsWhenInitialized_Cancel() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.cancel();\n    }\n}\n\ncontract FixedPriceTest is FixedPriceBaseTest {\n    FixedPrice public sale;\n    event End(FixedPrice.Sale _saleInfo);\n\n    mapping(uint256 => address) ownersOf;\n    uint256 startId;\n    uint256 finalId;\n    uint256 currentId;\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_Buy() public {\n        // make the fixed price sale\n        sale = FixedPrice(fixedSales.createFixedSale(fixedSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooMany_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"TOO MANY\");\n        sale.buy{value: 11 ether}(11);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsTooMuchValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 2 ether}(1);\n    }\n\n    function test_WhenMintsOut_Buy() public {\n        test_Buy();\n        uint256 cached_balance = address(this).balance - 9 ether;\n\n        // set sale state to be emitted\n        fixedSale.currentId = uint48(10);\n        vm.expectEmit(true, true, false, true);\n        emit End(fixedSale);\n        sale.buy{value: 9 ether}(9);\n        assertEq(address(69).balance, 9.5 ether);\n        assertEq(address(this).balance - cached_balance, 0.5 ether);\n    }\n\n    function test_RevertsWhenMintedOut_Buy() public {\n        test_WhenMintsOut_Buy();\n\n        vm.expectRevert();\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwnership() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.transferOwnership(address(1));\n        assertEq(sale.owner(), fixedSale.saleReceiver);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        fixedSale.startTime = uint96(block.timestamp + 1);\n        // make the fixed price sale\n        sale = FixedPrice(fixedSales.createFixedSale(fixedSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        vm.prank(address(69));\n        sale.cancel();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {LPDAFactory, LPDA} from \"src/minters/LPDAFactory.sol\";\n\ncontract LPDABase is EscherTest {\n    LPDAFactory public lpdaSales;\n    LPDA.Sale public lpdaSale;\n\n    function setUp() public virtual override {\n        super.setUp();\n        lpdaSales = new LPDAFactory();\n        // set up a LPDA Sale\n        lpdaSale = LPDA.Sale({\n            currentId: uint48(0),\n            finalId: uint48(10),\n            edition: address(edition),\n            startPrice: uint80(uint256(1 ether)),\n            finalPrice: uint80(uint256(0.1 ether)),\n            dropPerSecond: uint80(uint256(0.1 ether) / 1 days),\n            startTime: uint96(block.timestamp),\n            saleReceiver: payable(address(69)),\n            endTime: uint96(block.timestamp + 1 days)\n        });\n    }\n}\n\ncontract LPDAFactoryTest is LPDABase {\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(lpdaSales.feeReceiver()), address(this));\n        lpdaSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(lpdaSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        lpdaSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(lpdaSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        lpdaSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        lpdaSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        lpdaSales.createLPDASale(lpdaSale);\n    }\n\n    function test_CreateSale() public {\n        lpdaSales.createLPDASale(lpdaSale);\n    }\n}\n\ncontract LPDATest is LPDABase {\n    LPDA public sale;\n    event End(LPDA.Sale _saleInfo);\n\n    function test_Buy() public {\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        // authorize the lpda sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        //lets buy an NFT\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsWhenEnded_Buy() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime);\n\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_SellsOut_Buy() public {\n        test_Buy();\n\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_RevertsWhenSoldOut_Buy() public {\n        test_SellsOut_Buy();\n\n        vm.expectRevert(\"TOO MANY\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        lpdaSale.startTime = uint96(block.timestamp + 1);\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n\n        vm.prank(address(69));\n        sale.cancel();\n    }\n\n    function test_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime + 1);\n        sale.refund();\n    }\n\n    function test_WhenNotOver_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime - 1);\n        sale.refund();\n    }\n\n    function test_RevertsWhenNoRefund_Refund() public {\n        test_Buy();\n\n        vm.warp(lpdaSale.endTime + 1);\n        vm.expectRevert(\"NOTHING TO REFUND\");\n        vm.prank(address(69));\n        sale.refund();\n    }\n\n    function test_RevertsWhenAlreadyRefunded_Refund() public {\n        test_Refund();\n\n        vm.expectRevert(\"NOTHING TO REFUND\");\n        sale.refund();\n    }\n\n    function test_LPDA() public {\n        // make the lpda sales contract\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        // authorize the lpda sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        //lets buy an NFT\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n\n        vm.warp(block.timestamp + 1 days);\n        assertApproxEqRel(sale.getPrice(), 0.9 ether, lpdaSale.dropPerSecond);\n\n        // buy the rest\n        // this will auto end the sale\n        sale.buy{value: uint256((0.9 ether + lpdaSale.dropPerSecond) * 9)}(9);\n\n        vm.warp(block.timestamp + 2 days);\n\n        // now lets get a refund\n        uint256 bal = address(this).balance;\n        sale.refund();\n        assertApproxEqRel(address(this).balance, bal + 0.1 ether, lpdaSale.dropPerSecond);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {OpenEditionFactory, OpenEdition} from \"src/minters/OpenEditionFactory.sol\";\n\ncontract OpenEditionBase is EscherTest {\n    OpenEditionFactory public openSales;\n    OpenEdition.Sale public openSale;\n\n    function setUp() public virtual override {\n        super.setUp();\n        openSales = new OpenEditionFactory();\n        openSale = OpenEdition.Sale({\n            price: uint72(uint256(1 ether)),\n            currentId: uint24(1),\n            edition: address(edition),\n            startTime: uint96(block.timestamp),\n            saleReceiver: payable(address(69)),\n            endTime: uint96(block.timestamp + 1 days)\n        });\n    }\n}\n\ncontract OpenEditionFactoryTest is OpenEditionBase {\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(openSales.feeReceiver()), address(this));\n        openSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(openSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        openSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(openSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        openSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        openSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        openSales.createOpenEdition(openSale);\n    }\n\n    function test_CreateSale() public {\n        openSales.createOpenEdition(openSale);\n    }\n}\n\ncontract OpenEditionImplementation is OpenEditionBase {\n    OpenEdition public implementation;\n\n    function setUp() public override {\n        super.setUp();\n        implementation = OpenEdition(openSales.implementation());\n    }\n\n    function test_RevertsWhenInitialized_Initialize() public {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        implementation.initialize(openSale);\n    }\n\n    function test_RevertsWhenInitialized_Buy() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.buy{value: 0}(0);\n    }\n\n    function test_RevertsWhenInitialized_TransferOwnership() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.transferOwnership(address(1));\n        assertEq(implementation.owner(), address(0));\n    }\n\n    function test_RevertsWhenInitialized_Cancel() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.cancel();\n    }\n\n    function test_RevertsWhenInitialized_Finalize() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.finalize();\n    }\n}\n\ncontract OpenEditionTest is OpenEditionBase {\n    OpenEdition public sale;\n    event End(OpenEdition.Sale _saleInfo);\n\n    function test_Buy() public {\n        sale = OpenEdition(openSales.createOpenEdition(openSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsTooMuchValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 2 ether}(1);\n    }\n\n    function test_RevertsWhenEnded_Buy() public {\n        test_Buy();\n        vm.warp(openSale.endTime);\n\n        vm.expectRevert(\"TOO LATE\");\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_RevertsWhenNotEnded_Finalize() public {\n        test_Buy();\n        vm.warp(openSale.endTime - 1);\n\n        vm.expectRevert(\"TOO SOON\");\n        sale.finalize();\n    }\n\n    function test_WhenEnded_Finalize() public {\n        test_Buy();\n        vm.warp(openSale.endTime);\n\n        sale.finalize();\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwnership() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.transferOwnership(address(1));\n        assertEq(sale.owner(), openSale.saleReceiver);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        openSale.startTime = uint96(block.timestamp + 1);\n        sale = OpenEdition(openSales.createOpenEdition(openSale));\n\n        vm.prank(address(69));\n        sale.cancel();\n    }\n}\n\n\n",
        "CodeNames": [
            "OpenEdition.sol",
            "LPDA.sol",
            "FixedPrice.sol",
            "FixedPrice.t.sol",
            "LPDA.t.sol",
            "OpenEdition.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LPDA.sol, FixedPrice.sol, OpenEdition.sol",
                "Type": "Use of payable.transfer() vulnerability",
                "Description": "The use of Solidity\u2019s transfer() when transferring ETH to the recipients can render ETH impossible to transfer when the recipient is a smart contract that does not implement a payable fallback function, or implements a payable fallback function which would incur more than 2300 gas units, or implements a payable fallback function incurring less than 2300 gas units but is called through a proxy that raises the call\u2019s gas usage above 2300.",
                "Repair": "Use of call with its returned boolean checked in combination with re-entrancy guard or Address.sendValue() available in OpenZeppelin Contract\u2019s Address library"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract OpenEdition is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint72 price;\n        uint24 currentId;\n        address edition;\n        // slot 2\n        uint96 startTime;\n        address payable saleReceiver;\n        // slot 3\n        uint96 endTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(\n            type(uint72).max,\n            type(uint24).max,\n            address(0),\n            type(uint96).max,\n            payable(0),\n            type(uint96).max\n        );\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint24 amount = uint24(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        require(block.timestamp < temp.endTime, \"TOO LATE\");\n        require(amount * sale.price == msg.value, \"WRONG PRICE\");\n        uint24 newId = amount + temp.currentId;\n\n        for (uint24 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice finish an open edition and payout the artist\n    function finalize() public {\n        Sale memory temp = sale;\n        require(block.timestamp >= temp.endTime, \"TOO SOON\");\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        _end(temp);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice how much time is left in the sale\n    function timeLeft() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? sale.endTime - block.timestamp : 0;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    function available() public view returns (uint256) {\n        return sale.endTime > block.timestamp ? type(uint24).max : 0;\n    }\n\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        selfdestruct(_sale.saleReceiver);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {EscherTest} from \"./utils/EscherTest.sol\";\nimport {OpenEditionFactory, OpenEdition} from \"src/minters/OpenEditionFactory.sol\";\n\ncontract OpenEditionBase is EscherTest {\n    OpenEditionFactory public openSales;\n    OpenEdition.Sale public openSale;\n\n    function setUp() public virtual override {\n        super.setUp();\n        openSales = new OpenEditionFactory();\n        openSale = OpenEdition.Sale({\n            price: uint72(uint256(1 ether)),\n            currentId: uint24(1),\n            edition: address(edition),\n            startTime: uint96(block.timestamp),\n            saleReceiver: payable(address(69)),\n            endTime: uint96(block.timestamp + 1 days)\n        });\n    }\n}\n\ncontract OpenEditionFactoryTest is OpenEditionBase {\n    function test_WhenOwner_SetFeeReceiver() public {\n        assertEq(address(openSales.feeReceiver()), address(this));\n        openSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(openSales.feeReceiver()), address(69));\n    }\n\n    function test_RevertsWhenNotOwner_SetFeeReceiver() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        openSales.setFeeReceiver(payable(address(69)));\n        assertEq(address(openSales.feeReceiver()), address(this));\n    }\n\n    function test_WhenOwner_TransferOwner() public {\n        openSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwner() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(69));\n        openSales.transferOwnership(address(69));\n    }\n\n    function test_RevertsWhenNotAdmin_CreateSale() public {\n        vm.prank(address(69));\n        vm.expectRevert(\"NOT AUTHORIZED\");\n        openSales.createOpenEdition(openSale);\n    }\n\n    function test_CreateSale() public {\n        openSales.createOpenEdition(openSale);\n    }\n}\n\ncontract OpenEditionImplementation is OpenEditionBase {\n    OpenEdition public implementation;\n\n    function setUp() public override {\n        super.setUp();\n        implementation = OpenEdition(openSales.implementation());\n    }\n\n    function test_RevertsWhenInitialized_Initialize() public {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        implementation.initialize(openSale);\n    }\n\n    function test_RevertsWhenInitialized_Buy() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.buy{value: 0}(0);\n    }\n\n    function test_RevertsWhenInitialized_TransferOwnership() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.transferOwnership(address(1));\n        assertEq(implementation.owner(), address(0));\n    }\n\n    function test_RevertsWhenInitialized_Cancel() public {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        implementation.cancel();\n    }\n\n    function test_RevertsWhenInitialized_Finalize() public {\n        vm.expectRevert(\"TOO SOON\");\n        implementation.finalize();\n    }\n}\n\ncontract OpenEditionTest is OpenEditionBase {\n    OpenEdition public sale;\n    event End(OpenEdition.Sale _saleInfo);\n\n    function test_Buy() public {\n        sale = OpenEdition(openSales.createOpenEdition(openSale));\n        // authorize the fixed price sale to mint tokens\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        // lets buy some NFTs\n        sale.buy{value: 1 ether}(1);\n        assertEq(address(sale).balance, 1 ether);\n    }\n\n    function test_RevertsWhenTooSoon_Buy() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"TOO SOON\");\n        sale.buy{value: 1 ether}(1);\n    }\n\n    function test_RevertsWhenTooLittleValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 0 ether}(1);\n    }\n\n    function test_RevertsTooMuchValue_Buy() public {\n        test_Buy();\n\n        vm.expectRevert(\"WRONG PRICE\");\n        sale.buy{value: 2 ether}(1);\n    }\n\n    function test_RevertsWhenEnded_Buy() public {\n        test_Buy();\n        vm.warp(openSale.endTime);\n\n        vm.expectRevert(\"TOO LATE\");\n        sale.buy{value: 9 ether}(9);\n    }\n\n    function test_RevertsWhenNotEnded_Finalize() public {\n        test_Buy();\n        vm.warp(openSale.endTime - 1);\n\n        vm.expectRevert(\"TOO SOON\");\n        sale.finalize();\n    }\n\n    function test_WhenEnded_Finalize() public {\n        test_Buy();\n        vm.warp(openSale.endTime);\n\n        sale.finalize();\n    }\n\n    function test_RevertsWhenNotOwner_TransferOwnership() public {\n        test_Buy();\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.transferOwnership(address(1));\n        assertEq(sale.owner(), openSale.saleReceiver);\n    }\n\n    function test_RevertsWhenNotOwner_Cancel() public {\n        test_Buy();\n\n        rewind(1);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        sale.cancel();\n    }\n\n    function test_RevertsWhenTooLate_Cancel() public {\n        test_Buy();\n\n        vm.prank(address(69));\n        vm.expectRevert(\"TOO LATE\");\n        sale.cancel();\n    }\n\n    function test_Cancel() public {\n        openSale.startTime = uint96(block.timestamp + 1);\n        sale = OpenEdition(openSales.createOpenEdition(openSale));\n\n        vm.prank(address(69));\n        sale.cancel();\n    }\n}\n\n\n",
        "CodeNames": [
            "OpenEdition.sol",
            "OpenEdition.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "OpenEdition contract",
                "Type": "Sale cancellation vulnerability",
                "Description": "The owner of the sale contract can still virtually cancel a sale after it has started by simply revoking the minting permissions to the sale contract.",
                "Repair": "Make the cancel function unrestricted or implement additional architecture changes to prevent the revocation of minting permissions under certain conditions"
            },
            {
                "Location": "OpenEdition.buy() function",
                "Type": "uint overflow",
                "Description": "The buy() function might revert due to uint overflow when it should work properly.",
                "Repair": "Modify the validation statement to convert uint24 to uint256 before multiplication"
            }
        ]
    }
]