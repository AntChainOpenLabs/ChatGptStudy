[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./lib/ReentrancyGuarded.sol\";\nimport \"./lib/EIP712.sol\";\nimport \"./lib/MerkleVerifier.sol\";\nimport \"./interfaces/IExchange.sol\";\nimport \"./interfaces/IPool.sol\";\nimport \"./interfaces/IExecutionDelegate.sol\";\nimport \"./interfaces/IPolicyManager.sol\";\nimport \"./interfaces/IMatchingPolicy.sol\";\nimport {\n  Side,\n  SignatureVersion,\n  AssetType,\n  Fee,\n  Order,\n  Input,\n  Execution\n} from \"./lib/OrderStructs.sol\";\n\n/**\n * @title Exchange\n * @dev Core exchange contract\n */\ncontract Exchange is IExchange, ReentrancyGuarded, EIP712, OwnableUpgradeable, UUPSUpgradeable {\n\n    /* Auth */\n    uint256 public isOpen;\n\n    modifier whenOpen() {\n        require(isOpen == 1, \"Closed\");\n        _;\n    }\n\n    modifier setupExecution() {\n        remainingETH = msg.value;\n        isInternal = true;\n        _;\n        remainingETH = 0;\n        isInternal = false;\n    }\n\n    modifier internalCall() {\n        require(isInternal, \"This function should not be called directly\");\n        _;\n    }\n\n    event Opened();\n    event Closed();\n\n    function open() external onlyOwner {\n        isOpen = 1;\n        emit Opened();\n    }\n    function close() external onlyOwner {\n        isOpen = 0;\n        emit Closed();\n    }\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n\n    /* Constants */\n    string public constant NAME = \"Exchange\";\n    string public constant VERSION = \"1.0\";\n    uint256 public constant INVERSE_BASIS_POINT = 10_000;\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant POOL = 0xF66CfDf074D2FFD6A4037be3A669Ed04380Aef2B;\n\n\n    /* Variables */\n    IExecutionDelegate public executionDelegate;\n    IPolicyManager public policyManager;\n    address public oracle;\n    uint256 public blockRange;\n\n\n    /* Storage */\n    mapping(bytes32 => bool) public cancelledOrFilled;\n    mapping(address => uint256) public nonces;\n\n\n    /* Events */\n    event OrdersMatched(\n        address indexed maker,\n        address indexed taker,\n        Order sell,\n        bytes32 sellHash,\n        Order buy,\n        bytes32 buyHash\n    );\n\n    event OrderCancelled(bytes32 hash);\n    event NonceIncremented(address indexed trader, uint256 newNonce);\n\n    event NewExecutionDelegate(IExecutionDelegate indexed executionDelegate);\n    event NewPolicyManager(IPolicyManager indexed policyManager);\n    event NewOracle(address indexed oracle);\n    event NewBlockRange(uint256 blockRange);\n\n    constructor() {\n      _disableInitializers();\n    }\n\n    /* Constructor (for ERC1967) */\n    function initialize(\n        IExecutionDelegate _executionDelegate,\n        IPolicyManager _policyManager,\n        address _oracle,\n        uint _blockRange\n    ) external initializer {\n        __Ownable_init();\n        isOpen = 1;\n\n        DOMAIN_SEPARATOR = _hashDomain(EIP712Domain({\n            name              : NAME,\n            version           : VERSION,\n            chainId           : block.chainid,\n            verifyingContract : address(this)\n        }));\n\n        executionDelegate = _executionDelegate;\n        policyManager = _policyManager;\n        oracle = _oracle;\n        blockRange = _blockRange;\n    }\n\n    // temporary function for testing\n    function updateDomainSeparator() external {\n        DOMAIN_SEPARATOR = _hashDomain(EIP712Domain({\n            name              : NAME,\n            version           : VERSION,\n            chainId           : block.chainid,\n            verifyingContract : address(this)\n        }));\n    }\n\n\n    /* External Functions */\n    bool public isInternal = false;\n    uint256 public remainingETH = 0;\n\n    /**\n     * @dev _execute wrapper \n     * @param sell Sell input\n     * @param buy Buy input\n     */\n    function execute(Input calldata sell, Input calldata buy)\n        external\n        payable\n        whenOpen\n        setupExecution\n    {\n        _execute(sell, buy);\n        _returnDust();\n    }\n\n    /**\n     * @dev Bulk execute multiple matches\n     * @param executions Potential buy/sell matches\n     */\n    function bulkExecute(Execution[] calldata executions)\n        external\n        payable\n        whenOpen\n        setupExecution\n    {\n        /*\n        REFERENCE\n        uint256 executionsLength = executions.length;\n        for (uint8 i=0; i < executionsLength; i++) {\n            bytes memory data = abi.encodeWithSelector(this._execute.selector, executions[i].sell, executions[i].buy);\n            (bool success,) = address(this).delegatecall(data);\n        }\n        _returnDust(remainingETH);\n        */\n        uint256 executionsLength = executions.length;\n        for (uint8 i = 0; i < executionsLength; i++) {\n            assembly {\n                let memPointer := mload(0x40)\n\n                let order_location := calldataload(add(executions.offset, mul(i, 0x20)))\n                let order_pointer := add(executions.offset, order_location)\n\n                let size\n                switch eq(add(i, 0x01), executionsLength)\n                case 1 {\n                    size := sub(calldatasize(), order_pointer)\n                }\n                default {\n                    let next_order_location := calldataload(add(executions.offset, mul(add(i, 0x01), 0x20)))\n                    let next_order_pointer := add(executions.offset, next_order_location)\n                    size := sub(next_order_pointer, order_pointer)\n                }\n\n                mstore(memPointer, 0xe04d94ae00000000000000000000000000000000000000000000000000000000) // _execute\n                calldatacopy(add(0x04, memPointer), order_pointer, size)\n                // must be put in separate transaction to bypass failed executions\n                // must be put in delegatecall to maintain the authorization from the caller\n                let result := delegatecall(gas(), address(), memPointer, add(size, 0x04), 0, 0)\n            }\n        }\n        _returnDust();\n    }\n\n    function _returnDust() private {\n        uint256 _remainingETH = remainingETH;\n        assembly {\n            if gt(_remainingETH, 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n    }\n\n    /**\n     * @dev Match two orders, ensuring validity of the match, and execute all associated state transitions. Protected against reentrancy by a contract-global lock. Must be called internally.\n     * @param sell Sell input\n     * @param buy Buy input\n     */\n    function _execute(Input calldata sell, Input calldata buy)\n        public\n        payable\n        reentrancyGuard\n        internalCall\n    {\n        require(sell.order.side == Side.Sell);\n\n        bytes32 sellHash = _hashOrder(sell.order, nonces[sell.order.trader]);\n        bytes32 buyHash = _hashOrder(buy.order, nonces[buy.order.trader]);\n\n        require(_validateSignatures(sell, sellHash), \"Sell failed authorization\");\n        require(_validateSignatures(buy, buyHash), \"Buy failed authorization\");\n\n        require(_validateOrderParameters(sell.order, sellHash), \"Sell has invalid parameters\");\n        require(_validateOrderParameters(buy.order, buyHash), \"Buy has invalid parameters\");\n\n        (uint256 price, uint256 tokenId, uint256 amount, AssetType assetType) = _canMatchOrders(sell.order, buy.order);\n\n        /* Mark orders as filled. */\n        cancelledOrFilled[sellHash] = true;\n        cancelledOrFilled[buyHash] = true;\n\n        _executeFundsTransfer(\n            sell.order.trader,\n            buy.order.trader,\n            sell.order.paymentToken,\n            sell.order.fees,\n            price\n        );\n        _executeTokenTransfer(\n            sell.order.collection,\n            sell.order.trader,\n            buy.order.trader,\n            tokenId,\n            amount,\n            assetType\n        );\n\n        emit OrdersMatched(\n            sell.order.listingTime <= buy.order.listingTime ? sell.order.trader : buy.order.trader,\n            sell.order.listingTime > buy.order.listingTime ? sell.order.trader : buy.order.trader,\n            sell.order,\n            sellHash,\n            buy.order,\n            buyHash\n        );\n\n        // return (price);\n    }\n\n    /**\n     * @dev Cancel an order, preventing it from being matched. Must be called by the trader of the order\n     * @param order Order to cancel\n     */\n    function cancelOrder(Order calldata order) public {\n        /* Assert sender is authorized to cancel order. */\n        require(msg.sender == order.trader);\n\n        bytes32 hash = _hashOrder(order, nonces[order.trader]);\n\n        require(!cancelledOrFilled[hash], \"Order already cancelled or filled\");\n\n        /* Mark order as cancelled, preventing it from being matched. */\n        cancelledOrFilled[hash] = true;\n        emit OrderCancelled(hash);\n    }\n\n    /**\n     * @dev Cancel multiple orders\n     * @param orders Orders to cancel\n     */\n    function cancelOrders(Order[] calldata orders) external {\n        for (uint8 i = 0; i < orders.length; i++) {\n            cancelOrder(orders[i]);\n        }\n    }\n\n    /**\n     * @dev Cancel all current orders for a user, preventing them from being matched. Must be called by the trader of the order\n     */\n    function incrementNonce() external {\n        nonces[msg.sender] += 1;\n        emit NonceIncremented(msg.sender, nonces[msg.sender]);\n    }\n\n\n    /* Setters */\n\n    function setExecutionDelegate(IExecutionDelegate _executionDelegate)\n        external\n        onlyOwner\n    {\n        require(address(_executionDelegate) != address(0), \"Address cannot be zero\");\n        executionDelegate = _executionDelegate;\n        emit NewExecutionDelegate(executionDelegate);\n    }\n\n    function setPolicyManager(IPolicyManager _policyManager)\n        external\n        onlyOwner\n    {\n        require(address(_policyManager) != address(0), \"Address cannot be zero\");\n        policyManager = _policyManager;\n        emit NewPolicyManager(policyManager);\n    }\n\n    function setOracle(address _oracle)\n        external\n        onlyOwner\n    {\n        require(_oracle != address(0), \"Address cannot be zero\");\n        oracle = _oracle;\n        emit NewOracle(oracle);\n    }\n\n    function setBlockRange(uint256 _blockRange)\n        external\n        onlyOwner\n    {\n        blockRange = _blockRange;\n        emit NewBlockRange(blockRange);\n    }\n\n\n    /* Internal Functions */\n\n    /**\n     * @dev Verify the validity of the order parameters\n     * @param order order\n     * @param orderHash hash of order\n     */\n    function _validateOrderParameters(Order calldata order, bytes32 orderHash)\n        internal\n        view\n        returns (bool)\n    {\n        return (\n            /* Order must have a trader. */\n            (order.trader != address(0)) &&\n            /* Order must not be cancelled or filled. */\n            (!cancelledOrFilled[orderHash]) &&\n            /* Order must be settleable. */\n            (order.listingTime < block.timestamp) &&\n            (block.timestamp < order.expirationTime)\n        );\n    }\n\n    /**\n     * @dev Verify the validity of the signatures\n     * @param order order\n     * @param orderHash hash of order\n     */\n    function _validateSignatures(Input calldata order, bytes32 orderHash)\n        internal\n        view\n        returns (bool)\n    {\n\n        if (order.order.trader == msg.sender) {\n          return true;\n        }\n\n        /* Check user authorization. */\n        if (\n            !_validateUserAuthorization(\n                orderHash,\n                order.order.trader,\n                order.v,\n                order.r,\n                order.s,\n                order.signatureVersion,\n                order.extraSignature\n            )\n        ) {\n            return false;\n        }\n\n        if (order.order.extraParams.length > 0 && order.order.extraParams[0] == 0x01) {\n            /* Check oracle authorization. */\n            require(block.number - order.blockNumber < blockRange, \"Signed block number out of range\");\n            if (\n                !_validateOracleAuthorization(\n                    orderHash,\n                    order.signatureVersion,\n                    order.extraSignature,\n                    order.blockNumber\n                )\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Verify the validity of the user signature\n     * @param orderHash hash of the order\n     * @param trader order trader who should be the signer\n     * @param v v\n     * @param r r\n     * @param s s\n     * @param signatureVersion signature version\n     * @param extraSignature packed merkle path\n     */\n    function _validateUserAuthorization(\n        bytes32 orderHash,\n        address trader,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        SignatureVersion signatureVersion,\n        bytes calldata extraSignature\n    ) internal view returns (bool) {\n        bytes32 hashToSign;\n        if (signatureVersion == SignatureVersion.Single) {\n            /* Single-listing authentication: Order signed by trader */\n            hashToSign = _hashToSign(orderHash);\n        } else if (signatureVersion == SignatureVersion.Bulk) {\n            /* Bulk-listing authentication: Merkle root of orders signed by trader */\n            (bytes32[] memory merklePath) = abi.decode(extraSignature, (bytes32[]));\n\n            bytes32 computedRoot = MerkleVerifier._computeRoot(orderHash, merklePath);\n            hashToSign = _hashToSignRoot(computedRoot);\n        }\n\n        return _verify(trader, hashToSign, v, r, s);\n    }\n\n    /**\n     * @dev Verify the validity of oracle signature\n     * @param orderHash hash of the order\n     * @param signatureVersion signature version\n     * @param extraSignature packed oracle signature\n     * @param blockNumber block number used in oracle signature\n     */\n    function _validateOracleAuthorization(\n        bytes32 orderHash,\n        SignatureVersion signatureVersion,\n        bytes calldata extraSignature,\n        uint256 blockNumber\n    ) internal view returns (bool) {\n        bytes32 oracleHash = _hashToSignOracle(orderHash, blockNumber);\n\n        uint8 v; bytes32 r; bytes32 s;\n        if (signatureVersion == SignatureVersion.Single) {\n            assembly {\n                v := calldataload(extraSignature.offset)\n                r := calldataload(add(extraSignature.offset, 0x20))\n                s := calldataload(add(extraSignature.offset, 0x40))\n            }\n            /*\n            REFERENCE\n            (v, r, s) = abi.decode(extraSignature, (uint8, bytes32, bytes32));\n            */\n        } else if (signatureVersion == SignatureVersion.Bulk) {\n            /* If the signature was a bulk listing the merkle path must be unpacked before the oracle signature. */\n            assembly {\n                v := calldataload(add(extraSignature.offset, 0x20))\n                r := calldataload(add(extraSignature.offset, 0x40))\n                s := calldataload(add(extraSignature.offset, 0x60))\n            }\n            /*\n            REFERENCE\n            uint8 _v, bytes32 _r, bytes32 _s;\n            (bytes32[] memory merklePath, uint8 _v, bytes32 _r, bytes32 _s) = abi.decode(extraSignature, (bytes32[], uint8, bytes32, bytes32));\n            v = _v; r = _r; s = _s;\n            */\n        }\n\n        return _verify(oracle, oracleHash, v, r, s);\n    }\n\n    /**\n     * @dev Verify ECDSA signature\n     * @param signer Expected signer\n     * @param digest Signature preimage\n     * @param v v\n     * @param r r\n     * @param s s\n     */\n    function _verify(\n        address signer,\n        bytes32 digest,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (bool) {\n        require(v == 27 || v == 28, \"Invalid v parameter\");\n        address recoveredSigner = ecrecover(digest, v, r, s);\n        if (recoveredSigner == address(0)) {\n          return false;\n        } else {\n          return signer == recoveredSigner;\n        }\n    }\n\n    /**\n     * @dev Call the matching policy to check orders can be matched and get execution parameters\n     * @param sell sell order\n     * @param buy buy order\n     */\n    function _canMatchOrders(Order calldata sell, Order calldata buy)\n        internal\n        view\n        returns (uint256 price, uint256 tokenId, uint256 amount, AssetType assetType)\n    {\n        bool canMatch;\n        if (sell.listingTime <= buy.listingTime) {\n            /* Seller is maker. */\n            require(policyManager.isPolicyWhitelisted(sell.matchingPolicy), \"Policy is not whitelisted\");\n            (canMatch, price, tokenId, amount, assetType) = IMatchingPolicy(sell.matchingPolicy).canMatchMakerAsk(sell, buy);\n        } else {\n            /* Buyer is maker. */\n            require(policyManager.isPolicyWhitelisted(buy.matchingPolicy), \"Policy is not whitelisted\");\n            (canMatch, price, tokenId, amount, assetType) = IMatchingPolicy(buy.matchingPolicy).canMatchMakerBid(buy, sell);\n        }\n        require(canMatch, \"Orders cannot be matched\");\n\n        return (price, tokenId, amount, assetType);\n    }\n\n    /**\n     * @dev Execute all ERC20 token / ETH transfers associated with an order match (fees and buyer => seller transfer)\n     * @param seller seller\n     * @param buyer buyer\n     * @param paymentToken payment token\n     * @param fees fees\n     * @param price price\n     */\n    function _executeFundsTransfer(\n        address seller,\n        address buyer,\n        address paymentToken,\n        Fee[] calldata fees,\n        uint256 price\n    ) internal {\n        if (msg.sender == buyer && paymentToken == address(0)) {\n            require(remainingETH >= price);\n            remainingETH -= price;\n        }\n\n        /* Take fee. */\n        uint256 receiveAmount = _transferFees(fees, paymentToken, buyer, price);\n\n        /* Transfer remainder to seller. */\n        _transferTo(paymentToken, buyer, seller, receiveAmount);\n    }\n\n    /**\n     * @dev Charge a fee in ETH or WETH\n     * @param fees fees to distribute\n     * @param paymentToken address of token to pay in\n     * @param from address to charge fees\n     * @param price price of token\n     */\n    function _transferFees(\n        Fee[] calldata fees,\n        address paymentToken,\n        address from,\n        uint256 price\n    ) internal returns (uint256) {\n        uint256 totalFee = 0;\n        for (uint8 i = 0; i < fees.length; i++) {\n            uint256 fee = (price * fees[i].rate) / INVERSE_BASIS_POINT;\n            _transferTo(paymentToken, from, fees[i].recipient, fee);\n            totalFee += fee;\n        }\n\n        require(totalFee <= price, \"Total amount of fees are more than the price\");\n\n        /* Amount that will be received by seller. */\n        uint256 receiveAmount = price - totalFee;\n        return (receiveAmount);\n    }\n\n    /**\n     * @dev Transfer amount in ETH or WETH\n     * @param paymentToken address of token to pay in\n     * @param from token sender\n     * @param to token recipient\n     * @param amount amount to transfer\n     */\n    function _transferTo(\n        address paymentToken,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (paymentToken == address(0)) {\n            /* Transfer funds in ETH. */\n            require(to != address(0), \"Transfer to zero address\");\n            (bool success,) = payable(to).call{value: amount}(\"\");\n            require(success, \"ETH transfer failed\");\n        } else if (paymentToken == POOL) {\n            /* Transfer Pool funds. */\n            bool success = IPool(POOL).transferFrom(from, to, amount);\n            require(success, \"Pool transfer failed\");\n        } else if (paymentToken == WETH) {\n            /* Transfer funds in WETH. */\n            executionDelegate.transferERC20(WETH, from, to, amount);\n        } else {\n            revert(\"Invalid payment token\");\n        }\n    }\n\n    /**\n     * @dev Execute call through delegate proxy\n     * @param collection collection contract address\n     * @param from seller address\n     * @param to buyer address\n     * @param tokenId tokenId\n     * @param assetType asset type of the token\n     */\n    function _executeTokenTransfer(\n        address collection,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        AssetType assetType\n    ) internal {\n        /* Call execution delegate. */\n        if (assetType == AssetType.ERC721) {\n            executionDelegate.transferERC721(collection, from, to, tokenId);\n        } else if (assetType == AssetType.ERC1155) {\n            executionDelegate.transferERC1155(collection, from, to, tokenId, amount);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Exchange.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Exchange.sol contract",
                "Type": "Centralization risk",
                "Description": "Hacked owner or malicious owner can immediately steal all assets on the platform due to the significant centralization risk trusting Exchange.sol contract to behave well, because it is an immediately upgradeable ERC1967Proxy.",
                "Repair": "Implement a timelock to give users enough time to withdraw their approvals before some malicious action becomes possible"
            },
            {
                "Location": "Exchange.sol contract",
                "Type": "Direct theft of buyer\u2019s ETH funds",
                "Description": "Seller or Fee recipient can steal ETH funds from the buyer when he is making a single or bulk execution. (Direct theft of funds).",
                "Repair": "Fix reentrancy issue by calling _execute before sending funds to fee recipient, add a check to prevent empty parameter in bulkExecute, and modify _returnDust to only send back the unused ETH to the buyer"
            },
            {
                "Location": "bulkExecute function and execute function in Exchange.sol contract",
                "Type": "Reentrancy Attack",
                "Description": "The vulnerability allows the fee recipient to drain the balance of the Exchange contract by reentering the contract through bulkExecute function and steal the buyer's ETH funds. The repair method involves adding a reentrancyGuard, modifying _refundDust function, and adding a revert statement in bulkExecute function.",
                "Repair": "1. Put a reentrancyGuard on execute and bulkExecute functions. 2. _refundDust return only _remainingETH. 3. Revert in bulkExecute if parameter array is empty."
            },
            {
                "Location": "Exchange contract",
                "Type": "Non-executable orders",
                "Description": "All orders which use expirationTime == 0 to support oracle cancellation are not executable",
                "Repair": "Implement the checks the same way as they were in the previous version of Exchange"
            },
            {
                "Location": "Exchange contract, function _returnDust",
                "Type": "Unchecked Yul call return value",
                "Description": "The Yul call return value on function _returnDust is not checked, which could lead to the sender lose funds",
                "Repair": "Mitigation to check call status and revert if unsuccessful was implemented"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./interfaces/IPool.sol\";\n\n/**\n * @title Pool\n * @dev ETH pool; funds can only be transferred by Exchange or Swap\n */\ncontract Pool is IPool, OwnableUpgradeable, UUPSUpgradeable {\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    address private constant EXCHANGE = 0x707531c9999AaeF9232C8FEfBA31FBa4cB78d84a;\n    // TODO: set proper address before deployment\n    address private constant SWAP = 0x707531c9999AaeF9232C8FEfBA31FBa4cB78d84a;\n\n    mapping(address => uint256) private _balances;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /**\n     * @dev receive deposit function\n     */\n    receive() external payable {\n        deposit();\n    }\n\n    /**\n     * @dev deposit ETH into pool\n     */\n    function deposit() public payable {\n        _balances[msg.sender] += msg.value;\n        emit Transfer(msg.sender, address(0), msg.value);\n    }\n\n    /**\n     * @dev withdraw ETH from pool\n     * @param amount Amount to withdraw\n     */\n    function withdraw(uint256 amount) public {\n        require(_balances[msg.sender] >= amount);\n        _balances[msg.sender] -= amount;\n        (bool success,) = payable(msg.sender).call{value: amount}(\"\");\n        require(success);\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    /**\n     * @dev transferFrom Transfer balances within pool; only callable by Swap and Exchange\n     * @param from Pool fund sender\n     * @param to Pool fund recipient\n     * @param amount Amount to transfer\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        returns (bool)\n    {\n        if (msg.sender != EXCHANGE && msg.sender != SWAP) {\n            revert('Caller is not authorized to transfer');\n        }\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    function _transfer(address from, address to, uint256 amount) private {\n        require(_balances[from] >= amount);\n        require(to != address(0));\n        _balances[from] -= amount;\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n    }\n\n    function balanceOf(address user) public view returns (uint256) {\n        return _balances[user];\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n\n",
        "CodeNames": [
            "Pool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Pool contract",
                "Type": "Un-upgradeable contract",
                "Description": "Pool designed to be upgradeable but does not set owner, making it un-upgradeable",
                "Repair": "Implement an initializer for Pool similarly to the Exchange.sol contract"
            }
        ]
    }
]