[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function recoverERC20(address token) external onlyOwner returns(bool)",
                "Type": "Privilege Escalation",
                "Description": "Owner can transfer all ERC20 reward token out using function recoverERC20.",
                "Repair": "Use a multisig wallet to safeguard the owner's wallet. Keep track of the reserved amount for rewarding token and only transfer the remaining amount of token out."
            },
            {
                "Location": "input validation checks",
                "Type": "Token Whitelist Bypass",
                "Description": "Pledges that contain delisted tokens can be extended to continue using delisted reward tokens.",
                "Repair": "Add a check during the input validation block to ensure that reward token of the pledge being extended is still a valid reward token."
            },
            {
                "Location": "function _boost()",
                "Type": "Reward Calculation Error",
                "Description": "Pledge may be out of reward due to the decay in veCRV balance. targetVotes is never reached.",
                "Repair": "Provide a way for the creator to provide additional rewards after the pledge creation. Or provide some reward refreshment function that recalculates votesDifference and transfers the required additional reward."
            },
            {
                "Location": "createPledge function",
                "Type": "Fee calculation vulnerability",
                "Description": "Fees charged from entire theoretical pledge amount instead of actual pledge amount.",
                "Repair": "Collect fees after the pledge completes or create a new pull function for owner to collect fees"
            },
            {
                "Location": "_pledge function",
                "Type": "Loss of precision vulnerability",
                "Description": "Due to loss of precision, targetVotes may not reach.",
                "Repair": "Use bias instead of amount in the check"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./oz/interfaces/IERC20.sol\";\nimport \"./oz/libraries/SafeERC20.sol\";\nimport \"./utils/Owner.sol\";\nimport \"./oz/utils/Pausable.sol\";\nimport \"./oz/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IBoostV2.sol\";\nimport \"./utils/Errors.sol\";\n\n/** @title Warden Pledge contract */\n/// @author Paladin\n/*\n    Delegation market (Pledge version) based on Curve Boost V2 contract\n*/\ncontract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Constants :\n    uint256 public constant UNIT = 1e18;\n    uint256 public constant MAX_PCT = 10000;\n    uint256 public constant WEEK = 7 * 86400;\n\n    // Storage :\n\n    struct Pledge{\n        // Target amount of veCRV (balance scaled by Boost v2, fetched as adjusted_balance)\n        uint256 targetVotes;\n        // Difference of votes between the target and the receiver balance at the start of the Pledge\n        // (used for later extend/increase of some parameters the Pledge)\n        uint256 votesDifference;\n        // Price per vote per second, set by the owner\n        uint256 rewardPerVote;\n        // Address to receive the Boosts\n        address receiver;\n        // Address of the token given as rewards to Boosters\n        address rewardToken;\n        // Timestamp of end of the Pledge\n        uint64 endTimestamp;\n        // Set to true if the Pledge is canceled, or when closed after the endTimestamp\n        bool closed;\n    }\n\n    /** @notice List of all Pledges */\n    Pledge[] public pledges;\n\n    /** @notice Owner of each Pledge (ordered by index in the pledges list) */\n    mapping(uint256 => address) public pledgeOwner;\n    /** @notice List of all Pledges for each owner */\n    mapping(address => uint256[]) public ownerPledges;\n\n    /** @notice Amount of rewards available for each Pledge */\n    // sorted by Pledge index\n    mapping(uint256 => uint256) public pledgeAvailableRewardAmounts;\n\n\n    /** @notice Address of the votingToken to delegate */\n    IVotingEscrow public votingEscrow;\n    /** @notice Address of the Delegation Boost contract */\n    IBoostV2 public delegationBoost;\n\n\n    /** @notice Minimum amount of reward per vote for each reward token */\n    // Also used to whitelist the tokens for rewards\n    mapping(address => uint256) public minAmountRewardToken;\n\n\n    /** @notice ratio of fees to pay the protocol (in BPS) */\n    uint256 public protocalFeeRatio = 250; //bps\n    /** @notice Address to receive protocol fees */\n    address public chestAddress;\n\n    /** @notice Minimum target of votes for a Pledge */\n    uint256 public minTargetVotes;\n\n    /** @notice Minimum delegation time, taken from veBoost contract */\n    uint256 public minDelegationTime = 1 weeks;\n\n\n    // Events\n\n    /** @notice Event emitted when xx */\n    event NewPledge(\n        address creator,\n        address receiver,\n        address rewardToken,\n        uint256 targetVotes,\n        uint256 rewardPerVote,\n        uint256 endTimestamp\n    );\n    /** @notice Event emitted when xx */\n    event ExtendPledgeDuration(uint256 indexed pledgeId, uint256 oldEndTimestamp, uint256 newEndTimestamp);\n    /** @notice Event emitted when xx */\n    event IncreasePledgeTargetVotes(uint256 indexed pledgeId, uint256 oldTargetVotes, uint256 newTargetVotes);\n    /** @notice Event emitted when xx */\n    event IncreasePledgeRewardPerVote(uint256 indexed pledgeId, uint256 oldRewardPerVote, uint256 newRewardPerVote);\n    /** @notice Event emitted when xx */\n    event ClosePledge(uint256 indexed pledgeId);\n    /** @notice Event emitted when xx */\n    event RetrievedPledgeRewards(uint256 indexed pledgeId, address receiver, uint256 amount);\n\n    /** @notice Event emitted when xx */\n    event Pledged(uint256 indexed pledgeId, address indexed user, uint256 amount, uint256 endTimestamp);\n\n    /** @notice Event emitted when xx */\n    event NewRewardToken(address indexed token, uint256 minRewardPerSecond);\n    /** @notice Event emitted when xx */\n    event UpdateRewardToken(address indexed token, uint256 minRewardPerSecond);\n    /** @notice Event emitted when xx */\n    event RemoveRewardToken(address indexed token);\n\n    /** @notice Event emitted when xx */\n    event ChestUpdated(address oldChest, address newChest);\n    /** @notice Event emitted when xx */\n    event PlatformFeeUpdated(uint256 oldfee, uint256 newFee);\n    /** @notice Event emitted when xx */\n    event MinTargetUpdated(uint256 oldMinTarget, uint256 newMinTargetVotes);\n\n\n\n    // Constructor\n\n    /**\n    * @dev Creates the contract, set the given base parameters\n    * @param _votingEscrow address of the voting token to delegate\n    * @param _delegationBoost address of the contract handling delegation\n    * @param _minTargetVotes min amount of veToken to target in a Pledge\n    */\n    constructor(\n        address _votingEscrow,\n        address _delegationBoost,\n        address _chestAddress,\n        uint256 _minTargetVotes\n    ) {\n        votingEscrow = IVotingEscrow(_votingEscrow);\n        delegationBoost = IBoostV2(_delegationBoost);\n\n        chestAddress = _chestAddress;\n\n        minTargetVotes = _minTargetVotes;\n    }\n\n    \n    // View Methods\n\n    /**\n    * @notice Amount of Pledges listed in this contract\n    * @dev Amount of Pledges listed in this contract\n    * @return uint256: Amount of Pledges listed in this contract\n    */\n    function pledgesIndex() public view returns(uint256){\n        return pledges.length;\n    }\n\n    /**\n    * @notice Get all Pledges created by the user\n    * @dev Get all Pledges created by the user\n    * @param user Address of the user\n    * @return uint256[]: List of Pledges IDs\n    */\n    function getUserPledges(address user) external view returns(uint256[] memory){\n        return ownerPledges[user];\n    }\n\n    /**\n    * @notice Get all the Pledges\n    * @dev Get all the Pledges\n    * @return Pledge[]: List of Pledge structs\n    */\n    function getAllPledges() external view returns(Pledge[] memory){\n        return pledges;\n    }\n\n    /**\n    * @dev Rounds down given timestamp to weekly periods\n    * @param timestamp timestamp to round down\n    * @return uint256: rounded down timestamp\n    */\n    function _getRoundedTimestamp(uint256 timestamp) internal pure returns(uint256) {\n        return (timestamp / WEEK) * WEEK;\n    }\n\n\n    // Pledgers Methods\n\n    /**\n    * @notice Delegates boost to a given Pledge & receive rewards\n    * @dev Delegates boost to a given Pledge & receive rewards\n    * @param pledgeId Pledge to delegate to\n    * @param amount Amount to delegate\n    * @param endTimestamp End of delegation\n    */\n    function pledge(uint256 pledgeId, uint256 amount, uint256 endTimestamp) external whenNotPaused nonReentrant {\n        _pledge(pledgeId, msg.sender, amount, endTimestamp);\n    }\n\n    /**\n    * @notice Delegates boost (using a percentage of the balance) to a given Pledge & receive rewards\n    * @dev Delegates boost (using a percentage of the balance) to a given Pledge & receive rewards\n    * @param pledgeId Pledge to delegate to\n    * @param percent Percent of balance to delegate\n    * @param endTimestamp End of delegation\n    */\n    function pledgePercent(uint256 pledgeId, uint256 percent, uint256 endTimestamp) external whenNotPaused nonReentrant {\n        if(percent > MAX_PCT) revert Errors.PercentOverMax();\n\n        uint256 amount = (votingEscrow.balanceOf(msg.sender) * percent) / MAX_PCT;\n\n        _pledge(pledgeId, msg.sender, amount, endTimestamp);\n        \n    }\n\n    /**\n    * @dev Delegates the boost to the Pledge receiver & sends rewards to the delegator\n    * @param pledgeId Pledge to delegate to\n    * @param user Address of the delegator\n    * @param amount Amount to delegate\n    * @param endTimestamp End of delegation\n    */\n    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        if(amount == 0) revert Errors.NullValue();\n\n        // Load Pledge parameters & check the Pledge is still active\n        Pledge memory pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        // To join until the end of the pledge, user can input 0 as endTimestamp\n        // so it's override by the Pledge's endTimestamp\n        if(endTimestamp == 0) endTimestamp = pledgeParams.endTimestamp;\n        if(endTimestamp > pledgeParams.endTimestamp || endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n\n        // Calculated the effective Pledge duration\n        uint256 boostDuration = endTimestamp - block.timestamp;\n\n        // Check that the user has enough boost delegation available & set the correct allowance to this contract\n        delegationBoost.checkpoint_user(user);\n        if(delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance();\n        if(delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate();\n\n        // Check that this will not go over the Pledge target of votes\n        if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n\n        // Creates the DelegationBoost\n        delegationBoost.boost(\n            pledgeParams.receiver,\n            amount,\n            endTimestamp,\n            user\n        );\n\n        // Re-calculate the new Boost bias & slope (using Boostv2 logic)\n        uint256 slope = amount / boostDuration;\n        uint256 bias = slope * boostDuration;\n\n        // Rewards are set in the Pledge as reward/veToken/sec\n        // To find the total amount of veToken delegated through the whole Boost duration\n        // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases\n        // each second of the Boost duration\n        uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;\n        // Then we can calculate the total amount of rewards for this Boost\n        uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;\n\n        if(rewardAmount > pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();\n        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;\n\n        // Send the rewards to the user\n        IERC20(pledgeParams.rewardToken).safeTransfer(user, rewardAmount);\n\n        emit Pledged(pledgeId, user, amount, endTimestamp);\n    }\n\n\n    // Pledge Creators Methods\n\n    struct CreatePledgeVars {\n        uint256 duration;\n        uint256 votesDifference;\n        uint256 totalRewardAmount;\n        uint256 feeAmount;\n        uint256 newPledgeID;\n    }\n\n    /**\n    * @notice Creates a new Pledge\n    * @dev Creates a new Pledge\n    * @param receiver Address to receive the boost delegation\n    * @param rewardToken Address of the token distributed as reward\n    * @param targetVotes Maximum taget of votes to have (own balacne + delegation) for the receiver\n    * @param rewardPerVote Amount of reward given for each vote delegation (per second)\n    * @param endTimestamp End of the Pledge\n    * @param maxTotalRewardAmount Maximum total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum feeamount allowed ot be pulled by this contract\n    * @return uint256: Newly created Pledge ID\n    */\n    function createPledge(\n        address receiver,\n        address rewardToken,\n        uint256 targetVotes,\n        uint256 rewardPerVote, // reward/veToken/second\n        uint256 endTimestamp,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant returns(uint256){\n        address creator = msg.sender;\n\n        if(receiver == address(0) || rewardToken == address(0)) revert Errors.ZeroAddress();\n        if(targetVotes < minTargetVotes) revert Errors.TargetVoteUnderMin();\n        if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted();\n        if(rewardPerVote < minAmountRewardToken[rewardToken]) revert Errors.RewardPerVoteTooLow();\n\n        if(endTimestamp == 0) revert Errors.NullEndTimestamp();\n        if(endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n\n        CreatePledgeVars memory vars;\n        vars.duration = endTimestamp - block.timestamp;\n        if(vars.duration < minDelegationTime) revert Errors.DurationTooShort();\n\n        // Get the missing votes for the given receiver to reach the target votes\n        // We ignore any delegated boost here because they might expire during the Pledge duration\n        // (we can have a future version of this contract using adjusted_balance)\n        vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);\n\n        vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;\n        vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(vars.totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(vars.feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n        // Pull all the rewards in this contract\n        IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount);\n\n        vars.newPledgeID = pledgesIndex();\n\n        // Add the total reards as available for the Pledge & write Pledge parameters in storage\n        pledgeAvailableRewardAmounts[vars.newPledgeID] += vars.totalRewardAmount;\n\n        pledges.push(Pledge(\n            targetVotes,\n            vars.votesDifference,\n            rewardPerVote,\n            receiver,\n            rewardToken,\n            safe64(endTimestamp),\n            false\n        ));\n\n        pledgeOwner[vars.newPledgeID] = creator;\n        ownerPledges[creator].push(vars.newPledgeID);\n\n        emit NewPledge(creator, receiver, rewardToken, targetVotes, rewardPerVote, endTimestamp);\n\n        return vars.newPledgeID;\n    }\n\n    /**\n    * @notice Extends the Pledge duration\n    * @dev Extends the Pledge duration & add rewards for that new duration\n    * @param pledgeId ID of the Pledge\n    * @param newEndTimestamp New end of the Pledge\n    * @param maxTotalRewardAmount Maximum added total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum fee amount allowed ot be pulled by this contract\n    */\n    function extendPledge(\n        uint256 pledgeId,\n        uint256 newEndTimestamp,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n        if(newEndTimestamp == 0) revert Errors.NullEndTimestamp();\n        uint256 oldEndTimestamp = pledgeParams.endTimestamp;\n        if(newEndTimestamp != _getRoundedTimestamp(newEndTimestamp) || newEndTimestamp < oldEndTimestamp) revert Errors.InvalidEndTimestamp();\n\n        uint256 addedDuration = newEndTimestamp - oldEndTimestamp;\n        if(addedDuration < minDelegationTime) revert Errors.DurationTooShort();\n        uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;\n        uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n\n        // Pull all the rewards in this contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, address(this), totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, chestAddress, feeAmount);\n\n        // Update the Pledge parameters in storage\n        pledgeParams.endTimestamp = safe64(newEndTimestamp);\n\n        pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;\n\n        emit ExtendPledgeDuration(pledgeId, oldEndTimestamp, newEndTimestamp);\n    }\n\n    /**\n    * @notice Increases the Pledge reward per vote delegated\n    * @dev Increases the Pledge reward per vote delegated & add rewards for that new duration\n    * @param pledgeId ID of the Pledge\n    * @param newRewardPerVote New amount of reward given for each vote delegation (per second)\n    * @param maxTotalRewardAmount Maximum added total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum fee amount allowed ot be pulled by this contract\n    */\n    function increasePledgeRewardPerVote(\n        uint256 pledgeId,\n        uint256 newRewardPerVote,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        uint256 oldRewardPerVote = pledgeParams.rewardPerVote;\n        if(newRewardPerVote <= oldRewardPerVote) revert Errors.RewardsPerVotesTooLow();\n        uint256 remainingDuration = pledgeParams.endTimestamp - block.timestamp;\n        uint256 rewardPerVoteDiff = newRewardPerVote - oldRewardPerVote;\n        uint256 totalRewardAmount = (rewardPerVoteDiff * pledgeParams.votesDifference * remainingDuration) / UNIT;\n        uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n        // Pull all the rewards in this contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, address(this), totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, chestAddress, feeAmount);\n\n        // Update the Pledge parameters in storage\n        pledgeParams.rewardPerVote = newRewardPerVote;\n\n        pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;\n\n        emit IncreasePledgeRewardPerVote(pledgeId, oldRewardPerVote, newRewardPerVote);\n    }\n\n    /**\n    * @notice Retrieves all non distributed rewards from a closed Pledge\n    * @dev Retrieves all non distributed rewards from a closed Pledge & send them to the given receiver\n    * @param pledgeId ID fo the Pledge\n    * @param receiver Address to receive the remaining rewards\n    */\n    function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n        if(receiver == address(0)) revert Errors.ZeroAddress();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.endTimestamp > block.timestamp) revert Errors.PledgeNotExpired();\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        // Set the Pledge as Closed\n        if(!pledgeParams.closed) pledgeParams.closed = true;\n\n        if(remainingAmount > 0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);\n\n        }\n    }\n\n    /**\n    * @notice Closes a Pledge and retrieves all non distributed rewards from a Pledge\n    * @dev Closes a Pledge and retrieves all non distributed rewards from a Pledge & send them to the given receiver\n    * @param pledgeId ID fo the Pledge to close\n    * @param receiver Address to receive the remaining rewards\n    */\n    function closePledge(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n        if(receiver == address(0)) revert Errors.ZeroAddress();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeAlreadyClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        // Set the Pledge as Closed\n        pledgeParams.closed = true;\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        if(remainingAmount > 0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);\n\n        }\n\n        emit ClosePledge(pledgeId);\n    }\n\n\n    // Admin Methods\n\n    /**\n    * @dev Adds a given reward token to the whitelist\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function _addRewardToken(address token, uint256 minRewardPerSecond) internal {\n        if(minAmountRewardToken[token] != 0) revert Errors.AlreadyAllowedToken();\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minRewardPerSecond == 0) revert Errors.NullValue();\n        \n        minAmountRewardToken[token] = minRewardPerSecond;\n\n        emit NewRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Adds a given reward token to the whitelist\n    * @dev Adds a given reward token to the whitelist\n    * @param tokens List of token addresses to add\n    * @param minRewardsPerSecond Minmum amount of reward per vote per second for each token in the list\n    */\n    function addMultipleRewardToken(address[] calldata tokens, uint256[] calldata minRewardsPerSecond) external onlyOwner {\n        uint256 length = tokens.length;\n\n        if(length == 0) revert Errors.EmptyArray();\n        if(length != minRewardsPerSecond.length) revert Errors.InequalArraySizes();\n\n        for(uint256 i = 0; i < length;){\n            _addRewardToken(tokens[i], minRewardsPerSecond[i]);\n\n            unchecked{ ++i; }\n        }\n    }\n\n    /**\n    * @notice Adds a given reward token to the whitelist\n    * @dev Adds a given reward token to the whitelist\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function addRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n        _addRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Updates a reward token\n    * @dev Updates a reward token\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function updateRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minAmountRewardToken[token] == 0) revert Errors.NotAllowedToken();\n        if(minRewardPerSecond == 0) revert Errors.InvalidValue();\n\n        minAmountRewardToken[token] = minRewardPerSecond;\n\n        emit UpdateRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Removes a reward token from the whitelist\n    * @dev Removes a reward token from the whitelist\n    * @param token Address of the token\n    */\n    function removeRewardToken(address token) external onlyOwner {\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minAmountRewardToken[token] == 0) revert Errors.NotAllowedToken();\n        \n        minAmountRewardToken[token] = 0;\n        \n        emit RemoveRewardToken(token);\n    }\n    \n    /**\n    * @notice Updates the Chest address\n    * @dev Updates the Chest address\n    * @param chest Address of the new Chest\n    */\n    function updateChest(address chest) external onlyOwner {\n        if(chest == address(0)) revert Errors.ZeroAddress();\n        address oldChest = chestAddress;\n        chestAddress = chest;\n\n        emit ChestUpdated(oldChest, chest);\n    }\n\n    /**\n    * @notice Updates the new min target of votes for Pledges\n    * @dev Updates the new min target of votes for Pledges\n    * @param newMinTargetVotes New minimum target of votes\n    */\n    function updateMinTargetVotes(uint256 newMinTargetVotes) external onlyOwner {\n        if(newMinTargetVotes == 0) revert Errors.InvalidValue();\n        uint256 oldMinTarget = minTargetVotes;\n        minTargetVotes = newMinTargetVotes;\n\n        emit MinTargetUpdated(oldMinTarget, newMinTargetVotes);\n    }\n\n    /**\n    * @notice Updates the Platfrom fees BPS ratio\n    * @dev Updates the Platfrom fees BPS ratio\n    * @param newFee New fee ratio\n    */\n    function updatePlatformFee(uint256 newFee) external onlyOwner {\n        if(newFee > 500) revert Errors.InvalidValue();\n        uint256 oldfee = protocalFeeRatio;\n        protocalFeeRatio = newFee;\n\n        emit PlatformFeeUpdated(oldfee, newFee);\n    }\n\n    /**\n     * @notice Pauses the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n    * @notice Recovers ERC2O tokens sent by mistake to the contract\n    * @dev Recovers ERC2O tokens sent by mistake to the contract\n    * @param token Address tof the EC2O token\n    * @return bool: success\n    */\n    function recoverERC20(address token) external onlyOwner returns(bool) {\n        if(minAmountRewardToken[token] != 0) revert Errors.CannotRecoverToken();\n\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        if(amount == 0) revert Errors.NullValue();\n        IERC20(token).safeTransfer(owner(), amount);\n\n        return true;\n    }\n\n    // Utils \n\n    function safe64(uint256 n) internal pure returns (uint64) {\n        if(n > type(uint64).max) revert Errors.NumberExceed64Bits();\n        return uint64(n);\n    }\n\n\n}\n\n",
        "CodeNames": [
            "WardenPledge.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "extendPledge and increasePledgeRewardPerVote functions in WardenPledge.sol",
                "Type": "Calculation Error",
                "Description": "Total reward amount in extendPledge and increasePledgeRewardPerVote can be calculated incorrectly due to cached pledgeParams.votesDifference, which can lead to over- or undercounting of rewards and failure to reach pledge target.",
                "Repair": "Update votesDifference when extending a pledge or increasing a pledge reward per vote"
            },
            {
                "Location": "WardenPledge contract, pause() function",
                "Type": "Pausing contract vulnerability",
                "Description": "Pausing the WardenPledge contract by its owner can unexpectedly block pledge creator from calling closePledge or retrievePledgeRewards function, which can cause disputes with the protocol and degrade user experience.",
                "Repair": "Making the pause() function only callable by a timelock governance contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./oz/interfaces/IERC20.sol\";\nimport \"./oz/libraries/SafeERC20.sol\";\nimport \"./utils/Owner.sol\";\nimport \"./oz/utils/Pausable.sol\";\nimport \"./oz/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IBoostV2.sol\";\nimport \"./utils/Errors.sol\";\n\n/** @title Warden Pledge contract */\n/// @author Paladin\n/*\n    Delegation market (Pledge version) based on Curve Boost V2 contract\n*/\ncontract WardenPledge is Ownable, Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // Constants :\n    uint256 public constant UNIT = 1e18;\n    uint256 public constant MAX_PCT = 10000;\n    uint256 public constant WEEK = 7 * 86400;\n\n    // Storage :\n\n    struct Pledge{\n        // Target amount of veCRV (balance scaled by Boost v2, fetched as adjusted_balance)\n        uint256 targetVotes;\n        // Difference of votes between the target and the receiver balance at the start of the Pledge\n        // (used for later extend/increase of some parameters the Pledge)\n        uint256 votesDifference;\n        // Price per vote per second, set by the owner\n        uint256 rewardPerVote;\n        // Address to receive the Boosts\n        address receiver;\n        // Address of the token given as rewards to Boosters\n        address rewardToken;\n        // Timestamp of end of the Pledge\n        uint64 endTimestamp;\n        // Set to true if the Pledge is canceled, or when closed after the endTimestamp\n        bool closed;\n    }\n\n    /** @notice List of all Pledges */\n    Pledge[] public pledges;\n\n    /** @notice Owner of each Pledge (ordered by index in the pledges list) */\n    mapping(uint256 => address) public pledgeOwner;\n    /** @notice List of all Pledges for each owner */\n    mapping(address => uint256[]) public ownerPledges;\n\n    /** @notice Amount of rewards available for each Pledge */\n    // sorted by Pledge index\n    mapping(uint256 => uint256) public pledgeAvailableRewardAmounts;\n\n\n    /** @notice Address of the votingToken to delegate */\n    IVotingEscrow public votingEscrow;\n    /** @notice Address of the Delegation Boost contract */\n    IBoostV2 public delegationBoost;\n\n\n    /** @notice Minimum amount of reward per vote for each reward token */\n    // Also used to whitelist the tokens for rewards\n    mapping(address => uint256) public minAmountRewardToken;\n\n\n    /** @notice ratio of fees to pay the protocol (in BPS) */\n    uint256 public protocalFeeRatio = 250; //bps\n    /** @notice Address to receive protocol fees */\n    address public chestAddress;\n\n    /** @notice Minimum target of votes for a Pledge */\n    uint256 public minTargetVotes;\n\n    /** @notice Minimum delegation time, taken from veBoost contract */\n    uint256 public minDelegationTime = 1 weeks;\n\n\n    // Events\n\n    /** @notice Event emitted when xx */\n    event NewPledge(\n        address creator,\n        address receiver,\n        address rewardToken,\n        uint256 targetVotes,\n        uint256 rewardPerVote,\n        uint256 endTimestamp\n    );\n    /** @notice Event emitted when xx */\n    event ExtendPledgeDuration(uint256 indexed pledgeId, uint256 oldEndTimestamp, uint256 newEndTimestamp);\n    /** @notice Event emitted when xx */\n    event IncreasePledgeTargetVotes(uint256 indexed pledgeId, uint256 oldTargetVotes, uint256 newTargetVotes);\n    /** @notice Event emitted when xx */\n    event IncreasePledgeRewardPerVote(uint256 indexed pledgeId, uint256 oldRewardPerVote, uint256 newRewardPerVote);\n    /** @notice Event emitted when xx */\n    event ClosePledge(uint256 indexed pledgeId);\n    /** @notice Event emitted when xx */\n    event RetrievedPledgeRewards(uint256 indexed pledgeId, address receiver, uint256 amount);\n\n    /** @notice Event emitted when xx */\n    event Pledged(uint256 indexed pledgeId, address indexed user, uint256 amount, uint256 endTimestamp);\n\n    /** @notice Event emitted when xx */\n    event NewRewardToken(address indexed token, uint256 minRewardPerSecond);\n    /** @notice Event emitted when xx */\n    event UpdateRewardToken(address indexed token, uint256 minRewardPerSecond);\n    /** @notice Event emitted when xx */\n    event RemoveRewardToken(address indexed token);\n\n    /** @notice Event emitted when xx */\n    event ChestUpdated(address oldChest, address newChest);\n    /** @notice Event emitted when xx */\n    event PlatformFeeUpdated(uint256 oldfee, uint256 newFee);\n    /** @notice Event emitted when xx */\n    event MinTargetUpdated(uint256 oldMinTarget, uint256 newMinTargetVotes);\n\n\n\n    // Constructor\n\n    /**\n    * @dev Creates the contract, set the given base parameters\n    * @param _votingEscrow address of the voting token to delegate\n    * @param _delegationBoost address of the contract handling delegation\n    * @param _minTargetVotes min amount of veToken to target in a Pledge\n    */\n    constructor(\n        address _votingEscrow,\n        address _delegationBoost,\n        address _chestAddress,\n        uint256 _minTargetVotes\n    ) {\n        votingEscrow = IVotingEscrow(_votingEscrow);\n        delegationBoost = IBoostV2(_delegationBoost);\n\n        chestAddress = _chestAddress;\n\n        minTargetVotes = _minTargetVotes;\n    }\n\n    \n    // View Methods\n\n    /**\n    * @notice Amount of Pledges listed in this contract\n    * @dev Amount of Pledges listed in this contract\n    * @return uint256: Amount of Pledges listed in this contract\n    */\n    function pledgesIndex() public view returns(uint256){\n        return pledges.length;\n    }\n\n    /**\n    * @notice Get all Pledges created by the user\n    * @dev Get all Pledges created by the user\n    * @param user Address of the user\n    * @return uint256[]: List of Pledges IDs\n    */\n    function getUserPledges(address user) external view returns(uint256[] memory){\n        return ownerPledges[user];\n    }\n\n    /**\n    * @notice Get all the Pledges\n    * @dev Get all the Pledges\n    * @return Pledge[]: List of Pledge structs\n    */\n    function getAllPledges() external view returns(Pledge[] memory){\n        return pledges;\n    }\n\n    /**\n    * @dev Rounds down given timestamp to weekly periods\n    * @param timestamp timestamp to round down\n    * @return uint256: rounded down timestamp\n    */\n    function _getRoundedTimestamp(uint256 timestamp) internal pure returns(uint256) {\n        return (timestamp / WEEK) * WEEK;\n    }\n\n\n    // Pledgers Methods\n\n    /**\n    * @notice Delegates boost to a given Pledge & receive rewards\n    * @dev Delegates boost to a given Pledge & receive rewards\n    * @param pledgeId Pledge to delegate to\n    * @param amount Amount to delegate\n    * @param endTimestamp End of delegation\n    */\n    function pledge(uint256 pledgeId, uint256 amount, uint256 endTimestamp) external whenNotPaused nonReentrant {\n        _pledge(pledgeId, msg.sender, amount, endTimestamp);\n    }\n\n    /**\n    * @notice Delegates boost (using a percentage of the balance) to a given Pledge & receive rewards\n    * @dev Delegates boost (using a percentage of the balance) to a given Pledge & receive rewards\n    * @param pledgeId Pledge to delegate to\n    * @param percent Percent of balance to delegate\n    * @param endTimestamp End of delegation\n    */\n    function pledgePercent(uint256 pledgeId, uint256 percent, uint256 endTimestamp) external whenNotPaused nonReentrant {\n        if(percent > MAX_PCT) revert Errors.PercentOverMax();\n\n        uint256 amount = (votingEscrow.balanceOf(msg.sender) * percent) / MAX_PCT;\n\n        _pledge(pledgeId, msg.sender, amount, endTimestamp);\n        \n    }\n\n    /**\n    * @dev Delegates the boost to the Pledge receiver & sends rewards to the delegator\n    * @param pledgeId Pledge to delegate to\n    * @param user Address of the delegator\n    * @param amount Amount to delegate\n    * @param endTimestamp End of delegation\n    */\n    function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        if(amount == 0) revert Errors.NullValue();\n\n        // Load Pledge parameters & check the Pledge is still active\n        Pledge memory pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        // To join until the end of the pledge, user can input 0 as endTimestamp\n        // so it's override by the Pledge's endTimestamp\n        if(endTimestamp == 0) endTimestamp = pledgeParams.endTimestamp;\n        if(endTimestamp > pledgeParams.endTimestamp || endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n\n        // Calculated the effective Pledge duration\n        uint256 boostDuration = endTimestamp - block.timestamp;\n\n        // Check that the user has enough boost delegation available & set the correct allowance to this contract\n        delegationBoost.checkpoint_user(user);\n        if(delegationBoost.allowance(user, address(this)) < amount) revert Errors.InsufficientAllowance();\n        if(delegationBoost.delegable_balance(user) < amount) revert Errors.CannotDelegate();\n\n        // Check that this will not go over the Pledge target of votes\n        if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();\n\n        // Creates the DelegationBoost\n        delegationBoost.boost(\n            pledgeParams.receiver,\n            amount,\n            endTimestamp,\n            user\n        );\n\n        // Re-calculate the new Boost bias & slope (using Boostv2 logic)\n        uint256 slope = amount / boostDuration;\n        uint256 bias = slope * boostDuration;\n\n        // Rewards are set in the Pledge as reward/veToken/sec\n        // To find the total amount of veToken delegated through the whole Boost duration\n        // based on the Boost bias & the Boost duration, to take in account that the delegated amount decreases\n        // each second of the Boost duration\n        uint256 totalDelegatedAmount = ((bias * boostDuration) + bias) / 2;\n        // Then we can calculate the total amount of rewards for this Boost\n        uint256 rewardAmount = (totalDelegatedAmount * pledgeParams.rewardPerVote) / UNIT;\n\n        if(rewardAmount > pledgeAvailableRewardAmounts[pledgeId]) revert Errors.RewardsBalanceTooLow();\n        pledgeAvailableRewardAmounts[pledgeId] -= rewardAmount;\n\n        // Send the rewards to the user\n        IERC20(pledgeParams.rewardToken).safeTransfer(user, rewardAmount);\n\n        emit Pledged(pledgeId, user, amount, endTimestamp);\n    }\n\n\n    // Pledge Creators Methods\n\n    struct CreatePledgeVars {\n        uint256 duration;\n        uint256 votesDifference;\n        uint256 totalRewardAmount;\n        uint256 feeAmount;\n        uint256 newPledgeID;\n    }\n\n    /**\n    * @notice Creates a new Pledge\n    * @dev Creates a new Pledge\n    * @param receiver Address to receive the boost delegation\n    * @param rewardToken Address of the token distributed as reward\n    * @param targetVotes Maximum taget of votes to have (own balacne + delegation) for the receiver\n    * @param rewardPerVote Amount of reward given for each vote delegation (per second)\n    * @param endTimestamp End of the Pledge\n    * @param maxTotalRewardAmount Maximum total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum feeamount allowed ot be pulled by this contract\n    * @return uint256: Newly created Pledge ID\n    */\n    function createPledge(\n        address receiver,\n        address rewardToken,\n        uint256 targetVotes,\n        uint256 rewardPerVote, // reward/veToken/second\n        uint256 endTimestamp,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant returns(uint256){\n        address creator = msg.sender;\n\n        if(receiver == address(0) || rewardToken == address(0)) revert Errors.ZeroAddress();\n        if(targetVotes < minTargetVotes) revert Errors.TargetVoteUnderMin();\n        if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted();\n        if(rewardPerVote < minAmountRewardToken[rewardToken]) revert Errors.RewardPerVoteTooLow();\n\n        if(endTimestamp == 0) revert Errors.NullEndTimestamp();\n        if(endTimestamp != _getRoundedTimestamp(endTimestamp)) revert Errors.InvalidEndTimestamp();\n\n        CreatePledgeVars memory vars;\n        vars.duration = endTimestamp - block.timestamp;\n        if(vars.duration < minDelegationTime) revert Errors.DurationTooShort();\n\n        // Get the missing votes for the given receiver to reach the target votes\n        // We ignore any delegated boost here because they might expire during the Pledge duration\n        // (we can have a future version of this contract using adjusted_balance)\n        vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);\n\n        vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;\n        vars.feeAmount = (vars.totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(vars.totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(vars.feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n        // Pull all the rewards in this contract\n        IERC20(rewardToken).safeTransferFrom(creator, address(this), vars.totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(rewardToken).safeTransferFrom(creator, chestAddress, vars.feeAmount);\n\n        vars.newPledgeID = pledgesIndex();\n\n        // Add the total reards as available for the Pledge & write Pledge parameters in storage\n        pledgeAvailableRewardAmounts[vars.newPledgeID] += vars.totalRewardAmount;\n\n        pledges.push(Pledge(\n            targetVotes,\n            vars.votesDifference,\n            rewardPerVote,\n            receiver,\n            rewardToken,\n            safe64(endTimestamp),\n            false\n        ));\n\n        pledgeOwner[vars.newPledgeID] = creator;\n        ownerPledges[creator].push(vars.newPledgeID);\n\n        emit NewPledge(creator, receiver, rewardToken, targetVotes, rewardPerVote, endTimestamp);\n\n        return vars.newPledgeID;\n    }\n\n    /**\n    * @notice Extends the Pledge duration\n    * @dev Extends the Pledge duration & add rewards for that new duration\n    * @param pledgeId ID of the Pledge\n    * @param newEndTimestamp New end of the Pledge\n    * @param maxTotalRewardAmount Maximum added total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum fee amount allowed ot be pulled by this contract\n    */\n    function extendPledge(\n        uint256 pledgeId,\n        uint256 newEndTimestamp,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n        if(newEndTimestamp == 0) revert Errors.NullEndTimestamp();\n        uint256 oldEndTimestamp = pledgeParams.endTimestamp;\n        if(newEndTimestamp != _getRoundedTimestamp(newEndTimestamp) || newEndTimestamp < oldEndTimestamp) revert Errors.InvalidEndTimestamp();\n\n        uint256 addedDuration = newEndTimestamp - oldEndTimestamp;\n        if(addedDuration < minDelegationTime) revert Errors.DurationTooShort();\n        uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;\n        uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n\n        // Pull all the rewards in this contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, address(this), totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, chestAddress, feeAmount);\n\n        // Update the Pledge parameters in storage\n        pledgeParams.endTimestamp = safe64(newEndTimestamp);\n\n        pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;\n\n        emit ExtendPledgeDuration(pledgeId, oldEndTimestamp, newEndTimestamp);\n    }\n\n    /**\n    * @notice Increases the Pledge reward per vote delegated\n    * @dev Increases the Pledge reward per vote delegated & add rewards for that new duration\n    * @param pledgeId ID of the Pledge\n    * @param newRewardPerVote New amount of reward given for each vote delegation (per second)\n    * @param maxTotalRewardAmount Maximum added total reward amount allowed ot be pulled by this contract\n    * @param maxFeeAmount Maximum fee amount allowed ot be pulled by this contract\n    */\n    function increasePledgeRewardPerVote(\n        uint256 pledgeId,\n        uint256 newRewardPerVote,\n        uint256 maxTotalRewardAmount,\n        uint256 maxFeeAmount\n    ) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        uint256 oldRewardPerVote = pledgeParams.rewardPerVote;\n        if(newRewardPerVote <= oldRewardPerVote) revert Errors.RewardsPerVotesTooLow();\n        uint256 remainingDuration = pledgeParams.endTimestamp - block.timestamp;\n        uint256 rewardPerVoteDiff = newRewardPerVote - oldRewardPerVote;\n        uint256 totalRewardAmount = (rewardPerVoteDiff * pledgeParams.votesDifference * remainingDuration) / UNIT;\n        uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;\n        if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();\n        if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();\n\n        // Pull all the rewards in this contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, address(this), totalRewardAmount);\n        // And transfer the fees from the Pledge creator to the Chest contract\n        IERC20(pledgeParams.rewardToken).safeTransferFrom(creator, chestAddress, feeAmount);\n\n        // Update the Pledge parameters in storage\n        pledgeParams.rewardPerVote = newRewardPerVote;\n\n        pledgeAvailableRewardAmounts[pledgeId] += totalRewardAmount;\n\n        emit IncreasePledgeRewardPerVote(pledgeId, oldRewardPerVote, newRewardPerVote);\n    }\n\n    /**\n    * @notice Retrieves all non distributed rewards from a closed Pledge\n    * @dev Retrieves all non distributed rewards from a closed Pledge & send them to the given receiver\n    * @param pledgeId ID fo the Pledge\n    * @param receiver Address to receive the remaining rewards\n    */\n    function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n        if(receiver == address(0)) revert Errors.ZeroAddress();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.endTimestamp > block.timestamp) revert Errors.PledgeNotExpired();\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        // Set the Pledge as Closed\n        if(!pledgeParams.closed) pledgeParams.closed = true;\n\n        if(remainingAmount > 0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);\n\n        }\n    }\n\n    /**\n    * @notice Closes a Pledge and retrieves all non distributed rewards from a Pledge\n    * @dev Closes a Pledge and retrieves all non distributed rewards from a Pledge & send them to the given receiver\n    * @param pledgeId ID fo the Pledge to close\n    * @param receiver Address to receive the remaining rewards\n    */\n    function closePledge(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {\n        if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();\n        address creator = pledgeOwner[pledgeId];\n        if(msg.sender != creator) revert Errors.NotPledgeCreator();\n        if(receiver == address(0)) revert Errors.ZeroAddress();\n\n        Pledge storage pledgeParams = pledges[pledgeId];\n        if(pledgeParams.closed) revert Errors.PledgeAlreadyClosed();\n        if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();\n\n        // Set the Pledge as Closed\n        pledgeParams.closed = true;\n\n        // Get the current remaining amount of rewards not distributed for the Pledge\n        uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];\n\n        if(remainingAmount > 0) {\n            // Transfer the non used rewards and reset storage\n            pledgeAvailableRewardAmounts[pledgeId] = 0;\n\n            IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);\n\n            emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);\n\n        }\n\n        emit ClosePledge(pledgeId);\n    }\n\n\n    // Admin Methods\n\n    /**\n    * @dev Adds a given reward token to the whitelist\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function _addRewardToken(address token, uint256 minRewardPerSecond) internal {\n        if(minAmountRewardToken[token] != 0) revert Errors.AlreadyAllowedToken();\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minRewardPerSecond == 0) revert Errors.NullValue();\n        \n        minAmountRewardToken[token] = minRewardPerSecond;\n\n        emit NewRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Adds a given reward token to the whitelist\n    * @dev Adds a given reward token to the whitelist\n    * @param tokens List of token addresses to add\n    * @param minRewardsPerSecond Minmum amount of reward per vote per second for each token in the list\n    */\n    function addMultipleRewardToken(address[] calldata tokens, uint256[] calldata minRewardsPerSecond) external onlyOwner {\n        uint256 length = tokens.length;\n\n        if(length == 0) revert Errors.EmptyArray();\n        if(length != minRewardsPerSecond.length) revert Errors.InequalArraySizes();\n\n        for(uint256 i = 0; i < length;){\n            _addRewardToken(tokens[i], minRewardsPerSecond[i]);\n\n            unchecked{ ++i; }\n        }\n    }\n\n    /**\n    * @notice Adds a given reward token to the whitelist\n    * @dev Adds a given reward token to the whitelist\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function addRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n        _addRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Updates a reward token\n    * @dev Updates a reward token\n    * @param token Address of the token\n    * @param minRewardPerSecond Minmum amount of reward per vote per second for the token\n    */\n    function updateRewardToken(address token, uint256 minRewardPerSecond) external onlyOwner {\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minAmountRewardToken[token] == 0) revert Errors.NotAllowedToken();\n        if(minRewardPerSecond == 0) revert Errors.InvalidValue();\n\n        minAmountRewardToken[token] = minRewardPerSecond;\n\n        emit UpdateRewardToken(token, minRewardPerSecond);\n    }\n\n    /**\n    * @notice Removes a reward token from the whitelist\n    * @dev Removes a reward token from the whitelist\n    * @param token Address of the token\n    */\n    function removeRewardToken(address token) external onlyOwner {\n        if(token == address(0)) revert Errors.ZeroAddress();\n        if(minAmountRewardToken[token] == 0) revert Errors.NotAllowedToken();\n        \n        minAmountRewardToken[token] = 0;\n        \n        emit RemoveRewardToken(token);\n    }\n    \n    /**\n    * @notice Updates the Chest address\n    * @dev Updates the Chest address\n    * @param chest Address of the new Chest\n    */\n    function updateChest(address chest) external onlyOwner {\n        if(chest == address(0)) revert Errors.ZeroAddress();\n        address oldChest = chestAddress;\n        chestAddress = chest;\n\n        emit ChestUpdated(oldChest, chest);\n    }\n\n    /**\n    * @notice Updates the new min target of votes for Pledges\n    * @dev Updates the new min target of votes for Pledges\n    * @param newMinTargetVotes New minimum target of votes\n    */\n    function updateMinTargetVotes(uint256 newMinTargetVotes) external onlyOwner {\n        if(newMinTargetVotes == 0) revert Errors.InvalidValue();\n        uint256 oldMinTarget = minTargetVotes;\n        minTargetVotes = newMinTargetVotes;\n\n        emit MinTargetUpdated(oldMinTarget, newMinTargetVotes);\n    }\n\n    /**\n    * @notice Updates the Platfrom fees BPS ratio\n    * @dev Updates the Platfrom fees BPS ratio\n    * @param newFee New fee ratio\n    */\n    function updatePlatformFee(uint256 newFee) external onlyOwner {\n        if(newFee > 500) revert Errors.InvalidValue();\n        uint256 oldfee = protocalFeeRatio;\n        protocalFeeRatio = newFee;\n\n        emit PlatformFeeUpdated(oldfee, newFee);\n    }\n\n    /**\n     * @notice Pauses the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n    * @notice Recovers ERC2O tokens sent by mistake to the contract\n    * @dev Recovers ERC2O tokens sent by mistake to the contract\n    * @param token Address tof the EC2O token\n    * @return bool: success\n    */\n    function recoverERC20(address token) external onlyOwner returns(bool) {\n        if(minAmountRewardToken[token] != 0) revert Errors.CannotRecoverToken();\n\n        uint256 amount = IERC20(token).balanceOf(address(this));\n        if(amount == 0) revert Errors.NullValue();\n        IERC20(token).safeTransfer(owner(), amount);\n\n        return true;\n    }\n\n    // Utils \n\n    function safe64(uint256 n) internal pure returns (uint64) {\n        if(n > type(uint64).max) revert Errors.NumberExceed64Bits();\n        return uint64(n);\n    }\n\n\n}\n\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n",
        "CodeNames": [
            "WardenPledge.sol",
            "Ownable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "contract WardenPledge is Ownable",
                "Type": "Inheritance-related vulnerability",
                "Description": "WardenPledge accidentally inherits Ownable instead of Owner which removes an important safeguard without sponsor knowledge.",
                "Repair": "Change the inheritance to the intended contract (Owner)"
            }
        ]
    }
]