[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./ICoreRef.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\n/// @title A Reference to Core\n/// @author Fei Protocol\n/// @notice defines some modifiers and utilities around interacting with Core\nabstract contract CoreRef is ICoreRef, Pausable {\n    ICore private immutable _core;\n    IVolt private immutable _volt;\n    IERC20 private immutable _vcon;\n\n    /// @notice a role used with a subset of governor permissions for this contract only\n    bytes32 public override CONTRACT_ADMIN_ROLE;\n\n    constructor(address coreAddress) {\n        _core = ICore(coreAddress);\n\n        _volt = ICore(coreAddress).volt();\n        _vcon = ICore(coreAddress).vcon();\n\n        _setContractAdminRole(ICore(coreAddress).GOVERN_ROLE());\n    }\n\n    function _initialize() internal {} // no-op for backward compatibility\n\n    modifier ifMinterSelf() {\n        if (_core.isMinter(address(this))) {\n            _;\n        }\n    }\n\n    modifier onlyMinter() {\n        require(_core.isMinter(msg.sender), \"CoreRef: Caller is not a minter\");\n        _;\n    }\n\n    modifier onlyBurner() {\n        require(_core.isBurner(msg.sender), \"CoreRef: Caller is not a burner\");\n        _;\n    }\n\n    modifier onlyPCVController() {\n        require(\n            _core.isPCVController(msg.sender),\n            \"CoreRef: Caller is not a PCV controller\"\n        );\n        _;\n    }\n\n    modifier onlyGovernorOrAdmin() {\n        require(\n            _core.isGovernor(msg.sender) || isContractAdmin(msg.sender),\n            \"CoreRef: Caller is not a governor or contract admin\"\n        );\n        _;\n    }\n\n    modifier onlyGovernor() {\n        require(\n            _core.isGovernor(msg.sender),\n            \"CoreRef: Caller is not a governor\"\n        );\n        _;\n    }\n\n    modifier onlyGuardianOrGovernor() {\n        require(\n            _core.isGovernor(msg.sender) || _core.isGuardian(msg.sender),\n            \"CoreRef: Caller is not a guardian or governor\"\n        );\n        _;\n    }\n\n    modifier onlyGovernorOrGuardianOrAdmin() {\n        require(\n            _core.isGovernor(msg.sender) ||\n                _core.isGuardian(msg.sender) ||\n                isContractAdmin(msg.sender),\n            \"CoreRef: Caller is not governor or guardian or admin\"\n        );\n        _;\n    }\n\n    // Named onlyTribeRole to prevent collision with OZ onlyRole modifier\n    modifier onlyTribeRole(bytes32 role) {\n        require(_core.hasRole(role, msg.sender), \"UNAUTHORIZED\");\n        _;\n    }\n\n    // Modifiers to allow any combination of roles\n    modifier hasAnyOfTwoRoles(bytes32 role1, bytes32 role2) {\n        require(\n            _core.hasRole(role1, msg.sender) ||\n                _core.hasRole(role2, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier hasAnyOfThreeRoles(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3\n    ) {\n        require(\n            _core.hasRole(role1, msg.sender) ||\n                _core.hasRole(role2, msg.sender) ||\n                _core.hasRole(role3, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier hasAnyOfFourRoles(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3,\n        bytes32 role4\n    ) {\n        require(\n            _core.hasRole(role1, msg.sender) ||\n                _core.hasRole(role2, msg.sender) ||\n                _core.hasRole(role3, msg.sender) ||\n                _core.hasRole(role4, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier hasAnyOfFiveRoles(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3,\n        bytes32 role4,\n        bytes32 role5\n    ) {\n        require(\n            _core.hasRole(role1, msg.sender) ||\n                _core.hasRole(role2, msg.sender) ||\n                _core.hasRole(role3, msg.sender) ||\n                _core.hasRole(role4, msg.sender) ||\n                _core.hasRole(role5, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier onlyVolt() {\n        require(msg.sender == address(_volt), \"CoreRef: Caller is not VOLT\");\n        _;\n    }\n\n    /// @notice sets a new admin role for this contract\n    function setContractAdminRole(bytes32 newContractAdminRole)\n        external\n        override\n        onlyGovernor\n    {\n        _setContractAdminRole(newContractAdminRole);\n    }\n\n    /// @notice returns whether a given address has the admin role for this contract\n    function isContractAdmin(address _admin)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _core.hasRole(CONTRACT_ADMIN_ROLE, _admin);\n    }\n\n    /// @notice set pausable methods to paused\n    function pause() public override onlyGuardianOrGovernor {\n        _pause();\n    }\n\n    /// @notice set pausable methods to unpaused\n    function unpause() public override onlyGuardianOrGovernor {\n        _unpause();\n    }\n\n    /// @notice address of the Core contract referenced\n    /// @return ICore implementation address\n    function core() public view override returns (ICore) {\n        return _core;\n    }\n\n    /// @notice address of the Fei contract referenced by Core\n    /// @return IFei implementation address\n    function volt() public view override returns (IVolt) {\n        return _volt;\n    }\n\n    /// @notice address of the Tribe contract referenced by Core\n    /// @return IERC20 implementation address\n    function vcon() public view override returns (IERC20) {\n        return _vcon;\n    }\n\n    /// @notice volt balance of contract\n    /// @return volt amount held\n    function voltBalance() public view override returns (uint256) {\n        return _volt.balanceOf(address(this));\n    }\n\n    /// @notice vcon balance of contract\n    /// @return vcon amount held\n    function vconBalance() public view override returns (uint256) {\n        return _vcon.balanceOf(address(this));\n    }\n\n    function _burnVoltHeld() internal {\n        _volt.burn(voltBalance());\n    }\n\n    function _mintVolt(address to, uint256 amount) internal virtual {\n        if (amount != 0) {\n            _volt.mint(to, amount);\n        }\n    }\n\n    function _setContractAdminRole(bytes32 newContractAdminRole) internal {\n        bytes32 oldContractAdminRole = CONTRACT_ADMIN_ROLE;\n        CONTRACT_ADMIN_ROLE = newContractAdminRole;\n        emit ContractAdminRoleUpdate(\n            oldContractAdminRole,\n            newContractAdminRole\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Vcon} from \"../vcon/Vcon.sol\";\nimport {IVolt, Volt, IERC20} from \"../volt/Volt.sol\";\nimport {ICore} from \"./ICore.sol\";\nimport {Permissions} from \"./Permissions.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/// @title Source of truth for VOLT Protocol\n/// @author Fei Protocol\n/// @notice maintains roles, access control, Volt, Vcon, and the Vcon treasury\ncontract Core is ICore, Permissions, Initializable {\n    /// @notice the address of the FEI contract\n    IVolt public override volt;\n\n    /// @notice the address of the Vcon contract\n    IERC20 public override vcon;\n\n    function init() external initializer {\n        volt = new Volt(address(this));\n        /// msg.sender already has the VOLT Minting abilities, so grant them governor as well\n        _setupGovernor(msg.sender);\n    }\n\n    /// @notice governor only function to set the VCON token\n    function setVcon(IERC20 _vcon) external onlyGovernor {\n        vcon = _vcon;\n\n        emit VconUpdate(_vcon);\n    }\n}\n\n\n",
        "CodeNames": [
            "CoreRef.sol",
            "Core.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Core.sol#L27, CoreRef.sol#L22, CoreRef.sol#L199",
                "Type": "vcon address not persistent",
                "Description": "vcon address is allowed to be updated by GOVERNOR in Core, however, this change will not be reflected in CoreRef._vcon.",
                "Repair": "Dynamically fetch vcon from Core whenever CoreRef uses it, and avoid storing a static copy locally or expose a public API to update _vcon in CoreRef"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"./IOracleRef.sol\";\nimport \"./CoreRef.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/// @title Reference to an Oracle\n/// @author Fei Protocol\n/// @notice defines some utilities around interacting with the referenced oracle\nabstract contract OracleRef is IOracleRef, CoreRef {\n    using Decimal for Decimal.D256;\n    using SafeCast for int256;\n\n    /// @notice the oracle reference by the contract\n    IOracle public override oracle;\n\n    /// @notice the backup oracle reference by the contract\n    IOracle public override backupOracle;\n\n    /// @notice number of decimals to scale oracle price by, i.e. multiplying by 10^(decimalsNormalizer)\n    int256 public override decimalsNormalizer;\n\n    bool public override doInvert;\n\n    /// @notice OracleRef constructor\n    /// @param _core Fei Core to reference\n    /// @param _oracle oracle to reference\n    /// @param _backupOracle backup oracle to reference\n    /// @param _decimalsNormalizer number of decimals to normalize the oracle feed if necessary\n    /// @param _doInvert invert the oracle price if this flag is on\n    constructor(\n        address _core,\n        address _oracle,\n        address _backupOracle,\n        int256 _decimalsNormalizer,\n        bool _doInvert\n    ) CoreRef(_core) {\n        _setOracle(_oracle);\n        if (_backupOracle != address(0) && _backupOracle != _oracle) {\n            _setBackupOracle(_backupOracle);\n        }\n        _setDoInvert(_doInvert);\n        _setDecimalsNormalizer(_decimalsNormalizer);\n    }\n\n    /// @notice sets the referenced oracle\n    /// @param newOracle the new oracle to reference\n    function setOracle(address newOracle) external override onlyGovernor {\n        _setOracle(newOracle);\n    }\n\n    /// @notice sets the flag for whether to invert or not\n    /// @param newDoInvert the new flag for whether to invert\n    function setDoInvert(bool newDoInvert) external override onlyGovernor {\n        _setDoInvert(newDoInvert);\n    }\n\n    /// @notice sets the new decimalsNormalizer\n    /// @param newDecimalsNormalizer the new decimalsNormalizer\n    function setDecimalsNormalizer(int256 newDecimalsNormalizer)\n        external\n        override\n        onlyGovernor\n    {\n        _setDecimalsNormalizer(newDecimalsNormalizer);\n    }\n\n    /// @notice sets the referenced backup oracle\n    /// @param newBackupOracle the new backup oracle to reference\n    function setBackupOracle(address newBackupOracle)\n        external\n        override\n        onlyGovernorOrAdmin\n    {\n        _setBackupOracle(newBackupOracle);\n    }\n\n    /// @notice invert a peg price\n    /// @param price the peg price to invert\n    /// @return the inverted peg as a Decimal\n    /// @dev the inverted peg would be X per FEI\n    function invert(Decimal.D256 memory price)\n        public\n        pure\n        override\n        returns (Decimal.D256 memory)\n    {\n        return Decimal.one().div(price);\n    }\n\n    /// @notice updates the referenced oracle\n    function updateOracle() public override {\n        oracle.update();\n    }\n\n    /// @notice the peg price of the referenced oracle\n    /// @return the peg as a Decimal\n    /// @dev the peg is defined as FEI per X with X being ETH, dollars, etc\n    function readOracle() public view override returns (Decimal.D256 memory) {\n        (Decimal.D256 memory _peg, bool valid) = oracle.read();\n        if (!valid && address(backupOracle) != address(0)) {\n            (_peg, valid) = backupOracle.read();\n        }\n        require(valid, \"OracleRef: oracle invalid\");\n\n        // Scale the oracle price by token decimals delta if necessary\n        uint256 scalingFactor;\n        if (decimalsNormalizer < 0) {\n            scalingFactor = 10**(-1 * decimalsNormalizer).toUint256();\n            _peg = _peg.div(scalingFactor);\n        } else {\n            scalingFactor = 10**decimalsNormalizer.toUint256();\n            _peg = _peg.mul(scalingFactor);\n        }\n\n        // Invert the oracle price if necessary\n        if (doInvert) {\n            _peg = invert(_peg);\n        }\n        return _peg;\n    }\n\n    function _setOracle(address newOracle) internal {\n        require(newOracle != address(0), \"OracleRef: zero address\");\n        address oldOracle = address(oracle);\n        oracle = IOracle(newOracle);\n        emit OracleUpdate(oldOracle, newOracle);\n    }\n\n    // Supports zero address if no backup\n    function _setBackupOracle(address newBackupOracle) internal {\n        address oldBackupOracle = address(backupOracle);\n        backupOracle = IOracle(newBackupOracle);\n        emit BackupOracleUpdate(oldBackupOracle, newBackupOracle);\n    }\n\n    function _setDoInvert(bool newDoInvert) internal {\n        bool oldDoInvert = doInvert;\n        doInvert = newDoInvert;\n\n        if (oldDoInvert != newDoInvert) {\n            _setDecimalsNormalizer(-1 * decimalsNormalizer);\n        }\n\n        emit InvertUpdate(oldDoInvert, newDoInvert);\n    }\n\n    function _setDecimalsNormalizer(int256 newDecimalsNormalizer) internal {\n        int256 oldDecimalsNormalizer = decimalsNormalizer;\n        decimalsNormalizer = newDecimalsNormalizer;\n        emit DecimalsNormalizerUpdate(\n            oldDecimalsNormalizer,\n            newDecimalsNormalizer\n        );\n    }\n\n    function _setDecimalsNormalizerFromToken(address token) internal {\n        int256 feiDecimals = 18;\n        int256 _decimalsNormalizer = feiDecimals -\n            int256(uint256(IERC20Metadata(token).decimals()));\n\n        if (doInvert) {\n            _decimalsNormalizer = -1 * _decimalsNormalizer;\n        }\n\n        _setDecimalsNormalizer(_decimalsNormalizer);\n    }\n}\n\n\n",
        "CodeNames": [
            "OracleRef.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "OracleRef.sol#L104",
                "Type": "assumption of backup oracle",
                "Description": "OracleRef assumes that the backup oracle uses the same normalizer as the main oracle.",
                "Repair": "Assume that both oracles will use the same scaling factor and thus we will not need a second value for the backup oracle"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Constants} from \"./../Constants.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/// @title contract that determines whether or not a new value is within\n/// an acceptable deviation threshold\n/// @author Elliot Friedman, FEI Protocol\nlibrary Deviation {\n    using SafeCast for *;\n\n    /// @notice event that is emitted when the threshold is changed\n    event DeviationThresholdUpdate(uint256 oldThreshold, uint256 newThreshold);\n\n    /// @notice return the percent deviation between a and b in basis points terms\n    function calculateDeviationThresholdBasisPoints(int256 a, int256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        int256 delta = a - b;\n        int256 basisPoints = (delta * Constants.BP_INT) / a;\n\n        return (basisPoints < 0 ? basisPoints * -1 : basisPoints).toUint256();\n    }\n\n    /// @notice function to return whether or not the new price is within\n    /// the acceptable deviation threshold\n    function isWithinDeviationThreshold(\n        uint256 maxDeviationThresholdBasisPoints,\n        int256 oldValue,\n        int256 newValue\n    ) internal pure returns (bool) {\n        return\n            maxDeviationThresholdBasisPoints >=\n            calculateDeviationThresholdBasisPoints(oldValue, newValue);\n    }\n}\n\n\n",
        "CodeNames": [
            "Deviation.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Deviation.sol#L23",
                "Type": "division by 0",
                "Description": "Division by 0 can lead to accidentally revert.",
                "Repair": "Add protection to check if a is 0 before performing the division"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Decimal} from \"../external/Decimal.sol\";\nimport {Constants} from \"../Constants.sol\";\nimport {OracleRef} from \"./../refs/OracleRef.sol\";\nimport {TribeRoles} from \"./../core/TribeRoles.sol\";\nimport {RateLimited} from \"./../utils/RateLimited.sol\";\nimport {IPCVDeposit, PCVDeposit} from \"./../pcv/PCVDeposit.sol\";\nimport {INonCustodialPSM} from \"./INonCustodialPSM.sol\";\nimport {GlobalRateLimitedMinter} from \"./../utils/GlobalRateLimitedMinter.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @notice Peg Stability Module that holds no funds.\n/// On a mint, it transfers all proceeds to a PCV Deposit\n/// When funds are needed for a redemption, they are simply pulled from the PCV Deposit\ncontract NonCustodialPSM is\n    OracleRef,\n    RateLimited,\n    ReentrancyGuard,\n    INonCustodialPSM\n{\n    using Decimal for Decimal.D256;\n    using SafeCast for *;\n    using SafeERC20 for IERC20;\n\n    /// @notice the fee in basis points for selling an asset into VOLT\n    uint256 public override mintFeeBasisPoints;\n\n    /// @notice the fee in basis points for buying the asset for VOLT\n    uint256 public override redeemFeeBasisPoints;\n\n    /// @notice the PCV deposit target to deposit and withdraw from\n    IPCVDeposit public override pcvDeposit;\n\n    /// @notice the token this PSM will exchange for VOLT\n    /// Must be a stable token pegged to $1\n    IERC20 public immutable override underlyingToken;\n\n    /// @notice Rate Limited Minter contract that will be called when VOLT needs to be minted\n    GlobalRateLimitedMinter public override rateLimitedMinter;\n\n    /// @notice the max mint and redeem fee in basis points\n    /// Governance cannot change the maximum fee\n    uint256 public immutable override MAX_FEE = 300;\n\n    /// @notice boolean switch that indicates whether redeeming is paused\n    bool public redeemPaused;\n\n    /// @notice boolean switch that indicates whether minting is paused\n    bool public mintPaused;\n\n    /// @notice struct for passing constructor parameters related to OracleRef\n    struct OracleParams {\n        address coreAddress;\n        address oracleAddress;\n        address backupOracle;\n        int256 decimalsNormalizer;\n    }\n\n    /// @notice struct for passing constructor parameters related to MultiRateLimited\n    struct RateLimitedParams {\n        uint256 maxRateLimitPerSecond;\n        uint256 rateLimitPerSecond;\n        uint256 bufferCap;\n    }\n\n    /// @notice struct for passing constructor parameters related to the non custodial PSM\n    struct PSMParams {\n        uint256 mintFeeBasisPoints;\n        uint256 redeemFeeBasisPoints;\n        IERC20 underlyingToken;\n        IPCVDeposit pcvDeposit;\n        GlobalRateLimitedMinter rateLimitedMinter;\n    }\n\n    /// @notice construct the non custodial PSM. Structs are used to prevent stack too deep errors\n    /// @param params oracle ref constructor data\n    /// @param rateLimitedParams rate limited constructor data\n    /// @param psmParams non custodial PSM constructor data\n    constructor(\n        OracleParams memory params,\n        RateLimitedParams memory rateLimitedParams,\n        PSMParams memory psmParams\n    )\n        OracleRef(\n            params.coreAddress,\n            params.oracleAddress,\n            params.backupOracle,\n            params.decimalsNormalizer,\n            true /// hardcode doInvert to true to allow swaps to work correctly\n        )\n        /// rate limited replenishable passes false as the last param as there can be no partial actions\n        RateLimited(\n            rateLimitedParams.maxRateLimitPerSecond,\n            rateLimitedParams.rateLimitPerSecond,\n            rateLimitedParams.bufferCap,\n            false\n        )\n    {\n        underlyingToken = psmParams.underlyingToken;\n\n        _setGlobalRateLimitedMinter(psmParams.rateLimitedMinter);\n        _setMintFee(psmParams.mintFeeBasisPoints);\n        _setRedeemFee(psmParams.redeemFeeBasisPoints);\n        _setPCVDeposit(psmParams.pcvDeposit);\n    }\n\n    // ----------- Mint & Redeem pausing modifiers -----------\n\n    /// @notice modifier that allows execution when redemptions are not paused\n    modifier whileRedemptionsNotPaused() {\n        require(!redeemPaused, \"PegStabilityModule: Redeem paused\");\n        _;\n    }\n\n    /// @notice modifier that allows execution when minting is not paused\n    modifier whileMintingNotPaused() {\n        require(!mintPaused, \"PegStabilityModule: Minting paused\");\n        _;\n    }\n\n    // ----------- Governor & Guardian only pausing api -----------\n\n    /// @notice set secondary pausable methods to paused\n    function pauseRedeem() external onlyGuardianOrGovernor {\n        redeemPaused = true;\n        emit RedemptionsPaused(msg.sender);\n    }\n\n    /// @notice set secondary pausable methods to unpaused\n    function unpauseRedeem() external onlyGuardianOrGovernor {\n        redeemPaused = false;\n        emit RedemptionsUnpaused(msg.sender);\n    }\n\n    /// @notice set secondary pausable methods to paused\n    function pauseMint() external onlyGuardianOrGovernor {\n        mintPaused = true;\n        emit MintingPaused(msg.sender);\n    }\n\n    /// @notice set secondary pausable methods to unpaused\n    function unpauseMint() external onlyGuardianOrGovernor {\n        mintPaused = false;\n        emit MintingUnpaused(msg.sender);\n    }\n\n    // ----------- Governor, psm admin and parameter admin only state changing api -----------\n\n    /// @notice set the mint fee vs oracle price in basis point terms\n    /// @param newMintFeeBasisPoints the new fee in basis points for minting\n    function setMintFee(uint256 newMintFeeBasisPoints)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PARAMETER_ADMIN)\n    {\n        _setMintFee(newMintFeeBasisPoints);\n    }\n\n    /// @notice set the redemption fee vs oracle price in basis point terms\n    /// @param newRedeemFeeBasisPoints the new fee in basis points for redemptions\n    function setRedeemFee(uint256 newRedeemFeeBasisPoints)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PARAMETER_ADMIN)\n    {\n        _setRedeemFee(newRedeemFeeBasisPoints);\n    }\n\n    /// @notice set the target for sending all PCV\n    /// @param newTarget new PCV Deposit target for this PSM\n    function setPCVDeposit(IPCVDeposit newTarget)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PSM_ADMIN_ROLE)\n    {\n        _setPCVDeposit(newTarget);\n    }\n\n    /// @notice set the target to call for VOLT minting\n    /// @param newMinter new Global Rate Limited Minter for this PSM\n    function setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)\n        external\n        override\n        hasAnyOfTwoRoles(TribeRoles.GOVERNOR, TribeRoles.PSM_ADMIN_ROLE)\n    {\n        _setGlobalRateLimitedMinter(newMinter);\n    }\n\n    // ----------- PCV Controller only state changing api -----------\n\n    /// @notice withdraw ERC20 from the contract\n    /// @param token address of the ERC20 to send\n    /// @param to address destination of the ERC20\n    /// @param amount quantity of ERC20 to send\n    function withdrawERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyPCVController {\n        IERC20(token).safeTransfer(to, amount);\n        emit WithdrawERC20(msg.sender, token, to, amount);\n    }\n\n    // ----------- Public State Changing API -----------\n\n    /// @notice function to redeem VOLT for an underlying asset\n    /// We do not burn VOLT; this allows the contract's balance of VOLT to be used before the buffer is used\n    /// In practice, this helps prevent artificial cycling of mint-burn cycles and prevents DOS attacks.\n    /// This function will deplete the buffer based on the amount of VOLT that is being redeemed.\n    /// @param to the destination address for proceeds\n    /// @param amountVoltIn the amount of VOLT to sell\n    /// @param minAmountOut the minimum amount out otherwise the TX will fail\n    function redeem(\n        address to,\n        uint256 amountVoltIn,\n        uint256 minAmountOut\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        whileRedemptionsNotPaused\n        returns (uint256 amountOut)\n    {\n        _depleteBuffer(amountVoltIn); /// deplete buffer first to save gas on buffer exhaustion sad path\n\n        updateOracle();\n\n        amountOut = _getRedeemAmountOut(amountVoltIn);\n        require(\n            amountOut >= minAmountOut,\n            \"PegStabilityModule: Redeem not enough out\"\n        );\n\n        IERC20(volt()).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amountVoltIn\n        );\n\n        pcvDeposit.withdraw(to, amountOut);\n\n        emit Redeem(to, amountVoltIn, amountOut);\n    }\n\n    /// @notice function to buy VOLT for an underlying asset that is pegged to $1\n    /// We first transfer any contract-owned VOLT, then mint the remaining if necessary\n    /// This function will replenish the buffer based on the amount of VOLT that is being sent out.\n    /// @param to the destination address for proceeds\n    /// @param amountIn the amount of external asset to sell to the PSM\n    /// @param minVoltAmountOut the minimum amount of VOLT out otherwise the TX will fail\n    function mint(\n        address to,\n        uint256 amountIn,\n        uint256 minVoltAmountOut\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        whileMintingNotPaused\n        returns (uint256 amountVoltOut)\n    {\n        updateOracle();\n\n        amountVoltOut = _getMintAmountOut(amountIn);\n        require(\n            amountVoltOut >= minVoltAmountOut,\n            \"PegStabilityModule: Mint not enough out\"\n        );\n\n        underlyingToken.safeTransferFrom(\n            msg.sender,\n            address(pcvDeposit),\n            amountIn\n        );\n\n        uint256 amountFeiToTransfer = Math.min(\n            volt().balanceOf(address(this)),\n            amountVoltOut\n        );\n        uint256 amountFeiToMint = amountVoltOut - amountFeiToTransfer;\n\n        if (amountFeiToTransfer != 0) {\n            IERC20(volt()).safeTransfer(to, amountFeiToTransfer);\n        }\n\n        if (amountFeiToMint != 0) {\n            rateLimitedMinter.mintVolt(to, amountFeiToMint);\n        }\n\n        _replenishBuffer(amountVoltOut);\n\n        emit Mint(to, amountIn, amountVoltOut);\n    }\n\n    // ----------- Public View-Only API ----------\n\n    /// @notice calculate the amount of VOLT out for a given `amountIn` of underlying\n    /// First get oracle price of token\n    /// Then figure out how many dollars that amount in is worth by multiplying price * amount.\n    /// ensure decimals are normalized if on underlying they are not 18\n    /// @param amountIn the amount of external asset to sell to the PSM\n    /// @return amountVoltOut the amount of VOLT received for the amountIn of external asset\n    function getMintAmountOut(uint256 amountIn)\n        public\n        view\n        override\n        returns (uint256 amountVoltOut)\n    {\n        amountVoltOut = _getMintAmountOut(amountIn);\n    }\n\n    /// @notice calculate the amount of underlying out for a given `amountVoltIn` of VOLT\n    /// First get oracle price of token\n    /// Then figure out how many dollars that amount in is worth by multiplying price * amount.\n    /// ensure decimals are normalized if on underlying they are not 18\n    /// @param amountVoltIn the amount of VOLT to redeem\n    /// @return amountTokenOut the amount of the external asset received in exchange for the amount of VOLT redeemed\n    function getRedeemAmountOut(uint256 amountVoltIn)\n        public\n        view\n        override\n        returns (uint256 amountTokenOut)\n    {\n        amountTokenOut = _getRedeemAmountOut(amountVoltIn);\n    }\n\n    /// @notice getter to return the maximum amount of VOLT that could be purchased at once\n    /// @return the maximum amount of VOLT available for purchase at once through this PSM\n    function getMaxMintAmountOut() external view override returns (uint256) {\n        return\n            volt().balanceOf(address(this)) +\n            rateLimitedMinter.individualBuffer(address(this));\n    }\n\n    // ----------- Internal Methods -----------\n\n    /// @notice helper function to get mint amount out based on current market prices\n    /// @dev will revert if price is outside of bounds and price bound PSM is being used\n    /// @param amountIn the amount of stable asset in\n    /// @return amountVoltOut the amount of VOLT received for the amountIn of stable assets\n    function _getMintAmountOut(uint256 amountIn)\n        internal\n        view\n        virtual\n        returns (uint256 amountVoltOut)\n    {\n        Decimal.D256 memory price = readOracle();\n        _validatePriceRange(price);\n\n        Decimal.D256 memory adjustedAmountIn = price.mul(amountIn);\n\n        amountVoltOut = adjustedAmountIn\n            .mul(Constants.BASIS_POINTS_GRANULARITY - mintFeeBasisPoints)\n            .div(Constants.BASIS_POINTS_GRANULARITY)\n            .asUint256();\n    }\n\n    /// @notice helper function to get redeem amount out based on current market prices\n    /// @dev will revert if price is outside of bounds and price bound PSM is being used\n    /// @param amountVoltIn the amount of VOLT to redeem\n    /// @return amountTokenOut the amount of the external asset received in exchange for the amount of VOLT redeemed\n    function _getRedeemAmountOut(uint256 amountVoltIn)\n        internal\n        view\n        virtual\n        returns (uint256 amountTokenOut)\n    {\n        Decimal.D256 memory price = readOracle();\n        _validatePriceRange(price);\n\n        /// get amount of VOLT being provided being redeemed after fees\n        Decimal.D256 memory adjustedAmountIn = Decimal.from(\n            (amountVoltIn *\n                (Constants.BASIS_POINTS_GRANULARITY - redeemFeeBasisPoints)) /\n                Constants.BASIS_POINTS_GRANULARITY\n        );\n\n        /// now turn the VOLT into the underlying token amounts\n        /// amount VOLT in / VOLT you receive for $1 = how much stable token to pay out\n        amountTokenOut = adjustedAmountIn.div(price).asUint256();\n    }\n\n    // ----------- Helper methods to change state -----------\n\n    /// @notice set the global rate limited minter this PSM calls to mint VOLT\n    /// @param newMinter the new minter contract that this PSM will reference\n    function _setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)\n        internal\n    {\n        require(\n            address(newMinter) != address(0),\n            \"PegStabilityModule: Invalid new GlobalRateLimitedMinter\"\n        );\n        GlobalRateLimitedMinter oldMinter = rateLimitedMinter;\n        rateLimitedMinter = newMinter;\n\n        emit GlobalRateLimitedMinterUpdate(oldMinter, newMinter);\n    }\n\n    /// @notice set the mint fee vs oracle price in basis point terms\n    /// @param newMintFeeBasisPoints the new fee for minting in basis points\n    function _setMintFee(uint256 newMintFeeBasisPoints) internal {\n        require(\n            newMintFeeBasisPoints <= MAX_FEE,\n            \"PegStabilityModule: Mint fee exceeds max fee\"\n        );\n        uint256 _oldMintFee = mintFeeBasisPoints;\n        mintFeeBasisPoints = newMintFeeBasisPoints;\n\n        emit MintFeeUpdate(_oldMintFee, newMintFeeBasisPoints);\n    }\n\n    /// @notice internal helper function to set the redemption fee\n    /// @param newRedeemFeeBasisPoints the new fee for redemptions in basis points\n    function _setRedeemFee(uint256 newRedeemFeeBasisPoints) internal {\n        require(\n            newRedeemFeeBasisPoints <= MAX_FEE,\n            \"PegStabilityModule: Redeem fee exceeds max fee\"\n        );\n        uint256 _oldRedeemFee = redeemFeeBasisPoints;\n        redeemFeeBasisPoints = newRedeemFeeBasisPoints;\n\n        emit RedeemFeeUpdate(_oldRedeemFee, newRedeemFeeBasisPoints);\n    }\n\n    /// @notice helper function to set the PCV deposit\n    /// @param newPCVDeposit the new PCV deposit that this PSM will pull assets from and deposit assets into\n    function _setPCVDeposit(IPCVDeposit newPCVDeposit) internal {\n        require(\n            address(newPCVDeposit) != address(0),\n            \"PegStabilityModule: Invalid new PCVDeposit\"\n        );\n        require(\n            newPCVDeposit.balanceReportedIn() == address(underlyingToken),\n            \"PegStabilityModule: Underlying token mismatch\"\n        );\n        IPCVDeposit oldTarget = pcvDeposit;\n        pcvDeposit = newPCVDeposit;\n\n        emit PCVDepositUpdate(oldTarget, newPCVDeposit);\n    }\n\n    // ----------- Hooks -----------\n\n    /// @notice overriden function in the price bound PSM\n    function _validatePriceRange(Decimal.D256 memory price)\n        internal\n        view\n        virtual\n    {}\n}\n\n\n",
        "CodeNames": [
            "NonCustodialPSM.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NonCustodialPSM.sol#L236-L248",
                "Type": "insolvency due to CPI index rise",
                "Description": "NonCustodialPSM can become insolvent as CPI index rises.",
                "Repair": "Provide a way to directly inject funds from a separately held stability fund in addition to pcvDeposit, limit the redeem amount to total user's share of the pcvDeposit and its stability fund part"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Timed} from \"./../utils/Timed.sol\";\nimport {CoreRef} from \"./../refs/CoreRef.sol\";\nimport {Decimal} from \"../external/Decimal.sol\";\nimport {Constants} from \"./../Constants.sol\";\nimport {Deviation} from \"./../utils/Deviation.sol\";\nimport {IScalingPriceOracle} from \"./IScalingPriceOracle.sol\";\nimport {BokkyPooBahsDateTimeContract} from \"./../external/calendar/BokkyPooBahsDateTimeContract.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {ERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ChainlinkClient, Chainlink} from \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\n\n/// @notice contract that receives a chainlink price feed and then linearly interpolates that rate over\n/// a 28 day period into the VOLT price. Interest is compounded monthly when the rate is updated\n/// @author Elliot Friedman\ncontract ScalingPriceOracle is\n    Timed,\n    ChainlinkClient,\n    IScalingPriceOracle,\n    BokkyPooBahsDateTimeContract\n{\n    using SafeCast for *;\n    using Deviation for *;\n    using Decimal for Decimal.D256;\n    using Chainlink for Chainlink.Request;\n\n    /// ---------- Mutable Price Variables ----------\n\n    /// @notice current amount that oracle price is inflating/deflating by monthly in basis points\n    int256 public override monthlyChangeRateBasisPoints;\n\n    /// @notice oracle price. starts off at 1e18 and compounds monthly\n    uint256 public override oraclePrice = 1e18;\n\n    /// ---------- Mutable CPI Variables Packed Into Single Storage Slot to Save an SSTORE & SLOAD ----------\n\n    /// @notice the current month's CPI data\n    uint128 public currentMonth;\n\n    /// @notice the previous month's CPI data\n    uint128 public previousMonth;\n\n    /// ---------- Immutable Variables ----------\n\n    /// @notice the time frame over which all changes in CPI data are applied\n    /// 28 days was chosen as that is the shortest length of a month\n    uint256 public constant override TIMEFRAME = 28 days;\n\n    /// @notice the maximum allowable deviation in basis points for a new chainlink oracle update\n    /// only allow price changes by 20% in a month.\n    /// Any change over this threshold in either direction will be rejected\n    uint256 public constant override MAXORACLEDEVIATION = 2_000;\n\n    /// @notice address of chainlink oracle to send request\n    address public immutable oracle;\n\n    /// @notice job id that retrieves the latest CPI data\n    bytes32 public immutable jobId;\n\n    /// @notice amount in LINK paid to node operator for each request\n    uint256 public immutable fee;\n\n    /// @param _oracle address of chainlink data provider\n    /// @param _jobid job id\n    /// @param _fee maximum fee paid to chainlink data provider\n    /// @param _currentMonth current month's inflation data\n    /// @param _previousMonth previous month's inflation data\n    constructor(\n        address _oracle,\n        bytes32 _jobid,\n        uint256 _fee,\n        uint128 _currentMonth,\n        uint128 _previousMonth\n    ) Timed(TIMEFRAME) {\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n\n        if (chainId == 1 || chainId == 42) {\n            setPublicChainlinkToken();\n        }\n\n        oracle = _oracle;\n        jobId = _jobid;\n        fee = _fee;\n\n        currentMonth = _currentMonth;\n        previousMonth = _previousMonth;\n\n        _initTimed();\n\n        /// calculate new monthly CPI-U rate in basis points based on current and previous month\n        int256 aprBasisPoints = getMonthlyAPR();\n\n        /// store data and apply the change rate over the next month to the VOLT price\n        _oracleUpdateChangeRate(aprBasisPoints);\n    }\n\n    // ----------- Getters -----------\n\n    /// @notice get the current scaled oracle price\n    /// applies the change smoothly over a 28 day period\n    /// scaled by 18 decimals\n    // prettier-ignore\n    function getCurrentOraclePrice() public view override returns (uint256) {\n        int256 oraclePriceInt = oraclePrice.toInt256();\n\n        int256 timeDelta = Math.min(block.timestamp - startTime, TIMEFRAME).toInt256();\n        int256 pricePercentageChange = oraclePriceInt * monthlyChangeRateBasisPoints / Constants.BP_INT;\n        int256 priceDelta = pricePercentageChange * timeDelta / TIMEFRAME.toInt256();\n\n        return (oraclePriceInt + priceDelta).toUint256();\n    }\n\n    /// @notice get APR from chainlink data by measuring (current month - previous month) / previous month\n    /// @return percentageChange percentage change in basis points over past month\n    function getMonthlyAPR() public view returns (int256 percentageChange) {\n        int256 delta = int128(currentMonth) - int128(previousMonth);\n        percentageChange = (delta * Constants.BP_INT) / int128(previousMonth);\n    }\n\n    /// ------------- Public API To Request Chainlink Data -------------\n\n    /// @notice Create a Chainlink request to retrieve API response, find the target\n    /// data, then multiply by 1000 (to remove decimal places from data).\n    /// @return requestId for this request\n    /// only allows 1 request per month after the 14th day\n    /// callable by anyone after time period and 14th day of the month\n    function requestCPIData()\n        external\n        afterTimeInit\n        returns (bytes32 requestId)\n    {\n        require(\n            getDay(block.timestamp) > 14,\n            \"ScalingPriceOracle: cannot request data before the 15th\"\n        );\n\n        Chainlink.Request memory request = buildChainlinkRequest(\n            jobId,\n            address(this),\n            this.fulfill.selector\n        );\n\n        return sendChainlinkRequestTo(oracle, request, fee);\n    }\n\n    /// ------------- Chainlink Node Operator API -------------\n\n    /// @notice Receive the response in the form of uint256\n    /// @param _requestId of the chainlink request\n    /// @param _cpiData latest CPI data from BLS\n    /// called by the chainlink oracle\n    function fulfill(bytes32 _requestId, uint256 _cpiData)\n        external\n        recordChainlinkFulfillment(_requestId)\n    {\n        _updateCPIData(_cpiData);\n    }\n\n    // ----------- Internal state changing api -----------\n\n    /// @notice helper function to store and validate new chainlink data\n    /// @param _cpiData latest CPI data from BLS\n    /// update will fail if new values exceed deviation threshold of 20% monthly\n    function _updateCPIData(uint256 _cpiData) internal {\n        require(\n            MAXORACLEDEVIATION.isWithinDeviationThreshold(\n                currentMonth.toInt256(),\n                _cpiData.toInt256()\n            ),\n            \"ScalingPriceOracle: Chainlink data outside of deviation threshold\"\n        );\n\n        /// store CPI data, removes stale data\n        _addNewMonth(uint128(_cpiData));\n\n        /// calculate new monthly CPI-U rate in basis points\n        int256 aprBasisPoints = getMonthlyAPR();\n\n        /// pass data to VOLT Price Oracle\n        _oracleUpdateChangeRate(aprBasisPoints);\n    }\n\n    /// @notice function for chainlink oracle to be able to call in and change the rate\n    /// @param newChangeRateBasisPoints the new monthly interest rate applied to the chainlink oracle price\n    ///\n    /// function effects:\n    ///   compounds interest accumulated over period\n    ///   set new change rate in basis points for next period\n    function _oracleUpdateChangeRate(int256 newChangeRateBasisPoints) internal {\n        /// compound the interest with the current rate\n        oraclePrice = getCurrentOraclePrice();\n\n        int256 currentChangeRateBasisPoints = monthlyChangeRateBasisPoints; /// save 1 SSLOAD\n\n        /// emit even if there isn't an update\n        emit CPIMonthlyChangeRateUpdate(\n            currentChangeRateBasisPoints,\n            newChangeRateBasisPoints\n        );\n\n        /// if the oracle change rate is the same as last time, save an SSTORE\n        if (newChangeRateBasisPoints == currentChangeRateBasisPoints) {\n            return;\n        }\n\n        monthlyChangeRateBasisPoints = newChangeRateBasisPoints;\n    }\n\n    /// @notice this is the only method needed as we will be storing the most recent 2 months of data\n    /// @param newMonth the new month to store\n    function _addNewMonth(uint128 newMonth) internal {\n        previousMonth = currentMonth;\n\n        currentMonth = newMonth;\n    }\n}\n\n\n",
        "CodeNames": [
            "ScalingPriceOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ScalingPriceOracle.sol#L136",
                "Type": "Oracle price does not compound",
                "Description": "The oracle does not correctly compound the monthly APRs it resets on fulfill. The oraclePrice storage variable is only set in _updateCPIData as part of the oracle fulfill callback. It always resets to 1.0 after every fulfill instead of compounding it.",
                "Repair": "Update the oraclePrice in requestCPIData() instead of fulfill. Cover the scenario of multi-month accumulation in tests."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {CoreRef} from \"../refs/CoreRef.sol\";\nimport {TribeRoles} from \"./../core/TribeRoles.sol\";\nimport {RateLimited} from \"./RateLimited.sol\";\nimport {IMultiRateLimited} from \"./IMultiRateLimited.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/// @title abstract contract for putting a rate limit on how fast an address can perform an action e.g. Minting\n/// there are two buffers, one buffer which is each individual addresses's current buffer,\n/// and then there is a global buffer which is the buffer that each individual address must respect as well\n/// @author Elliot Friedman, Fei Protocol\n/// this contract was made abstract so that other contracts that already construct an instance of CoreRef\n/// do not collide with this one\nabstract contract MultiRateLimited is RateLimited, IMultiRateLimited {\n    using SafeCast for *;\n\n    /// @notice the struct containing all information per rate limited address\n    struct RateLimitData {\n        uint32 lastBufferUsedTime;\n        uint112 bufferCap;\n        uint112 bufferStored;\n        uint112 rateLimitPerSecond;\n    }\n\n    /// @notice rate limited address information\n    mapping(address => RateLimitData) public rateLimitPerAddress;\n\n    /// @notice max rate limit per second allowable by non governor per contract\n    uint256 public individualMaxRateLimitPerSecond;\n\n    /// @notice max buffer cap allowable by non governor per contract\n    uint256 public individualMaxBufferCap;\n\n    /// @param _maxRateLimitPerSecond maximum amount of fei that can replenish per second ever, this amount cannot be changed by governance\n    /// @param _rateLimitPerSecond maximum rate limit per second per address\n    /// @param _individualMaxRateLimitPerSecond maximum rate limit per second per address in multi rate limited\n    /// @param _individualMaxBufferCap maximum buffer cap in multi rate limited\n    /// @param _globalBufferCap maximum global buffer cap\n    constructor(\n        uint256 _maxRateLimitPerSecond,\n        uint256 _rateLimitPerSecond,\n        uint256 _individualMaxRateLimitPerSecond,\n        uint256 _individualMaxBufferCap,\n        uint256 _globalBufferCap\n    )\n        RateLimited(\n            _maxRateLimitPerSecond,\n            _rateLimitPerSecond,\n            _globalBufferCap,\n            false\n        )\n    {\n        require(\n            _individualMaxBufferCap < _globalBufferCap,\n            \"MultiRateLimited: max buffer cap invalid\"\n        );\n\n        individualMaxRateLimitPerSecond = _individualMaxRateLimitPerSecond;\n        individualMaxBufferCap = _individualMaxBufferCap;\n    }\n\n    modifier addressIsRegistered(address rateLimitedAddress) {\n        require(\n            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime != 0,\n            \"MultiRateLimited: rate limit address does not exist\"\n        );\n        _;\n    }\n\n    // ----------- Governor and Admin only state changing api -----------\n\n    /// @notice update the ADD_MINTER_ROLE rate limit per second\n    /// @param newRateLimitPerSecond new maximum rate limit per second for add minter role\n    function updateMaxRateLimitPerSecond(uint256 newRateLimitPerSecond)\n        external\n        virtual\n        override\n        onlyGovernor\n    {\n        require(\n            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: exceeds global max rate limit per second\"\n        );\n\n        uint256 oldMaxRateLimitPerSecond = individualMaxRateLimitPerSecond;\n        individualMaxRateLimitPerSecond = newRateLimitPerSecond;\n\n        emit MultiMaxRateLimitPerSecondUpdate(\n            oldMaxRateLimitPerSecond,\n            newRateLimitPerSecond\n        );\n    }\n\n    /// @notice update the ADD_MINTER_ROLE max buffer cap\n    /// @param newBufferCap new buffer cap for ADD_MINTER_ROLE added addresses\n    function updateMaxBufferCap(uint256 newBufferCap)\n        external\n        virtual\n        override\n        onlyGovernor\n    {\n        require(\n            newBufferCap <= bufferCap,\n            \"MultiRateLimited: exceeds global buffer cap\"\n        );\n\n        uint256 oldBufferCap = individualMaxBufferCap;\n        individualMaxBufferCap = newBufferCap;\n\n        emit MultiBufferCapUpdate(oldBufferCap, newBufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the buffer cap for this rateLimitedAddress\n    function addAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) external virtual override onlyGovernor {\n        _addAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the address whose buffer and rate limit per second will be set\n    /// @param _rateLimitPerSecond the new rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the new buffer cap for this rateLimitedAddress\n    function updateAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    )\n        external\n        virtual\n        override\n        addressIsRegistered(rateLimitedAddress)\n        hasAnyOfTwoRoles(TribeRoles.ADD_MINTER_ROLE, TribeRoles.GOVERNOR)\n    {\n        if (core().hasRole(TribeRoles.ADD_MINTER_ROLE, msg.sender)) {\n            require(\n                _rateLimitPerSecond <= individualMaxRateLimitPerSecond,\n                \"MultiRateLimited: rate limit per second exceeds non governor allowable amount\"\n            );\n            require(\n                _bufferCap <= individualMaxBufferCap,\n                \"MultiRateLimited: max buffer cap exceeds non governor allowable amount\"\n            );\n        }\n        require(\n            _bufferCap <= bufferCap,\n            \"MultiRateLimited: buffercap too high\"\n        );\n\n        _updateAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// gives the newly added contract the maximum allowable rate limit per second and buffer cap\n    function addAddressWithCaps(address rateLimitedAddress)\n        external\n        virtual\n        override\n        onlyTribeRole(TribeRoles.ADD_MINTER_ROLE)\n    {\n        _addAddress(\n            rateLimitedAddress,\n            uint112(individualMaxRateLimitPerSecond),\n            uint112(individualMaxBufferCap)\n        );\n    }\n\n    /// @notice remove an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the address to remove from the whitelist of addresses\n    function removeAddress(address rateLimitedAddress)\n        external\n        virtual\n        override\n        addressIsRegistered(rateLimitedAddress)\n        onlyGuardianOrGovernor\n    {\n        uint256 oldRateLimitPerSecond = rateLimitPerAddress[rateLimitedAddress]\n            .rateLimitPerSecond;\n\n        delete rateLimitPerAddress[rateLimitedAddress];\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            oldRateLimitPerSecond,\n            0\n        );\n    }\n\n    // ----------- Getters -----------\n\n    /// @notice the amount of action used before hitting limit\n    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap\n    /// @param rateLimitedAddress the address whose buffer will be returned\n    /// @return the buffer of the specified rate limited address\n    function individualBuffer(address rateLimitedAddress)\n        public\n        view\n        override\n        returns (uint112)\n    {\n        RateLimitData memory rateLimitData = rateLimitPerAddress[\n            rateLimitedAddress\n        ];\n\n        uint256 elapsed = block.timestamp - rateLimitData.lastBufferUsedTime;\n        return\n            uint112(\n                Math.min(\n                    rateLimitData.bufferStored +\n                        (rateLimitData.rateLimitPerSecond * elapsed),\n                    rateLimitData.bufferCap\n                )\n            );\n    }\n\n    /// @notice the rate per second for each address\n    function getRateLimitPerSecond(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].rateLimitPerSecond;\n    }\n\n    /// @notice the last time the buffer was used by each address\n    function getLastBufferUsedTime(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].lastBufferUsedTime;\n    }\n\n    /// @notice the cap of the buffer that can be used at once\n    function getBufferCap(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].bufferCap;\n    }\n\n    // ----------- Helper Methods -----------\n\n    function _updateAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) internal {\n        RateLimitData storage rateLimitData = rateLimitPerAddress[\n            rateLimitedAddress\n        ];\n\n        require(\n            rateLimitData.lastBufferUsedTime != 0,\n            \"MultiRateLimited: rate limit address does not exist\"\n        );\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n\n        uint112 oldRateLimitPerSecond = rateLimitData.rateLimitPerSecond;\n\n        rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();\n        rateLimitData.bufferCap = _bufferCap;\n        rateLimitData.rateLimitPerSecond = _rateLimitPerSecond;\n        rateLimitData.bufferStored = _bufferCap;\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            oldRateLimitPerSecond,\n            _rateLimitPerSecond\n        );\n    }\n\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the buffer cap for this rateLimitedAddress\n    function _addAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) internal {\n        require(\n            _bufferCap <= bufferCap,\n            \"MultiRateLimited: new buffercap too high\"\n        );\n        require(\n            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime == 0,\n            \"MultiRateLimited: address already added\"\n        );\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n\n        RateLimitData memory rateLimitData = RateLimitData({\n            lastBufferUsedTime: block.timestamp.toUint32(),\n            bufferCap: _bufferCap,\n            rateLimitPerSecond: _rateLimitPerSecond,\n            bufferStored: _bufferCap\n        });\n\n        rateLimitPerAddress[rateLimitedAddress] = rateLimitData;\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            0,\n            _rateLimitPerSecond\n        );\n    }\n\n    /// @notice the method that enforces the rate limit. Decreases buffer by \"amount\".\n    /// @param rateLimitedAddress the address whose buffer will be depleted\n    /// @param amount the amount to remove from the rateLimitedAddress's buffer\n    function _depleteIndividualBuffer(\n        address rateLimitedAddress,\n        uint256 amount\n    ) internal returns (uint256) {\n        _depleteBuffer(amount);\n\n        uint256 newBuffer = individualBuffer(rateLimitedAddress);\n\n        require(newBuffer != 0, \"MultiRateLimited: no rate limit buffer\");\n        require(amount <= newBuffer, \"MultiRateLimited: rate limit hit\");\n\n        rateLimitPerAddress[rateLimitedAddress].bufferStored = uint112(\n            newBuffer - amount\n        );\n\n        rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime = block\n            .timestamp\n            .toUint32();\n\n        emit IndividualBufferUsed(\n            rateLimitedAddress,\n            amount,\n            newBuffer - amount\n        );\n\n        return amount;\n    }\n}\n\n\n",
        "CodeNames": [
            "MultiRateLimited.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MultiRateLimited.sol#L280",
                "Type": "Updating rate limit for addresses restores their entire buffer amount",
                "Description": "When the bufferCap is updated for an address in _updateAddress, the address's allowed buffer (bufferStored) is replenished to the entire bufferCap. The address could frontrun the updateAddress call and spend their entire buffer, then the buffer is replenished and they can spend their entire buffer a second time.",
                "Repair": "Keep the old buffer value, capped by the new bufferCap"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../refs/CoreRef.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title abstract contract for putting a rate limit on how fast a contract can perform an action e.g. Minting\n/// @author Fei Protocol\nabstract contract RateLimited is CoreRef {\n    /// @notice maximum rate limit per second governance can set for this contract\n    uint256 public immutable MAX_RATE_LIMIT_PER_SECOND;\n\n    /// @notice the rate per second for this contract\n    uint256 public rateLimitPerSecond;\n\n    /// @notice the last time the buffer was used by the contract\n    uint256 public lastBufferUsedTime;\n\n    /// @notice the cap of the buffer that can be used at once\n    uint256 public bufferCap;\n\n    /// @notice a flag for whether to allow partial actions to complete if the buffer is less than amount\n    bool public doPartialAction;\n\n    /// @notice the buffer at the timestamp of lastBufferUsedTime\n    uint256 public bufferStored;\n\n    event BufferUsed(uint256 amountUsed, uint256 bufferRemaining);\n    event BufferCapUpdate(uint256 oldBufferCap, uint256 newBufferCap);\n    event RateLimitPerSecondUpdate(\n        uint256 oldRateLimitPerSecond,\n        uint256 newRateLimitPerSecond\n    );\n\n    constructor(\n        uint256 _maxRateLimitPerSecond,\n        uint256 _rateLimitPerSecond,\n        uint256 _bufferCap,\n        bool _doPartialAction\n    ) {\n        lastBufferUsedTime = block.timestamp;\n\n        _setBufferCap(_bufferCap);\n        bufferStored = _bufferCap;\n\n        require(\n            _rateLimitPerSecond <= _maxRateLimitPerSecond,\n            \"RateLimited: rateLimitPerSecond too high\"\n        );\n        _setRateLimitPerSecond(_rateLimitPerSecond);\n\n        MAX_RATE_LIMIT_PER_SECOND = _maxRateLimitPerSecond;\n        doPartialAction = _doPartialAction;\n    }\n\n    /// @notice set the rate limit per second\n    function setRateLimitPerSecond(uint256 newRateLimitPerSecond)\n        external\n        virtual\n        onlyGovernorOrAdmin\n    {\n        require(\n            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"RateLimited: rateLimitPerSecond too high\"\n        );\n        _updateBufferStored();\n\n        _setRateLimitPerSecond(newRateLimitPerSecond);\n    }\n\n    /// @notice set the buffer cap\n    function setBufferCap(uint256 newBufferCap)\n        external\n        virtual\n        onlyGovernorOrAdmin\n    {\n        _setBufferCap(newBufferCap);\n    }\n\n    /// @notice the amount of action used before hitting limit\n    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap\n    function buffer() public view returns (uint256) {\n        uint256 elapsed = block.timestamp - lastBufferUsedTime;\n        return\n            Math.min(bufferStored + (rateLimitPerSecond * elapsed), bufferCap);\n    }\n\n    /** \n        @notice the method that enforces the rate limit. Decreases buffer by \"amount\". \n        If buffer is <= amount either\n        1. Does a partial mint by the amount remaining in the buffer or\n        2. Reverts\n        Depending on whether doPartialAction is true or false\n    */\n    function _depleteBuffer(uint256 amount) internal virtual returns (uint256) {\n        uint256 newBuffer = buffer();\n\n        uint256 usedAmount = amount;\n        if (doPartialAction && usedAmount > newBuffer) {\n            usedAmount = newBuffer;\n        }\n\n        require(newBuffer != 0, \"RateLimited: no rate limit buffer\");\n        require(usedAmount <= newBuffer, \"RateLimited: rate limit hit\");\n\n        bufferStored = newBuffer - usedAmount;\n\n        lastBufferUsedTime = block.timestamp;\n\n        emit BufferUsed(usedAmount, bufferStored);\n\n        return usedAmount;\n    }\n\n    /// @notice function to replenish buffer\n    /// @param amount to increase buffer by if under buffer cap\n    function _replenishBuffer(uint256 amount) internal {\n        uint256 newBuffer = buffer();\n\n        uint256 _bufferCap = bufferCap; /// gas opti, save an SLOAD\n\n        /// cannot replenish any further if already at buffer cap\n        if (newBuffer == _bufferCap) {\n            return;\n        }\n\n        /// ensure that bufferStored cannot be gt buffer cap\n        bufferStored = Math.min(newBuffer + amount, _bufferCap);\n    }\n\n    function _setRateLimitPerSecond(uint256 newRateLimitPerSecond) internal {\n        uint256 oldRateLimitPerSecond = rateLimitPerSecond;\n        rateLimitPerSecond = newRateLimitPerSecond;\n\n        emit RateLimitPerSecondUpdate(\n            oldRateLimitPerSecond,\n            newRateLimitPerSecond\n        );\n    }\n\n    function _setBufferCap(uint256 newBufferCap) internal {\n        _updateBufferStored();\n\n        uint256 oldBufferCap = bufferCap;\n        bufferCap = newBufferCap;\n\n        emit BufferCapUpdate(oldBufferCap, newBufferCap);\n    }\n\n    function _resetBuffer() internal {\n        bufferStored = bufferCap;\n    }\n\n    function _updateBufferStored() internal {\n        bufferStored = buffer();\n        lastBufferUsedTime = block.timestamp;\n    }\n}\n\n\n",
        "CodeNames": [
            "RateLimited.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RateLimited.sol#L142",
                "Type": "Setting new buffer does not reduce current buffer to cap",
                "Description": "The RateLimited.setBufferCap function first updates the buffer and then sets the new cap, but does not apply the new cap to the updated buffer. The updated buffer value can be larger than the new buffer cap which should never be the case.",
                "Repair": "Update the buffer after setting the new cap"
            }
        ]
    }
]