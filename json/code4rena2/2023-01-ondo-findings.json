[
    {
        "Code": "/**SPDX-License-Identifier: BUSL-1.1\n\n      \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\n   \u2553\u2588\u2588\u2580\u2514 ,\u2553\u2584\u2584\u2584, '\u2580\u2588\u2588\u2584\n  \u2588\u2588\u2580 \u2584\u2588\u2588\u2580\u2580\u2559\u2559\u2580\u2580\u2588\u2588\u2584 \u2514\u2588\u2588\u00b5           ,,       ,,      ,     ,,,            ,,,\n \u2588\u2588 ,\u2588\u2588\u00ac \u2584\u2588\u2588\u2588\u2588\u2584  \u2580\u2588\u2584 \u2559\u2588\u2584      \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2584   \u2588\u2588\u2588\u2584    \u2588\u2588  \u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584    \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588,\n\u2588\u2588  \u2588\u2588 \u2552\u2588\u2580'   \u2559\u2588\u258c \u2559\u2588\u258c \u2588\u2588     \u2590\u2588\u2588      \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588,  \u2588\u2588  \u2588\u2588\u258c    \u2514\u2588\u2588\u258c  \u2588\u2588\u258c     \u2514\u2588\u2588\u258c\n\u2588\u2588 \u2590\u2588\u258c \u2588\u2588      \u255f\u2588  \u2588\u258c \u255f\u2588     \u2588\u2588\u258c      \u2590\u2588\u2588  \u2588\u2588 \u2514\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u258c     \u255f\u2588\u2588 j\u2588\u2588       \u255f\u2588\u2588\n\u255f\u2588  \u2588\u2588 \u2559\u2588\u2588    \u2584\u2588\u2580 \u2590\u2588\u258c \u2588\u2588     \u2559\u2588\u2588      \u2588\u2588\u258c  \u2588\u2588   \u2559\u2588\u2588\u2588\u2588  \u2588\u2588\u258c    \u2584\u2588\u2588\u2580  \u2588\u2588\u258c     ,\u2588\u2588\u2580\n \u2588\u2588 \"\u2588\u2588, \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310      \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580   \u2588\u2588     \u2559\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580     \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`\n  \u2588\u2588\u2584 \u2559\u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584,,,                \u00ac\u2500                                    '\u2500\u00ac\n   \u2559\u2580\u2588\u2588\u2584 '\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\n      \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588R\u2310\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/cash/interfaces/IKYCRegistry.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/cash/external/chainalysis/ISanctionsList.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * @title KYCRegistry\n * @author Ondo Finance\n * @notice This contract manages KYC status for addresses that interact with\n *         Ondo products.\n */\ncontract KYCRegistry is AccessControlEnumerable, IKYCRegistry, EIP712 {\n  bytes32 public constant _APPROVAL_TYPEHASH =\n    keccak256(\n      \"KYCApproval(uint256 kycRequirementGroup,address user,uint256 deadline)\"\n    );\n  // Admin role that has permission to add/remove KYC related roles\n  bytes32 public constant REGISTRY_ADMIN = keccak256(\"REGISTRY_ADMIN\");\n\n  // {<KYCLevel> => {<user account address> => is user KYC approved}\n  mapping(uint256 => mapping(address => bool)) public kycState;\n\n  // Represents which roles msg.sender must have in order to change\n  // KYC state at that group.\n  /// @dev Default admin role of 0x00... will be able to set all group roles\n  ///      that are unset.\n  mapping(uint256 => bytes32) public kycGroupRoles;\n\n  // Chainalysis sanctions list\n  ISanctionsList public immutable sanctionsList;\n\n  /// @notice constructor\n  constructor(\n    address admin,\n    address _sanctionsList\n  ) EIP712(\"OndoKYCRegistry\", \"1\") {\n    _grantRole(DEFAULT_ADMIN_ROLE, admin);\n    _grantRole(REGISTRY_ADMIN, admin);\n    sanctionsList = ISanctionsList(_sanctionsList);\n  }\n\n  /**\n   * @notice Add a provided user to the registry at a specified\n   *         `kycRequirementGroup`. In order to sucessfully call this function,\n   *         An external caller must provide a signature signed by an address\n   *         with the role `kycGroupRoles[kycRequirementGroup]`.\n   *\n   * @param kycRequirementGroup KYC requirement group to modify `user`'s\n   *                            KYC status for\n   * @param user                User address to change KYC status for\n   * @param deadline            Deadline for which the signature-auth based\n   *                            operations with the signature become invalid\n   * @param v                   Recovery ID (See EIP 155)\n   * @param r                   Part of ECDSA signature representation\n   * @param s                   Part of ECDSA signature representation\n   *\n   * @dev Please note that ecrecover (which the Registry uses) requires V be\n   *      27 or 28, so a conversion must be applied before interacting with\n   *      `addKYCAddressViaSignature`\n   */\n  function addKYCAddressViaSignature(\n    uint256 kycRequirementGroup,\n    address user,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    require(v == 27 || v == 28, \"KYCRegistry: invalid v value in signature\");\n    require(\n      !kycState[kycRequirementGroup][user],\n      \"KYCRegistry: user already verified\"\n    );\n    require(block.timestamp <= deadline, \"KYCRegistry: signature expired\");\n    bytes32 structHash = keccak256(\n      abi.encode(_APPROVAL_TYPEHASH, kycRequirementGroup, user, deadline)\n    );\n    // https://eips.ethereum.org/EIPS/eip-712 compliant\n    bytes32 expectedMessage = _hashTypedDataV4(structHash);\n\n    // `ECDSA.recover` reverts if signer is address(0)\n    address signer = ECDSA.recover(expectedMessage, v, r, s);\n    _checkRole(kycGroupRoles[kycRequirementGroup], signer);\n\n    kycState[kycRequirementGroup][user] = true;\n\n    emit KYCAddressAddViaSignature(\n      msg.sender,\n      user,\n      signer,\n      kycRequirementGroup,\n      deadline\n    );\n  }\n\n  /// @notice Getter for EIP 712 Domain separator.\n  function DOMAIN_SEPARATOR() external view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  /**\n   * @notice Get KYC status of `account` for the provided\n   *         `kycRequirementGroup`. In order to return true, `account`'s state\n   *         in this contract must be true and additionally pass a\n   *         `sanctionsList` check.\n   *\n   * @param kycRequirementGroup KYC group to check KYC status for\n   * @param account             Addresses to check KYC status for\n   */\n  function getKYCStatus(\n    uint256 kycRequirementGroup,\n    address account\n  ) external view override returns (bool) {\n    return\n      kycState[kycRequirementGroup][account] &&\n      !sanctionsList.isSanctioned(account);\n  }\n\n  /**\n   * @notice Assigns a role to specified `kycRequirementGroup` to gate changes\n   *         to that group's KYC state\n   *\n   * @param kycRequirementGroup KYC group to set role for\n   * @param role                The role being assigned to a group\n   */\n  function assignRoletoKYCGroup(\n    uint256 kycRequirementGroup,\n    bytes32 role\n  ) external onlyRole(REGISTRY_ADMIN) {\n    kycGroupRoles[kycRequirementGroup] = role;\n    emit RoleAssignedToKYCGroup(kycRequirementGroup, role);\n  }\n\n  /**\n   * @notice Add addresses to KYC list for specified `kycRequirementGroup`\n   *\n   * @param kycRequirementGroup KYC group associated with `addresses`\n   * @param addresses           List of addresses to grant KYC'd status\n   */\n  function addKYCAddresses(\n    uint256 kycRequirementGroup,\n    address[] calldata addresses\n  ) external onlyRole(kycGroupRoles[kycRequirementGroup]) {\n    uint256 length = addresses.length;\n    for (uint256 i = 0; i < length; i++) {\n      kycState[kycRequirementGroup][addresses[i]] = true;\n    }\n    emit KYCAddressesAdded(msg.sender, kycRequirementGroup, addresses);\n  }\n\n  /**\n   * @notice Remove addresses from KYC list\n   *\n   * @param kycRequirementGroup KYC group associated with `addresses`\n   * @param addresses           List of addresses to revoke KYC'd status\n   */\n  function removeKYCAddresses(\n    uint256 kycRequirementGroup,\n    address[] calldata addresses\n  ) external onlyRole(kycGroupRoles[kycRequirementGroup]) {\n    uint256 length = addresses.length;\n    for (uint256 i = 0; i < length; i++) {\n      kycState[kycRequirementGroup][addresses[i]] = false;\n    }\n    emit KYCAddressesRemoved(msg.sender, kycRequirementGroup, addresses);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Events\n  //////////////////////////////////////////////////////////////*/\n  /**\n   * @dev Event emitted when a role is assigned to a KYC group\n   *\n   * @param kycRequirementGroup The KYC group\n   * @param role                The role being assigned\n   */\n  event RoleAssignedToKYCGroup(\n    uint256 indexed kycRequirementGroup,\n    bytes32 indexed role\n  );\n\n  /**\n   * @dev Event emitted when addresses are added to KYC requirement group\n   *\n   * @param sender              Sender of the transaction\n   * @param kycRequirementGroup KYC requirement group being updated\n   * @param addresses           Array of addresses being added as elligible\n   */\n  event KYCAddressesAdded(\n    address indexed sender,\n    uint256 indexed kycRequirementGroup,\n    address[] addresses\n  );\n\n  /**\n   * @dev Event emitted when a user is added to the KYCRegistry\n   *      by an external caller through signature-auth\n   *\n   * @param sender              Sender of the transaction\n   * @param user                User being added to registry\n   * @param signer              Digest signer\n   * @param kycRequirementGroup KYC requirement group being updated\n   * @param deadline            Expiration constraint on signature\n   */\n  event KYCAddressAddViaSignature(\n    address indexed sender,\n    address indexed user,\n    address indexed signer,\n    uint256 kycRequirementGroup,\n    uint256 deadline\n  );\n\n  /**\n   * @dev Event emitted when addresses are removed from KYC requirement group\n   *\n   * @param sender              Sender of the transaction\n   * @param kycRequirementGroup KYC requirement group being updated\n   * @param addresses           Array of addresses being added as elligible\n   */\n  event KYCAddressesRemoved(\n    address indexed sender,\n    uint256 indexed kycRequirementGroup,\n    address[] addresses\n  );\n}\n\n\n",
        "CodeNames": [
            "KYCRegistry.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "KYCRegistry contract's addKYCAddressViaSignature function",
                "Type": "signature replay attack",
                "Description": "The addKYCAddressViaSignature function does not prevent replaying of signatures in the case where KYC status was revoked from a user, allowing a malicious user to forcefully grant KYC status to themselves again.",
                "Repair": "Maintain a nonce mapping for message signers that can be incremented for every successful signature validation"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"../cErc20Delegate/ComptrollerInterface.sol\";\nimport \"../cErc20Delegate/ErrorReporter.sol\";\nimport \"../cErc20Delegate/EIP20Interface.sol\";\nimport \"../cErc20Delegate/InterestRateModel.sol\";\nimport \"../cErc20Delegate/ExponentialNoError.sol\";\nimport \"./CTokenInterfacesModified.sol\";\n\n/**\n * @title Ondo's Generic CToken Contract\n * @notice Abstract base for CTokens w/underlying as non-CASH tokens\n * @dev Does sanctions and KYC checks on key functions\n * @author Compound + Ondo\n */\nabstract contract CTokenModified is\n  CTokenInterface,\n  ExponentialNoError,\n  TokenErrorReporter\n{\n  /**\n   * @notice Initialize the money market\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ EIP-20 name of this token\n   * @param symbol_ EIP-20 symbol of this token\n   * @param decimals_ EIP-20 decimal precision of this token\n   * @param kycRegistry_ KYC Registry contract address\n   * @param kycRequirementGroup_ KYC Requirement group to check KYC status\n   *                             against\n   */\n  function initialize(\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address kycRegistry_,\n    uint256 kycRequirementGroup_\n  ) public {\n    require(msg.sender == admin, \"only admin may initialize the market\");\n    require(\n      accrualBlockNumber == 0 && borrowIndex == 0,\n      \"market may only be initialized once\"\n    );\n\n    // Set initial exchange rate\n    initialExchangeRateMantissa = initialExchangeRateMantissa_;\n    require(\n      initialExchangeRateMantissa > 0,\n      \"initial exchange rate must be greater than zero.\"\n    );\n\n    // Set the comptroller\n    uint err = _setComptroller(comptroller_);\n    require(err == NO_ERROR, \"setting comptroller failed\");\n\n    // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n    accrualBlockNumber = getBlockNumber();\n    borrowIndex = mantissaOne;\n\n    // Set the interest rate model (depends on block number / borrow index)\n    err = _setInterestRateModelFresh(interestRateModel_);\n    require(err == NO_ERROR, \"setting interest rate model failed\");\n\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n\n    // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n    _notEntered = true;\n\n    // Initialize KYCRegistryClient\n    _setKYCRegistry(kycRegistry_);\n    _setKYCRequirementGroup(kycRequirementGroup_);\n  }\n\n  /**\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n   * @dev Called by both `transfer` and `transferFrom` internally\n   * @param spender The address of the account performing the transfer\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param tokens The number of tokens to transfer\n   * @return 0 if the transfer succeeded, else revert\n   */\n  function transferTokens(\n    address spender,\n    address src,\n    address dst,\n    uint tokens\n  ) internal returns (uint) {\n    /* Revert if sanctioned */\n    require(!sanctionsList.isSanctioned(spender), \"Spender is sanctioned\");\n    require(!sanctionsList.isSanctioned(src), \"Source is sanctioned\");\n    require(!sanctionsList.isSanctioned(dst), \"Destination is sanctioned\");\n\n    /* Fail if transfer not allowed */\n    uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n    if (allowed != 0) {\n      revert TransferComptrollerRejection(allowed);\n    }\n\n    /* Do not allow self-transfers */\n    if (src == dst) {\n      revert TransferNotAllowed();\n    }\n\n    /* Get the allowance, infinite for the account owner */\n    uint startingAllowance = 0;\n    if (spender == src) {\n      startingAllowance = type(uint).max;\n    } else {\n      startingAllowance = transferAllowances[src][spender];\n    }\n\n    /* Do the calculations, checking for {under,over}flow */\n    uint allowanceNew = startingAllowance - tokens;\n    uint srcTokensNew = accountTokens[src] - tokens;\n    uint dstTokensNew = accountTokens[dst] + tokens;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    accountTokens[src] = srcTokensNew;\n    accountTokens[dst] = dstTokensNew;\n\n    /* Eat some of the allowance (if necessary) */\n    if (startingAllowance != type(uint).max) {\n      transferAllowances[src][spender] = allowanceNew;\n    }\n\n    /* We emit a Transfer event */\n    emit Transfer(src, dst, tokens);\n\n    // unused function\n    // comptroller.transferVerify(address(this), src, dst, tokens);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(\n    address dst,\n    uint256 amount\n  ) external override nonReentrant returns (bool) {\n    return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external override nonReentrant returns (bool) {\n    return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (uint256.max means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(\n    address spender,\n    uint256 amount\n  ) external override returns (bool) {\n    address src = msg.sender;\n    transferAllowances[src][spender] = amount;\n    emit Approval(src, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(\n    address owner,\n    address spender\n  ) external view override returns (uint256) {\n    return transferAllowances[owner][spender];\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n   * @param owner The address of the account to query\n   * @return The number of tokens owned by `owner`\n   */\n  function balanceOf(address owner) external view override returns (uint256) {\n    return accountTokens[owner];\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n   * @dev This also accrues interest in a transaction\n   * @param owner The address of the account to query\n   * @return The amount of underlying owned by `owner`\n   */\n  function balanceOfUnderlying(address owner) external override returns (uint) {\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n    return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\n   * @param account Address of the account to snapshot\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n   */\n  function getAccountSnapshot(\n    address account\n  ) external view override returns (uint, uint, uint, uint) {\n    return (\n      NO_ERROR,\n      accountTokens[account],\n      borrowBalanceStoredInternal(account),\n      exchangeRateStoredInternal()\n    );\n  }\n\n  /**\n   * @dev Function to simply retrieve block number\n   *  This exists mainly for inheriting test contracts to stub this result.\n   */\n  function getBlockNumber() internal view virtual returns (uint) {\n    return block.number;\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this cToken\n   * @return The borrow interest rate per block, scaled by 1e18\n   */\n  function borrowRatePerBlock() external view override returns (uint) {\n    return\n      interestRateModel.getBorrowRate(\n        getCashPrior(),\n        totalBorrows,\n        totalReserves\n      );\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this cToken\n   * @return The supply interest rate per block, scaled by 1e18\n   */\n  function supplyRatePerBlock() external view override returns (uint) {\n    return\n      interestRateModel.getSupplyRate(\n        getCashPrior(),\n        totalBorrows,\n        totalReserves,\n        reserveFactorMantissa\n      );\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n   * @return The total borrows with interest\n   */\n  function totalBorrowsCurrent() external override nonReentrant returns (uint) {\n    accrueInterest();\n    return totalBorrows;\n  }\n\n  /**\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n   * @param account The address whose balance should be calculated after updating borrowIndex\n   * @return The calculated balance\n   */\n  function borrowBalanceCurrent(\n    address account\n  ) external override nonReentrant returns (uint) {\n    accrueInterest();\n    return borrowBalanceStored(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return The calculated balance\n   */\n  function borrowBalanceStored(\n    address account\n  ) public view override returns (uint) {\n    return borrowBalanceStoredInternal(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return (error code, the calculated balance or 0 if error code is non-zero)\n   */\n  function borrowBalanceStoredInternal(\n    address account\n  ) internal view returns (uint) {\n    /* Get borrowBalance and borrowIndex */\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n     */\n    if (borrowSnapshot.principal == 0) {\n      return 0;\n    }\n\n    /* Calculate new borrow balance using the interest index:\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n     */\n    uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\n    return principalTimesIndex / borrowSnapshot.interestIndex;\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateCurrent() public override nonReentrant returns (uint) {\n    accrueInterest();\n    return exchangeRateStored();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStored() public view override returns (uint) {\n    return exchangeRateStoredInternal();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStoredInternal() internal view virtual returns (uint) {\n    uint _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n      /*\n       * If there are no tokens minted:\n       *  exchangeRate = initialExchangeRate\n       */\n      return initialExchangeRateMantissa;\n    } else {\n      /*\n       * Otherwise:\n       *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n       */\n      uint totalCash = getCashPrior();\n      uint cashPlusBorrowsMinusReserves = totalCash +\n        totalBorrows -\n        totalReserves;\n      uint exchangeRate = (cashPlusBorrowsMinusReserves * expScale) /\n        _totalSupply;\n\n      return exchangeRate;\n    }\n  }\n\n  /**\n   * @notice Get cash balance of this cToken in the underlying asset\n   * @return The quantity of underlying asset owned by this contract\n   */\n  function getCash() external view override returns (uint) {\n    return getCashPrior();\n  }\n\n  /**\n   * @notice Applies accrued interest to total borrows and reserves\n   * @dev This calculates interest accrued from the last checkpointed block\n   *   up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public virtual override returns (uint) {\n    /* Remember the initial block number */\n    uint currentBlockNumber = getBlockNumber();\n    uint accrualBlockNumberPrior = accrualBlockNumber;\n\n    /* Short-circuit accumulating 0 interest */\n    if (accrualBlockNumberPrior == currentBlockNumber) {\n      return NO_ERROR;\n    }\n\n    /* Read the previous values out of storage */\n    uint cashPrior = getCashPrior();\n    uint borrowsPrior = totalBorrows;\n    uint reservesPrior = totalReserves;\n    uint borrowIndexPrior = borrowIndex;\n\n    /* Calculate the current borrow interest rate */\n    uint borrowRateMantissa = interestRateModel.getBorrowRate(\n      cashPrior,\n      borrowsPrior,\n      reservesPrior\n    );\n    require(\n      borrowRateMantissa <= borrowRateMaxMantissa,\n      \"borrow rate is absurdly high\"\n    );\n\n    /* Calculate the number of blocks elapsed since the last accrual */\n    uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n\n    /*\n     * Calculate the interest accumulated into borrows and reserves and the new index:\n     *  simpleInterestFactor = borrowRate * blockDelta\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n     */\n\n    Exp memory simpleInterestFactor = mul_(\n      Exp({mantissa: borrowRateMantissa}),\n      blockDelta\n    );\n    uint interestAccumulated = mul_ScalarTruncate(\n      simpleInterestFactor,\n      borrowsPrior\n    );\n    uint totalBorrowsNew = interestAccumulated + borrowsPrior;\n    uint totalReservesNew = mul_ScalarTruncateAddUInt(\n      Exp({mantissa: reserveFactorMantissa}),\n      interestAccumulated,\n      reservesPrior\n    );\n    uint borrowIndexNew = mul_ScalarTruncateAddUInt(\n      simpleInterestFactor,\n      borrowIndexPrior,\n      borrowIndexPrior\n    );\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    accrualBlockNumber = currentBlockNumber;\n    borrowIndex = borrowIndexNew;\n    totalBorrows = totalBorrowsNew;\n    totalReserves = totalReservesNew;\n\n    /* We emit an AccrueInterest event */\n    emit AccrueInterest(\n      cashPrior,\n      interestAccumulated,\n      borrowIndexNew,\n      totalBorrowsNew\n    );\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   */\n  function mintInternal(uint mintAmount) internal nonReentrant {\n    accrueInterest();\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n    mintFresh(msg.sender, mintAmount);\n  }\n\n  /**\n   * @notice User supplies assets into the market and receives cTokens in exchange\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param minter The address of the account which is supplying the assets\n   * @param mintAmount The amount of the underlying asset to supply\n   */\n  function mintFresh(address minter, uint mintAmount) internal {\n    /* Revert if sanctioned */\n    require(!sanctionsList.isSanctioned(minter), \"Minter is sanctioned\");\n\n    /* Fail if mint not allowed */\n    uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n    if (allowed != 0) {\n      revert MintComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert MintFreshnessCheck();\n    }\n\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     *  We call `doTransferIn` for the minter and the mintAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n     *  side-effects occurred. The function returns the amount actually transferred,\n     *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n     *  of cash.\n     */\n    uint actualMintAmount = doTransferIn(minter, mintAmount);\n\n    /*\n     * We get the current exchange rate and calculate the number of cTokens to be minted:\n     *  mintTokens = actualMintAmount / exchangeRate\n     */\n\n    uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n    /*\n     * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n     *  totalSupplyNew = totalSupply + mintTokens\n     *  accountTokensNew = accountTokens[minter] + mintTokens\n     * And write them into storage\n     */\n    totalSupply = totalSupply + mintTokens;\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, actualMintAmount, mintTokens);\n    emit Transfer(address(this), minter, mintTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   */\n  function redeemInternal(uint redeemTokens) internal nonReentrant {\n    accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    redeemFresh(payable(msg.sender), redeemTokens, 0);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n   */\n  function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant {\n    accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    redeemFresh(payable(msg.sender), 0, redeemAmount);\n  }\n\n  /**\n   * @notice User redeems cTokens in exchange for the underlying asset\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param redeemer The address of the account which is redeeming the tokens\n   * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   */\n  function redeemFresh(\n    address payable redeemer,\n    uint redeemTokensIn,\n    uint redeemAmountIn\n  ) internal {\n    /* Revert if sanctioned */\n    require(!sanctionsList.isSanctioned(redeemer), \"Redeemer is sanctioned\");\n\n    require(\n      redeemTokensIn == 0 || redeemAmountIn == 0,\n      \"one of redeemTokensIn or redeemAmountIn must be zero\"\n    );\n\n    /* exchangeRate = invoke Exchange Rate Stored() */\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n\n    uint redeemTokens;\n    uint redeemAmount;\n    /* If redeemTokensIn > 0: */\n    if (redeemTokensIn > 0) {\n      /*\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\n       *  redeemTokens = redeemTokensIn\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n       */\n      redeemTokens = redeemTokensIn;\n      redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n    } else {\n      /*\n       * We get the current exchange rate and calculate the amount to be redeemed:\n       *  redeemTokens = redeemAmountIn / exchangeRate\n       *  redeemAmount = redeemAmountIn\n       */\n      redeemTokens = div_(redeemAmountIn, exchangeRate);\n      redeemAmount = redeemAmountIn;\n    }\n\n    /* Fail if redeem not allowed */\n    uint allowed = comptroller.redeemAllowed(\n      address(this),\n      redeemer,\n      redeemTokens\n    );\n    if (allowed != 0) {\n      revert RedeemComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert RedeemFreshnessCheck();\n    }\n\n    /* Fail gracefully if protocol has insufficient cash */\n    if (getCashPrior() < redeemAmount) {\n      revert RedeemTransferOutNotPossible();\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We write the previously calculated values into storage.\n     *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\n     */\n    totalSupply = totalSupply - redeemTokens;\n    accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\n\n    /*\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken has redeemAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(redeemer, redeemAmount);\n\n    /* We emit a Transfer event, and a Redeem event */\n    emit Transfer(redeemer, address(this), redeemTokens);\n    emit Redeem(redeemer, redeemAmount, redeemTokens);\n\n    /* We call the defense hook */\n    comptroller.redeemVerify(\n      address(this),\n      redeemer,\n      redeemAmount,\n      redeemTokens\n    );\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   */\n  function borrowInternal(uint borrowAmount) internal nonReentrant {\n    accrueInterest();\n    // borrowFresh emits borrow-specific logs on errors, so we don't need to\n    borrowFresh(payable(msg.sender), borrowAmount);\n  }\n\n  /**\n   * @notice Users borrow assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   */\n  function borrowFresh(address payable borrower, uint borrowAmount) internal {\n    /* Revert if borrower not KYC'd */\n    require(_getKYCStatus(borrower), \"Borrower not KYC'd\");\n\n    /* Fail if borrow not allowed */\n    uint allowed = comptroller.borrowAllowed(\n      address(this),\n      borrower,\n      borrowAmount\n    );\n    if (allowed != 0) {\n      revert BorrowComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert BorrowFreshnessCheck();\n    }\n\n    /* Fail gracefully if protocol has insufficient underlying cash */\n    if (getCashPrior() < borrowAmount) {\n      revert BorrowCashNotAvailable();\n    }\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on overflow:\n     *  accountBorrowNew = accountBorrow + borrowAmount\n     *  totalBorrowsNew = totalBorrows + borrowAmount\n     */\n    uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n    uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;\n    uint totalBorrowsNew = totalBorrows + borrowAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n         * We write the previously calculated values into storage.\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\n        `*/\n    accountBorrows[borrower].principal = accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = totalBorrowsNew;\n\n    /*\n     * We invoke doTransferOut for the borrower and the borrowAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken borrowAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(borrower, borrowAmount);\n\n    /* We emit a Borrow event */\n    emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   */\n  function repayBorrowInternal(uint repayAmount) internal nonReentrant {\n    accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n   */\n  function repayBorrowBehalfInternal(\n    address borrower,\n    uint repayAmount\n  ) internal nonReentrant {\n    accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    repayBorrowFresh(msg.sender, borrower, repayAmount);\n  }\n\n  /**\n   * @notice Borrows are repaid by another user (possibly the borrower).\n   * @param payer the account paying off the borrow\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount\n   * @return (uint) the actual repayment amount.\n   */\n  function repayBorrowFresh(\n    address payer,\n    address borrower,\n    uint repayAmount\n  ) internal returns (uint) {\n    /* Revert if not KYC'd */\n    require(_getKYCStatus(payer), \"Payer not KYC'd\");\n    require(_getKYCStatus(borrower), \"Borrower not KYC'd\");\n\n    /* Fail if repayBorrow not allowed */\n    uint allowed = comptroller.repayBorrowAllowed(\n      address(this),\n      payer,\n      borrower,\n      repayAmount\n    );\n    if (allowed != 0) {\n      revert RepayBorrowComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert RepayBorrowFreshnessCheck();\n    }\n\n    /* We fetch the amount the borrower owes, with accumulated interest */\n    uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n\n    /* If repayAmount == -1, repayAmount = accountBorrows */\n    uint repayAmountFinal = repayAmount == type(uint).max\n      ? accountBorrowsPrev\n      : repayAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the payer and the repayAmount\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken holds an additional repayAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *   it returns the amount actually transferred, in case of a fee.\n     */\n    uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on underflow:\n     *  accountBorrowsNew = accountBorrows - actualRepayAmount\n     *  totalBorrowsNew = totalBorrows - actualRepayAmount\n     */\n    uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\n    uint totalBorrowsNew = totalBorrows - actualRepayAmount;\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = totalBorrowsNew;\n\n    /* We emit a RepayBorrow event */\n    emit RepayBorrow(\n      payer,\n      borrower,\n      actualRepayAmount,\n      accountBorrowsNew,\n      totalBorrowsNew\n    );\n\n    return actualRepayAmount;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   */\n  function liquidateBorrowInternal(\n    address borrower,\n    uint repayAmount,\n    CTokenInterface cTokenCollateral\n  ) internal nonReentrant {\n    accrueInterest();\n\n    uint error = cTokenCollateral.accrueInterest();\n    if (error != NO_ERROR) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n      revert LiquidateAccrueCollateralInterestFailed(error);\n    }\n\n    // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n    liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n  }\n\n  /**\n   * @notice The liquidator liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param liquidator The address repaying the borrow and seizing collateral\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   */\n  function liquidateBorrowFresh(\n    address liquidator,\n    address borrower,\n    uint repayAmount,\n    CTokenInterface cTokenCollateral\n  ) internal {\n    /* Fail if liquidate not allowed */\n    uint allowed = comptroller.liquidateBorrowAllowed(\n      address(this),\n      address(cTokenCollateral),\n      liquidator,\n      borrower,\n      repayAmount\n    );\n    if (allowed != 0) {\n      revert LiquidateComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert LiquidateFreshnessCheck();\n    }\n\n    /* Verify cTokenCollateral market's block number equals current block number */\n    if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n      revert LiquidateCollateralFreshnessCheck();\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      revert LiquidateLiquidatorIsBorrower();\n    }\n\n    /* Fail if repayAmount = 0 */\n    if (repayAmount == 0) {\n      revert LiquidateCloseAmountIsZero();\n    }\n\n    /* Fail if repayAmount = -1 */\n    if (repayAmount == type(uint).max) {\n      revert LiquidateCloseAmountIsUintMax();\n    }\n\n    /* Fail if repayBorrow fails */\n    uint actualRepayAmount = repayBorrowFresh(\n      liquidator,\n      borrower,\n      repayAmount\n    );\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We calculate the number of collateral tokens that will be seized */\n    (uint amountSeizeError, uint seizeTokens) = comptroller\n      .liquidateCalculateSeizeTokens(\n        address(this),\n        address(cTokenCollateral),\n        actualRepayAmount\n      );\n    require(\n      amountSeizeError == NO_ERROR,\n      \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\"\n    );\n\n    /* Revert if borrower collateral token balance < seizeTokens */\n    require(\n      cTokenCollateral.balanceOf(borrower) >= seizeTokens,\n      \"LIQUIDATE_SEIZE_TOO_MUCH\"\n    );\n\n    // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n    if (address(cTokenCollateral) == address(this)) {\n      seizeInternal(address(this), liquidator, borrower, seizeTokens);\n    } else {\n      require(\n        cTokenCollateral.seize(liquidator, borrower, seizeTokens) == NO_ERROR,\n        \"token seizure failed\"\n      );\n    }\n\n    /* We emit a LiquidateBorrow event */\n    emit LiquidateBorrow(\n      liquidator,\n      borrower,\n      actualRepayAmount,\n      address(cTokenCollateral),\n      seizeTokens\n    );\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Will fail unless called by another cToken during the process of liquidation.\n   *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seize(\n    address liquidator,\n    address borrower,\n    uint seizeTokens\n  ) external override nonReentrant returns (uint) {\n    seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n   *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n   * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   */\n  function seizeInternal(\n    address seizerToken,\n    address liquidator,\n    address borrower,\n    uint seizeTokens\n  ) internal {\n    /* Revert if sanctioned */\n    require(\n      !sanctionsList.isSanctioned(liquidator),\n      \"Liquidator is sanctioned\"\n    );\n    require(!sanctionsList.isSanctioned(borrower), \"Borrower is sanctioned\");\n\n    /* Fail if seize not allowed */\n    uint allowed = comptroller.seizeAllowed(\n      address(this),\n      seizerToken,\n      liquidator,\n      borrower,\n      seizeTokens\n    );\n    if (allowed != 0) {\n      revert LiquidateSeizeComptrollerRejection(allowed);\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      revert LiquidateSeizeLiquidatorIsBorrower();\n    }\n\n    /*\n     * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n     *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n     *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n     */\n    uint protocolSeizeTokens = mul_(\n      seizeTokens,\n      Exp({mantissa: protocolSeizeShareMantissa})\n    );\n    uint liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateStoredInternal()});\n    uint protocolSeizeAmount = mul_ScalarTruncate(\n      exchangeRate,\n      protocolSeizeTokens\n    );\n    uint totalReservesNew = totalReserves + protocolSeizeAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the calculated values into storage */\n    totalReserves = totalReservesNew;\n    totalSupply = totalSupply - protocolSeizeTokens;\n    accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\n    accountTokens[liquidator] =\n      accountTokens[liquidator] +\n      liquidatorSeizeTokens;\n\n    /* Emit a Transfer event */\n    emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\n    emit Transfer(borrower, address(this), protocolSeizeTokens);\n    emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPendingAdmin(\n    address payable newPendingAdmin\n  ) external override returns (uint) {\n    // Check caller = admin\n    if (msg.sender != admin) {\n      revert SetPendingAdminOwnerCheck();\n    }\n\n    // Save current value, if any, for inclusion in log\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store pendingAdmin with value newPendingAdmin\n    pendingAdmin = newPendingAdmin;\n\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptAdmin() external override returns (uint) {\n    // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n      revert AcceptAdminPendingAdminCheck();\n    }\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n\n    // Clear the pending value\n    pendingAdmin = payable(address(0));\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sets a new comptroller for the market\n   * @dev Admin function to set a new comptroller\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setComptroller(\n    ComptrollerInterface newComptroller\n  ) public override returns (uint) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert SetComptrollerOwnerCheck();\n    }\n\n    ComptrollerInterface oldComptroller = comptroller;\n    // Ensure invoke comptroller.isComptroller() returns true\n    require(newComptroller.isComptroller(), \"marker method returned false\");\n\n    // Set market's comptroller to newComptroller\n    comptroller = newComptroller;\n\n    // Emit NewComptroller(oldComptroller, newComptroller)\n    emit NewComptroller(oldComptroller, newComptroller);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n   * @dev Admin function to accrue interest and set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactor(\n    uint newReserveFactorMantissa\n  ) external override nonReentrant returns (uint) {\n    accrueInterest();\n    // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n    return _setReserveFactorFresh(newReserveFactorMantissa);\n  }\n\n  /**\n   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n   * @dev Admin function to set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactorFresh(\n    uint newReserveFactorMantissa\n  ) internal returns (uint) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert SetReserveFactorAdminCheck();\n    }\n\n    // Verify market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert SetReserveFactorFreshCheck();\n    }\n\n    // Check newReserveFactor \u2264 maxReserveFactor\n    if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n      revert SetReserveFactorBoundsCheck();\n    }\n\n    uint oldReserveFactorMantissa = reserveFactorMantissa;\n    reserveFactorMantissa = newReserveFactorMantissa;\n\n    emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring from msg.sender\n   * @param addAmount Amount of addition to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addReservesInternal(\n    uint addAmount\n  ) internal nonReentrant returns (uint) {\n    accrueInterest();\n\n    // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n    _addReservesFresh(addAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Add reserves by transferring from caller\n   * @dev Requires fresh interest accrual\n   * @param addAmount Amount of addition to reserves\n   * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n   */\n  function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n    // totalReserves + actualAddAmount\n    uint totalReservesNew;\n    uint actualAddAmount;\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert AddReservesFactorFreshCheck(actualAddAmount);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the caller and the addAmount\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken holds an additional addAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *  it returns the amount actually transferred, in case of a fee.\n     */\n\n    actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n    totalReservesNew = totalReserves + actualAddAmount;\n\n    // Store reserves[n+1] = reserves[n] + actualAddAmount\n    totalReserves = totalReservesNew;\n\n    /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n    emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n    /* Return (NO_ERROR, actualAddAmount) */\n    return (NO_ERROR, actualAddAmount);\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring to admin\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReserves(\n    uint reduceAmount\n  ) external override nonReentrant returns (uint) {\n    accrueInterest();\n    // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n    return _reduceReservesFresh(reduceAmount);\n  }\n\n  /**\n   * @notice Reduces reserves by transferring to admin\n   * @dev Requires fresh interest accrual\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n    // totalReserves - reduceAmount\n    uint totalReservesNew;\n\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert ReduceReservesAdminCheck();\n    }\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert ReduceReservesFreshCheck();\n    }\n\n    // Fail gracefully if protocol has insufficient underlying cash\n    if (getCashPrior() < reduceAmount) {\n      revert ReduceReservesCashNotAvailable();\n    }\n\n    // Check reduceAmount \u2264 reserves[n] (totalReserves)\n    if (reduceAmount > totalReserves) {\n      revert ReduceReservesCashValidation();\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    totalReservesNew = totalReserves - reduceAmount;\n\n    // Store reserves[n+1] = reserves[n] - reduceAmount\n    totalReserves = totalReservesNew;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(admin, reduceAmount);\n\n    emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n   * @dev Admin function to accrue interest and update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModel(\n    InterestRateModel newInterestRateModel\n  ) public override returns (uint) {\n    accrueInterest();\n    // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n    return _setInterestRateModelFresh(newInterestRateModel);\n  }\n\n  /**\n   * @notice updates the interest rate model (*requires fresh interest accrual)\n   * @dev Admin function to update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModelFresh(\n    InterestRateModel newInterestRateModel\n  ) internal returns (uint) {\n    // Used to store old model for use in the event that is emitted on success\n    InterestRateModel oldInterestRateModel;\n\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert SetInterestRateModelOwnerCheck();\n    }\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert SetInterestRateModelFreshCheck();\n    }\n\n    // Track the market's current interest rate model\n    oldInterestRateModel = interestRateModel;\n\n    // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n    require(\n      newInterestRateModel.isInterestRateModel(),\n      \"marker method returned false\"\n    );\n\n    // Set the interest rate model to newInterestRateModel\n    interestRateModel = newInterestRateModel;\n\n    // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n    emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n    return NO_ERROR;\n  }\n\n  /*** KYC ***/\n\n  /**\n   * @notice Update KYC group of the contract for which\n   *         accounts are checked against\n   *\n   * @param _kycRequirementGroup The new KYC requirement group\n   */\n  function setKYCRequirementGroup(uint256 _kycRequirementGroup) external {\n    require(msg.sender == admin, \"Only admin can set KYC requirement group\");\n    _setKYCRequirementGroup(_kycRequirementGroup);\n  }\n\n  /**\n   * @notice Sets the KYC registry requirement group for this\n   *         client to check kyc status for\n   *\n   * @param _kycRequirementGroup The new KYC group\n   */\n  function _setKYCRequirementGroup(uint256 _kycRequirementGroup) internal {\n    uint256 oldKYCLevel = kycRequirementGroup;\n    kycRequirementGroup = _kycRequirementGroup;\n    emit KYCRequirementGroupSet(oldKYCLevel, _kycRequirementGroup);\n  }\n\n  /**\n   * @notice Update KYC registry address\n   *\n   * @param _kycRegistry The new KYC registry address\n   */\n  function setKYCRegistry(address _kycRegistry) external {\n    require(msg.sender == admin, \"Only admin can set KYC registry\");\n    _setKYCRegistry(_kycRegistry);\n  }\n\n  /**\n   * @notice Sets the KYC registry address for this client\n   *\n   * @param _kycRegistry The new KYC registry address\n   */\n  function _setKYCRegistry(address _kycRegistry) internal {\n    require(_kycRegistry != address(0), \"KYC registry cannot be zero address\");\n    address oldKYCRegistry = address(kycRegistry);\n    kycRegistry = IKYCRegistry(_kycRegistry);\n    emit KYCRegistrySet(oldKYCRegistry, _kycRegistry);\n  }\n\n  /**\n   * @notice Checks whether an address has been KYC'd\n   *\n   * @param account The address to check\n   */\n  function _getKYCStatus(address account) internal view returns (bool) {\n    return kycRegistry.getKYCStatus(kycRequirementGroup, account);\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying owned by this contract\n   */\n  function getCashPrior() internal view virtual returns (uint);\n\n  /**\n   * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n   *  This may revert due to insufficient balance or insufficient allowance.\n   */\n  function doTransferIn(\n    address from,\n    uint amount\n  ) internal virtual returns (uint);\n\n  /**\n   * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\n   *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n   *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n   */\n  function doTransferOut(address payable to, uint amount) internal virtual;\n\n  /*** Reentrancy Guard ***/\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   */\n  modifier nonReentrant() {\n    require(_notEntered, \"re-entered\");\n    _notEntered = false;\n    _;\n    _notEntered = true; // get a gas-refund post-Istanbul\n  }\n}\n\n\n",
        "CodeNames": [
            "CTokenModified.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CTokenModified.sol",
                "Type": "Arithmetic",
                "Description": "The exchange rate is dependent upon the ratio of CToken's totalSupply and underlying token balance of CToken contract, which can be manipulated by an attacker to steal funds of initial depositors of a freshly deployed CToken contract.",
                "Repair": "Enforce a minimum deposit that cannot be withdrawn by minting a small amount of CToken units to 0x00 address on the first deposit"
            }
        ]
    },
    {
        "Code": "/**SPDX-License-Identifier: BUSL-1.1\n\n      \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\n   \u2553\u2588\u2588\u2580\u2514 ,\u2553\u2584\u2584\u2584, '\u2580\u2588\u2588\u2584\n  \u2588\u2588\u2580 \u2584\u2588\u2588\u2580\u2580\u2559\u2559\u2580\u2580\u2588\u2588\u2584 \u2514\u2588\u2588\u00b5           ,,       ,,      ,     ,,,            ,,,\n \u2588\u2588 ,\u2588\u2588\u00ac \u2584\u2588\u2588\u2588\u2588\u2584  \u2580\u2588\u2584 \u2559\u2588\u2584      \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2584   \u2588\u2588\u2588\u2584    \u2588\u2588  \u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584    \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588,\n\u2588\u2588  \u2588\u2588 \u2552\u2588\u2580'   \u2559\u2588\u258c \u2559\u2588\u258c \u2588\u2588     \u2590\u2588\u2588      \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588,  \u2588\u2588  \u2588\u2588\u258c    \u2514\u2588\u2588\u258c  \u2588\u2588\u258c     \u2514\u2588\u2588\u258c\n\u2588\u2588 \u2590\u2588\u258c \u2588\u2588      \u255f\u2588  \u2588\u258c \u255f\u2588     \u2588\u2588\u258c      \u2590\u2588\u2588  \u2588\u2588 \u2514\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u258c     \u255f\u2588\u2588 j\u2588\u2588       \u255f\u2588\u2588\n\u255f\u2588  \u2588\u2588 \u2559\u2588\u2588    \u2584\u2588\u2580 \u2590\u2588\u258c \u2588\u2588     \u2559\u2588\u2588      \u2588\u2588\u258c  \u2588\u2588   \u2559\u2588\u2588\u2588\u2588  \u2588\u2588\u258c    \u2584\u2588\u2588\u2580  \u2588\u2588\u258c     ,\u2588\u2588\u2580\n \u2588\u2588 \"\u2588\u2588, \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310      \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580   \u2588\u2588     \u2559\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580     \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`\n  \u2588\u2588\u2584 \u2559\u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584,,,                \u00ac\u2500                                    '\u2500\u00ac\n   \u2559\u2580\u2588\u2588\u2584 '\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\n      \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588R\u2310\n */\npragma solidity 0.8.16;\n\nimport \"contracts/cash/interfaces/ICashManager.sol\";\nimport \"contracts/cash/interfaces/IMulticall.sol\";\nimport \"contracts/cash/token/Cash.sol\";\nimport \"contracts/cash/kyc/KYCRegistryClientConstructable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/security/Pausable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/token/SafeERC20.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/cash/external/openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract CashManager is\n  ICashManager,\n  IMulticall,\n  AccessControlEnumerable,\n  KYCRegistryClientConstructable,\n  Pausable,\n  ReentrancyGuard\n{\n  using SafeERC20 for IERC20;\n\n  /// @dev Tokens\n  // ERC20 token used to Mint CASH with\n  IERC20 public immutable collateral;\n\n  // CASH contract\n  Cash public immutable cash;\n\n  /// @dev Collateral Recipients\n  // The address to which the `collateral` is sent\n  address public assetRecipient;\n\n  // The address to which fees are sent\n  address public feeRecipient;\n\n  // The address from which redemptions are processed\n  address public assetSender;\n\n  /// @dev Mint/Redeem Parameters\n  // Minimum amount that must be deposited to mint CASH\n  // Denoted in decimals of `collateral`\n  uint256 public minimumDepositAmount = 10_000;\n\n  // Minimum amount that must be redeemed for a withdraw request\n  uint256 public minimumRedeemAmount;\n\n  // Minting fee specified in basis points\n  uint256 public mintFee = 0;\n\n  // Limit for how far `exchangeRate` can stray from\n  // `lastSetMintExchangeRate` within an epoch (in basis points)\n  uint256 public exchangeRateDeltaLimit = 100;\n\n  // Struct representing all redemption requests in an epoch\n  struct RedemptionRequests {\n    // Total CASH burned in the epoch\n    uint256 totalBurned;\n    // Mapping from address to amount of CASH address burned\n    mapping(address => uint256) addressToBurnAmt;\n  }\n\n  // Mapping from epoch to redemption info struct for that epoch\n  mapping(uint256 => RedemptionRequests) public redemptionInfoPerEpoch;\n\n  // Mapping used for getting the exchange rate during a given epoch\n  mapping(uint256 => uint256) public epochToExchangeRate;\n\n  // Nested mapping containing mint requests for an epoch\n  // { <epoch> : {<user> : <collateralAmount> }\n  mapping(uint256 => mapping(address => uint256)) public mintRequestsPerEpoch;\n\n  // Helper constant that allows us to specify basis points in calculations\n  uint256 public constant BPS_DENOMINATOR = 10_000;\n\n  // Decimal multiplier representing the difference between `CASH` decimals\n  // In `collateral` token decimals\n  uint256 public immutable decimalsMultiplier;\n\n  /// @dev Epoch Parameters\n  // Epoch that contract is currently in\n  uint256 public currentEpoch;\n\n  // Duration of an epoch in seconds\n  uint256 public epochDuration;\n\n  // Timestamp of the start of `currentEpoch`\n  uint256 public currentEpochStartTimestamp;\n\n  // `exchangeRate` at start of `currentEpoch`\n  uint256 public lastSetMintExchangeRate = 1e6;\n\n  /// @dev Mint/Redeem Limit Parameters\n  // Maximum amount that can be minted during an epoch\n  uint256 public mintLimit;\n\n  // Amount already minted during the `currentEpoch`\n  uint256 public currentMintAmount;\n\n  // Maximum amount that can be redeemed during an epoch\n  uint256 public redeemLimit;\n\n  // Amount already redeemed during the `currentEpoch`\n  uint256 public currentRedeemAmount;\n\n  /// @dev Role Based Access control members\n  bytes32 public constant MANAGER_ADMIN = keccak256(\"MANAGER_ADMIN\");\n  bytes32 public constant PAUSER_ADMIN = keccak256(\"PAUSER_ADMIN\");\n  bytes32 public constant SETTER_ADMIN = keccak256(\"SETTER_ADMIN\");\n\n  /// @notice constructor\n  constructor(\n    address _collateral,\n    address _cash,\n    address managerAdmin,\n    address pauser,\n    address _assetRecipient,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _mintLimit,\n    uint256 _redeemLimit,\n    uint256 _epochDuration,\n    address _kycRegistry,\n    uint256 _kycRequirementGroup\n  ) KYCRegistryClientConstructable(_kycRegistry, _kycRequirementGroup) {\n    if (_collateral == address(0)) {\n      revert CollateralZeroAddress();\n    }\n    if (_cash == address(0)) {\n      revert CashZeroAddress();\n    }\n    if (_assetRecipient == address(0)) {\n      revert AssetRecipientZeroAddress();\n    }\n    if (_assetSender == address(0)) {\n      revert AssetSenderZeroAddress();\n    }\n    if (_feeRecipient == address(0)) {\n      revert FeeRecipientZeroAddress();\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, managerAdmin);\n    _grantRole(MANAGER_ADMIN, managerAdmin);\n    _setRoleAdmin(PAUSER_ADMIN, MANAGER_ADMIN);\n    _setRoleAdmin(SETTER_ADMIN, MANAGER_ADMIN);\n    _grantRole(PAUSER_ADMIN, pauser);\n\n    collateral = IERC20(_collateral);\n    cash = Cash(_cash);\n    feeRecipient = _feeRecipient;\n    assetRecipient = _assetRecipient;\n    assetSender = _assetSender;\n    currentEpoch = currentEpoch;\n\n    mintLimit = _mintLimit;\n    redeemLimit = _redeemLimit;\n    epochDuration = _epochDuration;\n\n    currentEpochStartTimestamp =\n      block.timestamp -\n      (block.timestamp % epochDuration);\n\n    // Implicit constraint: cash decimals >= collateral decimals.\n    decimalsMultiplier =\n      10 **\n        (IERC20Metadata(_cash).decimals() -\n          IERC20Metadata(_collateral).decimals());\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Mint Logic\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function used by users to submit a request to mint\n   *\n   * @param collateralAmountIn The amount of collateral one wishes to deposit\n   *                           to mint CASH tokens\n   */\n  function requestMint(\n    uint256 collateralAmountIn\n  )\n    external\n    override\n    updateEpoch\n    nonReentrant\n    whenNotPaused\n    checkKYC(msg.sender)\n  {\n    if (collateralAmountIn < minimumDepositAmount) {\n      revert MintRequestAmountTooSmall();\n    }\n\n    uint256 feesInCollateral = _getMintFees(collateralAmountIn);\n    uint256 depositValueAfterFees = collateralAmountIn - feesInCollateral;\n\n    _checkAndUpdateMintLimit(depositValueAfterFees);\n\n    collateral.safeTransferFrom(msg.sender, feeRecipient, feesInCollateral);\n    collateral.safeTransferFrom(\n      msg.sender,\n      assetRecipient,\n      depositValueAfterFees\n    );\n\n    mintRequestsPerEpoch[currentEpoch][msg.sender] += depositValueAfterFees;\n\n    emit MintRequested(\n      msg.sender,\n      currentEpoch,\n      collateralAmountIn,\n      depositValueAfterFees,\n      feesInCollateral\n    );\n  }\n\n  /**\n   * @notice Function used by users to claim an airdrop for a given epoch\n   *\n   * @param user       The user who requested to mint\n   * @param epochToClaim The epoch in which the mint was requested\n   *\n   * @dev We perform KYC check on the user destined to receive `cash`, not the\n   *      msg.sender\n   */\n  function claimMint(\n    address user,\n    uint256 epochToClaim\n  ) external override updateEpoch nonReentrant whenNotPaused checkKYC(user) {\n    uint256 collateralDeposited = mintRequestsPerEpoch[epochToClaim][user];\n    if (collateralDeposited == 0) {\n      revert NoCashToClaim();\n    }\n    if (epochToExchangeRate[epochToClaim] == 0) {\n      revert ExchangeRateNotSet();\n    }\n\n    // Get the amount of CASH due at a given rate per epoch\n    uint256 cashOwed = _getMintAmountForEpoch(\n      collateralDeposited,\n      epochToClaim\n    );\n\n    mintRequestsPerEpoch[epochToClaim][user] = 0;\n    cash.mint(user, cashOwed);\n\n    emit MintCompleted(\n      user,\n      cashOwed,\n      collateralDeposited,\n      epochToExchangeRate[epochToClaim],\n      epochToClaim\n    );\n  }\n\n  /**\n   * @notice Sets mint exchange rate\n   *\n   * @param exchangeRate New mint exchange rate (in 6 decimals)\n   * @param epochToSet   The epoch we want to set the exchange rate for\n   *\n   * @dev If the exchange rate differs more than `exchangeRateDeltaLimit`\n   *      from the last exchange rate set, the entire contract will be paused.\n   *      See `overrideExchangeRate` should this check need to be bypassed\n   */\n  function setMintExchangeRate(\n    uint256 exchangeRate,\n    uint256 epochToSet\n  ) external override updateEpoch onlyRole(SETTER_ADMIN) {\n    if (exchangeRate == 0) {\n      revert ZeroExchangeRate();\n    }\n    if (epochToSet >= currentEpoch) {\n      revert EpochNotElapsed();\n    }\n    if (epochToExchangeRate[epochToSet] != 0) {\n      revert EpochExchangeRateAlreadySet();\n    }\n\n    uint256 rateDifference;\n    if (exchangeRate > lastSetMintExchangeRate) {\n      rateDifference = exchangeRate - lastSetMintExchangeRate;\n    } else if (exchangeRate < lastSetMintExchangeRate) {\n      rateDifference = lastSetMintExchangeRate - exchangeRate;\n    }\n\n    uint256 maxDifferenceThisEpoch = (lastSetMintExchangeRate *\n      exchangeRateDeltaLimit) / BPS_DENOMINATOR;\n\n    if (rateDifference > maxDifferenceThisEpoch) {\n      epochToExchangeRate[epochToSet] = exchangeRate;\n      _pause();\n      emit MintExchangeRateCheckFailed(\n        epochToSet,\n        lastSetMintExchangeRate,\n        exchangeRate\n      );\n    } else {\n      uint256 oldExchangeRate = lastSetMintExchangeRate;\n      epochToExchangeRate[epochToSet] = exchangeRate;\n      lastSetMintExchangeRate = exchangeRate;\n      emit MintExchangeRateSet(epochToSet, oldExchangeRate, exchangeRate);\n    }\n  }\n\n  /**\n   * @notice Override admin function for changing the representation of the\n   *         amount of collateral a user has deposited to kick off minting\n   *         process\n   *\n   * @param user       The user whose balance is being set\n   * @param epoch      The epoch in which to set user balance for\n   * @param oldBalance The user's previous balance\n   * @param newBalance The user's new balance to set\n   *\n   * @dev The total burned amount for the epoch must be set appropriately\n   *      in order to correctly calculate redemptions.\n   * @dev `oldBalance` is provided to prevent front running attacks where a\n   *      user could attempt to claim before and after this is set.\n   */\n  function setPendingMintBalance(\n    address user,\n    uint256 epoch,\n    uint256 oldBalance,\n    uint256 newBalance\n  ) external updateEpoch onlyRole(MANAGER_ADMIN) {\n    if (oldBalance != mintRequestsPerEpoch[epoch][user]) {\n      revert UnexpectedMintBalance();\n    }\n    if (epoch > currentEpoch) {\n      revert CannotServiceFutureEpoch();\n    }\n    mintRequestsPerEpoch[epoch][user] = newBalance;\n    emit PendingMintBalanceSet(user, epoch, oldBalance, newBalance);\n  }\n\n  /**\n   * @notice Allows for the `MANAGER_ADMIN` to arbitrarily set an exchange\n   *         rate for a given epoch\n   *\n   * @param correctExchangeRate      The exchange rate we wish to update to\n   * @param epochToSet               The epoch for which we want to set the rate\n   * @param _lastSetMintExchangeRate Value to set `lastSetMintExchangeRate` to\n   *                                 if not equal to 0\n   *\n   * @dev This function allows the caller to also update the\n   *      `lastSetMintExchangeRate`, which is compared against\n   *      when calling `setMintExchangeRate` to prevent large\n   *      swings in prices.\n   */\n  function overrideExchangeRate(\n    uint256 correctExchangeRate,\n    uint256 epochToSet,\n    uint256 _lastSetMintExchangeRate\n  ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n    if (epochToSet >= currentEpoch) {\n      revert MustServicePastEpoch();\n    }\n    uint256 incorrectRate = epochToExchangeRate[epochToSet];\n    epochToExchangeRate[epochToSet] = correctExchangeRate;\n    if (_lastSetMintExchangeRate != 0) {\n      lastSetMintExchangeRate = _lastSetMintExchangeRate;\n    }\n    emit MintExchangeRateOverridden(\n      epochToSet,\n      incorrectRate,\n      correctExchangeRate,\n      lastSetMintExchangeRate\n    );\n  }\n\n  /**\n   * @notice Sets mint exchange rate delta limit\n   *\n   * @param _exchangeRateDeltaLimit New mint exchange rate delta limit (in bps)\n   */\n  function setMintExchangeRateDeltaLimit(\n    uint256 _exchangeRateDeltaLimit\n  ) external override onlyRole(MANAGER_ADMIN) {\n    uint256 oldExchangeRateDeltaLimit = exchangeRateDeltaLimit;\n    exchangeRateDeltaLimit = _exchangeRateDeltaLimit;\n    emit ExchangeRateDeltaLimitSet(\n      oldExchangeRateDeltaLimit,\n      _exchangeRateDeltaLimit\n    );\n  }\n\n  /**\n   * @notice Sets mint fee\n   *\n   * @param _mintFee new mint fee specified in basis points\n   *\n   * @dev The maximum fee that can be set is 10_000 bps, or 100%\n   */\n  function setMintFee(\n    uint256 _mintFee\n  ) external override onlyRole(MANAGER_ADMIN) {\n    if (_mintFee >= BPS_DENOMINATOR) {\n      revert MintFeeTooLarge();\n    }\n    uint256 oldMintFee = mintFee;\n    mintFee = _mintFee;\n    emit MintFeeSet(oldMintFee, _mintFee);\n  }\n\n  /**\n   * @notice Sets minimum deposit amount\n   *\n   * @param _minimumDepositAmount New minimum deposit amount\n   *                              (in decimals specified by `collateral`)\n   *\n   * @dev Must be larger than BPS_DENOMINATOR due to keep our `_getMintFees`\n   *      calculation correct. For example, if a deposit amount is less than\n   *      BPS_DENOMINAOR (say 9999) and `mintFee` = 1,\n   *      (collateralAmount * mintFee) / BPS_DENOMINATOR will incorrectly\n   *      return 0.\n   */\n  function setMinimumDepositAmount(\n    uint256 _minimumDepositAmount\n  ) external override onlyRole(MANAGER_ADMIN) {\n    if (_minimumDepositAmount < BPS_DENOMINATOR) {\n      revert MinimumDepositAmountTooSmall();\n    }\n    uint256 oldMinimumDepositAmount = minimumDepositAmount;\n    minimumDepositAmount = _minimumDepositAmount;\n    emit MinimumDepositAmountSet(\n      oldMinimumDepositAmount,\n      _minimumDepositAmount\n    );\n  }\n\n  /**\n   * @notice Sets fee recipient\n   *\n   * @param _feeRecipient New fee recipient address\n   */\n  function setFeeRecipient(\n    address _feeRecipient\n  ) external override onlyRole(MANAGER_ADMIN) {\n    address oldFeeRecipient = feeRecipient;\n    feeRecipient = _feeRecipient;\n    emit FeeRecipientSet(oldFeeRecipient, _feeRecipient);\n  }\n\n  /**\n   * @notice Sets asset recipient\n   *\n   * @param _assetRecipient New asset recipient address\n   */\n  function setAssetRecipient(\n    address _assetRecipient\n  ) external override onlyRole(MANAGER_ADMIN) {\n    address oldAssetRecipient = assetRecipient;\n    assetRecipient = _assetRecipient;\n    emit AssetRecipientSet(oldAssetRecipient, _assetRecipient);\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how much CASH should be\n   *         minted\n   *\n   * @param collateralAmountIn Amount of `collateral` to exchange\n   *                           (in 18 decimals)\n   * @param epoch              The epoch we want to set the rate\n   *                           for\n   *\n   * @return cashAmountOut The amount of cash to be returned\n   *\n   * @dev Scales to 24 decimals to divide by exchange rate in 6 decimals,\n   *      bringing us down to 18 decimals of precision\n   */\n  function _getMintAmountForEpoch(\n    uint256 collateralAmountIn,\n    uint256 epoch\n  ) private view returns (uint256 cashAmountOut) {\n    uint256 amountE24 = _scaleUp(collateralAmountIn) * 1e6;\n    cashAmountOut = amountE24 / epochToExchangeRate[epoch];\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how\n   *\n   *\n   * @param collateralAmount Amount `collateral` to exchange\n   *                         (in decimals of `collateral`)\n   */\n  function _getMintFees(\n    uint256 collateralAmount\n  ) private view returns (uint256) {\n    return (collateralAmount * mintFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Scale provided amount up by `decimalsMultiplier`\n   *\n   * @dev This helper is used for converting the collateral's decimals\n   *      representation to the CASH amount decimals representation.\n   */\n  function _scaleUp(uint256 amount) private view returns (uint256) {\n    return amount * decimalsMultiplier;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Pause Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Will pause minting functionality of this contract\n   *\n   */\n  function pause() external onlyRole(PAUSER_ADMIN) {\n    _pause();\n  }\n\n  /**\n   * @notice Will unpause minting functionality of this contract\n   */\n  function unpause() external onlyRole(MANAGER_ADMIN) {\n    _unpause();\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    Epoch and Rate Limiting Logic\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Update the duration of one epoch\n   *\n   * @param _epochDuration The epoch duration in seconds\n   */\n  function setEpochDuration(\n    uint256 _epochDuration\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldEpochDuration = epochDuration;\n    epochDuration = _epochDuration;\n    emit EpochDurationSet(oldEpochDuration, _epochDuration);\n  }\n\n  /**\n   * @notice Modifier to transition epoch\n   */\n  modifier updateEpoch() {\n    transitionEpoch();\n    _;\n  }\n\n  /**\n   * @notice Transition to another epoch\n   *\n   * @dev Should be called prior to `_checkAndUpdateRedeemLimit`\n   *      and `_checkAndUpdateMintLimit`\n   * @dev Epochs do not always have to be incremented by 1\n   *\n   * @notice If this function determines to transition the epoch\n   *         1) The total supply at the end of the epoch is stored\n   *         2) `currentRedeemAmount` & `currentMintAmount` are set to 0\n   *         3) `currentEpoch` is incremented by number of epochs that\n   *            have elapsed\n   *         4) `currentEpochStartTimestamp` is set.\n   */\n  function transitionEpoch() public {\n    uint256 epochDifference = (block.timestamp - currentEpochStartTimestamp) /\n      epochDuration;\n    if (epochDifference > 0) {\n      currentRedeemAmount = 0;\n      currentMintAmount = 0;\n      currentEpoch += epochDifference;\n      currentEpochStartTimestamp =\n        block.timestamp -\n        (block.timestamp % epochDuration);\n    }\n  }\n\n  /**\n   * @notice Update the amount of token that can be minted during one epoch\n   *\n   * @param _mintLimit The token amount\n   *\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  function setMintLimit(uint256 _mintLimit) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldMintLimit = mintLimit;\n    mintLimit = _mintLimit;\n    emit MintLimitSet(oldMintLimit, _mintLimit);\n  }\n\n  /**\n   * @notice Update the amount of token that can be redeemed during one epoch\n   *\n   * @param _redeemLimit The token amount\n   *\n   * @dev If a limit is zero, the relevant check always fails.\n   */\n  function setRedeemLimit(\n    uint256 _redeemLimit\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldRedeemLimit = redeemLimit;\n    redeemLimit = _redeemLimit;\n    emit RedeemLimitSet(oldRedeemLimit, _redeemLimit);\n  }\n\n  /**\n   * @notice Checks the requested mint amount against the rate limiter\n   *\n   * @param collateralAmountIn The requested mint amount\n   *\n   * @dev Reverts if the requested mint amount exceeds the current limit\n   * @dev Should only be called w/n functions w/ `updateEpoch` modifier\n   */\n  function _checkAndUpdateMintLimit(uint256 collateralAmountIn) private {\n    if (collateralAmountIn > mintLimit - currentMintAmount) {\n      revert MintExceedsRateLimit();\n    }\n\n    currentMintAmount += collateralAmountIn;\n  }\n\n  /**\n   * @notice Checks the requested redeem amount against the rate limiter\n   *\n   * @param amount The requested redeem amount\n   *\n   * @dev Reverts if the requested redeem amount exceeds the current limit\n   * @dev Should only be called w/n function w/ `updateEpoch` modifier\n   */\n  function _checkAndUpdateRedeemLimit(uint256 amount) private {\n    if (amount == 0) {\n      revert RedeemAmountCannotBeZero();\n    }\n    if (amount > redeemLimit - currentRedeemAmount) {\n      revert RedeemExceedsRateLimit();\n    }\n\n    currentRedeemAmount += amount;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Redeem Logic\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Adds a RedemptionRequests member to the current epoch array &\n   *         burns tokens\n   *\n   * @param amountCashToRedeem The requested redeem amount\n   */\n  function requestRedemption(\n    uint256 amountCashToRedeem\n  )\n    external\n    override\n    updateEpoch\n    nonReentrant\n    whenNotPaused\n    checkKYC(msg.sender)\n  {\n    if (amountCashToRedeem < minimumRedeemAmount) {\n      revert WithdrawRequestAmountTooSmall();\n    }\n\n    _checkAndUpdateRedeemLimit(amountCashToRedeem);\n\n    redemptionInfoPerEpoch[currentEpoch].addressToBurnAmt[\n        msg.sender\n      ] += amountCashToRedeem;\n    redemptionInfoPerEpoch[currentEpoch].totalBurned += amountCashToRedeem;\n\n    cash.burnFrom(msg.sender, amountCashToRedeem);\n\n    emit RedemptionRequested(msg.sender, amountCashToRedeem, currentEpoch);\n  }\n\n  /**\n   * @notice Allows for an admin account to distribute collateral to users\n   *         based off of the total amount of cash tokens burned w/n a given\n   *         epoch. This function also allows for an admin to refund redemption\n   *         requests w/n an epoch provided that the redemption cannot be\n   *         serviced\n   *\n   * @param redeemers              List of addresses to which we want to\n   *                               issue redemptions to\n   * @param refundees              List of addresses to which we want to issue\n   *                               refunds to in the form of cash tokens\n   * @param collateralAmountToDist The total amount to distribute for redemptions\n   *                               including fees to accrue to Ondo\n   *                               (In units of collateral)\n   * @param epochToService         The epoch number we wish to issue redemptions/\n   *                               refunds for\n   * @param fees                   The amount of fees to send to Ondo\n   *                               (In units of collateral)\n   */\n  function completeRedemptions(\n    address[] calldata redeemers,\n    address[] calldata refundees,\n    uint256 collateralAmountToDist,\n    uint256 epochToService,\n    uint256 fees\n  ) external override updateEpoch onlyRole(MANAGER_ADMIN) {\n    _checkAddressesKYC(redeemers);\n    _checkAddressesKYC(refundees);\n    if (epochToService >= currentEpoch) {\n      revert MustServicePastEpoch();\n    }\n    // Calculate the total quantity of shares tokens burned w/n an epoch\n    uint256 refundedAmt = _processRefund(refundees, epochToService);\n    uint256 quantityBurned = redemptionInfoPerEpoch[epochToService]\n      .totalBurned - refundedAmt;\n    uint256 amountToDist = collateralAmountToDist - fees;\n    _processRedemption(redeemers, amountToDist, quantityBurned, epochToService);\n    collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n    emit RedemptionFeesCollected(feeRecipient, fees, epochToService);\n  }\n\n  /**\n   * @notice Will iterate over the array of `addressToWithdraw` calculate\n   *         the proportion of burned tokens w/n a given epoch and will\n   *         then distribute collateral based off this % of burned tokens\n   *\n   * @param redeemers      List of addresses we are issuing redemptions too\n   * @param amountToDist   The amount to distribute to clients minus the\n   *                       the fee amount taken by Ondo\n   * @param quantityBurned The total amount of tokens burned in an epoch\n   *                       minus those burned by users who are issued a\n   *                       refund\n   * @param epochToService The epoch we wish to service redemptions and\n   *                       redemptions for\n   */\n  function _processRedemption(\n    address[] calldata redeemers,\n    uint256 amountToDist,\n    uint256 quantityBurned,\n    uint256 epochToService\n  ) private {\n    uint256 size = redeemers.length;\n    for (uint256 i = 0; i < size; ++i) {\n      address redeemer = redeemers[i];\n      uint256 cashAmountReturned = redemptionInfoPerEpoch[epochToService]\n        .addressToBurnAmt[redeemer];\n      redemptionInfoPerEpoch[epochToService].addressToBurnAmt[redeemer] = 0;\n      uint256 collateralAmountDue = (amountToDist * cashAmountReturned) /\n        quantityBurned;\n\n      if (collateralAmountDue == 0) {\n        revert CollateralRedemptionTooSmall();\n      }\n\n      collateral.safeTransferFrom(assetSender, redeemer, collateralAmountDue);\n      emit RedemptionCompleted(\n        redeemer,\n        cashAmountReturned,\n        collateralAmountDue,\n        epochToService\n      );\n    }\n  }\n\n  /**\n   * @notice Iterates over the array of `addressToRefund` and mint them\n   *         back the same quantity of cash tokens burned.\n   *\n   * @param refundees      List of addresses we are issuing refunds for\n   * @param epochToService The epoch we wish to service redemptions for\n   *\n   * @return totalCashAmountRefunded The total amount of cash refunded for `epochToService`.\n   */\n  function _processRefund(\n    address[] calldata refundees,\n    uint256 epochToService\n  ) private returns (uint256 totalCashAmountRefunded) {\n    uint256 size = refundees.length;\n    for (uint256 i = 0; i < size; ++i) {\n      address refundee = refundees[i];\n      uint256 cashAmountBurned = redemptionInfoPerEpoch[epochToService]\n        .addressToBurnAmt[refundee];\n      redemptionInfoPerEpoch[epochToService].addressToBurnAmt[refundee] = 0;\n      cash.mint(refundee, cashAmountBurned);\n      totalCashAmountRefunded += cashAmountBurned;\n      emit RefundIssued(refundee, cashAmountBurned, epochToService);\n    }\n    return totalCashAmountRefunded;\n  }\n\n  /**\n   * @notice will change the `assetSender` variable\n   *\n   * @param newAssetSender The address we wish to change `assetSender` too\n   */\n  function setAssetSender(\n    address newAssetSender\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldAssetSender = assetSender;\n    assetSender = newAssetSender;\n    emit AssetSenderSet(oldAssetSender, newAssetSender);\n  }\n\n  /**\n   * @notice Allows for `MANAGER_ADMIN` to set a new `minimumRedeemAmount`\n   *\n   * @param newRedeemMinimum The new minimum redemption amount\n   *                         in units of 1e18\n   */\n  function setRedeemMinimum(\n    uint256 newRedeemMinimum\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldRedeemMin = minimumRedeemAmount;\n    minimumRedeemAmount = newRedeemMinimum;\n    emit MinimumRedeemAmountSet(oldRedeemMin, minimumRedeemAmount);\n  }\n\n  /**\n   * @notice Custom view function to return the quantity burned by\n   *         an address w/n a given epoch.\n   *\n   * @param epoch The epoch we want to query\n   * @param user  The user we want to know the burned quantity\n   *              of cash tokens for in a given epoch\n   */\n  function getBurnedQuantity(\n    uint256 epoch,\n    address user\n  ) external view returns (uint256) {\n    return redemptionInfoPerEpoch[epoch].addressToBurnAmt[user];\n  }\n\n  /**\n   * @notice Override admin function for changing the representation of the\n   *         amount of CASH a user has burned to kick off redemption process\n   *\n   * @param user    The user whose balance is being set\n   * @param epoch   The epoch in which to set user balance for\n   * @param balance The user's new balance\n   *\n   * @dev The total burned amount for the epoch must be set appropriately\n   *      in order to correctly calculate redemptions.\n   */\n  function setPendingRedemptionBalance(\n    address user,\n    uint256 epoch,\n    uint256 balance\n  ) external updateEpoch onlyRole(MANAGER_ADMIN) {\n    if (epoch > currentEpoch) {\n      revert CannotServiceFutureEpoch();\n    }\n    uint256 previousBalance = redemptionInfoPerEpoch[epoch].addressToBurnAmt[\n      user\n    ];\n    // Increment or decrement total burned for the epoch based on whether we\n    // are increasing or decreasing the balance.\n    if (balance < previousBalance) {\n      redemptionInfoPerEpoch[epoch].totalBurned -= previousBalance - balance;\n    } else if (balance > previousBalance) {\n      redemptionInfoPerEpoch[epoch].totalBurned += balance - previousBalance;\n    }\n    redemptionInfoPerEpoch[epoch].addressToBurnAmt[user] = balance;\n    emit PendingRedemptionBalanceSet(\n      user,\n      epoch,\n      balance,\n      redemptionInfoPerEpoch[epoch].totalBurned\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           KYC FUNCTIONS\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Modifier to check KYC status of an account\n   */\n  modifier checkKYC(address account) {\n    _checkKYC(account);\n    _;\n  }\n\n  /**\n   * @notice Update KYC group of the contract for which\n   *         accounts are checked against\n   *\n   * @param _kycRequirementGroup The new KYC requirement group\n   */\n  function setKYCRequirementGroup(\n    uint256 _kycRequirementGroup\n  ) external override onlyRole(MANAGER_ADMIN) {\n    _setKYCRequirementGroup(_kycRequirementGroup);\n  }\n\n  /**\n   * @notice Update KYC registry address\n   *\n   * @param _kycRegistry The new KYC registry address\n   */\n  function setKYCRegistry(\n    address _kycRegistry\n  ) external override onlyRole(MANAGER_ADMIN) {\n    _setKYCRegistry(_kycRegistry);\n  }\n\n  /**\n   * @notice Private function to check KYC status\n   *         of an address\n   *\n   * @param account The account to check KYC status for\n   */\n  function _checkKYC(address account) private view {\n    if (!_getKYCStatus(account)) {\n      revert KYCCheckFailed();\n    }\n  }\n\n  /**\n   * @notice Private function to check KYC status\n   *         of an array of addresses\n   *\n   * @param accounts The accounts to check KYC status for\n   */\n  function _checkAddressesKYC(address[] calldata accounts) private view {\n    uint256 size = accounts.length;\n    for (uint256 i = 0; i < size; ++i) {\n      _checkKYC(accounts[i]);\n    }\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  )\n    external\n    payable\n    override\n    nonReentrant\n    onlyRole(MANAGER_ADMIN)\n    whenPaused\n    returns (bytes[] memory results)\n  {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "CashManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "completeRedemptions() function in CashManager contract",
                "Type": "Loss of user funds",
                "Description": "Refunded amount is not updated in the totalBurned storage variable for the given epoch, causing loss of funds for the users.",
                "Repair": "Update the totalBurned amount to consider refunds resulting from the call to _processRefund"
            },
            {
                "Location": "setPendingRedemptionBalance() function in CashManager contract",
                "Type": "Overwriting user balance",
                "Description": "setPendingRedemptionBalance() does not check old balances, resulting in the possibility of overwriting the new balance added by the user.",
                "Repair": "Add oldBalance check to revert if not equal"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function completeRedemptions()",
                "Type": "Locked Funds",
                "Description": "Sanctioned user's funds are locked and even the admin has no control over it.",
                "Repair": "Remove KYC check for redeemers and refundees or find a way to allow admin to refund or redeem locked funds"
            },
            {
                "Location": "function setEpochDuration()",
                "Type": "Inconsistent Output",
                "Description": "The result of the setEpochDuration function execution can be impacted by any external agent leading to inconsistent output.",
                "Repair": "Add updateEpoch modifier to ensure transitionEpoch is executed before setEpochDuration"
            }
        ]
    }
]