[
    {
        "Code": "/*\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.6.10;\npragma experimental \"ABIEncoderV2\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { SignedSafeMath } from \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\nimport { AddressArrayUtils } from \"../../../lib/AddressArrayUtils.sol\";\nimport { IController } from \"../../../interfaces/IController.sol\";\nimport { IManagerIssuanceHook } from \"../../../interfaces/IManagerIssuanceHook.sol\";\nimport { IModuleIssuanceHook } from \"../../../interfaces/IModuleIssuanceHook.sol\";\nimport { Invoke } from \"../../lib/Invoke.sol\";\nimport { ISetToken } from \"../../../interfaces/ISetToken.sol\";\nimport { ModuleBase } from \"../../lib/ModuleBase.sol\";\nimport { Position } from \"../../lib/Position.sol\";\nimport { PreciseUnitMath } from \"../../../lib/PreciseUnitMath.sol\";\n\n\n/**\n * @title DebtIssuanceModule\n * @author Set Protocol\n *\n * The DebtIssuanceModule is a module that enables users to issue and redeem SetTokens that contain default and all\n * external positions, including debt positions. Module hooks are added to allow for syncing of positions, and component\n * level hooks are added to ensure positions are replicated correctly. The manager can define arbitrary issuance logic\n * in the manager hook, as well as specify issue and redeem fees.\n */\ncontract DebtIssuanceModule is ModuleBase, ReentrancyGuard {\n\n    /* ============ Structs ============ */\n\n    // NOTE: moduleIssuanceHooks uses address[] for compatibility with AddressArrayUtils library\n    struct IssuanceSettings {\n        uint256 maxManagerFee;                          // Max issue/redeem fee defined on instantiation\n        uint256 managerIssueFee;                        // Current manager issuance fees in precise units (10^16 = 1%)\n        uint256 managerRedeemFee;                       // Current manager redeem fees in precise units (10^16 = 1%)\n        address feeRecipient;                           // Address that receives all manager issue and redeem fees\n        IManagerIssuanceHook managerIssuanceHook;       // Instance of manager defined hook, can hold arbitrary logic\n        address[] moduleIssuanceHooks;                  // Array of modules that are registered with this module\n        mapping(address => bool) isModuleHook;          // Mapping of modules to if they've registered a hook\n    }\n\n    /* ============ Events ============ */\n\n    event SetTokenIssued(\n        ISetToken indexed _setToken,\n        address indexed _issuer,\n        address indexed _to,\n        address _hookContract,\n        uint256 _quantity,\n        uint256 _managerFee,\n        uint256 _protocolFee\n    );\n    event SetTokenRedeemed(\n        ISetToken indexed _setToken,\n        address indexed _redeemer,\n        address indexed _to,\n        uint256 _quantity,\n        uint256 _managerFee,\n        uint256 _protocolFee\n    );\n    event FeeRecipientUpdated(ISetToken indexed _setToken, address _newFeeRecipient);\n    event IssueFeeUpdated(ISetToken indexed _setToken, uint256 _newIssueFee);\n    event RedeemFeeUpdated(ISetToken indexed _setToken, uint256 _newRedeemFee);\n\n    /* ============ Constants ============ */\n\n    uint256 private constant ISSUANCE_MODULE_PROTOCOL_FEE_SPLIT_INDEX = 0;\n\n    /* ============ State ============ */\n\n    mapping(ISetToken => IssuanceSettings) public issuanceSettings;\n\n    /* ============ Constructor ============ */\n\n    constructor(IController _controller) public ModuleBase(_controller) {}\n\n    /* ============ External Functions ============ */\n\n    /**\n     * Deposits components to the SetToken, replicates any external module component positions and mints\n     * the SetToken. If the token has a debt position all collateral will be transferred in first then debt\n     * will be returned to the minting address. If specified, a fee will be charged on issuance.\n     *\n     * @param _setToken         Instance of the SetToken to issue\n     * @param _quantity         Quantity of SetToken to issue\n     * @param _to               Address to mint SetToken to\n     */\n    function issue(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _to\n    )\n        external\n        virtual\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        require(_quantity > 0, \"Issue quantity must be > 0\");\n\n        address hookContract = _callManagerPreIssueHooks(_setToken, _quantity, msg.sender, _to);\n\n        _callModulePreIssueHooks(_setToken, _quantity);\n\n        (\n            uint256 quantityWithFees,\n            uint256 managerFee,\n            uint256 protocolFee\n        ) = calculateTotalFees(_setToken, _quantity, true);\n\n        (\n            address[] memory components,\n            uint256[] memory equityUnits,\n            uint256[] memory debtUnits\n        ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityWithFees, true);\n\n        _resolveEquityPositions(_setToken, quantityWithFees, _to, true, components, equityUnits);\n        _resolveDebtPositions(_setToken, quantityWithFees, true, components, debtUnits);\n        _resolveFees(_setToken, managerFee, protocolFee);\n\n        _setToken.mint(_to, _quantity);\n\n        emit SetTokenIssued(\n            _setToken,\n            msg.sender,\n            _to,\n            hookContract,\n            _quantity,\n            managerFee,\n            protocolFee\n        );\n    }\n\n    /**\n     * Returns components from the SetToken, unwinds any external module component positions and burns the SetToken.\n     * If the token has debt positions, the module transfers in the required debt amounts from the caller and uses\n     * those funds to repay the debts on behalf of the SetToken. All debt will be paid down first then equity positions\n     * will be returned to the minting address. If specified, a fee will be charged on redeem.\n     *\n     * @param _setToken         Instance of the SetToken to redeem\n     * @param _quantity         Quantity of SetToken to redeem\n     * @param _to               Address to send collateral to\n     */\n    function redeem(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _to\n    )\n        external\n        virtual\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        require(_quantity > 0, \"Redeem quantity must be > 0\");\n\n        _callModulePreRedeemHooks(_setToken, _quantity);\n\n        // Place burn after pre-redeem hooks because burning tokens may lead to false accounting of synced positions\n        _setToken.burn(msg.sender, _quantity);\n\n        (\n            uint256 quantityNetFees,\n            uint256 managerFee,\n            uint256 protocolFee\n        ) = calculateTotalFees(_setToken, _quantity, false);\n\n        (\n            address[] memory components,\n            uint256[] memory equityUnits,\n            uint256[] memory debtUnits\n        ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityNetFees, false);\n\n        _resolveDebtPositions(_setToken, quantityNetFees, false, components, debtUnits);\n        _resolveEquityPositions(_setToken, quantityNetFees, _to, false, components, equityUnits);\n        _resolveFees(_setToken, managerFee, protocolFee);\n\n        emit SetTokenRedeemed(\n            _setToken,\n            msg.sender,\n            _to,\n            _quantity,\n            managerFee,\n            protocolFee\n        );\n    }\n\n    /**\n     * MANAGER ONLY: Updates address receiving issue/redeem fees for a given SetToken.\n     *\n     * @param _setToken             Instance of the SetToken to update fee recipient\n     * @param _newFeeRecipient      New fee recipient address\n     */\n    function updateFeeRecipient(\n        ISetToken _setToken,\n        address _newFeeRecipient\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_newFeeRecipient != address(0), \"Fee Recipient must be non-zero address.\");\n        require(_newFeeRecipient != issuanceSettings[_setToken].feeRecipient, \"Same fee recipient passed\");\n\n        issuanceSettings[_setToken].feeRecipient = _newFeeRecipient;\n\n        emit FeeRecipientUpdated(_setToken, _newFeeRecipient);\n    }\n\n    /**\n     * MANAGER ONLY: Updates issue fee for passed SetToken\n     *\n     * @param _setToken             Instance of the SetToken to update issue fee\n     * @param _newIssueFee          New fee amount in preciseUnits (1% = 10^16)\n     */\n    function updateIssueFee(\n        ISetToken _setToken,\n        uint256 _newIssueFee\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_newIssueFee <= issuanceSettings[_setToken].maxManagerFee, \"Issue fee can't exceed maximum\");\n        require(_newIssueFee != issuanceSettings[_setToken].managerIssueFee, \"Same issue fee passed\");\n\n        issuanceSettings[_setToken].managerIssueFee = _newIssueFee;\n\n        emit IssueFeeUpdated(_setToken, _newIssueFee);\n    }\n\n    /**\n     * MANAGER ONLY: Updates redeem fee for passed SetToken\n     *\n     * @param _setToken             Instance of the SetToken to update redeem fee\n     * @param _newRedeemFee         New fee amount in preciseUnits (1% = 10^16)\n     */\n    function updateRedeemFee(\n        ISetToken _setToken,\n        uint256 _newRedeemFee\n    )\n        external\n        onlyManagerAndValidSet(_setToken)\n    {\n        require(_newRedeemFee <= issuanceSettings[_setToken].maxManagerFee, \"Redeem fee can't exceed maximum\");\n        require(_newRedeemFee != issuanceSettings[_setToken].managerRedeemFee, \"Same redeem fee passed\");\n\n        issuanceSettings[_setToken].managerRedeemFee = _newRedeemFee;\n\n        emit RedeemFeeUpdated(_setToken, _newRedeemFee);\n    }\n\n    /**\n     * MODULE ONLY: Adds calling module to array of modules that require they be called before component hooks are\n     * called. Can be used to sync debt positions before issuance.\n     *\n     * @param _setToken             Instance of the SetToken to issue\n     */\n    function registerToIssuanceModule(ISetToken _setToken) external onlyModule(_setToken) onlyValidAndInitializedSet(_setToken) {\n        require(!issuanceSettings[_setToken].isModuleHook[msg.sender], \"Module already registered.\");\n        issuanceSettings[_setToken].moduleIssuanceHooks.push(msg.sender);\n        issuanceSettings[_setToken].isModuleHook[msg.sender] = true;\n    }\n\n    /**\n     * MODULE ONLY: Removes calling module from array of modules that require they be called before component hooks are\n     * called.\n     *\n     * @param _setToken             Instance of the SetToken to issue\n     */\n    function unregisterFromIssuanceModule(ISetToken _setToken) external onlyModule(_setToken) onlyValidAndInitializedSet(_setToken) {\n        require(issuanceSettings[_setToken].isModuleHook[msg.sender], \"Module not registered.\");\n        issuanceSettings[_setToken].moduleIssuanceHooks.removeStorage(msg.sender);\n        issuanceSettings[_setToken].isModuleHook[msg.sender] = false;\n    }\n\n    /**\n     * MANAGER ONLY: Initializes this module to the SetToken with issuance-related hooks and fee information. Only callable\n     * by the SetToken's manager. Hook addresses are optional. Address(0) means that no hook will be called\n     *\n     * @param _setToken                     Instance of the SetToken to issue\n     * @param _maxManagerFee                Maximum fee that can be charged on issue and redeem\n     * @param _managerIssueFee              Fee to charge on issuance\n     * @param _managerRedeemFee             Fee to charge on redemption\n     * @param _feeRecipient                 Address to send fees to\n     * @param _managerIssuanceHook          Instance of the Manager Contract with the Pre-Issuance Hook function\n     */\n    function initialize(\n        ISetToken _setToken,\n        uint256 _maxManagerFee,\n        uint256 _managerIssueFee,\n        uint256 _managerRedeemFee,\n        address _feeRecipient,\n        IManagerIssuanceHook _managerIssuanceHook\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        require(_managerIssueFee <= _maxManagerFee, \"Issue fee can't exceed maximum fee\");\n        require(_managerRedeemFee <= _maxManagerFee, \"Redeem fee can't exceed maximum fee\");\n\n        issuanceSettings[_setToken] = IssuanceSettings({\n            maxManagerFee: _maxManagerFee,\n            managerIssueFee: _managerIssueFee,\n            managerRedeemFee: _managerRedeemFee,\n            feeRecipient: _feeRecipient,\n            managerIssuanceHook: _managerIssuanceHook,\n            moduleIssuanceHooks: new address[](0)\n        });\n\n        _setToken.initializeModule();\n    }\n\n    /**\n     * SET TOKEN ONLY: Allows removal of module (and deletion of state) if no other modules are registered.\n     */\n    function removeModule() external override {\n        require(issuanceSettings[ISetToken(msg.sender)].moduleIssuanceHooks.length == 0, \"Registered modules must be removed.\");\n        delete issuanceSettings[ISetToken(msg.sender)];\n    }\n\n    /* ============ External View Functions ============ */\n\n    /**\n     * Calculates the manager fee, protocol fee and resulting totalQuantity to use when calculating unit amounts. If fees are charged they\n     * are added to the total issue quantity, for example 1% fee on 100 Sets means 101 Sets are minted by caller, the _to address receives\n     * 100 and the feeRecipient receives 1. Conversely, on redemption the redeemer will only receive the collateral that collateralizes 99\n     * Sets, while the additional Set is given to the feeRecipient.\n     *\n     * @param _setToken                 Instance of the SetToken to issue\n     * @param _quantity                 Amount of SetToken issuer wants to receive/redeem\n     * @param _isIssue                  If issuing or redeeming\n     *\n     * @return totalQuantity           Total amount of Sets to be issued/redeemed with fee adjustment\n     * @return managerFee              Sets minted to the manager\n     * @return protocolFee             Sets minted to the protocol\n     */\n    function calculateTotalFees(\n        ISetToken _setToken,\n        uint256 _quantity,\n        bool _isIssue\n    )\n        public\n        view\n        returns (uint256 totalQuantity, uint256 managerFee, uint256 protocolFee)\n    {\n        IssuanceSettings memory setIssuanceSettings = issuanceSettings[_setToken];\n        uint256 protocolFeeSplit = controller.getModuleFee(address(this), ISSUANCE_MODULE_PROTOCOL_FEE_SPLIT_INDEX);\n        uint256 totalFeeRate = _isIssue ? setIssuanceSettings.managerIssueFee : setIssuanceSettings.managerRedeemFee;\n\n        uint256 totalFee = totalFeeRate.preciseMul(_quantity);\n        protocolFee = totalFee.preciseMul(protocolFeeSplit);\n        managerFee = totalFee.sub(protocolFee);\n\n        totalQuantity = _isIssue ? _quantity.add(totalFee) : _quantity.sub(totalFee);\n    }\n\n    /**\n     * Calculates the amount of each component needed to collateralize passed issue quantity plus fees of Sets as well as amount of debt\n     * that will be returned to caller. Values DO NOT take into account any updates from pre action manager or module hooks.\n     *\n     * @param _setToken         Instance of the SetToken to issue\n     * @param _quantity         Amount of Sets to be issued\n     *\n     * @return address[]        Array of component addresses making up the Set\n     * @return uint256[]        Array of equity notional amounts of each component, respectively, represented as uint256\n     * @return uint256[]        Array of debt notional amounts of each component, respectively, represented as uint256\n     */\n    function getRequiredComponentIssuanceUnits(\n        ISetToken _setToken,\n        uint256 _quantity\n    )\n        external\n        view\n        virtual\n        returns (address[] memory, uint256[] memory, uint256[] memory)\n    {\n        (\n            uint256 totalQuantity,,\n        ) = calculateTotalFees(_setToken, _quantity, true);\n\n        return _calculateRequiredComponentIssuanceUnits(_setToken, totalQuantity, true);\n    }\n\n    /**\n     * Calculates the amount of each component will be returned on redemption net of fees as well as how much debt needs to be paid down to.\n     * redeem. Values DO NOT take into account any updates from pre action manager or module hooks.\n     *\n     * @param _setToken         Instance of the SetToken to issue\n     * @param _quantity         Amount of Sets to be redeemed\n     *\n     * @return address[]        Array of component addresses making up the Set\n     * @return uint256[]        Array of equity notional amounts of each component, respectively, represented as uint256\n     * @return uint256[]        Array of debt notional amounts of each component, respectively, represented as uint256\n     */\n    function getRequiredComponentRedemptionUnits(\n        ISetToken _setToken,\n        uint256 _quantity\n    )\n        external\n        view\n        virtual\n        returns (address[] memory, uint256[] memory, uint256[] memory)\n    {\n        (\n            uint256 totalQuantity,,\n        ) = calculateTotalFees(_setToken, _quantity, false);\n\n        return _calculateRequiredComponentIssuanceUnits(_setToken, totalQuantity, false);\n    }\n\n    function getModuleIssuanceHooks(ISetToken _setToken) external view returns(address[] memory) {\n        return issuanceSettings[_setToken].moduleIssuanceHooks;\n    }\n\n    function isModuleIssuanceHook(ISetToken _setToken, address _hook) external view returns(bool) {\n        return issuanceSettings[_setToken].isModuleHook[_hook];\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Calculates the amount of each component needed to collateralize passed issue quantity of Sets as well as amount of debt that will\n     * be returned to caller. Can also be used to determine how much collateral will be returned on redemption as well as how much debt\n     * needs to be paid down to redeem.\n     *\n     * @param _setToken         Instance of the SetToken to issue\n     * @param _quantity         Amount of Sets to be issued/redeemed\n     * @param _isIssue          Whether Sets are being issued or redeemed\n     *\n     * @return address[]        Array of component addresses making up the Set\n     * @return uint256[]        Array of equity notional amounts of each component, respectively, represented as uint256\n     * @return uint256[]        Array of debt notional amounts of each component, respectively, represented as uint256\n     */\n    function _calculateRequiredComponentIssuanceUnits(\n        ISetToken _setToken,\n        uint256 _quantity,\n        bool _isIssue\n    )\n        internal\n        view\n        returns (address[] memory, uint256[] memory, uint256[] memory)\n    {\n        (\n            address[] memory components,\n            uint256[] memory equityUnits,\n            uint256[] memory debtUnits\n        ) = _getTotalIssuanceUnits(_setToken);\n\n        uint256 componentsLength = components.length;\n        uint256[] memory totalEquityUnits = new uint256[](componentsLength);\n        uint256[] memory totalDebtUnits = new uint256[](componentsLength);\n        for (uint256 i = 0; i < components.length; i++) {\n            // Use preciseMulCeil to round up to ensure overcollateration when small issue quantities are provided\n            // and preciseMul to round down to ensure overcollateration when small redeem quantities are provided\n            totalEquityUnits[i] = _isIssue ?\n                equityUnits[i].preciseMulCeil(_quantity) :\n                equityUnits[i].preciseMul(_quantity);\n\n            totalDebtUnits[i] = _isIssue ?\n                debtUnits[i].preciseMul(_quantity) :\n                debtUnits[i].preciseMulCeil(_quantity);\n        }\n\n        return (components, totalEquityUnits, totalDebtUnits);\n    }\n\n    /**\n     * Sums total debt and equity units for each component, taking into account default and external positions.\n     *\n     * @param _setToken         Instance of the SetToken to issue\n     *\n     * @return address[]        Array of component addresses making up the Set\n     * @return uint256[]        Array of equity unit amounts of each component, respectively, represented as uint256\n     * @return uint256[]        Array of debt unit amounts of each component, respectively, represented as uint256\n     */\n    function _getTotalIssuanceUnits(\n        ISetToken _setToken\n    )\n        internal\n        view\n        returns (address[] memory, uint256[] memory, uint256[] memory)\n    {\n        address[] memory components = _setToken.getComponents();\n        uint256 componentsLength = components.length;\n\n        uint256[] memory equityUnits = new uint256[](componentsLength);\n        uint256[] memory debtUnits = new uint256[](componentsLength);\n\n        for (uint256 i = 0; i < components.length; i++) {\n            address component = components[i];\n            int256 cumulativeEquity = _setToken.getDefaultPositionRealUnit(component);\n            int256 cumulativeDebt = 0;\n            address[] memory externalPositions = _setToken.getExternalPositionModules(component);\n\n            if (externalPositions.length > 0) {\n                for (uint256 j = 0; j < externalPositions.length; j++) {\n                    int256 externalPositionUnit = _setToken.getExternalPositionRealUnit(component, externalPositions[j]);\n\n                    // If positionUnit <= 0 it will be \"added\" to debt position\n                    if (externalPositionUnit > 0) {\n                        cumulativeEquity = cumulativeEquity.add(externalPositionUnit);\n                    } else {\n                        cumulativeDebt = cumulativeDebt.add(externalPositionUnit);\n                    }\n                }\n            }\n\n            equityUnits[i] = cumulativeEquity.toUint256();\n            debtUnits[i] = cumulativeDebt.mul(-1).toUint256();\n        }\n\n        return (components, equityUnits, debtUnits);\n    }\n\n    /**\n     * Resolve equity positions associated with SetToken. On issuance, the total equity position for an asset (including default and external\n     * positions) is transferred in. Then any external position hooks are called to transfer the external positions to their necessary place.\n     * On redemption all external positions are recalled by the external position hook, then those position plus any default position are\n     * transferred back to the _to address.\n     */\n    function _resolveEquityPositions(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _to,\n        bool _isIssue,\n        address[] memory _components,\n        uint256[] memory _componentEquityQuantities\n    )\n        internal\n    {\n        for (uint256 i = 0; i < _components.length; i++) {\n            address component = _components[i];\n            uint256 componentQuantity = _componentEquityQuantities[i];\n            if (componentQuantity > 0) {\n                if (_isIssue) {\n                    transferFrom(\n                        IERC20(component),\n                        msg.sender,\n                        address(_setToken),\n                        componentQuantity\n                    );\n\n                    _executeExternalPositionHooks(_setToken, _quantity, IERC20(component), true, true);\n                } else {\n                    _executeExternalPositionHooks(_setToken, _quantity, IERC20(component), false, true);\n\n                    _setToken.strictInvokeTransfer(\n                        component,\n                        _to,\n                        componentQuantity\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Resolve debt positions associated with SetToken. On issuance, debt positions are entered into by calling the external position hook. The\n     * resulting debt is then returned to the calling address. On redemption, the module transfers in the required debt amount from the caller\n     * and uses those funds to repay the debt on behalf of the SetToken.\n     */\n    function _resolveDebtPositions(\n        ISetToken _setToken,\n        uint256 _quantity,\n        bool _isIssue,\n        address[] memory _components,\n        uint256[] memory _componentDebtQuantities\n    )\n        internal\n    {\n        for (uint256 i = 0; i < _components.length; i++) {\n            address component = _components[i];\n            uint256 componentQuantity = _componentDebtQuantities[i];\n            if (componentQuantity > 0) {\n                if (_isIssue) {\n                    _executeExternalPositionHooks(_setToken, _quantity, IERC20(component), true, false);\n                    _setToken.strictInvokeTransfer(\n                        component,\n                        msg.sender,\n                        componentQuantity\n                    );\n                } else {\n                    transferFrom(\n                        IERC20(component),\n                        msg.sender,\n                        address(_setToken),\n                        componentQuantity\n                    );\n                    _executeExternalPositionHooks(_setToken, _quantity, IERC20(component), false, false);\n                }\n            }\n        }\n    }\n\n    /**\n     * If any manager fees mints Sets to the defined feeRecipient. If protocol fee is enabled mints Sets to protocol\n     * feeRecipient.\n     */\n    function _resolveFees(ISetToken _setToken, uint256 managerFee, uint256 protocolFee) internal {\n        if (managerFee > 0) {\n            _setToken.mint(issuanceSettings[_setToken].feeRecipient, managerFee);\n\n            // Protocol fee check is inside manager fee check because protocol fees are only collected on manager fees\n            if (protocolFee > 0) {\n                _setToken.mint(controller.feeRecipient(), protocolFee);\n            }\n        }\n    }\n\n    /**\n     * If a pre-issue hook has been configured, call the external-protocol contract. Pre-issue hook logic\n     * can contain arbitrary logic including validations, external function calls, etc.\n     */\n    function _callManagerPreIssueHooks(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _caller,\n        address _to\n    )\n        internal\n        returns(address)\n    {\n        IManagerIssuanceHook preIssueHook = issuanceSettings[_setToken].managerIssuanceHook;\n        if (address(preIssueHook) != address(0)) {\n            preIssueHook.invokePreIssueHook(_setToken, _quantity, _caller, _to);\n            return address(preIssueHook);\n        }\n\n        return address(0);\n    }\n\n    /**\n     * Calls all modules that have registered with the DebtIssuanceModule that have a moduleIssueHook.\n     */\n    function _callModulePreIssueHooks(ISetToken _setToken, uint256 _quantity) internal {\n        address[] memory issuanceHooks = issuanceSettings[_setToken].moduleIssuanceHooks;\n        for (uint256 i = 0; i < issuanceHooks.length; i++) {\n            IModuleIssuanceHook(issuanceHooks[i]).moduleIssueHook(_setToken, _quantity);\n        }\n    }\n\n    /**\n     * Calls all modules that have registered with the DebtIssuanceModule that have a moduleRedeemHook.\n     */\n    function _callModulePreRedeemHooks(ISetToken _setToken, uint256 _quantity) internal {\n        address[] memory issuanceHooks = issuanceSettings[_setToken].moduleIssuanceHooks;\n        for (uint256 i = 0; i < issuanceHooks.length; i++) {\n            IModuleIssuanceHook(issuanceHooks[i]).moduleRedeemHook(_setToken, _quantity);\n        }\n    }\n\n    /**\n     * For each component's external module positions, calculate the total notional quantity, and\n     * call the module's issue hook or redeem hook.\n     * Note: It is possible that these hooks can cause the states of other modules to change.\n     * It can be problematic if the hook called an external function that called back into a module, resulting in state inconsistencies.\n     */\n    function _executeExternalPositionHooks(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isIssue,\n        bool _isEquity\n    )\n        internal\n    {\n        address[] memory externalPositionModules = _setToken.getExternalPositionModules(address(_component));\n        uint256 modulesLength = externalPositionModules.length;\n        if (_isIssue) {\n            for (uint256 i = 0; i < modulesLength; i++) {\n                IModuleIssuanceHook(externalPositionModules[i]).componentIssueHook(_setToken, _setTokenQuantity, _component, _isEquity);\n            }\n        } else {\n            for (uint256 i = 0; i < modulesLength; i++) {\n                IModuleIssuanceHook(externalPositionModules[i]).componentRedeemHook(_setToken, _setTokenQuantity, _component, _isEquity);\n            }\n        }\n    }\n}\n\n",
        "CodeNames": [
            "DebtIssuanceModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "DebtIssuanceModule.sol#L131-L141",
                "Type": "smart contract vulnerability",
                "Description": "fCash of the wrong maturity and asset can be sent to wrapper address before wrapper is deployed",
                "Repair": "Create a function that reads how many fCash assets are at the address and send them away if they aren't of the correct asset and maturity"
            },
            {
                "Location": "DebtIssuanceModule.sol#L131-L141, ERC777.sol#L376-L380",
                "Type": "re-entrancy attack",
                "Description": "DOS set token through erc777 hook",
                "Repair": "Drop ERC777 or implement protocol-wide cross-contract reentrancy prevention"
            }
        ]
    },
    {
        "Code": "/*\n    Copyright 2022 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.6.10;\npragma experimental \"ABIEncoderV2\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC777 } from \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { IController } from \"../../../interfaces/IController.sol\";\nimport { IDebtIssuanceModule } from \"../../../interfaces/IDebtIssuanceModule.sol\";\nimport { IModuleIssuanceHook } from \"../../../interfaces/IModuleIssuanceHook.sol\";\nimport { IWrappedfCash, IWrappedfCashComplete } from \"../../../interfaces/IWrappedFCash.sol\";\nimport { IWrappedfCashFactory } from \"../../../interfaces/IWrappedFCashFactory.sol\";\nimport { ISetToken } from \"../../../interfaces/ISetToken.sol\";\nimport { ModuleBase } from \"../../lib/ModuleBase.sol\";\n\n\n\n/**\n * @title NotionalTradeModule\n * @author Set Protocol\n * @notice Smart contract that enables trading in and out of Notional fCash positions and redeem matured positions.\n * @dev This module depends on the wrappedFCash erc20-token-wrapper. Meaning positions managed with this module have to be in the form of wrappedfCash NOT fCash directly.\n */\ncontract NotionalTradeModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIssuanceHook {\n    using Address for address;\n\n    // This value has to be the same as the one used in wrapped-fcash Constants\n    address internal constant ETH_ADDRESS = address(0);\n\n    /* ============ Events ============ */\n\n    /**\n     * @dev Emitted on updateAnySetAllowed()\n     * @param _anySetAllowed    true if any set is allowed to initialize this module, false otherwise\n     */\n    event AnySetAllowedUpdated(\n        bool indexed _anySetAllowed\n    );\n\n    /**\n     * @dev Emitted on updateAllowedSetToken()\n     * @param _setToken SetToken being whose allowance to initialize this module is being updated\n     * @param _added    true if added false if removed\n     */\n    event SetTokenStatusUpdated(\n        ISetToken indexed _setToken,\n        bool indexed _added\n    );\n\n    /**\n     * @dev Emitted when minting new FCash\n     * @param _setToken         SetToken on whose behalf fcash was minted\n     * @param _fCashPosition    Address of wrappedFCash token\n     * @param _sendToken        Address of send token used to pay for minting\n     * @param _fCashAmount      Amount of fCash minted\n     * @param _sentAmount       Amount of sendToken spent\n     */\n    event FCashMinted(\n        ISetToken indexed _setToken,\n        IWrappedfCashComplete indexed _fCashPosition,\n        IERC20 indexed _sendToken, \n        uint256 _fCashAmount,\n        uint256 _sentAmount\n    );\n\n    /**\n     * @dev Emitted when redeeming new FCash\n     * @param _setToken         SetToken on whose behalf fcash was redeemed\n     * @param _fCashPosition    Address of wrappedFCash token\n     * @param _receiveToken     Address of receive token used to pay for redeeming\n     * @param _fCashAmount      Amount of fCash redeemed / burned\n     * @param _receivedAmount   Amount of receiveToken received\n     */\n    event FCashRedeemed(\n        ISetToken indexed _setToken,\n        IWrappedfCashComplete indexed _fCashPosition,\n        IERC20 indexed _receiveToken, \n        uint256 _fCashAmount,\n        uint256 _receivedAmount\n    );\n\n\n    /* ============ Constants ============ */\n\n    // String identifying the DebtIssuanceModule in the IntegrationRegistry. Note: Governance must add DefaultIssuanceModule as\n    // the string as the integration name\n    string constant internal DEFAULT_ISSUANCE_MODULE_NAME = \"DefaultIssuanceModule\";\n\n    /* ============ State Variables ============ */\n\n    // Mapping for a set token, wether or not to redeem to underlying upon reaching maturity\n    mapping(ISetToken => bool) public redeemToUnderlying;\n\n    // Mapping of SetToken to boolean indicating if SetToken is on allow list. Updateable by governance\n    mapping(ISetToken => bool) public allowedSetTokens;\n\n    // Boolean that returns if any SetToken can initialize this module. If false, then subject to allow list. Updateable by governance.\n    bool public anySetAllowed;\n\n    // Factory that is used to deploy and check fCash wrapper contracts\n    IWrappedfCashFactory public immutable wrappedfCashFactory;\n    IERC20 public immutable weth;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @dev Instantiate addresses\n     * @param _controller                       Address of controller contract\n     * @param _wrappedfCashFactory              Address of fCash wrapper factory used to check and deploy wrappers\n     */\n    constructor(\n        IController _controller,\n        IWrappedfCashFactory _wrappedfCashFactory,\n        IERC20 _weth\n\n    )\n        public\n        ModuleBase(_controller)\n    {\n        wrappedfCashFactory = _wrappedfCashFactory;\n        weth = _weth;\n    }\n\n    /* ============ External Functions ============ */\n\n\n    /**\n     * @dev MANAGER ONLY: Trades into a new fCash position.\n     * @param _setToken                   Instance of the SetToken\n     * @param _currencyId                 CurrencyId of the fCash token as defined by the notional protocol. \n     * @param _maturity                   Maturity of the fCash token as defined by the notional protocol.\n     * @param _mintAmount                 Amount of fCash token to mint \n     * @param _sendToken                  Token to mint from, must be either the underlying or the asset token.\n     * @param _maxSendAmount              Maximum amount to spend\n     */\n    function mintFCashPosition(\n        ISetToken _setToken,\n        uint16 _currencyId,\n        uint40 _maturity,\n        uint256 _mintAmount,\n        address _sendToken,\n        uint256 _maxSendAmount\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n        returns(uint256)\n    {\n        require(_setToken.isComponent(address(_sendToken)), \"Send token must be an index component\");\n\n        IWrappedfCashComplete wrappedfCash = _deployWrappedfCash(_currencyId, _maturity);\n        return _mintFCashPosition(_setToken, wrappedfCash, IERC20(_sendToken), _mintAmount, _maxSendAmount);\n    }\n\n    /**\n     * @dev MANAGER ONLY: Trades out of an existing fCash position.\n     * Will revert if no wrapper for the selected fCash token was deployed\n     * @param _setToken                   Instance of the SetToken\n     * @param _currencyId                 CurrencyId of the fCash token as defined by the notional protocol. \n     * @param _maturity                   Maturity of the fCash token as defined by the notional protocol.\n     * @param _redeemAmount               Amount of fCash token to redeem \n     * @param _receiveToken               Token to redeem into, must be either asset or underlying token of the fCash token\n     * @param _minReceiveAmount           Minimum amount of receive token to receive\n     */\n    function redeemFCashPosition(\n        ISetToken _setToken,\n        uint16 _currencyId,\n        uint40 _maturity,\n        uint256 _redeemAmount,\n        address _receiveToken,\n        uint256 _minReceiveAmount\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n        returns(uint256)\n    {\n        IWrappedfCashComplete wrappedfCash = _getWrappedfCash(_currencyId, _maturity);\n        require(_setToken.isComponent(address(wrappedfCash)), \"FCash to redeem must be an index component\");\n\n        return _redeemFCashPosition(_setToken, wrappedfCash, IERC20(_receiveToken), _redeemAmount, _minReceiveAmount);\n    }\n\n    /**\n     * @dev CALLABLE BY ANYBODY: Redeem all matured fCash positions of given setToken\n     * Redeem all fCash positions that have reached maturity for their asset token (cToken)\n     * This will update the set tokens components and positions (removes matured fCash positions and creates / increases positions of the asset token).\n     * @param _setToken                     Instance of the SetToken\n     */\n    function redeemMaturedPositions(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        _redeemMaturedPositions(_setToken);\n    }\n\n    /**\n     * @dev MANGER ONLY: Initialize given SetToken with initial list of registered fCash positions\n     * Redeem all fCash positions that have reached maturity for their asset token (cToken)\n     * @param _setToken                     Instance of the SetToken\n     */\n    function initialize(\n        ISetToken _setToken\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], \"Not allowed SetToken\");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), \"Issuance not initialized\");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for(uint256 i = 0; i < modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n    }\n\n    /**\n     * @dev MANAGER ONLY: Removes this module from the SetToken, via call by the SetToken. Redeems any matured positions\n     */\n    function removeModule() external override onlyValidAndInitializedSet(ISetToken(msg.sender)) {\n        ISetToken setToken = ISetToken(msg.sender);\n\n        // Redeem matured positions prior to any removal action\n        _redeemMaturedPositions(setToken);\n\n        // Try if unregister exists on any of the modules\n        address[] memory modules = setToken.getModules();\n        for(uint256 i = 0; i < modules.length; i++) {\n            if(modules[i].isContract()){\n                try IDebtIssuanceModule(modules[i]).unregisterFromIssuanceModule(setToken) {} catch {}\n            }\n        }\n    }\n\n    /**\n     * @dev MANAGER ONLY: Add registration of this module on the debt issuance module for the SetToken.\n     * Note: if the debt issuance module is not added to SetToken before this module is initialized, then this function\n     * needs to be called if the debt issuance module is later added and initialized to prevent state inconsistencies\n     * @param _setToken             Instance of the SetToken\n     * @param _debtIssuanceModule   Debt issuance module address to register\n     */\n    function registerToModule(ISetToken _setToken, IDebtIssuanceModule _debtIssuanceModule) external onlyManagerAndValidSet(_setToken) {\n        require(_setToken.isInitializedModule(address(_debtIssuanceModule)), \"Issuance not initialized\");\n\n        _debtIssuanceModule.registerToIssuanceModule(_setToken);\n    }\n\n    /**\n     * @dev GOVERNANCE ONLY: Enable/disable ability of a SetToken to initialize this module. Only callable by governance.\n     * @param _setToken             Instance of the SetToken\n     * @param _status               Bool indicating if _setToken is allowed to initialize this module\n     */\n    function updateAllowedSetToken(ISetToken _setToken, bool _status) external onlyOwner {\n        require(controller.isSet(address(_setToken)) || allowedSetTokens[_setToken], \"Invalid SetToken\");\n        allowedSetTokens[_setToken] = _status;\n        emit SetTokenStatusUpdated(_setToken, _status);\n    }\n\n    /**\n     * @dev GOVERNANCE ONLY: Toggle whether ANY SetToken is allowed to initialize this module. Only callable by governance.\n     * @param _anySetAllowed             Bool indicating if ANY SetToken is allowed to initialize this module\n     */\n    function updateAnySetAllowed(bool _anySetAllowed) external onlyOwner {\n        anySetAllowed = _anySetAllowed;\n        emit AnySetAllowedUpdated(_anySetAllowed);\n    }\n\n    function setRedeemToUnderlying(\n        ISetToken _setToken,\n        bool _toUnderlying\n    )\n    external\n    onlyManagerAndValidSet(_setToken)\n    {\n        redeemToUnderlying[_setToken] = _toUnderlying;\n    }\n\n\n    /**\n     * @dev Hook called once before setToken issuance\n     * @dev Ensures that no matured fCash positions are in the set when it is issued\n     */\n    function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenAmount */) external override onlyModule(_setToken) {\n        _redeemMaturedPositions(_setToken);\n    }\n\n    /**\n     * @dev Hook called once before setToken redemption\n     * @dev Ensures that no matured fCash positions are in the set when it is redeemed\n     */\n    function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenAmount */) external override onlyModule(_setToken) {\n        _redeemMaturedPositions(_setToken);\n    }\n\n\n    /**\n     * @dev Hook called once for each component upon setToken issuance\n     * @dev Empty method added to satisfy IModuleIssuanceHook interface\n     */\n    function componentIssueHook(\n        ISetToken _setToken,\n        uint256 _setTokenAmount,\n        IERC20 _component,\n        bool _isEquity\n    ) external override onlyModule(_setToken) {\n    }\n\n    /**\n     * @dev Hook called once for each component upon setToken redemption\n     * @dev Empty method added to satisfy IModuleIssuanceHook interface\n     */\n    function componentRedeemHook(\n        ISetToken _setToken,\n        uint256 _setTokenAmount,\n        IERC20 _component,\n        bool _isEquity\n    ) external override onlyModule(_setToken) {\n    }\n\n\n\n\n    /* ============ External Getter Functions ============ */\n\n    /**\n     * @dev Get array of registered fCash positions\n     * @param _setToken             Instance of the SetToken\n     */\n    function getFCashPositions(ISetToken _setToken)\n    external\n    view\n    returns(address[] memory positions)\n    {\n        return _getFCashPositions(_setToken);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev Deploy wrapper if it does not exist yet and return address\n     */\n    function _deployWrappedfCash(uint16 _currencyId, uint40 _maturity) internal returns(IWrappedfCashComplete) {\n        address wrappedfCashAddress = wrappedfCashFactory.deployWrapper(_currencyId, _maturity);\n        return IWrappedfCashComplete(wrappedfCashAddress);\n    }\n     \n    /**\n     * @dev Return wrapper address and revert if it isn't deployed\n     */\n    function _getWrappedfCash(uint16 _currencyId, uint40 _maturity) internal view returns(IWrappedfCashComplete) {\n        address wrappedfCashAddress = wrappedfCashFactory.computeAddress(_currencyId, _maturity);\n        require(wrappedfCashAddress.isContract(), \"WrappedfCash not deployed for given parameters\");\n        return IWrappedfCashComplete(wrappedfCashAddress);\n    }\n\n    /**\n     * @dev Redeem all matured fCash positions for the given SetToken\n     */\n    function _redeemMaturedPositions(ISetToken _setToken)\n    internal\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n        uint positionsLength = positions.length;\n\n        bool toUnderlying = redeemToUnderlying[_setToken];\n\n        for(uint256 i = 0; i < positionsLength; i++) {\n            // Check that the given position is an equity position\n            if(positions[i].unit > 0) {\n                address component = positions[i].component;\n                if(_isWrappedFCash(component)) {\n                    IWrappedfCashComplete fCashPosition = IWrappedfCashComplete(component);\n                    if(fCashPosition.hasMatured()) {\n                        (IERC20 receiveToken,) = fCashPosition.getToken(toUnderlying);\n                        if(address(receiveToken) == ETH_ADDRESS) {\n                            receiveToken = weth;\n                        }\n                        uint256 fCashBalance = fCashPosition.balanceOf(address(_setToken));\n                        _redeemFCashPosition(_setToken, fCashPosition, receiveToken, fCashBalance, 0);\n                    }\n                }\n            }\n        }\n    }\n\n\n\n    /**\n     * @dev Redeem a given fCash position from the specified send token (either underlying or asset token)\n     * @dev Alo adjust the components / position of the set token accordingly\n     */\n    function _mintFCashPosition(\n        ISetToken _setToken,\n        IWrappedfCashComplete _fCashPosition,\n        IERC20 _sendToken,\n        uint256 _fCashAmount,\n        uint256 _maxSendAmount\n    )\n    internal\n    returns(uint256 sentAmount)\n    {\n        if(_fCashAmount == 0) return 0;\n\n        bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);\n\n\n        _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);\n\n        uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));\n        uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));\n\n        _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying);\n\n\n        (sentAmount,) = _updateSetTokenPositions(\n            _setToken,\n            address(_sendToken),\n            preTradeSendTokenBalance,\n            address(_fCashPosition),\n            preTradeReceiveTokenBalance\n        );\n\n        require(sentAmount <= _maxSendAmount, \"Overspent\");\n        emit FCashMinted(_setToken, _fCashPosition, _sendToken, _fCashAmount, sentAmount);\n    }\n\n    /**\n     * @dev Redeem a given fCash position for the specified receive token (either underlying or asset token)\n     * @dev Alo adjust the components / position of the set token accordingly\n     */\n    function _redeemFCashPosition(\n        ISetToken _setToken,\n        IWrappedfCashComplete _fCashPosition,\n        IERC20 _receiveToken,\n        uint256 _fCashAmount,\n        uint256 _minReceiveAmount\n    )\n    internal\n    returns(uint256 receivedAmount)\n    {\n        if(_fCashAmount == 0) return 0;\n\n        bool toUnderlying = _isUnderlying(_fCashPosition, _receiveToken);\n        uint256 preTradeReceiveTokenBalance = _receiveToken.balanceOf(address(_setToken));\n        uint256 preTradeSendTokenBalance = _fCashPosition.balanceOf(address(_setToken));\n\n        _redeem(_setToken, _fCashPosition, _fCashAmount, toUnderlying);\n\n\n        (, receivedAmount) = _updateSetTokenPositions(\n            _setToken,\n            address(_fCashPosition),\n            preTradeSendTokenBalance,\n            address(_receiveToken),\n            preTradeReceiveTokenBalance\n        );\n\n\n        require(receivedAmount >= _minReceiveAmount, \"Not enough received amount\");\n        emit FCashRedeemed(_setToken, _fCashPosition, _receiveToken, _fCashAmount, receivedAmount);\n\n    }\n\n    /**\n     * @dev Approve the given wrappedFCash instance to spend the setToken's sendToken \n     */\n    function _approve(\n        ISetToken _setToken,\n        IWrappedfCashComplete _fCashPosition,\n        IERC20 _sendToken,\n        uint256 _maxAssetAmount\n    )\n    internal\n    {\n        if(IERC20(_sendToken).allowance(address(_setToken), address(_fCashPosition)) < _maxAssetAmount) {\n            bytes memory approveCallData = abi.encodeWithSelector(_sendToken.approve.selector, address(_fCashPosition), _maxAssetAmount);\n            _setToken.invoke(address(_sendToken), 0, approveCallData);\n        }\n    }\n\n    /**\n     * @dev Invokes the wrappedFCash token's mint function from the setToken\n     */\n    function _mint(\n        ISetToken _setToken,\n        IWrappedfCashComplete _fCashPosition,\n        uint256 _maxAssetAmount,\n        uint256 _fCashAmount,\n        bool _fromUnderlying\n    )\n    internal\n    {\n        uint32 minImpliedRate = 0;\n\n        bytes4 functionSelector = \n            _fromUnderlying ? _fCashPosition.mintViaUnderlying.selector : _fCashPosition.mintViaAsset.selector;\n        bytes memory mintCallData = abi.encodeWithSelector(\n            functionSelector,\n            _maxAssetAmount,\n            uint88(_fCashAmount),\n            address(_setToken),\n            minImpliedRate,\n            _fromUnderlying\n        );\n        _setToken.invoke(address(_fCashPosition), 0, mintCallData);\n    }\n\n    /**\n     * @dev Redeems the given amount of fCash token on behalf of the setToken\n     */\n    function _redeem(\n        ISetToken _setToken,\n        IWrappedfCashComplete _fCashPosition,\n        uint256 _fCashAmount,\n        bool _toUnderlying\n    )\n    internal\n    {\n        uint32 maxImpliedRate = type(uint32).max;\n\n        bytes4 functionSelector =\n            _toUnderlying ? _fCashPosition.redeemToUnderlying.selector : _fCashPosition.redeemToAsset.selector;\n        bytes memory redeemCallData = abi.encodeWithSelector(\n            functionSelector,\n            _fCashAmount,\n            address(_setToken),\n            maxImpliedRate\n        );\n        _setToken.invoke(address(_fCashPosition), 0, redeemCallData);\n    }\n\n    /**\n     * @dev Returns boolean indicating if given paymentToken is the underlying of the given fCashPosition\n     * @dev Reverts if given token is neither underlying nor asset token of the fCashPosition\n     */\n    function _isUnderlying(\n        IWrappedfCashComplete _fCashPosition,\n        IERC20 _paymentToken\n    )\n    internal\n    view\n    returns(bool isUnderlying)\n    {\n        (IERC20 underlyingToken, IERC20 assetToken) = _getUnderlyingAndAssetTokens(_fCashPosition);\n        isUnderlying = _paymentToken == underlyingToken;\n        if(!isUnderlying) {\n            require(_paymentToken == assetToken, \"Token is neither asset nor underlying token\");\n        }\n    }\n\n\n    /**\n     * @dev Returns both underlying and asset token address for given fCash position\n     */\n    function _getUnderlyingAndAssetTokens(IWrappedfCashComplete _fCashPosition)\n    internal\n    view\n    returns(IERC20 underlyingToken, IERC20 assetToken)\n    {\n        (underlyingToken,) = _fCashPosition.getUnderlyingToken();\n        if(address(underlyingToken) == ETH_ADDRESS) {\n            underlyingToken = weth;\n        }\n        (assetToken,,) = _fCashPosition.getAssetToken();\n    }\n\n    /**\n     * @dev Returns an array with fcash position addresses for given set token\n     */\n    function _getFCashPositions(ISetToken _setToken)\n    internal\n    view\n    returns(address[] memory fCashPositions)\n    {\n        ISetToken.Position[] memory positions = _setToken.getPositions();\n        uint positionsLength = positions.length;\n        uint numFCashPositions;\n\n        for(uint256 i = 0; i < positionsLength; i++) {\n            // Check that the given position is an equity position\n            if(positions[i].unit > 0) {\n                address component = positions[i].component;\n                if(_isWrappedFCash(component)) {\n                    numFCashPositions++;\n                }\n            }\n        }\n\n        fCashPositions = new address[](numFCashPositions);\n\n        uint j;\n        for(uint256 i = 0; i < positionsLength; i++) {\n            if(positions[i].unit > 0) {\n                address component = positions[i].component;\n                if(_isWrappedFCash(component)) {\n                    fCashPositions[j] = component;\n                    j++;\n                }\n            }\n        }\n    }\n\n\n\n    /**\n     * @dev Checks if a given address is an fCash position that was deployed from the factory\n     */\n    function _isWrappedFCash(address _fCashPosition) internal view returns(bool){\n        if(!_fCashPosition.isContract()) {\n            return false;\n        }\n\n        try IWrappedfCash(_fCashPosition).getDecodedID() returns(uint16 _currencyId, uint40 _maturity){\n            try wrappedfCashFactory.computeAddress(_currencyId, _maturity) returns(address _computedAddress){\n                return _fCashPosition == _computedAddress;\n            } catch {\n                return false;\n            }\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Update set token positions after mint or redeem\n     * @dev WARNING: This function is largely copied from the trade module\n     */\n    function _updateSetTokenPositions(\n        ISetToken setToken,\n        address sendToken,\n        uint256 preTradeSendTokenBalance,\n        address receiveToken,\n        uint256 preTradeReceiveTokenBalance\n    ) internal returns (uint256, uint256) {\n\n        uint256 setTotalSupply = setToken.totalSupply();\n\n        (uint256 currentSendTokenBalance,,) = setToken.calculateAndEditDefaultPosition(\n            sendToken,\n            setTotalSupply,\n            preTradeSendTokenBalance\n        );\n\n        (uint256 currentReceiveTokenBalance,,) = setToken.calculateAndEditDefaultPosition(\n            receiveToken,\n            setTotalSupply,\n            preTradeReceiveTokenBalance\n        );\n\n        return (\n            preTradeSendTokenBalance.sub(currentSendTokenBalance),\n            currentReceiveTokenBalance.sub(preTradeReceiveTokenBalance)\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "NotionalTradeModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_isUnderlying() function in NotionalTradeModule contract",
                "Type": "Logic Error",
                "Description": "The logic of _isUnderlying() in NotionalTradeModule is wrong which will cause mintFCashPosition() and redeemFCashPosition() revert on fcash tokens which asset token is underlying token (asset.tokenType == TokenType.NonMintable).",
                "Repair": "Change the logic of _isUnderlying() in NotionalTradeModule so it returns correct results for all fcash tokens. One simple solution can be that it first checks payment token value with asset token value."
            },
            {
                "Location": "NotionalTradeModule.sol",
                "Type": "Smart contract logic",
                "Description": "If one of the fCash redemptions fails, it will cause the entire function to revert. If this happens, no one could purchase or redeem the setToken because moduleIssueHook and modileRedeemHook hooks will revert every single time. Thus, the setToken issuance and redemption will stop working entirely and  this setToken can be considered 'bricked'.",
                "Repair": "Consider alternate method of updating the asset position so that the SetToken's core functions (e.g. issuance and redemption) will not be locked if one of the matured fCash redemptions fails. Evaluate if _redeemMaturedPositions really need to be called during SetToken's issuance and redemption. If not, consider removing them from the hooks, so that any issue or revert within _redeemMaturedPositions won't cause the SetToken's issuance and redemption functions to stop working entirely. Consider implementing additional function to give manager/user an option to specify a list of matured fCash positions to redeem instead of forcing them to redeem all matured fCash positions at one go."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_mint function",
                "Type": "Silent overflow",
                "Description": "If a _fCashAmount value that is greater than uint88 is passed into the _mint function, downcasting it to uint88 will silently overflow.",
                "Repair": "Use a safe downcast function"
            },
            {
                "Location": "_mintFCashPosition function",
                "Type": "Residual Allowance",
                "Description": "Having residual allowance increases the risk of the asset tokens being stolen from the SetToken contract.",
                "Repair": "Approve the allowance on-demand whenever _mintFCashPosition is called, and reset the allowance back to zero after each minting process to eliminate any residual allowance."
            },
            {
                "Location": "previewWithdraw and previewMint functions",
                "Type": "Rounding Issues",
                "Description": "The result of the previewMint and previewWithdraw should be rounded up. The current implementation of convertToShares function will round down the number of shares returned due to how solidity handles Integer Division. ERC4626 expects the returned value of convertToShares to be rounded down. Thus, this function behaves as expected. previewWithdraw and previewMint functions rely on NotionalV2.getfCashBorrowFromPrincipal and NotionalV2.getDepositFromfCashLend functions. Due to the nature of time-boxed contest, I was unable to verify if NotionalV2.getfCashBorrowFromPrincipal and NotionalV2.getDepositFromfCashLend functions return a rounded down or up value. If a rounded down value is returned from these functions, previewWithdraw and previewMint functions would not behave as expected.",
                "Repair": "Ensure that the rounding of vault's functions behave as expected. Following are the expected rounding direction for each vault function: previewMint(uint256 shares) Round Up \u2b06, previewWithdraw(uint256 assets) Round Up \u2b06, previewRedeem(uint256 shares) Round Down \u2b07, previewDeposit(uint256 assets) Round Down \u2b07, convertToAssets(uint256 shares) Round Down \u2b07, convertToShares(uint256 assets) Round Down \u2b07"
            },
            {
                "Location": "_redeemInternal() function",
                "Type": "Balance manipulation",
                "Description": "Control is transferred to the receiver when receiving the ERC777. They are able to transfer the ERC777 to another account, at which time the before and after balance calculation will be incorrect.",
                "Repair": "Implement a check to ensure that the balance of the receiver has not been altered after the control transfer"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4626-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    function _getMaturedValue() private view returns (uint256) {\n        // If the fCash has matured we use the cash balance instead.\n        uint16 currencyId = getCurrencyId();\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\n        // after maturity. This can be done by anyone so it should not be an issue\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\n        require(underlyingExternal > 0, \"Must Settle\");\n\n        return uint256(underlyingExternal);\n    }\n\n    function _getPresentValue(uint256 fCashAmount) private view returns (uint256) {\n        (/* */, int256 precision) = getUnderlyingToken();\n        // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        int256 pvInternal = NotionalV2.getPresentfCashValue(\n            currencyId,\n            maturity,\n            int256(fCashAmount), // total supply cannot overflow as fCash overflows at uint88\n            block.timestamp,\n            false\n        );\n\n        int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\n        // PV should always be >= 0 since we are lending\n        require(pvExternal >= 0);\n        return uint256(pvExternal);\n    }\n\n    /** @dev See {IERC4626-totalAssets} */\n    function totalAssets() public view override returns (uint256) {\n        return hasMatured() ?  _getMaturedValue() : _getPresentValue(totalSupply());\n    }\n\n    /** @dev See {IERC4626-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Scales assets by the value of a single unit of fCash\n            uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));\n            return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;\n        }\n\n        return (assets * totalSupply()) / totalAssets();\n    }\n\n    /** @dev See {IERC4626-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            // Catch the edge case where totalSupply causes a divide by zero error\n            return _getPresentValue(shares);\n        }\n\n        return (shares * totalAssets()) / supply;\n    }\n\n    /** @dev See {IERC4626-maxDeposit} */\n    function maxDeposit(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxMint} */\n    function maxMint(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw} */\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        return previewWithdraw(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4626-maxRedeem} */\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit} */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n\n            return fCashAmount;\n        }\n    }\n\n    /** @dev See {IERC4626-previewMint} */\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        if (hasMatured()) {\n            return 0;\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n\n            return depositAmountUnderlying;\n        }\n    }\n\n    /** @dev See {IERC4626-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-previewRedeem} */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        if (hasMatured()) {\n            assets = convertToAssets(shares);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    /** @dev See {IERC4626-deposit} */\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        uint256 shares = previewDeposit(assets);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint} */\n    function mint(uint256 shares, address receiver) public override returns (uint256) {\n        uint256 assets = previewMint(shares);\n        // Will revert if matured\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        uint256 shares = previewWithdraw(assets);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        // It is more accurate and gas efficient to check the balance of the\n        // receiver here than rely on the previewRedeem method.\n        uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);\n        uint256 assets = balanceAfter - balanceBefore;\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        return assets;\n    }\n\n    function _redeemInternal(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) private {\n        bytes memory userData = abi.encode(\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: 0\n            })\n        );\n\n        // No operator data\n        _burn(owner, shares, userData, \"\");\n    }\n\n    function _safeNegInt88(uint256 x) private pure returns (int88) {\n        int256 y = -int256(x);\n        require(int256(type(int88).min) <= y);\n        return int88(y);\n    }\n}\n\n",
        "CodeNames": [
            "wfCashERC4626.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "deposit(), mint(), and _redeemInternal() functions in wfCashERC4626 contract",
                "Type": "Incorrect parameter usage",
                "Description": "The deposit(), mint(), withdraw(), and redeem() functions in wfCashERC4626 contract always call _mintInternal() and _burn() functions with useUnderlying parameter set to true, which causes NotionalV2.batchLend() and NotionalV2.batchBalanceAndTradeAction() functions to fail for fcash tokens whose asset token is underlying token. This makes the contract useless for those tokens.",
                "Repair": "Check if the asset token is underlying token or not and set useUnderlying parameter accordingly"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\npragma experimental ABIEncoderV2;\n\nimport \"./wfCashBase.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @dev This implementation contract is deployed as an UpgradeableBeacon. Each BeaconProxy\n/// that uses this contract as an implementation will call initialize to set its own fCash id.\n/// That identifier will represent the fCash that this ERC20 wrapper can hold.\nabstract contract wfCashLogic is wfCashBase, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\n    // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;\n\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashBase(_notional, _weth) {}\n\n    /***** Mint Methods *****/\n\n    /// @notice Lends deposit amount in return for fCashAmount using cTokens or aTokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaAsset(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, false);\n    }\n\n    /// @notice Lends deposit amount in return for fCashAmount using underlying tokens\n    /// @param depositAmountExternal amount of cash to deposit into this method\n    /// @param fCashAmount amount of fCash to purchase (lend)\n    /// @param receiver address to receive the fCash shares\n    /// @param minImpliedRate minimum annualized interest rate to lend at\n    function mintViaUnderlying(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate\n    ) external override {\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, true);\n    }\n\n    function _mintInternal(\n        uint256 depositAmountExternal,\n        uint88 fCashAmount,\n        address receiver,\n        uint32 minImpliedRate,\n        bool useUnderlying\n    ) internal nonReentrant {\n        require(!hasMatured(), \"fCash matured\");\n        (IERC20 token, bool isETH) = getToken(useUnderlying);\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\n\n        // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses\n        // ETH natively but due to pull payment requirements for batchLend, it does not support\n        // ETH. batchLend only supports ERC20 tokens like cETH or aETH. Since the wrapper is a compatibility\n        // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using\n        // \"batchLend\" we will use \"batchBalanceActionWithTrades\". The difference is that \"batchLend\"\n        // is more gas efficient (does not require and additional redeem call to asset tokens). If using cETH\n        // then everything will proceed via batchLend.\n        if (isETH) {\n            IERC20((address(WETH))).safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n            WETH.withdraw(depositAmountExternal);\n\n            BalanceActionWithTrades[] memory action = EncodeDecode.encodeLendETHTrade(\n                getCurrencyId(),\n                getMarketIndex(),\n                depositAmountExternal,\n                fCashAmount,\n                minImpliedRate\n            );\n            // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those\n            // native ETH tokens will be wrapped back to WETH.\n            NotionalV2.batchBalanceAndTradeAction{value: depositAmountExternal}(address(this), action);\n        } else {\n            // Transfers tokens in for lending, Notional will transfer from this contract.\n            token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);\n\n            // Executes a lending action on Notional\n            BatchLend[] memory action = EncodeDecode.encodeLendTrade(\n                getCurrencyId(),\n                getMarketIndex(),\n                fCashAmount,\n                minImpliedRate,\n                useUnderlying\n            );\n            NotionalV2.batchLend(address(this), action);\n        }\n\n        // Mints ERC20 tokens for the receiver, the false flag denotes that we will not do an\n        // operatorAck\n        _mint(receiver, fCashAmount, \"\", \"\", false);\n\n        _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\n    }\n\n    /// @notice This hook will be called every time this contract receives fCash, will validate that\n    /// this is the correct fCash and then mint the corresponding amount of wrapped fCash tokens\n    /// back to the user.\n    function onERC1155Received(\n        address _operator,\n        address _from,\n        uint256 _id,\n        uint256 _value,\n        bytes calldata _data\n    ) external nonReentrant returns (bytes4) {\n        uint256 fCashID = getfCashId();\n        // Only accept erc1155 transfers from NotionalV2\n        require(\n            msg.sender == address(NotionalV2) &&\n            // Only accept the fcash id that corresponds to the listed currency and maturity\n            _id == fCashID &&\n            // Protect against signed value underflows\n            int256(_value) > 0,\n            \"Invalid\"\n        );\n\n        // Double check the account's position, these are not strictly necessary and add gas costs\n        // but might be good safe guards\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\n        PortfolioAsset[] memory assets = NotionalV2.getAccountPortfolio(address(this));\n        require(\n            ac.hasDebt == 0x00 &&\n            assets.length == 1 &&\n            EncodeDecode.encodeERC1155Id(\n                assets[0].currencyId,\n                assets[0].maturity,\n                assets[0].assetType\n            ) == fCashID\n        );\n\n        // Update per account fCash balance, calldata from the ERC1155 call is\n        // passed via the ERC777 interface.\n        bytes memory userData;\n        bytes memory operatorData;\n        if (_operator == _from) userData = _data;\n        else operatorData = _data;\n\n        // We don't require a recipient ack here to maintain compatibility\n        // with contracts that don't support ERC777\n        _mint(_from, _value, userData, operatorData, false);\n\n        // This will allow the fCash to be accepted\n        return ERC1155_ACCEPTED;\n    }\n\n    /***** Redeem (Burn) Methods *****/\n\n    /// @notice Redeems tokens using custom options\n    /// @dev re-entrancy is protected on _burn\n    function redeem(uint256 amount, RedeemOpts memory opts) public override {\n        bytes memory data = abi.encode(opts);\n        // In this case, the owner is msg.sender based on the OZ ERC777 implementation\n        burn(amount, data);\n    }\n\n    /// @notice Redeems tokens to asset tokens\n    /// @dev re-entrancy is protected on _burn\n    function redeemToAsset(\n        uint256 amount,\n        address receiver,\n        uint32 maxImpliedRate\n    ) external override {\n        redeem(\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: false,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: maxImpliedRate\n            })\n        );\n    }\n\n    /// @notice Redeems tokens to underlying\n    /// @dev re-entrancy is protected on _burn\n    function redeemToUnderlying(\n        uint256 amount,\n        address receiver,\n        uint32 maxImpliedRate\n    ) external override {\n        redeem(\n            amount,\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: maxImpliedRate\n            })\n        );\n    }\n\n    /// @notice Called before tokens are burned (redemption) and so we will handle\n    /// the fCash properly before and after maturity.\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) internal override nonReentrant {\n        // Save the total supply value before burning to calculate the cash claim share\n        uint256 initialTotalSupply = totalSupply();\n        RedeemOpts memory opts = abi.decode(userData, (RedeemOpts));\n        require(opts.receiver != address(0), \"Receiver is zero address\");\n        // This will validate that the account has sufficient tokens to burn and make\n        // any relevant underlying stateful changes to balances.\n        super._burn(from, amount, userData, operatorData);\n\n        if (hasMatured()) {\n            // If the fCash has matured, then we need to ensure that the account is settled\n            // and then we will transfer back the account's share of asset tokens.\n\n            // This is a noop if the account is already settled\n            NotionalV2.settleAccount(address(this));\n            uint16 currencyId = getCurrencyId();\n\n            (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n            require(0 < cashBalance, \"Negative Cash Balance\");\n\n            // This always rounds down in favor of the wrapped fCash contract.\n            uint256 assetInternalCashClaim = (uint256(cashBalance) * amount) / initialTotalSupply;\n\n            // Transfer withdrawn tokens to the `from` address\n            _withdrawCashToAccount(\n                currencyId,\n                opts.receiver,\n                _safeUint88(assetInternalCashClaim),\n                opts.redeemToUnderlying\n            );\n        } else if (opts.transferfCash) {\n            // If the fCash has not matured, then we can transfer it via ERC1155.\n            // NOTE: this may fail if the destination is a contract and it does not implement \n            // the `onERC1155Received` hook. If that is the case it is possible to use a regular\n            // ERC20 transfer on this contract instead.\n            NotionalV2.safeTransferFrom(\n                address(this), // Sending from this contract\n                opts.receiver, // Where to send the fCash\n                getfCashId(), // fCash identifier\n                amount, // Amount of fCash to send\n                userData\n            );\n        } else {\n            _sellfCash(\n                opts.receiver,\n                amount,\n                opts.redeemToUnderlying,\n                opts.maxImpliedRate\n            );\n        }\n    }\n\n    /// @notice After maturity, withdraw cash back to account\n    function _withdrawCashToAccount(\n        uint16 currencyId,\n        address receiver,\n        uint88 assetInternalCashClaim,\n        bool toUnderlying\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(toUnderlying);\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\n\n        NotionalV2.withdraw(currencyId, assetInternalCashClaim, toUnderlying);\n\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    /// @dev Sells an fCash share back on the Notional AMM\n    function _sellfCash(\n        address receiver,\n        uint256 fCashToSell,\n        bool toUnderlying,\n        uint32 maxImpliedRate\n    ) private returns (uint256 tokensTransferred) {\n        (IERC20 token, bool isETH) = getToken(toUnderlying);\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\n\n        // Sells fCash on Notional AMM (via borrowing)\n        BalanceActionWithTrades[] memory action = EncodeDecode.encodeBorrowTrade(\n            getCurrencyId(),\n            getMarketIndex(),\n            _safeUint88(fCashToSell),\n            maxImpliedRate,\n            toUnderlying\n        );\n        NotionalV2.batchBalanceAndTradeAction(address(this), action);\n\n        // Send borrowed cash back to receiver\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\n    }\n\n    function _sendTokensToReceiver(\n        IERC20 token,\n        address receiver,\n        bool isETH,\n        uint256 balanceBefore\n    ) private returns (uint256 tokensTransferred) {\n        uint256 balanceAfter = isETH ? address(this).balance : token.balanceOf(address(this));\n        tokensTransferred = balanceAfter - balanceBefore;\n\n        if (isETH) {\n            WETH.deposit{value: tokensTransferred}();\n            IERC20(address(WETH)).safeTransfer(receiver, tokensTransferred);\n        } else {\n            token.safeTransfer(receiver, tokensTransferred);\n        }\n    }\n\n    function _safeUint88(uint256 x) internal pure returns (uint88) {\n        require(x <= uint256(type(uint88).max));\n        return uint88(x);\n    }\n}\n\n",
        "CodeNames": [
            "wfCashLogic.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "wfCashLogic.sol#L216",
                "Type": "Unexpected behavior",
                "Description": "If maturity is reached and user has asked for redeem with opts.transferfCash as true, then if (hasMatured()) turns true at wfCashLogic.sol#L216 causing fcash to be cashed out in underlying token and then sent to receiver. So receiver obtains underlying when fcash was expected. The sender wont get an error thinking fcash transfer was success1.",
                "Repair": "Throw an error mentioning that fCash can no longer be transferred"
            }
        ]
    }
]