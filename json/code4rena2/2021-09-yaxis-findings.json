[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./VaultToken.sol\";\n\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/ExtendedIERC20.sol\";\n\n/**\n * @title Vault\n * @notice The vault is where users deposit and withdraw\n * like-kind assets that have been added by governance.\n */\ncontract Vault is VaultToken, IVault {\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX = 10000;\n\n    IManager public immutable override manager;\n\n    // Strategist-updated variables\n    address public override gauge;\n    uint256 public min;\n    uint256 public totalDepositCap;\n\n    event Deposit(address indexed account, uint256 amount);\n    event Withdraw(address indexed account, uint256 amount);\n    event Earn(address indexed token, uint256 amount);\n\n    /**\n     * @param _name The name of the vault token for depositors\n     * @param _symbol The symbol of the vault token for depositors\n     * @param _manager The address of the vault manager contract\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _manager\n    )\n        public\n        VaultToken(_name, _symbol)\n    {\n        manager = IManager(_manager);\n        min = 9500;\n        totalDepositCap = 10000000 ether;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the value of this vault's gauge\n     * @dev Allow to be unset with the zero address\n     * @param _gauge The address of the gauge\n     */\n    function setGauge(\n        address _gauge\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        gauge = _gauge;\n    }\n\n    /**\n     * @notice Sets the value for min\n     * @dev min is the minimum percent of funds to keep small withdrawals cheap\n     * @param _min The new min value\n     */\n    function setMin(\n        uint256 _min\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(_min <= MAX, \"!_min\");\n        min = _min;\n    }\n\n    /**\n     * @notice Sets the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(\n        uint256 _totalDepositCap\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * @notice Swaps tokens held within the vault\n     * @param _token0 The token address to swap out\n     * @param _token1 The token address to to\n     * @param _expectedAmount The expected amount of _token1 to receive\n     */\n    function swap(\n        address _token0,\n        address _token1,\n        uint256 _expectedAmount\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n        returns (uint256 _balance)\n    {\n        IConverter _converter = IConverter(IController(manager.controllers(address(this))).converter(address(this)));\n        _balance = IERC20(_token0).balanceOf(address(this));\n        IERC20(_token0).safeTransfer(address(_converter), _balance);\n        _balance = _converter.convert(_token0, _token1, _balance, _expectedAmount);\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn(\n        address _token,\n        address _strategy\n    )\n        external\n        override\n        checkToken(_token)\n        notHalted\n        onlyHarvester\n    {\n        require(manager.allowedStrategies(_strategy), \"!_strategy\");\n        IController _controller = IController(manager.controllers(address(this)));\n        if (_controller.investEnabled()) {\n            uint256 _balance = available(_token);\n            IERC20(_token).safeTransfer(address(_controller), _balance);\n            _controller.earn(_strategy, _token, _balance);\n            emit Earn(_token, _balance);\n        }\n    }\n\n    /**\n     * USER-FACING FUNCTIONS\n     */\n\n    /**\n     * @notice Deposits the given token into the vault\n     * @param _token The address of the token\n     * @param _amount The amount of tokens to deposit\n     */\n     function deposit(\n        address _token,\n        uint256 _amount\n     )\n        public\n        override\n        checkToken(_token)\n        notHalted\n        returns (uint256 _shares)\n    {\n        require(_amount > 0, \"!_amount\");\n\n        uint256 _balance = balance();\n\n        uint256 _before = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        _amount = IERC20(_token).balanceOf(address(this)).sub(_before);\n\n        if (_amount > 0) {\n            _amount = _normalizeDecimals(_token, _amount);\n\n            if (totalSupply() > 0) {\n                _amount = (_amount.mul(totalSupply())).div(_balance);\n            }\n\n            _shares = _amount;\n        }\n\n        if (_shares > 0) {\n            _mint(msg.sender, _shares);\n            require(totalSupply() <= totalDepositCap, \">totalDepositCap\");\n            emit Deposit(msg.sender, _shares);\n        }\n    }\n\n    /**\n     * @notice Deposits multiple tokens simultaneously to the vault\n     * @dev Users must approve the vault to spend their stablecoin\n     * @param _tokens The addresses of each token being deposited\n     * @param _amounts The amounts of each token being deposited\n     */\n    function depositMultiple(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    )\n        external\n        override\n        returns (uint256 _shares)\n    {\n        require(_tokens.length == _amounts.length, \"!length\");\n\n        for (uint8 i; i < _amounts.length; i++) {\n            _shares = _shares.add(deposit(_tokens[i], _amounts[i]));\n        }\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output token\n     * @param _shares The amount of shares to withdraw\n     * @param _output The address of the token to receive\n     */\n    function withdraw(\n        uint256 _shares,\n        address _output\n    )\n        public\n        override\n        checkToken(_output)\n    {\n        uint256 _amount = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();\n        if (_withdrawalProtectionFee > 0) {\n            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);\n            _amount = _amount.sub(_withdrawalProtection);\n        }\n\n        uint256 _balance = IERC20(_output).balanceOf(address(this));\n        if (_balance < _amount) {\n            IController _controller = IController(manager.controllers(address(this)));\n            uint256 _toWithdraw = _amount.sub(_balance);\n            if (_controller.strategies() > 0) {\n                _controller.withdraw(_output, _toWithdraw);\n            }\n            uint256 _after = IERC20(_output).balanceOf(address(this));\n            uint256 _diff = _after.sub(_balance);\n            if (_diff < _toWithdraw) {\n                _amount = _after;\n            }\n        }\n\n        IERC20(_output).safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     * @param _output The address of the desired token to receive\n     */\n    function withdrawAll(\n        address _output\n    )\n        external\n        override\n    {\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    /**\n     * VIEWS\n     */\n\n    /**\n     * @notice Returns the amount of tokens available to be sent to strategies\n     * @dev Custom logic in here for how much the vault allows to be borrowed\n     * @dev Sets minimum required on-hand to keep small withdrawals cheap\n     * @param _token The address of the token\n     */\n    function available(\n        address _token\n    )\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return IERC20(_token).balanceOf(address(this)).mul(min).div(MAX);\n    }\n\n    /**\n     * @notice Returns the total balance of the vault, including strategies\n     */\n    function balance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());\n    }\n\n    /**\n     * @notice Returns the balance of allowed tokens present on the vault only\n     */\n    function balanceOfThis()\n        public\n        view\n        returns (uint256 _balance)\n    {\n        address[] memory _tokens = manager.getTokens(address(this));\n        for (uint8 i; i < _tokens.length; i++) {\n            address _token = _tokens[i];\n            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n        }\n    }\n\n    /**\n     * @notice Returns the rate of vault shares\n     */\n    function getPricePerFullShare()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalSupply() > 0) {\n            return balance().mul(1e18).div(totalSupply());\n        } else {\n            return balance();\n        }\n    }\n\n    /**\n     * @notice Returns an array of the tokens for this vault\n     */\n    function getTokens()\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return manager.getTokens(address(this));\n    }\n\n    /**\n     * @notice Returns the fee for withdrawing the given amount\n     * @param _amount The amount to withdraw\n     */\n    function withdrawFee(\n        uint256 _amount\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);\n    }\n\n    function _normalizeDecimals(\n        address _token,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = uint256(ExtendedIERC20(_token).decimals());\n        if (_decimals < 18) {\n            _amount = _amount.mul(10**(18-_decimals));\n        }\n        return _amount;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier checkToken(address _token) {\n        require(manager.allowedTokens(_token) && manager.vaults(_token) == address(this), \"!_token\");\n        _;\n    }\n\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IConverter.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IHarvester.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IManager.sol\";\n\n/**\n * @title Controller\n * @notice This controller allows multiple strategies to be used\n * for a single vault supporting multiple tokens.\n */\ncontract Controller is IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IManager public immutable override manager;\n\n    bool public globalInvestEnabled;\n    uint256 public maxStrategies;\n\n    struct VaultDetail {\n        address converter;\n        uint256 balance;\n        address[] strategies;\n        mapping(address => uint256) balances;\n        mapping(address => uint256) index;\n        mapping(address => uint256) caps;\n    }\n\n    // vault => Vault\n    mapping(address => VaultDetail) internal _vaultDetails;\n    // strategy => vault\n    mapping(address => address) internal _vaultStrategies;\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(address indexed strategy);\n\n    /**\n     * @notice Logged when a strategy is added for a vault\n     */\n    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);\n\n    /**\n     * @notice Logged when a strategy is removed for a vault\n     */\n    event StrategyRemoved(address indexed vault, address indexed strategy);\n\n    /**\n     * @notice Logged when strategies are reordered for a vault\n     */\n    event StrategiesReordered(\n        address indexed vault,\n        address indexed strategy1,\n        address indexed strategy2\n    );\n\n    /**\n     * @param _manager The address of the manager\n     */\n    constructor(\n        address _manager\n    )\n        public\n    {\n        manager = IManager(_manager);\n        globalInvestEnabled = true;\n        maxStrategies = 10;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _cap The cap of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        uint256 _timeout\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        require(_vaultDetails[_vault].converter != address(0), \"!converter\");\n        // checking if strategy is already added\n        require(_vaultStrategies[_strategy] == address(0), \"Strategy is already added\"); \n        // get the index of the newly added strategy\n        uint256 index = _vaultDetails[_vault].strategies.length;\n        // ensure we haven't added too many strategies already\n        require(index < maxStrategies, \"!maxStrategies\");\n        // push the strategy to the array of strategies\n        _vaultDetails[_vault].strategies.push(_strategy);\n        // set the cap\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        // set the index\n        _vaultDetails[_vault].index[_strategy] = index;\n        // store the mapping of strategy to the vault\n        _vaultStrategies[_strategy] = _vault;\n        if (_timeout > 0) {\n            // add it to the harvester\n            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);\n        }\n        emit StrategyAdded(_vault, _strategy, _cap);\n    }\n\n    /**\n     * @notice Withdraws token from a strategy to the treasury address as returned by the manager\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     */\n    function inCaseStrategyGetStuck(\n        address _strategy,\n        address _token\n    )\n        external\n        onlyStrategist\n    {\n        IStrategy(_strategy).withdraw(_token);\n        IERC20(_token).safeTransfer(\n            manager.treasury(),\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice Withdraws token from the controller to the treasury\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function inCaseTokensGetStuck(\n        address _token,\n        uint256 _amount\n    )\n        external\n        onlyStrategist\n    {\n        IERC20(_token).safeTransfer(manager.treasury(), _amount);\n    }\n\n    /**\n     * @notice Removes a strategy for a given token\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        VaultDetail storage vaultDetail = _vaultDetails[_vault];\n        // get the index of the strategy to remove\n        uint256 index = vaultDetail.index[_strategy];\n        // get the index of the last strategy\n        uint256 tail = vaultDetail.strategies.length.sub(1);\n        // get the address of the last strategy\n        address replace = vaultDetail.strategies[tail];\n        // replace the removed strategy with the tail\n        vaultDetail.strategies[index] = replace;\n        // set the new index for the replaced strategy\n        vaultDetail.index[replace] = index;\n        // remove the duplicate replaced strategy\n        vaultDetail.strategies.pop();\n        // remove the strategy's index\n        delete vaultDetail.index[_strategy];\n        // remove the strategy's cap\n        delete vaultDetail.caps[_strategy];\n        // remove the strategy's balance\n        delete vaultDetail.balances[_strategy];\n        // remove the mapping of strategy to the vault\n        delete _vaultStrategies[_strategy];\n        // pull funds from the removed strategy to the vault\n        IStrategy(_strategy).withdrawAll();\n        // remove the strategy from the harvester\n        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);\n        emit StrategyRemoved(_vault, _strategy);\n    }\n\n    /**\n     * @notice Reorders two strategies for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy1 The address of the first strategy\n     * @param _strategy2 The address of the second strategy\n     */\n    function reorderStrategies(\n        address _vault,\n        address _strategy1,\n        address _strategy2\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        require(_vaultStrategies[_strategy1] == _vault, \"!_strategy1\");\n        require(_vaultStrategies[_strategy2] == _vault, \"!_strategy2\");\n        VaultDetail storage vaultDetail = _vaultDetails[_vault];\n        // get the indexes of the strategies\n        uint256 index1 = vaultDetail.index[_strategy1];\n        uint256 index2 = vaultDetail.index[_strategy2];\n        // set the new addresses at their indexes\n        vaultDetail.strategies[index1] = _strategy2;\n        vaultDetail.strategies[index2] = _strategy1;\n        // update indexes\n        vaultDetail.index[_strategy1] = index2;\n        vaultDetail.index[_strategy2] = index1;\n        emit StrategiesReordered(_vault, _strategy1, _strategy2);\n    }\n\n    /**\n     * @notice Sets/updates the cap of a strategy for a vault\n     * @dev If the balance of the strategy is greater than the new cap (except if\n     * the cap is 0), then withdraw the difference from the strategy to the vault.\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _cap The new cap of the strategy\n     */\n    function setCap(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        address _convert\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        uint256 _balance = IStrategy(_strategy).balanceOf();\n        // send excess funds (over cap) back to the vault\n        if (_balance > _cap && _cap != 0) {\n            uint256 _diff = _balance.sub(_cap);\n            IStrategy(_strategy).withdraw(_diff);\n            updateBalance(_vault, _strategy);\n            _balance = IStrategy(_strategy).balanceOf();\n            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);\n            address _want = IStrategy(_strategy).want();\n            _balance = IERC20(_want).balanceOf(address(this));\n            if (_convert != address(0)) {\n                IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n                IERC20(_want).safeTransfer(address(_converter), _balance);\n                _balance = _converter.convert(_want, _convert, _balance, 1);\n                IERC20(_convert).safeTransfer(_vault, _balance);\n            } else {\n                IERC20(_want).safeTransfer(_vault, _balance);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets/updates the converter for a given vault\n     * @param _vault The address of the vault\n     * @param _converter The address of the converter\n     */\n    function setConverter(\n        address _vault,\n        address _converter\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedConverters(_converter), \"!allowedConverters\");\n        _vaultDetails[_vault].converter = _converter;\n    }\n\n    /**\n     * @notice Sets/updates the global invest enabled flag\n     * @param _investEnabled The new bool of the invest enabled flag\n     */\n    function setInvestEnabled(\n        bool _investEnabled\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        globalInvestEnabled = _investEnabled;\n    }\n\n    /**\n     * @notice Sets/updates the maximum number of strategies for a vault\n     * @param _maxStrategies The new value of the maximum strategies\n     */\n    function setMaxStrategies(\n        uint256 _maxStrategies\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        maxStrategies = _maxStrategies;\n    }\n\n    function skim(\n        address _strategy\n    )\n        external\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        address _want = IStrategy(_strategy).want();\n        IStrategy(_strategy).skim();\n        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Withdraws all funds from a strategy\n     * @param _strategy The address of the strategy\n     * @param _convert The token address to convert to\n     */\n    function withdrawAll(\n        address _strategy,\n        address _convert\n    )\n        external\n        override\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        address _want = IStrategy(_strategy).want();\n        IStrategy(_strategy).withdrawAll();\n        uint256 _amount = IERC20(_want).balanceOf(address(this));\n        address _vault = _vaultStrategies[_strategy];\n        updateBalance(_vault, _strategy);\n        if (_convert != address(0)) {\n            IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n            IERC20(_want).safeTransfer(address(_converter), _amount);\n            _amount = _converter.convert(_want, _convert, _amount, 1);\n            IERC20(_convert).safeTransfer(_vault, _amount);\n        } else {\n            IERC20(_want).safeTransfer(_vault, _amount);\n        }\n        uint256 _balance = _vaultDetails[_vault].balance;\n        if (_balance >= _amount) {\n            _vaultDetails[_vault].balance = _balance.sub(_amount);\n        } else {\n            _vaultDetails[_vault].balance = 0;\n        }\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Harvests the specified strategy\n     * @param _strategy The address of the strategy\n     */\n    function harvestStrategy(\n        address _strategy,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        external\n        override\n        notHalted\n        onlyHarvester\n        onlyStrategy(_strategy)\n    {\n        uint256 _before = IStrategy(_strategy).balanceOf();\n        IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);\n        uint256 _after = IStrategy(_strategy).balanceOf();\n        address _vault = _vaultStrategies[_strategy];\n        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));\n        _vaultDetails[_vault].balances[_strategy] = _after;\n        emit Harvest(_strategy);\n    }\n\n    /**\n     * VAULT-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Invests funds into a strategy\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     * @param _amount The amount that will be invested\n     */\n    function earn(\n        address _strategy,\n        address _token,\n        uint256 _amount\n    )\n        external\n        override\n        notHalted\n        onlyStrategy(_strategy)\n        onlyVault(_token)\n    {\n        // get the want token of the strategy\n        address _want = IStrategy(_strategy).want();\n        if (_want != _token) {\n            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);\n            IERC20(_token).safeTransfer(address(_converter), _amount);\n            // TODO: do estimation for received\n            _amount = _converter.convert(_token, _want, _amount, 1);\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);\n        // call the strategy deposit function\n        IStrategy(_strategy).deposit();\n        updateBalance(msg.sender, _strategy);\n    }\n\n    /**\n     * @notice Withdraws funds from a strategy\n     * @dev If the withdraw amount is greater than the first strategy given\n     * by getBestStrategyWithdraw, this function will loop over strategies\n     * until the requested amount is met.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function withdraw(\n        address _token,\n        uint256 _amount\n    )\n        external\n        override\n        onlyVault(_token)\n    {\n        (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        ) = getBestStrategyWithdraw(_token, _amount);\n        for (uint i = 0; i < _strategies.length; i++) {\n            // getBestStrategyWithdraw will return arrays larger than needed\n            // if this happens, simply exit the loop\n            if (_strategies[i] == address(0)) {\n                break;\n            }\n            IStrategy(_strategies[i]).withdraw(_amounts[i]);\n            updateBalance(msg.sender, _strategies[i]);\n            address _want = IStrategy(_strategies[i]).want();\n            if (_want != _token) {\n                address _converter = _vaultDetails[msg.sender].converter;\n                IERC20(_want).safeTransfer(_converter, _amounts[i]);\n                // TODO: do estimation for received\n                IConverter(_converter).convert(_want, _token, _amounts[i], 1);\n            }\n        }\n        _amount = IERC20(_token).balanceOf(address(this));\n        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the rough balance of the sum of all strategies for a given vault\n     * @dev This function is optimized to prevent looping over all strategy balances,\n     * and instead the controller tracks the earn, withdraw, and harvest amounts.\n     */\n    function balanceOf()\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return _vaultDetails[msg.sender].balance;\n    }\n\n    /**\n     * @notice Returns the converter assigned for the given vault\n     * @param _vault Address of the vault\n     */\n    function converter(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address)\n    {\n        return _vaultDetails[_vault].converter;\n    }\n\n    /**\n     * @notice Returns the cap of a strategy for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     */\n    function getCap(\n        address _vault,\n        address _strategy\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _vaultDetails[_vault].caps[_strategy];\n    }\n\n    /**\n     * @notice Returns whether investing is enabled for the calling vault\n     * @dev Should be called by the vault\n     */\n    function investEnabled()\n        external\n        view\n        override\n        returns (bool)\n    {\n        if (globalInvestEnabled) {\n            return _vaultDetails[msg.sender].strategies.length > 0;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns all the strategies for a given vault\n     * @param _vault The address of the vault\n     */\n    function strategies(\n        address _vault\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return _vaultDetails[_vault].strategies;\n    }\n\n    /**\n     * @notice Returns the length of the strategies of the calling vault\n     * @dev This function is expected to be called by a vault\n     */\n    function strategies()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _vaultDetails[msg.sender].strategies.length;\n    }\n\n    /**\n     * INTERNAL FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from\n     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays\n     * from this function will always be the same length as the amount of strategies for\n     * a token. Check that _strategies[i] != address(0) when consuming to know when to\n     * break out of the loop.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function getBestStrategyWithdraw(\n        address _token,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        )\n    {\n        // get the length of strategies for a single token\n        address _vault = manager.vaults(_token);\n        uint256 k = _vaultDetails[_vault].strategies.length;\n        // initialize fixed-length memory arrays\n        _strategies = new address[](k);\n        _amounts = new uint256[](k);\n        address _strategy;\n        uint256 _balance;\n        // scan forward from the the beginning of strategies\n        for (uint i = 0; i < k; i++) {\n            _strategy = _vaultDetails[_vault].strategies[i];\n            _strategies[i] = _strategy;\n            // get the balance of the strategy\n            _balance = _vaultDetails[_vault].balances[_strategy];\n            // if the strategy doesn't have the balance to cover the withdraw\n            if (_balance < _amount) {\n                // withdraw what we can and add to the _amounts\n                _amounts[i] = _balance;\n                _amount = _amount.sub(_balance);\n            } else {\n                // stop scanning if the balance is more than the withdraw amount\n                _amounts[i] = _amount;\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the stored balance of a given strategy for a vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     */\n    function updateBalance(\n        address _vault,\n        address _strategy\n    )\n        internal\n    {\n        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    /**\n     * @notice Reverts if the protocol is halted\n     */\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not governance\n     */\n    modifier onlyGovernance() {\n        require(msg.sender == manager.governance(), \"!governance\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the strategist\n     */\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the strategy is not allowed in the manager\n     */\n    modifier onlyStrategy(address _strategy) {\n        require(manager.allowedStrategies(_strategy), \"!allowedStrategy\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the harvester\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the vault for the given token\n     */\n    modifier onlyVault(address _token) {\n        require(msg.sender == manager.vaults(_token), \"!vault\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol",
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Vault contract and Controller contract",
                "Type": "Smart Contract Vulnerability",
                "Description": "Vault withdrawals can be frontrun to cause users to burn tokens without receiving funds in return, treating all tokens exactly the same creates (huge) arbitrage opportunities, token -> vault mapping can be overwritten, controller does not raise an error when there's insufficient liquidity, controller is vulnerable to sandwich attack",
                "Repair": "Check withdrawal amount against getPricePerFullShare() and use a single source of truth for mapping, revert transaction when there's insufficient liquidity, specify minimum return amount when calling swap"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./interfaces/ILiquidityGaugeV2.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/**\n * @title VaultHelper\n * @notice The VaultHelper acts as a single contract that users may set\n * token approvals on for any token of any vault.\n * @dev This contract has no state and could be deployed by anyone if\n * they didn't trust the original deployer.\n */\ncontract VaultHelper {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Deposits the given token into the specified vault\n     * @dev Users must approve the vault helper to spend their token\n     * @param _vault The address of the vault\n     * @param _token The address of the token\n     * @param _amount The amount of tokens to deposit\n     */\n    function depositVault(\n        address _vault,\n        address _token,\n        uint256 _amount\n    )\n        external\n    {\n        require(_amount > 0, \"!_amount\");\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        IERC20(_token).safeApprove(_vault, 0);\n        IERC20(_token).safeApprove(_vault, _amount);\n        uint256 _shares = IVault(_vault).deposit(_token, _amount);\n        address _gauge = IVault(_vault).gauge();\n        if (_gauge != address(0)) {\n            IERC20(_vault).safeApprove(_gauge, 0);\n            IERC20(_vault).safeApprove(_gauge, _shares);\n            ILiquidityGaugeV2(_gauge).deposit(_shares);\n            IERC20(_gauge).safeTransfer(msg.sender, _shares);\n        } else {\n            IERC20(_vault).safeTransfer(msg.sender, _shares);\n        }\n    }\n\n    /**\n     * @notice Deposits multiple tokens simultaneously to the specified vault\n     * @dev Users must approve the vault helper to spend their tokens\n     * @param _vault The address of the vault\n     * @param _tokens The addresses of each token being deposited\n     * @param _amounts The amounts of each token being deposited\n     */\n    function depositMultipleVault(\n        address _vault,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    )\n        external\n    {\n        require(_tokens.length == _amounts.length, \"!length\");\n\n        for (uint8 i = 0; i < _amounts.length; i++) {\n            require(_amounts[i] > 0, \"!_amounts\");\n            IERC20(_tokens[i]).safeTransferFrom(msg.sender, address(this), _amounts[i]);\n            IERC20(_tokens[i]).safeApprove(_vault, 0);\n            IERC20(_tokens[i]).safeApprove(_vault, _amounts[i]);\n        }\n        uint256 _shares = IVault(_vault).depositMultiple(_tokens, _amounts);\n        address _gauge = IVault(_vault).gauge();\n        if (_gauge != address(0)) {\n            IERC20(_vault).safeApprove(_gauge, 0);\n            IERC20(_vault).safeApprove(_gauge, _shares);\n            ILiquidityGaugeV2(_gauge).deposit(_shares);\n            IERC20(_gauge).safeTransfer(msg.sender, _shares);\n        } else {\n            IERC20(_vault).safeTransfer(msg.sender, _shares);\n        }\n    }\n\n    function withdrawVault(\n        address _vault,\n        address _toToken,\n        uint256 _amount\n    )\n        external\n    {\n        address _gauge = IVault(_vault).gauge();\n        if (_gauge != address(0)) {\n            IERC20(_gauge).safeTransferFrom(msg.sender, address(this), _amount);\n            ILiquidityGaugeV2(_gauge).withdraw(_amount);\n            IVault(_vault).withdraw(IERC20(_vault).balanceOf(address(this)), _toToken);\n            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));\n        } else {\n            IERC20(_vault).safeTransferFrom(msg.sender, address(this), _amount);\n            IVault(_vault).withdraw(_amount, _toToken);\n            IERC20(_toToken).safeTransfer(msg.sender, IERC20(_toToken).balanceOf(address(this)));\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "VaultHelper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaultHelper deposits",
                "Type": "Medium Severity",
                "Description": "VaultHelper deposits don't work with fee-on transfer tokens",
                "Repair": "Measure the asset change right before and after the asset-transferring routines"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n// solhint-disable max-states-count\n// solhint-disable var-name-mixedcase\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IHarvester.sol\";\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/IVault.sol\";\n\n/**\n * @title Manager\n * @notice This contract serves as the central point for governance-voted\n * variables. Fees and permissioned addresses are stored and referenced in\n * this contract only.\n */\ncontract Manager is IManager {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant PENDING_STRATEGIST_TIMELOCK = 7 days;\n    uint256 public constant MAX_TOKENS = 256;\n\n    address public immutable override yaxis;\n\n    bool public override halted;\n\n    address public override governance;\n    address public override harvester;\n    address public override insurancePool;\n    address public override stakingPool;\n    address public override strategist;\n    address public override pendingStrategist;\n    address public override treasury;\n\n    // The following fees are all mutable.\n    // They are updated by governance (community vote).\n    uint256 public override insuranceFee;\n    uint256 public override insurancePoolFee;\n    uint256 public override stakingPoolShareFee;\n    uint256 public override treasuryFee;\n    uint256 public override withdrawalProtectionFee;\n\n\n    uint256 private setPendingStrategistTime;\n\n    // Governance must first allow the following properties before\n    // the strategist can make use of them\n    mapping(address => bool) public override allowedControllers;\n    mapping(address => bool) public override allowedConverters;\n    mapping(address => bool) public override allowedStrategies;\n    mapping(address => bool) public override allowedTokens;\n    mapping(address => bool) public override allowedVaults;\n\n    // vault => controller\n    mapping(address => address) public override controllers;\n    // vault => tokens[]\n    mapping(address => address[]) public override tokens;\n    // token => vault\n    mapping(address => address) public override vaults;\n\n    event AllowedController(\n        address indexed _controller,\n        bool _allowed\n    );\n    event AllowedConverter(\n        address indexed _converter,\n        bool _allowed\n    );\n    event AllowedStrategy(\n        address indexed _strategy,\n        bool _allowed\n    );\n    event AllowedToken(\n        address indexed _token,\n        bool _allowed\n    );\n    event AllowedVault(\n        address indexed _vault,\n        bool _allowed\n    );\n    event Halted();\n    event SetController(\n        address indexed _vault,\n        address indexed _controller\n    );\n    event SetGovernance(\n        address indexed _governance\n    );\n    event SetPendingStrategist(\n        address indexed _strategist\n    );\n    event SetStrategist(\n        address indexed _strategist\n    );\n    event TokenAdded(\n        address indexed _vault,\n        address indexed _token\n    );\n    event TokenRemoved(\n        address indexed _vault,\n        address indexed _token\n    );\n\n    /**\n     * @param _yaxis The address of the YAX token\n     */\n    constructor(\n        address _yaxis\n    )\n        public\n    {\n        require(_yaxis != address(0), \"!_yaxis\");\n        yaxis = _yaxis;\n        governance = msg.sender;\n        strategist = msg.sender;\n        harvester = msg.sender;\n        treasury = msg.sender;\n        stakingPoolShareFee = 2000;\n        treasuryFee = 500;\n        withdrawalProtectionFee = 10;\n    }\n\n    /**\n     * GOVERNANCE-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the permission for the given controller\n     * @param _controller The address of the controller\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedController(\n        address _controller,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IController(_controller).manager()) == address(this), \"!manager\");\n        allowedControllers[_controller] = _allowed;\n        emit AllowedController(_controller, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given converter\n     * @param _converter The address of the converter\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedConverter(\n        address _converter,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IConverter(_converter).manager()) == address(this), \"!manager\");\n        allowedConverters[_converter] = _allowed;\n        emit AllowedConverter(_converter, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given strategy\n     * @param _strategy The address of the strategy\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedStrategy(\n        address _strategy,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IStrategy(_strategy).manager()) == address(this), \"!manager\");\n        allowedStrategies[_strategy] = _allowed;\n        emit AllowedStrategy(_strategy, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given token\n     * @param _token The address of the token\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedToken(\n        address _token,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        allowedTokens[_token] = _allowed;\n        emit AllowedToken(_token, _allowed);\n    }\n\n    /**\n     * @notice Sets the permission for the given vault\n     * @param _vault The address of the vault\n     * @param _allowed The status of if it is allowed\n     */\n    function setAllowedVault(\n        address _vault,\n        bool _allowed\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IVault(_vault).manager()) == address(this), \"!manager\");\n        allowedVaults[_vault] = _allowed;\n        emit AllowedVault(_vault, _allowed);\n    }\n\n    /**\n     * @notice Sets the governance address\n     * @param _governance The address of the governance\n     */\n    function setGovernance(\n        address _governance\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        governance = _governance;\n        emit SetGovernance(_governance);\n    }\n\n    /**\n     * @notice Sets the harvester address\n     * @param _harvester The address of the harvester\n     */\n    function setHarvester(\n        address _harvester\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(address(IHarvester(_harvester).manager()) == address(this), \"!manager\");\n        harvester = _harvester;\n    }\n\n    /**\n     * @notice Sets the insurance fee\n     * @dev Throws if setting fee over 1%\n     * @param _insuranceFee The value for the insurance fee\n     */\n    function setInsuranceFee(\n        uint256 _insuranceFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insuranceFee <= 100, \"_insuranceFee over 1%\");\n        insuranceFee = _insuranceFee;\n    }\n\n    /**\n     * @notice Sets the insurance pool address\n     * @param _insurancePool The address of the insurance pool\n     */\n    function setInsurancePool(\n        address _insurancePool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        insurancePool = _insurancePool;\n    }\n\n    /**\n     * @notice Sets the insurance pool fee\n     * @dev Throws if setting fee over 20%\n     * @param _insurancePoolFee The value for the insurance pool fee\n     */\n    function setInsurancePoolFee(\n        uint256 _insurancePoolFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_insurancePoolFee <= 2000, \"_insurancePoolFee over 20%\");\n        insurancePoolFee = _insurancePoolFee;\n    }\n\n    /**\n     * @notice Sets the staking pool address\n     * @param _stakingPool The address of the staking pool\n     */\n    function setStakingPool(\n        address _stakingPool\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        stakingPool = _stakingPool;\n    }\n\n    /**\n     * @notice Sets the staking pool share fee\n     * @dev Throws if setting fee over 50%\n     * @param _stakingPoolShareFee The value for the staking pool fee\n     */\n    function setStakingPoolShareFee(\n        uint256 _stakingPoolShareFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_stakingPoolShareFee <= 5000, \"_stakingPoolShareFee over 50%\");\n        stakingPoolShareFee = _stakingPoolShareFee;\n    }\n\n    /**\n     * @notice Sets the pending strategist and the timestamp\n     * @param _strategist The address of the strategist\n     */\n    function setStrategist(\n        address _strategist\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_strategist != address(0), \"!_strategist\");\n        pendingStrategist = _strategist;\n        // solhint-disable-next-line not-rely-on-time\n        setPendingStrategistTime = block.timestamp;\n        emit SetPendingStrategist(_strategist);\n    }\n\n    /**\n     * @notice Sets the treasury address\n     * @param _treasury The address of the treasury\n     */\n    function setTreasury(\n        address _treasury\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasury != address(0), \"!_treasury\");\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Sets the treasury fee\n     * @dev Throws if setting fee over 20%\n     * @param _treasuryFee The value for the treasury fee\n     */\n    function setTreasuryFee(\n        uint256 _treasuryFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_treasuryFee <= 2000, \"_treasuryFee over 20%\");\n        treasuryFee = _treasuryFee;\n    }\n\n    /**\n     * @notice Sets the withdrawal protection fee\n     * @dev Throws if setting fee over 1%\n     * @param _withdrawalProtectionFee The value for the withdrawal protection fee\n     */\n    function setWithdrawalProtectionFee(\n        uint256 _withdrawalProtectionFee\n    )\n        external\n        notHalted\n        onlyGovernance\n    {\n        require(_withdrawalProtectionFee <= 100, \"_withdrawalProtectionFee over 1%\");\n        withdrawalProtectionFee = _withdrawalProtectionFee;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Updates the strategist to the pending strategist\n     * @dev This can only be called after the pending strategist timelock (7 days)\n     */\n    function acceptStrategist()\n        external\n        notHalted\n    {\n        require(msg.sender == pendingStrategist, \"!pendingStrategist\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp > setPendingStrategistTime.add(PENDING_STRATEGIST_TIMELOCK), \"PENDING_STRATEGIST_TIMELOCK\");\n        delete pendingStrategist;\n        delete setPendingStrategistTime;\n        strategist = msg.sender;\n        emit SetStrategist(msg.sender);\n    }\n\n    /**\n     * @notice Adds a token to be able to be deposited for a given vault\n     * @param _vault The address of the vault\n     * @param _token The address of the token\n     */\n    function addToken(\n        address _vault,\n        address _token\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        require(allowedTokens[_token], \"!allowedTokens\");\n        require(allowedVaults[_vault], \"!allowedVaults\");\n        require(tokens[_vault].length < MAX_TOKENS, \">tokens\");\n        require(vaults[_token] == address(0), \"!_token\");\n        vaults[_token] = _vault;\n        tokens[_vault].push(_token);\n        emit TokenAdded(_vault, _token);\n    }\n\n    /**\n     * @notice Allows the strategist to pull tokens out of this contract\n     * @dev This contract should never hold tokens\n     * @param _token The address of the token\n     * @param _amount The amount to withdraw\n     * @param _to The address to send to\n     */\n    function recoverToken(\n        IERC20 _token,\n        uint256 _amount,\n        address _to\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        _token.safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice Removes a token from being able to be deposited for a given vault\n     * @param _vault The address of the vault\n     * @param _token The address of the token\n     */\n    function removeToken(\n        address _vault,\n        address _token\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n    {\n        uint256 k = tokens[_vault].length;\n        uint256 index;\n        bool found;\n\n        for (uint i = 0; i < k; i++) {\n            if (tokens[_vault][i] == _token) {\n                index = i;\n                found = true;\n                break;\n            }\n        }\n\n        // TODO: Verify added check\n        if (found) {\n            tokens[_vault][index] = tokens[_vault][k-1];\n            tokens[_vault].pop();\n            delete vaults[_token];\n            emit TokenRemoved(_vault, _token);\n        }\n    }\n\n    /**\n     * @notice Sets the vault address for a controller\n     * @param _vault The address of the vault\n     * @param _controller The address of the controller\n     */\n    function setController(\n        address _vault,\n        address _controller\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(allowedVaults[_vault], \"!_vault\");\n        require(allowedControllers[_controller], \"!_controller\");\n        controllers[_vault] = _controller;\n        emit SetController(_vault, _controller);\n    }\n\n    /**\n     * @notice Sets the protocol as halted, disallowing all deposits forever\n     * @dev Withdraws will still work, allowing users to exit the protocol\n     */\n    function setHalted()\n        external\n        notHalted\n        onlyStrategist\n    {\n        halted = true;\n        emit Halted();\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns an array of token addresses for a given vault\n     * @param _vault The address of the vault\n     */\n    function getTokens(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return tokens[_vault];\n    }\n\n    /**\n     * @notice Returns a tuple of:\n     *     YAXIS token address,\n     *     Treasury address,\n     *     Treasury fee\n     */\n    function getHarvestFeeInfo()\n        external\n        view\n        override\n        returns (\n            address,\n            address,\n            uint256\n        )\n    {\n        return (\n            yaxis,\n            treasury,\n            treasuryFee\n        );\n    }\n\n    modifier notHalted() {\n        require(!halted, \"halted\");\n        _;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance, \"!governance\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == strategist, \"!strategist\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Manager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "addToken function in Manager.sol",
                "Type": "High Severity",
                "Description": "No safety check in addToken",
                "Repair": "Add a check for duplicates"
            },
            {
                "Location": "removeToken function in Manager.sol",
                "Type": "High Severity",
                "Description": "removeToken would break the vault/protocol.",
                "Repair": "Withdraw all tokenA from all strategies, swap tokenA for tokenB in the vault, and remove the token via the Manager function"
            },
            {
                "Location": "setHalted() in Manager.sol",
                "Type": "access control",
                "Description": "A malicious strategist can halt the entire protocol and force a permanent shutdown.",
                "Repair": "Change access control to onlyGovernance from onlyStrategist for setHalted()"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IConverter.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IHarvester.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IManager.sol\";\n\n/**\n * @title Controller\n * @notice This controller allows multiple strategies to be used\n * for a single vault supporting multiple tokens.\n */\ncontract Controller is IController {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IManager public immutable override manager;\n\n    bool public globalInvestEnabled;\n    uint256 public maxStrategies;\n\n    struct VaultDetail {\n        address converter;\n        uint256 balance;\n        address[] strategies;\n        mapping(address => uint256) balances;\n        mapping(address => uint256) index;\n        mapping(address => uint256) caps;\n    }\n\n    // vault => Vault\n    mapping(address => VaultDetail) internal _vaultDetails;\n    // strategy => vault\n    mapping(address => address) internal _vaultStrategies;\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(address indexed strategy);\n\n    /**\n     * @notice Logged when a strategy is added for a vault\n     */\n    event StrategyAdded(address indexed vault, address indexed strategy, uint256 cap);\n\n    /**\n     * @notice Logged when a strategy is removed for a vault\n     */\n    event StrategyRemoved(address indexed vault, address indexed strategy);\n\n    /**\n     * @notice Logged when strategies are reordered for a vault\n     */\n    event StrategiesReordered(\n        address indexed vault,\n        address indexed strategy1,\n        address indexed strategy2\n    );\n\n    /**\n     * @param _manager The address of the manager\n     */\n    constructor(\n        address _manager\n    )\n        public\n    {\n        manager = IManager(_manager);\n        globalInvestEnabled = true;\n        maxStrategies = 10;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _cap The cap of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        uint256 _timeout\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        require(_vaultDetails[_vault].converter != address(0), \"!converter\");\n        // checking if strategy is already added\n        require(_vaultStrategies[_strategy] == address(0), \"Strategy is already added\"); \n        // get the index of the newly added strategy\n        uint256 index = _vaultDetails[_vault].strategies.length;\n        // ensure we haven't added too many strategies already\n        require(index < maxStrategies, \"!maxStrategies\");\n        // push the strategy to the array of strategies\n        _vaultDetails[_vault].strategies.push(_strategy);\n        // set the cap\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        // set the index\n        _vaultDetails[_vault].index[_strategy] = index;\n        // store the mapping of strategy to the vault\n        _vaultStrategies[_strategy] = _vault;\n        if (_timeout > 0) {\n            // add it to the harvester\n            IHarvester(manager.harvester()).addStrategy(_vault, _strategy, _timeout);\n        }\n        emit StrategyAdded(_vault, _strategy, _cap);\n    }\n\n    /**\n     * @notice Withdraws token from a strategy to the treasury address as returned by the manager\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     */\n    function inCaseStrategyGetStuck(\n        address _strategy,\n        address _token\n    )\n        external\n        onlyStrategist\n    {\n        IStrategy(_strategy).withdraw(_token);\n        IERC20(_token).safeTransfer(\n            manager.treasury(),\n            IERC20(_token).balanceOf(address(this))\n        );\n    }\n\n    /**\n     * @notice Withdraws token from the controller to the treasury\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function inCaseTokensGetStuck(\n        address _token,\n        uint256 _amount\n    )\n        external\n        onlyStrategist\n    {\n        IERC20(_token).safeTransfer(manager.treasury(), _amount);\n    }\n\n    /**\n     * @notice Removes a strategy for a given token\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        VaultDetail storage vaultDetail = _vaultDetails[_vault];\n        // get the index of the strategy to remove\n        uint256 index = vaultDetail.index[_strategy];\n        // get the index of the last strategy\n        uint256 tail = vaultDetail.strategies.length.sub(1);\n        // get the address of the last strategy\n        address replace = vaultDetail.strategies[tail];\n        // replace the removed strategy with the tail\n        vaultDetail.strategies[index] = replace;\n        // set the new index for the replaced strategy\n        vaultDetail.index[replace] = index;\n        // remove the duplicate replaced strategy\n        vaultDetail.strategies.pop();\n        // remove the strategy's index\n        delete vaultDetail.index[_strategy];\n        // remove the strategy's cap\n        delete vaultDetail.caps[_strategy];\n        // remove the strategy's balance\n        delete vaultDetail.balances[_strategy];\n        // remove the mapping of strategy to the vault\n        delete _vaultStrategies[_strategy];\n        // pull funds from the removed strategy to the vault\n        IStrategy(_strategy).withdrawAll();\n        // remove the strategy from the harvester\n        IHarvester(manager.harvester()).removeStrategy(_vault, _strategy, _timeout);\n        emit StrategyRemoved(_vault, _strategy);\n    }\n\n    /**\n     * @notice Reorders two strategies for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy1 The address of the first strategy\n     * @param _strategy2 The address of the second strategy\n     */\n    function reorderStrategies(\n        address _vault,\n        address _strategy1,\n        address _strategy2\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedVaults(_vault), \"!_vault\");\n        require(_vaultStrategies[_strategy1] == _vault, \"!_strategy1\");\n        require(_vaultStrategies[_strategy2] == _vault, \"!_strategy2\");\n        VaultDetail storage vaultDetail = _vaultDetails[_vault];\n        // get the indexes of the strategies\n        uint256 index1 = vaultDetail.index[_strategy1];\n        uint256 index2 = vaultDetail.index[_strategy2];\n        // set the new addresses at their indexes\n        vaultDetail.strategies[index1] = _strategy2;\n        vaultDetail.strategies[index2] = _strategy1;\n        // update indexes\n        vaultDetail.index[_strategy1] = index2;\n        vaultDetail.index[_strategy2] = index1;\n        emit StrategiesReordered(_vault, _strategy1, _strategy2);\n    }\n\n    /**\n     * @notice Sets/updates the cap of a strategy for a vault\n     * @dev If the balance of the strategy is greater than the new cap (except if\n     * the cap is 0), then withdraw the difference from the strategy to the vault.\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _cap The new cap of the strategy\n     */\n    function setCap(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        address _convert\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        uint256 _balance = IStrategy(_strategy).balanceOf();\n        // send excess funds (over cap) back to the vault\n        if (_balance > _cap && _cap != 0) {\n            uint256 _diff = _balance.sub(_cap);\n            IStrategy(_strategy).withdraw(_diff);\n            updateBalance(_vault, _strategy);\n            _balance = IStrategy(_strategy).balanceOf();\n            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);\n            address _want = IStrategy(_strategy).want();\n            _balance = IERC20(_want).balanceOf(address(this));\n            if (_convert != address(0)) {\n                IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n                IERC20(_want).safeTransfer(address(_converter), _balance);\n                _balance = _converter.convert(_want, _convert, _balance, 1);\n                IERC20(_convert).safeTransfer(_vault, _balance);\n            } else {\n                IERC20(_want).safeTransfer(_vault, _balance);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets/updates the converter for a given vault\n     * @param _vault The address of the vault\n     * @param _converter The address of the converter\n     */\n    function setConverter(\n        address _vault,\n        address _converter\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(manager.allowedConverters(_converter), \"!allowedConverters\");\n        _vaultDetails[_vault].converter = _converter;\n    }\n\n    /**\n     * @notice Sets/updates the global invest enabled flag\n     * @param _investEnabled The new bool of the invest enabled flag\n     */\n    function setInvestEnabled(\n        bool _investEnabled\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        globalInvestEnabled = _investEnabled;\n    }\n\n    /**\n     * @notice Sets/updates the maximum number of strategies for a vault\n     * @param _maxStrategies The new value of the maximum strategies\n     */\n    function setMaxStrategies(\n        uint256 _maxStrategies\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        maxStrategies = _maxStrategies;\n    }\n\n    function skim(\n        address _strategy\n    )\n        external\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        address _want = IStrategy(_strategy).want();\n        IStrategy(_strategy).skim();\n        IERC20(_want).safeTransfer(_vaultStrategies[_strategy], IERC20(_want).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice Withdraws all funds from a strategy\n     * @param _strategy The address of the strategy\n     * @param _convert The token address to convert to\n     */\n    function withdrawAll(\n        address _strategy,\n        address _convert\n    )\n        external\n        override\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        address _want = IStrategy(_strategy).want();\n        IStrategy(_strategy).withdrawAll();\n        uint256 _amount = IERC20(_want).balanceOf(address(this));\n        address _vault = _vaultStrategies[_strategy];\n        updateBalance(_vault, _strategy);\n        if (_convert != address(0)) {\n            IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n            IERC20(_want).safeTransfer(address(_converter), _amount);\n            _amount = _converter.convert(_want, _convert, _amount, 1);\n            IERC20(_convert).safeTransfer(_vault, _amount);\n        } else {\n            IERC20(_want).safeTransfer(_vault, _amount);\n        }\n        uint256 _balance = _vaultDetails[_vault].balance;\n        if (_balance >= _amount) {\n            _vaultDetails[_vault].balance = _balance.sub(_amount);\n        } else {\n            _vaultDetails[_vault].balance = 0;\n        }\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Harvests the specified strategy\n     * @param _strategy The address of the strategy\n     */\n    function harvestStrategy(\n        address _strategy,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        external\n        override\n        notHalted\n        onlyHarvester\n        onlyStrategy(_strategy)\n    {\n        uint256 _before = IStrategy(_strategy).balanceOf();\n        IStrategy(_strategy).harvest(_estimatedWETH, _estimatedYAXIS);\n        uint256 _after = IStrategy(_strategy).balanceOf();\n        address _vault = _vaultStrategies[_strategy];\n        _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.add(_after.sub(_before));\n        _vaultDetails[_vault].balances[_strategy] = _after;\n        emit Harvest(_strategy);\n    }\n\n    /**\n     * VAULT-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Invests funds into a strategy\n     * @param _strategy The address of the strategy\n     * @param _token The address of the token\n     * @param _amount The amount that will be invested\n     */\n    function earn(\n        address _strategy,\n        address _token,\n        uint256 _amount\n    )\n        external\n        override\n        notHalted\n        onlyStrategy(_strategy)\n        onlyVault(_token)\n    {\n        // get the want token of the strategy\n        address _want = IStrategy(_strategy).want();\n        if (_want != _token) {\n            IConverter _converter = IConverter(_vaultDetails[msg.sender].converter);\n            IERC20(_token).safeTransfer(address(_converter), _amount);\n            // TODO: do estimation for received\n            _amount = _converter.convert(_token, _want, _amount, 1);\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.add(_amount);\n        // call the strategy deposit function\n        IStrategy(_strategy).deposit();\n        updateBalance(msg.sender, _strategy);\n    }\n\n    /**\n     * @notice Withdraws funds from a strategy\n     * @dev If the withdraw amount is greater than the first strategy given\n     * by getBestStrategyWithdraw, this function will loop over strategies\n     * until the requested amount is met.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function withdraw(\n        address _token,\n        uint256 _amount\n    )\n        external\n        override\n        onlyVault(_token)\n    {\n        (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        ) = getBestStrategyWithdraw(_token, _amount);\n        for (uint i = 0; i < _strategies.length; i++) {\n            // getBestStrategyWithdraw will return arrays larger than needed\n            // if this happens, simply exit the loop\n            if (_strategies[i] == address(0)) {\n                break;\n            }\n            IStrategy(_strategies[i]).withdraw(_amounts[i]);\n            updateBalance(msg.sender, _strategies[i]);\n            address _want = IStrategy(_strategies[i]).want();\n            if (_want != _token) {\n                address _converter = _vaultDetails[msg.sender].converter;\n                IERC20(_want).safeTransfer(_converter, _amounts[i]);\n                // TODO: do estimation for received\n                IConverter(_converter).convert(_want, _token, _amounts[i], 1);\n            }\n        }\n        _amount = IERC20(_token).balanceOf(address(this));\n        _vaultDetails[msg.sender].balance = _vaultDetails[msg.sender].balance.sub(_amount);\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the rough balance of the sum of all strategies for a given vault\n     * @dev This function is optimized to prevent looping over all strategy balances,\n     * and instead the controller tracks the earn, withdraw, and harvest amounts.\n     */\n    function balanceOf()\n        external\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return _vaultDetails[msg.sender].balance;\n    }\n\n    /**\n     * @notice Returns the converter assigned for the given vault\n     * @param _vault Address of the vault\n     */\n    function converter(\n        address _vault\n    )\n        external\n        view\n        override\n        returns (address)\n    {\n        return _vaultDetails[_vault].converter;\n    }\n\n    /**\n     * @notice Returns the cap of a strategy for a given vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     */\n    function getCap(\n        address _vault,\n        address _strategy\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return _vaultDetails[_vault].caps[_strategy];\n    }\n\n    /**\n     * @notice Returns whether investing is enabled for the calling vault\n     * @dev Should be called by the vault\n     */\n    function investEnabled()\n        external\n        view\n        override\n        returns (bool)\n    {\n        if (globalInvestEnabled) {\n            return _vaultDetails[msg.sender].strategies.length > 0;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Returns all the strategies for a given vault\n     * @param _vault The address of the vault\n     */\n    function strategies(\n        address _vault\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return _vaultDetails[_vault].strategies;\n    }\n\n    /**\n     * @notice Returns the length of the strategies of the calling vault\n     * @dev This function is expected to be called by a vault\n     */\n    function strategies()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _vaultDetails[msg.sender].strategies.length;\n    }\n\n    /**\n     * INTERNAL FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the best (optimistic) strategy for funds to be withdrawn from\n     * @dev Since Solidity doesn't support dynamic arrays in memory, the returned arrays\n     * from this function will always be the same length as the amount of strategies for\n     * a token. Check that _strategies[i] != address(0) when consuming to know when to\n     * break out of the loop.\n     * @param _token The address of the token\n     * @param _amount The amount that will be withdrawn\n     */\n    function getBestStrategyWithdraw(\n        address _token,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (\n            address[] memory _strategies,\n            uint256[] memory _amounts\n        )\n    {\n        // get the length of strategies for a single token\n        address _vault = manager.vaults(_token);\n        uint256 k = _vaultDetails[_vault].strategies.length;\n        // initialize fixed-length memory arrays\n        _strategies = new address[](k);\n        _amounts = new uint256[](k);\n        address _strategy;\n        uint256 _balance;\n        // scan forward from the the beginning of strategies\n        for (uint i = 0; i < k; i++) {\n            _strategy = _vaultDetails[_vault].strategies[i];\n            _strategies[i] = _strategy;\n            // get the balance of the strategy\n            _balance = _vaultDetails[_vault].balances[_strategy];\n            // if the strategy doesn't have the balance to cover the withdraw\n            if (_balance < _amount) {\n                // withdraw what we can and add to the _amounts\n                _amounts[i] = _balance;\n                _amount = _amount.sub(_balance);\n            } else {\n                // stop scanning if the balance is more than the withdraw amount\n                _amounts[i] = _amount;\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the stored balance of a given strategy for a vault\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     */\n    function updateBalance(\n        address _vault,\n        address _strategy\n    )\n        internal\n    {\n        _vaultDetails[_vault].balances[_strategy] = IStrategy(_strategy).balanceOf();\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    /**\n     * @notice Reverts if the protocol is halted\n     */\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not governance\n     */\n    modifier onlyGovernance() {\n        require(msg.sender == manager.governance(), \"!governance\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the strategist\n     */\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the strategy is not allowed in the manager\n     */\n    modifier onlyStrategy(address _strategy) {\n        require(manager.allowedStrategies(_strategy), \"!allowedStrategy\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the harvester\n     */\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if the caller is not the vault for the given token\n     */\n    modifier onlyVault(address _token) {\n        require(msg.sender == manager.vaults(_token), \"!vault\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "setCap function in Controller.sol",
                "Type": "High Severity",
                "Description": "set cap breaks vault's Balance",
                "Repair": "Subtract the difference of the balance"
            },
            {
                "Location": "Controller.setCap function",
                "Type": "Controller.setCap sets wrong vault balance",
                "Description": "The Controller.setCap function sets a cap for a strategy and withdraws any excess amounts (_diff). The vault balance is decreased by the entire strategy balance instead of by this _diff.",
                "Repair": "Sub the _diff instead of the balance"
            },
            {
                "Location": "Controller.inCaseStrategyGetStuck function",
                "Type": "Controller.inCaseStrategyGetStuck does not update balance",
                "Description": "The Controller.inCaseStrategyGetStuck withdraws from a strategy but does not call updateBalance(_vault, _strategy) afterwards.",
                "Repair": "Call updateBalance(_vault, _strategy) in inCaseStrategyGetStuck"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/Gauge.sol\";\nimport \"../../interfaces/Balancer.sol\";\n\nimport \"../interfaces/ExtendedIERC20.sol\";\n\nimport \"./BaseStrategy.sol\";\n\ncontract NativeStrategyCurve3Crv is BaseStrategy {\n    // used for Crv -> weth -> [dai/usdc/usdt] -> 3crv route\n    address public immutable crv;\n\n    // for add_liquidity via curve.fi to get back 3CRV (use getMostPremium() for the best stable coin used in the route)\n    address public immutable dai;\n    address public immutable usdc;\n    address public immutable usdt;\n\n    Mintr public immutable crvMintr;\n    IStableSwap3Pool public immutable stableSwap3Pool;\n    Gauge public immutable gauge; // 3Crv Gauge\n\n    constructor(\n        string memory _name,\n        address _want,\n        address _crv,\n        address _weth,\n        address _dai,\n        address _usdc,\n        address _usdt,\n        Gauge _gauge,\n        Mintr _crvMintr,\n        IStableSwap3Pool _stableSwap3Pool,\n        address _controller,\n        address _manager,\n        address _router\n    )\n        public\n        BaseStrategy(_name, _controller, _manager, _want, _weth, _router)\n    {\n        crv = _crv;\n        dai = _dai;\n        usdc = _usdc;\n        usdt = _usdt;\n        stableSwap3Pool = _stableSwap3Pool;\n        gauge = _gauge;\n        crvMintr = _crvMintr;\n        IERC20(_want).safeApprove(address(_gauge), type(uint256).max);\n        IERC20(_crv).safeApprove(address(_router), type(uint256).max);\n        IERC20(_dai).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdc).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_usdt).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n        IERC20(_want).safeApprove(address(_stableSwap3Pool), type(uint256).max);\n    }\n\n    function _deposit()\n        internal\n        override\n    {\n        uint256 _wantBal = balanceOfWant();\n        if (_wantBal > 0) {\n            // deposit [want] to Gauge\n            gauge.deposit(_wantBal);\n        }\n    }\n\n    function _claimReward()\n        internal\n    {\n        crvMintr.mint(address(gauge));\n    }\n\n    function _addLiquidity()\n        internal\n    {\n        uint256[3] memory amounts;\n        amounts[0] = IERC20(dai).balanceOf(address(this));\n        amounts[1] = IERC20(usdc).balanceOf(address(this));\n        amounts[2] = IERC20(usdt).balanceOf(address(this));\n        stableSwap3Pool.add_liquidity(amounts, 1);\n    }\n\n    function getMostPremium()\n        public\n        view\n        returns (address, uint256)\n    {\n        uint daiBalance = stableSwap3Pool.balances(0);\n        // USDC - Supports a change up to the 18 decimal standard\n        uint usdcBalance = stableSwap3Pool.balances(1).mul(10**18).div(10**(ExtendedIERC20(usdc).decimals()));\n        uint usdtBalance = stableSwap3Pool.balances(2).mul(10**12);\n\n        if (daiBalance <= usdcBalance && daiBalance <= usdtBalance) {\n            return (dai, 0);\n        }\n\n        if (usdcBalance <= daiBalance && usdcBalance <= usdtBalance) {\n            return (usdc, 1);\n        }\n\n        if (usdtBalance <= daiBalance && usdtBalance <= usdcBalance) {\n            return (usdt, 2);\n        }\n\n        return (dai, 0); // If they're somehow equal, we just want DAI\n    }\n\n    function _harvest(\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        internal\n        override\n    {\n        _claimReward();\n        uint256 _remainingWeth = _payHarvestFees(crv, _estimatedWETH, _estimatedYAXIS);\n\n        if (_remainingWeth > 0) {\n            (address _stableCoin,) = getMostPremium(); // stablecoin we want to convert to\n            _swapTokens(weth, _stableCoin, _remainingWeth, 1);\n            _addLiquidity();\n\n            _deposit();\n        }\n    }\n\n    function _withdrawAll()\n        internal\n        override\n    {\n        uint256 _bal = gauge.balanceOf(address(this));\n        _withdraw(_bal);\n    }\n\n    function _withdraw(\n        uint256 _amount\n    )\n        internal\n        override\n    {\n        gauge.withdraw(_amount);\n    }\n\n    function balanceOfPool()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return gauge.balanceOf(address(this));\n    }\n}\n\n\n",
        "CodeNames": [
            "NativeStrategyCurve3Crv.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "addLiquidity function in NativeStrategyCurve3Crv.sol",
                "Type": "Medium Severity",
                "Description": "Adding asymmetric liquidity in _addLiquidity results in fewer LP tokens minted than what should be wanted",
                "Repair": "Add liquidity in equal proportion to the curve pool balances, not the contract balances"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "multiple locations",
                "Type": "smart contract vulnerability",
                "Description": "various vulnerabilities including stealing funds from multi-token vaults, missing access control checks, decreasing share price, manipulable voting power, and harvest frontrunning",
                "Repair": "implement additional access control checks, consider price differences between tokens, add estimated quantities for swapped-out stablecoin and minted 3CRV, track time-weighted-average reserve amount, use slippage checks when swapping and minting tokens"
            },
            {
                "Location": "ERC20.transfer() and ERC20.transferFrom() functions",
                "Type": "ERC20 return values not checked",
                "Description": "The ERC20.transfer() and ERC20.transferFrom() functions return a boolean value indicating success. This parameter needs to be checked for success.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\nimport \"./VaultToken.sol\";\n\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IConverter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/ExtendedIERC20.sol\";\n\n/**\n * @title Vault\n * @notice The vault is where users deposit and withdraw\n * like-kind assets that have been added by governance.\n */\ncontract Vault is VaultToken, IVault {\n    using Address for address;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX = 10000;\n\n    IManager public immutable override manager;\n\n    // Strategist-updated variables\n    address public override gauge;\n    uint256 public min;\n    uint256 public totalDepositCap;\n\n    event Deposit(address indexed account, uint256 amount);\n    event Withdraw(address indexed account, uint256 amount);\n    event Earn(address indexed token, uint256 amount);\n\n    /**\n     * @param _name The name of the vault token for depositors\n     * @param _symbol The symbol of the vault token for depositors\n     * @param _manager The address of the vault manager contract\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _manager\n    )\n        public\n        VaultToken(_name, _symbol)\n    {\n        manager = IManager(_manager);\n        min = 9500;\n        totalDepositCap = 10000000 ether;\n    }\n\n    /**\n     * STRATEGIST-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sets the value of this vault's gauge\n     * @dev Allow to be unset with the zero address\n     * @param _gauge The address of the gauge\n     */\n    function setGauge(\n        address _gauge\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        gauge = _gauge;\n    }\n\n    /**\n     * @notice Sets the value for min\n     * @dev min is the minimum percent of funds to keep small withdrawals cheap\n     * @param _min The new min value\n     */\n    function setMin(\n        uint256 _min\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        require(_min <= MAX, \"!_min\");\n        min = _min;\n    }\n\n    /**\n     * @notice Sets the value for the totalDepositCap\n     * @dev totalDepositCap is the maximum amount of value that can be deposited\n     * to the metavault at a time\n     * @param _totalDepositCap The new totalDepositCap value\n     */\n    function setTotalDepositCap(\n        uint256 _totalDepositCap\n    )\n        external\n        notHalted\n        onlyStrategist\n    {\n        totalDepositCap = _totalDepositCap;\n    }\n\n    /**\n     * @notice Swaps tokens held within the vault\n     * @param _token0 The token address to swap out\n     * @param _token1 The token address to to\n     * @param _expectedAmount The expected amount of _token1 to receive\n     */\n    function swap(\n        address _token0,\n        address _token1,\n        uint256 _expectedAmount\n    )\n        external\n        override\n        notHalted\n        onlyStrategist\n        returns (uint256 _balance)\n    {\n        IConverter _converter = IConverter(IController(manager.controllers(address(this))).converter(address(this)));\n        _balance = IERC20(_token0).balanceOf(address(this));\n        IERC20(_token0).safeTransfer(address(_converter), _balance);\n        _balance = _converter.convert(_token0, _token1, _balance, _expectedAmount);\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Sends accrued 3CRV tokens on the metavault to the controller to be deposited to strategies\n     */\n    function earn(\n        address _token,\n        address _strategy\n    )\n        external\n        override\n        checkToken(_token)\n        notHalted\n        onlyHarvester\n    {\n        require(manager.allowedStrategies(_strategy), \"!_strategy\");\n        IController _controller = IController(manager.controllers(address(this)));\n        if (_controller.investEnabled()) {\n            uint256 _balance = available(_token);\n            IERC20(_token).safeTransfer(address(_controller), _balance);\n            _controller.earn(_strategy, _token, _balance);\n            emit Earn(_token, _balance);\n        }\n    }\n\n    /**\n     * USER-FACING FUNCTIONS\n     */\n\n    /**\n     * @notice Deposits the given token into the vault\n     * @param _token The address of the token\n     * @param _amount The amount of tokens to deposit\n     */\n     function deposit(\n        address _token,\n        uint256 _amount\n     )\n        public\n        override\n        checkToken(_token)\n        notHalted\n        returns (uint256 _shares)\n    {\n        require(_amount > 0, \"!_amount\");\n\n        uint256 _balance = balance();\n\n        uint256 _before = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n        _amount = IERC20(_token).balanceOf(address(this)).sub(_before);\n\n        if (_amount > 0) {\n            _amount = _normalizeDecimals(_token, _amount);\n\n            if (totalSupply() > 0) {\n                _amount = (_amount.mul(totalSupply())).div(_balance);\n            }\n\n            _shares = _amount;\n        }\n\n        if (_shares > 0) {\n            _mint(msg.sender, _shares);\n            require(totalSupply() <= totalDepositCap, \">totalDepositCap\");\n            emit Deposit(msg.sender, _shares);\n        }\n    }\n\n    /**\n     * @notice Deposits multiple tokens simultaneously to the vault\n     * @dev Users must approve the vault to spend their stablecoin\n     * @param _tokens The addresses of each token being deposited\n     * @param _amounts The amounts of each token being deposited\n     */\n    function depositMultiple(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts\n    )\n        external\n        override\n        returns (uint256 _shares)\n    {\n        require(_tokens.length == _amounts.length, \"!length\");\n\n        for (uint8 i; i < _amounts.length; i++) {\n            _shares = _shares.add(deposit(_tokens[i], _amounts[i]));\n        }\n    }\n\n    /**\n     * @notice Withdraws an amount of shares to a given output token\n     * @param _shares The amount of shares to withdraw\n     * @param _output The address of the token to receive\n     */\n    function withdraw(\n        uint256 _shares,\n        address _output\n    )\n        public\n        override\n        checkToken(_output)\n    {\n        uint256 _amount = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint256 _withdrawalProtectionFee = manager.withdrawalProtectionFee();\n        if (_withdrawalProtectionFee > 0) {\n            uint256 _withdrawalProtection = _amount.mul(_withdrawalProtectionFee).div(MAX);\n            _amount = _amount.sub(_withdrawalProtection);\n        }\n\n        uint256 _balance = IERC20(_output).balanceOf(address(this));\n        if (_balance < _amount) {\n            IController _controller = IController(manager.controllers(address(this)));\n            uint256 _toWithdraw = _amount.sub(_balance);\n            if (_controller.strategies() > 0) {\n                _controller.withdraw(_output, _toWithdraw);\n            }\n            uint256 _after = IERC20(_output).balanceOf(address(this));\n            uint256 _diff = _after.sub(_balance);\n            if (_diff < _toWithdraw) {\n                _amount = _after;\n            }\n        }\n\n        IERC20(_output).safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Withdraw the entire balance for an account\n     * @param _output The address of the desired token to receive\n     */\n    function withdrawAll(\n        address _output\n    )\n        external\n        override\n    {\n        withdraw(balanceOf(msg.sender), _output);\n    }\n\n    /**\n     * VIEWS\n     */\n\n    /**\n     * @notice Returns the amount of tokens available to be sent to strategies\n     * @dev Custom logic in here for how much the vault allows to be borrowed\n     * @dev Sets minimum required on-hand to keep small withdrawals cheap\n     * @param _token The address of the token\n     */\n    function available(\n        address _token\n    )\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return IERC20(_token).balanceOf(address(this)).mul(min).div(MAX);\n    }\n\n    /**\n     * @notice Returns the total balance of the vault, including strategies\n     */\n    function balance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        return balanceOfThis().add(IController(manager.controllers(address(this))).balanceOf());\n    }\n\n    /**\n     * @notice Returns the balance of allowed tokens present on the vault only\n     */\n    function balanceOfThis()\n        public\n        view\n        returns (uint256 _balance)\n    {\n        address[] memory _tokens = manager.getTokens(address(this));\n        for (uint8 i; i < _tokens.length; i++) {\n            address _token = _tokens[i];\n            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n        }\n    }\n\n    /**\n     * @notice Returns the rate of vault shares\n     */\n    function getPricePerFullShare()\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalSupply() > 0) {\n            return balance().mul(1e18).div(totalSupply());\n        } else {\n            return balance();\n        }\n    }\n\n    /**\n     * @notice Returns an array of the tokens for this vault\n     */\n    function getTokens()\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return manager.getTokens(address(this));\n    }\n\n    /**\n     * @notice Returns the fee for withdrawing the given amount\n     * @param _amount The amount to withdraw\n     */\n    function withdrawFee(\n        uint256 _amount\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return manager.withdrawalProtectionFee().mul(_amount).div(MAX);\n    }\n\n    function _normalizeDecimals(\n        address _token,\n        uint256 _amount\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = uint256(ExtendedIERC20(_token).decimals());\n        if (_decimals < 18) {\n            _amount = _amount.mul(10**(18-_decimals));\n        }\n        return _amount;\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier checkToken(address _token) {\n        require(manager.allowedTokens(_token) && manager.vaults(_token) == address(this), \"!_token\");\n        _;\n    }\n\n    modifier notHalted() {\n        require(!manager.halted(), \"halted\");\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(msg.sender == manager.harvester(), \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Vault.withdraw function",
                "Type": "Vault.withdraw sometimes burns too many shares",
                "Description": "The Vault.withdraw function attempts to withdraw funds from the controller if there are not enough in the vault already. In the case the controller could not withdraw enough, i.e., where _diff < _toWithdraw, the user will receive less output tokens than their fair share would entitle them to.",
                "Repair": "Recompute shares to burn based on the lower payout"
            },
            {
                "Location": "Vault contract",
                "Type": "Vault: Swaps at parity with swap fee = withdrawal fee",
                "Description": "The vault treats all assets to be of the same price. Given that one can also deposit and withdraw in the same transaction, this offers users the ability to swap available funds held in the vault at parity, with the withdrawal protection fee (0.1%) effectively being the swap fee.",
                "Repair": "Prevent users from depositing and withdrawing in the same transaction, setWithdrawalProtectionFee() could have a requirement for the value to be non-zero, use price oracles to accurately calculate the shares to be transferred to users for deposits, or token amounts to be sent for withdrawals"
            },
            {
                "Location": "Vault.withdraw function",
                "Type": "Vault.withdraw mixes normalized and standard amounts",
                "Description": "The Vault.balance function uses the balanceOfThis function which scales (\"normalizes\") all balances to 18 decimals. Note that balance()'s second term IController(manager.controllers(address(this))).balanceOf() is not normalized.",
                "Repair": "Denormalize derived token amount before using them"
            },
            {
                "Location": "Vault.balance function",
                "Type": "Vault.balance() mixes normalized and standard amounts",
                "Description": "The Vault.balance function uses the balanceOfThis function which scales (\"normalizes\") all balances to 18 decimals. Note that balance()'s second term IController(manager.controllers(address(this))).balanceOf() is not normalized.",
                "Repair": "Use a consistent usage of _normalizeDecimals"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IHarvester.sol\";\nimport \"./interfaces/ILegacyController.sol\";\nimport \"./interfaces/IManager.sol\";\nimport \"./interfaces/IStrategy.sol\";\nimport \"./interfaces/ISwap.sol\";\n\n/**\n * @title Harvester\n * @notice This contract is to be used as a central point to call\n * harvest on all strategies for any given vault. It has its own\n * permissions for harvesters (set by the strategist or governance).\n */\ncontract Harvester is IHarvester {\n    using SafeMath for uint256;\n\n    uint256 public constant ONE_HUNDRED_PERCENT = 10000;\n\n    IManager public immutable override manager;\n    IController public immutable controller;\n    ILegacyController public immutable legacyController;\n\n    uint256 public slippage;\n\n    struct Strategy {\n        uint256 timeout;\n        uint256 lastCalled;\n        address[] addresses;\n    }\n\n    mapping(address => Strategy) public strategies;\n    mapping(address => bool) public isHarvester;\n\n    /**\n     * @notice Logged when harvest is called for a strategy\n     */\n    event Harvest(\n        address indexed controller,\n        address indexed strategy\n    );\n\n    /**\n     * @notice Logged when a harvester is set\n     */\n    event HarvesterSet(address indexed harvester, bool status);\n\n    /**\n     * @notice Logged when a strategy is added for a vault\n     */\n    event StrategyAdded(address indexed vault, address indexed strategy, uint256 timeout);\n\n    /**\n     * @notice Logged when a strategy is removed for a vault\n     */\n    event StrategyRemoved(address indexed vault, address indexed strategy, uint256 timeout);\n\n    /**\n     * @param _manager The address of the yAxisMetaVaultManager contract\n     * @param _controller The address of the controller\n     */\n    constructor(\n        address _manager,\n        address _controller,\n        address _legacyController\n    )\n        public\n    {\n        manager = IManager(_manager);\n        controller = IController(_controller);\n        legacyController = ILegacyController(_legacyController);\n    }\n\n    /**\n     * (GOVERNANCE|STRATEGIST)-ONLY FUNCTIONS\n     */\n\n    /**\n     * @notice Adds a strategy to the rotation for a given vault and sets a timeout\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function addStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        override\n        onlyController\n    {\n        strategies[_vault].addresses.push(_strategy);\n        strategies[_vault].timeout = _timeout;\n        emit StrategyAdded(_vault, _strategy, _timeout);\n    }\n\n    /**\n     * @notice Removes a strategy from the rotation for a given vault and sets a timeout\n     * @param _vault The address of the vault\n     * @param _strategy The address of the strategy\n     * @param _timeout The timeout between harvests\n     */\n    function removeStrategy(\n        address _vault,\n        address _strategy,\n        uint256 _timeout\n    )\n        external\n        override\n        onlyController\n    {\n        uint256 tail = strategies[_vault].addresses.length;\n        uint256 index;\n        bool found;\n        for (uint i; i < tail; i++) {\n            if (strategies[_vault].addresses[i] == _strategy) {\n                index = i;\n                found = true;\n                break;\n            }\n        }\n\n        if (found) {\n            strategies[_vault].addresses[index] = strategies[_vault].addresses[tail.sub(1)];\n            strategies[_vault].addresses.pop();\n            strategies[_vault].timeout = _timeout;\n            emit StrategyRemoved(_vault, _strategy, _timeout);\n        }\n    }\n\n    /**\n     * @notice Sets the status of a harvester address to be able to call harvest functions\n     * @param _harvester The address of the harvester\n     * @param _status The status to allow the harvester to harvest\n     */\n    function setHarvester(\n        address _harvester,\n        bool _status\n    )\n        external\n        onlyStrategist\n    {\n        isHarvester[_harvester] = _status;\n        emit HarvesterSet(_harvester, _status);\n    }\n\n    function setSlippage(\n        uint256 _slippage\n    )\n        external\n        onlyStrategist\n    {\n        require(_slippage < ONE_HUNDRED_PERCENT, \"!_slippage\");\n        slippage = _slippage;\n    }\n\n    /**\n     * HARVESTER-ONLY FUNCTIONS\n     */\n\n    function earn(\n        address _strategy,\n        IVault _vault,\n        address _token\n    )\n        external\n        onlyHarvester\n    {\n        _vault.earn(_token, _strategy);\n    }\n\n    /**\n     * @notice Harvests a given strategy on the provided controller\n     * @dev This function ignores the timeout\n     * @param _controller The address of the controller\n     * @param _strategy The address of the strategy\n     */\n    function harvest(\n        IController _controller,\n        address _strategy,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        public\n        onlyHarvester\n    {\n        _controller.harvestStrategy(_strategy, _estimatedWETH, _estimatedYAXIS);\n        emit Harvest(address(_controller), _strategy);\n    }\n\n    /**\n     * @notice Harvests the next available strategy for a given vault and\n     * rotates the strategies\n     * @param _vault The address of the vault\n     */\n    function harvestNextStrategy(\n        address _vault,\n        uint256 _estimatedWETH,\n        uint256 _estimatedYAXIS\n    )\n        external\n    {\n        require(canHarvest(_vault), \"!canHarvest\");\n        address strategy = strategies[_vault].addresses[0];\n        harvest(controller, strategy, _estimatedWETH, _estimatedYAXIS);\n        uint256 k = strategies[_vault].addresses.length;\n        if (k > 1) {\n            address[] memory _strategies = new address[](k);\n            for (uint i; i < k-1; i++) {\n                _strategies[i] = strategies[_vault].addresses[i+1];\n            }\n            _strategies[k-1] = strategy;\n            strategies[_vault].addresses = _strategies;\n        }\n        // solhint-disable-next-line not-rely-on-time\n        strategies[_vault].lastCalled = block.timestamp;\n    }\n\n    /**\n     * @notice Earns tokens in the LegacyController to the v3 vault\n     * @param _token The address of the token\n     * @param _expected The expected amount to deposit after conversion\n     */\n    function legacyEarn(\n        address _token,\n        uint256 _expected\n    )\n        external\n        onlyHarvester\n    {\n        legacyController.legacyDeposit(_token, _expected);\n    }\n\n    /**\n     * EXTERNAL VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the addresses of the strategies for a given vault\n     * @param _vault The address of the vault\n     */\n    function strategyAddresses(\n        address _vault\n    )\n        external\n        view\n        returns (address[] memory)\n    {\n        return strategies[_vault].addresses;\n    }\n\n    /**\n     * PUBLIC VIEW FUNCTIONS\n     */\n\n    /**\n     * @notice Returns the availability of a vault's strategy to be harvested\n     * @param _vault The address of the vault\n     */\n    function canHarvest(\n        address _vault\n    )\n        public\n        view\n        returns (bool)\n    {\n        Strategy storage strategy = strategies[_vault];\n        // only can harvest if there are strategies, and when sufficient time has elapsed\n        return (strategy.addresses.length > 0 && strategy.lastCalled <= block.timestamp.sub(strategy.timeout));\n    }\n\n    /**\n     * @notice Returns the estimated amount of WETH and YAXIS for the given strategy\n     * @param _strategy The address of the strategy\n     */\n    function getEstimates(\n        address _strategy\n    )\n        public\n        view\n        returns (uint256 _estimatedWETH, uint256 _estimatedYAXIS)\n    {\n        ISwap _router = IStrategy(_strategy).router();\n        address[] memory _path;\n        _path[0] = IStrategy(_strategy).want();\n        _path[1] = IStrategy(_strategy).weth();\n        uint256[] memory _amounts = _router.getAmountsOut(\n            IStrategy(_strategy).balanceOfPool(),\n            _path\n        );\n        _estimatedWETH = _amounts[1];\n        uint256 _slippage = slippage;\n        if (_slippage > 0) {\n            _estimatedWETH = _estimatedWETH.mul(_slippage).div(ONE_HUNDRED_PERCENT);\n        }\n        _path[0] = manager.yaxis();\n        uint256 _fee = _estimatedWETH.mul(manager.treasuryFee()).div(ONE_HUNDRED_PERCENT);\n        _amounts = _router.getAmountsOut(_fee, _path);\n        _estimatedYAXIS = _amounts[1];\n        if (_slippage > 0) {\n            _estimatedYAXIS = _estimatedYAXIS.mul(_slippage).div(ONE_HUNDRED_PERCENT);\n        }\n    }\n\n    /**\n     * MODIFIERS\n     */\n\n    modifier onlyController() {\n        require(manager.allowedControllers(msg.sender), \"!controller\");\n        _;\n    }\n\n    modifier onlyHarvester() {\n        require(isHarvester[msg.sender], \"!harvester\");\n        _;\n    }\n\n    modifier onlyStrategist() {\n        require(msg.sender == manager.strategist(), \"!strategist\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "Harvester.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Harvester.getEstimates",
                "Type": "wrong estimates",
                "Description": "The Harvester.getEstimates contract tries to estimate a YAXIS amount but uses the wrong path and/or amount.",
                "Repair": "Change the path to WETH-YAXIS in Harvester.getEstimates"
            }
        ]
    }
]