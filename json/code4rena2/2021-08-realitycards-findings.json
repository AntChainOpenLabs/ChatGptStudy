[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCBridge.sol\";\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {\n    using SafeERC20 for IERC20;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public override orderbook;\n    /// @dev leaderboard instance\n    IRCLeaderboard public override leaderboard;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev the Factory so only the Factory can add new markets\n    IRCFactory public override factory;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public override marketBalance;\n    /// @dev a quick check if a user is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 public override marketBalanceTopup;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    /// @dev intended for beta use only, will be disabled after launch\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n    /// @dev allow markets to be restricted to a certain role\n    mapping(address => bytes32) public marketWhitelist;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent, claim or upgrade any cards for specific market\n    mapping(address => bool) public override marketPaused;\n    /// @dev if true, owner has locked the market pause (Governors are locked out)\n    mapping(address => bool) public override lockMarketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant FACTORY = keccak256(\"FACTORY\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant WHITELIST = keccak256(\"WHITELIST\");\n    bytes32 public constant ARTIST = keccak256(\"ARTIST\");\n    bytes32 public constant AFFILIATE = keccak256(\"AFFILIATE\");\n    bytes32 public constant CARD_AFFILIATE = keccak256(\"CARD_AFFILIATE\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n    event LogWhitelistUser(address user, bool allowed);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        /* setup AccessControl\n\n                         UBER_OWNER\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502           \u2502          \u2502            \u2502         \u2502\n          OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD\n            \u2502           \u2502\n         GOVERNOR     MARKET\n            \u2502\n         WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE\n        */\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(UBER_OWNER, _msgSender());\n        _setupRole(OWNER, _msgSender());\n        _setupRole(GOVERNOR, _msgSender());\n        _setupRole(WHITELIST, _msgSender());\n        _setupRole(TREASURY, address(this));\n        _setRoleAdmin(UBER_OWNER, UBER_OWNER);\n        _setRoleAdmin(OWNER, UBER_OWNER);\n        _setRoleAdmin(FACTORY, UBER_OWNER);\n        _setRoleAdmin(ORDERBOOK, UBER_OWNER);\n        _setRoleAdmin(TREASURY, UBER_OWNER);\n        _setRoleAdmin(GOVERNOR, OWNER);\n        _setRoleAdmin(WHITELIST, GOVERNOR);\n        _setRoleAdmin(ARTIST, GOVERNOR);\n        _setRoleAdmin(AFFILIATE, GOVERNOR);\n        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);\n        _setRoleAdmin(MARKET, FACTORY);\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1_000_000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks() {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyRole(OWNER)\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUCTOR - PUBLIC \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @dev this is only a soft check, it is possible to exceed this limit\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyRole(OWNER)\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyRole(OWNER) {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market\n    function changePauseMarket(address _market, bool _paused)\n        external\n        override\n        onlyRole(OWNER)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        marketPaused[_market] = _paused;\n        lockMarketPaused[_market] = marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it\n    function unPauseMarket(address _market)\n        external\n        override\n        onlyRole(FACTORY)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        require(!lockMarketPaused[_market], \"Owner has paused market\");\n        marketPaused[_market] = false;\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyRole(OWNER) {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add/Remove multiple users to the whitelist\n    /// @param _users an array of users to add or remove\n    /// @param add true to add the users\n    function batchWhitelist(address[] calldata _users, bool add)\n        external\n        override\n        onlyRole(GOVERNOR)\n    {\n        if (add) {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.grantRole(WHITELIST, _users[index]);\n            }\n        } else {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.revokeRole(WHITELIST, _users[index]);\n            }\n        }\n    }\n\n    /// @notice Some markets may be restricted to certain roles,\n    /// @notice This function checks if the user has the role requried for a given market\n    /// @dev Used for the markets to check themselves\n    /// @param _user The user to check\n    function marketWhitelistCheck(address _user)\n        external\n        view\n        override\n        returns (bool)\n    {\n        bytes32 requiredRole = marketWhitelist[msgSender()];\n        if (requiredRole == bytes32(0)) {\n            return true;\n        } else {\n            return hasRole(requiredRole, _user);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governance functions\n\n    function setFactoryAddress(address _newFactory)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newFactory != address(0), \"Must set an address\");\n        // factory is also an OWNER and GOVERNOR to use the proxy functions\n        revokeRole(FACTORY, address(factory));\n        revokeRole(OWNER, address(factory));\n        revokeRole(GOVERNOR, address(factory));\n        factory = IRCFactory(_newFactory);\n        grantRole(FACTORY, address(factory));\n        grantRole(OWNER, address(factory));\n        grantRole(GOVERNOR, address(factory));\n    }\n\n    function setOrderbookAddress(address _newOrderbook)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newOrderbook != address(0), \"Must set an address\");\n        revokeRole(ORDERBOOK, address(orderbook));\n        orderbook = IRCOrderbook(_newOrderbook);\n        grantRole(ORDERBOOK, address(orderbook));\n        factory.setOrderbookAddress(orderbook);\n    }\n\n    function setLeaderboardAddress(address _newLeaderboard)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newLeaderboard != address(0), \"Must set an address\");\n        leaderboard = IRCLeaderboard(_newLeaderboard);\n        factory.setLeaderboardAddress(leaderboard);\n    }\n\n    function setTokenAddress(address _newToken)\n        public\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner\n    function globalExit() external onlyRole(UBER_OWNER) {\n        uint256 _balance = erc20.balanceOf(address(this));\n        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised\n        erc20.safeTransfer(msg.sender, _balance);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        external\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(hasRole(WHITELIST, _user), \"Not in whitelist\");\n        }\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        assessForeclosure(_user);\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // step 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.safeTransfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        // do some cleaning up first, it might help avoid their foreclosure\n        orderbook.removeOldBids(_msgSender);\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            // foreclose user, this is requred to remove them from the orderbook\n            isForeclosed[_msgSender] = true;\n            // remove them from the orderbook\n            orderbook.removeUserFromOrderbook(_msgSender);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount)\n        external\n        override\n        balancedBooks\n    {\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n        marketBalanceTopup += _amount;\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (uint256)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            uint256 discrepancy = _amount - marketBalance;\n            if (discrepancy > marketBalanceTopup) {\n                marketBalanceTopup = 0;\n            } else {\n                marketBalanceTopup -= discrepancy;\n            }\n            _amount = marketBalance;\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n        /// @dev return the amount just incase it was adjusted\n        return _amount;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        assessForeclosure(_user);\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        assessForeclosure(_user);\n    }\n\n    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        address _msgSender = msgSender();\n        require(!lockMarketPaused[_msgSender], \"Market is paused\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.safeTransferFrom(_sponsor, address(this), _amount);\n        marketPot[_msgSender] += _amount;\n        totalMarketPots += _amount;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyRole(MARKET)\n    {\n        // update the last rental time\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        // check if this is their first rental (no previous rental calculation)\n        if (user[_user].lastRentCalc == 0) {\n            // we need to start their clock ticking, update their last rental calculation time\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function addMarket(address _market, bool _paused) external override {\n        require(hasRole(FACTORY, msgSender()), \"Not Authorised\");\n        marketPaused[_market] = _paused;\n        AccessControl.grantRole(MARKET, _market);\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice provides the sum total of a users bids across all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyRole(ORDERBOOK) {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !hasRole(MARKET, _newOwner)\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(\n                    user[_newOwner].lastRentCalc,\n                    _timeOwnershipChanged,\n                    _newPrice\n                );\n\n                // they have enough funds, just collect the extra\n                // we can be sure of this because it was checked they can cover the minimum rental\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                    // send an event for the UI to have a timestamp\n                    emit LogAdjustDeposit(_newOwner, 0, false);\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calculation and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calculates the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestamps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /\n                totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +\n                timeLeftOfDeposit;\n\n            if (\n                foreclosureTimeWithoutNewCard > _timeOfNewBid &&\n                _timeOfNewBid != 0\n            ) {\n                // calculate how long they can own the new card for\n                uint256 _rentDifference = rentOwedBetweenTimestamps(\n                    user[_user].lastRentCalc,\n                    _timeOfNewBid,\n                    totalUserDailyRent\n                );\n                uint256 _depositAtTimeOfNewBid = 0;\n\n                if (user[_user].lastRentCalc < _timeOfNewBid) {\n                    // new bid is after user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit -\n                        _rentDifference;\n                } else {\n                    // new bid is before user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit +\n                        _rentDifference;\n                }\n\n                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *\n                    1 days) / (totalUserDailyRent + _newBid);\n\n                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +\n                    _timeLeftOfDepositWithNewBid;\n                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {\n                    return _foreclosureTimeWithNewCard;\n                } else {\n                    // The user couldn't afford to own the new card up to their last\n                    // .. rent calculation, we can't rewind their rent calculation because\n                    // .. of gas limits (there could be many markets having taken rent).\n                    // Therefore unfortunately we can't give any ownership to this user as\n                    // .. this could mean getting caught in a loop we may not be able to\n                    // .. exit because of gas limits (there could be many users in this\n                    // .. situation and we can't leave any unaccounted for).\n                    // This means we return 0 to signify that the user can't afford this\n                    // .. new ownership.\n                    return 0;\n                }\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            if (_newBid == 0) {\n                // if no rentals they'll foreclose after the heat death of the universe\n                return type(uint256).max;\n            } else {\n                return\n                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);\n            }\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        require(_timeToCollectTo != 0, \"Must set collection time\");\n        require(\n            _timeToCollectTo <= block.timestamp,\n            \"Can't collect future rent\"\n        );\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts = ((_timeToCollectTo -\n                    previousCollectionTime) * uint256(user[_user].deposit)) /\n                    rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepositLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets available balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n\n    /// @notice checks if the user should still be foreclosed\n    function assessForeclosure(address _user) public override {\n        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        } else {\n            isForeclosed[_user] = true;\n            emit LogUserForeclosed(_user, true);\n        }\n    }\n\n    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual\n    function checkPermission(bytes32 role, address account)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return AccessControl.hasRole(role, account);\n    }\n\n    function grantRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.grantRole(_role, account);\n    }\n\n    function grantRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, true);\n        }\n        AccessControl.grantRole(role, account);\n    }\n\n    function revokeRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.revokeRole(_role, account);\n    }\n\n    function revokeRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, false);\n        }\n        AccessControl.revokeRole(role, account);\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCTreasury.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RCTreasury.deposit() function",
                "Type": "Deposits don't work with fee-on transfer tokens",
                "Description": "ERC20 tokens that charge a certain fee for every transfer() or transferFrom() may credit more deposits than the contract actually received.",
                "Repair": "Ensure that the erc20 token does not implement any customizations or measure the asset change right before and after the asset-transferring routines"
            },
            {
                "Location": "marketWhitelistCheck() function in RCTreasury.sol",
                "Type": "Uninitialized Variable",
                "Description": "The variable marketWhitelist is never initialized in the contract RCTreasury.sol, causing the function marketWhitelistCheck() to not perform a proper check on whitelisted users for a restricted market.",
                "Repair": "Ensure this behavior is intended or add a function that enables a market creator to restrict their market to a specific role by whitelisting users"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCBridge.sol\";\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {\n    using SafeERC20 for IERC20;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public override orderbook;\n    /// @dev leaderboard instance\n    IRCLeaderboard public override leaderboard;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev the Factory so only the Factory can add new markets\n    IRCFactory public override factory;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public override marketBalance;\n    /// @dev a quick check if a user is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 public override marketBalanceTopup;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    /// @dev intended for beta use only, will be disabled after launch\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n    /// @dev allow markets to be restricted to a certain role\n    mapping(address => bytes32) public marketWhitelist;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent, claim or upgrade any cards for specific market\n    mapping(address => bool) public override marketPaused;\n    /// @dev if true, owner has locked the market pause (Governors are locked out)\n    mapping(address => bool) public override lockMarketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant FACTORY = keccak256(\"FACTORY\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant WHITELIST = keccak256(\"WHITELIST\");\n    bytes32 public constant ARTIST = keccak256(\"ARTIST\");\n    bytes32 public constant AFFILIATE = keccak256(\"AFFILIATE\");\n    bytes32 public constant CARD_AFFILIATE = keccak256(\"CARD_AFFILIATE\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n    event LogWhitelistUser(address user, bool allowed);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        /* setup AccessControl\n\n                         UBER_OWNER\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502           \u2502          \u2502            \u2502         \u2502\n          OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD\n            \u2502           \u2502\n         GOVERNOR     MARKET\n            \u2502\n         WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE\n        */\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(UBER_OWNER, _msgSender());\n        _setupRole(OWNER, _msgSender());\n        _setupRole(GOVERNOR, _msgSender());\n        _setupRole(WHITELIST, _msgSender());\n        _setupRole(TREASURY, address(this));\n        _setRoleAdmin(UBER_OWNER, UBER_OWNER);\n        _setRoleAdmin(OWNER, UBER_OWNER);\n        _setRoleAdmin(FACTORY, UBER_OWNER);\n        _setRoleAdmin(ORDERBOOK, UBER_OWNER);\n        _setRoleAdmin(TREASURY, UBER_OWNER);\n        _setRoleAdmin(GOVERNOR, OWNER);\n        _setRoleAdmin(WHITELIST, GOVERNOR);\n        _setRoleAdmin(ARTIST, GOVERNOR);\n        _setRoleAdmin(AFFILIATE, GOVERNOR);\n        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);\n        _setRoleAdmin(MARKET, FACTORY);\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1_000_000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks() {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyRole(OWNER)\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUCTOR - PUBLIC \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @dev this is only a soft check, it is possible to exceed this limit\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyRole(OWNER)\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyRole(OWNER) {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market\n    function changePauseMarket(address _market, bool _paused)\n        external\n        override\n        onlyRole(OWNER)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        marketPaused[_market] = _paused;\n        lockMarketPaused[_market] = marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it\n    function unPauseMarket(address _market)\n        external\n        override\n        onlyRole(FACTORY)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        require(!lockMarketPaused[_market], \"Owner has paused market\");\n        marketPaused[_market] = false;\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyRole(OWNER) {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add/Remove multiple users to the whitelist\n    /// @param _users an array of users to add or remove\n    /// @param add true to add the users\n    function batchWhitelist(address[] calldata _users, bool add)\n        external\n        override\n        onlyRole(GOVERNOR)\n    {\n        if (add) {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.grantRole(WHITELIST, _users[index]);\n            }\n        } else {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.revokeRole(WHITELIST, _users[index]);\n            }\n        }\n    }\n\n    /// @notice Some markets may be restricted to certain roles,\n    /// @notice This function checks if the user has the role requried for a given market\n    /// @dev Used for the markets to check themselves\n    /// @param _user The user to check\n    function marketWhitelistCheck(address _user)\n        external\n        view\n        override\n        returns (bool)\n    {\n        bytes32 requiredRole = marketWhitelist[msgSender()];\n        if (requiredRole == bytes32(0)) {\n            return true;\n        } else {\n            return hasRole(requiredRole, _user);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governance functions\n\n    function setFactoryAddress(address _newFactory)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newFactory != address(0), \"Must set an address\");\n        // factory is also an OWNER and GOVERNOR to use the proxy functions\n        revokeRole(FACTORY, address(factory));\n        revokeRole(OWNER, address(factory));\n        revokeRole(GOVERNOR, address(factory));\n        factory = IRCFactory(_newFactory);\n        grantRole(FACTORY, address(factory));\n        grantRole(OWNER, address(factory));\n        grantRole(GOVERNOR, address(factory));\n    }\n\n    function setOrderbookAddress(address _newOrderbook)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newOrderbook != address(0), \"Must set an address\");\n        revokeRole(ORDERBOOK, address(orderbook));\n        orderbook = IRCOrderbook(_newOrderbook);\n        grantRole(ORDERBOOK, address(orderbook));\n        factory.setOrderbookAddress(orderbook);\n    }\n\n    function setLeaderboardAddress(address _newLeaderboard)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newLeaderboard != address(0), \"Must set an address\");\n        leaderboard = IRCLeaderboard(_newLeaderboard);\n        factory.setLeaderboardAddress(leaderboard);\n    }\n\n    function setTokenAddress(address _newToken)\n        public\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner\n    function globalExit() external onlyRole(UBER_OWNER) {\n        uint256 _balance = erc20.balanceOf(address(this));\n        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised\n        erc20.safeTransfer(msg.sender, _balance);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        external\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(hasRole(WHITELIST, _user), \"Not in whitelist\");\n        }\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        assessForeclosure(_user);\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // step 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.safeTransfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        // do some cleaning up first, it might help avoid their foreclosure\n        orderbook.removeOldBids(_msgSender);\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            // foreclose user, this is requred to remove them from the orderbook\n            isForeclosed[_msgSender] = true;\n            // remove them from the orderbook\n            orderbook.removeUserFromOrderbook(_msgSender);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount)\n        external\n        override\n        balancedBooks\n    {\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n        marketBalanceTopup += _amount;\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (uint256)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            uint256 discrepancy = _amount - marketBalance;\n            if (discrepancy > marketBalanceTopup) {\n                marketBalanceTopup = 0;\n            } else {\n                marketBalanceTopup -= discrepancy;\n            }\n            _amount = marketBalance;\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n        /// @dev return the amount just incase it was adjusted\n        return _amount;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        assessForeclosure(_user);\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        assessForeclosure(_user);\n    }\n\n    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        address _msgSender = msgSender();\n        require(!lockMarketPaused[_msgSender], \"Market is paused\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.safeTransferFrom(_sponsor, address(this), _amount);\n        marketPot[_msgSender] += _amount;\n        totalMarketPots += _amount;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyRole(MARKET)\n    {\n        // update the last rental time\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        // check if this is their first rental (no previous rental calculation)\n        if (user[_user].lastRentCalc == 0) {\n            // we need to start their clock ticking, update their last rental calculation time\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function addMarket(address _market, bool _paused) external override {\n        require(hasRole(FACTORY, msgSender()), \"Not Authorised\");\n        marketPaused[_market] = _paused;\n        AccessControl.grantRole(MARKET, _market);\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice provides the sum total of a users bids across all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyRole(ORDERBOOK) {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !hasRole(MARKET, _newOwner)\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(\n                    user[_newOwner].lastRentCalc,\n                    _timeOwnershipChanged,\n                    _newPrice\n                );\n\n                // they have enough funds, just collect the extra\n                // we can be sure of this because it was checked they can cover the minimum rental\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                    // send an event for the UI to have a timestamp\n                    emit LogAdjustDeposit(_newOwner, 0, false);\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calculation and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calculates the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestamps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /\n                totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +\n                timeLeftOfDeposit;\n\n            if (\n                foreclosureTimeWithoutNewCard > _timeOfNewBid &&\n                _timeOfNewBid != 0\n            ) {\n                // calculate how long they can own the new card for\n                uint256 _rentDifference = rentOwedBetweenTimestamps(\n                    user[_user].lastRentCalc,\n                    _timeOfNewBid,\n                    totalUserDailyRent\n                );\n                uint256 _depositAtTimeOfNewBid = 0;\n\n                if (user[_user].lastRentCalc < _timeOfNewBid) {\n                    // new bid is after user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit -\n                        _rentDifference;\n                } else {\n                    // new bid is before user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit +\n                        _rentDifference;\n                }\n\n                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *\n                    1 days) / (totalUserDailyRent + _newBid);\n\n                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +\n                    _timeLeftOfDepositWithNewBid;\n                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {\n                    return _foreclosureTimeWithNewCard;\n                } else {\n                    // The user couldn't afford to own the new card up to their last\n                    // .. rent calculation, we can't rewind their rent calculation because\n                    // .. of gas limits (there could be many markets having taken rent).\n                    // Therefore unfortunately we can't give any ownership to this user as\n                    // .. this could mean getting caught in a loop we may not be able to\n                    // .. exit because of gas limits (there could be many users in this\n                    // .. situation and we can't leave any unaccounted for).\n                    // This means we return 0 to signify that the user can't afford this\n                    // .. new ownership.\n                    return 0;\n                }\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            if (_newBid == 0) {\n                // if no rentals they'll foreclose after the heat death of the universe\n                return type(uint256).max;\n            } else {\n                return\n                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);\n            }\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        require(_timeToCollectTo != 0, \"Must set collection time\");\n        require(\n            _timeToCollectTo <= block.timestamp,\n            \"Can't collect future rent\"\n        );\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts = ((_timeToCollectTo -\n                    previousCollectionTime) * uint256(user[_user].deposit)) /\n                    rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepositLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets available balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n\n    /// @notice checks if the user should still be foreclosed\n    function assessForeclosure(address _user) public override {\n        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        } else {\n            isForeclosed[_user] = true;\n            emit LogUserForeclosed(_user, true);\n        }\n    }\n\n    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual\n    function checkPermission(bytes32 role, address account)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return AccessControl.hasRole(role, account);\n    }\n\n    function grantRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.grantRole(_role, account);\n    }\n\n    function grantRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, true);\n        }\n        AccessControl.grantRole(role, account);\n    }\n\n    function revokeRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.revokeRole(_role, account);\n    }\n\n    function revokeRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, false);\n        }\n        AccessControl.revokeRole(role, account);\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRealitio.sol\";\n\n/// @title Reality Cards Factory\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCFactory is NativeMetaTransaction, IRCFactory {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           VARIABLES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /////// CONTRACT VARIABLES ///////\n    IRCTreasury public override treasury;\n    IRCNftHubL2 public override nfthub;\n    IRCOrderbook public override orderbook;\n    IRCLeaderboard public override leaderboard;\n    IRealitio public override realitio;\n    /// @dev reference contract\n    address public override referenceContractAddress;\n    /// @dev increments each time a new reference contract is added\n    uint256 public override referenceContractVersion;\n    /// @dev market addresses, mode // address\n    /// @dev these are not used for anything, just an easy way to get markets\n    mapping(IRCMarket.Mode => address[]) public marketAddresses;\n\n    ////// BACKUP MODE //////\n    /// @dev should the Graph fail the UI needs a way to poll the contracts for market data\n    /// @dev the IPFS hash for each market\n    mapping(address => string) public override ipfsHash;\n    /// @dev the slug each market is hosted at\n    mapping(string => address) public override slugToAddress;\n    mapping(address => string) public override addressToSlug;\n    /// @dev the number of results to return in the backup view function\n    uint256 public override marketInfoResults;\n\n    ///// GOVERNANCE VARIABLES- OWNER /////\n    /// @dev artist / winner / market creator / affiliate / card affiliate\n    uint256[5] public potDistribution;\n    /// @dev minimum tokens that must be sent when creating market which forms initial pot\n    uint256 public override sponsorshipRequired;\n    /// @dev adjust required price increase (in %)\n    uint256 public override minimumPriceIncreasePercent;\n    /// @dev The number of users that are allowed to mint an NFT\n    uint256 public override nftsToAward;\n    /// @dev market opening time must be at least this many seconds in the future\n    uint32 public override advancedWarning;\n    /// @dev market closing time must be no more than this many seconds in the future\n    uint32 public override maximumDuration;\n    /// @dev market closing time must be at least this many seconds after opening\n    uint32 public override minimumDuration;\n    /// @dev if false, anyone can create markets\n    bool public override marketCreationGovernorsOnly = true;\n    /// @dev if false, anyone can be an affiliate\n    bool public override approvedAffiliatesOnly = true;\n    /// @dev if false, anyone can be an artist\n    bool public override approvedArtistsOnly = true;\n    /// @dev the maximum number of rent collections to perform in a single transaction\n    uint256 public override maxRentIterations;\n    /// @dev the maximum number of rent collections to have performed before locking the market\n    uint256 public override maxRentIterationsToLockMarket;\n    /// @dev the address of the arbitrator\n    address public override arbitrator;\n    /// @dev the time allowed to dispute the oracle answer\n    uint32 public override timeout;\n    /// @dev if true markets default to the paused state\n    bool public override marketPausedDefaultState;\n    /// @dev a limit to the number of NFTs to mint per market\n    uint256 public override cardLimit;\n\n    ///// GOVERNANCE VARIABLES- GOVERNORS /////\n    /// @dev unapproved markets hidden from the interface\n    mapping(address => bool) public override isMarketApproved;\n\n    ///// OTHER /////\n    uint256 public constant PER_MILLE = 1000; // in MegaBip so (1000 = 100%)\n    /// @dev store the tokenURIs for when we need to mint them\n    /// @dev we may want the original and the copies to have slightly different metadata\n    /// @dev so we append the metadata for the copies to the end of this array\n    mapping(address => mapping(uint256 => string)) tokenURIs;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant ARTIST = keccak256(\"ARTIST\");\n    bytes32 public constant AFFILIATE = keccak256(\"AFFILIATE\");\n    bytes32 public constant CARD_AFFILIATE = keccak256(\"CARD_AFFILIATE\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogMarketCreated1(\n        address contractAddress,\n        address treasuryAddress,\n        address nftHubAddress,\n        uint256 referenceContractVersion\n    );\n    event LogMarketCreated2(\n        address contractAddress,\n        IRCMarket.Mode mode,\n        string[] tokenURIs,\n        string ipfsHash,\n        uint32[] timestamps,\n        uint256 totalNftMintCount\n    );\n    event LogMarketApproved(address market, bool approved);\n    event LogMarketTimeRestrictions(\n        uint256 _newAdvancedWarning,\n        uint256 _newMinimumDuration,\n        uint256 _newMaximumDuration\n    );\n    event LogMintNFTCopy(\n        uint256 _originalTokenId,\n        address _newOwner,\n        uint256 _newTokenId\n    );\n    event LogMintNFT(uint256 _cardId, address _market, uint256 _tokenId);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          CONSTRUCTOR            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(\n        IRCTreasury _treasury,\n        address _realitioAddress,\n        address _arbitratorAddress\n    ) {\n        require(address(_treasury) != address(0), \"Must set Address\");\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsFactory\", \"1\");\n\n        // store contract instances\n        treasury = _treasury;\n\n        // initialise adjustable parameters\n        // artist // winner // creator // affiliate // card affiliates\n        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate\n        setMinimumPriceIncreasePercent(10); // 10%\n        setNumberOfNFTsToAward(3);\n        setCardLimit(100); // safe limit tested and set at 100, can be adjusted later if gas limit changes\n        setMaxRentIterations(50, 25); // safe limit tested and set at 50 & 25, can be adjusted later if gas limit changes\n        // oracle\n        setArbitrator(_arbitratorAddress);\n        setRealitioAddress(_realitioAddress);\n        setTimeout(86400); // 24 hours\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          VIEW FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Fetch the address of the most recently created market\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return the address of the most recent market in the given mode\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        override\n        returns (address)\n    {\n        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];\n    }\n\n    /// @notice Fetch all the market addresses for a given mode\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return an array of all markets in a given mode\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return marketAddresses[_mode];\n    }\n\n    /// @notice Returns the currently set pot distribution\n    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates\n    function getPotDistribution()\n        external\n        view\n        override\n        returns (uint256[5] memory)\n    {\n        return potDistribution;\n    }\n\n    /// @notice fetch the current oracle, arbitrator and timeout settings\n    /// @dev called by the market upon initialise\n    /// @dev not passed to initialise to avoid stack too deep error\n    /// @return Oracle Address\n    /// @return Arbitrator Address\n    /// @return Question timeout in seconds\n    function getOracleSettings()\n        external\n        view\n        override\n        returns (\n            IRealitio,\n            address,\n            uint32\n        )\n    {\n        return (realitio, arbitrator, timeout);\n    }\n\n    /// @notice Returns market addresses and ipfs hashes\n    /// @dev used for the UI backup mode\n    /// @param _mode return markets only in the given mode\n    /// @param _state return markets only in the given state\n    /// @param _skipResults the number of results to skip\n    function getMarketInfo(\n        IRCMarket.Mode _mode,\n        uint256 _state,\n        uint256 _skipResults\n    )\n        external\n        view\n        returns (\n            address[] memory,\n            string[] memory,\n            string[] memory,\n            uint256[] memory\n        )\n    {\n        uint256 _marketIndex = marketAddresses[_mode].length;\n        uint256 _resultNumber = 0;\n        address[] memory _marketAddresses = new address[](marketInfoResults);\n        string[] memory _ipfsHashes = new string[](marketInfoResults);\n        uint256[] memory _potSizes = new uint256[](marketInfoResults);\n        string[] memory _slugs = new string[](marketInfoResults);\n        while (_resultNumber < marketInfoResults && _marketIndex > 1) {\n            _marketIndex--;\n            address _market = marketAddresses[_mode][_marketIndex];\n            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {\n                if (_resultNumber < _skipResults) {\n                    _resultNumber++;\n                } else {\n                    _marketAddresses[_resultNumber] = _market;\n                    _ipfsHashes[_resultNumber] = ipfsHash[_market];\n                    _slugs[_resultNumber] = addressToSlug[_market];\n                    _potSizes[_resultNumber] = IRCMarket(_market)\n                        .totalRentCollected();\n                    _resultNumber++;\n                }\n            }\n        }\n        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    modifier onlyUberOwner() {\n        require(\n            treasury.checkPermission(UBER_OWNER, msgSender()),\n            \"Not approved\"\n        );\n        _;\n    }\n    modifier onlyOwner() {\n        require(treasury.checkPermission(OWNER, msgSender()), \"Not approved\");\n        _;\n    }\n    modifier onlyGovernors() {\n        require(\n            treasury.checkPermission(GOVERNOR, msgSender()),\n            \"Not approved\"\n        );\n        _;\n    }\n    modifier onlyMarkets() {\n        require(treasury.checkPermission(MARKET, msgSender()), \"Not approved\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n    // Min price increase & pot distribution emitted by Market.\n    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUCTOR - PUBLIC \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice update stakeholder payouts\n    /// @dev in MegaBip (so 1000 = 100%)\n    /// @param _artistCut The artist that designed the card\n    /// @param _winnerCut Extra cut for the longest owner\n    /// @param _creatorCut The creator of the market\n    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts\n    /// @param _cardAffiliateCut An affiliate cur for specific cards\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) public override onlyOwner {\n        require(\n            _artistCut +\n                _winnerCut +\n                _creatorCut +\n                _affiliateCut +\n                _cardAffiliateCut <=\n                PER_MILLE,\n            \"Cuts too big\"\n        );\n        potDistribution[0] = _artistCut;\n        potDistribution[1] = _winnerCut;\n        potDistribution[2] = _creatorCut;\n        potDistribution[3] = _affiliateCut;\n        potDistribution[4] = _cardAffiliateCut;\n    }\n\n    /// @notice how much above the current price a user must bid, in %\n    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease)\n        public\n        override\n        onlyOwner\n    {\n        minimumPriceIncreasePercent = _percentIncrease;\n    }\n\n    /// @notice how many NFTs will be awarded to the leaderboard\n    /// @param _nftsToAward the number of NFTs to award\n    function setNumberOfNFTsToAward(uint256 _nftsToAward)\n        public\n        override\n        onlyOwner\n    {\n        nftsToAward = _nftsToAward;\n    }\n\n    /// @notice A limit to the number of NFTs to mint per market\n    /// @dev to avoid gas limits\n    /// @param _cardLimit the limit to set\n    function setCardLimit(uint256 _cardLimit) public override onlyOwner {\n        cardLimit = _cardLimit;\n    }\n\n    /// @notice A limit to the number of rent collections per transaction\n    /// @dev to avoid gas limits\n    /// @param _rentLimit the limit to set\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        public\n        override\n        onlyOwner\n    {\n        maxRentIterations = _rentLimit;\n        maxRentIterationsToLockMarket = _rentLimitLocking;\n    }\n\n    /// @notice set the address of the reality.eth contracts\n    /// @param _newAddress the address to set\n    function setRealitioAddress(address _newAddress) public override onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @notice address of the arbitrator, in case of continued disputes on reality.eth\n    /// @param _newAddress the address to set\n    function setArbitrator(address _newAddress) public override onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        arbitrator = _newAddress;\n    }\n\n    /// @notice set how long reality.eth waits for disputes before finalising\n    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs\n    function setTimeout(uint32 _newTimeout) public override onlyOwner {\n        // event is emitted from the Oracle when the question is asked\n        timeout = _newTimeout;\n    }\n\n    function setMarketPausedDefaultState(bool _state)\n        external\n        override\n        onlyOwner\n    {\n        marketPausedDefaultState = _state;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice whether or not only governors can create the market\n    function changeMarketCreationGovernorsOnly() external override onlyOwner {\n        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;\n    }\n\n    /// @notice whether or not anyone can be an artist\n    function changeApprovedArtistsOnly() external override onlyOwner {\n        approvedArtistsOnly = !approvedArtistsOnly;\n    }\n\n    /// @notice whether or not anyone can be an affiliate\n    function changeApprovedAffilliatesOnly() external override onlyOwner {\n        approvedAffiliatesOnly = !approvedAffiliatesOnly;\n    }\n\n    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot\n    /// @param _amount the sponsorship required in wei\n    function setSponsorshipRequired(uint256 _amount)\n        external\n        override\n        onlyOwner\n    {\n        sponsorshipRequired = _amount;\n    }\n\n    /// @notice market opening time must be at least this many seconds in the future\n    /// @param _newAdvancedWarning the warning time to set in seconds\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external override onlyOwner {\n        advancedWarning = _newAdvancedWarning;\n        minimumDuration = _newMinimumDuration;\n        maximumDuration = _newMaximumDuration;\n        emit LogMarketTimeRestrictions(\n            _newAdvancedWarning,\n            _newMinimumDuration,\n            _newMaximumDuration\n        );\n    }\n\n    /// @notice Allow the owner to update a token URI.\n    /// @param _market the market address the token belongs to\n    /// @param _cardId the index 0 card id of the token to change\n    /// @param _newTokenURI the new URI to set\n    /// @param _newCopyTokenURI the new URI to set for the copy\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external override onlyOwner {\n        IRCMarket.Mode _mode = IRCMarket(_market).mode();\n        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();\n        tokenURIs[_market][_cardId] = _newTokenURI;\n        tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI;\n        string[] memory _tokenURIs = new string[](_numberOfCards);\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            _tokenURIs[i] = tokenURIs[_market][i];\n        }\n        uint32[] memory _timestamps = new uint32[](3);\n        _timestamps[0] = IRCMarket(_market).marketOpeningTime();\n        _timestamps[1] = IRCMarket(_market).marketLockingTime();\n        _timestamps[2] = IRCMarket(_market).oracleResolutionTime();\n\n        // reuse this event so the frontend can pickup the change\n        emit LogMarketCreated2(\n            _market,\n            IRCMarket.Mode(_mode),\n            _tokenURIs,\n            ipfsHash[_market],\n            _timestamps,\n            nfthub.totalSupply()\n        );\n    }\n\n    /// @notice change how many results are returned from getMarketInfo\n    /// @dev would be better to pass this as a parameter in getMarketInfo\n    /// @dev .. however we are limited because of stack too deep errors\n    function setMarketInfoResults(uint256 _results)\n        external\n        override\n        onlyOwner\n    {\n        // no event needed, only used for the backup view mode\n        marketInfoResults = _results;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - GOVERNORS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyGovernors modifier\n\n    /// @notice markets are default hidden from the interface, this reveals them\n    /// @param _market the market address to change approval for\n    function changeMarketApproval(address _market)\n        external\n        override\n        onlyGovernors\n    {\n        require(_market != address(0), \"Must set Address\");\n        // check it's an RC contract\n        require(treasury.checkPermission(MARKET, _market), \"Not Market\");\n        isMarketApproved[_market] = !isMarketApproved[_market];\n        // governors shouldn't have the ability to pause a market, only un-pause.\n        // .. if a governor accidentally approves a market they should seek\n        // .. assistance from the owner to decide if it should be paused.\n        treasury.unPauseMarket(_market);\n        // the market will however be hidden from the UI in the meantime\n        emit LogMarketApproved(_market, isMarketApproved[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551   GOVERNANCE - Role management  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev the following functions could all be performed directly on the treasury\n    /// @dev .. they are here as an interim solution to give governors an easy way\n    /// @dev .. to change all their parameters via the block explorer.\n\n    /// @notice Grant the artist role to an address\n    /// @param _newArtist the address to grant the role of artist\n    function addArtist(address _newArtist) external override onlyGovernors {\n        treasury.grantRole(ARTIST, _newArtist);\n    }\n\n    /// @notice Remove the artist role from an address\n    /// @param _oldArtist the address to revoke the role of artist\n    function removeArtist(address _oldArtist) external override onlyGovernors {\n        treasury.revokeRole(ARTIST, _oldArtist);\n    }\n\n    /// @notice Grant the affiliate role to an address\n    /// @param _newAffiliate the address to grant the role of affiliate\n    function addAffiliate(address _newAffiliate)\n        external\n        override\n        onlyGovernors\n    {\n        treasury.grantRole(AFFILIATE, _newAffiliate);\n    }\n\n    /// @notice Remove the affiliate role from an address\n    /// @param _oldAffiliate the address to revoke the role of affiliate\n    function removeAffiliate(address _oldAffiliate)\n        external\n        override\n        onlyGovernors\n    {\n        treasury.revokeRole(AFFILIATE, _oldAffiliate);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades, this is separated so owner can be\n    /// @dev ..  set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governance functions\n\n    /// @notice change the reference contract for the contract logic\n    /// @param _newAddress the address of the new reference contract to set\n    function setReferenceContractAddress(address _newAddress)\n        external\n        override\n        onlyUberOwner\n    {\n        require(_newAddress != address(0));\n        // check it's an RC contract\n        IRCMarket newContractVariable = IRCMarket(_newAddress);\n        require(newContractVariable.isMarket(), \"Not Market\");\n        // set\n        referenceContractAddress = _newAddress;\n        // increment version\n        referenceContractVersion += 1;\n    }\n\n    /// @notice where the NFTs live\n    /// @param _newAddress the address to set\n    function setNftHubAddress(IRCNftHubL2 _newAddress)\n        external\n        override\n        onlyUberOwner\n    {\n        require(address(_newAddress) != address(0), \"Must set Address\");\n        nfthub = _newAddress;\n    }\n\n    /// @notice set the address of the orderbook contract\n    /// @param _newOrderbook the address to set\n    /// @dev set by the treasury to ensure all contracts use the same orderbook\n    function setOrderbookAddress(IRCOrderbook _newOrderbook) external override {\n        require(\n            treasury.checkPermission(TREASURY, msgSender()),\n            \"Not approved\"\n        );\n        orderbook = _newOrderbook;\n    }\n\n    /// @notice set the address of the leaderboard contract\n    /// @param _newLeaderboard the address to set\n    /// @dev set by the treasury to ensure all contracts use the same leaderboard\n    function setLeaderboardAddress(IRCLeaderboard _newLeaderboard)\n        external\n        override\n    {\n        require(\n            treasury.checkPermission(TREASURY, msgSender()),\n            \"Not approved\"\n        );\n        leaderboard = _newLeaderboard;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         MARKET CREATION         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Creates a new market with the given parameters\n    /// @param _mode 0 = normal, 1 = winner takes all\n    /// @param _ipfsHash the IPFS location of the market metadata\n    /// @param _slug the URL subdomain in the UI\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _tokenURIs location of NFT metadata, originals followed by copies\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliates cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliates cut, if any\n    /// @param _realitioQuestion the details of the event to send to the oracle\n    /// @param _sponsorship amount of sponsorship to create the market with\n    /// @return The address of the new market\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string memory _realitioQuestion,\n        uint256 _sponsorship\n    ) external override returns (address) {\n        address _creator = msgSender();\n\n        // check nfthub has been set\n        require(address(nfthub) != address(0), \"Nfthub not set\");\n\n        // check sponsorship\n        require(\n            _sponsorship >= sponsorshipRequired,\n            \"Insufficient sponsorship\"\n        );\n        treasury.checkSponsorship(_creator, _sponsorship);\n\n        // check the number of NFTs to mint is within limits\n        /// @dev we want different tokenURIs for originals and copies\n        /// @dev ..the copies are appended to the end of the array\n        /// @dev ..so half the array length if the number of tokens.\n        require(\n            (_tokenURIs.length / 2) <= cardLimit,\n            \"Too many tokens to mint\"\n        );\n\n        // check stakeholder addresses\n        // artist\n        if (approvedArtistsOnly) {\n            require(\n                _artistAddress == address(0) ||\n                    treasury.checkPermission(ARTIST, _artistAddress),\n                \"Artist not approved\"\n            );\n        }\n\n        // affiliate\n        require(\n            _cardAffiliateAddresses.length == 0 ||\n                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),\n            \"Card Affiliate Length Error\"\n        );\n        if (approvedAffiliatesOnly) {\n            require(\n                _affiliateAddress == address(0) ||\n                    treasury.checkPermission(AFFILIATE, _affiliateAddress),\n                \"Affiliate not approved\"\n            );\n            // card affiliates\n            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {\n                require(\n                    _cardAffiliateAddresses[i] == address(0) ||\n                        treasury.checkPermission(\n                            CARD_AFFILIATE,\n                            _cardAffiliateAddresses[i]\n                        ),\n                    \"Card affiliate not approved\"\n                );\n            }\n        }\n\n        // check market creator is approved\n        if (marketCreationGovernorsOnly) {\n            require(\n                treasury.checkPermission(GOVERNOR, _creator),\n                \"Not approved\"\n            );\n        }\n\n        _checkTimestamps(_timestamps);\n\n        // create the market and emit the appropriate events\n        // two events to avoid stack too deep error\n        address _newAddress = Clones.clone(referenceContractAddress);\n        emit LogMarketCreated1(\n            _newAddress,\n            address(treasury),\n            address(nfthub),\n            referenceContractVersion\n        );\n        emit LogMarketCreated2(\n            _newAddress,\n            IRCMarket.Mode(_mode),\n            _tokenURIs,\n            _ipfsHash,\n            _timestamps,\n            nfthub.totalSupply()\n        );\n\n        // tell Treasury and NFT hub about new market\n        // before initialize as during initialize the market may call the treasury\n        treasury.addMarket(_newAddress, marketPausedDefaultState);\n        nfthub.addMarket(_newAddress);\n\n        // update internals\n        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);\n        ipfsHash[_newAddress] = _ipfsHash;\n        slugToAddress[_slug] = _newAddress;\n        addressToSlug[_newAddress] = _slug;\n\n        // initialize the market\n        IRCMarket(_newAddress).initialize(\n            IRCMarket.Mode(_mode),\n            _timestamps,\n            (_tokenURIs.length / 2),\n            _artistAddress,\n            _affiliateAddress,\n            _cardAffiliateAddresses,\n            _creator,\n            _realitioQuestion,\n            nftsToAward\n        );\n\n        // store token URIs\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            tokenURIs[_newAddress][i] = _tokenURIs[i];\n        }\n\n        // pay sponsorship, if applicable\n        if (_sponsorship > 0) {\n            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);\n        }\n\n        return _newAddress;\n    }\n\n    function _checkTimestamps(uint32[] memory _timestamps) internal view {\n        // check timestamps\n        require(_timestamps.length == 3, \"Incorrect number of array elements\");\n        // check market opening time\n        if (advancedWarning != 0) {\n            // different statements to give clearer revert messages\n            require(\n                _timestamps[0] >= block.timestamp,\n                \"Market opening time not set\"\n            );\n            require(\n                _timestamps[0] - advancedWarning > block.timestamp,\n                \"Market opens too soon\"\n            );\n        }\n        // check market locking time\n        if (maximumDuration != 0) {\n            require(\n                _timestamps[1] < block.timestamp + maximumDuration,\n                \"Market locks too late\"\n            );\n        }\n        require(\n            _timestamps[0] + minimumDuration < _timestamps[1] &&\n                block.timestamp + minimumDuration < _timestamps[1],\n            \"Market lock must be after opening\"\n        );\n        // check oracle resolution time (no more than 1 week after market locking to get result)\n        require(\n            _timestamps[1] + (1 weeks) > _timestamps[2] &&\n                _timestamps[1] <= _timestamps[2],\n            \"Oracle resolution time error\"\n        );\n    }\n\n    /// @notice Called by the markets to mint the original NFTs\n    /// @param _card the card id to be minted\n    function mintMarketNFT(uint256 _card) external override onlyMarkets {\n        uint256 nftHubMintCount = nfthub.totalSupply();\n        address _market = msgSender();\n        nfthub.mint(_market, nftHubMintCount, tokenURIs[_market][_card]);\n        emit LogMintNFT(_card, _market, nftHubMintCount);\n    }\n\n    /// @notice allows the market to mint a copy of the NFT for users on the leaderboard\n    /// @param _user the user to award the NFT to\n    /// @param _cardId the tokenId to copy\n    function mintCopyOfNFT(address _user, uint256 _cardId)\n        external\n        override\n        onlyMarkets\n    {\n        address _market = msgSender();\n        uint256 _newTokenId = nfthub.totalSupply();\n        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();\n        nfthub.mint(\n            _user,\n            _newTokenId,\n            tokenURIs[_market][(_cardId + _numberOfCards)]\n        );\n        emit LogMintNFTCopy(_cardId, _user, _newTokenId);\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCTreasury.sol",
            "RCFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "setNftHubAddress(), setOrderbookAddress(), setLeaderboardAddress() functions of RCFactory and setMinRental() function of RCTreasury",
                "Type": "Parameter updates not propagated",
                "Description": "Parameters updated in certain functions are only updated on the top level and not propagated to the other contracts.",
                "Repair": "Implement a way to notify the underlying contracts of the updates"
            },
            {
                "Location": "RCFactory and RCTreasury contracts",
                "Type": "UberOwner has too much power",
                "Description": "The Uber Owner has too much power within the system and can completely change the functionality of the system.",
                "Repair": "Limit the permission of the Uber Owner to something more manageable and trustable or use a proxy instead for upgrades to underlying contracts"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)",
                "Type": "Logic",
                "Description": "The function findNewOwner in RCOrderbook has a logic vulnerability where a valid owner can be considered invalid and skipped over if the processing finishes at the same time as the loop counter reaches the maximum deletions. This can impact the availability of the user's ownership and can be exploited by an attacker to rent a card at a cheaper rate. The fix involves checking if a valid user is found or if the deletion limit is hit to avoid skipping any bids.",
                "Repair": "Check if a valid user is found or if the deletion limit is hit to avoid skipping any bids"
            }
        ]
    }
]