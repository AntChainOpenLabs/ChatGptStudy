[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCBridge.sol\";\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {\n    using SafeERC20 for IERC20;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public override orderbook;\n    /// @dev leaderboard instance\n    IRCLeaderboard public override leaderboard;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev the Factory so only the Factory can add new markets\n    IRCFactory public override factory;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public override marketBalance;\n    /// @dev a quick check if a user is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 public override marketBalanceTopup;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    /// @dev intended for beta use only, will be disabled after launch\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n    /// @dev allow markets to be restricted to a certain role\n    mapping(address => bytes32) public marketWhitelist;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent, claim or upgrade any cards for specific market\n    mapping(address => bool) public override marketPaused;\n    /// @dev if true, owner has locked the market pause (Governors are locked out)\n    mapping(address => bool) public override lockMarketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant FACTORY = keccak256(\"FACTORY\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant WHITELIST = keccak256(\"WHITELIST\");\n    bytes32 public constant ARTIST = keccak256(\"ARTIST\");\n    bytes32 public constant AFFILIATE = keccak256(\"AFFILIATE\");\n    bytes32 public constant CARD_AFFILIATE = keccak256(\"CARD_AFFILIATE\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n    event LogWhitelistUser(address user, bool allowed);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        /* setup AccessControl\n\n                         UBER_OWNER\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502           \u2502          \u2502            \u2502         \u2502\n          OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD\n            \u2502           \u2502\n         GOVERNOR     MARKET\n            \u2502\n         WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE\n        */\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(UBER_OWNER, _msgSender());\n        _setupRole(OWNER, _msgSender());\n        _setupRole(GOVERNOR, _msgSender());\n        _setupRole(WHITELIST, _msgSender());\n        _setupRole(TREASURY, address(this));\n        _setRoleAdmin(UBER_OWNER, UBER_OWNER);\n        _setRoleAdmin(OWNER, UBER_OWNER);\n        _setRoleAdmin(FACTORY, UBER_OWNER);\n        _setRoleAdmin(ORDERBOOK, UBER_OWNER);\n        _setRoleAdmin(TREASURY, UBER_OWNER);\n        _setRoleAdmin(GOVERNOR, OWNER);\n        _setRoleAdmin(WHITELIST, GOVERNOR);\n        _setRoleAdmin(ARTIST, GOVERNOR);\n        _setRoleAdmin(AFFILIATE, GOVERNOR);\n        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);\n        _setRoleAdmin(MARKET, FACTORY);\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1_000_000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks() {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyRole(OWNER)\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUCTOR - PUBLIC \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @dev this is only a soft check, it is possible to exceed this limit\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyRole(OWNER)\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyRole(OWNER) {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market\n    function changePauseMarket(address _market, bool _paused)\n        external\n        override\n        onlyRole(OWNER)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        marketPaused[_market] = _paused;\n        lockMarketPaused[_market] = marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it\n    function unPauseMarket(address _market)\n        external\n        override\n        onlyRole(FACTORY)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        require(!lockMarketPaused[_market], \"Owner has paused market\");\n        marketPaused[_market] = false;\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyRole(OWNER) {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add/Remove multiple users to the whitelist\n    /// @param _users an array of users to add or remove\n    /// @param add true to add the users\n    function batchWhitelist(address[] calldata _users, bool add)\n        external\n        override\n        onlyRole(GOVERNOR)\n    {\n        if (add) {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.grantRole(WHITELIST, _users[index]);\n            }\n        } else {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.revokeRole(WHITELIST, _users[index]);\n            }\n        }\n    }\n\n    /// @notice Some markets may be restricted to certain roles,\n    /// @notice This function checks if the user has the role requried for a given market\n    /// @dev Used for the markets to check themselves\n    /// @param _user The user to check\n    function marketWhitelistCheck(address _user)\n        external\n        view\n        override\n        returns (bool)\n    {\n        bytes32 requiredRole = marketWhitelist[msgSender()];\n        if (requiredRole == bytes32(0)) {\n            return true;\n        } else {\n            return hasRole(requiredRole, _user);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governance functions\n\n    function setFactoryAddress(address _newFactory)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newFactory != address(0), \"Must set an address\");\n        // factory is also an OWNER and GOVERNOR to use the proxy functions\n        revokeRole(FACTORY, address(factory));\n        revokeRole(OWNER, address(factory));\n        revokeRole(GOVERNOR, address(factory));\n        factory = IRCFactory(_newFactory);\n        grantRole(FACTORY, address(factory));\n        grantRole(OWNER, address(factory));\n        grantRole(GOVERNOR, address(factory));\n    }\n\n    function setOrderbookAddress(address _newOrderbook)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newOrderbook != address(0), \"Must set an address\");\n        revokeRole(ORDERBOOK, address(orderbook));\n        orderbook = IRCOrderbook(_newOrderbook);\n        grantRole(ORDERBOOK, address(orderbook));\n        factory.setOrderbookAddress(orderbook);\n    }\n\n    function setLeaderboardAddress(address _newLeaderboard)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newLeaderboard != address(0), \"Must set an address\");\n        leaderboard = IRCLeaderboard(_newLeaderboard);\n        factory.setLeaderboardAddress(leaderboard);\n    }\n\n    function setTokenAddress(address _newToken)\n        public\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner\n    function globalExit() external onlyRole(UBER_OWNER) {\n        uint256 _balance = erc20.balanceOf(address(this));\n        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised\n        erc20.safeTransfer(msg.sender, _balance);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        external\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(hasRole(WHITELIST, _user), \"Not in whitelist\");\n        }\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        assessForeclosure(_user);\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // step 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.safeTransfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        // do some cleaning up first, it might help avoid their foreclosure\n        orderbook.removeOldBids(_msgSender);\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            // foreclose user, this is requred to remove them from the orderbook\n            isForeclosed[_msgSender] = true;\n            // remove them from the orderbook\n            orderbook.removeUserFromOrderbook(_msgSender);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount)\n        external\n        override\n        balancedBooks\n    {\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n        marketBalanceTopup += _amount;\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (uint256)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            uint256 discrepancy = _amount - marketBalance;\n            if (discrepancy > marketBalanceTopup) {\n                marketBalanceTopup = 0;\n            } else {\n                marketBalanceTopup -= discrepancy;\n            }\n            _amount = marketBalance;\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n        /// @dev return the amount just incase it was adjusted\n        return _amount;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        assessForeclosure(_user);\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        assessForeclosure(_user);\n    }\n\n    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        address _msgSender = msgSender();\n        require(!lockMarketPaused[_msgSender], \"Market is paused\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.safeTransferFrom(_sponsor, address(this), _amount);\n        marketPot[_msgSender] += _amount;\n        totalMarketPots += _amount;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyRole(MARKET)\n    {\n        // update the last rental time\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        // check if this is their first rental (no previous rental calculation)\n        if (user[_user].lastRentCalc == 0) {\n            // we need to start their clock ticking, update their last rental calculation time\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function addMarket(address _market, bool _paused) external override {\n        require(hasRole(FACTORY, msgSender()), \"Not Authorised\");\n        marketPaused[_market] = _paused;\n        AccessControl.grantRole(MARKET, _market);\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice provides the sum total of a users bids across all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyRole(ORDERBOOK) {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !hasRole(MARKET, _newOwner)\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(\n                    user[_newOwner].lastRentCalc,\n                    _timeOwnershipChanged,\n                    _newPrice\n                );\n\n                // they have enough funds, just collect the extra\n                // we can be sure of this because it was checked they can cover the minimum rental\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                    // send an event for the UI to have a timestamp\n                    emit LogAdjustDeposit(_newOwner, 0, false);\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calculation and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calculates the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestamps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /\n                totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +\n                timeLeftOfDeposit;\n\n            if (\n                foreclosureTimeWithoutNewCard > _timeOfNewBid &&\n                _timeOfNewBid != 0\n            ) {\n                // calculate how long they can own the new card for\n                uint256 _rentDifference = rentOwedBetweenTimestamps(\n                    user[_user].lastRentCalc,\n                    _timeOfNewBid,\n                    totalUserDailyRent\n                );\n                uint256 _depositAtTimeOfNewBid = 0;\n\n                if (user[_user].lastRentCalc < _timeOfNewBid) {\n                    // new bid is after user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit -\n                        _rentDifference;\n                } else {\n                    // new bid is before user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit +\n                        _rentDifference;\n                }\n\n                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *\n                    1 days) / (totalUserDailyRent + _newBid);\n\n                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +\n                    _timeLeftOfDepositWithNewBid;\n                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {\n                    return _foreclosureTimeWithNewCard;\n                } else {\n                    // The user couldn't afford to own the new card up to their last\n                    // .. rent calculation, we can't rewind their rent calculation because\n                    // .. of gas limits (there could be many markets having taken rent).\n                    // Therefore unfortunately we can't give any ownership to this user as\n                    // .. this could mean getting caught in a loop we may not be able to\n                    // .. exit because of gas limits (there could be many users in this\n                    // .. situation and we can't leave any unaccounted for).\n                    // This means we return 0 to signify that the user can't afford this\n                    // .. new ownership.\n                    return 0;\n                }\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            if (_newBid == 0) {\n                // if no rentals they'll foreclose after the heat death of the universe\n                return type(uint256).max;\n            } else {\n                return\n                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);\n            }\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        require(_timeToCollectTo != 0, \"Must set collection time\");\n        require(\n            _timeToCollectTo <= block.timestamp,\n            \"Can't collect future rent\"\n        );\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts = ((_timeToCollectTo -\n                    previousCollectionTime) * uint256(user[_user].deposit)) /\n                    rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepositLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets available balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n\n    /// @notice checks if the user should still be foreclosed\n    function assessForeclosure(address _user) public override {\n        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        } else {\n            isForeclosed[_user] = true;\n            emit LogUserForeclosed(_user, true);\n        }\n    }\n\n    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual\n    function checkPermission(bytes32 role, address account)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return AccessControl.hasRole(role, account);\n    }\n\n    function grantRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.grantRole(_role, account);\n    }\n\n    function grantRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, true);\n        }\n        AccessControl.grantRole(role, account);\n    }\n\n    function revokeRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.revokeRole(_role, account);\n    }\n\n    function revokeRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, false);\n        }\n        AccessControl.revokeRole(role, account);\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCTreasury.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "setNftHubAddress, setOrderbookAddress, setLeaderboardAddress in RCFactory; setMinRental in RCTreasury",
                "Type": "Parameter updates not propagated",
                "Description": "The parameters are only updated on the top level and not propagated to the other contracts. This could lead to various unpredictable results.",
                "Repair": "Implement a way to notify the underlying contracts of the updates"
            },
            {
                "Location": "deposit() function in RCTreasury.sol",
                "Type": "Deposits don't work with fee-on transfer tokens",
                "Description": "The deposit function will credit more deposits than the contract actually received.",
                "Repair": "Ensure that the erc20 token does not implement any customizations or measure the asset change right before and after the asset-transferring routines"
            },
            {
                "Location": "marketWhitelistCheck() function in RCTreasury.sol",
                "Type": "Uninitialized Variable",
                "Description": "The variable, marketWhitelist, is never initialized in the contract RCTreasury.sol.",
                "Repair": "Ensure this behavior is intended or add a function that enables a market creator to restrict their market to a specific role by whitelisting users"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRealitio.sol\";\n\n/// @title Reality Cards Factory\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCFactory is NativeMetaTransaction, IRCFactory {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           VARIABLES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /////// CONTRACT VARIABLES ///////\n    IRCTreasury public override treasury;\n    IRCNftHubL2 public override nfthub;\n    IRCOrderbook public override orderbook;\n    IRCLeaderboard public override leaderboard;\n    IRealitio public override realitio;\n    /// @dev reference contract\n    address public override referenceContractAddress;\n    /// @dev increments each time a new reference contract is added\n    uint256 public override referenceContractVersion;\n    /// @dev market addresses, mode // address\n    /// @dev these are not used for anything, just an easy way to get markets\n    mapping(IRCMarket.Mode => address[]) public marketAddresses;\n\n    ////// BACKUP MODE //////\n    /// @dev should the Graph fail the UI needs a way to poll the contracts for market data\n    /// @dev the IPFS hash for each market\n    mapping(address => string) public override ipfsHash;\n    /// @dev the slug each market is hosted at\n    mapping(string => address) public override slugToAddress;\n    mapping(address => string) public override addressToSlug;\n    /// @dev the number of results to return in the backup view function\n    uint256 public override marketInfoResults;\n\n    ///// GOVERNANCE VARIABLES- OWNER /////\n    /// @dev artist / winner / market creator / affiliate / card affiliate\n    uint256[5] public potDistribution;\n    /// @dev minimum tokens that must be sent when creating market which forms initial pot\n    uint256 public override sponsorshipRequired;\n    /// @dev adjust required price increase (in %)\n    uint256 public override minimumPriceIncreasePercent;\n    /// @dev The number of users that are allowed to mint an NFT\n    uint256 public override nftsToAward;\n    /// @dev market opening time must be at least this many seconds in the future\n    uint32 public override advancedWarning;\n    /// @dev market closing time must be no more than this many seconds in the future\n    uint32 public override maximumDuration;\n    /// @dev market closing time must be at least this many seconds after opening\n    uint32 public override minimumDuration;\n    /// @dev if false, anyone can create markets\n    bool public override marketCreationGovernorsOnly = true;\n    /// @dev if false, anyone can be an affiliate\n    bool public override approvedAffiliatesOnly = true;\n    /// @dev if false, anyone can be an artist\n    bool public override approvedArtistsOnly = true;\n    /// @dev the maximum number of rent collections to perform in a single transaction\n    uint256 public override maxRentIterations;\n    /// @dev the maximum number of rent collections to have performed before locking the market\n    uint256 public override maxRentIterationsToLockMarket;\n    /// @dev the address of the arbitrator\n    address public override arbitrator;\n    /// @dev the time allowed to dispute the oracle answer\n    uint32 public override timeout;\n    /// @dev if true markets default to the paused state\n    bool public override marketPausedDefaultState;\n    /// @dev a limit to the number of NFTs to mint per market\n    uint256 public override cardLimit;\n\n    ///// GOVERNANCE VARIABLES- GOVERNORS /////\n    /// @dev unapproved markets hidden from the interface\n    mapping(address => bool) public override isMarketApproved;\n\n    ///// OTHER /////\n    uint256 public constant PER_MILLE = 1000; // in MegaBip so (1000 = 100%)\n    /// @dev store the tokenURIs for when we need to mint them\n    /// @dev we may want the original and the copies to have slightly different metadata\n    /// @dev so we append the metadata for the copies to the end of this array\n    mapping(address => mapping(uint256 => string)) tokenURIs;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant ARTIST = keccak256(\"ARTIST\");\n    bytes32 public constant AFFILIATE = keccak256(\"AFFILIATE\");\n    bytes32 public constant CARD_AFFILIATE = keccak256(\"CARD_AFFILIATE\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogMarketCreated1(\n        address contractAddress,\n        address treasuryAddress,\n        address nftHubAddress,\n        uint256 referenceContractVersion\n    );\n    event LogMarketCreated2(\n        address contractAddress,\n        IRCMarket.Mode mode,\n        string[] tokenURIs,\n        string ipfsHash,\n        uint32[] timestamps,\n        uint256 totalNftMintCount\n    );\n    event LogMarketApproved(address market, bool approved);\n    event LogMarketTimeRestrictions(\n        uint256 _newAdvancedWarning,\n        uint256 _newMinimumDuration,\n        uint256 _newMaximumDuration\n    );\n    event LogMintNFTCopy(\n        uint256 _originalTokenId,\n        address _newOwner,\n        uint256 _newTokenId\n    );\n    event LogMintNFT(uint256 _cardId, address _market, uint256 _tokenId);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          CONSTRUCTOR            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(\n        IRCTreasury _treasury,\n        address _realitioAddress,\n        address _arbitratorAddress\n    ) {\n        require(address(_treasury) != address(0), \"Must set Address\");\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsFactory\", \"1\");\n\n        // store contract instances\n        treasury = _treasury;\n\n        // initialise adjustable parameters\n        // artist // winner // creator // affiliate // card affiliates\n        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate\n        setMinimumPriceIncreasePercent(10); // 10%\n        setNumberOfNFTsToAward(3);\n        setCardLimit(100); // safe limit tested and set at 100, can be adjusted later if gas limit changes\n        setMaxRentIterations(50, 25); // safe limit tested and set at 50 & 25, can be adjusted later if gas limit changes\n        // oracle\n        setArbitrator(_arbitratorAddress);\n        setRealitioAddress(_realitioAddress);\n        setTimeout(86400); // 24 hours\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          VIEW FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Fetch the address of the most recently created market\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return the address of the most recent market in the given mode\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        override\n        returns (address)\n    {\n        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];\n    }\n\n    /// @notice Fetch all the market addresses for a given mode\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return an array of all markets in a given mode\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return marketAddresses[_mode];\n    }\n\n    /// @notice Returns the currently set pot distribution\n    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates\n    function getPotDistribution()\n        external\n        view\n        override\n        returns (uint256[5] memory)\n    {\n        return potDistribution;\n    }\n\n    /// @notice fetch the current oracle, arbitrator and timeout settings\n    /// @dev called by the market upon initialise\n    /// @dev not passed to initialise to avoid stack too deep error\n    /// @return Oracle Address\n    /// @return Arbitrator Address\n    /// @return Question timeout in seconds\n    function getOracleSettings()\n        external\n        view\n        override\n        returns (\n            IRealitio,\n            address,\n            uint32\n        )\n    {\n        return (realitio, arbitrator, timeout);\n    }\n\n    /// @notice Returns market addresses and ipfs hashes\n    /// @dev used for the UI backup mode\n    /// @param _mode return markets only in the given mode\n    /// @param _state return markets only in the given state\n    /// @param _skipResults the number of results to skip\n    function getMarketInfo(\n        IRCMarket.Mode _mode,\n        uint256 _state,\n        uint256 _skipResults\n    )\n        external\n        view\n        returns (\n            address[] memory,\n            string[] memory,\n            string[] memory,\n            uint256[] memory\n        )\n    {\n        uint256 _marketIndex = marketAddresses[_mode].length;\n        uint256 _resultNumber = 0;\n        address[] memory _marketAddresses = new address[](marketInfoResults);\n        string[] memory _ipfsHashes = new string[](marketInfoResults);\n        uint256[] memory _potSizes = new uint256[](marketInfoResults);\n        string[] memory _slugs = new string[](marketInfoResults);\n        while (_resultNumber < marketInfoResults && _marketIndex > 1) {\n            _marketIndex--;\n            address _market = marketAddresses[_mode][_marketIndex];\n            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {\n                if (_resultNumber < _skipResults) {\n                    _resultNumber++;\n                } else {\n                    _marketAddresses[_resultNumber] = _market;\n                    _ipfsHashes[_resultNumber] = ipfsHash[_market];\n                    _slugs[_resultNumber] = addressToSlug[_market];\n                    _potSizes[_resultNumber] = IRCMarket(_market)\n                        .totalRentCollected();\n                    _resultNumber++;\n                }\n            }\n        }\n        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    modifier onlyUberOwner() {\n        require(\n            treasury.checkPermission(UBER_OWNER, msgSender()),\n            \"Not approved\"\n        );\n        _;\n    }\n    modifier onlyOwner() {\n        require(treasury.checkPermission(OWNER, msgSender()), \"Not approved\");\n        _;\n    }\n    modifier onlyGovernors() {\n        require(\n            treasury.checkPermission(GOVERNOR, msgSender()),\n            \"Not approved\"\n        );\n        _;\n    }\n    modifier onlyMarkets() {\n        require(treasury.checkPermission(MARKET, msgSender()), \"Not approved\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n    // Min price increase & pot distribution emitted by Market.\n    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUCTOR - PUBLIC \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice update stakeholder payouts\n    /// @dev in MegaBip (so 1000 = 100%)\n    /// @param _artistCut The artist that designed the card\n    /// @param _winnerCut Extra cut for the longest owner\n    /// @param _creatorCut The creator of the market\n    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts\n    /// @param _cardAffiliateCut An affiliate cur for specific cards\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) public override onlyOwner {\n        require(\n            _artistCut +\n                _winnerCut +\n                _creatorCut +\n                _affiliateCut +\n                _cardAffiliateCut <=\n                PER_MILLE,\n            \"Cuts too big\"\n        );\n        potDistribution[0] = _artistCut;\n        potDistribution[1] = _winnerCut;\n        potDistribution[2] = _creatorCut;\n        potDistribution[3] = _affiliateCut;\n        potDistribution[4] = _cardAffiliateCut;\n    }\n\n    /// @notice how much above the current price a user must bid, in %\n    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease)\n        public\n        override\n        onlyOwner\n    {\n        minimumPriceIncreasePercent = _percentIncrease;\n    }\n\n    /// @notice how many NFTs will be awarded to the leaderboard\n    /// @param _nftsToAward the number of NFTs to award\n    function setNumberOfNFTsToAward(uint256 _nftsToAward)\n        public\n        override\n        onlyOwner\n    {\n        nftsToAward = _nftsToAward;\n    }\n\n    /// @notice A limit to the number of NFTs to mint per market\n    /// @dev to avoid gas limits\n    /// @param _cardLimit the limit to set\n    function setCardLimit(uint256 _cardLimit) public override onlyOwner {\n        cardLimit = _cardLimit;\n    }\n\n    /// @notice A limit to the number of rent collections per transaction\n    /// @dev to avoid gas limits\n    /// @param _rentLimit the limit to set\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        public\n        override\n        onlyOwner\n    {\n        maxRentIterations = _rentLimit;\n        maxRentIterationsToLockMarket = _rentLimitLocking;\n    }\n\n    /// @notice set the address of the reality.eth contracts\n    /// @param _newAddress the address to set\n    function setRealitioAddress(address _newAddress) public override onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @notice address of the arbitrator, in case of continued disputes on reality.eth\n    /// @param _newAddress the address to set\n    function setArbitrator(address _newAddress) public override onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        arbitrator = _newAddress;\n    }\n\n    /// @notice set how long reality.eth waits for disputes before finalising\n    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs\n    function setTimeout(uint32 _newTimeout) public override onlyOwner {\n        // event is emitted from the Oracle when the question is asked\n        timeout = _newTimeout;\n    }\n\n    function setMarketPausedDefaultState(bool _state)\n        external\n        override\n        onlyOwner\n    {\n        marketPausedDefaultState = _state;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice whether or not only governors can create the market\n    function changeMarketCreationGovernorsOnly() external override onlyOwner {\n        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;\n    }\n\n    /// @notice whether or not anyone can be an artist\n    function changeApprovedArtistsOnly() external override onlyOwner {\n        approvedArtistsOnly = !approvedArtistsOnly;\n    }\n\n    /// @notice whether or not anyone can be an affiliate\n    function changeApprovedAffilliatesOnly() external override onlyOwner {\n        approvedAffiliatesOnly = !approvedAffiliatesOnly;\n    }\n\n    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot\n    /// @param _amount the sponsorship required in wei\n    function setSponsorshipRequired(uint256 _amount)\n        external\n        override\n        onlyOwner\n    {\n        sponsorshipRequired = _amount;\n    }\n\n    /// @notice market opening time must be at least this many seconds in the future\n    /// @param _newAdvancedWarning the warning time to set in seconds\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external override onlyOwner {\n        advancedWarning = _newAdvancedWarning;\n        minimumDuration = _newMinimumDuration;\n        maximumDuration = _newMaximumDuration;\n        emit LogMarketTimeRestrictions(\n            _newAdvancedWarning,\n            _newMinimumDuration,\n            _newMaximumDuration\n        );\n    }\n\n    /// @notice Allow the owner to update a token URI.\n    /// @param _market the market address the token belongs to\n    /// @param _cardId the index 0 card id of the token to change\n    /// @param _newTokenURI the new URI to set\n    /// @param _newCopyTokenURI the new URI to set for the copy\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external override onlyOwner {\n        IRCMarket.Mode _mode = IRCMarket(_market).mode();\n        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();\n        tokenURIs[_market][_cardId] = _newTokenURI;\n        tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI;\n        string[] memory _tokenURIs = new string[](_numberOfCards);\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            _tokenURIs[i] = tokenURIs[_market][i];\n        }\n        uint32[] memory _timestamps = new uint32[](3);\n        _timestamps[0] = IRCMarket(_market).marketOpeningTime();\n        _timestamps[1] = IRCMarket(_market).marketLockingTime();\n        _timestamps[2] = IRCMarket(_market).oracleResolutionTime();\n\n        // reuse this event so the frontend can pickup the change\n        emit LogMarketCreated2(\n            _market,\n            IRCMarket.Mode(_mode),\n            _tokenURIs,\n            ipfsHash[_market],\n            _timestamps,\n            nfthub.totalSupply()\n        );\n    }\n\n    /// @notice change how many results are returned from getMarketInfo\n    /// @dev would be better to pass this as a parameter in getMarketInfo\n    /// @dev .. however we are limited because of stack too deep errors\n    function setMarketInfoResults(uint256 _results)\n        external\n        override\n        onlyOwner\n    {\n        // no event needed, only used for the backup view mode\n        marketInfoResults = _results;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - GOVERNORS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyGovernors modifier\n\n    /// @notice markets are default hidden from the interface, this reveals them\n    /// @param _market the market address to change approval for\n    function changeMarketApproval(address _market)\n        external\n        override\n        onlyGovernors\n    {\n        require(_market != address(0), \"Must set Address\");\n        // check it's an RC contract\n        require(treasury.checkPermission(MARKET, _market), \"Not Market\");\n        isMarketApproved[_market] = !isMarketApproved[_market];\n        // governors shouldn't have the ability to pause a market, only un-pause.\n        // .. if a governor accidentally approves a market they should seek\n        // .. assistance from the owner to decide if it should be paused.\n        treasury.unPauseMarket(_market);\n        // the market will however be hidden from the UI in the meantime\n        emit LogMarketApproved(_market, isMarketApproved[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551   GOVERNANCE - Role management  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev the following functions could all be performed directly on the treasury\n    /// @dev .. they are here as an interim solution to give governors an easy way\n    /// @dev .. to change all their parameters via the block explorer.\n\n    /// @notice Grant the artist role to an address\n    /// @param _newArtist the address to grant the role of artist\n    function addArtist(address _newArtist) external override onlyGovernors {\n        treasury.grantRole(ARTIST, _newArtist);\n    }\n\n    /// @notice Remove the artist role from an address\n    /// @param _oldArtist the address to revoke the role of artist\n    function removeArtist(address _oldArtist) external override onlyGovernors {\n        treasury.revokeRole(ARTIST, _oldArtist);\n    }\n\n    /// @notice Grant the affiliate role to an address\n    /// @param _newAffiliate the address to grant the role of affiliate\n    function addAffiliate(address _newAffiliate)\n        external\n        override\n        onlyGovernors\n    {\n        treasury.grantRole(AFFILIATE, _newAffiliate);\n    }\n\n    /// @notice Remove the affiliate role from an address\n    /// @param _oldAffiliate the address to revoke the role of affiliate\n    function removeAffiliate(address _oldAffiliate)\n        external\n        override\n        onlyGovernors\n    {\n        treasury.revokeRole(AFFILIATE, _oldAffiliate);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades, this is separated so owner can be\n    /// @dev ..  set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governance functions\n\n    /// @notice change the reference contract for the contract logic\n    /// @param _newAddress the address of the new reference contract to set\n    function setReferenceContractAddress(address _newAddress)\n        external\n        override\n        onlyUberOwner\n    {\n        require(_newAddress != address(0));\n        // check it's an RC contract\n        IRCMarket newContractVariable = IRCMarket(_newAddress);\n        require(newContractVariable.isMarket(), \"Not Market\");\n        // set\n        referenceContractAddress = _newAddress;\n        // increment version\n        referenceContractVersion += 1;\n    }\n\n    /// @notice where the NFTs live\n    /// @param _newAddress the address to set\n    function setNftHubAddress(IRCNftHubL2 _newAddress)\n        external\n        override\n        onlyUberOwner\n    {\n        require(address(_newAddress) != address(0), \"Must set Address\");\n        nfthub = _newAddress;\n    }\n\n    /// @notice set the address of the orderbook contract\n    /// @param _newOrderbook the address to set\n    /// @dev set by the treasury to ensure all contracts use the same orderbook\n    function setOrderbookAddress(IRCOrderbook _newOrderbook) external override {\n        require(\n            treasury.checkPermission(TREASURY, msgSender()),\n            \"Not approved\"\n        );\n        orderbook = _newOrderbook;\n    }\n\n    /// @notice set the address of the leaderboard contract\n    /// @param _newLeaderboard the address to set\n    /// @dev set by the treasury to ensure all contracts use the same leaderboard\n    function setLeaderboardAddress(IRCLeaderboard _newLeaderboard)\n        external\n        override\n    {\n        require(\n            treasury.checkPermission(TREASURY, msgSender()),\n            \"Not approved\"\n        );\n        leaderboard = _newLeaderboard;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         MARKET CREATION         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Creates a new market with the given parameters\n    /// @param _mode 0 = normal, 1 = winner takes all\n    /// @param _ipfsHash the IPFS location of the market metadata\n    /// @param _slug the URL subdomain in the UI\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _tokenURIs location of NFT metadata, originals followed by copies\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliates cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliates cut, if any\n    /// @param _realitioQuestion the details of the event to send to the oracle\n    /// @param _sponsorship amount of sponsorship to create the market with\n    /// @return The address of the new market\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string memory _realitioQuestion,\n        uint256 _sponsorship\n    ) external override returns (address) {\n        address _creator = msgSender();\n\n        // check nfthub has been set\n        require(address(nfthub) != address(0), \"Nfthub not set\");\n\n        // check sponsorship\n        require(\n            _sponsorship >= sponsorshipRequired,\n            \"Insufficient sponsorship\"\n        );\n        treasury.checkSponsorship(_creator, _sponsorship);\n\n        // check the number of NFTs to mint is within limits\n        /// @dev we want different tokenURIs for originals and copies\n        /// @dev ..the copies are appended to the end of the array\n        /// @dev ..so half the array length if the number of tokens.\n        require(\n            (_tokenURIs.length / 2) <= cardLimit,\n            \"Too many tokens to mint\"\n        );\n\n        // check stakeholder addresses\n        // artist\n        if (approvedArtistsOnly) {\n            require(\n                _artistAddress == address(0) ||\n                    treasury.checkPermission(ARTIST, _artistAddress),\n                \"Artist not approved\"\n            );\n        }\n\n        // affiliate\n        require(\n            _cardAffiliateAddresses.length == 0 ||\n                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),\n            \"Card Affiliate Length Error\"\n        );\n        if (approvedAffiliatesOnly) {\n            require(\n                _affiliateAddress == address(0) ||\n                    treasury.checkPermission(AFFILIATE, _affiliateAddress),\n                \"Affiliate not approved\"\n            );\n            // card affiliates\n            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {\n                require(\n                    _cardAffiliateAddresses[i] == address(0) ||\n                        treasury.checkPermission(\n                            CARD_AFFILIATE,\n                            _cardAffiliateAddresses[i]\n                        ),\n                    \"Card affiliate not approved\"\n                );\n            }\n        }\n\n        // check market creator is approved\n        if (marketCreationGovernorsOnly) {\n            require(\n                treasury.checkPermission(GOVERNOR, _creator),\n                \"Not approved\"\n            );\n        }\n\n        _checkTimestamps(_timestamps);\n\n        // create the market and emit the appropriate events\n        // two events to avoid stack too deep error\n        address _newAddress = Clones.clone(referenceContractAddress);\n        emit LogMarketCreated1(\n            _newAddress,\n            address(treasury),\n            address(nfthub),\n            referenceContractVersion\n        );\n        emit LogMarketCreated2(\n            _newAddress,\n            IRCMarket.Mode(_mode),\n            _tokenURIs,\n            _ipfsHash,\n            _timestamps,\n            nfthub.totalSupply()\n        );\n\n        // tell Treasury and NFT hub about new market\n        // before initialize as during initialize the market may call the treasury\n        treasury.addMarket(_newAddress, marketPausedDefaultState);\n        nfthub.addMarket(_newAddress);\n\n        // update internals\n        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);\n        ipfsHash[_newAddress] = _ipfsHash;\n        slugToAddress[_slug] = _newAddress;\n        addressToSlug[_newAddress] = _slug;\n\n        // initialize the market\n        IRCMarket(_newAddress).initialize(\n            IRCMarket.Mode(_mode),\n            _timestamps,\n            (_tokenURIs.length / 2),\n            _artistAddress,\n            _affiliateAddress,\n            _cardAffiliateAddresses,\n            _creator,\n            _realitioQuestion,\n            nftsToAward\n        );\n\n        // store token URIs\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            tokenURIs[_newAddress][i] = _tokenURIs[i];\n        }\n\n        // pay sponsorship, if applicable\n        if (_sponsorship > 0) {\n            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);\n        }\n\n        return _newAddress;\n    }\n\n    function _checkTimestamps(uint32[] memory _timestamps) internal view {\n        // check timestamps\n        require(_timestamps.length == 3, \"Incorrect number of array elements\");\n        // check market opening time\n        if (advancedWarning != 0) {\n            // different statements to give clearer revert messages\n            require(\n                _timestamps[0] >= block.timestamp,\n                \"Market opening time not set\"\n            );\n            require(\n                _timestamps[0] - advancedWarning > block.timestamp,\n                \"Market opens too soon\"\n            );\n        }\n        // check market locking time\n        if (maximumDuration != 0) {\n            require(\n                _timestamps[1] < block.timestamp + maximumDuration,\n                \"Market locks too late\"\n            );\n        }\n        require(\n            _timestamps[0] + minimumDuration < _timestamps[1] &&\n                block.timestamp + minimumDuration < _timestamps[1],\n            \"Market lock must be after opening\"\n        );\n        // check oracle resolution time (no more than 1 week after market locking to get result)\n        require(\n            _timestamps[1] + (1 weeks) > _timestamps[2] &&\n                _timestamps[1] <= _timestamps[2],\n            \"Oracle resolution time error\"\n        );\n    }\n\n    /// @notice Called by the markets to mint the original NFTs\n    /// @param _card the card id to be minted\n    function mintMarketNFT(uint256 _card) external override onlyMarkets {\n        uint256 nftHubMintCount = nfthub.totalSupply();\n        address _market = msgSender();\n        nfthub.mint(_market, nftHubMintCount, tokenURIs[_market][_card]);\n        emit LogMintNFT(_card, _market, nftHubMintCount);\n    }\n\n    /// @notice allows the market to mint a copy of the NFT for users on the leaderboard\n    /// @param _user the user to award the NFT to\n    /// @param _cardId the tokenId to copy\n    function mintCopyOfNFT(address _user, uint256 _cardId)\n        external\n        override\n        onlyMarkets\n    {\n        address _market = msgSender();\n        uint256 _newTokenId = nfthub.totalSupply();\n        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();\n        nfthub.mint(\n            _user,\n            _newTokenId,\n            tokenURIs[_market][(_cardId + _numberOfCards)]\n        );\n        emit LogMintNFTCopy(_cardId, _user, _newTokenId);\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCBridge.sol\";\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {\n    using SafeERC20 for IERC20;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public override orderbook;\n    /// @dev leaderboard instance\n    IRCLeaderboard public override leaderboard;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev the Factory so only the Factory can add new markets\n    IRCFactory public override factory;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public override marketBalance;\n    /// @dev a quick check if a user is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 public override marketBalanceTopup;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    /// @dev intended for beta use only, will be disabled after launch\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n    /// @dev allow markets to be restricted to a certain role\n    mapping(address => bytes32) public marketWhitelist;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent, claim or upgrade any cards for specific market\n    mapping(address => bool) public override marketPaused;\n    /// @dev if true, owner has locked the market pause (Governors are locked out)\n    mapping(address => bool) public override lockMarketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant FACTORY = keccak256(\"FACTORY\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant WHITELIST = keccak256(\"WHITELIST\");\n    bytes32 public constant ARTIST = keccak256(\"ARTIST\");\n    bytes32 public constant AFFILIATE = keccak256(\"AFFILIATE\");\n    bytes32 public constant CARD_AFFILIATE = keccak256(\"CARD_AFFILIATE\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n    event LogWhitelistUser(address user, bool allowed);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        /* setup AccessControl\n\n                         UBER_OWNER\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502           \u2502          \u2502            \u2502         \u2502\n          OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD\n            \u2502           \u2502\n         GOVERNOR     MARKET\n            \u2502\n         WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE\n        */\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(UBER_OWNER, _msgSender());\n        _setupRole(OWNER, _msgSender());\n        _setupRole(GOVERNOR, _msgSender());\n        _setupRole(WHITELIST, _msgSender());\n        _setupRole(TREASURY, address(this));\n        _setRoleAdmin(UBER_OWNER, UBER_OWNER);\n        _setRoleAdmin(OWNER, UBER_OWNER);\n        _setRoleAdmin(FACTORY, UBER_OWNER);\n        _setRoleAdmin(ORDERBOOK, UBER_OWNER);\n        _setRoleAdmin(TREASURY, UBER_OWNER);\n        _setRoleAdmin(GOVERNOR, OWNER);\n        _setRoleAdmin(WHITELIST, GOVERNOR);\n        _setRoleAdmin(ARTIST, GOVERNOR);\n        _setRoleAdmin(AFFILIATE, GOVERNOR);\n        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);\n        _setRoleAdmin(MARKET, FACTORY);\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1_000_000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks() {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyRole(OWNER)\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUCTOR - PUBLIC \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @dev this is only a soft check, it is possible to exceed this limit\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyRole(OWNER)\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyRole(OWNER) {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market\n    function changePauseMarket(address _market, bool _paused)\n        external\n        override\n        onlyRole(OWNER)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        marketPaused[_market] = _paused;\n        lockMarketPaused[_market] = marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it\n    function unPauseMarket(address _market)\n        external\n        override\n        onlyRole(FACTORY)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        require(!lockMarketPaused[_market], \"Owner has paused market\");\n        marketPaused[_market] = false;\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyRole(OWNER) {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add/Remove multiple users to the whitelist\n    /// @param _users an array of users to add or remove\n    /// @param add true to add the users\n    function batchWhitelist(address[] calldata _users, bool add)\n        external\n        override\n        onlyRole(GOVERNOR)\n    {\n        if (add) {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.grantRole(WHITELIST, _users[index]);\n            }\n        } else {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.revokeRole(WHITELIST, _users[index]);\n            }\n        }\n    }\n\n    /// @notice Some markets may be restricted to certain roles,\n    /// @notice This function checks if the user has the role requried for a given market\n    /// @dev Used for the markets to check themselves\n    /// @param _user The user to check\n    function marketWhitelistCheck(address _user)\n        external\n        view\n        override\n        returns (bool)\n    {\n        bytes32 requiredRole = marketWhitelist[msgSender()];\n        if (requiredRole == bytes32(0)) {\n            return true;\n        } else {\n            return hasRole(requiredRole, _user);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governance functions\n\n    function setFactoryAddress(address _newFactory)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newFactory != address(0), \"Must set an address\");\n        // factory is also an OWNER and GOVERNOR to use the proxy functions\n        revokeRole(FACTORY, address(factory));\n        revokeRole(OWNER, address(factory));\n        revokeRole(GOVERNOR, address(factory));\n        factory = IRCFactory(_newFactory);\n        grantRole(FACTORY, address(factory));\n        grantRole(OWNER, address(factory));\n        grantRole(GOVERNOR, address(factory));\n    }\n\n    function setOrderbookAddress(address _newOrderbook)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newOrderbook != address(0), \"Must set an address\");\n        revokeRole(ORDERBOOK, address(orderbook));\n        orderbook = IRCOrderbook(_newOrderbook);\n        grantRole(ORDERBOOK, address(orderbook));\n        factory.setOrderbookAddress(orderbook);\n    }\n\n    function setLeaderboardAddress(address _newLeaderboard)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newLeaderboard != address(0), \"Must set an address\");\n        leaderboard = IRCLeaderboard(_newLeaderboard);\n        factory.setLeaderboardAddress(leaderboard);\n    }\n\n    function setTokenAddress(address _newToken)\n        public\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner\n    function globalExit() external onlyRole(UBER_OWNER) {\n        uint256 _balance = erc20.balanceOf(address(this));\n        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised\n        erc20.safeTransfer(msg.sender, _balance);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        external\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(hasRole(WHITELIST, _user), \"Not in whitelist\");\n        }\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        assessForeclosure(_user);\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // step 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.safeTransfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        // do some cleaning up first, it might help avoid their foreclosure\n        orderbook.removeOldBids(_msgSender);\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            // foreclose user, this is requred to remove them from the orderbook\n            isForeclosed[_msgSender] = true;\n            // remove them from the orderbook\n            orderbook.removeUserFromOrderbook(_msgSender);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount)\n        external\n        override\n        balancedBooks\n    {\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n        marketBalanceTopup += _amount;\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (uint256)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            uint256 discrepancy = _amount - marketBalance;\n            if (discrepancy > marketBalanceTopup) {\n                marketBalanceTopup = 0;\n            } else {\n                marketBalanceTopup -= discrepancy;\n            }\n            _amount = marketBalance;\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n        /// @dev return the amount just incase it was adjusted\n        return _amount;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        assessForeclosure(_user);\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        assessForeclosure(_user);\n    }\n\n    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        address _msgSender = msgSender();\n        require(!lockMarketPaused[_msgSender], \"Market is paused\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.safeTransferFrom(_sponsor, address(this), _amount);\n        marketPot[_msgSender] += _amount;\n        totalMarketPots += _amount;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyRole(MARKET)\n    {\n        // update the last rental time\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        // check if this is their first rental (no previous rental calculation)\n        if (user[_user].lastRentCalc == 0) {\n            // we need to start their clock ticking, update their last rental calculation time\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function addMarket(address _market, bool _paused) external override {\n        require(hasRole(FACTORY, msgSender()), \"Not Authorised\");\n        marketPaused[_market] = _paused;\n        AccessControl.grantRole(MARKET, _market);\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice provides the sum total of a users bids across all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyRole(ORDERBOOK) {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !hasRole(MARKET, _newOwner)\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(\n                    user[_newOwner].lastRentCalc,\n                    _timeOwnershipChanged,\n                    _newPrice\n                );\n\n                // they have enough funds, just collect the extra\n                // we can be sure of this because it was checked they can cover the minimum rental\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                    // send an event for the UI to have a timestamp\n                    emit LogAdjustDeposit(_newOwner, 0, false);\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calculation and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calculates the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestamps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /\n                totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +\n                timeLeftOfDeposit;\n\n            if (\n                foreclosureTimeWithoutNewCard > _timeOfNewBid &&\n                _timeOfNewBid != 0\n            ) {\n                // calculate how long they can own the new card for\n                uint256 _rentDifference = rentOwedBetweenTimestamps(\n                    user[_user].lastRentCalc,\n                    _timeOfNewBid,\n                    totalUserDailyRent\n                );\n                uint256 _depositAtTimeOfNewBid = 0;\n\n                if (user[_user].lastRentCalc < _timeOfNewBid) {\n                    // new bid is after user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit -\n                        _rentDifference;\n                } else {\n                    // new bid is before user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit +\n                        _rentDifference;\n                }\n\n                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *\n                    1 days) / (totalUserDailyRent + _newBid);\n\n                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +\n                    _timeLeftOfDepositWithNewBid;\n                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {\n                    return _foreclosureTimeWithNewCard;\n                } else {\n                    // The user couldn't afford to own the new card up to their last\n                    // .. rent calculation, we can't rewind their rent calculation because\n                    // .. of gas limits (there could be many markets having taken rent).\n                    // Therefore unfortunately we can't give any ownership to this user as\n                    // .. this could mean getting caught in a loop we may not be able to\n                    // .. exit because of gas limits (there could be many users in this\n                    // .. situation and we can't leave any unaccounted for).\n                    // This means we return 0 to signify that the user can't afford this\n                    // .. new ownership.\n                    return 0;\n                }\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            if (_newBid == 0) {\n                // if no rentals they'll foreclose after the heat death of the universe\n                return type(uint256).max;\n            } else {\n                return\n                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);\n            }\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        require(_timeToCollectTo != 0, \"Must set collection time\");\n        require(\n            _timeToCollectTo <= block.timestamp,\n            \"Can't collect future rent\"\n        );\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts = ((_timeToCollectTo -\n                    previousCollectionTime) * uint256(user[_user].deposit)) /\n                    rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepositLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets available balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n\n    /// @notice checks if the user should still be foreclosed\n    function assessForeclosure(address _user) public override {\n        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        } else {\n            isForeclosed[_user] = true;\n            emit LogUserForeclosed(_user, true);\n        }\n    }\n\n    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual\n    function checkPermission(bytes32 role, address account)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return AccessControl.hasRole(role, account);\n    }\n\n    function grantRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.grantRole(_role, account);\n    }\n\n    function grantRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, true);\n        }\n        AccessControl.grantRole(role, account);\n    }\n\n    function revokeRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.revokeRole(_role, account);\n    }\n\n    function revokeRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, false);\n        }\n        AccessControl.revokeRole(role, account);\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRealitio.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCLeaderboard.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\n\n/// @title Reality Cards Market\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    // CONTRACT SETUP\n    uint256 public constant PER_MILLE = 1000; // in MegaBip so (1000 = 100%)\n    /// @dev minimum rental value per day, setting to 24mil means 1 USDC/hour\n    uint256 public constant MIN_RENTAL_VALUE = 24_000_000;\n    /// @dev the number of cards in this market\n    uint256 public override numberOfCards;\n    /// @dev current market state, Closed -> Open -> Locked -> Withdraw\n    States public override state;\n    /// @dev type of event.\n    Mode public override mode;\n    /// @dev so the Factory can check it's a market\n    bool public constant override isMarket = true;\n    /// @dev how many nfts to award to the leaderboard\n    uint256 public override nftsToAward;\n    /// @dev the unique token id for each card\n    uint256[] public tokenIds;\n\n    // CONTRACT VARIABLES\n    IRCTreasury public override treasury;\n    IRCFactory public override factory;\n    IRCNftHubL2 public override nfthub;\n    IRCOrderbook public override orderbook;\n    IRCLeaderboard public override leaderboard;\n    IRealitio public override realitio;\n\n    // PRICE, DEPOSITS, RENT\n    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.\n    mapping(address => uint256) public override rentCollectedPerUser;\n    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout\n    mapping(address => mapping(uint256 => uint256))\n        public\n        override rentCollectedPerUserPerCard;\n    /// @dev an easy way to track the above across all cards\n    uint256 public override totalRentCollected;\n    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)\n    mapping(address => uint256) public override exitedTimestamp;\n\n    // PARAMETERS\n    /// @dev read from the Factory upon market creation, can not be changed for existing market\n    /// @dev the minimum required price increase in %\n    uint256 public override minimumPriceIncreasePercent;\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev maximum number of times to calculate rent in one transaction\n    uint256 public override maxRentIterations;\n    /// @dev maximum number of times to calculate rent and continue locking the market\n    uint256 public maxRentIterationsToLockMarket;\n\n    struct Card {\n        /// @dev how many seconds each user has held each card for, for determining winnings\n        mapping(address => uint256) timeHeld;\n        /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld\n        uint256 totalTimeHeld;\n        /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.\n        uint256 timeLastCollected;\n        /// @dev to track who has owned it the most (for giving NFT to winner)\n        address longestOwner;\n        /// @dev to track the card timeHeldLimit for the current owner\n        uint256 cardTimeLimit;\n        /// @dev card price in wei\n        uint256 cardPrice;\n        /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout\n        uint256 rentCollectedPerCard;\n        /// @dev prevent users claiming twice\n        mapping(address => bool) userAlreadyClaimed; // cardID // user // bool\n        /// @dev has this card affiliate been paid\n        bool cardAffiliatePaid;\n    }\n    mapping(uint256 => Card) public card;\n\n    // TIMESTAMPS\n    /// @dev when the market opens\n    uint32 public override marketOpeningTime;\n    /// @dev when the market locks\n    uint32 public override marketLockingTime;\n    /// @dev when the question can be answered on realitio\n    uint32 public override oracleResolutionTime;\n\n    // PAYOUT VARIABLES\n    /// @dev the winning card if known, otherwise type(uint256).max\n    uint256 public override winningOutcome;\n    /// @dev prevent users withdrawing twice\n    mapping(address => bool) public override userAlreadyWithdrawn;\n    /// @dev the artist\n    address public override artistAddress;\n    uint256 public override artistCut;\n    bool public override artistPaid;\n    /// @dev the affiliate\n    address public override affiliateAddress;\n    uint256 public override affiliateCut;\n    bool public override affiliatePaid;\n    /// @dev the winner\n    uint256 public override winnerCut;\n    /// @dev the market creator\n    address public override marketCreatorAddress;\n    uint256 public override creatorCut;\n    bool public override creatorPaid;\n    /// @dev card specific recipients\n    address[] public override cardAffiliateAddresses;\n    uint256 public override cardAffiliateCut;\n    /// @dev keeps track of which card is next to complete the\n    /// @dev .. accounting for when locking the market\n    uint256 public override cardAccountingIndex;\n    /// @dev has the market locking accounting been completed yet\n    bool public override accountingComplete;\n\n    // ORACLE VARIABLES\n    bytes32 public override questionId;\n    address public override arbitrator;\n    uint32 public override timeout; // the time allowed for the answer to be corrected\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);\n    event LogRentCollection(\n        uint256 rentCollected,\n        uint256 indexed newTimeHeld,\n        uint256 indexed cardId,\n        address indexed owner\n    );\n    event LogContractLocked(bool indexed didTheEventFinish);\n    event LogWinnerKnown(uint256 indexed winningOutcome);\n    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);\n    event LogStakeholderPaid(\n        address indexed paidTo,\n        uint256 indexed amountPaid\n    );\n    event LogRentReturned(\n        address indexed returnedTo,\n        uint256 indexed amountReturned\n    );\n    event LogStateChange(uint256 indexed newState);\n    event LogUpdateTimeHeldLimit(\n        address indexed owner,\n        uint256 newLimit,\n        uint256 cardId\n    );\n    event LogSponsor(address indexed sponsor, uint256 indexed amount);\n    event LogPayoutDetails(\n        address indexed artistAddress,\n        address marketCreatorAddress,\n        address affiliateAddress,\n        address[] cardAffiliateAddresses,\n        uint256 indexed artistCut,\n        uint256 winnerCut,\n        uint256 creatorCut,\n        uint256 affiliateCut,\n        uint256 cardAffiliateCut\n    );\n    event LogSettings(\n        uint256 minRentalDayDivisor,\n        uint256 minimumPriceIncreasePercent,\n        uint256 nftsToAward\n    );\n    event LogLongestOwner(uint256 cardId, address longestOwner);\n    event LogQuestionPostedToOracle(\n        address indexed marketAddress,\n        bytes32 indexed questionId\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _numberOfCards how many Cards in this market\n    /// @param _artistAddress where to send artist's cut, if any (zero address is valid)\n    /// @param _affiliateAddress where to send affiliate's cut, if any (zero address is valid)\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any (zero address is valid)\n    /// @param _marketCreatorAddress where to send market creator's cut, if any (zero address is valid)\n    /// @param _realitioQuestion the question posted to the Oracle\n    function initialize(\n        Mode _mode,\n        uint32[] memory _timestamps,\n        uint256 _numberOfCards,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion,\n        uint256 _nftsToAward\n    ) external override initializer {\n        mode = Mode(_mode);\n\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsMarket\", \"1\");\n\n        // external contract variables:\n        factory = IRCFactory(msgSender());\n        treasury = factory.treasury();\n        nfthub = factory.nfthub();\n        orderbook = factory.orderbook();\n        leaderboard = factory.leaderboard();\n\n        // get adjustable parameters from the factory/treasury\n        uint256[5] memory _potDistribution = factory.getPotDistribution();\n        minRentalDayDivisor = treasury.minRentalDayDivisor();\n        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();\n        maxRentIterations = factory.maxRentIterations();\n        maxRentIterationsToLockMarket = factory.maxRentIterationsToLockMarket();\n\n        // Initialize!\n        winningOutcome = type(uint256).max; // default invalid\n\n        // assign arguments to public variables\n        numberOfCards = _numberOfCards;\n        nftsToAward = _nftsToAward;\n        marketOpeningTime = _timestamps[0];\n        marketLockingTime = _timestamps[1];\n        oracleResolutionTime = _timestamps[2];\n        artistAddress = _artistAddress;\n        marketCreatorAddress = _marketCreatorAddress;\n        affiliateAddress = _affiliateAddress;\n        cardAffiliateAddresses = _cardAffiliateAddresses;\n        artistCut = _potDistribution[0];\n        winnerCut = _potDistribution[1];\n        creatorCut = _potDistribution[2];\n        affiliateCut = _potDistribution[3];\n        cardAffiliateCut = _potDistribution[4];\n        (realitio, arbitrator, timeout) = factory.getOracleSettings();\n        for (uint256 i = 0; i < _numberOfCards; i++) {\n            tokenIds.push(type(uint256).max);\n        }\n\n        // reduce artist cut to zero if zero address set\n        if (_artistAddress == address(0)) {\n            artistCut = 0;\n        }\n\n        // reduce affiliate cut to zero if zero address set\n        if (_affiliateAddress == address(0)) {\n            affiliateCut = 0;\n        }\n\n        // check the validity of card affiliate array.\n        // if not valid, reduce payout to zero\n        if (_cardAffiliateAddresses.length == _numberOfCards) {\n            for (uint256 i = 0; i < _numberOfCards; i++) {\n                if (_cardAffiliateAddresses[i] == address(0)) {\n                    cardAffiliateCut = 0;\n                    break;\n                }\n            }\n        } else {\n            cardAffiliateCut = 0;\n        }\n\n        // if winner takes all mode, set winnerCut to max\n        if (_mode == Mode.WINNER_TAKES_ALL) {\n            winnerCut =\n                (((uint256(PER_MILLE) - artistCut) - creatorCut) -\n                    affiliateCut) -\n                cardAffiliateCut;\n        }\n\n        // post question to Oracle\n        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);\n\n        // move to OPEN immediately if market opening time in the past\n        if (marketOpeningTime <= block.timestamp) {\n            _incrementState();\n        }\n\n        emit LogPayoutDetails(\n            _artistAddress,\n            _marketCreatorAddress,\n            _affiliateAddress,\n            cardAffiliateAddresses,\n            artistCut,\n            winnerCut,\n            creatorCut,\n            affiliateCut,\n            cardAffiliateCut\n        );\n        emit LogSettings(\n            minRentalDayDivisor,\n            minimumPriceIncreasePercent,\n            nftsToAward\n        );\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            MODIFIERS            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice automatically opens market if appropriate\n    modifier autoUnlock() {\n        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {\n            _incrementState();\n        }\n        _;\n    }\n\n    /// @notice automatically locks market if appropriate\n    modifier autoLock() {\n        if (marketLockingTime <= block.timestamp) {\n            lockMarket();\n        }\n        _;\n    }\n\n    /// @dev can only be called by Card owners\n    modifier onlyTokenOwner(uint256 _token) {\n        require(msgSender() == ownerOf(_token), \"Not owner\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     NFT HUB CONTRACT CALLS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice gets the owner of the NFT via their Card Id\n    function ownerOf(uint256 _cardId) public view override returns (address) {\n        require(_cardId < numberOfCards, \"Card does not exist\");\n        if (tokenExists(_cardId)) {\n            uint256 _tokenId = getTokenId(_cardId);\n            return nfthub.ownerOf(_tokenId);\n        } else {\n            return address(this);\n        }\n    }\n\n    /// @notice transfer ERC 721 between users\n    function _transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId\n    ) internal {\n        require(\n            _from != address(0) && _to != address(0),\n            \"Cannot send to/from zero address\"\n        );\n        uint256 _tokenId = getTokenId(_cardId);\n\n        nfthub.transferNft(_from, _to, _tokenId);\n        emit LogNewOwner(_cardId, _to);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called externally by Orderbook\n    function transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external override {\n        require(msgSender() == address(orderbook), \"Not orderbook\");\n        _checkState(States.OPEN);\n        if (_to != _from) {\n            _transferCard(_from, _to, _cardId);\n        }\n        card[_cardId].cardTimeLimit = _timeLimit;\n        card[_cardId].cardPrice = _price;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        ORACLE FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev called within initializer only\n    function _postQuestionToOracle(\n        string calldata _question,\n        uint32 _oracleResolutionTime\n    ) internal {\n        uint256 templateId = 2; //template 2 works for all RealityCards questions\n        uint256 nonce = 0; // We don't need to ask it again, always use 0\n        bytes32 questionHash = keccak256(\n            abi.encodePacked(templateId, _oracleResolutionTime, _question)\n        );\n        questionId = keccak256(\n            abi.encodePacked(\n                questionHash,\n                arbitrator,\n                timeout,\n                address(this),\n                nonce\n            )\n        );\n        if (realitio.getContentHash(questionId) != questionHash) {\n            // check if our questionHash matches an existing questionId\n            // otherwise ask the question.\n            questionId = realitio.askQuestion(\n                templateId,\n                _question,\n                arbitrator,\n                timeout,\n                _oracleResolutionTime,\n                nonce\n            );\n        }\n        emit LogQuestionPostedToOracle(address(this), questionId);\n    }\n\n    /// @notice has the oracle finalised\n    function isFinalized() public view override returns (bool) {\n        bool _isFinalized = realitio.isFinalized(questionId);\n        return _isFinalized;\n    }\n\n    /// @dev sets the winning outcome\n    /// @dev market.setWinner() will revert if done twice, because wrong state\n    function getWinnerFromOracle() external override {\n        require(isFinalized(), \"Oracle not finalised\");\n        // check market state to prevent market closing early\n        require(marketLockingTime <= block.timestamp, \"Market not finished\");\n        bytes32 _winningOutcome = realitio.resultFor(questionId);\n        // call the market\n        setWinner(uint256(_winningOutcome));\n    }\n\n    /// @dev admin override of the oracle\n    function setAmicableResolution(uint256 _winningOutcome) external override {\n        require(\n            treasury.checkPermission(keccak256(\"OWNER\"), msgSender()),\n            \"Not authorised\"\n        );\n        setWinner(_winningOutcome);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551  MARKET RESOLUTION FUNCTIONS    \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Checks whether the competition has ended, if so moves to LOCKED state\n    /// @notice May require multiple calls as all accounting must be completed before\n    /// @notice the market should be locked.\n    /// @dev can be called by anyone\n    /// @dev public because called within autoLock modifier & setWinner\n    function lockMarket() public override {\n        _checkState(States.OPEN);\n        require(\n            uint256(marketLockingTime) <= block.timestamp,\n            \"Market has not finished\"\n        );\n\n        bool cardAccountingComplete = false;\n        uint256 rentIterationCounter = 0;\n        // do a final rent collection before the contract is locked down\n        while (cardAccountingIndex < numberOfCards && !accountingComplete) {\n            (cardAccountingComplete, rentIterationCounter) = _collectRent(\n                cardAccountingIndex,\n                rentIterationCounter\n            );\n            if (cardAccountingComplete) {\n                cardAccountingComplete = false;\n                cardAccountingIndex++;\n            }\n            if (cardAccountingIndex == numberOfCards) {\n                accountingComplete = true;\n                break;\n            }\n            if (rentIterationCounter >= maxRentIterations) {\n                break;\n            }\n        }\n        // check the accounting is complete but only continue if we haven't used much gas so far\n        /// @dev using gasleft() would be nice, but it causes problems with tx gas estimations\n        if (\n            accountingComplete &&\n            rentIterationCounter < maxRentIterationsToLockMarket\n        ) {\n            // and check that the orderbook has shut the market\n            if (orderbook.closeMarket()) {\n                // now lock the market\n                _incrementState();\n\n                for (uint256 i = 0; i < numberOfCards; i++) {\n                    if (tokenExists(i)) {\n                        // bring the cards back to the market so the winners get the satisfaction of claiming them\n                        _transferCard(ownerOf(i), address(this), i);\n                    }\n                    emit LogLongestOwner(i, card[i].longestOwner);\n                }\n                emit LogContractLocked(true);\n            }\n        }\n    }\n\n    /// @notice called by getWinnerFromOracle, sets the winner\n    /// @param _winningOutcome the index of the winning card\n    function setWinner(uint256 _winningOutcome) internal {\n        if (state == States.OPEN) {\n            // change the locking time to allow lockMarket to lock\n            /// @dev implementing our own SafeCast as this is the only place we need it\n            uint256 _blockTimestamp = uint32(block.timestamp);\n            require(_blockTimestamp <= type(uint32).max, \"Overflow\");\n            marketLockingTime = uint32(_blockTimestamp);\n            lockMarket();\n        }\n        if (state == States.LOCKED) {\n            // get the winner. This will revert if answer is not resolved.\n            winningOutcome = _winningOutcome;\n            _incrementState();\n            emit LogWinnerKnown(winningOutcome);\n        }\n    }\n\n    /// @notice pays out winnings, or returns funds\n    function withdraw() external override {\n        _checkState(States.WITHDRAW);\n        require(!userAlreadyWithdrawn[msgSender()], \"Already withdrawn\");\n        userAlreadyWithdrawn[msgSender()] = true;\n        if (card[winningOutcome].totalTimeHeld > 0) {\n            _payoutWinnings();\n        } else {\n            _returnRent();\n        }\n    }\n\n    /// @notice the longest owner of each NFT gets to keep it\n    /// @notice users on the leaderboard can make a copy of it\n    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known\n    /// @param _card the id of the card, the index\n    function claimCard(uint256 _card) external override {\n        _checkNotState(States.CLOSED);\n        _checkNotState(States.OPEN);\n        require(\n            !treasury.marketPaused(address(this)) && !treasury.globalPause(),\n            \"Market is Paused\"\n        );\n        address _user = msgSender();\n        require(!card[_card].userAlreadyClaimed[_user], \"Already claimed\");\n        card[_card].userAlreadyClaimed[_user] = true;\n        if (_user == card[_card].longestOwner) {\n            _transferCard(ownerOf(_card), card[_card].longestOwner, _card);\n        } else {\n            leaderboard.claimNFT(_user, _card);\n            factory.mintCopyOfNFT(_user, _card);\n        }\n    }\n\n    /// @notice pays winnings\n    function _payoutWinnings() internal {\n        uint256 _winningsToTransfer = 0;\n        uint256 _remainingCut = ((((uint256(PER_MILLE) - artistCut) -\n            affiliateCut) - cardAffiliateCut) - winnerCut) - creatorCut;\n        // calculate longest owner's extra winnings, if relevant\n        if (card[winningOutcome].longestOwner == msgSender() && winnerCut > 0) {\n            _winningsToTransfer =\n                (totalRentCollected * winnerCut) /\n                (PER_MILLE);\n        }\n        uint256 _remainingPot = 0;\n        if (mode == Mode.SAFE_MODE) {\n            // return all rent paid on winning card\n            _remainingPot =\n                ((totalRentCollected -\n                    card[winningOutcome].rentCollectedPerCard) *\n                    _remainingCut) /\n                PER_MILLE;\n            _winningsToTransfer +=\n                (rentCollectedPerUserPerCard[msgSender()][winningOutcome] *\n                    _remainingCut) /\n                PER_MILLE;\n        } else {\n            // calculate normal winnings, if any\n            _remainingPot = (totalRentCollected * _remainingCut) / (PER_MILLE);\n        }\n        uint256 _winnersTimeHeld = card[winningOutcome].timeHeld[msgSender()];\n        uint256 _numerator = _remainingPot * _winnersTimeHeld;\n        _winningsToTransfer =\n            _winningsToTransfer +\n            (_numerator / card[winningOutcome].totalTimeHeld);\n        require(_winningsToTransfer > 0, \"Not a winner\");\n        _payout(msgSender(), _winningsToTransfer);\n        emit LogWinningsPaid(msgSender(), _winningsToTransfer);\n    }\n\n    /// @notice returns all funds to users in case of invalid outcome\n    function _returnRent() internal {\n        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)\n        uint256 _remainingCut = ((uint256(PER_MILLE) - artistCut) -\n            affiliateCut) - cardAffiliateCut;\n        uint256 _rentCollected = rentCollectedPerUser[msgSender()];\n        require(_rentCollected > 0, \"Paid no rent\");\n        uint256 _rentCollectedAdjusted = (_rentCollected * _remainingCut) /\n            (PER_MILLE);\n        _payout(msgSender(), _rentCollectedAdjusted);\n        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);\n    }\n\n    /// @notice all payouts happen through here\n    function _payout(address _recipient, uint256 _amount) internal {\n        treasury.payout(_recipient, _amount);\n    }\n\n    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)\n    /// @dev they are not called within setWinner() because of the risk of an\n    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings\n    /// @dev [hangover from when ether was native currency, keeping in case we return to this]\n\n    /// @notice pay artist\n    function payArtist() external override {\n        _checkState(States.WITHDRAW);\n        require(!artistPaid, \"Artist already paid\");\n        artistPaid = true;\n        _processStakeholderPayment(artistCut, artistAddress);\n    }\n\n    /// @notice pay market creator\n    function payMarketCreator() external override {\n        _checkState(States.WITHDRAW);\n        require(card[winningOutcome].totalTimeHeld > 0, \"No winner\");\n        require(!creatorPaid, \"Creator already paid\");\n        creatorPaid = true;\n        _processStakeholderPayment(creatorCut, marketCreatorAddress);\n    }\n\n    /// @notice pay affiliate\n    function payAffiliate() external override {\n        _checkState(States.WITHDRAW);\n        require(!affiliatePaid, \"Affiliate already paid\");\n        affiliatePaid = true;\n        _processStakeholderPayment(affiliateCut, affiliateAddress);\n    }\n\n    /// @notice pay card affiliate\n    /// @dev does not call _processStakeholderPayment because it works differently\n    function payCardAffiliate(uint256 _card) external override {\n        _checkState(States.WITHDRAW);\n        require(!card[_card].cardAffiliatePaid, \"Card affiliate already paid\");\n        card[_card].cardAffiliatePaid = true;\n        uint256 _cardAffiliatePayment = (card[_card].rentCollectedPerCard *\n            cardAffiliateCut) / (PER_MILLE);\n        if (_cardAffiliatePayment > 0) {\n            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);\n            emit LogStakeholderPaid(\n                cardAffiliateAddresses[_card],\n                _cardAffiliatePayment\n            );\n        }\n    }\n\n    function _processStakeholderPayment(uint256 _cut, address _recipient)\n        internal\n    {\n        if (_cut > 0) {\n            uint256 _payment = (totalRentCollected * _cut) / (PER_MILLE);\n            _payout(_recipient, _payment);\n            emit LogStakeholderPaid(_recipient, _payment);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             EXTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev basically functions that have _checkState(States.OPEN) on first line\n\n    /// @notice collects rent a specifc card\n    function collectRent(uint256 _cardId) external override returns (bool) {\n        _checkState(States.OPEN);\n        bool _success;\n        (_success, ) = _collectRent(_cardId, 0);\n        if (_success) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice rent every Card at the minimum price\n    /// @param _maxSumOfPrices a limit to the sum of the bids to place\n    function rentAllCards(uint256 _maxSumOfPrices) external override {\n        _checkState(States.OPEN);\n        // check that not being front run\n        uint256 _actualSumOfPrices = 0;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (card[i].cardPrice == 0) {\n                _actualSumOfPrices += MIN_RENTAL_VALUE;\n            } else {\n                _actualSumOfPrices +=\n                    (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) /\n                    100;\n            }\n        }\n        require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");\n\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != msgSender()) {\n                uint256 _newPrice;\n                if (card[i].cardPrice > 0) {\n                    _newPrice =\n                        (card[i].cardPrice *\n                            (minimumPriceIncreasePercent + 100)) /\n                        100;\n                } else {\n                    _newPrice = MIN_RENTAL_VALUE;\n                }\n                newRental(_newPrice, 0, address(0), i);\n            }\n        }\n    }\n\n    /// @notice to rent a Card\n    /// @param _newPrice the price to rent the card for\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _startingPosition where to start looking to insert the bid into the orderbook\n    /// @param _card the index of the card to update\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) public override autoUnlock autoLock {\n        // if the market isn't open then don't do anything else, not reverting\n        // .. will allow autoLock to process the accounting to lock the market\n        if (state == States.OPEN) {\n            require(_newPrice >= MIN_RENTAL_VALUE, \"Price below min\");\n            require(_card < numberOfCards, \"Card does not exist\");\n\n            // if the NFT hasn't been minted, we should probably do that\n            if (!tokenExists(_card)) {\n                tokenIds[_card] = nfthub.totalSupply();\n                factory.mintMarketNFT(_card);\n            }\n\n            address _user = msgSender();\n\n            // prevent re-renting, this limits (but doesn't eliminate) a frontrunning attack\n            require(\n                exitedTimestamp[_user] != block.timestamp,\n                \"Cannot lose and re-rent in same block\"\n            );\n            require(\n                !treasury.marketPaused(address(this)) &&\n                    !treasury.globalPause(),\n                \"Rentals are disabled\"\n            );\n            // restrict certain markets to specific whitelists\n            require(\n                treasury.marketWhitelistCheck(_user),\n                \"Not approved for this market\"\n            );\n\n            // if the user is foreclosed then delete some old bids\n            // .. this could remove their foreclosure\n            if (treasury.isForeclosed(_user)) {\n                orderbook.removeUserFromOrderbook(_user);\n            }\n            require(\n                !treasury.isForeclosed(_user),\n                \"Can't rent while foreclosed\"\n            );\n            if (ownerOf(_card) == _user) {\n                // the owner may only increase by more than X% or reduce their price\n                uint256 _requiredPrice = (card[_card].cardPrice *\n                    (minimumPriceIncreasePercent + 100)) / (100);\n                require(\n                    _newPrice >= _requiredPrice ||\n                        _newPrice < card[_card].cardPrice,\n                    \"Invalid price\"\n                );\n            }\n\n            // do some cleaning up before we collect rent or check their bidRate\n            orderbook.removeOldBids(_user);\n\n            /// @dev ignore the return value and let the user post the bid for the sake of UX\n            _collectRent(_card, 0);\n\n            // check sufficient deposit\n            uint256 _userTotalBidRate = (treasury.userTotalBids(_user) -\n                orderbook.getBidValue(_user, _card)) + _newPrice;\n            require(\n                treasury.userDeposit(_user) >=\n                    _userTotalBidRate / minRentalDayDivisor,\n                \"Insufficient deposit\"\n            );\n\n            _checkTimeHeldLimit(_timeHeldLimit);\n\n            orderbook.addBidToOrderbook(\n                _user,\n                _card,\n                _newPrice,\n                _timeHeldLimit,\n                _startingPosition\n            );\n\n            treasury.updateLastRentalTime(_user);\n        }\n    }\n\n    /// @notice to change your timeHeldLimit without having to re-rent\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _card the index of the card to update\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external\n        override\n    {\n        _checkState(States.OPEN);\n        address _user = msgSender();\n        bool rentCollected;\n        (rentCollected, ) = _collectRent(_card, 0);\n        if (rentCollected) {\n            _checkTimeHeldLimit(_timeHeldLimit);\n\n            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);\n\n            if (ownerOf(_card) == _user) {\n                card[_card].cardTimeLimit = _timeHeldLimit;\n            }\n\n            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);\n        }\n    }\n\n    /// @notice stop renting all cards\n    function exitAll() external override {\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            exit(i);\n        }\n    }\n\n    /// @notice stop renting a card and/or remove from orderbook\n    /// @dev public because called by exitAll()\n    /// @dev doesn't need to be current owner so user can prevent ownership returning to them\n    /// @dev does not apply minimum rental duration, because it returns ownership to the next user\n    /// @dev doesn't revert if non-existant bid because user might be trying to exitAll()\n    /// @param _card The card index to exit\n    function exit(uint256 _card) public override {\n        _checkState(States.OPEN);\n        address _msgSender = msgSender();\n\n        // collectRent first\n        /// @dev ignore the return value and let the user exit the bid for the sake of UX\n        _collectRent(_card, 0);\n\n        if (ownerOf(_card) == _msgSender) {\n            // block frontrunning attack\n            exitedTimestamp[_msgSender] = block.timestamp;\n\n            // if current owner, find a new one\n            orderbook.findNewOwner(_card, block.timestamp);\n            assert(!orderbook.bidExists(_msgSender, address(this), _card));\n        } else {\n            // if not owner, just delete from orderbook\n            if (orderbook.bidExists(_msgSender, address(this), _card)) {\n                // block frontrunning attack\n                exitedTimestamp[_msgSender] = block.timestamp;\n\n                orderbook.removeBidFromOrderbook(_msgSender, _card);\n            }\n        }\n    }\n\n    /// @notice ability to add liquidity to the pot without being able to win.\n    /// @dev called by user, sponsor is msgSender\n    function sponsor(uint256 _amount) external override {\n        address _creator = msgSender();\n        _sponsor(_creator, _amount);\n    }\n\n    /// @notice ability to add liquidity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        address _msgSender = msgSender();\n        if (_msgSender != address(factory)) {\n            _sponsorAddress = _msgSender;\n        }\n        _sponsor(_sponsorAddress, _amount);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             INTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev actually processes the sponsorship\n    function _sponsor(address _sponsorAddress, uint256 _amount) internal {\n        _checkNotState(States.LOCKED);\n        _checkNotState(States.WITHDRAW);\n        require(_amount > 0, \"Must send something\");\n        // send tokens to the Treasury\n        treasury.sponsor(_sponsorAddress, _amount);\n        totalRentCollected = totalRentCollected + _amount;\n        // just so user can get it back if invalid outcome\n        rentCollectedPerUser[_sponsorAddress] =\n            rentCollectedPerUser[_sponsorAddress] +\n            _amount;\n        // allocate equally to each card, in case card specific affiliates\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            card[i].rentCollectedPerCard =\n                card[i].rentCollectedPerCard +\n                (_amount / numberOfCards);\n        }\n        emit LogSponsor(_sponsorAddress, _amount);\n    }\n\n    function _checkTimeHeldLimit(uint256 _timeHeldLimit) internal view {\n        if (_timeHeldLimit != 0) {\n            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;\n            require(_timeHeldLimit >= _minRentalTime, \"Limit too low\");\n        }\n    }\n\n    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls\n    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit\n    /// @param _card the card id to collect rent for\n    /// @return true if the rent collection was completed, (ownership updated to the current time)\n    function _collectRent(uint256 _card, uint256 _counter)\n        internal\n        returns (bool, uint256)\n    {\n        bool shouldContinue = true;\n        while (_counter < maxRentIterations && shouldContinue) {\n            shouldContinue = _collectRentAction(_card);\n            _counter++;\n        }\n        return (!shouldContinue, _counter);\n    }\n\n    /// @notice collects rent for a specific card\n    /// @dev also calculates and updates how long the current user has held the card for\n    /// @dev is not a problem if called externally, but making internal over public to save gas\n    /// @param _card the card id to collect rent for\n    /// @return true if we should repeat the rent collection\n    function _collectRentAction(uint256 _card) internal returns (bool) {\n        address _user = ownerOf(_card);\n        uint256 _timeOfThisCollection = block.timestamp;\n\n        // don't collect rent beyond the locking time\n        if (marketLockingTime <= block.timestamp) {\n            _timeOfThisCollection = marketLockingTime;\n        }\n\n        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)\n        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)\n        if (\n            _user != address(this) &&\n            card[_card].timeLastCollected < _timeOfThisCollection\n        ) {\n            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet\n            uint256 _timeUserForeclosed = treasury.collectRentUser(\n                _user,\n                _timeOfThisCollection\n            );\n\n            // Calculate the card timeLimitTimestamp\n            uint256 _cardTimeLimitTimestamp = card[_card].timeLastCollected +\n                card[_card].cardTimeLimit;\n\n            // input bools\n            bool _foreclosed = _timeUserForeclosed != 0;\n            bool _limitHit = card[_card].cardTimeLimit != 0 &&\n                _cardTimeLimitTimestamp < block.timestamp;\n\n            // outputs\n            bool _newOwner = false;\n            uint256 _refundTime = 0; // seconds of rent to refund the user\n\n            /* Permutations of the events: Foreclosure and Time limit\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n            \u2502Case       \u25021\u25022\u25023\u25024\u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2524\n            \u2502Foreclosure\u25020\u25020\u25021\u25021\u2502\n            \u2502Time Limit \u25020\u25021\u25020\u25021\u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n            */\n\n            if (!_foreclosed && !_limitHit) {\n                // CASE 1\n                // didn't foreclose AND\n                // didn't hit time limit\n                // THEN simple rent collect, same owner\n                _timeOfThisCollection = _timeOfThisCollection;\n                _newOwner = false;\n                _refundTime = 0;\n            } else if (!_foreclosed && _limitHit) {\n                // CASE 2\n                // didn't foreclose AND\n                // did hit time limit\n                // THEN refund rent between time limit and now\n                _timeOfThisCollection = _cardTimeLimitTimestamp;\n                _newOwner = true;\n                _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n            } else if (_foreclosed && !_limitHit) {\n                // CASE 3\n                // did foreclose AND\n                // didn't hit time limit\n                // THEN rent OK, find new owner\n                _timeOfThisCollection = _timeUserForeclosed;\n                _newOwner = true;\n                _refundTime = 0;\n            } else if (_foreclosed && _limitHit) {\n                // CASE 4\n                // did foreclose AND\n                // did hit time limit\n                // THEN if foreclosed first rent ok, otherwise refund after limit\n                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {\n                    // user foreclosed before time limit\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // time limit hit before user foreclosed\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                }\n            }\n            if (_refundTime != 0) {\n                uint256 _refundAmount = (_refundTime * card[_card].cardPrice) /\n                    1 days;\n                treasury.refundUser(_user, _refundAmount);\n            }\n            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens\n\n            if (_newOwner) {\n                orderbook.findNewOwner(_card, _timeOfThisCollection);\n                return true;\n            }\n        } else {\n            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking\n            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental\n            card[_card].timeLastCollected = _timeOfThisCollection;\n        }\n        return false;\n    }\n\n    /// @dev processes actual rent collection and updates the state\n    function _processRentCollection(\n        address _user,\n        uint256 _card,\n        uint256 _timeOfCollection\n    ) internal {\n        uint256 _rentOwed = (card[_card].cardPrice *\n            (_timeOfCollection - card[_card].timeLastCollected)) / 1 days;\n        uint256 _timeHeldToIncrement = (_timeOfCollection -\n            card[_card].timeLastCollected);\n\n        // if the user has a timeLimit, adjust it as necessary\n        if (card[_card].cardTimeLimit != 0) {\n            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);\n            card[_card].cardTimeLimit -= _timeHeldToIncrement;\n        }\n\n        // update time\n        card[_card].timeHeld[_user] += _timeHeldToIncrement;\n        card[_card].totalTimeHeld += _timeHeldToIncrement;\n        card[_card].timeLastCollected = _timeOfCollection;\n\n        // longest owner tracking\n        if (\n            card[_card].timeHeld[_user] >\n            card[_card].timeHeld[card[_card].longestOwner]\n        ) {\n            card[_card].longestOwner = _user;\n        }\n\n        // update amounts\n        /// @dev get back the actual rent collected, it may be less than owed\n        uint256 _rentCollected = treasury.payRent(_rentOwed);\n        card[_card].rentCollectedPerCard += _rentCollected;\n        rentCollectedPerUserPerCard[_user][_card] += _rentCollected;\n        rentCollectedPerUser[_user] += _rentCollected;\n        totalRentCollected += _rentCollected;\n\n        leaderboard.updateLeaderboard(\n            _user,\n            _card,\n            card[_card].timeHeld[_user]\n        );\n        emit LogRentCollection(\n            _rentCollected,\n            _timeHeldToIncrement,\n            _card,\n            _user\n        );\n    }\n\n    function _checkState(States currentState) internal view {\n        require(state == currentState, \"Incorrect state\");\n    }\n\n    function _checkNotState(States currentState) internal view {\n        require(state != currentState, \"Incorrect state\");\n    }\n\n    /// @dev should only be called thrice\n    function _incrementState() internal {\n        state = States(uint256(state) + 1);\n        emit LogStateChange(uint256(state));\n    }\n\n    /// @notice returns the tokenId (the unique NFT index) given the cardId (the market specific index)\n    /// @param _card the market specific index of the card\n    /// @return _tokenId the unique NFT index\n    function getTokenId(uint256 _card)\n        public\n        view\n        override\n        returns (uint256 _tokenId)\n    {\n        require(tokenExists(_card));\n        return tokenIds[_card];\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       VIEW FUNCTIONS            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Check if the NFT has been minted yet\n    /// @param _card the market specific index of the card\n    /// @return true if the NFT has been minted\n    function tokenExists(uint256 _card) internal view returns (bool) {\n        return tokenIds[_card] != type(uint256).max;\n    }\n\n    /// @dev a simple getter for the time a user has held a given card\n    function timeHeld(uint256 _card, address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return card[_card].timeHeld[_user];\n    }\n\n    /// @dev a simple getter for the time a card last had rent collected\n    function timeLastCollected(uint256 _card)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return card[_card].timeLastCollected;\n    }\n\n    /// @dev a simple getter for the longest owner of a card\n    function longestOwner(uint256 _card)\n        external\n        view\n        override\n        returns (address)\n    {\n        return card[_card].longestOwner;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          BACKUP MODE            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev in the event of failures in the UI we need a simple reliable way to poll\n    /// @dev ..the contracts for relevant info, this view function helps facilitate this.\n\n    /// @dev quick and easy view function to get all market data relevant to the UI\n    function getMarketInfo()\n        external\n        view\n        returns (\n            States,\n            string memory,\n            uint256,\n            uint256,\n            address[] memory,\n            uint256[] memory\n        )\n    {\n        address[] memory _owners = new address[](numberOfCards);\n        uint256[] memory _prices = new uint256[](numberOfCards);\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            _owners[i] = ownerOf(i);\n            _prices[i] = card[i].cardPrice;\n        }\n        return (\n            state,\n            factory.ipfsHash(address(this)),\n            winningOutcome,\n            totalRentCollected,\n            _owners,\n            _prices\n        );\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        CIRCUIT BREAKER          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev in case Oracle never resolves for any reason\n    /// @dev does not set a winner so same as invalid outcome\n    /// @dev market does not need to be locked, just in case lockMarket bugs out\n    function circuitBreaker() external override {\n        require(\n            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),\n            \"Too early\"\n        );\n        state = States.WITHDRAW;\n        orderbook.closeMarket();\n        emit LogStateChange(uint256(state));\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCFactory.sol",
            "RCTreasury.sol",
            "RCMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RCFactory.sol, RCTreasury.sol, RCMarket.sol",
                "Type": "UberOwner has too much power",
                "Description": "The Uber Owner has too much power within the system, making the protocol closer to a centralized prediction market whose rules are determined by the Uber Owner.",
                "Repair": "Limit the permission of the Uber Owner to something more manageable and trustable or use a proxy instead for upgrades to underlying contracts"
            }
        ]
    }
]