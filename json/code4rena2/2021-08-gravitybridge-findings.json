[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "check_for_events function in ethereum_event_watcher.rs",
                "Type": "Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms",
                "Description": "An attacker can trigger a perpetual state of returning the GravityError::EthereumRestError(Web3Error::BadResponse error by deploying ERC20s generated by the public function in Gravity.sol and specifying a large string as the denom, name, or symbol. This will freeze the bridge by disallowing attestations to take place.",
                "Repair": "Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results. Additionally, you could require that validators sign ERC20 creation requests."
            },
            {
                "Location": "ERC20DeployedEvent function in ethereum_events.rs",
                "Type": "Freeze Bridge via Non-UTF8 Token Name/Symbol/Denom",
                "Description": "Manual insertion of non-utf8 characters in a token name will break parsing of logs and will always result in the oracle getting in a loop of failing and early returning an error. This will freeze the bridge by disallowing any attestations to take place.",
                "Repair": "Check in the solidity contract if the name contains valid utf8 strings for denom, symbol and name. Alternatively, you could require that validators sign ERC20 creation requests and perform checks before the transaction is sent."
            },
            {
                "Location": "sendToCosmos function in Gravity.sol",
                "Type": "Incorrect accounting on transfer-on-fee/deflationary tokens in Gravity",
                "Description": "If the transferred token is a transfer-on-fee/deflationary token, the actually received amount could be less than the amount passed as a parameter of the SendToCosmosEvent event, causing the Cosmos side to think more tokens are locked on the Ethereum side.",
                "Repair": "Get the received amount by calculating the difference of token balance (using balanceOf) before and after the transferFrom."
            },
            {
                "Location": "updateValset function in Gravity.sol",
                "Type": "The function updateValset does not have enough sanity checks",
                "Description": "The current set of validators can add a new set without checking that the combined power of all new validators is above the state_powerThreshold, causing the contract to be effectively stuck. Additionally, a large number of validators can cause gas limit issues.",
                "Repair": "Add an on-chain check that the combined power of all new validators is above the state_powerThreshold. Also, add a check that the size of the new validator is less than a certain number. Alternatively, do the updating as a two-step process: the current set of validators proposes a pending set of validators, and the pending set of validators need to do the transition to become the new set of validators, going through the same threshold checks."
            },
            {
                "Location": "SubmitBadSignatureEvidence handler in module/x/gravity/handler.go",
                "Type": "Cannot actually submit evidence",
                "Description": "The SubmitBadSignatureEvidence is not actually registered in the handler and hence no one can actually submit this message, rendering the message useless.",
                "Repair": "Handle the MsgSubmitBadSignatureEvidence in module/x/gravity/handler.go"
            },
            {
                "Location": "eth_oracle_main_loop and check_for_events in eth_oracle_main_loop",
                "Type": "Crash Eth Oracle On Any LogicCallEvent",
                "Description": "A sufficiently large validator set or sufficiently rapid validator update, could cause both the eth_oracle_main_loop and relayer_main_loop to fall into a state of perpetual errors.",
                "Repair": "Implement the method from_log in LogicCallExecutedEvent and handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results."
            },
            {
                "Location": "find_latest_valset in orchestrator/relayer/src/find_latest_valset.rs",
                "Type": "Large Validator Sets/Rapid Validator Set Updates May Freeze the Bridge or Relayers",
                "Description": "A sufficiently large validator set or sufficiently rapid validator update, could cause both the eth_oracle_main_loop and relayer_main_loop to fall into a state of perpetual errors.",
                "Repair": "Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results."
            }
        ]
    }
]