[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Manual insertion of non-utf8 characters in a token name",
                "Type": "Freeze Bridge via Non-UTF8 Token Name/Symbol/Denom",
                "Description": "This will freeze the bridge by disallowing any attestations to take place. This is an extremely low cost way to bring down the network.",
                "Repair": "Check in the solidity contract if the name contains valid utf8 strings for denom, symbol and name. Alternatively, require that validators sign ERC20 creation requests and perform checks before the transaction is sent."
            },
            {
                "Location": "sendToCosmos function of Gravity",
                "Type": "Incorrect accounting on transfer-on-fee/deflationary tokens in  Gravity",
                "Description": "If the transferred token is a transfer-on-fee/deflationary token, the actually received amount could be less than _amount. However, since _amount is passed as a parameter of the SendToCosmosEvent event, the Cosmos side will think more tokens are locked on the Ethereum side.",
                "Repair": "Get the received amount by calculating the difference of token balance (using balanceOf) before and after the transferFrom."
            },
            {
                "Location": "check_for_events function in the Gravity.sol contract",
                "Type": "Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms",
                "Description": "This can be triggered at will and keep the loop in a perpetual state of returning the GravityError::EthereumRestError(Web3Error::BadResponse(            'Failed to get logs!')) error. To force the node into this state, you just have to deploy ERC20s generated by the public function in Gravity.sol and specify a large string as the denom, name, or symbol. This will freeze the bridge by disallowing attestations to take place.",
                "Repair": "Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results. Additionally, you could require that validators sign ERC20 creation requests."
            },
            {
                "Location": "updateValset function",
                "Type": "missing sanity checks",
                "Description": "The updateValset function does not have enough sanity checks, which can cause the contract to be stuck if the combined power of all new validators is below the state_powerThreshold or if the size of the new validator set is too large.",
                "Repair": "Add an on-chain check for the combined power of all new validators and a check for the size of the new validator set. Alternatively, do the updating as a two-step process where the current set of validators proposes a pending set of validators and the pending set of validators need to do the transition to become the new set of validators, going through the same threshold checks."
            },
            {
                "Location": "eth_oracle_main_loop function",
                "Type": "crash",
                "Description": "The get_last_checked_block function in the eth_oracle_main_loop can crash due to an unimplemented method, and the SubmitBadSignatureEvidence message is not registered in the handler, rendering it useless.",
                "Repair": "Implement the LogicCallExecutedEvent::from_log method and handle the MsgSubmitBadSignatureEvidence in module/x/gravity/handler.go"
            },
            {
                "Location": "module/x/gravity/handler.go",
                "Type": "useless message",
                "Description": "The SubmitBadSignatureEvidence message is not registered in the handler, making it impossible to submit and rendering it useless.",
                "Repair": "Handle the MsgSubmitBadSignatureEvidence in module/x/gravity/handler.go"
            },
            {
                "Location": "find_latest_valset function",
                "Type": "rewards manipulation",
                "Description": "A large validator set or rapid validator update can cause the relayers to fall into a state of perpetual errors, allowing an attacker to win all batch, logic, and valset rewards as their node is the only relayer running.",
                "Repair": "Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results."
            },
            {
                "Location": "find_latest_valset function",
                "Type": "bridge freeze",
                "Description": "A sufficiently large validator set or sufficiently rapid validator update can cause the eth_oracle_main_loop and relayer_main_loop to fall into a state of perpetual errors, freezing the bridge by disallowing attestations to take place.",
                "Repair": "Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results."
            }
        ]
    }
]