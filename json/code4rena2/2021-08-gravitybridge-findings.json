[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "[H-01] Cannot actually submit evidence",
                "Location": "SubmitBadSignatureEvidence handler",
                "Type": "Functionality",
                "Description": "The SubmitBadSignatureEvidence is not actually registered in the handler and hence no one can actually submit this message, rendering the message useless. This harms the security model of Gravity since validators have no disincentive to attempt to collude and take over the bridge.",
                "Repair": "Handle the MsgSubmitBadSignatureEvidence in module/x/gravity/handler.go"
            },
            {
                "Name": "[H-02] Freeze Bridge via Non-UTF8 Token Name/Symbol/Denom",
                "Location": "ERC20DeployedEvent parsing code",
                "Type": "Parsing vulnerability",
                "Description": "Manual insertion of non-utf8 characters in a token name will break parsing of logs and will always result in the oracle getting in a loop of failing and early returning an error. The fix is non-trivial and likely requires significant redesign.",
                "Repair": "Check if the name contains valid utf8 strings for denom, symbol and name in the solidity contract or encode the bytes themselves in hex and pass that along"
            },
            {
                "Name": "[H-03] Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms",
                "Location": "Ethereum Oracles watch for events on the Gravity.sol contract on the Ethereum blockchain in the check_for_events function",
                "Type": "Denial of Service (DoS)",
                "Description": "An attacker can trigger a perpetual state of returning the GravityError::EthereumRestError(Web3Error::BadResponse(            \"Failed to get logs!\".to_string())) error by deploying ERC20s generated by the public function in Gravity.sol and specifying a large string as the denom, name, or symbol. This will freeze the bridge by disallowing attestations to take place. This requires a patch to reenable the bridge.",
                "Repair": "Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results. Additionally, you could require that validators sign ERC20 creation requests."
            },
            {
                "Name": "[H-04] Large Validator Sets/Rapid Validator Set Updates May Freeze the Bridge or Relayers",
                "Location": "find_latest_valset function",
                "Type": "Denial of Service (DoS)",
                "Description": "A sufficiently large validator set or sufficiently rapid validator update could cause both the eth_oracle_main_loop and relayer_main_loop to fall into a state of perpetual errors, freezing the bridge by disallowing attestations to take place. The vulnerability can be triggered if the logs in a 5000 block range are in excess of 10mb, which can happen if there are more than 517 updates per 5000 block range when the number of validators is 300. The patch requires handling the error more concretely and checking if a byte limit error occurred.",
                "Repair": "Chunk the search size into 2 and try again. Repeat as necessary, and combine the results."
            },
            {
                "Name": "[M-01] The function  updateValset  does not have enough sanity checks",
                "Location": "updateValset function",
                "Type": "Missing Check",
                "Description": "The function updateValset does not have enough sanity checks. It is missing the check that the combined power of all new validators is above the state_powerThreshold. If this is false, then the contract is effectively stuck. Consider adding an on-chain check for this. It is also worth adding a check that the size of the new validator is less than a certain number.",
                "Repair": "Add on-chain check for combined power of new validators and size of new validator check"
            },
            {
                "Name": "[M-02] Crash Eth Oracle On Any  LogicCallEvent ",
                "Location": "eth_oracle_main_loop function",
                "Type": "Panic",
                "Description": "The vulnerability can be triggered by calling the LogicCallExecutedEvent::from_log method, which is currently unimplemented, causing the program to panic. This can freeze attestations until the issue is patched.",
                "Repair": "Implement the from_log method in LogicCallExecutedEvent struct"
            },
            {
                "Name": "[M-03] Win all relayer rewards",
                "Location": "Relayer",
                "Type": "Availability",
                "Description": "An attacker can win all batch, logic, and valset rewards as their node is the only relayer running, due to the relayer freeze caused by large validator sets/rapid validator set updates.",
                "Repair": "Update the relayer software to handle large validator sets and rapid validator set updates"
            },
            {
                "Name": "[M-04] Incorrect accounting on transfer-on-fee/deflationary tokens in  Gravity ",
                "Location": "sendToCosmos function of Gravity",
                "Type": "Incorrect accounting",
                "Description": "If the transferred token is a transfer-on-fee/deflationary token, the actually received amount could be less than _amount. However, since _amount is passed as a parameter of the SendToCosmosEvent event, the Cosmos side will think more tokens are locked on the Ethereum side.",
                "Repair": "Calculate the difference of token balance (using balanceOf) before and after the transferFrom"
            }
        ]
    }
]