[
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../external/interfaces/AggregatorV3Interface.sol\";\nimport \"../external/interfaces/IUniswapV2Factory.sol\";\nimport \"../external/interfaces/IUniswapV2Pair.sol\";\n\nimport \"../external/libraries/FixedPoint.sol\";\nimport \"../external/libraries/UniswapV2OracleLibrary.sol\";\nimport \"../external/libraries/UniswapV2Library.sol\";\n\nimport \"../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\n\ncontract TwapOracle is Ownable {\n    /* ========== LIBRARIES ========== */\n\n    using FixedPoint for *;\n\n    /* ========== STRUCTURES ========== */\n\n    struct PairData {\n        // The address of the pair interface (IUniswapV2Pair or IVaderPoolV2)\n        address pair;\n        // The first token of the pair.\n        address token0;\n        // The second token of the pair.\n        address token1;\n        // The last cumulative price of the first token.\n        uint256 price0CumulativeLast;\n        // The last cumulative price of the second token.\n        uint256 price1CumulativeLast;\n        // The block timestamp of the last update.\n        uint32 blockTimestampLast;\n        // The average price of the first token.\n        FixedPoint.uq112x112 price0Average;\n        // The average price of the second token.\n        FixedPoint.uq112x112 price1Average;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The address of the deployed VADER token.\n    address public VADER;\n\n    // The address of the deployed USDV token.\n    address public USDV;\n\n    // A predicated which determines if USDV is enabled.\n    bool private _usdvEnabled;\n\n    // The mapping of native assets to USD aggregators.\n    mapping(address => address) private _aggregators;\n\n    // The vader pool used across all native assets.\n    IVaderPoolV2 private _vaderPool;\n\n    // The frequency that the pair collection should be updated.\n    uint256 private _updatePeriod;\n\n    // The collection of pairs tracked by the TWAP oracle.\n    PairData[] private _pairs;\n\n    // A mapping of pair hashes to existence predicates.\n    mapping(bytes32 => bool) private _pairExists;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /**\n     * @dev Constructs a new TWAP oracle with a VADER pool and update period.\n     * @param vaderPool The VADER pool address.\n     * @param updatePeriod The required period of time between each oracle update.\n     */\n    constructor(address vaderPool, uint256 updatePeriod) Ownable() {\n        _vaderPool = IVaderPoolV2(vaderPool);\n        _updatePeriod = updatePeriod;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier initialized() {\n        require(\n            VADER != address(0) && USDV != address(0),\n            \"TwapOracle::initialized: not initialized\"\n        );\n        _;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @dev Checks if a pair exists for the supplied {token0} and {token1} addresses.\n     * @param token0 The primary token address, either VADER or USDV.\n     * @param token1 The asset token address, paired to either VADER or USDV.\n     */\n    function pairExists(address token0, address token1)\n        public\n        view\n        returns (bool)\n    {\n        bytes32 pairHash0 = keccak256(abi.encodePacked(token0, token1));\n        bytes32 pairHash1 = keccak256(abi.encodePacked(token1, token0));\n        return _pairExists[pairHash0] || _pairExists[pairHash1];\n    }\n\n    /**\n     * @dev Performs a consultation to retrieve the equivalent to {amountIn} for the supplied {token} address.\n     * The {token} address must have a registered pairing, otherwise the transaction will revert.\n     * @param token The token address to consult the equivalent {amountIn} for.\n     */\n    function consult(address token) public view returns (uint256 result) {\n        uint256 pairCount = _pairs.length;\n        uint256 sumNative = 0;\n        uint256 sumUSD = 0;\n\n        for (uint256 i = 0; i < pairCount; i++) {\n            PairData memory pairData = _pairs[i];\n\n            if (token == pairData.token0) {\n                //\n                // TODO - Review:\n                //   Verify price1Average is amount of USDV against 1 unit of token1\n                //\n\n                sumNative += pairData.price1Average.mul(1).decode144(); // native asset amount\n                if (pairData.price1Average._x != 0) {\n                    require(sumNative != 0);\n                }\n\n                (\n                    uint80 roundID,\n                    int256 price,\n                    ,\n                    ,\n                    uint80 answeredInRound\n                ) = AggregatorV3Interface(_aggregators[pairData.token1])\n                        .latestRoundData();\n\n                require(\n                    answeredInRound >= roundID,\n                    \"TwapOracle::consult: stale chainlink price\"\n                );\n                require(\n                    price != 0,\n                    \"TwapOracle::consult: chainlink malfunction\"\n                );\n\n                sumUSD += uint256(price) * (10**10);\n            }\n        }\n        require(sumNative != 0, \"TwapOracle::consult: Sum of native is zero\");\n        result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative);\n    }\n\n    /**\n     * @dev Gets the exchange rate for the Vader to USDV.\n     */\n    function getRate() public view returns (uint256 result) {\n        uint256 tUSDInUSDV = consult(USDV);\n        uint256 tUSDInVader = consult(VADER);\n\n        result = tUSDInUSDV / tUSDInVader;\n    }\n\n    /**\n     * @dev Gets the VADER amount from the supplied USDV amount.\n     * @param usdvAmount The amount in USDV.\n     */\n    function usdvtoVader(uint256 usdvAmount) external view returns (uint256) {\n        return usdvAmount * getRate();\n    }\n\n    /**\n     * @dev Gets the USDV amount from the supplied VADER amount.\n     * @param vaderAmount The amount in VADER.\n     */\n    function vaderToUsdv(uint256 vaderAmount) external view returns (uint256) {\n        if (!_usdvEnabled) {\n            // consult call returns true USD amount against 1 Vader and is multiplied with {vaderAmount}.\n            return consult(VADER) * vaderAmount;\n        }\n\n        // usdv price is disabled so true USD value of both Vader and USDV is taken into account.\n        return vaderAmount / getRate();\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @dev Initializes the variables for VADER and USDV.\n     * @param _usdv The USDV token address.\n     * @param _vader The VADER token address.\n     */\n    function initialize(address _usdv, address _vader) external onlyOwner {\n        require(\n            VADER == address(0),\n            \"TwapOracle::initialize: Vader already set\"\n        );\n        require(USDV == address(0), \"TwapOracle::initialize: USDV already set\");\n        require(\n            _usdv != address(0),\n            \"TwapOracle::initialize: can not set to a zero address\"\n        );\n        require(\n            _vader != address(0),\n            \"TwapOracle::initialize: can not set to a zero address\"\n        );\n\n        VADER = _vader;\n        USDV = _usdv;\n    }\n\n    /**\n     * @dev Enables utilization of USDV.\n     */\n    function enableUSDV() external onlyOwner {\n        _usdvEnabled = true;\n    }\n\n    /**\n     * @dev Registers a chainlink {aggregator} for the supplied {asset} address.\n     * @param asset The address of the native asset.\n     * @param aggregator The address of the chainlink aggregator.\n     */\n    function registerAggregator(address asset, address aggregator)\n        external\n        onlyOwner\n        initialized\n    {\n        require(\n            asset != address(0),\n            \"TwapOracle::registerAggregator: asset zero address provided\"\n        );\n        require(\n            aggregator != address(0),\n            \"TwapOracle::registerAggregator: aggregator zero address provided\"\n        );\n        require(\n            _aggregators[asset] == address(0),\n            \"TwapOracle::registerAggregator: aggregator already exists\"\n        );\n\n        _aggregators[asset] = aggregator;\n    }\n\n    /**\n     * @dev Registers either a VADER or USDV pairing in the TWAP oracle.\n     * @param factory The factory address, if any.\n     * @param token0 The primary token address, either VADER or USDV.\n     * @param token1 The asset token address, paired to VADER or USDV.\n     */\n    function registerPair(\n        address factory,\n        address token0,\n        address token1\n    ) external onlyOwner initialized {\n        require(\n            token0 == VADER || token0 == USDV,\n            \"TwapOracle::registerPair: Invalid token0 address\"\n        );\n        require(\n            token0 != token1,\n            \"TwapOracle::registerPair: Same token address\"\n        );\n        require(\n            !pairExists(token0, token1),\n            \"TwapOracle::registerPair: Pair exists\"\n        );\n\n        address pairAddr;\n        uint256 price0CumulativeLast;\n        uint256 price1CumulativeLast;\n        uint112 reserve0;\n        uint112 reserve1;\n        uint32 blockTimestampLast;\n\n        if (token0 == VADER) {\n            IUniswapV2Pair pair = IUniswapV2Pair(\n                IUniswapV2Factory(factory).getPair(token0, token1)\n            );\n            pairAddr = address(pair);\n            price0CumulativeLast = pair.price0CumulativeLast();\n            price1CumulativeLast = pair.price1CumulativeLast();\n            (reserve0, reserve1, blockTimestampLast) = pair.getReserves();\n        } else {\n            pairAddr = address(_vaderPool);\n            (price0CumulativeLast, price1CumulativeLast, ) = _vaderPool\n                .cumulativePrices(IERC20(token1));\n            (reserve0, reserve1, blockTimestampLast) = _vaderPool.getReserves(\n                IERC20(token1)\n            );\n        }\n\n        require(\n            reserve0 != 0 && reserve1 != 0,\n            \"TwapOracle::registerPair: No reserves\"\n        );\n\n        _pairExists[keccak256(abi.encodePacked(token0, token1))] = true;\n\n        _pairs.push(\n            PairData({\n                pair: pairAddr,\n                token0: token0,\n                token1: token1,\n                price0CumulativeLast: price0CumulativeLast,\n                price1CumulativeLast: price1CumulativeLast,\n                blockTimestampLast: blockTimestampLast,\n                price0Average: FixedPoint.uq112x112({_x: 0}),\n                price1Average: FixedPoint.uq112x112({_x: 0})\n            })\n        );\n    }\n\n    /**\n     * @dev Updates the average prices for all token pairs registered in the TWAP oracle.\n     */\n    function update() external onlyOwner initialized {\n        uint256 pairCount = _pairs.length;\n\n        // Update all of the registered pairs in the TWAP oracle.\n        for (uint256 i = 0; i < pairCount; i++) {\n            PairData storage pairData = _pairs[i];\n\n            // Get the current cumulative prices and block timestamp of the current pairing.\n            (\n                uint256 price0Cumulative,\n                uint256 price1Cumulative,\n                uint32 blockTimestamp\n            ) = (pairData.token0 == VADER)\n                    ? UniswapV2OracleLibrary.currentCumulativePrices(\n                        pairData.pair\n                    )\n                    : _vaderPool.cumulativePrices(IERC20(pairData.token1));\n\n            unchecked {\n                // Ensure that at least one full period has passed since the pairing was last update.\n                uint32 timeElapsed = blockTimestamp -\n                    pairData.blockTimestampLast;\n                require(\n                    timeElapsed >= _updatePeriod,\n                    \"TwapOracle::update: Period not elapsed\"\n                );\n\n                // Cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed.\n                pairData.price0Average = FixedPoint.uq112x112(\n                    uint224(\n                        (price0Cumulative - pairData.price0CumulativeLast) /\n                            timeElapsed\n                    )\n                );\n                pairData.price1Average = FixedPoint.uq112x112(\n                    uint224(\n                        (price1Cumulative - pairData.price1CumulativeLast) /\n                            timeElapsed\n                    )\n                );\n            }\n\n            // Update the stored pairing data\n            pairData.price0CumulativeLast = price0Cumulative;\n            pairData.price1CumulativeLast = price1Cumulative;\n            pairData.blockTimestampLast = blockTimestamp;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "TwapOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TwapOracle.sol#L166",
                "Type": "Wrong rate calculation",
                "Description": "tUSDInUSDV can be smaller than tUSDInVader, and then getRate will return 0. This will lead to wrong rate calculation.",
                "Repair": "Manually multiply enough decimals before division"
            },
            {
                "Location": "TwapOracle.sol",
                "Type": "Incorrect Calculation",
                "Description": "TwapOracle doesn't calculate VADER:USDV exchange rate correctly.",
                "Repair": "Replace L156 with the correct scaling factor"
            },
            {
                "Location": "TwapOracle.sol",
                "Type": "Dependency Issue",
                "Description": "Should a Chainlink aggregator become stuck in a stale state then TwapOracle will become irrecoverably broken.",
                "Repair": "Allow governance to update the aggregator for a pair"
            },
            {
                "Location": "TwapOracle.sol",
                "Type": "Inflexible Update Period",
                "Description": "TWAP Oracle inflexible _updatePeriod.",
                "Repair": "Add a function to set the update period or consider adding a configurable update period per asset."
            },
            {
                "Location": "consult function in the contract TwapOracle.sol",
                "Type": "Should check return data from Chainlink aggregators",
                "Description": "There are no checks on timeStamp, resulting in stale prices.",
                "Repair": "Add checks on the return data with proper revert messages if the price is stale or the round is incomplete"
            },
            {
                "Location": "TwapOracle.sol",
                "Type": "Permissioned nature of TwapOracle allows owner to manipulate oracle",
                "Description": "Only the owner of TwapOracle can call update on the oracle.",
                "Repair": "Remove the permissioning from TwapOracle.update"
            },
            {
                "Location": "TwapOracle.sol#L115-L157, TwapOracle.sol#L314, and TwapOracle.sol#L322-L369",
                "Type": "Newly Registered Assets Skew Consultation Results",
                "Description": "If a new asset is added by first registering the token pair and aggregator, the consultation result for that token pair will remain skewed until the next update interval.",
                "Repair": "Perform proper checks to ensure that if pairData.price1Average._x == 0, then the Chainlink aggregator is not queried and not added to sumUSD. Additionally, fix the current check to assert that the pairData.price1Average.mul(1).decode144() result is not 0. Set a minimum deposit amount (both asset amount and native amount) for the first lp provider."
            },
            {
                "Location": "TwapOracle.update function",
                "Type": "Unbounded loop",
                "Description": "Unbounded loop in TwapOracle.update can result in oracle being locked",
                "Repair": "Add a method to stop tracking a particular pair or allow updating a subset of all pairs at a time"
            },
            {
                "Location": "TwapOracle.consult function",
                "Type": "Incorrect calculation",
                "Description": "The TwapOracle.consult() function iterates over all token pairs which belong to either VADER or USDV and then calculates the price of the respective asset by using both UniswapV2 and Chainlink price data. This helps to further protect against price manipulation attacks as the price is averaged out over the various registered token pairs. However, the protocol calculates it as ((SUSHI/USD + UNISWAP/USD) * token.decimals()) / (USDV/SUSHI + USDV/UNISWAP) which gives us an incorrectly denominated result.",
                "Repair": "Calculate the correct consultation of a given token, the returned result should consist of a sum of priceUSD * token.decimals() * priceNative divided by the number of calculations. This should correctly take the average token pair price."
            },
            {
                "Location": "TwapOracle.sol",
                "Type": "Incorrect Price Consultation Results",
                "Description": "The TwapOracle.consult() function iterates over all token pairs which belong to either VADER or USDV and then calculates the price of the respective asset by using both UniswapV2 and Chainlink price data. This helps to further protect against price manipulation attacks as the price is averaged out over the various registered token pairs.",
                "Repair": "Return the correct code to ensure the target token to consult is denominated in USD and contains the correct number of decimals"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nlibrary VaderMath {\n    /* ========== CONSTANTS ========== */\n\n    uint256 public constant ONE = 1 ether;\n\n    /* ========== LIBRARY FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the amount of liquidity units for the {vaderDeposited}\n     * and {assetDeposited} amounts across {totalPoolUnits}.\n     *\n     * The {vaderBalance} and {assetBalance} are taken into account in order to\n     * calculate any necessary slippage adjustment.\n     */\n    function calculateLiquidityUnits(\n        uint256 vaderDeposited,\n        uint256 vaderBalance,\n        uint256 assetDeposited,\n        uint256 assetBalance,\n        uint256 totalPoolUnits\n    ) public pure returns (uint256) {\n        // slipAdjustment\n        uint256 slip = calculateSlipAdjustment(\n            vaderDeposited,\n            vaderBalance,\n            assetDeposited,\n            assetBalance\n        );\n\n        // (Va + vA)\n        uint256 poolUnitFactor = (vaderBalance * assetDeposited) +\n            (vaderDeposited * assetBalance);\n\n        // 2VA\n        uint256 denominator = ONE * 2 * vaderBalance * assetBalance;\n\n        // P * [(Va + vA) / (2 * V * A)] * slipAdjustment\n        return ((totalPoolUnits * poolUnitFactor) / denominator) * slip;\n    }\n\n    /**\n    * @dev Calculates the necessary slippage adjustment for the {vaderDeposited} and {assetDeposited}\n    * amounts across the total {vaderBalance} and {assetBalance} amounts.\n    */\n    function calculateSlipAdjustment(\n        uint256 vaderDeposited,\n        uint256 vaderBalance,\n        uint256 assetDeposited,\n        uint256 assetBalance\n    ) public pure returns (uint256) {\n        // Va\n        uint256 vaderAsset = vaderBalance * assetDeposited;\n\n        // aV\n        uint256 assetVader = assetBalance * vaderDeposited;\n\n        // (v + V) * (a + A)\n        uint256 denominator = (vaderDeposited + vaderBalance) *\n            (assetDeposited + assetBalance);\n\n        // 1 - [|Va - aV| / (v + V) * (a + A)]\n        return ONE - (delta(vaderAsset, assetVader) / denominator);\n    }\n\n    /**\n    * @dev Calculates the loss based on the supplied {releasedVader} and {releasedAsset}\n    * compared to the supplied {originalVader} and {originalAsset}.\n    */\n    function calculateLoss(\n        uint256 originalVader,\n        uint256 originalAsset,\n        uint256 releasedVader,\n        uint256 releasedAsset\n    ) public pure returns (uint256 loss) {\n        //\n        // TODO: Vader Formula Differs https://github.com/vetherasset/vaderprotocol-contracts/blob/main/contracts/Utils.sol#L347-L356\n        //\n\n        // [(A0 * P1) + V0]\n        uint256 originalValue = ((originalAsset * releasedVader) /\n            releasedAsset) + originalVader;\n\n        // [(A1 * P1) + V1]\n        uint256 releasedValue = ((releasedAsset * releasedVader) /\n            releasedAsset) + releasedVader;\n\n        // [(A0 * P1) + V0] - [(A1 * P1) + V1]\n        if (originalValue > releasedValue) loss = originalValue - releasedValue;\n    }\n\n    /**\n    * @dev Calculates the {amountOut} of the swap based on the supplied {amountIn}\n    * across the supplied {reserveIn} and {reserveOut} amounts.\n    */\n    function calculateSwap(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure returns (uint256 amountOut) {\n        // x * Y * X\n        uint256 numerator = amountIn * reserveIn * reserveOut;\n\n        // (x + X) ^ 2\n        uint256 denominator = pow(amountIn + reserveIn);\n\n        amountOut = numerator / denominator;\n    }\n\n    /**\n    * @dev Calculates the {amountIn} of the swap based on the supplied {amountOut}\n    * across the supplied {reserveIn} and {reserveOut} amounts.\n    */\n    function calculateSwapReverse(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure returns (uint256 amountIn) {\n        // X * Y\n        uint256 XY = reserveIn * reserveOut;\n\n        // 2y\n        uint256 y2 = amountOut * 2;\n\n        // 4y\n        uint256 y4 = y2 * 2;\n\n        require(\n            y4 < reserveOut,\n            \"VaderMath::calculateSwapReverse: Desired Output Exceeds Maximum Output Possible (1/4 of Liquidity Pool)\"\n        );\n\n        // root(-X^2 * Y * (4y - Y))    =>    root(X^2 * Y * (Y - 4y)) as Y - 4y >= 0    =>    Y >= 4y holds true\n        uint256 numeratorA = root(XY) * root(reserveIn * (reserveOut - y4));\n\n        // X * (2y - Y)    =>    2yX - XY\n        uint256 numeratorB = y2 * reserveIn;\n        uint256 numeratorC = XY;\n\n        // -1 * (root(-X^2 * Y * (4y - Y)) + (X * (2y - Y)))    =>    -1 * (root(X^2 * Y * (Y - 4y)) + 2yX - XY)    =>    XY - root(X^2 * Y * (Y - 4y) - 2yX\n        uint256 numerator = numeratorC - numeratorA - numeratorB;\n\n        // 2y\n        uint256 denominator = y2;\n\n        amountIn = numerator / denominator;\n    }\n\n    /**\n    * @dev Calculates the difference between the supplied {a} and {b} values as a positive number.\n    */\n    function delta(uint256 a, uint256 b) public pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    /**\n    * @dev Calculates the power of 2 of the supplied {a} value.\n    */\n    function pow(uint256 a) public pure returns (uint256) {\n        return a * a;\n    }\n\n    /**\n    * @dev Calculates the square root {c} of the supplied {a} value utilizing the Babylonian method:\n    * https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n    */\n    function root(uint256 a) public pure returns (uint256 c) {\n        if (a > 3) {\n            c = a;\n            uint256 x = a / 2 + 1;\n            while (x < c) {\n                c = x;\n                x = (a / x + x) / 2;\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "VaderMath.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaderMath.sol#L69-L93",
                "Type": "Loss calculation vulnerability",
                "Description": "The lp value is calculated as [(A0 * P1) + V0] and // (A1 * P1) + V1]. The formula it uses to calculate lp value is vulnerable to manipulation.",
                "Repair": "Use the fair lp pricing formula from alpha finance instead"
            },
            {
                "Location": "VaderMath.sol#L42",
                "Type": "The first lp provider can destroy the pool",
                "Description": "If the first lp sets the pool's rate to an extreme value no one can deposit to the pool afterward.",
                "Repair": "Set a minimum deposit amount (both asset amount and native amount) for the first lp provider."
            },
            {
                "Location": "VaderMath.sol",
                "Type": "Wrong swap formula",
                "Description": "The current formula to calculate the amountOut for a swap is wrong and it will result in unexpected and unfavorable outputs.",
                "Repair": "Redesign the formula to avoid unexpected and unfavorable outputs"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./BasePoolV2.sol\";\n\nimport \"../../interfaces/shared/IERC20Extended.sol\";\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\nimport \"../../interfaces/dex-v2/wrapper/ILPWrapper.sol\";\nimport \"../../interfaces/dex-v2/synth/ISynthFactory.sol\";\n\n/*\n * @dev Implementation of {VaderPoolV2} contract.\n *\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\n * queue system.\n *\n * Extends on the liquidity redeeming function by introducing the `burn` function\n * that internally calls the namesake on `BasePoolV2` contract and computes the\n * loss covered by the position being redeemed and returns it along with amounts\n * of native and foreign assets sent.\n **/\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The LP wrapper contract\n    ILPWrapper public wrapper;\n\n    // The Synth Factory\n    ISynthFactory public synthFactory;\n\n    // Denotes whether the queue system is active\n    bool public queueActive;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialised the contract state by passing the native asset's address\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\n     * to the {queueActive} state variable.\n     **/\n    constructor(bool _queueActive, IERC20 _nativeAsset)\n        BasePoolV2(_nativeAsset)\n    {\n        queueActive = _queueActive;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns cumulative prices and the timestamp the were last updated\n     * for both native and foreign assets against the pair specified by\n     * parameter {foreignAsset}.\n     **/\n    function cumulativePrices(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint256 price0CumulativeLast,\n            uint256 price1CumulativeLast,\n            uint32 blockTimestampLast\n        )\n    {\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\n            .priceCumulative;\n        price0CumulativeLast = priceCumulative.nativeLast;\n        price1CumulativeLast = priceCumulative.foreignLast;\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Initializes contract's state with LP wrapper, synth factory\n     * and router addresses.\n     *\n     * Requirements:\n     * - None of the parameters are zero addresses.\n     * - The parameters are not already set.\n     * - Only callable by contract owner.\n     **/\n    function initialize(\n        ILPWrapper _wrapper,\n        ISynthFactory _synthFactory,\n        address _router\n    ) external onlyOwner {\n        require(\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Already initialized\"\n        );\n        require(\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\n        );\n        require(\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\n        );\n        require(\n            _router != _ZERO_ADDRESS,\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\n        );\n        wrapper = _wrapper;\n        synthFactory = _synthFactory;\n        router = _router;\n    }\n\n    /*\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\n     * on the native asset amount deposited and returns the minted synth asset amount.\n     *\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must be a supported token.\n     **/\n    function mintSynth(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        supportedToken(foreignAsset)\n        returns (uint256 amountSynth)\n    {\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        if (synth == ISynth(_ZERO_ADDRESS))\n            synth = synthFactory.createSynth(\n                IERC20Extended(address(foreignAsset))\n            );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountSynth = VaderMath.calculateSwap(\n            nativeDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        synth.mint(to, amountSynth);\n    }\n\n    /*\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\n     * and returns the redeemed amount of native asset.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must have a valid synthetic asset against it.\n     * - {synthAmount} must be greater than zero.\n     **/\n    function burnSynth(\n        IERC20 foreignAsset,\n        uint256 synthAmount,\n        address to\n    ) external override nonReentrant returns (uint256 amountNative) {\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        require(\n            synth != ISynth(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\n        );\n\n        require(\n            synthAmount > 0,\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\n        );\n\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\n        synth.burn(synthAmount);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountNative = VaderMath.calculateSwap(\n            synthAmount,\n            reserveForeign,\n            reserveNative\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        nativeAsset.safeTransfer(to, amountNative);\n    }\n\n    /*\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\n     *\n     * Deletes the position in {positions} mapping against the burned NFT token.\n     *\n     * Internally calls `_burn` function on {BasePoolV2} contract.\n     *\n     * Calculates the impermanent loss incurred by the position.\n     *\n     * Returns the amounts for native and foreign assets sent to the {to} address\n     * along with the covered loss.\n     *\n     * Requirements:\n     * - Can only be called by the Router.\n     **/\n    // NOTE: IL is only covered via router!\n    function burn(uint256 id, address to)\n        external\n        override\n        onlyRouter\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n\n        // NOTE: Validate it behaves as expected for non-18 decimal tokens\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n\n        // TODO: Original Implementation Applied 100 Days\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n\n    /*\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\n     * tracked within this contract along with liquidity issued against non-fungible\n     * token.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'mint' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     **/\n    function mintFungible(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override nonReentrant returns (uint256 liquidity) {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\n        );\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        lp.mint(to, liquidity);\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n    }\n\n    /*\n     * @dev Allows burning of liquidity issued in fungible tokens.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'burn' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\n     **/\n    function burnFungible(\n        IERC20 foreignAsset,\n        uint256 liquidity,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\n        );\n\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\n        lp.burn(liquidity);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // TODO: Investigate Necessity\n    function toggleQueue() external override onlyOwner {\n        bool _queueActive = !queueActive;\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setTokenSupport(IERC20 foreignAsset, bool support)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            supported[foreignAsset] != support,\n            \"VaderPoolV2::supportToken: Already At Desired State\"\n        );\n        supported[foreignAsset] = support;\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setFungibleTokenSupport(IERC20 foreignAsset)\n        external\n        override\n        onlyOwner\n    {\n        wrapper.createWrapper(foreignAsset);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n\n",
        "CodeNames": [
            "VaderPoolV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaderPoolV2.sol#L126-L155, VaderPoolV2.sol#L179-L197",
                "Type": "Front-running vulnerability",
                "Description": "mintSynth() and burnSynth() will issue and redeem assets based on the price of the pool (reserves), and they will create price impact based on the volume being minted and burnt. However, the current implementation provides no parameter for slippage control, making them vulnerable to front-run attacks.",
                "Repair": "Add a minAmountOut parameter"
            },
            {
                "Location": "VaderPoolV2.sol#L126-L167",
                "Type": "Manipulation vulnerability",
                "Description": "An attacker may set the exchange rate between nativeAsset and synths (calculated from the reserves). An attacker can exploit this to drain funds from the pool.",
                "Repair": "Prevent minting of synths or at the very least tie the exchange rate to a manipulation resistant oracle"
            },
            {
                "Location": "VaderPoolV2.sol#L505-L517",
                "Type": "Access control vulnerability",
                "Description": "VaderPoolV2 has a rescue function which allows any unaccounted for tokens to be recovered. However there is no access control on this function which means than should any tokens be sent to VaderPoolV2 by accident they'll just be scooped up by flashbots rather than being recoverable by the original owner or Vader governance.",
                "Repair": "Permission this function to only allow Vader governance to claim tokens"
            },
            {
                "Location": "VaderPoolV2.sol",
                "Type": "Loss of Funds",
                "Description": "All user assets which are approved to VaderPoolV2 may be stolen.",
                "Repair": "Remove 'from' argument and use msg.sender instead"
            },
            {
                "Location": "VaderPoolV2.sol",
                "Type": "Loss of Funds",
                "Description": "Covering impermanent loss allows profiting off asymmetric liquidity provision at the expense of reserve holdings.",
                "Repair": "Remove a possibility to add liquidity asymmetrically"
            },
            {
                "Location": "VaderPoolV2.sol",
                "Type": "Loss of Funds",
                "Description": "Minting and burning synths exposes users to unlimited slippage.",
                "Repair": "Add an argument for the minimum amount of synths to mint or nativeAsset to receive"
            },
            {
                "Location": "VaderPoolV2.sol#L284-L335",
                "Type": "Lack of access control allow attacker to  mintFungible()  and  mintSynth()  with other user's wallet balance",
                "Description": "This issue allows anyone to call mintFungible() and mintSynth() and steal almost all their wallet balances for all the users who have approved the contract before.",
                "Repair": "Consider removing the from argument in mintFungible() and update the safeTransferFrom() calls to instead transfer from msg.sender."
            },
            {
                "Location": "VaderPoolV2.sol#L284-L335",
                "Type": "Anyone Can Arbitrarily Mint Fungible Tokens In  VaderPoolV2.mintFungible()",
                "Description": "The mintFungible() function is callable by any user that wishes to mint liquidity pool fungible tokens.",
                "Repair": "Consider removing the from argument in mintFungible() and update the safeTransferFrom() calls to instead transfer from msg.sender."
            },
            {
                "Location": "VaderPoolV2.sol#L271-L335",
                "Type": "VaderPoolV2.mintFungible exposes users to unlimited slippage",
                "Description": "However there's no way for users to specify the minimum number of liquidity units they will accept. As the number of liquidity units minted is calculated from the current reserves, this allows frontrunners to manipulate the pool's reserves in such a way that the LP receives fewer liquidity units than they should.",
                "Repair": "Add a user-specified minimum amount of LP tokens to mint."
            },
            {
                "Location": "VaderPoolV2.sol:L237-L269",
                "Type": "High Severity",
                "Description": "LPs of VaderPoolV2 can manipulate pool reserves to extract funds from the reserve using impermanent loss protection.",
                "Repair": "Use a manipulation resistant oracle for the relative prices of the pool's assets (TWAP, etc.)"
            },
            {
                "Location": "VaderPoolV2.sol:L284-L335",
                "Type": "High Severity",
                "Description": "Wrong design/implementation of addLiquidity() allows attacker to steal funds from the liquidity pool.",
                "Repair": "Implement a fixed ratio of amounts in comparison to Uni v2"
            },
            {
                "Location": "VaderPoolV2.sol",
                "Type": "High Severity",
                "Description": "Synth tokens can get over-minted.",
                "Repair": "Deduct or lock reserveForeign when minting Synth tokens"
            },
            {
                "Location": "VaderPoolV2.sol",
                "Type": "High Severity",
                "Description": "Wrong design/implementation of addLiquidity() allows anyone to manipulate the price of the pool easily and create an arbitrage opportunity at the cost of all other liquidity providers.",
                "Repair": "Safeguard the amount supplied for a trade off-chain"
            },
            {
                "Location": "VaderPoolV2.sol",
                "Type": "VaderPoolV2 incorrectly calculates the amount of IL protection to send to LPs",
                "Description": "The IL experienced by the LP is calculated with the assumption that it is working on units of VADER whereas it is provided amounts in terms of USDV.",
                "Repair": "Add handling for the conversion rate between VADER and USDV using a tamper-resistant oracle"
            },
            {
                "Location": "VaderPoolV2.mintSynth() function",
                "Type": "Arbitrary minting of synthetic assets",
                "Description": "Anyone Can Arbitrarily Mint Synthetic Assets In VaderPoolV2.mintSynth()",
                "Repair": "Remove the 'from' argument in mintSynth() and update the safeTransferFrom() call to instead transfer from msg.sender"
            },
            {
                "Location": "VaderPoolV2.burn function",
                "Type": "Draining of Vader Reserve",
                "Description": "Paying IL protection for all VaderPool pairs allows the reserve to be drained.",
                "Repair": "Add a whitelist to the pairs which qualify for IL protection"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../math/VaderMath.sol\";\n\nimport \"../../interfaces/reserve/IVaderReserve.sol\";\nimport \"../../interfaces/dex/router/IVaderRouter.sol\";\nimport \"../../interfaces/dex/pool/IVaderPoolFactory.sol\";\n\n/*\n @dev Implementation of {VaderRouter} contract.\n *\n * The contract VaderRouter inherits from {Ownable} and {ProtocolConstants} contracts.\n *\n * It allows adding of liquidity to Vader pools and facilitate creation of Vader pools if\n * it does not already exist when depositing liquidity.\n *\n * Allows removing of liquidity by the users and claiming the underlying assets from\n * the Vader pools.\n *\n * Allows swapping between native and foreign assets within a single Vader pool.\n *\n * Allows swapping of foreign assets across two different Vader pools.\n *\n * Contains helper functions to compute the destination asset amount given the exact source\n * asset amount and vice versa.\n **/\ncontract VaderRouter is IVaderRouter, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The address of Vader pool factory contract.\n    IVaderPoolFactory public immutable factory;\n\n    // The address of Reserve contract.\n    IVaderReserve public reserve;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initializes contract's state by setting the vader pool factory address.\n     *\n     * Requirements:\n     * - Vader pool factory address must not be zero.\n     **/\n    constructor(IVaderPoolFactory _factory) {\n        require(\n            _factory != IVaderPoolFactory(_ZERO_ADDRESS),\n            \"VaderRouter::constructor: Incorrect Arguments\"\n        );\n\n        factory = _factory;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows adding of liquidity to the Vader pools.\n     *\n     * Internally calls {addLiquidity} function.\n     *\n     * Returns the amounts of assetA and assetB used in liquidity and\n     * the amount of liquidity units minted.\n     **/\n    // NOTE: For Uniswap V2 compliancy, necessary due to stack too deep\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256, // amountAMin = unused\n        uint256, // amountBMin = unused\n        address to,\n        uint256 deadline\n    )\n        external\n        override\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        return\n            addLiquidity(\n                tokenA,\n                tokenB,\n                amountADesired,\n                amountBDesired,\n                to,\n                deadline\n            );\n    }\n\n    /*\n     * @dev Allows adding of liquidity to the Vader pools.\n     *\n     * Internally calls {_addLiquidity} function.\n     *\n     * Transfers the amounts of tokenA and tokenB from {msg.sender} to the pool.\n     *\n     * Calls the {mint} function on the pool to deposit liquidity on the behalf of\n     * {to} address.\n     *\n     * Returns the amounts of assetA and assetB used in liquidity and\n     * the amount of liquidity units minted.\n     *\n     * Requirements:\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        address to,\n        uint256 deadline\n    )\n        public\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        IVaderPool pool;\n        (pool, amountA, amountB) = _addLiquidity(\n            address(tokenA),\n            address(tokenB),\n            amountADesired,\n            amountBDesired\n        );\n        tokenA.safeTransferFrom(msg.sender, address(pool), amountA);\n        tokenB.safeTransferFrom(msg.sender, address(pool), amountB);\n        liquidity = pool.mint(to);\n    }\n\n    /*\n     * @dev Allows removing of liquidity by {msg.sender} and transfers the\n     * underlying assets to {to} address.\n     *\n     * Transfers the NFT with Id {id} representing user's position, to the pool address,\n     * so the pool is able to burn it in the `burn` function call.\n     *\n     * Calls the `burn` function on the pool contract.\n     *\n     * Calls the `reimburseImpermanentLoss` on reserve contract to cover impermanent loss\n     * for the liquidity being removed.\n     *\n     * Requirements:\n     * - The underlying assets amounts of {amountA} and {amountB} must\n     *   be greater than or equal to {amountAMin} and {amountBMin}, respectively.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 id,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        override\n        ensure(deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        IVaderPool pool = factory.getPool(tokenA, tokenB);\n\n        pool.transferFrom(msg.sender, address(pool), id);\n\n        (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        ) = pool.burn(id, to);\n\n        (amountA, amountB) = tokenA == factory.nativeAsset()\n            ? (amountNative, amountForeign)\n            : (amountForeign, amountNative);\n\n        require(\n            amountA >= amountAMin,\n            \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\"\n        );\n        require(\n            amountB >= amountBMin,\n            \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\"\n        );\n\n        reserve.reimburseImpermanentLoss(msg.sender, coveredLoss);\n    }\n\n    /*\n     * @dev Allows swapping of exact source token amount to destination\n     * token amount.\n     *\n     * Internally calls {_swap} function.\n     *\n     * Requirements:\n     * - The destination amount {amountOut} must greater than or equal to param {amountOutMin}.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256 amountOut) {\n        amountOut = _swap(amountIn, path, to);\n\n        require(\n            amountOut >= amountOutMin,\n            \"VaderRouter::swapExactTokensForTokens: Insufficient Trade Output\"\n        );\n    }\n\n    /*\n     * @dev Allows swapping of source token amount to exact destination token\n     * amount.\n     *\n     * Internally calls {calculateInGivenOut} and {_swap} functions.\n     *\n     * Requirements:\n     * - Param {amountInMax} must be greater than or equal to the source amount computed {amountIn}.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual ensure(deadline) returns (uint256 amountIn) {\n        amountIn = calculateInGivenOut(amountOut, path);\n\n        require(\n            amountInMax >= amountIn,\n            \"VaderRouter::swapTokensForExactTokens: Large Trade Input\"\n        );\n\n        _swap(amountIn, path, to);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /*\n     * @dev Sets the reserve address and renounces contract's ownership.\n     *\n     * Requirements:\n     * - Only existing owner can call this function.\n     * - Param {_reserve} cannot be a zero address.\n     **/\n    function initialize(IVaderReserve _reserve) external onlyOwner {\n        require(\n            _reserve != IVaderReserve(_ZERO_ADDRESS),\n            \"VaderRouter::initialize: Incorrect Reserve Specified\"\n        );\n\n        reserve = _reserve;\n\n        renounceOwnership();\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows swapping of assets from within a single Vader pool or\n     * across two different Vader pools.\n     *\n     * In case of a single Vader pool, the native asset can be swapped for foreign\n     * asset and vice versa.\n     *\n     * In case of two Vader pools, the foreign asset is swapped for native asset from\n     * the first Vader pool and the native asset retrieved from the first Vader pool is swapped\n     * for foreign asset from the second Vader pool.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    // TODO: Refactor with central pool, perhaps diminishes security? would need directSwap & bridgeSwap\n    function _swap(\n        uint256 amountIn,\n        address[] calldata path,\n        address to\n    ) private returns (uint256 amountOut) {\n        if (path.length == 3) {\n            require(\n                path[0] != path[1] &&\n                    path[1] == factory.nativeAsset() &&\n                    path[2] != path[1],\n                \"VaderRouter::_swap: Incorrect Path\"\n            );\n\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool0),\n                amountIn\n            );\n\n            return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);\n        } else {\n            require(\n                path.length == 2,\n                \"VaderRouter::_swap: Incorrect Path Length\"\n            );\n            address nativeAsset = factory.nativeAsset();\n            require(path[0] != path[1], \"VaderRouter::_swap: Incorrect Path\");\n\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool),\n                amountIn\n            );\n            if (path[0] == nativeAsset) {\n                return pool.swap(amountIn, 0, to);\n            } else {\n                require(\n                    path[1] == nativeAsset,\n                    \"VaderRouter::_swap: Incorrect Path\"\n                );\n                return pool.swap(0, amountIn, to);\n            }\n        }\n    }\n\n    /*\n     * @dev An internal function that returns Vader pool's address against\n     * the provided assets of {tokenA} and {tokenB} if it exists, otherwise\n     * a new Vader pool created against the provided assets.\n     **/\n    // NOTE: DEX allows asymmetric deposits\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    )\n        private\n        returns (\n            IVaderPool pool,\n            uint256 amountA,\n            uint256 amountB\n        )\n    {\n        // create the pair if it doesn't exist yet\n        pool = factory.getPool(tokenA, tokenB);\n        if (pool == IVaderPool(_ZERO_ADDRESS)) {\n            pool = factory.createPool(tokenA, tokenB);\n        }\n\n        (amountA, amountB) = (amountADesired, amountBDesired);\n    }\n\n    /*\n     * @dev Returns the amount of source asset given the amount of destination asset.\n     *\n     * Calls the {calculateSwapReverse} on VaderMath library to compute the source\n     * token amount.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    function calculateInGivenOut(uint256 amountOut, address[] calldata path)\n        public\n        view\n        returns (uint256 amountIn)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwapReverse(\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }\n\n    /*\n     * @dev Returns the amount of destination asset given the amount of source asset.\n     *\n     * Calls the {calculateSwap} on VaderMath library to compute the destination\n     * token amount.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    function calculateOutGivenIn(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256 amountOut)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwap(\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    // Guard ensuring that the current timestamp has not exceeded the param {deadline}.\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"VaderRouter::ensure: Expired\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "VaderRouter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaderRouter (both V1 and V2)",
                "Type": "Unused slippage params",
                "Description": "Function addLiquidity in VaderRouter (both V1 and V2) do not use slippage parameters, making it susceptible to sandwich attacks / MEV.",
                "Repair": "Consider paying some attention to the slippage to reduce possible manipulation attacks from mempool snipers"
            },
            {
                "Location": "VaderRouter._swap function",
                "Type": "Wrong swap",
                "Description": "VaderRouter._swap performs wrong swap",
                "Repair": "Use 'return pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to);' instead"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../shared/ProtocolConstants.sol\";\n\ncontract XVader is ProtocolConstants, ERC20Votes, ReentrancyGuard {\n    // Address of vader token\n    IERC20 public immutable vader;\n\n    /*\n     * @dev Initializes contract's state by setting vader's tokens address and\n     * setting current token's name and symbol.\n     **/\n    constructor(IERC20 _vader)\n        ERC20Permit(\"XVader\")\n        ERC20(\"XVader\", \"xVADER\")\n    {\n        require(\n            _vader != IERC20(_ZERO_ADDRESS),\n            \"XVader::constructor: _vader cannot be a zero address\"\n        );\n        vader = _vader;\n    }\n\n    // Locks vader and mints xVader\n    function enter(uint256 _amount) external nonReentrant {\n        // Gets the amount of vader locked in the contract\n        uint256 totalVader = vader.balanceOf(address(this));\n        // Gets the amount of xVader in existence\n        uint256 totalShares = totalSupply();\n\n        uint256 xVADERToMint = totalShares == 0 || totalVader == 0\n            // If no xVader exists, mint it 1:1 to the amount put in\n            ? _amount\n            // Calculate and mint the amount of xVader the vader is worth.\n            // The ratio will change overtime, as xVader is burned/minted and\n            // vader deposited + gained from fees / withdrawn.\n            : (_amount * totalShares) / totalVader;\n\n        _mint(msg.sender, xVADERToMint);\n\n        // Lock the vader in the contract\n        vader.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Claim back your VADER\n    // Unlocks the staked + gained vader and burns xVader\n    function leave(uint256 _shares) external nonReentrant {\n        // Calculates the amount of vader the xVader is worth\n        uint vaderAmount = (_shares * vader.balanceOf(address(this))) / totalSupply();\n\n        _burn(msg.sender, _shares);\n        vader.transfer(msg.sender, vaderAmount);\n    }\n}\n\n",
        "CodeNames": [
            "XVader.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "XVader.sol",
                "Type": "Fee-On-Transfer",
                "Description": "The Vader token contains a Fee-On-Transfer so in XVader.sol, an attacker may be able to keep calling enter() and leave() while being credited more tokens than the contract actually receives eventually draining it.",
                "Repair": "There should be pre and post checks on balances to get the real amount"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../math/VaderMath.sol\";\n\nimport \"../../interfaces/reserve/IVaderReserve.sol\";\nimport \"../../interfaces/dex/router/IVaderRouter.sol\";\nimport \"../../interfaces/dex/pool/IVaderPoolFactory.sol\";\n\n/*\n @dev Implementation of {VaderRouter} contract.\n *\n * The contract VaderRouter inherits from {Ownable} and {ProtocolConstants} contracts.\n *\n * It allows adding of liquidity to Vader pools and facilitate creation of Vader pools if\n * it does not already exist when depositing liquidity.\n *\n * Allows removing of liquidity by the users and claiming the underlying assets from\n * the Vader pools.\n *\n * Allows swapping between native and foreign assets within a single Vader pool.\n *\n * Allows swapping of foreign assets across two different Vader pools.\n *\n * Contains helper functions to compute the destination asset amount given the exact source\n * asset amount and vice versa.\n **/\ncontract VaderRouter is IVaderRouter, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The address of Vader pool factory contract.\n    IVaderPoolFactory public immutable factory;\n\n    // The address of Reserve contract.\n    IVaderReserve public reserve;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initializes contract's state by setting the vader pool factory address.\n     *\n     * Requirements:\n     * - Vader pool factory address must not be zero.\n     **/\n    constructor(IVaderPoolFactory _factory) {\n        require(\n            _factory != IVaderPoolFactory(_ZERO_ADDRESS),\n            \"VaderRouter::constructor: Incorrect Arguments\"\n        );\n\n        factory = _factory;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows adding of liquidity to the Vader pools.\n     *\n     * Internally calls {addLiquidity} function.\n     *\n     * Returns the amounts of assetA and assetB used in liquidity and\n     * the amount of liquidity units minted.\n     **/\n    // NOTE: For Uniswap V2 compliancy, necessary due to stack too deep\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256, // amountAMin = unused\n        uint256, // amountBMin = unused\n        address to,\n        uint256 deadline\n    )\n        external\n        override\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        return\n            addLiquidity(\n                tokenA,\n                tokenB,\n                amountADesired,\n                amountBDesired,\n                to,\n                deadline\n            );\n    }\n\n    /*\n     * @dev Allows adding of liquidity to the Vader pools.\n     *\n     * Internally calls {_addLiquidity} function.\n     *\n     * Transfers the amounts of tokenA and tokenB from {msg.sender} to the pool.\n     *\n     * Calls the {mint} function on the pool to deposit liquidity on the behalf of\n     * {to} address.\n     *\n     * Returns the amounts of assetA and assetB used in liquidity and\n     * the amount of liquidity units minted.\n     *\n     * Requirements:\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        address to,\n        uint256 deadline\n    )\n        public\n        override\n        ensure(deadline)\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        )\n    {\n        IVaderPool pool;\n        (pool, amountA, amountB) = _addLiquidity(\n            address(tokenA),\n            address(tokenB),\n            amountADesired,\n            amountBDesired\n        );\n        tokenA.safeTransferFrom(msg.sender, address(pool), amountA);\n        tokenB.safeTransferFrom(msg.sender, address(pool), amountB);\n        liquidity = pool.mint(to);\n    }\n\n    /*\n     * @dev Allows removing of liquidity by {msg.sender} and transfers the\n     * underlying assets to {to} address.\n     *\n     * Transfers the NFT with Id {id} representing user's position, to the pool address,\n     * so the pool is able to burn it in the `burn` function call.\n     *\n     * Calls the `burn` function on the pool contract.\n     *\n     * Calls the `reimburseImpermanentLoss` on reserve contract to cover impermanent loss\n     * for the liquidity being removed.\n     *\n     * Requirements:\n     * - The underlying assets amounts of {amountA} and {amountB} must\n     *   be greater than or equal to {amountAMin} and {amountBMin}, respectively.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 id,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        override\n        ensure(deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        IVaderPool pool = factory.getPool(tokenA, tokenB);\n\n        pool.transferFrom(msg.sender, address(pool), id);\n\n        (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        ) = pool.burn(id, to);\n\n        (amountA, amountB) = tokenA == factory.nativeAsset()\n            ? (amountNative, amountForeign)\n            : (amountForeign, amountNative);\n\n        require(\n            amountA >= amountAMin,\n            \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\"\n        );\n        require(\n            amountB >= amountBMin,\n            \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\"\n        );\n\n        reserve.reimburseImpermanentLoss(msg.sender, coveredLoss);\n    }\n\n    /*\n     * @dev Allows swapping of exact source token amount to destination\n     * token amount.\n     *\n     * Internally calls {_swap} function.\n     *\n     * Requirements:\n     * - The destination amount {amountOut} must greater than or equal to param {amountOutMin}.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256 amountOut) {\n        amountOut = _swap(amountIn, path, to);\n\n        require(\n            amountOut >= amountOutMin,\n            \"VaderRouter::swapExactTokensForTokens: Insufficient Trade Output\"\n        );\n    }\n\n    /*\n     * @dev Allows swapping of source token amount to exact destination token\n     * amount.\n     *\n     * Internally calls {calculateInGivenOut} and {_swap} functions.\n     *\n     * Requirements:\n     * - Param {amountInMax} must be greater than or equal to the source amount computed {amountIn}.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual ensure(deadline) returns (uint256 amountIn) {\n        amountIn = calculateInGivenOut(amountOut, path);\n\n        require(\n            amountInMax >= amountIn,\n            \"VaderRouter::swapTokensForExactTokens: Large Trade Input\"\n        );\n\n        _swap(amountIn, path, to);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /*\n     * @dev Sets the reserve address and renounces contract's ownership.\n     *\n     * Requirements:\n     * - Only existing owner can call this function.\n     * - Param {_reserve} cannot be a zero address.\n     **/\n    function initialize(IVaderReserve _reserve) external onlyOwner {\n        require(\n            _reserve != IVaderReserve(_ZERO_ADDRESS),\n            \"VaderRouter::initialize: Incorrect Reserve Specified\"\n        );\n\n        reserve = _reserve;\n\n        renounceOwnership();\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows swapping of assets from within a single Vader pool or\n     * across two different Vader pools.\n     *\n     * In case of a single Vader pool, the native asset can be swapped for foreign\n     * asset and vice versa.\n     *\n     * In case of two Vader pools, the foreign asset is swapped for native asset from\n     * the first Vader pool and the native asset retrieved from the first Vader pool is swapped\n     * for foreign asset from the second Vader pool.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    // TODO: Refactor with central pool, perhaps diminishes security? would need directSwap & bridgeSwap\n    function _swap(\n        uint256 amountIn,\n        address[] calldata path,\n        address to\n    ) private returns (uint256 amountOut) {\n        if (path.length == 3) {\n            require(\n                path[0] != path[1] &&\n                    path[1] == factory.nativeAsset() &&\n                    path[2] != path[1],\n                \"VaderRouter::_swap: Incorrect Path\"\n            );\n\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool0),\n                amountIn\n            );\n\n            return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);\n        } else {\n            require(\n                path.length == 2,\n                \"VaderRouter::_swap: Incorrect Path Length\"\n            );\n            address nativeAsset = factory.nativeAsset();\n            require(path[0] != path[1], \"VaderRouter::_swap: Incorrect Path\");\n\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool),\n                amountIn\n            );\n            if (path[0] == nativeAsset) {\n                return pool.swap(amountIn, 0, to);\n            } else {\n                require(\n                    path[1] == nativeAsset,\n                    \"VaderRouter::_swap: Incorrect Path\"\n                );\n                return pool.swap(0, amountIn, to);\n            }\n        }\n    }\n\n    /*\n     * @dev An internal function that returns Vader pool's address against\n     * the provided assets of {tokenA} and {tokenB} if it exists, otherwise\n     * a new Vader pool created against the provided assets.\n     **/\n    // NOTE: DEX allows asymmetric deposits\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    )\n        private\n        returns (\n            IVaderPool pool,\n            uint256 amountA,\n            uint256 amountB\n        )\n    {\n        // create the pair if it doesn't exist yet\n        pool = factory.getPool(tokenA, tokenB);\n        if (pool == IVaderPool(_ZERO_ADDRESS)) {\n            pool = factory.createPool(tokenA, tokenB);\n        }\n\n        (amountA, amountB) = (amountADesired, amountBDesired);\n    }\n\n    /*\n     * @dev Returns the amount of source asset given the amount of destination asset.\n     *\n     * Calls the {calculateSwapReverse} on VaderMath library to compute the source\n     * token amount.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    function calculateInGivenOut(uint256 amountOut, address[] calldata path)\n        public\n        view\n        returns (uint256 amountIn)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwapReverse(\n                    VaderMath.calculateSwapReverse(\n                        amountOut,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }\n\n    /*\n     * @dev Returns the amount of destination asset given the amount of source asset.\n     *\n     * Calls the {calculateSwap} on VaderMath library to compute the destination\n     * token amount.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    function calculateOutGivenIn(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256 amountOut)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwap(\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    // Guard ensuring that the current timestamp has not exceeded the param {deadline}.\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"VaderRouter::ensure: Expired\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../../dex/math/VaderMath.sol\";\n\nimport \"../../interfaces/reserve/IVaderReserve.sol\";\nimport \"../../interfaces/dex-v2/router/IVaderRouterV2.sol\";\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\n\n/*\n @dev Implementation of {VaderRouterV2} contract.\n *\n * The contract VaderRouter inherits from {Ownable} and {ProtocolConstants} contracts.\n *\n * It allows adding of liquidity to Vader pairs.\n *\n * Allows removing of liquidity by the users and claiming the underlying assets from\n * the Vader pairs/pools.\n *\n * Allows swapping between native and foreign assets within a single Vader pair.\n *\n * Allows swapping of foreign assets across two different Vader pairs.\n **/\ncontract VaderRouterV2 is IVaderRouterV2, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of the Vader pool contract.\n    IVaderPoolV2 public immutable pool;\n\n    // Address of native asset (USDV or Vader).\n    IERC20 public immutable nativeAsset;\n\n    // Address of reserve contract.\n    IVaderReserve public reserve;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialises contract by setting pool and native asset addresses.\n     *\n     * Native assets address is taken from param {_pool} and native asset's address\n     * is retrieved from {VaderPoolV2} contract.\n     **/\n    constructor(IVaderPoolV2 _pool) {\n        require(\n            _pool != IVaderPoolV2(_ZERO_ADDRESS),\n            \"VaderRouterV2::constructor: Incorrect Arguments\"\n        );\n\n        pool = _pool;\n        nativeAsset = pool.nativeAsset();\n    }\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows adding of liquidity to the Vader pool.\n     *\n     * Internally calls {addLiquidity} function.\n     *\n     * Returns the amount of liquidity minted.\n     **/\n    // NOTE: For Uniswap V2 compliancy, necessary due to stack too deep\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256, // amountAMin = unused\n        uint256, // amountBMin = unused\n        address to,\n        uint256 deadline\n    ) external override returns (uint256 liquidity) {\n        return\n            addLiquidity(\n                tokenA,\n                tokenB,\n                amountADesired,\n                amountBDesired,\n                to,\n                deadline\n            );\n    }\n\n    /*\n     * @dev Allows adding of liquidity to the Vader pool.\n     *\n     * Calls `mint` function on the {BasePoolV2} contract.\n     *\n     * Pair is determined based {tokenA} and {tokenB} where one of them represents\n     * native asset and the other one represents foreign asset.\n     *\n     * Returns the amount of liquidity units minted against a pair.\n     *\n     * Requirements:\n     * - The current timestamp has not exceeded the param {deadline}.\n     * - Amongst {tokenA} and {tokenB}, one should be the native asset and the other\n     *   one must be the foreign asset.\n     * - The foreign asset among {tokenA} and {tokenB} must be a supported token.\n     **/\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        address to,\n        uint256 deadline\n    ) public override ensure(deadline) returns (uint256 liquidity) {\n        IERC20 foreignAsset;\n        uint256 nativeDeposit;\n        uint256 foreignDeposit;\n\n        if (tokenA == nativeAsset) {\n            require(\n                pool.supported(tokenB),\n                \"VaderRouterV2::addLiquidity: Unsupported Assets Specified\"\n            );\n            foreignAsset = tokenB;\n            foreignDeposit = amountBDesired;\n            nativeDeposit = amountADesired;\n        } else {\n            require(\n                tokenB == nativeAsset && pool.supported(tokenA),\n                \"VaderRouterV2::addLiquidity: Unsupported Assets Specified\"\n            );\n            foreignAsset = tokenA;\n            foreignDeposit = amountADesired;\n            nativeDeposit = amountBDesired;\n        }\n\n        liquidity = pool.mint(\n            foreignAsset,\n            nativeDeposit,\n            foreignDeposit,\n            msg.sender,\n            to\n        );\n    }\n\n    /*\n     * @dev Allows removing of liquidity by {msg.sender} and transfers the\n     * underlying assets to {to} address.\n     *\n     * The liquidity is removed from a pair represented by {tokenA} and {tokenB}.\n     *\n     * Transfers the NFT with Id {id} representing user's position, to the pool address,\n     * so the pool is able to burn it in the `burn` function call.\n     *\n     * Calls the `burn` function on the pool contract.\n     *\n     * Calls the `reimburseImpermanentLoss` on reserve contract to cover impermanent loss\n     * for the liquidity being removed.\n     *\n     * Requirements:\n     * - The underlying assets amounts of {amountA} and {amountB} must\n     *   be greater than or equal to {amountAMin} and {amountBMin}, respectively.\n     * - The current timestamp has not exceeded the param {deadline}.\n     * - Either of {tokenA} or {tokenB} should be a native asset and the other one\n     *   must be the foreign asset associated with the NFT representing liquidity.\n     **/\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 id,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        public\n        override\n        ensure(deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        IERC20 _foreignAsset = pool.positionForeignAsset(id);\n        IERC20 _nativeAsset = nativeAsset;\n\n        bool isNativeA = _nativeAsset == IERC20(tokenA);\n\n        if (isNativeA) {\n            require(\n                IERC20(tokenB) == _foreignAsset,\n                \"VaderRouterV2::removeLiquidity: Incorrect Addresses Specified\"\n            );\n        } else {\n            require(\n                IERC20(tokenA) == _foreignAsset &&\n                    IERC20(tokenB) == _nativeAsset,\n                \"VaderRouterV2::removeLiquidity: Incorrect Addresses Specified\"\n            );\n        }\n\n        pool.transferFrom(msg.sender, address(pool), id);\n\n        (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        ) = pool.burn(id, to);\n\n        (amountA, amountB) = isNativeA\n            ? (amountNative, amountForeign)\n            : (amountForeign, amountNative);\n\n        require(\n            amountA >= amountAMin,\n            \"VaderRouterV2: INSUFFICIENT_A_AMOUNT\"\n        );\n        require(\n            amountB >= amountBMin,\n            \"VaderRouterV2: INSUFFICIENT_B_AMOUNT\"\n        );\n\n        reserve.reimburseImpermanentLoss(msg.sender, coveredLoss);\n    }\n\n    /*\n     * @dev Allows swapping of exact source token amount to destination\n     * token amount.\n     *\n     * Internally calls {_swap} function.\n     *\n     * Requirements:\n     * - The destination amount {amountOut} must greater than or equal to param {amountOutMin}.\n     * - The current timestamp has not exceeded the param {deadline}.\n     **/\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256 amountOut) {\n        amountOut = _swap(amountIn, path, to);\n\n        require(\n            amountOut >= amountOutMin,\n            \"VaderRouterV2::swapExactTokensForTokens: Insufficient Trade Output\"\n        );\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /*\n    * @dev Sets the reserve address and renounces contract's ownership.\n     *\n     * Requirements:\n     * - Only existing owner can call this function.\n     * - Param {_reserve} cannot be a zero address.\n     **/\n    function initialize(IVaderReserve _reserve) external onlyOwner {\n        require(\n            _reserve != IVaderReserve(_ZERO_ADDRESS),\n            \"VaderRouterV2::initialize: Incorrect Reserve Specified\"\n        );\n\n        reserve = _reserve;\n\n        renounceOwnership();\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows swapping of assets from within a single Vader pool pair or\n     * across two different Vader pairs.\n     *\n     * In case of a single Vader pair, the native asset can be swapped for foreign\n     * asset and vice versa.\n     *\n     * In case of two Vader pairs, the foreign asset is swapped for native asset from\n     * the first Vader pool and the native asset retrieved from the first Vader pair is swapped\n     * for foreign asset from the second Vader pair.\n     *\n     * Requirements:\n     * - Param {path} length can be either 2 or 3.\n     * - If the {path} length is 3 the index 0 and 1 must contain foreign assets' addresses\n     *   and index 1 must contain native asset's address.\n     * - If the {path} length is 2 then either of indexes must contain foreign asset's address\n     *   and the other one must contain native asset's address.\n     **/\n    function _swap(\n        uint256 amountIn,\n        IERC20[] calldata path,\n        address to\n    ) private returns (uint256 amountOut) {\n        if (path.length == 3) {\n            require(\n                path[0] != path[1] &&\n                    path[1] == pool.nativeAsset() &&\n                    path[2] != path[1],\n                \"VaderRouterV2::_swap: Incorrect Path\"\n            );\n\n            path[0].safeTransferFrom(msg.sender, address(pool), amountIn);\n\n            return pool.doubleSwap(path[0], path[2], amountIn, to);\n        } else {\n            require(\n                path.length == 2,\n                \"VaderRouterV2::_swap: Incorrect Path Length\"\n            );\n            IERC20 _nativeAsset = nativeAsset;\n            require(path[0] != path[1], \"VaderRouterV2::_swap: Incorrect Path\");\n\n            path[0].safeTransferFrom(msg.sender, address(pool), amountIn);\n            if (path[0] == _nativeAsset) {\n                return pool.swap(path[1], amountIn, 0, to);\n            } else {\n                require(\n                    path[1] == _nativeAsset,\n                    \"VaderRouterV2::_swap: Incorrect Path\"\n                );\n                return pool.swap(path[0], 0, amountIn, to);\n            }\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    // Guard ensuring that the current timestamp has not exceeded the param {deadline}.\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"VaderRouterV2::ensure: Expired\");\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "VaderRouter.sol",
            "VaderRouterV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaderRouter and VaderRouterV2 contract",
                "Type": "Sandwich Attack",
                "Description": "'addLiquidity' in the VaderRouter and VaderRouterV2 contract does not check the minimum liquidity amount. This makes users' funds vulnerable to sandwich attacks.",
                "Repair": "Always check how much liquidity a user received in a transaction"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"./VaderPool.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../../interfaces/shared/IERC20Extended.sol\";\nimport \"../../interfaces/dex/pool/IVaderPoolFactory.sol\";\n\n/*\n * @dev Implementation of {VaderPoolFactory} contract.\n *\n * The VaderPoolFactory contract inherits from {Ownable} and {ProtocolConstants} contracts.\n *\n * Keeps track of all the created Vader pools through {getPool} mapping and\n * {allPools} array. Also stores the address of asset used as native asset\n * across all of the Vader pools created through the factory.\n *\n * Allows creation of new Vader pools.\n **/\ncontract VaderPoolFactory is IVaderPoolFactory, ProtocolConstants, Ownable {\n    /* ========== STATE VARIABLES ========== */\n\n    // Denotes whether the queue system is active on new pairs, disabled by default\n    bool public queueActive;\n\n    // Native Asset of the system\n    address public override nativeAsset;\n\n    // Token A -> Token B -> Pool mapping\n    mapping(address => mapping(address => IVaderPool)) public override getPool;\n\n    // A list of all pools\n    IVaderPool[] public allPools;\n\n    /* ========== VIEWS ========== */\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows creation of a Vader pool of native and foreign assets.\n     *\n     * Populates the {getPool} mapping with the newly created Vader pool and\n     * pushes this pool to {allPools} array.\n     *\n     * Requirements:\n     * - Native and foreign assets cannot be the same.\n     * - Foreign asset cannot be the zero address.\n     * - The pool against the specified foreign asset does not already exist.\n     **/\n    // NOTE: Between deployment & initialization may be corrupted but chance small\n    function createPool(address tokenA, address tokenB)\n        external\n        override\n        returns (IVaderPool pool)\n    {\n        (address token0, address token1) = tokenA == nativeAsset\n            ? (tokenA, tokenB)\n            : tokenB == nativeAsset\n            ? (tokenB, tokenA)\n            : (_ZERO_ADDRESS, _ZERO_ADDRESS);\n\n        require(\n            token0 != token1,\n            \"VaderPoolFactory::createPool: Identical Tokens\"\n        );\n\n        require(\n            token1 != _ZERO_ADDRESS,\n            \"VaderPoolFactory::createPool: Inexistent Token\"\n        );\n\n        require(\n            getPool[token0][token1] == IVaderPool(_ZERO_ADDRESS),\n            \"VaderPoolFactory::createPool: Pair Exists\"\n        ); // single check is sufficient\n\n        pool = new VaderPool(\n            queueActive,\n            IERC20Extended(token0),\n            IERC20Extended(token1)\n        );\n        getPool[token0][token1] = pool;\n        getPool[token1][token0] = pool; // populate mapping in the reverse direction\n        allPools.push(pool);\n        emit PoolCreated(token0, token1, pool, allPools.length);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /*\n     * @dev Allows initializing of the factory contract by owner by setting the\n     * address of native asset for all the Vader pool and also transferring the\n     * contract's ownership to {_dao}.\n     *\n     * Requirements:\n     * - Only onwer can call this function.\n     **/\n    function initialize(address _nativeAsset, address _dao) external onlyOwner {\n        require(\n            _nativeAsset != _ZERO_ADDRESS && _dao != _ZERO_ADDRESS,\n            \"VaderPoolFactory::initialize: Incorrect Arguments\"\n        );\n\n        nativeAsset = _nativeAsset;\n        transferOwnership(_dao);\n    }\n\n    /*\n     * @dev Allows toggling of queue system of a pool.\n     *\n     * Requirements:\n     * - This function can only be called when DAO is active.\n     **/\n    function toggleQueue(address token0, address token1) external onlyDAO {\n        getPool[token0][token1].toggleQueue();\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Ensures only the DAO is able to invoke a particular function by validating that\n     * the owner is the msg.sender, equivalent to the DAO address, and that the native asset\n     * has been set\n     */\n    function _onlyDAO() private view {\n        require(\n            nativeAsset != _ZERO_ADDRESS && owner() == _msgSender(),\n            \"BasePool::_onlyDAO: Insufficient Privileges\"\n        );\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /**\n     * @dev Throws if invoked by anyone else other than the DAO\n     */\n    modifier onlyDAO() {\n        _onlyDAO();\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./BasePoolV2.sol\";\n\nimport \"../../interfaces/shared/IERC20Extended.sol\";\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\nimport \"../../interfaces/dex-v2/wrapper/ILPWrapper.sol\";\nimport \"../../interfaces/dex-v2/synth/ISynthFactory.sol\";\n\n/*\n * @dev Implementation of {VaderPoolV2} contract.\n *\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\n * queue system.\n *\n * Extends on the liquidity redeeming function by introducing the `burn` function\n * that internally calls the namesake on `BasePoolV2` contract and computes the\n * loss covered by the position being redeemed and returns it along with amounts\n * of native and foreign assets sent.\n **/\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The LP wrapper contract\n    ILPWrapper public wrapper;\n\n    // The Synth Factory\n    ISynthFactory public synthFactory;\n\n    // Denotes whether the queue system is active\n    bool public queueActive;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialised the contract state by passing the native asset's address\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\n     * to the {queueActive} state variable.\n     **/\n    constructor(bool _queueActive, IERC20 _nativeAsset)\n        BasePoolV2(_nativeAsset)\n    {\n        queueActive = _queueActive;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns cumulative prices and the timestamp the were last updated\n     * for both native and foreign assets against the pair specified by\n     * parameter {foreignAsset}.\n     **/\n    function cumulativePrices(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint256 price0CumulativeLast,\n            uint256 price1CumulativeLast,\n            uint32 blockTimestampLast\n        )\n    {\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\n            .priceCumulative;\n        price0CumulativeLast = priceCumulative.nativeLast;\n        price1CumulativeLast = priceCumulative.foreignLast;\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Initializes contract's state with LP wrapper, synth factory\n     * and router addresses.\n     *\n     * Requirements:\n     * - None of the parameters are zero addresses.\n     * - The parameters are not already set.\n     * - Only callable by contract owner.\n     **/\n    function initialize(\n        ILPWrapper _wrapper,\n        ISynthFactory _synthFactory,\n        address _router\n    ) external onlyOwner {\n        require(\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Already initialized\"\n        );\n        require(\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\n        );\n        require(\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\n        );\n        require(\n            _router != _ZERO_ADDRESS,\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\n        );\n        wrapper = _wrapper;\n        synthFactory = _synthFactory;\n        router = _router;\n    }\n\n    /*\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\n     * on the native asset amount deposited and returns the minted synth asset amount.\n     *\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must be a supported token.\n     **/\n    function mintSynth(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        supportedToken(foreignAsset)\n        returns (uint256 amountSynth)\n    {\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        if (synth == ISynth(_ZERO_ADDRESS))\n            synth = synthFactory.createSynth(\n                IERC20Extended(address(foreignAsset))\n            );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountSynth = VaderMath.calculateSwap(\n            nativeDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        synth.mint(to, amountSynth);\n    }\n\n    /*\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\n     * and returns the redeemed amount of native asset.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must have a valid synthetic asset against it.\n     * - {synthAmount} must be greater than zero.\n     **/\n    function burnSynth(\n        IERC20 foreignAsset,\n        uint256 synthAmount,\n        address to\n    ) external override nonReentrant returns (uint256 amountNative) {\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        require(\n            synth != ISynth(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\n        );\n\n        require(\n            synthAmount > 0,\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\n        );\n\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\n        synth.burn(synthAmount);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountNative = VaderMath.calculateSwap(\n            synthAmount,\n            reserveForeign,\n            reserveNative\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        nativeAsset.safeTransfer(to, amountNative);\n    }\n\n    /*\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\n     *\n     * Deletes the position in {positions} mapping against the burned NFT token.\n     *\n     * Internally calls `_burn` function on {BasePoolV2} contract.\n     *\n     * Calculates the impermanent loss incurred by the position.\n     *\n     * Returns the amounts for native and foreign assets sent to the {to} address\n     * along with the covered loss.\n     *\n     * Requirements:\n     * - Can only be called by the Router.\n     **/\n    // NOTE: IL is only covered via router!\n    function burn(uint256 id, address to)\n        external\n        override\n        onlyRouter\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n\n        // NOTE: Validate it behaves as expected for non-18 decimal tokens\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n\n        // TODO: Original Implementation Applied 100 Days\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n\n    /*\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\n     * tracked within this contract along with liquidity issued against non-fungible\n     * token.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'mint' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     **/\n    function mintFungible(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override nonReentrant returns (uint256 liquidity) {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\n        );\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        lp.mint(to, liquidity);\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n    }\n\n    /*\n     * @dev Allows burning of liquidity issued in fungible tokens.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'burn' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\n     **/\n    function burnFungible(\n        IERC20 foreignAsset,\n        uint256 liquidity,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\n        );\n\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\n        lp.burn(liquidity);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // TODO: Investigate Necessity\n    function toggleQueue() external override onlyOwner {\n        bool _queueActive = !queueActive;\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setTokenSupport(IERC20 foreignAsset, bool support)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            supported[foreignAsset] != support,\n            \"VaderPoolV2::supportToken: Already At Desired State\"\n        );\n        supported[foreignAsset] = support;\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setFungibleTokenSupport(IERC20 foreignAsset)\n        external\n        override\n        onlyOwner\n    {\n        wrapper.createWrapper(foreignAsset);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n\n",
        "CodeNames": [
            "VaderPoolFactory.sol",
            "VaderPoolV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaderPoolFactory.sol#L43-L89, VaderPoolV2.sol#L115-L167",
                "Type": "Attacker can get extremely cheap synth by front-running create Pool",
                "Description": "The attacker can create the pool and set it to be extremely cheap. (By depositing 1 wei coin and 10^18 wei Vader.) The attacker can mint a lot of synth by providing another 10^18 wei Vader.",
                "Repair": "Decide minimum liquidity for a synthetic asset (e.g 1M Vader in the pool). Once there's enough liquidity pool, anyone can deploy a synthetic asset after a cool down. (e.g. 3 days)."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../../interfaces/tokens/vesting/ILinearVesting.sol\";\n\n/**\n * @dev Implementation of the {ILinearVesting} interface.\n *\n * The straightforward vesting contract that gradually releases a\n * fixed supply of tokens to multiple vest parties over a 2 year\n * window.\n *\n * The token expects the {begin} hook to be invoked the moment\n * it is supplied with the necessary amount of tokens to vest,\n * which should be equivalent to the time the {setComponents}\n * function is invoked on the Vader token.\n */\ncontract LinearVesting is ILinearVesting, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe VADER transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The Vader token\n    IERC20 public immutable vader;\n\n    // The start of the vesting period\n    uint256 public start;\n\n    // The end of the vesting period\n    uint256 public end;\n\n    // The status of each vesting member (Vester)\n    mapping(address => Vester) public vest;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /**\n     * @dev Initializes the contract's vesters and vesting amounts as well as sets\n     * the Vader token address.\n     *\n     * It conducts a sanity check to ensure that the total vesting amounts specified match\n     * the team allocation to ensure that the contract is deployed correctly.\n     *\n     * Additionally, it transfers ownership to the Vader contract that needs to consequently\n     * initiate the vesting period via {begin} after it mints the necessary amount to the contract.\n     */\n    constructor(\n        IERC20 _vader,\n        address[] memory vesters,\n        uint192[] memory amounts\n    ) {\n        require(\n            _vader != IERC20(_ZERO_ADDRESS) && vesters.length == amounts.length,\n            \"LinearVesting::constructor: Misconfiguration\"\n        );\n\n        vader = _vader;\n\n        uint256 total;\n        for (uint256 i = 0; i < vesters.length; i++) {\n            require(\n                amounts[i] != 0,\n                \"LinearVesting::constructor: Incorrect Amount Specified\"\n            );\n            vest[vesters[i]].amount = amounts[i];\n            total = total + amounts[i];\n        }\n        require(\n            total == _TEAM_ALLOCATION,\n            \"LinearVesting::constructor: Invalid Vest Amounts Specified\"\n        );\n\n        transferOwnership(address(_vader));\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @dev Returns the amount a user can claim at a given point in time.\n     *\n     * Requirements:\n     * - the vesting period has started\n     */\n    function getClaim()\n        external\n        view\n        override\n        hasStarted\n        returns (uint256 vestedAmount)\n    {\n        Vester memory vester = vest[msg.sender];\n        return _getClaim(vester.amount, vester.lastClaim);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @dev Allows a user to claim their pending vesting amount.\n     *\n     * Emits a {Vested} event indicating the user who claimed their vested tokens\n     * as well as the amount that was vested.\n     *\n     * Requirements:\n     *\n     * - the vesting period has started\n     * - the caller must have a non-zero vested amount\n     */\n    function claim()\n        external\n        override\n        hasStarted\n        returns (uint256 vestedAmount)\n    {\n        Vester memory vester = vest[msg.sender];\n\n        require(\n            vester.start == 0,\n            \"LinearVesting::claim: Incorrect Vesting Type\"\n        );\n\n        vestedAmount = _getClaim(vester.amount, vester.lastClaim);\n\n        require(vestedAmount != 0, \"LinearVesting::claim: Nothing to claim\");\n\n        vester.amount -= uint192(vestedAmount);\n        vester.lastClaim = uint64(block.timestamp);\n\n        vest[msg.sender] = vester;\n\n        emit Vested(msg.sender, vestedAmount);\n\n        vader.safeTransfer(msg.sender, vestedAmount);\n    }\n\n    /**\n     * @dev Allows a user to claim their pending vesting amount of the vested claim\n     *\n     * Emits a {Vested} event indicating the user who claimed their vested tokens\n     * as well as the amount that was vested.\n     *\n     * Requirements:\n     *\n     * - the vesting period has started\n     * - the caller must have a non-zero vested amount\n     */\n    function claimConverted() external override returns (uint256 vestedAmount) {\n        Vester memory vester = vest[msg.sender];\n\n        require(\n            vester.start != 0,\n            \"LinearVesting::claim: Incorrect Vesting Type\"\n        );\n\n        require(\n            vester.start < block.timestamp,\n            \"LinearVesting::claim: Not Started Yet\"\n        );\n\n        vestedAmount = _getClaim(\n            vester.amount,\n            vester.lastClaim,\n            vester.start,\n            vester.end\n        );\n\n        require(vestedAmount != 0, \"LinearVesting::claim: Nothing to claim\");\n\n        vester.amount -= uint192(vestedAmount);\n        vester.lastClaim = uint64(block.timestamp);\n\n        vest[msg.sender] = vester;\n\n        emit Vested(msg.sender, vestedAmount);\n\n        vader.safeTransfer(msg.sender, vestedAmount);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /**\n     * @dev Allows the vesting period to be initiated.\n     *\n     * Emits a {VestingInitialized} event from which the start and\n     * end can be calculated via it's attached timestamp.\n     *\n     * Requirements:\n     *\n     * - the caller must be the owner (vader token)\n     */\n    function begin() external override onlyOwner {\n        start = block.timestamp;\n        end = block.timestamp + _VESTING_DURATION;\n\n        emit VestingInitialized(_VESTING_DURATION);\n\n        renounceOwnership();\n    }\n\n    /**\n     * @dev Adds a new vesting schedule to the contract\n     */\n    function vestFor(address user, uint256 amount) external override {\n        require(\n            vest[user].amount == 0,\n            \"LinearVesting::selfVest: Already a vester\"\n        );\n        vest[user] = Vester(\n            uint192(amount),\n            0,\n            uint128(block.timestamp),\n            uint128(block.timestamp + 365 days)\n        );\n        vader.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the amount a user's vest is due. To calculate,\n     * the following formula is utilized:\n     *\n     * - (remainingAmount * timeElapsed) / timeUntilEnd\n     *\n     * Each variable is described as follows:\n     *\n     * - remainingAmount (amount): Vesting amount remaining. Each claim subtracts from\n     * this amount to ensure calculations are properly conducted.\n     *\n     * - timeElapsed (block.timestamp.sub(lastClaim)): Time that has elapsed since the\n     * last claim.\n     *\n     * - timeUntilEnd (end.sub(lastClaim)): Time remaining for the particular vesting\n     * member's total duration.\n     *\n     * Vesting calculations are relative and always update the last\n     * claim timestamp as well as remaining amount whenever they\n     * are claimed.\n     */\n    function _getClaim(uint256 amount, uint256 lastClaim)\n        private\n        view\n        returns (uint256)\n    {\n        uint256 _end = end;\n\n        if (block.timestamp >= _end) return amount;\n        if (lastClaim == 0) lastClaim = start;\n\n        return (amount * (block.timestamp - lastClaim)) / (_end - lastClaim);\n    }\n\n    /**\n     * @dev Calculates the amount a user's vest is due. To calculate,\n     * the following formula is utilized:\n     *\n     * - (remainingAmount * timeElapsed) / timeUntilEnd\n     *\n     * Each variable is described as follows:\n     *\n     * - remainingAmount (amount): Vesting amount remaining. Each claim subtracts from\n     * this amount to ensure calculations are properly conducted.\n     *\n     * - timeElapsed (block.timestamp.sub(lastClaim)): Time that has elapsed since the\n     * last claim.\n     *\n     * - timeUntilEnd (end.sub(lastClaim)): Time remaining for the particular vesting\n     * member's total duration.\n     *\n     * Vesting calculations are relative and always update the last\n     * claim timestamp as well as remaining amount whenever they\n     * are claimed.\n     */\n    function _getClaim(\n        uint256 amount,\n        uint256 lastClaim,\n        uint256 _start,\n        uint256 _end\n    ) private view returns (uint256) {\n        if (block.timestamp >= _end) return amount;\n        if (lastClaim == 0) lastClaim = _start;\n\n        return (amount * (block.timestamp - lastClaim)) / (_end - lastClaim);\n    }\n\n    /**\n     * @dev Validates that the vesting period has started\n     */\n    function _hasStarted() private view {\n        require(\n            start != 0,\n            \"LinearVesting::_hasStarted: Vesting hasn't started yet\"\n        );\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /**\n     * @dev Throws if the vesting period hasn't started\n     */\n    modifier hasStarted() {\n        _hasStarted();\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "LinearVesting.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LinearVesting.vestFor",
                "Type": "Vests can be denied",
                "Description": "There's an attack where a griefer frontruns the vestFor call and instead vests the smallest unit of VADER for the user.",
                "Repair": "Allow several separate vestings per user."
            },
            {
                "Location": "LinearVesting.sol:L158",
                "Type": "Medium Severity",
                "Description": "Missing hasStarted modifier can lead to user vesting before the owner begins the vesting.",
                "Repair": "Add hasStarted modifier"
            },
            {
                "Location": "LinearVesting.sol",
                "Type": "Incorrect Calculation",
                "Description": "LinearVesting does not calculate vested amount linearly.",
                "Repair": "Change the formula to User total amount * (block.timestamp \u2013 start) / (vesting duration) \u2013 user claimed amount."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../math/VaderMath.sol\";\n// import \"../queue/SwapQueue.sol\";\nimport \"../utils/GasThrottle.sol\";\n\nimport \"../../external/libraries/UQ112x112.sol\";\n\nimport \"../../interfaces/dex/pool/IBasePool.sol\";\nimport \"../../interfaces/shared/IERC20Extended.sol\";\n\n/*\n * @dev Implementation of {BasePool} contract.\n *\n * The BasePool contract represents pool of two assets termed as native and\n * foreign assets. The functionality in this contract allows depositing of both\n * of these assets to mint liquidity. Minted liquidity is associated with a\n * position which is represented by an NFT token.\n *\n * The contract allows burning of NFT and in turn redeems the associated liquidity,\n * transferring out underlying assets to the LP.\n *\n * The contract allows swapping of both native and foreign assets among themselves.\n *\n * Keeps track of the cumulative prices for both native and foreign assets and updates\n * them after minting and burning of liquidity, and swapping of assets.\n **/\ncontract BasePool is IBasePool, GasThrottle, ERC721, Ownable, ReentrancyGuard {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    // Used by Uniswap-like TWAP mechanism\n    using UQ112x112 for uint224;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of native asset (Vader or USDV).\n    IERC20 public immutable nativeAsset;\n\n    // Address of foreign asset with which the native asset is paired in the pool.\n    IERC20 public immutable foreignAsset;\n\n    // Cumulative price of native asset.\n    uint256 public priceNativeCumulativeLast;\n\n    // Cumulative price of foreign asset.\n    uint256 public priceForeignCumulativeLast;\n\n    /*\n     * @dev A mapping representing positions of liquidity providers. Each position\n     * is an Non-fungible token that is mapped against amounts of native and foreign assets\n     * deposited, the timestamp at which the position is created and the amount of\n     * liquidity assigned to the LP.\n     *\n     * Each position in the mapping is mapped against {positionId}.\n     **/\n    mapping(uint256 => Position) public positions;\n\n    // A unique id the of the position created when liquidity is added to the pool.\n    uint256 public positionId;\n\n    // Total amount of liquidity units minted.\n    uint256 public totalSupply;\n\n    // Name of the contract.\n    string private _name;\n\n    // Total amount of the native asset realised by the contract.\n    uint112 private _reserveNative; // uses single storage slot, accessible via getReserves\n\n    // Total amount of the foreign asset realised by the contract.\n    uint112 private _reserveForeign; // uses single storage slot, accessible via getReserves\n\n    // Last timestamp at which the cumulative prices for native and foreign assets were updated.\n    uint32 private _blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialized the contract state setting the addresses for native and foreign assets.\n     *\n     * Also computes the name of the contract and stores it in the contract's state.\n     **/\n    constructor(IERC20Extended _nativeAsset, IERC20Extended _foreignAsset)\n        ERC721(\"Vader LP\", \"VLP\")\n    {\n        nativeAsset = IERC20(_nativeAsset);\n        foreignAsset = IERC20(_foreignAsset);\n\n        string memory calculatedName = string(\n            abi.encodePacked(\"Vader USDV /\", _foreignAsset.symbol(), \" LP\")\n        );\n        _name = calculatedName;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns the realised amount of native and foreign assets, and the last timestamp\n     * at which the cumulative prices for native and foreign assets were updated.\n     **/\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 reserveNative,\n            uint112 reserveForeign,\n            uint32 blockTimestampLast\n        )\n    {\n        reserveNative = _reserveNative;\n        reserveForeign = _reserveForeign;\n        blockTimestampLast = _blockTimestampLast;\n    }\n\n    // Returns the name of the contract.\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows depositing of liquidity to the pool by accepting native and foreign assets\n     * and mints an NFT to the {to} address which records the amounts of the native and foreign\n     * assets deposited and the liquidity units minted against it in {positions} mapping.\n     *\n     * Updates the total supply of liquidity units by adding currently minted liquidity units\n     * to {totalSupply}.\n     *\n     * Updates the cumulative prices of native and foreign assets after minting the appropriate\n     * liquidity units.\n     *\n     * Requirements:\n     * - Amounts of native and foreign must be sent to the pool prior to calling `mint` such that\n     *   balance of pool for both assets must be greater than their corresponding reserves.\n     * - The amount of {liquidity} to be minted must be greater than 0.\n     **/\n    function mint(address to)\n        external\n        override\n        nonReentrant\n        returns (uint256 liquidity)\n    {\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        uint256 balanceNative = nativeAsset.balanceOf(address(this));\n        uint256 balanceForeign = foreignAsset.balanceOf(address(this));\n        uint256 nativeDeposit = balanceNative - reserveNative;\n        uint256 foreignDeposit = balanceForeign - reserveForeign;\n\n        uint256 totalLiquidityUnits = totalSupply;\n        if (totalLiquidityUnits == 0)\n            liquidity = nativeDeposit; // TODO: Contact ThorChain on proper approach\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"BasePool::mint: Insufficient Liquidity Provided\"\n        );\n\n        uint256 id = positionId++;\n\n        totalSupply += liquidity;\n        _mint(to, id);\n\n        positions[id] = Position(\n            block.timestamp,\n            liquidity,\n            nativeDeposit,\n            foreignDeposit\n        );\n\n        _update(balanceNative, balanceForeign, reserveNative, reserveForeign);\n\n        emit Mint(msg.sender, to, nativeDeposit, foreignDeposit);\n        emit PositionOpened(msg.sender, id, liquidity);\n    }\n\n    /*\n     * @dev Allows redeeming of liquidity units by burning the NFT associated with the liquidity\n     * position.\n     *\n     * Computes the amounts of native and foreign assets depending upon current reserves of assets and\n     * the liquidity associated with the position, and transfers them to the {to} address.\n     *\n     * Burns the redeemed NFT token and decreases {totalSupply} by the {liquidity}\n     * associated with that NFT token.\n     *\n     * Updates the cumulative prices for native and foreign assets after transferring the assets\n     * to the {to} address.\n     *\n     * Requirements:\n     * - The NFT token being redeemed must be transferred to the pool prior to calling `_burn`.\n     * - The amount of native and foreign assets computed for transfer to {to} address must be greater\n     *   than 0.\n     **/\n    function _burn(uint256 id, address to)\n        internal\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        require(\n            ownerOf(id) == address(this),\n            \"BasePool::burn: Incorrect Ownership\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(); // gas savings\n        IERC20 _nativeAsset = nativeAsset; // gas savings\n        IERC20 _foreignAsset = foreignAsset; // gas savings\n        uint256 nativeBalance = IERC20(_nativeAsset).balanceOf(address(this));\n        uint256 foreignBalance = IERC20(_foreignAsset).balanceOf(address(this));\n\n        uint256 liquidity = positions[id].liquidity;\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amountNative = (liquidity * nativeBalance) / _totalSupply; // using balances ensures pro-rata distribution\n        amountForeign = (liquidity * foreignBalance) / _totalSupply; // using balances ensures pro-rata distribution\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"BasePool::burn: Insufficient Liquidity Burned\"\n        );\n\n        totalSupply -= liquidity;\n        _burn(id);\n\n        _nativeAsset.safeTransfer(to, amountNative);\n        _foreignAsset.safeTransfer(to, amountForeign);\n\n        nativeBalance = _nativeAsset.balanceOf(address(this));\n        foreignBalance = _foreignAsset.balanceOf(address(this));\n\n        _update(nativeBalance, foreignBalance, reserveNative, reserveForeign);\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /*\n     * @dev  Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Internally calls {swap} function.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to,\n        bytes calldata\n    ) external override returns (uint256) {\n        return swap(nativeAmountIn, foreignAmountIn, to);\n    }\n\n    /*\n     * @dev Allows swapping between native and foreign assets. It receives the source asset\n     * and computes the destination asset and transfers it to the {to} address.\n     *\n     * Updates the cumulative prices for native and foreign assets after performing swap.\n     *\n     * Returns the amount of destination tokens resulting from the swap.\n     *\n     * Requirements:\n     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero\n     *   if the destination asset in swap is native asset.\n     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero\n     *   if the destination asset in swap is foreign asset.\n     * - Param {to} cannot be the addresses of native or foreign assets.\n     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.\n     * - The source asset amount in the swap cannot exceed the source asset's reserve.\n     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination\n     *   asset's reserve.\n     **/\n    function swap(\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to\n    ) public override nonReentrant validateGas returns (uint256) {\n        require(\n            (nativeAmountIn > 0 && foreignAmountIn == 0) ||\n                (nativeAmountIn == 0 && foreignAmountIn > 0),\n            \"BasePool::swap: Only One-Sided Swaps Supported\"\n        );\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(); // gas savings\n\n        uint256 nativeBalance;\n        uint256 foreignBalance;\n        uint256 nativeAmountOut;\n        uint256 foreignAmountOut;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            IERC20 _nativeAsset = nativeAsset;\n            IERC20 _foreignAsset = foreignAsset;\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n\n            require(\n                to != address(_nativeAsset) && to != address(_foreignAsset),\n                \"BasePool::swap: Invalid Receiver\"\n            );\n\n            if (foreignAmountIn > 0) {\n                require(\n                    foreignAmountIn <= foreignBalance - foreignReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    foreignAmountIn <= foreignReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                nativeAmountOut = VaderMath.calculateSwap(\n                    foreignAmountIn,\n                    foreignReserve,\n                    nativeReserve\n                );\n\n                require(\n                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens\n            } else {\n                require(\n                    nativeAmountIn <= nativeBalance - nativeReserve,\n                    \"BasePool::swap: Insufficient Tokens Provided\"\n                );\n                require(\n                    nativeAmountIn <= nativeReserve,\n                    \"BasePool::swap: Unfavourable Trade\"\n                );\n\n                foreignAmountOut = VaderMath.calculateSwap(\n                    nativeAmountIn,\n                    nativeReserve,\n                    foreignReserve\n                );\n\n                require(\n                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n                    \"BasePool::swap: Swap Impossible\"\n                );\n\n                _foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens\n            }\n\n            nativeBalance = _nativeAsset.balanceOf(address(this));\n            foreignBalance = _foreignAsset.balanceOf(address(this));\n        }\n\n        _update(nativeBalance, foreignBalance, nativeReserve, foreignReserve);\n\n        emit Swap(\n            msg.sender,\n            nativeAmountIn,\n            foreignAmountIn,\n            nativeAmountOut,\n            foreignAmountOut,\n            to\n        );\n\n        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /*\n     * @dev Internally called to update the cumulative prices for native and foreign assets depending\n     * upon the last reserves and updates the reserves for both of the assets corresponding to their\n     * current balances along with the {_blockTimestampLast}.\n     *\n     * Requirements:\n     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.\n     *\n     **/\n    function _update(\n        uint256 balanceNative,\n        uint256 balanceForeign,\n        uint112 reserveNative,\n        uint112 reserveForeign\n    ) internal {\n        require(\n            balanceNative <= type(uint112).max &&\n                balanceForeign <= type(uint112).max,\n            \"BasePool::_update: Balance Overflow\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - _blockTimestampLast; // overflow is desired\n            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {\n                // * never overflows, and + overflow is desired\n                priceNativeCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)\n                    ) *\n                    timeElapsed;\n                priceForeignCumulativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)\n                    ) *\n                    timeElapsed;\n            }\n        }\n        _reserveNative = uint112(balanceNative);\n        _reserveForeign = uint112(balanceForeign);\n        _blockTimestampLast = blockTimestamp;\n        emit Sync(balanceNative, balanceForeign);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /* ========== MODIFIERS ========== */\n}\n\n\n",
        "CodeNames": [
            "BasePool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BasePool.sol:L161-L163",
                "Type": "High Severity",
                "Description": "The first liquidity takes the nativeDeposit amount and uses it directly, making it possible for a malicious user to add liquidity with only 1 wei USDV and making it nearly impossible for future users to add liquidity to the pool.",
                "Repair": "Lock some of the first minter's tokens by minting ~1% of the initial amount to the zero address instead of to the first minter"
            },
            {
                "Location": "BasePool.sol",
                "Type": "Front-running",
                "Description": "(dex-v1) BasePool.mint() function can be frontrun.",
                "Repair": "Include in the mint() function the transfer of _nativeAssets and _foreignAssets to the smart contract."
            },
            {
                "Location": "BasePool.sol",
                "Type": "BasePool.mint() Is Callable By Anyone",
                "Description": "The BasePool.mint() function differs from its implementation in BasePoolV2.mint() in which it lacks an onlyRouter modifier.",
                "Repair": "Add an onlyRouter modifier to the BasePool.mint() function to ensure users cannot directly call this function"
            },
            {
                "Location": "BasePool.swap() function",
                "Type": "Direct Function Invocation",
                "Description": "The BasePool.swap() function can be called directly by anyone, bypassing necessary input validation performed by VaderRouter._swap() function.",
                "Repair": "Add an 'onlyRouter' modifier to the BasePool.swap() function to ensure users cannot directly call it"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.9;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/governance/ITimelock.sol\";\nimport \"../interfaces/x-vader/IXVader.sol\";\n\n/**\n * @dev Implementation of {GovernorAlpha} contract.\n *\n * The GovernorAlpha contract allows creation of proposals by anyone\n * by depositing xVader (1000 xVader initially).\n *\n * Anyone can vote on the created proposals utilizing their xVader weight in\n * xVader contract.\n *\n * Only 1 proposal can be active at a time by a particular proposer.\n *\n * A proposal is queued when it succeeds and can be executed after a cool-off\n * time period specified by {delay} in the Timelock contract.\n *\n * A proposal can be cancelled by a {guardian} if it has not been already\n * executed.\n *\n * A proposal can be vetoed by {council} while its state is active/pending\n * and a proposal vetoed with success is also queued at the same time.\n */\ncontract GovernorAlpha {\n    // The name of this contract\n    string public constant name = \"Vader Governor Alpha\";\n\n    // The address of the Vader Protocol Timelock\n    ITimelock public timelock;\n\n    // The address of the Governor Guardian\n    address public guardian;\n\n    // The total number of proposals\n    uint256 public proposalCount;\n\n    // address of xVader token\n    IXVader public immutable xVader;\n\n    // address of fee receiver\n    address public feeReceiver;\n\n    // amount of fee deducted when proposing proposal\n    uint256 public feeAmount;\n\n    // address of council that is allowed to veto on proposals\n    address public council;\n\n    /**\n     * @dev {Proposal} struct contains parameters for a single proposal.\n     * id: Unique id for looking up a proposal.\n     * canceled: Flag marking whether the proposal has been canceled.\n     * executed: Flag marking whether the proposal has been executed.\n     * proposer: Creator of the proposal\n     * eta: The timestamp that the proposal will be available for execution, set once the vote succeeds\n     * targets: the ordered list of target addresses for calls to be made\n     * values: The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n     * signatures: The ordered list of function signatures to be called\n     * calldatas: The ordered list of calldata to be passed to each call\n     * startBlock: startBlock: The block at which voting begins: holders must delegate their votes prior to this block\n     * endBlock: The block at which voting ends: votes must be cast prior to this block\n     * forVotes: Current number of votes in favor of this proposal\n     * againstVotes: Current number of votes in opposition to this proposal\n     * receipts: Receipts of ballots for the entire set of voters\n     * vetoStatus: Veto status if the proposal has been vetoed by council in favor or against\n     */\n    struct Proposal {\n        uint256 id;\n        bool canceled;\n        bool executed;\n        address proposer;\n        uint256 eta;\n        address[] targets;\n        uint256[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint256 startBlock;\n        uint256 endBlock;\n        uint224 forVotes;\n        uint224 againstVotes;\n        VetoStatus vetoStatus;\n        mapping(address => Receipt) receipts;\n    }\n\n    /**\n     * @dev {Receipt} struct contains parameters for a voter against a particular proposal\n     * and is a ballot receipt record for a voter.\n     *\n     * hasVoted: Whether or not a vote has been casted\n     * support: Whether or not the voter supports the proposal\n     * votes: The number of votes the voter had, which were cast\n     */\n    struct Receipt {\n        bool hasVoted;\n        bool support;\n        uint224 votes;\n    }\n\n    /**\n     * @dev {VetoStatus} contains parameters representing if a proposal has been vetoed by council\n     *\n     * hasBeenVetoed: Whether proposal has been vetoed or not\n     * support: Whether veto is in favor or against of proposal\n     */\n    struct VetoStatus {\n        bool hasBeenVetoed;\n        bool support;\n    }\n\n    // Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    // The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    // The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    // The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\n            \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n        );\n\n    // The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH =\n        keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    // An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    // An event emitted when a vote has been cast on a proposal\n    event VoteCast(\n        address voter,\n        uint256 proposalId,\n        bool support,\n        uint256 votes\n    );\n\n    // An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    // An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    // An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    // An event emitted when fee receiver is changed\n    event FeeReceiverChanged(address oldFeeReceiver, address newFeeReceiver);\n\n    // An event emitted when fee amount is changed\n    event FeeAmountChanged(uint256 oldFeeAmount, uint256 newFeeAmount);\n\n    // An event emitted when a proposal has been vetoed by the council\n    event ProposalVetoed(uint256 proposalId, bool support);\n\n    // An event emitted when council is changed\n    event CouncilChanged(address oldCouncil, address newCouncil);\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /**\n     * @dev Initializes the contract's state setting xVader, fee receiver,\n     * council and guardian addresses along with the fee amount.\n     *\n     * It performs sanity checks for the address type parameters against zero\n     * address values.\n     */\n    constructor(\n        address guardian_,\n        address xVader_,\n        address feeReceiver_,\n        uint256 feeAmount_,\n        address council_\n    ) {\n        require(\n            xVader_ != address(0),\n            \"GovernorAlpha::constructor: xVader address is zero\"\n        );\n\n        require(\n            guardian_ != address(0) &&\n                feeReceiver_ != address(0) &&\n                council_ != address(0),\n            \"GovernorAlpha::constructor: guardian, feeReceiver or council cannot be zero\"\n        );\n\n        guardian = guardian_;\n        xVader = IXVader(xVader_);\n        feeReceiver = feeReceiver_;\n        feeAmount = feeAmount_;\n        council = council_;\n\n        emit FeeReceiverChanged(address(0), feeReceiver_);\n        emit FeeAmountChanged(0, feeAmount_);\n    }\n\n    /* ========== VIEWS ========== */\n\n    // The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes(uint256 blockNumber) public view returns (uint256) {\n        return (xVader.getPastTotalSupply(blockNumber) * 4) / 100; // 4% of xVader's supply at the time of proposal creation.\n    }\n\n    // The maximum number of actions that can be included in a proposal\n    function proposalMaxOperations() public pure returns (uint256) {\n        return 10; // 10 actions\n    }\n\n    // The delay before voting on a proposal may take place, once proposed\n    function votingDelay() public pure returns (uint256) {\n        return 1; // 1 block\n    }\n\n    // The duration of voting on a proposal, in blocks\n    function votingPeriod() public pure virtual returns (uint256) {\n        return 17280; // ~3 days in blocks (assuming 15s blocks)\n    }\n\n    /**\n     * @dev Returns the actions contained in a proposal with id {proposalId}.\n     */\n    function getActions(uint256 proposalId)\n        public\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    /**\n     * @dev Returns receipt of the {voter} against the proposal with id {proposalId}.\n     */\n    function getReceipt(uint256 proposalId, address voter)\n        public\n        view\n        returns (Receipt memory)\n    {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    /**\n     * @dev Returns the current state of the proposal with id {proposalId}.\n     *\n     * Requirements:\n     * - The {proposalId} should be greater than 0\n     * - The {proposalId} should be less than or equal to {proposalCount}\n     */\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > 0,\n            \"GovernorAlpha::state: invalid proposal id\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) return ProposalState.Canceled;\n\n        if (proposal.vetoStatus.hasBeenVetoed) {\n            // proposal has been vetoed\n            uint256 _eta = proposal.eta;\n\n            // proposal has been vetoed in favor, so considered succeeded\n            if (proposal.vetoStatus.support && _eta == 0)\n                return ProposalState.Succeeded;\n\n            // proposal has been vetoed against, so considered defeated\n            if (_eta == 0) return ProposalState.Defeated;\n        } else {\n            // proposal has not been vetoed, normal flow ensues\n            if (block.number <= proposal.startBlock)\n                return ProposalState.Pending;\n\n            if (block.number <= proposal.endBlock) return ProposalState.Active;\n\n            if (\n                proposal.forVotes <= proposal.againstVotes ||\n                proposal.forVotes < quorumVotes(proposal.startBlock)\n            ) return ProposalState.Defeated;\n\n            if (proposal.eta == 0) return ProposalState.Succeeded;\n        }\n\n        if (proposal.executed) return ProposalState.Executed;\n\n        if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD())\n            return ProposalState.Expired;\n\n        return ProposalState.Queued;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @dev Sets timelock state variable. Contracts {GovernorAlpha} and\n     * {Timelock} have circular dependencies upon each other and constructors\n     * cannot be used to set them, hence this function is introduced to set\n     * {Timelock} in {GovernorAlpha} after it has been deployed.\n     *\n     * Requirements:\n     * - only guardian can call this function\n     */\n    function setTimelock(address _timelock) external onlyGuardian {\n        require(\n            _timelock != address(0),\n            \"GovernorAlpha::initTimelock: _timelock cannot be zero address\"\n        );\n        timelock = ITimelock(_timelock);\n    }\n\n    /**\n     * @dev Allows any to make a proposal by depositing {feeAmount} xVader.\n     * It accepts targets along with the values, signature and calldatas\n     * for the actions to perform if the proposal succeeds.\n     *\n     * Requirements:\n     * - targets, values, signatures and calldatas arrays' lengths must be greater\n     *   than zero, less than {proposalMaxOperations} and are the same.\n     * - the caller must approve {feeAmount} xVader to this contract prior to call.\n     * - the caller must not have an active/pending proposal.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256 proposalId) {\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            \"GovernorAlpha::propose: proposal function information arity mismatch\"\n        );\n        require(\n            targets.length != 0,\n            \"GovernorAlpha::propose: must provide actions\"\n        );\n        require(\n            targets.length <= proposalMaxOperations(),\n            \"GovernorAlpha::propose: too many actions\"\n        );\n\n        xVader.transferFrom(msg.sender, feeReceiver, feeAmount);\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(\n                latestProposalId\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n            );\n        }\n\n        uint256 startBlock = block.number + votingDelay();\n        uint256 endBlock = startBlock + votingPeriod();\n\n        proposalId = ++proposalCount;\n        Proposal storage newProposal = proposals[proposalId];\n        newProposal.id = proposalId;\n        newProposal.proposer = msg.sender;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n\n        latestProposalIds[msg.sender] = proposalId;\n\n        emit ProposalCreated(\n            proposalId,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            startBlock,\n            endBlock,\n            description\n        );\n    }\n\n    /**\n     * @dev Queues a proposal by setting the hashes of its actions in {Timelock} contract.\n     * It also determines 'eta' for the proposal by adding timestamp to {delay} in {Timelock}\n     * and sets it against the proposal in question.\n     *\n     * Requirements:\n     * - the proposal in question must have succeeded either through majority for-votes\n     *   or has been vetoed in its favour.\n     */\n    function queue(uint256 proposalId) public {\n        require(\n            state(proposalId) == ProposalState.Succeeded,\n            \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = block.timestamp + timelock.delay();\n\n        uint256 length = proposal.targets.length;\n        for (uint256 i = 0; i < length; i++) {\n            _queueOrRevert(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    /**\n     * @dev Executes a proposal after it has been queued and cool-off time has elapsed.\n     * It sets the {executed} status of the proposal to 'true'.\n     *\n     * Requirements:\n     * - the proposal in question must have been quened and cool-off time has elapsed\n     * - none of the actions of the proposal revert upon execution\n     */\n    function execute(uint256 proposalId) public payable {\n        require(\n            state(proposalId) == ProposalState.Queued,\n            \"GovernorAlpha::execute: proposal can only be executed if it is queued\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        uint256 length = proposal.targets.length;\n        for (uint256 i = 0; i < length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @dev Casts vote by {msg.sender}.\n     * It calls the internal function `_castVote` to perform vote casting.\n     */\n    function castVote(uint256 proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    /**\n     * @dev Called by a relayer to cast vote by a message signer.\n     *\n     * Requirements:\n     * - {signatory} retrieved must not be a zero address\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(BALLOT_TYPEHASH, proposalId, support)\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n\n        require(\n            signatory != address(0),\n            \"GovernorAlpha::castVoteBySig: invalid signature\"\n        );\n\n        return _castVote(signatory, proposalId, support);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /**\n     * @dev Changes the {feeReceiver}.\n     *\n     * Requirements:\n     * - only guardian can call\n     */\n    function changeFeeReceiver(address feeReceiver_) external onlyGuardian {\n        emit FeeReceiverChanged(feeReceiver, feeReceiver_);\n        feeReceiver = feeReceiver_;\n    }\n\n    /**\n     * @dev Changes the {feeAmount}.\n     *\n     * Requirements:\n     * - only guardian can call\n     */\n    function changeFeeAmount(uint256 feeAmount_) external onlyGuardian {\n        emit FeeAmountChanged(feeAmount, feeAmount_);\n        feeAmount = feeAmount_;\n    }\n\n    /**\n     * @dev Allows vetoeing of a proposal in favor or against it.\n     * It also queues a proposal if it has been vetoed in favor of it and.\n     * sets the veto status of the proposal.\n     *\n     * Requirements:\n     * - can only be called by {council}\n     * - proposal being vetoed must be active or pending\n     * - none of the actions in proposal being vetoed point to the contract\n     *   itself. This to restrict council from vetoing a proposal intended\n     *   to change council.\n     */\n    function veto(uint256 proposalId, bool support) external onlyCouncil {\n        ProposalState _state = state(proposalId);\n        require(\n            _state == ProposalState.Active || _state == ProposalState.Pending,\n            \"GovernorAlpha::veto: Proposal can only be vetoed when active\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        address[] memory _targets = proposal.targets;\n        for (uint256 i = 0; i < _targets.length; i++) {\n            if (_targets[i] == address(this)) {\n                revert(\n                    \"GovernorAlpha::veto: council cannot veto on proposal having action with address(this) as target\"\n                );\n            }\n        }\n\n        VetoStatus storage _vetoStatus = proposal.vetoStatus;\n        _vetoStatus.hasBeenVetoed = true;\n        _vetoStatus.support = support;\n\n        if (support) {\n            queue(proposalId);\n        }\n\n        emit ProposalVetoed(proposalId, support);\n    }\n\n    /**\n     * @dev Changes the {council}.\n     *\n     * Requirements:\n     * - can only be called by {Timelock} contract through a non-vetoeable proposal\n     */\n    function changeCouncil(address council_) external onlyTimelock {\n        emit CouncilChanged(council, council_);\n        council = council_;\n    }\n\n    /**\n     * @dev Cancels the proposal with id {proposalId}.\n     * It also sets the {canceled} property of {Proposal} to `true` and\n     * removes the proposal's corresponding actions from {Timelock} contract.\n     *\n     * Requirements:\n     * - proposal must not be already executed\n     */\n    function cancel(uint256 proposalId) public onlyGuardian {\n        ProposalState _state = state(proposalId);\n        require(\n            _state != ProposalState.Executed,\n            \"GovernorAlpha::cancel: cannot cancel executed proposal\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        proposal.canceled = true;\n        uint256 length = proposal.targets.length;\n        for (uint256 i = 0; i < length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /**\n     * @dev Calls {acceptAdmin} on {Timelock} contract and makes the current contract\n     * the admin of {Timelock} contract.\n     *\n     * Requirements:\n     * - only guardian can call it\n     * - current contract must be the `pendingAdmin` in {Timelock} contract\n     */\n    function __acceptAdmin() public onlyGuardian {\n        timelock.acceptAdmin();\n    }\n\n    /**\n     * @dev Gives up the guardian role associated with the contract.\n     *\n     * Requirements:\n     * - only callable by guardian\n     */\n    function __abdicate() public onlyGuardian {\n        guardian = address(0);\n    }\n\n    /**\n     * @dev Queues the transaction to set `pendingAdmin` in {Timelock}.\n     *\n     * Requirements:\n     * - only callable by guardian\n     */\n    function __queueSetTimelockPendingAdmin(\n        address newPendingAdmin,\n        uint256 eta\n    ) public onlyGuardian {\n        timelock.queueTransaction(\n            address(timelock),\n            0,\n            \"setPendingAdmin(address)\",\n            abi.encode(newPendingAdmin),\n            eta\n        );\n    }\n\n    /**\n     * @dev Executes the transaction to set `pendingAdmin` in {Timelock}.\n     *\n     * Requirements:\n     * - only callable by guardian\n     */\n    function __executeSetTimelockPendingAdmin(\n        address newPendingAdmin,\n        uint256 eta\n    ) public onlyGuardian {\n        timelock.executeTransaction(\n            address(timelock),\n            0,\n            \"setPendingAdmin(address)\",\n            abi.encode(newPendingAdmin),\n            eta\n        );\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /**\n     * @dev Queues a transaction in {Timelock}.\n     *\n     * Requirements:\n     * - only callable by guardian\n     * - transaction is not already queued in {Timelock}\n     */\n    function _queueOrRevert(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(\n            !timelock.queuedTransactions(\n                keccak256(abi.encode(target, value, signature, data, eta))\n            ),\n            \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n        );\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    /**\n     * @dev Casts vote against proposal with id {proposalId}.\n     * It gets the voting weight of voter from {xVader} token contract corresponding to\n     * the blocknumber when proposal started and adds those votes to either\n     * {forVotes} or {againstVotes} property of {Proposal} depending upon if\n     * the voter is voting in favor of or against the proposal.\n     *\n     * Requirements:\n     * - proposal being voted must be active\n     * - voter has not already voted against the proposal\n     */\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(\n            state(proposalId) == ProposalState.Active,\n            \"GovernorAlpha::_castVote: voting is closed\"\n        );\n\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n\n        require(\n            !receipt.hasVoted,\n            \"GovernorAlpha::_castVote: voter already voted\"\n        );\n\n        // optimistically casting to uint224 as xVader contract performs the checks for\n        // votes to not overflow uint224.\n        uint224 votes = uint224(xVader.getPastVotes(voter, proposal.startBlock));\n\n        if (support) {\n            proposal.forVotes = proposal.forVotes + votes;\n        } else {\n            proposal.againstVotes = proposal.againstVotes + votes;\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    // gets the chainid from current network\n    function getChainId() internal view returns (uint256 chainId) {\n        assembly {\n            chainId := chainid()\n        }\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    // ensures only {guardian} is able to a particular function.\n    function _onlyGuardian() private view {\n        require(\n            msg.sender == guardian,\n            \"GovernorAlpha::_onlyGuardian: only guardian can call\"\n        );\n    }\n\n    // ensures only {timelock} is able to a particular function.\n    function _onlyTimelock() private view {\n        require(\n            msg.sender == address(timelock),\n            \"GovernorAlpha::_onlyTimelock: only timelock can call\"\n        );\n    }\n\n    // ensures only {council} is able to a particular function.\n    function _onlyCouncil() private view {\n        require(\n            msg.sender == council,\n            \"GovernorAlpha::_onlyCouncil: only council can call\"\n        );\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /**\n     * @dev Throws if invoked by anyone else other than the {guardian}\n     */\n    modifier onlyGuardian() {\n        _onlyGuardian();\n        _;\n    }\n\n    /**\n     * @dev Throws if invoked by anyone else other than the {timelock}\n     */\n    modifier onlyTimelock() {\n        _onlyTimelock();\n        _;\n    }\n\n    /**\n     * @dev Throws if invoked by anyone else other than the {council}\n     */\n    modifier onlyCouncil() {\n        _onlyCouncil();\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "GovernorAlpha.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GovernorAlpha.sol:L562",
                "Type": "High Severity",
                "Description": "Governance veto can be bypassed by adding an action that points to governance that does nothing.",
                "Repair": "Make proposals vetoable whenever the differential is less than x%, even if it involves governance change"
            },
            {
                "Location": "GovernorAlpha contract",
                "Type": "Governor's veto protection can be exploited",
                "Description": "Governor's veto protection can be exploited",
                "Repair": "Restrict the veto check by specifying the actual function selector that is not allowed to be vetoed"
            },
            {
                "Location": "GovernorAlpha.sol",
                "Type": "Missing duplicate veto check",
                "Description": "On the GovernorAlpha contract, function veto has been added. Although the function behaviour is expected, duplicate veto process has not been checked on that function.",
                "Repair": "Check if proposals have been vetoed before"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./IStakingRewards.sol\";\nimport \"./RewardsDistributionRecipient.sol\";\nimport \"./Pausable.sol\";\n\ncontract StakingRewards is\n    IStakingRewards,\n    RewardsDistributionRecipient,\n    ReentrancyGuard,\n    Pausable\n{\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public immutable rewardsToken;\n    IERC20 public immutable stakingToken;\n    uint public periodFinish;\n    uint public rewardRate;\n    uint public rewardsDuration = 7 days;\n    uint public lastUpdateTime;\n    uint public rewardPerTokenStored;\n\n    mapping(address => uint) public userRewardPerTokenPaid;\n    mapping(address => uint) public rewards;\n\n    uint private _totalSupply;\n    mapping(address => uint) private _balances;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken\n    ) Owned(_owner) {\n        require(_rewardsDistribution != address(0), \"reward dist = zero address\");\n        require(_rewardsToken != address(0), \"reward token = zero address\");\n        require(_stakingToken != address(0), \"staking token = zero address\");\n\n        rewardsToken = IERC20(_rewardsToken);\n        stakingToken = IERC20(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint) {\n        return _balances[account];\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored +\n            ((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18) /\n            _totalSupply;\n    }\n\n    function earned(address account) public view returns (uint) {\n        return\n            _balances[account] *\n            ((rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18) +\n            rewards[account];\n    }\n\n    function getRewardForDuration() external view returns (uint) {\n        return rewardRate * rewardsDuration;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function stake(uint amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot stake 0\");\n        _totalSupply += amount;\n        _balances[msg.sender] += amount;\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint amount) public nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply -= amount;\n        _balances[msg.sender] -= amount;\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint reward)\n        external\n        override\n        onlyRewardsDistribution\n        updateReward(address(0))\n    {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            uint remaining = periodFinish - block.timestamp;\n            uint leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / rewardsDuration;\n        }\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint balance = rewardsToken.balanceOf(address(this));\n        require(rewardRate <= balance / rewardsDuration, \"Provided reward too high\");\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + rewardsDuration;\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint tokenAmount) external onlyOwner {\n        require(\n            tokenAddress != address(stakingToken),\n            \"Cannot withdraw the staking token\"\n        );\n        IERC20(tokenAddress).safeTransfer(msg.sender, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(_rewardsDuration);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint reward);\n    event Staked(address indexed user, uint amount);\n    event Withdrawn(address indexed user, uint amount);\n    event RewardPaid(address indexed user, uint reward);\n    event RewardsDurationUpdated(uint newDuration);\n    event Recovered(address token, uint amount);\n}\n\n\n",
        "CodeNames": [
            "StakingRewards.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "StakingRewards.sol",
                "Type": "Inconsistent Balance",
                "Description": "Inconsistent balance when supplying transfer-on-fee or deflationary tokens.",
                "Repair": "Get the actual received amount by calculating the difference of token balance before and after the transfer."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../../interfaces/external/chainlink/IAggregator.sol\";\n\ncontract GasThrottle is ProtocolConstants {\n    modifier validateGas() {\n        // TODO: Uncomment prior to launch\n        // require(\n        //     block.basefee <= tx.gasprice &&\n        //         tx.gasprice <=\n        //         uint256(IAggregator(_FAST_GAS_ORACLE).latestAnswer()),\n        //     \"GasThrottle::validateGas: Gas Exceeds Thresholds\"\n        // );\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "GasThrottle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "GasThrottle.sol",
                "Type": "Denial of Service",
                "Description": "No way to remove GasThrottle after deployment.",
                "Repair": "Either remove GasThrottle.sol entirely or allow governance to turn it off."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../shared/ProtocolConstants.sol\";\n\nimport \"../interfaces/reserve/IVaderReserve.sol\";\n\ncontract VaderReserve is IVaderReserve, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe VADER transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The Vader token the reserve is handling\n    IERC20 public immutable vader;\n\n    // Router address for IL awards\n    address public router;\n\n    // Tracks last grant time for throttling\n    uint256 public lastGrant;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        IERC20 _vader\n    ) {\n        require(\n            _vader != IERC20(_ZERO_ADDRESS),\n            \"VaderReserve::constructor: Incorrect Arguments\"\n        );\n        vader = _vader;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function reserve() public view override returns (uint256) {\n        return vader.balanceOf(address(this));\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function grant(address recipient, uint256 amount)\n        external\n        override\n        onlyOwner\n        throttle\n    {\n        amount = _min(\n            (reserve() * _MAX_GRANT_BASIS_POINTS) / _MAX_BASIS_POINTS,\n            amount\n        );\n        vader.safeTransfer(recipient, amount);\n\n        emit GrantDistributed(recipient, amount);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function initialize(address _router, address _dao) external onlyOwner {\n         require(\n            _router != _ZERO_ADDRESS &&\n                _dao != _ZERO_ADDRESS,\n            \"VaderReserve::initialize: Incorrect Arguments\"\n        );\n        router = _router;\n        transferOwnership(_dao);\n    }\n\n    function reimburseImpermanentLoss(address recipient, uint256 amount)\n        external\n        override\n    {\n        require(\n            msg.sender == router,\n            \"VaderReserve::reimburseImpermanentLoss: Insufficient Priviledges\"\n        );\n\n        uint256 actualAmount = _min(reserve(), amount);\n\n        vader.safeTransfer(recipient, actualAmount);\n\n        emit LossCovered(recipient, amount, actualAmount);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier throttle() {\n        require(\n            lastGrant + _GRANT_DELAY <= block.timestamp,\n            \"VaderReserve::throttle: Grant Too Fast\"\n        );\n        lastGrant = block.timestamp;\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "VaderReserve.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaderReserve.sol",
                "Type": "Impermanent Loss Compensation",
                "Description": "User may not receive the full amount of IL compensation.",
                "Repair": "Return the actual amount or check whether there's slippage. Revert if the user doesn't receive the full amount."
            },
            {
                "Location": "VaderReserve.sol#L80-L83",
                "Type": "VaderReserve does not support paying IL protection out to more than one address, resulting in locked funds",
                "Description": "All liquidity deployed to one of VaderPool or VaderPoolV2 will be locked permanently.",
                "Repair": "Allow the reserve to whitelist multiple addresses to claim funds or allow the call to the reserve to fail without reverting the entire transaction (probably want to make this optional for LPs)"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../../dex/math/VaderMath.sol\";\nimport \"../../dex/utils/GasThrottle.sol\";\n\nimport \"../../external/libraries/UQ112x112.sol\";\n\nimport \"../../interfaces/dex-v2/pool/IBasePoolV2.sol\";\n\n/*\n * @dev Implementation of {BasePoolV2} contract.\n *\n * The BasePoolV2 contract keeps track of all the Vader pools in the form of\n * pairs. Each pair tracked through {pairInfo} mapping and is mapped against the\n * foreign asset for which the pair is created.\n *\n * Has function to deposited liquidity to any of pair by specifying the mapped\n * foreign asset against the pair.\n *\n * The minted liquidity is associated with a position, that is tracked by a minted NFT.\n * The NFT has information about the pair for which it represents the liquidity.\n *\n * The contract allows redeeming of liquidity against a particular pool by burning the\n * associated position representing NFT.\n *\n * The contract allows swapping of native to foreign assets and vice versa within a pair and\n * allows foreign to foreign asset swap across two different pairs.\n *\n * Keeps track of the cumulative prices for both native and foreign assets for\n * pairs and updates them after minting and burning of liquidity, and swapping of assets.\n **/\ncontract BasePoolV2 is\n    IBasePoolV2,\n    ProtocolConstants,\n    GasThrottle,\n    ERC721,\n    ReentrancyGuard\n{\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    // Used by Uniswap-like TWAP mechanism\n    using UQ112x112 for uint224;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of native asset (Vader or USDV).\n    IERC20 public immutable override nativeAsset;\n\n    // Denotes what tokens are actively supported by the system\n    mapping(IERC20 => bool) public override supported;\n\n    /*\n     * @dev A mapping of foreign asset to the pool's pair.\n     * Each pair is represents a pool of native and foreign assets and\n     * contains data such as the reserves of native and foreign assets and\n     * the liquidity units issues against the deposits of these assets.\n     **/\n    mapping(IERC20 => PairInfo) public pairInfo;\n\n    /*\n     * @dev A mapping representing positions of liquidity providers. Each position\n     * is an Non-fungible token that is mapped against amounts of native and foreign assets\n     * deposited across different pools of pairs the timestamp at which the position\n     * is created and the amount of liquidity of a particular pool assigned to the LP.\n     *\n     * Each position in the mapping is mapped against {positionId}.\n     **/\n    mapping(uint256 => Position) public positions;\n\n    // A unique id the of the position created when liquidity is added to a pool.\n    uint256 public positionId;\n\n    // Address of the router contract (used for restriction)\n    address public router;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initializes the contract by setting address of native asset.\n     **/\n    constructor(IERC20 _nativeAsset) ERC721(\"Vader LP\", \"VLP\") {\n        require(\n            _nativeAsset != IERC20(_ZERO_ADDRESS),\n            \"BasePoolV2::constructor: Incorrect Arguments\"\n        );\n        nativeAsset = IERC20(_nativeAsset);\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Accepts address of foreign asset {foreignAsset} to determine the pair (pool)\n     * and returns reserves amounts of native and foreign assets, and the last timestamp\n     * when cumulative prices for these assets were updated.\n     **/\n    function getReserves(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint112 reserveNative,\n            uint112 reserveForeign,\n            uint32 blockTimestampLast\n        )\n    {\n        PairInfo storage pair = pairInfo[foreignAsset];\n        (reserveNative, reserveForeign, blockTimestampLast) = (\n            pair.reserveNative,\n            pair.reserveForeign,\n            pair.blockTimestampLast\n        );\n    }\n\n    /*\n     * @dev Accepts {id} of a liquidity position and returns foreign asset's\n     * address for that particular liquidity position.\n     **/\n    function positionForeignAsset(uint256 id)\n        external\n        view\n        override\n        returns (IERC20)\n    {\n        return positions[id].foreignAsset;\n    }\n\n    function pairSupply(IERC20 foreignAsset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return pairInfo[foreignAsset].totalSupply;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows depositing of liquidity to a pool/pair by accepting native and foreign assets\n     * and mints an NFT to the {to} address which records in {positions} mapping, the amounts\n     * of the native and foreign assets deposited and the liquidity units minted against.\n     *\n     * The pool/pair to accept the native and foreign assets against is determined by {foreignAsset}.\n     *\n     * Updates the total supply of liquidity units by adding currently minted liquidity units\n     * to {pair.totalSupply} of pair/pool.\n     *\n     * Updates the cumulative prices of native and foreign assets in pool/pair after minting the appropriate\n     * liquidity units.\n     *\n     * Requirements:\n     * - Amounts of native and foreign must be approved to the pool prior to calling the `mint` function.\n     * - The amount of {liquidity} to be minted must be greater than 0.\n     * - The param {foreignAsset} must be a supported token.\n     * - Can only be called by Router.\n     **/\n    function mint(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        onlyRouter\n        supportedToken(foreignAsset)\n        returns (uint256 liquidity)\n    {\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"BasePoolV2::mint: Insufficient Liquidity Provided\"\n        );\n\n        uint256 id = positionId++;\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n        _mint(to, id);\n\n        positions[id] = Position(\n            foreignAsset,\n            block.timestamp,\n            liquidity,\n            nativeDeposit,\n            foreignDeposit\n        );\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n        emit PositionOpened(from, to, id, liquidity);\n    }\n\n    /*\n     * @dev Allows redeeming of liquidity units by burning the NFT with {id} associated with the liquidity\n     * position.\n     *\n     * Computes the amounts of native and foreign assets from pool/pair against which the NFT with Id {id}\n     * was minted. The computed assets' amounts depends upon current reserves of assets and\n     * the liquidity associated with the position, and is transferred to the {to} address.\n     *\n     * Burns the redeemed NFT token and decreases {pair.totalSupply} by the {liquidity}\n     * associated with that NFT token.\n     *\n     * Updates the cumulative prices for native and foreign assets in pool/pair after transferring the assets\n     * to the {to} address.\n     *\n     * Requirements:\n     * - The NFT token being redeemed must be transferred to the contract prior to calling `_burn`.\n     * - The amount of native and foreign assets computed for transfer to {to} address must be greater\n     *   than 0.\n     **/\n    function _burn(uint256 id, address to)\n        internal\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        require(\n            ownerOf(id) == address(this),\n            \"BasePoolV2::burn: Incorrect Ownership\"\n        );\n\n        IERC20 foreignAsset = positions[id].foreignAsset;\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        uint256 liquidity = positions[id].liquidity;\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"BasePoolV2::burn: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n        _burn(id);\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /*\n     * @dev Allows swapping between two foreign assets from two different pools/pairs.\n     *\n     * It receives amount {foreignAmountIn} in {foreignAssetA} and returns the swapped amount in {foreignAssetB}.\n     *\n     * The amount {foreignAmountIn} is swapped to the native asset from the pair against {foreignAssetA} and the\n     * received native asset is swapped to foreign asset from the pair against {foreignAssetB}.\n     *\n     * Updates the cumulative prices for native and foreign assets across pools against assets {foreignAssetA} and\n     * {foreignAssetB}.\n     *\n     * Requirements:\n     * - The amount {foreignAmountIn} in {foreignAssetA} must be transferred to the contract prior to calling\n     *   the function `doubleSwap`.\n     * - The intermediary native asset retrieved from first swap must be greater than 0 and the reserve for native asset.\n     * - The foreign amount received from second swap must be greater than 0 and the reserve for foreign asset in the pair/pool\n     *   against that particular foreign asset.\n     * - The params {foreignAssetA} and {foreignAssetB} must be the supported tokens.\n     * - Can only be called by Router.\n     **/\n    function doubleSwap(\n        IERC20 foreignAssetA,\n        IERC20 foreignAssetB,\n        uint256 foreignAmountIn,\n        address to\n    )\n        external\n        override\n        onlyRouter\n        supportedToken(foreignAssetA)\n        supportedToken(foreignAssetB)\n        nonReentrant\n        validateGas\n        returns (uint256 foreignAmountOut)\n    {\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(\n            foreignAssetA\n        ); // gas savings\n\n        require(\n            foreignReserve + foreignAmountIn <=\n                foreignAssetA.balanceOf(address(this)),\n            \"BasePoolV2::doubleSwap: Insufficient Tokens Provided\"\n        );\n\n        uint256 nativeAmountOut = VaderMath.calculateSwap(\n            foreignAmountIn,\n            foreignReserve,\n            nativeReserve\n        );\n\n        require(\n            nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n            \"BasePoolV2::doubleSwap: Swap Impossible\"\n        );\n\n        _update(\n            foreignAssetA,\n            nativeReserve - nativeAmountOut,\n            foreignReserve + foreignAmountIn,\n            nativeReserve,\n            foreignReserve\n        );\n\n        emit Swap(\n            foreignAssetA,\n            msg.sender,\n            0,\n            foreignAmountIn,\n            nativeAmountOut,\n            0,\n            address(this)\n        );\n\n        (nativeReserve, foreignReserve, ) = getReserves(foreignAssetB); // gas savings\n\n        foreignAmountOut = VaderMath.calculateSwap(\n            nativeAmountOut,\n            nativeReserve,\n            foreignReserve\n        );\n\n        require(\n            foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n            \"BasePoolV2::doubleSwap: Swap Impossible\"\n        );\n\n        _update(\n            foreignAssetB,\n            nativeReserve + nativeAmountOut,\n            foreignReserve - foreignAmountOut,\n            nativeReserve,\n            foreignReserve\n        );\n\n        emit Swap(\n            foreignAssetB,\n            msg.sender,\n            nativeAmountOut,\n            0,\n            0,\n            foreignAmountOut,\n            to\n        );\n\n        foreignAssetB.safeTransfer(to, foreignAmountOut);\n    }\n\n    /*\n     * @dev Allows swapping between native and foreign assets from within a single pair/pool determined\n     * by {foreignAsset}.\n     *\n     * It receives the source asset and computes the destination asset and transfers it to the {to} address.\n     *\n     * Updates the cumulative prices for native and foreign assets for the pair involved after performing swap.\n     *\n     * Returns the amount of destination tokens resulting from the swap.\n     *\n     * Requirements:\n     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero\n     *   if the destination asset in swap is native asset.\n     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero\n     *   if the destination asset in swap is foreign asset.\n     * - Param {to} cannot be the addresses of native or foreign assets.\n     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.\n     * - The source asset amount in the swap cannot exceed the source asset's reserve.\n     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination\n     *   asset's reserve.\n     * - The param {foreignAsset} must be a supported token.\n     * - Can only be called by Router.\n     **/\n    function swap(\n        IERC20 foreignAsset,\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to\n    )\n        external\n        override\n        onlyRouter\n        supportedToken(foreignAsset)\n        nonReentrant\n        validateGas\n        returns (uint256)\n    {\n        require(\n            (nativeAmountIn > 0 && foreignAmountIn == 0) ||\n                (nativeAmountIn == 0 && foreignAmountIn > 0),\n            \"BasePoolV2::swap: Only One-Sided Swaps Supported\"\n        );\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        uint256 nativeAmountOut;\n        uint256 foreignAmountOut;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            IERC20 _nativeAsset = nativeAsset;\n            require(\n                to != address(_nativeAsset) && to != address(foreignAsset),\n                \"BasePoolV2::swap: Invalid Receiver\"\n            );\n\n            if (foreignAmountIn > 0) {\n                nativeAmountOut = VaderMath.calculateSwap(\n                    foreignAmountIn,\n                    foreignReserve,\n                    nativeReserve\n                );\n                require(\n                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n                    \"BasePoolV2::swap: Swap Impossible\"\n                );\n                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens\n            } else {\n                foreignAmountOut = VaderMath.calculateSwap(\n                    nativeAmountIn,\n                    nativeReserve,\n                    foreignReserve\n                );\n                require(\n                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n                    \"BasePoolV2::swap: Swap Impossible\"\n                );\n                foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens\n            }\n        }\n\n        _update(\n            foreignAsset,\n            nativeReserve - nativeAmountOut + nativeAmountIn,\n            foreignReserve - foreignAmountOut + foreignAmountIn,\n            nativeReserve,\n            foreignReserve\n        );\n\n        emit Swap(\n            foreignAsset,\n            msg.sender,\n            nativeAmountIn,\n            foreignAmountIn,\n            nativeAmountOut,\n            foreignAmountOut,\n            to\n        );\n\n        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;\n    }\n\n    /*\n     * @dev Allows withdrawing of unaccounted/unrealised foreign asset from the contract.\n     *\n     * Determines the realised amount of foreign asset from the pair against {foreignAsset}.\n     **/\n    function rescue(IERC20 foreignAsset) external {\n        uint256 foreignBalance = foreignAsset.balanceOf(address(this));\n        uint256 reserveForeign = pairInfo[foreignAsset].reserveForeign;\n\n        uint256 unaccounted = foreignBalance - reserveForeign;\n\n        foreignAsset.safeTransfer(msg.sender, unaccounted);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /*\n     * @dev Internally called to update the cumulative prices for native and foreign assets for\n     * the pair against {foreignAsset}. The updated prices depend upon the last reserves and\n     * updates the reserves for both of the assets corresponding to their\n     * current balances along with the timestamp.\n     *\n     * Requirements:\n     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.\n     *\n     **/\n    function _update(\n        IERC20 foreignAsset,\n        uint256 balanceNative,\n        uint256 balanceForeign,\n        uint112 reserveNative,\n        uint112 reserveForeign\n    ) internal {\n        require(\n            balanceNative <= type(uint112).max &&\n                balanceForeign <= type(uint112).max,\n            \"BasePoolV2::_update: Balance Overflow\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        PairInfo storage pair = pairInfo[foreignAsset];\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - pair.blockTimestampLast; // overflow is desired\n            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {\n                // * never overflows, and + overflow is desired\n                pair.priceCumulative.nativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)\n                    ) *\n                    timeElapsed;\n                pair.priceCumulative.foreignLast +=\n                    uint256(\n                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)\n                    ) *\n                    timeElapsed;\n            }\n        }\n        pair.reserveNative = uint112(balanceNative);\n        pair.reserveForeign = uint112(balanceForeign);\n        pair.blockTimestampLast = blockTimestamp;\n        emit Sync(foreignAsset, balanceNative, balanceForeign);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /*\n     * @dev Private function that returns if the param {token} is a supported token\n     * or not.\n     **/\n    function _supportedToken(IERC20 token) private view {\n        require(\n            supported[token],\n            \"BasePoolV2::_supportedToken: Unsupported Token\"\n        );\n    }\n\n    /*\n     * @dev Private function that returns if {msg.sender} is a Router or not.\n     **/\n    function _onlyRouter() private view {\n        require(\n            msg.sender == router,\n            \"BasePoolV2::_onlyRouter: Only Router is allowed to call\"\n        );\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /*\n     * @dev Modifier that only allows continuation of execution\n     * if {msg.sender} is Router.\n     **/\n    modifier onlyRouter() {\n        _onlyRouter();\n        _;\n    }\n\n    /*\n     * @dev Modifier that only allows continuation of exectuion if the param\n     * {token} is a supported token.\n     **/\n    modifier supportedToken(IERC20 token) {\n        _supportedToken(token);\n        _;\n    }\n}\n\n\n",
        "CodeNames": [
            "BasePoolV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BasePoolV2.sol#mint() function",
                "Type": "Tokens with fee on transfer are not supported",
                "Description": "The current implementation assumes that the received amount is the same as the transfer amount.",
                "Repair": "Consider calling balanceOf() to get the actual balances"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/IERC20Metadata.sol\";\nimport \"./interfaces/ITreasury.sol\";\n// import \"./lib/FixedPoint.sol\";\nimport \"./Ownable.sol\";\n\ncontract VaderBond is Ownable, ReentrancyGuard {\n    // using FixedPoint for FixedPoint.uq112x112;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint;\n\n    enum PARAMETER {\n        VESTING,\n        PAYOUT,\n        DEBT\n    }\n\n    event SetBondTerms(PARAMETER indexed param, uint input);\n    event SetAdjustment(bool add, uint rate, uint target, uint buffer);\n    event BondCreated(uint deposit, uint payout, uint expires);\n    event BondRedeemed(address indexed recipient, uint payout, uint remaining);\n    event BondPriceChanged(uint internalPrice, uint debtRatio);\n    event ControlVariableAdjustment(uint initialBCV, uint newBCV, uint adjustment, bool addition);\n    event TreasuryChanged(address treasury);\n\n    uint8 private immutable PRINCIPAL_TOKEN_DECIMALS;\n    uint8 private constant PAYOUT_TOKEN_DECIMALS = 18; // Vader has 18 decimals\n    uint private constant MIN_PAYOUT = 10**PAYOUT_TOKEN_DECIMALS / 100; // 0.01\n    uint private constant MAX_PERCENT_VESTED = 1e4; // 1 = 0.01%, 10000 = 100%\n    uint private constant MAX_PAYOUT_DENOM = 1e5; // 100 = 0.1%, 100000 = 100%\n\n    IERC20 public immutable payoutToken; // token paid for principal\n    IERC20 public immutable principalToken; // inflow token\n    ITreasury public treasury; // pays for and receives principal\n\n    Terms public terms; // stores terms for new bonds\n    Adjust public adjustment; // stores adjustment to BCV data\n\n    mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\n    uint public lastDecay; // reference block for debt decay\n\n    // Info for creating new bonds\n    struct Terms {\n        uint controlVariable; // scaling variable for price\n        uint vestingTerm; // in blocks\n        uint minPrice; // vs principal value\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n        uint maxDebt; // max debt, same decimals with payout token\n    }\n    // Info for bond holder\n    struct Bond {\n        uint payout; // payout token remaining to be paid\n        uint vesting; // Blocks left to vest\n        uint lastBlock; // Last interaction\n    }\n    // Info for incremental adjustments to control variable\n    struct Adjust {\n        bool add; // addition or subtraction\n        uint rate; // increment\n        uint target; // BCV when adjustment finished\n        uint buffer; // minimum length (in blocks) between adjustments\n        uint lastBlock; // block when last adjustment made\n    }\n\n    constructor(\n        address _treasury,\n        address _payoutToken,\n        address _principalToken\n    ) {\n        require(_treasury != address(0), \"treasury = zero\");\n        treasury = ITreasury(_treasury);\n        require(_payoutToken != address(0), \"payout token = zero\");\n        payoutToken = IERC20(_payoutToken);\n        require(_principalToken != address(0), \"principal token = zero\");\n        principalToken = IERC20(_principalToken);\n\n        PRINCIPAL_TOKEN_DECIMALS = IERC20Metadata(_principalToken).decimals();\n    }\n\n    /**\n     *  @notice initializes bond parameters\n     *  @param _controlVariable uint\n     *  @param _vestingTerm uint\n     *  @param _minPrice uint\n     *  @param _maxPayout uint\n     *  @param _maxDebt uint\n     *  @param _initialDebt uint\n     */\n    function initializeBond(\n        uint _controlVariable,\n        uint _vestingTerm,\n        uint _minPrice,\n        uint _maxPayout,\n        uint _maxDebt,\n        uint _initialDebt\n    ) external onlyOwner {\n        require(terms.controlVariable == 0, \"initialized\");\n\n        require(_controlVariable > 0, \"cv = 0\");\n        // roughly 36 hours (262 blocks / hour)\n        require(_vestingTerm >= 10000, \"vesting < 10000\");\n        // max payout must be < 1% of total supply of payout token\n        require(_maxPayout <= MAX_PAYOUT_DENOM / 100, \"max payout > 1%\");\n\n        terms = Terms({\n            controlVariable: _controlVariable,\n            vestingTerm: _vestingTerm,\n            minPrice: _minPrice,\n            maxPayout: _maxPayout,\n            maxDebt: _maxDebt\n        });\n\n        totalDebt = _initialDebt;\n        lastDecay = block.number;\n    }\n\n    /**\n     *  @notice set parameters for new bonds\n     *  @param _param PARAMETER\n     *  @param _input uint\n     */\n    function setBondTerms(PARAMETER _param, uint _input) external onlyOwner {\n        if (_param == PARAMETER.VESTING) {\n            // roughly 36 hours (262 blocks / hour)\n            require(_input >= 10000, \"vesting < 10000\");\n            terms.vestingTerm = _input;\n        } else if (_param == PARAMETER.PAYOUT) {\n            // max payout must be < 1% of total supply of payout token\n            require(_input <= MAX_PAYOUT_DENOM / 100, \"max payout > 1%\");\n            terms.maxPayout = _input;\n        } else if (_param == PARAMETER.DEBT) {\n            terms.maxDebt = _input;\n        }\n        emit SetBondTerms(_param, _input);\n    }\n\n    /**\n     *  @notice set control variable adjustment\n     *  @param _add bool\n     *  @param _rate uint\n     *  @param _target uint\n     *  @param _buffer uint\n     */\n    function setAdjustment(\n        bool _add,\n        uint _rate,\n        uint _target,\n        uint _buffer\n    ) external onlyOwner {\n        require(_rate <= terms.controlVariable.mul(3) / 100, \"rate > 3%\");\n        adjustment = Adjust({add: _add, rate: _rate, target: _target, buffer: _buffer, lastBlock: block.number});\n        emit SetAdjustment(_add, _rate, _target, _buffer);\n    }\n\n    /**\n     *  @notice deposit bond\n     *  @param _amount uint\n     *  @param _maxPrice uint\n     *  @param _depositor address\n     *  @return uint\n     *  @dev Deposit resets vesting term for _depositor\n     */\n    function deposit(\n        uint _amount,\n        uint _maxPrice,\n        address _depositor\n    ) external nonReentrant returns (uint) {\n        require(_depositor != address(0), \"depositor = zero\");\n\n        decayDebt();\n        require(totalDebt <= terms.maxDebt, \"max debt\");\n        require(_maxPrice >= bondPrice(), \"bond price > max\");\n\n        uint value = treasury.valueOfToken(address(principalToken), _amount);\n        uint payout = payoutFor(value);\n\n        require(payout >= MIN_PAYOUT, \"payout < min\");\n        // size protection because there is no slippage\n        require(payout <= maxPayout(), \"payout > max\");\n\n        principalToken.safeTransferFrom(msg.sender, address(this), _amount);\n        principalToken.approve(address(treasury), _amount);\n        treasury.deposit(address(principalToken), _amount, payout);\n\n        totalDebt = totalDebt.add(value);\n\n        bondInfo[_depositor] = Bond({\n            payout: bondInfo[_depositor].payout.add(payout),\n            vesting: terms.vestingTerm,\n            lastBlock: block.number\n        });\n\n        emit BondCreated(_amount, payout, block.number.add(terms.vestingTerm));\n\n        uint price = bondPrice();\n        // remove floor if price above min\n        if (price > terms.minPrice && terms.minPrice > 0) {\n            terms.minPrice = 0;\n        }\n\n        emit BondPriceChanged(price, debtRatio());\n\n        adjust(); // control variable is adjusted\n        return payout;\n    }\n\n    /**\n     *  @notice redeem bond for user\n     *  @return uint\n     */\n    function redeem(address _depositor) external nonReentrant returns (uint) {\n        Bond memory info = bondInfo[_depositor];\n        uint percentVested = percentVestedFor(_depositor); // (blocks since last interaction / vesting term remaining)\n\n        if (percentVested >= MAX_PERCENT_VESTED) {\n            // if fully vested\n            delete bondInfo[_depositor]; // delete user info\n            emit BondRedeemed(_depositor, info.payout, 0); // emit bond data\n            payoutToken.transfer(_depositor, info.payout);\n            return info.payout;\n        } else {\n            // if unfinished\n            // calculate payout vested\n            uint payout = info.payout.mul(percentVested) / MAX_PERCENT_VESTED;\n\n            // store updated deposit info\n            bondInfo[_depositor] = Bond({\n                payout: info.payout.sub(payout),\n                vesting: info.vesting.sub(block.number.sub(info.lastBlock)),\n                lastBlock: block.number\n            });\n\n            emit BondRedeemed(_depositor, payout, bondInfo[_depositor].payout);\n            payoutToken.transfer(_depositor, payout);\n            return payout;\n        }\n    }\n\n    /**\n     *  @notice makes incremental adjustment to control variable\n     */\n    function adjust() private {\n        uint blockCanAdjust = adjustment.lastBlock.add(adjustment.buffer);\n        if (adjustment.rate != 0 && block.number >= blockCanAdjust) {\n            uint initial = terms.controlVariable;\n            if (adjustment.add) {\n                terms.controlVariable = terms.controlVariable.add(adjustment.rate);\n                if (terms.controlVariable >= adjustment.target) {\n                    adjustment.rate = 0;\n                }\n            } else {\n                terms.controlVariable = terms.controlVariable.sub(adjustment.rate);\n                if (terms.controlVariable <= adjustment.target) {\n                    adjustment.rate = 0;\n                }\n            }\n            adjustment.lastBlock = block.number;\n            emit ControlVariableAdjustment(initial, terms.controlVariable, adjustment.rate, adjustment.add);\n        }\n    }\n\n    /**\n     *  @notice amount to decay total debt by\n     *  @return decay uint\n     */\n    function debtDecay() public view returns (uint decay) {\n        uint blocksSinceLast = block.number.sub(lastDecay);\n        decay = totalDebt.mul(blocksSinceLast).div(terms.vestingTerm);\n        if (decay > totalDebt) {\n            decay = totalDebt;\n        }\n    }\n\n    /**\n     *  @notice reduce total debt\n     */\n    function decayDebt() private {\n        totalDebt = totalDebt.sub(debtDecay());\n        lastDecay = block.number;\n    }\n\n    /**\n     *  @notice calculate debt factoring in decay\n     *  @return uint\n     */\n    function currentDebt() public view returns (uint) {\n        return totalDebt.sub(debtDecay());\n    }\n\n    /**\n     *  @notice calculate current ratio of debt to payout token supply\n     *  @notice protocols using DAO should be careful when quickly adding large %s to total supply\n     *  @return uint\n     */\n    function debtRatio() public view returns (uint) {\n        // TODO: use fraction?\n        // return\n        //     FixedPoint\n        //         .fraction(currentDebt().mul(10**PAYOUT_TOKEN_DECIMALS), payoutToken.totalSupply())\n        //         .decode112with18() / 1e18;\n        // NOTE: debt ratio is scaled up by 1e18\n        // NOTE: fails if payoutToken.totalSupply() == 0\n        return currentDebt().mul(1e18).div(payoutToken.totalSupply());\n    }\n\n    /**\n     *  @notice calculate current bond premium\n     *  @return price uint\n     *  @dev price = 10 ** principal token decimals = 1 principal token buys 1 bond\n     */\n    function bondPrice() public view returns (uint price) {\n        // NOTE: debt ratio scaled up with 1e18, so divide by 1e18\n        price = terms.controlVariable.mul(debtRatio()) / 1e18;\n        if (price < terms.minPrice) {\n            price = terms.minPrice;\n        }\n    }\n\n    /**\n     *  @notice determine maximum bond size\n     *  @return uint\n     */\n    function maxPayout() public view returns (uint) {\n        return payoutToken.totalSupply().mul(terms.maxPayout) / MAX_PAYOUT_DENOM;\n    }\n\n    /**\n     *  @notice calculate total interest due for new bond\n     *  @param _value uint\n     *  @return uint\n     */\n    function payoutFor(uint _value) public view returns (uint) {\n        // TODO: use fraction?\n        // NOTE: scaled up by 1e7\n        // return FixedPoint.fraction(_value, bondPrice()).decode112with18() / 1e11;\n\n        /*\n        B = amount of bond to payout\n        A = amount of principal token in\n        P = amount of principal token to pay to get 1 bond\n\n        B = A / P\n        */\n        // NOTE: decimals of value must match payout token decimals\n        // NOTE: bond price must match principal token decimals\n        return _value.mul(10**PRINCIPAL_TOKEN_DECIMALS).div(bondPrice());\n    }\n\n    /**\n     *  @notice calculate how far into vesting a depositor is\n     *  @param _depositor address\n     *  @return percentVested uint\n     */\n    function percentVestedFor(address _depositor) public view returns (uint percentVested) {\n        Bond memory bond = bondInfo[_depositor];\n        uint blocksSinceLast = block.number.sub(bond.lastBlock);\n        uint vesting = bond.vesting;\n        if (vesting > 0) {\n            percentVested = blocksSinceLast.mul(MAX_PERCENT_VESTED).div(vesting);\n        }\n        // default percentVested = 0\n    }\n\n    /**\n     *  @notice calculate amount of payout token available for claim by depositor\n     *  @param _depositor address\n     *  @return uint\n     */\n    function pendingPayoutFor(address _depositor) external view returns (uint) {\n        uint percentVested = percentVestedFor(_depositor);\n        uint payout = bondInfo[_depositor].payout;\n        if (percentVested >= MAX_PERCENT_VESTED) {\n            return payout;\n        } else {\n            return payout.mul(percentVested) / MAX_PERCENT_VESTED;\n        }\n    }\n\n    /**\n     *  @notice owner can update treasury address\n     *  @param _treasury address\n     *  @dev allow new treasury to be zero address\n     */\n    function setTreasury(address _treasury) external onlyOwner {\n        require(_treasury != address(treasury), \"no change\");\n        treasury = ITreasury(_treasury);\n        emit TreasuryChanged(_treasury);\n    }\n\n    /**\n     *  @notice allows owner to send lost tokens to owner\n     *  @param _token address\n     */\n    function recoverLostToken(address _token) external onlyOwner {\n        require(_token != address(principalToken), \"protected\");\n        require(_token != address(payoutToken), \"protected\");\n        IERC20(_token).safeTransfer(owner, IERC20(_token).balanceOf(address(this)));\n    }\n}\n\n\n",
        "CodeNames": [
            "VaderBond.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaderBond.deposit() function",
                "Type": "Users can reset bond depositor's vesting period",
                "Description": "The deposit function overwrites a depositor's bond info on each call with the updated payout information.",
                "Repair": "Prevent users from depositing to an existing bond holder or force the user to redeem any claimable tokens in the same function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../../dex/math/VaderMath.sol\";\nimport \"../../dex/utils/GasThrottle.sol\";\n\nimport \"../../external/libraries/UQ112x112.sol\";\n\nimport \"../../interfaces/dex-v2/pool/IBasePoolV2.sol\";\n\n/*\n * @dev Implementation of {BasePoolV2} contract.\n *\n * The BasePoolV2 contract keeps track of all the Vader pools in the form of\n * pairs. Each pair tracked through {pairInfo} mapping and is mapped against the\n * foreign asset for which the pair is created.\n *\n * Has function to deposited liquidity to any of pair by specifying the mapped\n * foreign asset against the pair.\n *\n * The minted liquidity is associated with a position, that is tracked by a minted NFT.\n * The NFT has information about the pair for which it represents the liquidity.\n *\n * The contract allows redeeming of liquidity against a particular pool by burning the\n * associated position representing NFT.\n *\n * The contract allows swapping of native to foreign assets and vice versa within a pair and\n * allows foreign to foreign asset swap across two different pairs.\n *\n * Keeps track of the cumulative prices for both native and foreign assets for\n * pairs and updates them after minting and burning of liquidity, and swapping of assets.\n **/\ncontract BasePoolV2 is\n    IBasePoolV2,\n    ProtocolConstants,\n    GasThrottle,\n    ERC721,\n    ReentrancyGuard\n{\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    // Used by Uniswap-like TWAP mechanism\n    using UQ112x112 for uint224;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Address of native asset (Vader or USDV).\n    IERC20 public immutable override nativeAsset;\n\n    // Denotes what tokens are actively supported by the system\n    mapping(IERC20 => bool) public override supported;\n\n    /*\n     * @dev A mapping of foreign asset to the pool's pair.\n     * Each pair is represents a pool of native and foreign assets and\n     * contains data such as the reserves of native and foreign assets and\n     * the liquidity units issues against the deposits of these assets.\n     **/\n    mapping(IERC20 => PairInfo) public pairInfo;\n\n    /*\n     * @dev A mapping representing positions of liquidity providers. Each position\n     * is an Non-fungible token that is mapped against amounts of native and foreign assets\n     * deposited across different pools of pairs the timestamp at which the position\n     * is created and the amount of liquidity of a particular pool assigned to the LP.\n     *\n     * Each position in the mapping is mapped against {positionId}.\n     **/\n    mapping(uint256 => Position) public positions;\n\n    // A unique id the of the position created when liquidity is added to a pool.\n    uint256 public positionId;\n\n    // Address of the router contract (used for restriction)\n    address public router;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initializes the contract by setting address of native asset.\n     **/\n    constructor(IERC20 _nativeAsset) ERC721(\"Vader LP\", \"VLP\") {\n        require(\n            _nativeAsset != IERC20(_ZERO_ADDRESS),\n            \"BasePoolV2::constructor: Incorrect Arguments\"\n        );\n        nativeAsset = IERC20(_nativeAsset);\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Accepts address of foreign asset {foreignAsset} to determine the pair (pool)\n     * and returns reserves amounts of native and foreign assets, and the last timestamp\n     * when cumulative prices for these assets were updated.\n     **/\n    function getReserves(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint112 reserveNative,\n            uint112 reserveForeign,\n            uint32 blockTimestampLast\n        )\n    {\n        PairInfo storage pair = pairInfo[foreignAsset];\n        (reserveNative, reserveForeign, blockTimestampLast) = (\n            pair.reserveNative,\n            pair.reserveForeign,\n            pair.blockTimestampLast\n        );\n    }\n\n    /*\n     * @dev Accepts {id} of a liquidity position and returns foreign asset's\n     * address for that particular liquidity position.\n     **/\n    function positionForeignAsset(uint256 id)\n        external\n        view\n        override\n        returns (IERC20)\n    {\n        return positions[id].foreignAsset;\n    }\n\n    function pairSupply(IERC20 foreignAsset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return pairInfo[foreignAsset].totalSupply;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Allows depositing of liquidity to a pool/pair by accepting native and foreign assets\n     * and mints an NFT to the {to} address which records in {positions} mapping, the amounts\n     * of the native and foreign assets deposited and the liquidity units minted against.\n     *\n     * The pool/pair to accept the native and foreign assets against is determined by {foreignAsset}.\n     *\n     * Updates the total supply of liquidity units by adding currently minted liquidity units\n     * to {pair.totalSupply} of pair/pool.\n     *\n     * Updates the cumulative prices of native and foreign assets in pool/pair after minting the appropriate\n     * liquidity units.\n     *\n     * Requirements:\n     * - Amounts of native and foreign must be approved to the pool prior to calling the `mint` function.\n     * - The amount of {liquidity} to be minted must be greater than 0.\n     * - The param {foreignAsset} must be a supported token.\n     * - Can only be called by Router.\n     **/\n    function mint(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        onlyRouter\n        supportedToken(foreignAsset)\n        returns (uint256 liquidity)\n    {\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"BasePoolV2::mint: Insufficient Liquidity Provided\"\n        );\n\n        uint256 id = positionId++;\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n        _mint(to, id);\n\n        positions[id] = Position(\n            foreignAsset,\n            block.timestamp,\n            liquidity,\n            nativeDeposit,\n            foreignDeposit\n        );\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n        emit PositionOpened(from, to, id, liquidity);\n    }\n\n    /*\n     * @dev Allows redeeming of liquidity units by burning the NFT with {id} associated with the liquidity\n     * position.\n     *\n     * Computes the amounts of native and foreign assets from pool/pair against which the NFT with Id {id}\n     * was minted. The computed assets' amounts depends upon current reserves of assets and\n     * the liquidity associated with the position, and is transferred to the {to} address.\n     *\n     * Burns the redeemed NFT token and decreases {pair.totalSupply} by the {liquidity}\n     * associated with that NFT token.\n     *\n     * Updates the cumulative prices for native and foreign assets in pool/pair after transferring the assets\n     * to the {to} address.\n     *\n     * Requirements:\n     * - The NFT token being redeemed must be transferred to the contract prior to calling `_burn`.\n     * - The amount of native and foreign assets computed for transfer to {to} address must be greater\n     *   than 0.\n     **/\n    function _burn(uint256 id, address to)\n        internal\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        require(\n            ownerOf(id) == address(this),\n            \"BasePoolV2::burn: Incorrect Ownership\"\n        );\n\n        IERC20 foreignAsset = positions[id].foreignAsset;\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        uint256 liquidity = positions[id].liquidity;\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"BasePoolV2::burn: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n        _burn(id);\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /*\n     * @dev Allows swapping between two foreign assets from two different pools/pairs.\n     *\n     * It receives amount {foreignAmountIn} in {foreignAssetA} and returns the swapped amount in {foreignAssetB}.\n     *\n     * The amount {foreignAmountIn} is swapped to the native asset from the pair against {foreignAssetA} and the\n     * received native asset is swapped to foreign asset from the pair against {foreignAssetB}.\n     *\n     * Updates the cumulative prices for native and foreign assets across pools against assets {foreignAssetA} and\n     * {foreignAssetB}.\n     *\n     * Requirements:\n     * - The amount {foreignAmountIn} in {foreignAssetA} must be transferred to the contract prior to calling\n     *   the function `doubleSwap`.\n     * - The intermediary native asset retrieved from first swap must be greater than 0 and the reserve for native asset.\n     * - The foreign amount received from second swap must be greater than 0 and the reserve for foreign asset in the pair/pool\n     *   against that particular foreign asset.\n     * - The params {foreignAssetA} and {foreignAssetB} must be the supported tokens.\n     * - Can only be called by Router.\n     **/\n    function doubleSwap(\n        IERC20 foreignAssetA,\n        IERC20 foreignAssetB,\n        uint256 foreignAmountIn,\n        address to\n    )\n        external\n        override\n        onlyRouter\n        supportedToken(foreignAssetA)\n        supportedToken(foreignAssetB)\n        nonReentrant\n        validateGas\n        returns (uint256 foreignAmountOut)\n    {\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(\n            foreignAssetA\n        ); // gas savings\n\n        require(\n            foreignReserve + foreignAmountIn <=\n                foreignAssetA.balanceOf(address(this)),\n            \"BasePoolV2::doubleSwap: Insufficient Tokens Provided\"\n        );\n\n        uint256 nativeAmountOut = VaderMath.calculateSwap(\n            foreignAmountIn,\n            foreignReserve,\n            nativeReserve\n        );\n\n        require(\n            nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n            \"BasePoolV2::doubleSwap: Swap Impossible\"\n        );\n\n        _update(\n            foreignAssetA,\n            nativeReserve - nativeAmountOut,\n            foreignReserve + foreignAmountIn,\n            nativeReserve,\n            foreignReserve\n        );\n\n        emit Swap(\n            foreignAssetA,\n            msg.sender,\n            0,\n            foreignAmountIn,\n            nativeAmountOut,\n            0,\n            address(this)\n        );\n\n        (nativeReserve, foreignReserve, ) = getReserves(foreignAssetB); // gas savings\n\n        foreignAmountOut = VaderMath.calculateSwap(\n            nativeAmountOut,\n            nativeReserve,\n            foreignReserve\n        );\n\n        require(\n            foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n            \"BasePoolV2::doubleSwap: Swap Impossible\"\n        );\n\n        _update(\n            foreignAssetB,\n            nativeReserve + nativeAmountOut,\n            foreignReserve - foreignAmountOut,\n            nativeReserve,\n            foreignReserve\n        );\n\n        emit Swap(\n            foreignAssetB,\n            msg.sender,\n            nativeAmountOut,\n            0,\n            0,\n            foreignAmountOut,\n            to\n        );\n\n        foreignAssetB.safeTransfer(to, foreignAmountOut);\n    }\n\n    /*\n     * @dev Allows swapping between native and foreign assets from within a single pair/pool determined\n     * by {foreignAsset}.\n     *\n     * It receives the source asset and computes the destination asset and transfers it to the {to} address.\n     *\n     * Updates the cumulative prices for native and foreign assets for the pair involved after performing swap.\n     *\n     * Returns the amount of destination tokens resulting from the swap.\n     *\n     * Requirements:\n     * - Param {nativeAmountIn} must be zero and {foreignAmountIn} must be non-zero\n     *   if the destination asset in swap is native asset.\n     * - Param {foreignAmountIn} must be zero and {nativeAmountIn} must be non zero\n     *   if the destination asset in swap is foreign asset.\n     * - Param {to} cannot be the addresses of native or foreign assets.\n     * - The source asset amount in the swap must be transferred to the pool prior to calling `swap`.\n     * - The source asset amount in the swap cannot exceed the source asset's reserve.\n     * - The destination asset's amount in the swap must be greater than 0 and not exceed destination\n     *   asset's reserve.\n     * - The param {foreignAsset} must be a supported token.\n     * - Can only be called by Router.\n     **/\n    function swap(\n        IERC20 foreignAsset,\n        uint256 nativeAmountIn,\n        uint256 foreignAmountIn,\n        address to\n    )\n        external\n        override\n        onlyRouter\n        supportedToken(foreignAsset)\n        nonReentrant\n        validateGas\n        returns (uint256)\n    {\n        require(\n            (nativeAmountIn > 0 && foreignAmountIn == 0) ||\n                (nativeAmountIn == 0 && foreignAmountIn > 0),\n            \"BasePoolV2::swap: Only One-Sided Swaps Supported\"\n        );\n        (uint112 nativeReserve, uint112 foreignReserve, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        uint256 nativeAmountOut;\n        uint256 foreignAmountOut;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            IERC20 _nativeAsset = nativeAsset;\n            require(\n                to != address(_nativeAsset) && to != address(foreignAsset),\n                \"BasePoolV2::swap: Invalid Receiver\"\n            );\n\n            if (foreignAmountIn > 0) {\n                nativeAmountOut = VaderMath.calculateSwap(\n                    foreignAmountIn,\n                    foreignReserve,\n                    nativeReserve\n                );\n                require(\n                    nativeAmountOut > 0 && nativeAmountOut <= nativeReserve,\n                    \"BasePoolV2::swap: Swap Impossible\"\n                );\n                _nativeAsset.safeTransfer(to, nativeAmountOut); // optimistically transfer tokens\n            } else {\n                foreignAmountOut = VaderMath.calculateSwap(\n                    nativeAmountIn,\n                    nativeReserve,\n                    foreignReserve\n                );\n                require(\n                    foreignAmountOut > 0 && foreignAmountOut <= foreignReserve,\n                    \"BasePoolV2::swap: Swap Impossible\"\n                );\n                foreignAsset.safeTransfer(to, foreignAmountOut); // optimistically transfer tokens\n            }\n        }\n\n        _update(\n            foreignAsset,\n            nativeReserve - nativeAmountOut + nativeAmountIn,\n            foreignReserve - foreignAmountOut + foreignAmountIn,\n            nativeReserve,\n            foreignReserve\n        );\n\n        emit Swap(\n            foreignAsset,\n            msg.sender,\n            nativeAmountIn,\n            foreignAmountIn,\n            nativeAmountOut,\n            foreignAmountOut,\n            to\n        );\n\n        return nativeAmountOut > 0 ? nativeAmountOut : foreignAmountOut;\n    }\n\n    /*\n     * @dev Allows withdrawing of unaccounted/unrealised foreign asset from the contract.\n     *\n     * Determines the realised amount of foreign asset from the pair against {foreignAsset}.\n     **/\n    function rescue(IERC20 foreignAsset) external {\n        uint256 foreignBalance = foreignAsset.balanceOf(address(this));\n        uint256 reserveForeign = pairInfo[foreignAsset].reserveForeign;\n\n        uint256 unaccounted = foreignBalance - reserveForeign;\n\n        foreignAsset.safeTransfer(msg.sender, unaccounted);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /*\n     * @dev Internally called to update the cumulative prices for native and foreign assets for\n     * the pair against {foreignAsset}. The updated prices depend upon the last reserves and\n     * updates the reserves for both of the assets corresponding to their\n     * current balances along with the timestamp.\n     *\n     * Requirements:\n     * - Params {balanceNative} and {balanceForeign} must not overflow type `uint112`.\n     *\n     **/\n    function _update(\n        IERC20 foreignAsset,\n        uint256 balanceNative,\n        uint256 balanceForeign,\n        uint112 reserveNative,\n        uint112 reserveForeign\n    ) internal {\n        require(\n            balanceNative <= type(uint112).max &&\n                balanceForeign <= type(uint112).max,\n            \"BasePoolV2::_update: Balance Overflow\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        PairInfo storage pair = pairInfo[foreignAsset];\n        unchecked {\n            uint32 timeElapsed = blockTimestamp - pair.blockTimestampLast; // overflow is desired\n            if (timeElapsed > 0 && reserveNative != 0 && reserveForeign != 0) {\n                // * never overflows, and + overflow is desired\n                pair.priceCumulative.nativeLast +=\n                    uint256(\n                        UQ112x112.encode(reserveForeign).uqdiv(reserveNative)\n                    ) *\n                    timeElapsed;\n                pair.priceCumulative.foreignLast +=\n                    uint256(\n                        UQ112x112.encode(reserveNative).uqdiv(reserveForeign)\n                    ) *\n                    timeElapsed;\n            }\n        }\n        pair.reserveNative = uint112(balanceNative);\n        pair.reserveForeign = uint112(balanceForeign);\n        pair.blockTimestampLast = blockTimestamp;\n        emit Sync(foreignAsset, balanceNative, balanceForeign);\n    }\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /*\n     * @dev Private function that returns if the param {token} is a supported token\n     * or not.\n     **/\n    function _supportedToken(IERC20 token) private view {\n        require(\n            supported[token],\n            \"BasePoolV2::_supportedToken: Unsupported Token\"\n        );\n    }\n\n    /*\n     * @dev Private function that returns if {msg.sender} is a Router or not.\n     **/\n    function _onlyRouter() private view {\n        require(\n            msg.sender == router,\n            \"BasePoolV2::_onlyRouter: Only Router is allowed to call\"\n        );\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /*\n     * @dev Modifier that only allows continuation of execution\n     * if {msg.sender} is Router.\n     **/\n    modifier onlyRouter() {\n        _onlyRouter();\n        _;\n    }\n\n    /*\n     * @dev Modifier that only allows continuation of exectuion if the param\n     * {token} is a supported token.\n     **/\n    modifier supportedToken(IERC20 token) {\n        _supportedToken(token);\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./BasePoolV2.sol\";\n\nimport \"../../interfaces/shared/IERC20Extended.sol\";\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\nimport \"../../interfaces/dex-v2/wrapper/ILPWrapper.sol\";\nimport \"../../interfaces/dex-v2/synth/ISynthFactory.sol\";\n\n/*\n * @dev Implementation of {VaderPoolV2} contract.\n *\n * The contract VaderPool inherits from {BasePoolV2} contract and implements\n * queue system.\n *\n * Extends on the liquidity redeeming function by introducing the `burn` function\n * that internally calls the namesake on `BasePoolV2` contract and computes the\n * loss covered by the position being redeemed and returns it along with amounts\n * of native and foreign assets sent.\n **/\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe token transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The LP wrapper contract\n    ILPWrapper public wrapper;\n\n    // The Synth Factory\n    ISynthFactory public synthFactory;\n\n    // Denotes whether the queue system is active\n    bool public queueActive;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /*\n     * @dev Initialised the contract state by passing the native asset's address\n     * to the inherited {BasePoolV2} contract's constructor and setting queue status\n     * to the {queueActive} state variable.\n     **/\n    constructor(bool _queueActive, IERC20 _nativeAsset)\n        BasePoolV2(_nativeAsset)\n    {\n        queueActive = _queueActive;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /*\n     * @dev Returns cumulative prices and the timestamp the were last updated\n     * for both native and foreign assets against the pair specified by\n     * parameter {foreignAsset}.\n     **/\n    function cumulativePrices(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint256 price0CumulativeLast,\n            uint256 price1CumulativeLast,\n            uint32 blockTimestampLast\n        )\n    {\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\n            .priceCumulative;\n        price0CumulativeLast = priceCumulative.nativeLast;\n        price1CumulativeLast = priceCumulative.foreignLast;\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /*\n     * @dev Initializes contract's state with LP wrapper, synth factory\n     * and router addresses.\n     *\n     * Requirements:\n     * - None of the parameters are zero addresses.\n     * - The parameters are not already set.\n     * - Only callable by contract owner.\n     **/\n    function initialize(\n        ILPWrapper _wrapper,\n        ISynthFactory _synthFactory,\n        address _router\n    ) external onlyOwner {\n        require(\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Already initialized\"\n        );\n        require(\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\n        );\n        require(\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\n        );\n        require(\n            _router != _ZERO_ADDRESS,\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\n        );\n        wrapper = _wrapper;\n        synthFactory = _synthFactory;\n        router = _router;\n    }\n\n    /*\n     * @dev Allows minting of synthetic assets corresponding to the {foreignAsset} based\n     * on the native asset amount deposited and returns the minted synth asset amount.\n     *\n     * Creates the synthetic asset against {foreignAsset} if it does not already exist.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must be a supported token.\n     **/\n    function mintSynth(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        supportedToken(foreignAsset)\n        returns (uint256 amountSynth)\n    {\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        if (synth == ISynth(_ZERO_ADDRESS))\n            synth = synthFactory.createSynth(\n                IERC20Extended(address(foreignAsset))\n            );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountSynth = VaderMath.calculateSwap(\n            nativeDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        synth.mint(to, amountSynth);\n    }\n\n    /*\n     * @dev Allows burning of synthetic assets corresponding to the {foreignAsset}\n     * and returns the redeemed amount of native asset.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Requirements:\n     * - {foreignAsset} must have a valid synthetic asset against it.\n     * - {synthAmount} must be greater than zero.\n     **/\n    function burnSynth(\n        IERC20 foreignAsset,\n        uint256 synthAmount,\n        address to\n    ) external override nonReentrant returns (uint256 amountNative) {\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        require(\n            synth != ISynth(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\n        );\n\n        require(\n            synthAmount > 0,\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\n        );\n\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\n        synth.burn(synthAmount);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountNative = VaderMath.calculateSwap(\n            synthAmount,\n            reserveForeign,\n            reserveNative\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        nativeAsset.safeTransfer(to, amountNative);\n    }\n\n    /*\n     * @dev Allows burning of NFT represented by param {id} for liquidity redeeming.\n     *\n     * Deletes the position in {positions} mapping against the burned NFT token.\n     *\n     * Internally calls `_burn` function on {BasePoolV2} contract.\n     *\n     * Calculates the impermanent loss incurred by the position.\n     *\n     * Returns the amounts for native and foreign assets sent to the {to} address\n     * along with the covered loss.\n     *\n     * Requirements:\n     * - Can only be called by the Router.\n     **/\n    // NOTE: IL is only covered via router!\n    function burn(uint256 id, address to)\n        external\n        override\n        onlyRouter\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n\n        // NOTE: Validate it behaves as expected for non-18 decimal tokens\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n\n        // TODO: Original Implementation Applied 100 Days\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n\n    /*\n     * @dev Allows minting of liquidity in fungible tokens. The fungible token\n     * is a wrapped LP token against a particular pair. The liquidity issued is also\n     * tracked within this contract along with liquidity issued against non-fungible\n     * token.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'mint' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     **/\n    function mintFungible(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override nonReentrant returns (uint256 liquidity) {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\n        );\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        lp.mint(to, liquidity);\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n    }\n\n    /*\n     * @dev Allows burning of liquidity issued in fungible tokens.\n     *\n     * Updates the cumulative prices for native and foreign assets.\n     *\n     * Calls 'burn' on the LP wrapper token contract.\n     *\n     * Requirements:\n     * - LP wrapper token must exist against {foreignAsset}.\n     * - {amountNative} and {amountForeign} redeemed, both must be greater than zero.,\n     **/\n    function burnFungible(\n        IERC20 foreignAsset,\n        uint256 liquidity,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\n        );\n\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\n        lp.burn(liquidity);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    // TODO: Investigate Necessity\n    function toggleQueue() external override onlyOwner {\n        bool _queueActive = !queueActive;\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setTokenSupport(IERC20 foreignAsset, bool support)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            supported[foreignAsset] != support,\n            \"VaderPoolV2::supportToken: Already At Desired State\"\n        );\n        supported[foreignAsset] = support;\n    }\n\n    /*\n     * @dev Sets the supported state of the token represented by param {foreignAsset}.\n     *\n     * Requirements:\n     * - The param {foreignAsset} is not already a supported token.\n     **/\n    function setFungibleTokenSupport(IERC20 foreignAsset)\n        external\n        override\n        onlyOwner\n    {\n        wrapper.createWrapper(foreignAsset);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n\n\n",
        "CodeNames": [
            "BasePoolV2.sol",
            "VaderPoolV2.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BasePoolV2.sol#L270 and VaderPoolV2.sol#L374",
                "Type": "Mixing different types of LP shares can lead to losses for Synth holders",
                "Description": "Users that mint Synths do not get pool shares, so exiting of normal LP can lead to their losses as no funds can be left for retrieval.",
                "Repair": "Implement a mechanism to ensure that LPs cannot withdraw more than their fair share of the pool liquidity"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../../interfaces/external/chainlink/IAggregator.sol\";\n\ncontract GasThrottle is ProtocolConstants {\n    modifier validateGas() {\n        // TODO: Uncomment prior to launch\n        // require(\n        //     block.basefee <= tx.gasprice &&\n        //         tx.gasprice <=\n        //         uint256(IAggregator(_FAST_GAS_ORACLE).latestAnswer()),\n        //     \"GasThrottle::validateGas: Gas Exceeds Thresholds\"\n        // );\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../external/interfaces/AggregatorV3Interface.sol\";\nimport \"../external/interfaces/IUniswapV2Factory.sol\";\nimport \"../external/interfaces/IUniswapV2Pair.sol\";\n\nimport \"../external/libraries/FixedPoint.sol\";\nimport \"../external/libraries/UniswapV2OracleLibrary.sol\";\nimport \"../external/libraries/UniswapV2Library.sol\";\n\nimport \"../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\n\ncontract TwapOracle is Ownable {\n    /* ========== LIBRARIES ========== */\n\n    using FixedPoint for *;\n\n    /* ========== STRUCTURES ========== */\n\n    struct PairData {\n        // The address of the pair interface (IUniswapV2Pair or IVaderPoolV2)\n        address pair;\n        // The first token of the pair.\n        address token0;\n        // The second token of the pair.\n        address token1;\n        // The last cumulative price of the first token.\n        uint256 price0CumulativeLast;\n        // The last cumulative price of the second token.\n        uint256 price1CumulativeLast;\n        // The block timestamp of the last update.\n        uint32 blockTimestampLast;\n        // The average price of the first token.\n        FixedPoint.uq112x112 price0Average;\n        // The average price of the second token.\n        FixedPoint.uq112x112 price1Average;\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The address of the deployed VADER token.\n    address public VADER;\n\n    // The address of the deployed USDV token.\n    address public USDV;\n\n    // A predicated which determines if USDV is enabled.\n    bool private _usdvEnabled;\n\n    // The mapping of native assets to USD aggregators.\n    mapping(address => address) private _aggregators;\n\n    // The vader pool used across all native assets.\n    IVaderPoolV2 private _vaderPool;\n\n    // The frequency that the pair collection should be updated.\n    uint256 private _updatePeriod;\n\n    // The collection of pairs tracked by the TWAP oracle.\n    PairData[] private _pairs;\n\n    // A mapping of pair hashes to existence predicates.\n    mapping(bytes32 => bool) private _pairExists;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /**\n     * @dev Constructs a new TWAP oracle with a VADER pool and update period.\n     * @param vaderPool The VADER pool address.\n     * @param updatePeriod The required period of time between each oracle update.\n     */\n    constructor(address vaderPool, uint256 updatePeriod) Ownable() {\n        _vaderPool = IVaderPoolV2(vaderPool);\n        _updatePeriod = updatePeriod;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier initialized() {\n        require(\n            VADER != address(0) && USDV != address(0),\n            \"TwapOracle::initialized: not initialized\"\n        );\n        _;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @dev Checks if a pair exists for the supplied {token0} and {token1} addresses.\n     * @param token0 The primary token address, either VADER or USDV.\n     * @param token1 The asset token address, paired to either VADER or USDV.\n     */\n    function pairExists(address token0, address token1)\n        public\n        view\n        returns (bool)\n    {\n        bytes32 pairHash0 = keccak256(abi.encodePacked(token0, token1));\n        bytes32 pairHash1 = keccak256(abi.encodePacked(token1, token0));\n        return _pairExists[pairHash0] || _pairExists[pairHash1];\n    }\n\n    /**\n     * @dev Performs a consultation to retrieve the equivalent to {amountIn} for the supplied {token} address.\n     * The {token} address must have a registered pairing, otherwise the transaction will revert.\n     * @param token The token address to consult the equivalent {amountIn} for.\n     */\n    function consult(address token) public view returns (uint256 result) {\n        uint256 pairCount = _pairs.length;\n        uint256 sumNative = 0;\n        uint256 sumUSD = 0;\n\n        for (uint256 i = 0; i < pairCount; i++) {\n            PairData memory pairData = _pairs[i];\n\n            if (token == pairData.token0) {\n                //\n                // TODO - Review:\n                //   Verify price1Average is amount of USDV against 1 unit of token1\n                //\n\n                sumNative += pairData.price1Average.mul(1).decode144(); // native asset amount\n                if (pairData.price1Average._x != 0) {\n                    require(sumNative != 0);\n                }\n\n                (\n                    uint80 roundID,\n                    int256 price,\n                    ,\n                    ,\n                    uint80 answeredInRound\n                ) = AggregatorV3Interface(_aggregators[pairData.token1])\n                        .latestRoundData();\n\n                require(\n                    answeredInRound >= roundID,\n                    \"TwapOracle::consult: stale chainlink price\"\n                );\n                require(\n                    price != 0,\n                    \"TwapOracle::consult: chainlink malfunction\"\n                );\n\n                sumUSD += uint256(price) * (10**10);\n            }\n        }\n        require(sumNative != 0, \"TwapOracle::consult: Sum of native is zero\");\n        result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative);\n    }\n\n    /**\n     * @dev Gets the exchange rate for the Vader to USDV.\n     */\n    function getRate() public view returns (uint256 result) {\n        uint256 tUSDInUSDV = consult(USDV);\n        uint256 tUSDInVader = consult(VADER);\n\n        result = tUSDInUSDV / tUSDInVader;\n    }\n\n    /**\n     * @dev Gets the VADER amount from the supplied USDV amount.\n     * @param usdvAmount The amount in USDV.\n     */\n    function usdvtoVader(uint256 usdvAmount) external view returns (uint256) {\n        return usdvAmount * getRate();\n    }\n\n    /**\n     * @dev Gets the USDV amount from the supplied VADER amount.\n     * @param vaderAmount The amount in VADER.\n     */\n    function vaderToUsdv(uint256 vaderAmount) external view returns (uint256) {\n        if (!_usdvEnabled) {\n            // consult call returns true USD amount against 1 Vader and is multiplied with {vaderAmount}.\n            return consult(VADER) * vaderAmount;\n        }\n\n        // usdv price is disabled so true USD value of both Vader and USDV is taken into account.\n        return vaderAmount / getRate();\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @dev Initializes the variables for VADER and USDV.\n     * @param _usdv The USDV token address.\n     * @param _vader The VADER token address.\n     */\n    function initialize(address _usdv, address _vader) external onlyOwner {\n        require(\n            VADER == address(0),\n            \"TwapOracle::initialize: Vader already set\"\n        );\n        require(USDV == address(0), \"TwapOracle::initialize: USDV already set\");\n        require(\n            _usdv != address(0),\n            \"TwapOracle::initialize: can not set to a zero address\"\n        );\n        require(\n            _vader != address(0),\n            \"TwapOracle::initialize: can not set to a zero address\"\n        );\n\n        VADER = _vader;\n        USDV = _usdv;\n    }\n\n    /**\n     * @dev Enables utilization of USDV.\n     */\n    function enableUSDV() external onlyOwner {\n        _usdvEnabled = true;\n    }\n\n    /**\n     * @dev Registers a chainlink {aggregator} for the supplied {asset} address.\n     * @param asset The address of the native asset.\n     * @param aggregator The address of the chainlink aggregator.\n     */\n    function registerAggregator(address asset, address aggregator)\n        external\n        onlyOwner\n        initialized\n    {\n        require(\n            asset != address(0),\n            \"TwapOracle::registerAggregator: asset zero address provided\"\n        );\n        require(\n            aggregator != address(0),\n            \"TwapOracle::registerAggregator: aggregator zero address provided\"\n        );\n        require(\n            _aggregators[asset] == address(0),\n            \"TwapOracle::registerAggregator: aggregator already exists\"\n        );\n\n        _aggregators[asset] = aggregator;\n    }\n\n    /**\n     * @dev Registers either a VADER or USDV pairing in the TWAP oracle.\n     * @param factory The factory address, if any.\n     * @param token0 The primary token address, either VADER or USDV.\n     * @param token1 The asset token address, paired to VADER or USDV.\n     */\n    function registerPair(\n        address factory,\n        address token0,\n        address token1\n    ) external onlyOwner initialized {\n        require(\n            token0 == VADER || token0 == USDV,\n            \"TwapOracle::registerPair: Invalid token0 address\"\n        );\n        require(\n            token0 != token1,\n            \"TwapOracle::registerPair: Same token address\"\n        );\n        require(\n            !pairExists(token0, token1),\n            \"TwapOracle::registerPair: Pair exists\"\n        );\n\n        address pairAddr;\n        uint256 price0CumulativeLast;\n        uint256 price1CumulativeLast;\n        uint112 reserve0;\n        uint112 reserve1;\n        uint32 blockTimestampLast;\n\n        if (token0 == VADER) {\n            IUniswapV2Pair pair = IUniswapV2Pair(\n                IUniswapV2Factory(factory).getPair(token0, token1)\n            );\n            pairAddr = address(pair);\n            price0CumulativeLast = pair.price0CumulativeLast();\n            price1CumulativeLast = pair.price1CumulativeLast();\n            (reserve0, reserve1, blockTimestampLast) = pair.getReserves();\n        } else {\n            pairAddr = address(_vaderPool);\n            (price0CumulativeLast, price1CumulativeLast, ) = _vaderPool\n                .cumulativePrices(IERC20(token1));\n            (reserve0, reserve1, blockTimestampLast) = _vaderPool.getReserves(\n                IERC20(token1)\n            );\n        }\n\n        require(\n            reserve0 != 0 && reserve1 != 0,\n            \"TwapOracle::registerPair: No reserves\"\n        );\n\n        _pairExists[keccak256(abi.encodePacked(token0, token1))] = true;\n\n        _pairs.push(\n            PairData({\n                pair: pairAddr,\n                token0: token0,\n                token1: token1,\n                price0CumulativeLast: price0CumulativeLast,\n                price1CumulativeLast: price1CumulativeLast,\n                blockTimestampLast: blockTimestampLast,\n                price0Average: FixedPoint.uq112x112({_x: 0}),\n                price1Average: FixedPoint.uq112x112({_x: 0})\n            })\n        );\n    }\n\n    /**\n     * @dev Updates the average prices for all token pairs registered in the TWAP oracle.\n     */\n    function update() external onlyOwner initialized {\n        uint256 pairCount = _pairs.length;\n\n        // Update all of the registered pairs in the TWAP oracle.\n        for (uint256 i = 0; i < pairCount; i++) {\n            PairData storage pairData = _pairs[i];\n\n            // Get the current cumulative prices and block timestamp of the current pairing.\n            (\n                uint256 price0Cumulative,\n                uint256 price1Cumulative,\n                uint32 blockTimestamp\n            ) = (pairData.token0 == VADER)\n                    ? UniswapV2OracleLibrary.currentCumulativePrices(\n                        pairData.pair\n                    )\n                    : _vaderPool.cumulativePrices(IERC20(pairData.token1));\n\n            unchecked {\n                // Ensure that at least one full period has passed since the pairing was last update.\n                uint32 timeElapsed = blockTimestamp -\n                    pairData.blockTimestampLast;\n                require(\n                    timeElapsed >= _updatePeriod,\n                    \"TwapOracle::update: Period not elapsed\"\n                );\n\n                // Cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed.\n                pairData.price0Average = FixedPoint.uq112x112(\n                    uint224(\n                        (price0Cumulative - pairData.price0CumulativeLast) /\n                            timeElapsed\n                    )\n                );\n                pairData.price1Average = FixedPoint.uq112x112(\n                    uint224(\n                        (price1Cumulative - pairData.price1CumulativeLast) /\n                            timeElapsed\n                    )\n                );\n            }\n\n            // Update the stored pairing data\n            pairData.price0CumulativeLast = price0Cumulative;\n            pairData.price1CumulativeLast = price1Cumulative;\n            pairData.blockTimestampLast = blockTimestamp;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "GasThrottle.sol",
            "TwapOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TwapOracle.sol#L134-L150 and GasThrottle.sol#L15",
                "Type": "Lacking Validation Of Chainlink' Oracle Queries",
                "Description": "TwapOracle.consult() is missing additional validations to ensure that the round is complete and has returned a valid/expected price.",
                "Repair": "Validate the output of latestRoundData() to ensure that the round is complete and has returned a valid/expected price. Replace the latestAnswer() function with latestRoundData() in GasThrottle.validateGas()."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "vestFor function",
                "Type": "Unrestricted vestFor",
                "Description": "Anyone can call function vestFor and block any user with a tiny amount of Vader. This function has no auth checks so a malicious actor can front-run legit vestFor calls with insignificant amounts.",
                "Repair": "Introduce a whitelist of callers that can vest on behalf of others (e.g. Converter)"
            },
            {
                "Location": "TWAPOracle.sol",
                "Type": "TWAPOracle.getRate does not scale the ratio",
                "Description": "The TWAPOracle.getRate function simply performs an integer division to compute the rate.",
                "Repair": "Scale the rate by some value, for example, 1e18"
            }
        ]
    }
]