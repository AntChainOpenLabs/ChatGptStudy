[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "HybridPool contract",
                "Type": "Funds theft",
                "Description": "An attacker can call the bento.harvest function during the callback function of a flash swap of the HybridPool to reduce the number of input tokens that he has to pay to the pool, as long as there is any unrealized profit in the strategy contract of the underlying asset.",
                "Repair": "Consider not using bento.toAmount to track the reservers and balances, but use balanceOf instead (as done in the other two pools)."
            },
            {
                "Location": "TridentRouter contract",
                "Type": "Rounding errors",
                "Description": "Some rare tokens have 0 decimals, and for these tokens, small losses of precision will be amplified by the lack of decimals.",
                "Repair": "Rounding the final getAmountOut division upwards would fix this."
            },
            {
                "Location": "_depositToBentoBox and _depositFromUserToBentoBox functions in TridentRouter contract",
                "Type": "Back-running vulnerability",
                "Description": "In these two functions, the input parameter does not represent the actual amount of ETH to deposit, and users have to calculate the actual amount and send it to the router, causing a back-run vulnerability if there are ETH left after the operation.",
                "Repair": "Directly push the remaining ETH to the sender to prevent any ETH left in the router."
            },
            {
                "Location": "_depositToBentoBox function in TridentRouter contract",
                "Type": "Use of both ETH and WETH",
                "Description": "The TridentRouter._depositToBentoBox function only uses the ETH in the contract if it's higher then the desired underlyingAmount. Otherwise, the ETH is ignored and the function uses WETH from the user.",
                "Repair": "Each batch must use refundETH at the end. Furthermore, we recommend still depositing address(this).balance ETH into Bento and if it's less than underlyingAmount use WETH only for the remaining token difference."
            },
            {
                "Location": "TridentRouter contract",
                "Type": "Failure when adding liquidity to index pool",
                "Description": "TridentRouter is easy to fail when trying to provide liquidity to an index pool. Users would either transfer extra tokens or fail.",
                "Repair": "The router should calculate the optimal parameters for users."
            },
            {
                "Location": "IndexPool contract",
                "Type": "Flash swap vulnerability",
                "Description": "In the IndexPool contract, flashSwap does not work. The callback function is called prior to token transfer. The sender won't receive tokens in the callBack function.",
                "Repair": "Flashswap is not implemented correctly. It may need a migration to redeploy all indexPools if the issue is found after main-net launch."
            },
            {
                "Location": "IndexPool.mint function",
                "Type": "Unsafe cast",
                "Description": "Unsafe cast in IndexPool mint leads to attack",
                "Repair": "Use SafeCast library everywhere a typecast is done"
            },
            {
                "Location": "IndexPool.sol L286-L291",
                "Type": "Error in pow implementation",
                "Description": "Index Pool always swap to Zero",
                "Repair": "Add brackets for 'for' loop"
            },
            {
                "Location": "IndexPool.sol L110",
                "Type": "Integer overflow",
                "Description": "Overflow in the mint function of IndexPool causes LPs' funds to be stolen",
                "Repair": "Cast amountIn to uint256"
            },
            {
                "Location": "HybridPool.sol L425-L441",
                "Type": "Pricing/Fee issue",
                "Description": "Hybrid pool uses wrong non_optimal_mint_fee",
                "Repair": "Calculate the swapping fee based on the stable swap curve"
            },
            {
                "Location": "TridentRouter.complexPath function",
                "Type": "Incorrect calculation",
                "Description": "Router's complexPath percentagePaths don't work as expected",
                "Repair": "Cache the balanceShares value once before the second for loop starts"
            },
            {
                "Location": "HybridPool's reserve",
                "Type": "Data inconsistency",
                "Description": "HybridPool's reserve is converted to 'amount' twice",
                "Repair": "Make sure that the reserves are in the correct amounts"
            },
            {
                "Location": "ConstantProductPool.burnSingle function",
                "Type": "Data inconsistency",
                "Description": "ConstantProductPool.burnSingle swap amount computations should use balance",
                "Repair": "Call _getAmountOut with the balances instead of the reserves"
            },
            {
                "Location": "TridentHelper.withdrawFromWETH function",
                "Type": "Incorrect function implementation",
                "Description": "withdrawFromWETH always reverts",
                "Repair": "Remove the data.length = 32 from the require and only check if success is true"
            },
            {
                "Location": "IndexPool.mint function in IndexPool.sol",
                "Type": "High Severity",
                "Description": "The first liquidity provider is forced to supply assets in the same amount, which may cause a significant amount of fund loss.",
                "Repair": "Allow the first liquidity provider to use custom amountIn values for each token or always take the MIN_BALANCE of each token"
            },
            {
                "Location": "HybridPool.sol",
                "Type": "Medium Severity",
                "Description": "Approximations may finish with inaccurate values.",
                "Repair": "Revert the transactions if approximation does not converge"
            },
            {
                "Location": "ConstantProductPool and HybridPool in MathUtils.sol",
                "Type": "Medium Severity",
                "Description": "Adding and removing unbalanced liquidity yields slightly more tokens than swap.",
                "Repair": "Distribute the minted fee to existing LPs first by incrementing reserve0 and reserve1 with the fee amounts"
            },
            {
                "Location": "MathUtils.sol",
                "Type": "High Severity",
                "Description": "Absolute difference is not calculated properly when a > b in MathUtils.",
                "Repair": "Add an else condition to the difference function to mitigate it"
            },
            {
                "Location": "IndexPool.sol",
                "Type": "Medium Severity",
                "Description": "No bar fees for IndexPools.",
                "Repair": "Add a way to send barFees to barFeeTo, same as the other pools"
            },
            {
                "Location": "IndexPool.sol",
                "Type": "High Severity",
                "Description": "IndexPool's INIT_POOL_SUPPLY is not fair.",
                "Repair": "Determine an optimized parameter for the user"
            },
            {
                "Location": "IndexPool.sol",
                "Type": "High Severity",
                "Description": "Incorrect usage of _pow in _computeSingleOutGivenPoolIn of IndexPool.",
                "Repair": "Change the _pow function to the _compute function, which supports exponents in WAD"
            },
            {
                "Location": "_computeSingleOutGivenPoolIn function of IndexPool",
                "Type": "Incorrect multiplication",
                "Description": "The _computeSingleOutGivenPoolIn function of IndexPool uses the raw multiplication (i.e., *) to calculate the zaz variable. However, since both (BASE normalizedWeight) and _swapFee are in WAD, the _mul function should be used instead to calculate the correct value of zaz. Otherwise, zaz would be 10^18 times larger than the expected value and causes an integer underflow when calculating amountOut. The incorrect usage of multiplication prevents anyone from calling the function successfully.",
                "Repair": "Change (BASE normalizedWeight) * _swapFee to _mul((BASE normalizedWeight), _swapFee)"
            },
            {
                "Location": "IndexPool contract, pow is used in calculating price",
                "Type": "pow overflows",
                "Description": "In the IndexPool contract, pow is used in calculating price. However, Pow is easy to cause overflow. If the weightRatio is large (e.g. 10), there's always overflow. Lp providers can still provide liquidity to the pool where no one can swap. All pools need to redeploy. I consider this a high-risk issue.",
                "Repair": "The weightRatio is an 18 decimals number. It should be divided by (BASE)^exp. The scale in the contract is not consistent. Recommend the dev to check all the scales/ decimals."
            },
            {
                "Location": "A number of functions in IndexPool contract",
                "Type": "Poor conversion",
                "Description": "A number of functions in IndexPool contract suffer from the erroneous conversion of Balancer V1's implementation.",
                "Repair": "The fixed implementation is provided in the article section"
            },
            {
                "Location": "IndexPool constructor function",
                "Type": "initial LP supply computation is wrong",
                "Description": "The IndexPool constructor function already mints INIT_POOL_SUPPLY = 100 * 1e18 = 1e20 LP tokens to the zero address. When trying to use the pool, someone has to provide the actual initial reserve tokens in mint. On the first mint, the pool reserves are zero and the token amount required to mint is just this ratio itself.",
                "Repair": "Do not mint the initial token supply to the zero address in the constructor. Do it like Uniswap/Balancer and let the first liquidity provider provide arbitrary token amounts, then mint the initial pool supply. If reserve == 0, amountIn should just take the pool balances that were transferred to this account. In case the initial mint to the zero address in the constructor was done to prevent the Uniswap-attack where the price of a single wei of LP token can be very high and price out LPs, send a small fraction of this initial LP supply (~1000) to the zero address after it was minted to the first supplier in mint."
            },
            {
                "Location": "HybridPool flashSwap function",
                "Type": "flashSwap sends entire fee to barFeeTo",
                "Description": "The HybridPool.flashSwap function sends the entire trade fees fee to the barFeeTo. It should only send barFee * fee to the barFeeTo address. LPs are not getting paid at all when this function is used. There is no incentive to provide liquidity.",
                "Repair": "The flashSwap function should use the same fee mechanism as swap and only send barFee * fee / MAX_FEE to the barFeeTo. See _handleFee function."
            }
        ]
    }
]