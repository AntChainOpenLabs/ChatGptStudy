[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Private Pool (NFT collateral)\n\n//    (                (   (\n//    )\\      )    (   )\\  )\\ )  (\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"./interfaces/IERC721.sol\";\nimport \"./interfaces/INFTOracle.sol\";\n\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\n\nstruct SignatureParams {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\n\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n\n    function asset() external view returns (IERC20);\n\n    function masterContract() external view returns (address);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n\n/// @title NFTPairWithOracle\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\ncontract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogRequestLoan(\n        address indexed borrower,\n        uint256 indexed tokenId,\n        uint128 valuation,\n        uint64 duration,\n        uint16 annualInterestBPS,\n        uint16 ltvBPS\n    );\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPairWithOracle public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n\n    // A note on terminology:\n    // \"Shares\" are BentoBox shares.\n\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n\n    // Per token settings.\n    mapping(uint256 => TokenLoanParams) public tokenLoanParams;\n\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 => TokenLoan) public tokenLoan;\n\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n\n    // Highest order term in the Maclaurin series for exp used by\n    // `calculateIntest`.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns \"second-order\" interest-on-interest, which\n    // itself earns \"third-order\" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \\           x^k                \\              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why \"at least\"? There are also rounding errors. See\n    // `calculateInterest` for more detail.\n    // The factorial in the denominator \"wins\"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the \"true\" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in \"total\"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n\n    // For signed lend / borrow requests:\n    mapping(address => uint256) public nonces;\n\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via `init`.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), \"NFTPair: already initialized\");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), \"NFTPair: bad pair\");\n    }\n\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, \"NFTPair: not the lender\");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration >= cur.duration &&\n                    params.valuation <= cur.valuation &&\n                    params.annualInterestBPS <= cur.annualInterestBPS &&\n                    params.ltvBPS <= cur.ltvBPS,\n                \"NFTPair: worse params\"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert(\"NFTPair: no collateral\");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    function _requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, \"NFTPair: loan exists\");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), \"NFTPair: skim failed\");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n\n    /// @notice Removes `tokenId` as collateral and transfers it to `to`.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, \"NFTPair: not the lender\");\n\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(rate.mul(loanParams.ltvBPS) / BPS < amount, \"NFT is still valued\");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with `skim` set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, \"NFTPair: not available\");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as `accepted`.\n        require(\n            params.valuation == accepted.valuation &&\n                params.duration <= accepted.duration &&\n                params.annualInterestBPS >= accepted.annualInterestBPS &&\n                params.ltvBPS >= accepted.ltvBPS,\n            \"NFTPair: bad params\"\n        );\n\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, \"Oracle: price too low.\");\n        }\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                \"NFTPair: skim too much\"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS <= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }\n\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n\n    // keccak256(\"Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;\n\n    // keccak256(\"Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;\n\n    /// @notice Request and immediately borrow from a pre-committed lender\n\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        SignatureParams memory signature\n    ) public {\n        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), \"NFTPair: LendingClub does not like you\");\n        } else {\n            require(block.timestamp <= signature.deadline, \"NFTPair: signature expired\");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    params.ltvBPS,\n                    params.oracle,\n                    nonce,\n                    signature.deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, \"NFTPair: signature invalid\");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        SignatureParams memory signature\n    ) public {\n        require(block.timestamp <= signature.deadline, \"NFTPair: signature expired\");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                params.ltvBPS,\n                params.oracle,\n                nonce,\n                signature.deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, \"NFTPair: signature invalid\");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n\n    /// Approximates continuous compounding. Uses Horner's method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n > 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \\           principal * (t * aprBPS)^k        \\\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the \"theoretical\" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term_{k-1} * ------------                          (*)\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From (*) we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M >= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n\n        interest = term_k;\n        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // <- Only overflow check we need\n        }\n\n        if (interest >= 2**128) {\n            revert();\n        }\n    }\n\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, \"NFTPair: no loan\");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration > block.timestamp,\n            \"NFTPair: loan expired\"\n        );\n\n        uint128 principal = loanParams.valuation;\n\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), \"NFTPair: skim too much\");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n\n        emit LogRepay(from, tokenId);\n    }\n\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into `bentoBox`.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the `bentoBox`.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.\n    /// This also means that calls made from this contract shall *not* be trusted.\n    function _call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 && !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), \"NFTPair: can't call\");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, \"NFTPair: call failed\");\n        return (returnData, returnValues);\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i < actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    SignatureParams memory signature\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi\n                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);\n            }\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n\n        uint256 _share = feesEarnedShare;\n        if (_share > 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, _share);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n\n\n",
        "CodeNames": [
            "NFTPairWithOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTPairWithOracle.sol:286-288",
                "Type": "Critical Oracle Manipulation Risk",
                "Description": "The lender could change the Oracle once a loan is outstanding, and therefore seize the collateral at the expense of the borrower, if the actual value of the collateral has increased significantly.",
                "Repair": "Add a check in the require statement in line 205-211 that params.oracle == cur.oracle"
            },
            {
                "Location": "NFTPairWithOracle.sol:316",
                "Type": "Avoidance of Liquidation Via Malicious Oracle",
                "Description": "A borrower who requests a loan with a malicious oracle can avoid legitimate liquidation.",
                "Repair": "Add require(params.oracle == accepted.oracle) as a condition in _lend. Consider only allowing whitelisted oracles, to avoid injection of malicious oracles at the initial loan request stage"
            },
            {
                "Location": "NFTPairWithOracle.sol:198-223",
                "Type": "Lender is able to seize the collateral by changing the loan parameters",
                "Description": "The lender is able to seize the collateral at any time by modifying the loan parameters.",
                "Repair": "Don't allow updateLoanParams() to change the ltvBPS value"
            },
            {
                "Location": "NFTPairWithOracle.sol:316",
                "Type": "Mistake while checking LTV to lender accepted LTV",
                "Description": "It comments in the _lend() function that lender accepted conditions must be at least as good as the borrower is asking for.",
                "Repair": "Change the condition to params.ltvBPS <= accepted.ltvBPS"
            },
            {
                "Location": "NFTPairWithOracle contract",
                "Type": "Unchecked return value",
                "Description": "The success value returned by the get function of the INFTOracle interface is not checked in the NFTPairWithOracle contract, which may result in stale data being used and assets being lost. The vulnerability has been confirmed and upgraded to High severity.",
                "Repair": "Check the success value returned by the get function of the INFTOracle interface before using the rate value"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Private Pool (NFT collateral)\n\n//    (                (   (\n//    )\\      )    (   )\\  )\\ )  (\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"./interfaces/IERC721.sol\";\n\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n}\n\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\n\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n\n    function asset() external view returns (IERC20);\n\n    function masterContract() external view returns (address);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n\n/// @title NFTPair\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\ncontract NFTPair is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogRequestLoan(address indexed borrower, uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPair public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n\n    // A note on terminology:\n    // \"Shares\" are BentoBox shares.\n\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n\n    // Per token settings.\n    mapping(uint256 => TokenLoanParams) public tokenLoanParams;\n\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 => TokenLoan) public tokenLoan;\n\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n\n    // Highest order term in the Maclaurin series for exp used by\n    // `calculateIntest`.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns \"second-order\" interest-on-interest, which\n    // itself earns \"third-order\" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \\           x^k                \\              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why \"at least\"? There are also rounding errors. See\n    // `calculateInterest` for more detail.\n    // The factorial in the denominator \"wins\"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the \"true\" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in \"total\"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n\n    // For signed lend / borrow requests:\n    mapping(address => uint256) public nonces;\n\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via `init`.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), \"NFTPair: already initialized\");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), \"NFTPair: bad pair\");\n    }\n\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, \"NFTPair: not the lender\");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration >= cur.duration && params.valuation <= cur.valuation && params.annualInterestBPS <= cur.annualInterestBPS,\n                \"NFTPair: worse params\"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert(\"NFTPair: no collateral\");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS);\n    }\n\n    function _requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, \"NFTPair: loan exists\");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), \"NFTPair: skim failed\");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS);\n    }\n\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n\n    /// @notice Removes `tokenId` as collateral and transfers it to `to`.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral as the lender. The loan has to be\n            // expired and not paid off:\n            require(to == loan.lender, \"NFTPair: not the lender\");\n            require(\n                // Addition is safe: both summands are smaller than 256 bits\n                uint256(loan.startTime) + tokenLoanParams[tokenId].duration <= block.timestamp,\n                \"NFTPair: not expired\"\n            );\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with `skim` set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, \"NFTPair: not available\");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as `accepted`.\n        require(\n            params.valuation == accepted.valuation &&\n                params.duration <= accepted.duration &&\n                params.annualInterestBPS >= accepted.annualInterestBPS,\n            \"NFTPair: bad params\"\n        );\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                \"NFTPair: skim too much\"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS <= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }\n\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n\n    // keccak256(\"Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x06bcca6f35b7c1b98f11abbb10957d273a681069ba90358de25404f49e2430f8;\n\n    // keccak256(\"Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xf2c9128b0fb8406af3168320897e5ff08f3bb536dd5f804c29ed276e93ec4336;\n\n    /// @notice Request and immediately borrow from a pre-committed lender\n\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        if (v == 0 && r == bytes32(0) && s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), \"NFTPair: LendingClub does not like you\");\n        } else {\n            require(block.timestamp <= deadline, \"NFTPair: signature expired\");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    nonce,\n                    deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), v, r, s) == lender, \"NFTPair: signature invalid\");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(block.timestamp <= deadline, \"NFTPair: signature expired\");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                nonce,\n                deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), v, r, s) == borrower, \"NFTPair: signature invalid\");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n\n    /// Approximates continuous compounding. Uses Horner's method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n > 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \\           principal * (t * aprBPS)^k        \\\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the \"theoretical\" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term_{k-1} * ------------                          (*)\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From (*) we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M >= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n\n        interest = term_k;\n        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // <- Only overflow check we need\n        }\n\n        if (interest >= 2**128) {\n            revert();\n        }\n    }\n\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, \"NFTPair: no loan\");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration > block.timestamp,\n            \"NFTPair: loan expired\"\n        );\n\n        uint128 principal = loanParams.valuation;\n\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), \"NFTPair: skim too much\");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n\n        emit LogRepay(from, tokenId);\n    }\n\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into `bentoBox`.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the `bentoBox`.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.\n    /// This also means that calls made from this contract shall *not* be trusted.\n    function _call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 && !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), \"NFTPair: can't call\");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, \"NFTPair: call failed\");\n        return (returnData, returnValues);\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i < actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, uint256, uint8, bytes32, bytes32));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, deadline, v, r, s);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (\n                    uint256 tokenId,\n                    address borrower,\n                    TokenLoanParams memory params,\n                    bool skimFunds,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = abi.decode(datas[i], (uint256, address, TokenLoanParams, bool, uint256, uint8, bytes32, bytes32));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, deadline, v, r, s);\n            }\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n\n        uint256 _share = feesEarnedShare;\n        if (_share > 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, _share);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\n// Private Pool (NFT collateral)\n\n//    (                (   (\n//    )\\      )    (   )\\  )\\ )  (\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"./interfaces/IERC721.sol\";\nimport \"./interfaces/INFTOracle.sol\";\n\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\n\nstruct SignatureParams {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\n\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n\n    function asset() external view returns (IERC20);\n\n    function masterContract() external view returns (address);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n\n/// @title NFTPairWithOracle\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\ncontract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogRequestLoan(\n        address indexed borrower,\n        uint256 indexed tokenId,\n        uint128 valuation,\n        uint64 duration,\n        uint16 annualInterestBPS,\n        uint16 ltvBPS\n    );\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPairWithOracle public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n\n    // A note on terminology:\n    // \"Shares\" are BentoBox shares.\n\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n\n    // Per token settings.\n    mapping(uint256 => TokenLoanParams) public tokenLoanParams;\n\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 => TokenLoan) public tokenLoan;\n\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n\n    // Highest order term in the Maclaurin series for exp used by\n    // `calculateIntest`.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns \"second-order\" interest-on-interest, which\n    // itself earns \"third-order\" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \\           x^k                \\              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why \"at least\"? There are also rounding errors. See\n    // `calculateInterest` for more detail.\n    // The factorial in the denominator \"wins\"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the \"true\" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in \"total\"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n\n    // For signed lend / borrow requests:\n    mapping(address => uint256) public nonces;\n\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via `init`.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), \"NFTPair: already initialized\");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), \"NFTPair: bad pair\");\n    }\n\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, \"NFTPair: not the lender\");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration >= cur.duration &&\n                    params.valuation <= cur.valuation &&\n                    params.annualInterestBPS <= cur.annualInterestBPS &&\n                    params.ltvBPS <= cur.ltvBPS,\n                \"NFTPair: worse params\"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert(\"NFTPair: no collateral\");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    function _requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, \"NFTPair: loan exists\");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), \"NFTPair: skim failed\");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n\n    /// @notice Removes `tokenId` as collateral and transfers it to `to`.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, \"NFTPair: not the lender\");\n\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(rate.mul(loanParams.ltvBPS) / BPS < amount, \"NFT is still valued\");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with `skim` set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, \"NFTPair: not available\");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as `accepted`.\n        require(\n            params.valuation == accepted.valuation &&\n                params.duration <= accepted.duration &&\n                params.annualInterestBPS >= accepted.annualInterestBPS &&\n                params.ltvBPS >= accepted.ltvBPS,\n            \"NFTPair: bad params\"\n        );\n\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, \"Oracle: price too low.\");\n        }\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                \"NFTPair: skim too much\"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS <= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }\n\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n\n    // keccak256(\"Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;\n\n    // keccak256(\"Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;\n\n    /// @notice Request and immediately borrow from a pre-committed lender\n\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        SignatureParams memory signature\n    ) public {\n        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), \"NFTPair: LendingClub does not like you\");\n        } else {\n            require(block.timestamp <= signature.deadline, \"NFTPair: signature expired\");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    params.ltvBPS,\n                    params.oracle,\n                    nonce,\n                    signature.deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, \"NFTPair: signature invalid\");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        SignatureParams memory signature\n    ) public {\n        require(block.timestamp <= signature.deadline, \"NFTPair: signature expired\");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                params.ltvBPS,\n                params.oracle,\n                nonce,\n                signature.deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, \"NFTPair: signature invalid\");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n\n    /// Approximates continuous compounding. Uses Horner's method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n > 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \\           principal * (t * aprBPS)^k        \\\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the \"theoretical\" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term_{k-1} * ------------                          (*)\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From (*) we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M >= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n\n        interest = term_k;\n        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // <- Only overflow check we need\n        }\n\n        if (interest >= 2**128) {\n            revert();\n        }\n    }\n\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, \"NFTPair: no loan\");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration > block.timestamp,\n            \"NFTPair: loan expired\"\n        );\n\n        uint128 principal = loanParams.valuation;\n\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), \"NFTPair: skim too much\");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n\n        emit LogRepay(from, tokenId);\n    }\n\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into `bentoBox`.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the `bentoBox`.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.\n    /// This also means that calls made from this contract shall *not* be trusted.\n    function _call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 && !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), \"NFTPair: can't call\");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, \"NFTPair: call failed\");\n        return (returnData, returnValues);\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i < actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    SignatureParams memory signature\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi\n                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);\n            }\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n\n        uint256 _share = feesEarnedShare;\n        if (_share > 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, _share);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n\n\n",
        "CodeNames": [
            "NFTPair.sol",
            "NFTPairWithOracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTPair.sol:218, NFTPairWithOracle.sol:238",
                "Type": "Reentrancy",
                "Description": "The NFTPair contract can be reentered, and a loan can be requested without the borrower supplying the collateral.",
                "Repair": "Move the external call to the end of the function to conform with checks-effects-interaction pattern"
            }
        ]
    }
]