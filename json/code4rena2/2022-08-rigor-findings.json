[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Multiple locations in the project (see affected code)",
                "Type": "Untyped data signing",
                "Description": "Untyped application data is directly hashed and signed, enabling different attacks such as signature reuse across different Rigor projects, signature reuse across different chains, signature reuse across Rigor functions, and signature reuse from different Ethereum projects & phishing.",
                "Repair": "Follow EIP-712 and not implement your own standard/solution. Use a battle-tested approach that people have thought in detail about."
            },
            {
                "Location": "Multiple locations in the project (see affected code)",
                "Type": "Incorrect initialization of smart contracts with Access Control issue",
                "Description": "The initialization process of contracts is delayed, and contract initialization methods have no check over who calls them, leading to loss of funds, failure of the protocol, loss of control over protocol elements, and the possibility of replacing contracts and settings with harmful ones.",
                "Repair": "Carry out checks at the initialization stage or redesign the deployment process with the initialization of contracts during deployment"
            },
            {
                "Location": "[Project.sol#L770](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L770)",
                "Type": "Task Functionality completely sidestepped via autoWithdraw",
                "Description": "autoWithdraw will send funds to the builder, we can use this knowledge to drain all funds from Project to the builder contract.",
                "Repair": "Consider removing autoWithdraw (keep funds inside of project), create a separate multi-sig like way to withdraw or keep a split between funds sent by Builder and by Community, and make autoWithdraw send the funds back accordingly (may also need to re-compute total sent in Community)"
            },
            {
                "Location": "[Project.sol#L219](https://github.com/code-423n4/2022-08-rigor/blob/main/contracts/Project.sol#L219)",
                "Type": "Malicious delegated contractor can block funding tasks or mark tasks as complete",
                "Description": "A malicious delegated contractor can add a huge number of tasks (or one task with a huge cost). This would then pose problems in allocateFunds() as tasks could not be funded.",
                "Repair": "Create a function to update lastAllocatedTask. This could be restricted to Disputes contract or the builder. This could be used against maliciously inserted tasks. Add functionality for Disputes contract to be able to remove or replace the contractor. This would be a guard against malicious contractors."
            },
            {
                "Location": "[Project.sol#L386-L490](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L386-L490)",
                "Type": "Project funds can be drained by reusing signatures, in some cases",
                "Description": "This attack path is the results of signatures reusing in 2 functions changeOrder() and setComplete(), and a missing modifier at Tasks.unApprove() library function.",
                "Repair": "Use nonce to protect setComplete() and changeOrder() from signatures reuse. Add the onlyActive() modifier to Tasks.unApprove(). Consider limiting allocateFunds() for builder only"
            },
            {
                "Location": "[Project.sol#L162](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L162)",
                "Type": "updateProjectHash does not check project address",
                "Description": "_data (which is signed by builder and/or contractor) does not contain a reference to the project address. In all other external functions of Project.sol, _data contains the address of the project, used in this check: require(_projectAddress == address(this), \"Project::!projectAddress\");. The lack of this verification makes it possible to reuse the same _data, and the same _signature on another project.",
                "Repair": "When releasing a standard event, check whether the account balance has been modified accordingly"
            },
            {
                "Location": "[Project.sol#L330](https://github.com/code-423n4/2022-08-rigor/blob/5ab7ea84a1516cb726421ef690af5bc41029f88f/contracts/Project.sol#L330)",
                "Type": "reused signature",
                "Description": "In Project.setComplete(), the signature can be reused when the first call is reverted for some reason.",
                "Repair": "Add an option to cancel the approved hash in approveHash() function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDebtToken} from \"./interfaces/IDebtToken.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {Tasks, Task, TaskStatus} from \"./libraries/Tasks.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Deployable Project Contract for HomeFi v2.5.0\n\n * @notice contains the primary logic around construction project management. \n * Onboarding contractors, fund escrow, and completion tracking are all managed here. \n * Significant multi-signature and meta-transaction functionality is included here.\n\n * @dev This contract is created as a clone copy for the end user\n */\ncontract Project is\n    IProject,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using Tasks library for Task struct\n    using Tasks for Task;\n\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ------------------------FIXED INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @notice Disputes contract instance\n    address internal disputes;\n\n    /// @notice mapping of tasks index to Task struct.\n    mapping(uint256 => Task) internal tasks;\n\n    /// @notice array of indexes of change ordered tasks\n    uint256[] internal _changeOrderedTask;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    IHomeFi public override homeFi;\n    /// @inheritdoc IProject\n    IDebtToken public override currency;\n    /// @inheritdoc IProject\n    uint256 public override lenderFee;\n    /// @inheritdoc IProject\n    address public override builder;\n    /// @inheritdoc IProject\n    uint256 public constant override VERSION = 25000;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    address public override contractor;\n    /// @inheritdoc IProject\n    bool public override contractorConfirmed;\n    /// @inheritdoc IProject\n    uint256 public override hashChangeNonce;\n    /// @inheritdoc IProject\n    uint256 public override totalLent;\n    /// @inheritdoc IProject\n    uint256 public override totalAllocated;\n    /// @inheritdoc IProject\n    uint256 public override taskCount;\n    /// @inheritdoc IProject\n    bool public override contractorDelegated;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedTask;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedChangeOrderTask;\n    /// @inheritdoc IProject\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /// @dev Added to make sure master implementation cannot be initialized\n    // solhint-disable-next-line no-empty-blocks\n    constructor() initializer {}\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTION---------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    function initialize(\n        address _currency,\n        address _sender,\n        address _homeFiAddress\n    ) external override initializer {\n        // Initialize variables\n        homeFi = IHomeFi(_homeFiAddress);\n        disputes = homeFi.disputesContract();\n        lenderFee = homeFi.lenderFee();\n        builder = _sender;\n        currency = IDebtToken(_currency);\n    }\n\n    /// @inheritdoc IProject\n    function approveHash(bytes32 _hash) external override {\n        address _sender = _msgSender();\n        // Allowing anyone to sign, as its hard to add restrictions here.\n        // Store _hash as signed for sender.\n        approvedHashes[_sender][_hash] = true;\n\n        emit ApproveHash(_hash, _sender);\n    }\n\n    /// @inheritdoc IProject\n    function inviteContractor(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Revert if contractor has already confirmed his invitation\n        require(!contractorConfirmed, \"Project::GC accepted\");\n\n        // Decode params from _data\n        (address _contractor, address _projectAddress) = abi.decode(\n            _data,\n            (address, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if contractor address is invalid.\n        require(_contractor != address(0), \"Project::0 address\");\n\n        // Store new contractor\n        contractor = _contractor;\n        contractorConfirmed = true;\n\n        // Check signature for builder and contractor\n        checkSignature(_data, _signature);\n\n        emit ContractorInvited(contractor);\n    }\n\n    /// @inheritdoc IProject\n    function delegateContractor(bool _bool) external override {\n        // Revert if sender is not builder\n        require(_msgSender() == builder, \"Project::!B\");\n\n        // Revert if contract not assigned\n        require(contractor != address(0), \"Project::0 address\");\n\n        // Store new bool for contractorDelegated\n        contractorDelegated = _bool;\n\n        emit ContractorDelegated(_bool);\n    }\n\n    /// @inheritdoc IProject\n    function updateProjectHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Check for required signatures\n        checkSignature(_data, _signature);\n\n        // Decode params from _data\n        (bytes memory _hash, uint256 _nonce) = abi.decode(\n            _data,\n            (bytes, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit HashUpdated(_hash);\n    }\n\n    /// @inheritdoc IProject\n    function lendToProject(uint256 _cost) external override nonReentrant {\n        address _sender = _msgSender();\n\n        // Revert if sender is not builder or Community Contract (lender)\n        require(\n            _sender == builder || _sender == homeFi.communityContract(),\n            \"Project::!Builder&&!Community\"\n        );\n\n        // Revert if try to lend 0\n        require(_cost > 0, \"Project::!value>0\");\n\n        // Revert if try to lend more than project cost\n        uint256 _newTotalLent = totalLent + _cost;\n        require(\n            projectCost() >= uint256(_newTotalLent),\n            \"Project::value>required\"\n        );\n\n        if (_sender == builder) {\n            // Transfer assets from builder to this contract\n            currency.safeTransferFrom(_sender, address(this), _cost);\n        }\n\n        // Update total lent with added lend\n        totalLent = _newTotalLent;\n\n        emit LendToProject(_cost);\n\n        // Allocate funds to tasks and mark then as allocated\n        allocateFunds();\n    }\n\n    /// @inheritdoc IProject\n    function addTasks(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures\n            checkSignature(_data, _signature);\n        }\n\n        // Decode params from _data\n        (\n            bytes[] memory _hash,\n            uint256[] memory _taskCosts,\n            uint256 _taskCount,\n            address _projectAddress\n        ) = abi.decode(_data, (bytes[], uint256[], uint256, address));\n\n        // Revert if decoded taskCount is incorrect. This indicates wrong data.\n        require(_taskCount == taskCount, \"Project::!taskCount\");\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if IPFS hash array length is not equal to task cost array length.\n        uint256 _length = _hash.length;\n        require(_length == _taskCosts.length, \"Project::Lengths !match\");\n\n        // Loop over all the new tasks.\n        for (uint256 i = 0; i < _length; i++) {\n            // Increment local task counter.\n            _taskCount += 1;\n\n            // Check task cost precision. Revert if too precise.\n            checkPrecision(_taskCosts[i]);\n\n            // Initialize task.\n            tasks[_taskCount].initialize(_taskCosts[i]);\n        }\n\n        // Update task counter equal to local task counter.\n        taskCount = _taskCount;\n\n        emit TasksAdded(_taskCosts, _hash);\n    }\n\n    /// @inheritdoc IProject\n    function updateTaskHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (bytes memory _taskHash, uint256 _nonce, uint256 _taskID) = abi.decode(\n            _data,\n            (bytes, uint256, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // If subcontractor has confirmed then check signature using `checkSignatureTask`.\n        // Else check signature using `checkSignature`.\n        if (getAlerts(_taskID)[2]) {\n            // If subcontractor has confirmed.\n            checkSignatureTask(_data, _signature, _taskID);\n        } else {\n            // If subcontractor not has confirmed.\n            checkSignature(_data, _signature);\n        }\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit TaskHashUpdated(_taskID, _taskHash);\n    }\n\n    /// @inheritdoc IProject\n    function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)\n        external\n        override\n    {\n        // Revert if sender is neither builder nor contractor.\n        require(\n            _msgSender() == builder || _msgSender() == contractor,\n            \"Project::!Builder||!GC\"\n        );\n\n        // Revert if taskList array length not equal to scList array length.\n        uint256 _length = _taskList.length;\n        require(_length == _scList.length, \"Project::Lengths !match\");\n\n        // Invite subcontractor for each task.\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n\n        emit MultipleSCInvited(_taskList, _scList);\n    }\n\n    /// @inheritdoc IProject\n    function acceptInviteSC(uint256[] calldata _taskList) external override {\n        // Accept invitation for each task in taskList.\n        uint256 _length = _taskList.length;\n        for (uint256 i = 0; i < _length; i++) {\n            tasks[_taskList[i]].acceptInvitation(_msgSender());\n        }\n\n        emit SCConfirmed(_taskList);\n    }\n\n    /// @inheritdoc IProject\n    function setComplete(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (uint256 _taskID, address _projectAddress) = abi.decode(\n            _data,\n            (uint256, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!Project\");\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Mark task as complete. Only works when task is active.\n        tasks[_taskID].setComplete();\n\n        // Transfer funds to subcontractor.\n        currency.safeTransfer(\n            tasks[_taskID].subcontractor,\n            tasks[_taskID].cost\n        );\n\n        emit TaskComplete(_taskID);\n    }\n\n    /// @inheritdoc IProject\n    function recoverTokens(address _tokenAddress) external override {\n        /* If the token address is same as currency of this project,\n            then first check if all tasks are complete */\n        if (_tokenAddress == address(currency)) {\n            // Iterate for each task and check if it is complete.\n            uint256 _length = taskCount;\n            for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n                require(tasks[_taskID].getState() == 3, \"Project::!Complete\");\n            }\n        }\n\n        // Create token instance.\n        IDebtToken _token = IDebtToken(_tokenAddress);\n\n        // Check the balance of _token in this contract.\n        uint256 _leftOutTokens = _token.balanceOf(address(this));\n\n        // If balance is present then it to the builder.\n        if (_leftOutTokens > 0) {\n            _token.safeTransfer(builder, _leftOutTokens);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function changeOrder(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        nonReentrant\n    {\n        // Decode params from _data\n        (\n            uint256 _taskID,\n            address _newSC,\n            uint256 _newCost,\n            address _project\n        ) = abi.decode(_data, (uint256, address, uint256, address));\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        // Local variable for task cost. For gas saving.\n        uint256 _taskCost = tasks[_taskID].cost;\n\n        // Local variable indicating if subcontractor is already unapproved.\n        bool _unapproved = false;\n\n        // If task cost is to be changed.\n        if (_newCost != _taskCost) {\n            // Check new task cost precision. Revert if too precise.\n            checkPrecision(_newCost);\n\n            // Local variable for total cost allocated. For gas saving.\n            uint256 _totalAllocated = totalAllocated;\n\n            // If tasks are already allocated with old cost.\n            if (tasks[_taskID].alerts[1]) {\n                // If new task cost is less than old task cost.\n                if (_newCost < _taskCost) {\n                    // Find the difference between old - new.\n                    uint256 _withdrawDifference = _taskCost - _newCost;\n\n                    // Reduce this difference from total cost allocated.\n                    // As the same task is now allocated with lesser cost.\n                    totalAllocated -= _withdrawDifference;\n\n                    // Withdraw the difference back to builder's account.\n                    // As this additional amount may not be required by the project.\n                    autoWithdraw(_withdrawDifference);\n                }\n                // If new cost is more than task cost but total lent is enough to cover for it.\n                else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n                    // Increase the difference of new cost and old cost to total allocated.\n                    totalAllocated += _newCost - _taskCost;\n                }\n                // If new cost is more than task cost and totalLent is not enough.\n                else {\n                    // Un-confirm SC, mark task as inactive, mark allocated as false, mark lifecycle as None\n\n                    // Mark task as inactive by unapproving subcontractor.\n                    // As subcontractor can only be approved if task is allocated\n                    _unapproved = true;\n                    tasks[_taskID].unApprove();\n\n                    // Mark task as not allocated.\n                    tasks[_taskID].unAllocateFunds();\n\n                    // Reduce total allocation by old task cost.\n                    // As as needs to go though funding process again.\n                    totalAllocated -= _taskCost;\n\n                    // Add this task to _changeOrderedTask array. These tasks will be allocated first.\n                    _changeOrderedTask.push(_taskID);\n                }\n            }\n\n            // Store new cost for the task\n            tasks[_taskID].cost = _newCost;\n\n            emit ChangeOrderFee(_taskID, _newCost);\n        }\n\n        // If task subcontractor is to be changed.\n        if (_newSC != tasks[_taskID].subcontractor) {\n            // If task is not already unapproved, then un-approve it.\n            // Un-approving task means marking subcontractor as unconfirmed.\n            if (!_unapproved) {\n                tasks[_taskID].unApprove();\n            }\n\n            // If new subcontractor is not zero address.\n            if (_newSC != address(0)) {\n                // Invite the new subcontractor for the task.\n                _inviteSC(_taskID, _newSC, true);\n            }\n            // Else store zero address for the task subcontractor.\n            // This implies that a subcontractor is not invited from the task.\n            else {\n                tasks[_taskID].subcontractor = address(0);\n            }\n\n            emit ChangeOrderSC(_taskID, _newSC);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Recover the signer from the signature\n        address signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (address _project, uint256 _task, , , ) = abi.decode(\n            _data,\n            (address, uint256, uint8, bytes, bytes)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        if (_task == 0) {\n            // Revet if sender is not builder or contractor\n            require(\n                signer == builder || signer == contractor,\n                \"Project::!(GC||Builder)\"\n            );\n        } else {\n            // Revet if sender is not builder, contractor or task's subcontractor\n            require(\n                signer == builder ||\n                    signer == contractor ||\n                    signer == tasks[_task].subcontractor,\n                \"Project::!(GC||Builder||SC)\"\n            );\n\n            if (signer == tasks[_task].subcontractor) {\n                // If sender is task's subcontractor, revert if invitation is not accepted.\n                require(getAlerts(_task)[2], \"Project::!SCConfirmed\");\n            }\n        }\n\n        // Make a call to Disputes contract raiseDisputes.\n        IDisputes(disputes).raiseDispute(_data, _signature);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function getTask(uint256 id)\n        external\n        view\n        override\n        returns (\n            uint256 cost,\n            address subcontractor,\n            TaskStatus state\n        )\n    {\n        cost = tasks[id].cost;\n        subcontractor = tasks[id].subcontractor;\n        state = tasks[id].state;\n    }\n\n    /// @inheritdoc IProject\n    function changeOrderedTask()\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _changeOrderedTask;\n    }\n\n    /*******************************************************************************\n     * ----------------------------PUBLIC TRANSACTIONS---------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function allocateFunds() public override {\n        // Max amount out times this loop will run\n        // This is to ensure the transaction do not run out of gas (max gas limit)\n        uint256 _maxLoop = 50;\n\n        // Difference of totalLent and totalAllocated is what can be used to allocate new tasks\n        uint256 _costToAllocate = totalLent - totalAllocated;\n\n        // Bool if max loop limit is exceeded\n        bool _exceedLimit;\n\n        // Local instance of lastAllocatedChangeOrderTask. To save gas.\n        uint256 i = lastAllocatedChangeOrderTask;\n\n        // Local instance of lastAllocatedTask. To save gas.\n        uint256 j = lastAllocatedTask;\n\n        // Initialize empty array in which allocated tasks will be added.\n        uint256[] memory _tasksAllocated = new uint256[](\n            taskCount - j + _changeOrderedTask.length - i\n        );\n\n        // Number of times a loop has run.\n        uint256 _loopCount;\n\n        /// CHANGE ORDERED TASK FUNDING ///\n\n        // Any tasks added to _changeOrderedTask will be allocated first\n        if (_changeOrderedTask.length > 0) {\n            // Loop from lastAllocatedChangeOrderTask to _changeOrderedTask length (until _maxLoop)\n            for (; i < _changeOrderedTask.length; i++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[_changeOrderedTask[i]].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[_changeOrderedTask[i]].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = _changeOrderedTask[i];\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all the change ordered tasks are allocated, then delete\n            // the changeOrderedTask array and reset lastAllocatedChangeOrderTask.\n            if (i == _changeOrderedTask.length) {\n                lastAllocatedChangeOrderTask = 0;\n                delete _changeOrderedTask;\n            }\n            // Else store the last allocated change order task index.\n            else {\n                lastAllocatedChangeOrderTask = i;\n            }\n        }\n\n        /// TASK FUNDING ///\n\n        // If lastAllocatedTask is lesser than taskCount, that means there are un-allocated tasks\n        if (j < taskCount) {\n            // Loop from lastAllocatedTask + 1 to taskCount (until _maxLoop)\n            for (++j; j <= taskCount; j++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[j].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[j].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = j;\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all pending tasks are allocated store lastAllocatedTask equal to taskCount\n            if (j > taskCount) {\n                lastAllocatedTask = taskCount;\n            }\n            // If not all tasks are allocated store updated lastAllocatedTask\n            else {\n                lastAllocatedTask = --j;\n            }\n        }\n\n        // If any tasks is allocated, then emit event\n        if (_loopCount > 0) emit TaskAllocated(_tasksAllocated);\n\n        // If allocation was incomplete, then emit event\n        if (_exceedLimit) emit IncompleteAllocation();\n\n        // Update totalAllocated with all allocations\n        totalAllocated = totalLent - _costToAllocate;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function projectCost() public view override returns (uint256 _cost) {\n        // Local instance of taskCount. To save gas.\n        uint256 _length = taskCount;\n\n        // Iterate over all tasks to sum their cost\n        for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n            _cost += tasks[_taskID].cost;\n        }\n    }\n\n    /// @inheritdoc IProject\n    function getAlerts(uint256 _taskID)\n        public\n        view\n        override\n        returns (bool[3] memory _alerts)\n    {\n        return tasks[_taskID].getAlerts();\n    }\n\n    /// @inheritdoc IProject\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IProject)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Invite subcontractors for a single task. This can be called by builder or contractor.\n     * _taskList must not have a task which already has approved subcontractor.\n     \n     * @param _taskID uint256 task index\n     * @param _sc address addresses of subcontractor for the respective task\n     * @param _emitEvent whether to emit event for each sc added or not\n     */\n    function _inviteSC(\n        uint256 _taskID,\n        address _sc,\n        bool _emitEvent\n    ) internal {\n        // Revert if sc to invite is address 0\n        require(_sc != address(0), \"Project::0 address\");\n\n        // Internal call to tasks invite contractor\n        tasks[_taskID].inviteSubcontractor(_sc);\n\n        // If `_emitEvent` is true (called via changeOrder) then emit event\n        if (_emitEvent) {\n            emit SingleSCInvited(_taskID, _sc);\n        }\n    }\n\n    /**\n     * @dev Transfer excess funds back to builder wallet.\n     * Called internally in task changeOrder when new task cost is lower than older cost.\n\n     * @param _amount uint256 - amount of excess funds\n     */\n    function autoWithdraw(uint256 _amount) internal {\n        // Reduce amount from totalLent\n        totalLent -= _amount;\n\n        // Transfer amount to builder address\n        currency.safeTransfer(builder, _amount);\n\n        emit AutoWithdrawn(_amount);\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder and contractor address.\n     * Signatures must be in sequential order. First builder and then contractor.\n     * Reverts if signature do not match.\n     * If contractor is not assigned then only checks for builder signature.\n     * If contractor is assigned but not delegated then only checks for builder and contractor signature.\n     * If contractor is assigned and delegated then only checks for contractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     */\n    function checkSignature(bytes calldata _data, bytes calldata _signature)\n        internal\n    {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Check for builder's signature\n            checkSignatureValidity(builder, _hash, _signature, 0);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                //  Check contractor's signature\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for both B and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n            }\n        }\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder, contractor and subcontractor address for a task.\n     * Signatures must be in sequential order. First builder, then contractor, and then subcontractor.\n     * reverts if signatures do not match.\n     * If contractor is not assigned then only checks for builder and subcontractor signature.\n     * If contractor is assigned but not delegated then only checks for builder, contractor and subcontractor signature.\n     * If contractor is assigned and delegated then only checks for contractor and subcontractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     * @param _taskID index of the task.\n     */\n    function checkSignatureTask(\n        bytes calldata _data,\n        bytes calldata _signature,\n        uint256 _taskID\n    ) internal {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of subcontractor. To save gas.\n        address _sc = tasks[_taskID].subcontractor;\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Just check for B and SC sign\n            checkSignatureValidity(builder, _hash, _signature, 0);\n            checkSignatureValidity(_sc, _hash, _signature, 1);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                // Check for GC and SC sign\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n                checkSignatureValidity(_sc, _hash, _signature, 1);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for B, SC and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n                checkSignatureValidity(_sc, _hash, _signature, 2);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev Checks if the signature is approved or recovered\n     * @dev Reverts if not\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal {\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Project::invalid signature\"\n        );\n        // delete from approvedHash\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * -------------------------------INTERNAL PURE------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Check if precision is greater than 1000, if so, it reverts\n\n     * @param _amount amount needed to be checked for precision.\n     */\n    function checkPrecision(uint256 _amount) internal pure {\n        // Divide and multiply amount with 1000 should be equal to amount.\n        // This ensures the amount is not too precise.\n        require(\n            ((_amount / 1000) * 1000) == _amount,\n            \"Project::Precision>=1000\"\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "Project.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Project.sol#L402",
                "Type": "Smart Contract Logic",
                "Description": "The changeOrder() function will revert when it's called for the tasks that don't have subcontractors.",
                "Repair": "Check separately if the subcontractor is confirmed or not before calling checkSignatureTask()"
            },
            {
                "Location": "Project.sol#L859",
                "Type": "Smart Contract Logic",
                "Description": "Hash approval not possible when contractor == subcontractor.",
                "Repair": "Delete the approval only when all checks are done"
            },
            {
                "Location": "Project.sol#L710",
                "Type": "Denial of Service",
                "Description": "Possible DOS in lendToProject() and toggleLendingNeeded() function because unbounded loop can run out of gas.",
                "Repair": "Keep value of projectCost() in a storage variable and update it when a task is added or updated accordingly"
            },
            {
                "Location": "Project.sol#L238",
                "Type": "Smart Contract Logic",
                "Description": "Project.addTasks() wouldn't work properly when it's called from disputes contract.",
                "Repair": "Check separately if the function is called from disputes contract or not"
            },
            {
                "Location": "Project.sol#L402",
                "Type": "Smart Contract Logic",
                "Description": "changeOrder requires subcontractor signature when the subcontractor address is 0.",
                "Repair": "Check separately if the subcontractor address is zero or not"
            },
            {
                "Location": "checkSignatureValidity() function in Project.sol",
                "Type": "Signature Checks could be passed",
                "Description": "It is possible to pass Signature Validity check with an SignatureDecoder.recoverKey() returns 0 whenever the builder and /or contractor have an existing approved hash for a data.",
                "Repair": "Add a require check for _recoveredSignature != 0 in checkSignatureValidity()"
            },
            {
                "Location": "Project.sol#L498-L502",
                "Type": "Unauthorized Dispute Creation",
                "Description": "Anyone can create disputes if contractor is not set",
                "Repair": "Check the recovered signer address in Project.raiseDispute to not equal the zero-address"
            },
            {
                "Location": "[M-07] Project.sol#L493-L536",
                "Type": "Smart Contract Logic",
                "Description": "Project.raiseDispute() doesn't use approvedHashes - meaning users who use contracts can't raise disputes",
                "Repair": "Make raiseDispute() to check for approvedHashes too."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDebtToken} from \"./interfaces/IDebtToken.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {Tasks, Task, TaskStatus} from \"./libraries/Tasks.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Deployable Project Contract for HomeFi v2.5.0\n\n * @notice contains the primary logic around construction project management. \n * Onboarding contractors, fund escrow, and completion tracking are all managed here. \n * Significant multi-signature and meta-transaction functionality is included here.\n\n * @dev This contract is created as a clone copy for the end user\n */\ncontract Project is\n    IProject,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using Tasks library for Task struct\n    using Tasks for Task;\n\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ------------------------FIXED INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @notice Disputes contract instance\n    address internal disputes;\n\n    /// @notice mapping of tasks index to Task struct.\n    mapping(uint256 => Task) internal tasks;\n\n    /// @notice array of indexes of change ordered tasks\n    uint256[] internal _changeOrderedTask;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    IHomeFi public override homeFi;\n    /// @inheritdoc IProject\n    IDebtToken public override currency;\n    /// @inheritdoc IProject\n    uint256 public override lenderFee;\n    /// @inheritdoc IProject\n    address public override builder;\n    /// @inheritdoc IProject\n    uint256 public constant override VERSION = 25000;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    address public override contractor;\n    /// @inheritdoc IProject\n    bool public override contractorConfirmed;\n    /// @inheritdoc IProject\n    uint256 public override hashChangeNonce;\n    /// @inheritdoc IProject\n    uint256 public override totalLent;\n    /// @inheritdoc IProject\n    uint256 public override totalAllocated;\n    /// @inheritdoc IProject\n    uint256 public override taskCount;\n    /// @inheritdoc IProject\n    bool public override contractorDelegated;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedTask;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedChangeOrderTask;\n    /// @inheritdoc IProject\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /// @dev Added to make sure master implementation cannot be initialized\n    // solhint-disable-next-line no-empty-blocks\n    constructor() initializer {}\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTION---------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    function initialize(\n        address _currency,\n        address _sender,\n        address _homeFiAddress\n    ) external override initializer {\n        // Initialize variables\n        homeFi = IHomeFi(_homeFiAddress);\n        disputes = homeFi.disputesContract();\n        lenderFee = homeFi.lenderFee();\n        builder = _sender;\n        currency = IDebtToken(_currency);\n    }\n\n    /// @inheritdoc IProject\n    function approveHash(bytes32 _hash) external override {\n        address _sender = _msgSender();\n        // Allowing anyone to sign, as its hard to add restrictions here.\n        // Store _hash as signed for sender.\n        approvedHashes[_sender][_hash] = true;\n\n        emit ApproveHash(_hash, _sender);\n    }\n\n    /// @inheritdoc IProject\n    function inviteContractor(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Revert if contractor has already confirmed his invitation\n        require(!contractorConfirmed, \"Project::GC accepted\");\n\n        // Decode params from _data\n        (address _contractor, address _projectAddress) = abi.decode(\n            _data,\n            (address, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if contractor address is invalid.\n        require(_contractor != address(0), \"Project::0 address\");\n\n        // Store new contractor\n        contractor = _contractor;\n        contractorConfirmed = true;\n\n        // Check signature for builder and contractor\n        checkSignature(_data, _signature);\n\n        emit ContractorInvited(contractor);\n    }\n\n    /// @inheritdoc IProject\n    function delegateContractor(bool _bool) external override {\n        // Revert if sender is not builder\n        require(_msgSender() == builder, \"Project::!B\");\n\n        // Revert if contract not assigned\n        require(contractor != address(0), \"Project::0 address\");\n\n        // Store new bool for contractorDelegated\n        contractorDelegated = _bool;\n\n        emit ContractorDelegated(_bool);\n    }\n\n    /// @inheritdoc IProject\n    function updateProjectHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Check for required signatures\n        checkSignature(_data, _signature);\n\n        // Decode params from _data\n        (bytes memory _hash, uint256 _nonce) = abi.decode(\n            _data,\n            (bytes, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit HashUpdated(_hash);\n    }\n\n    /// @inheritdoc IProject\n    function lendToProject(uint256 _cost) external override nonReentrant {\n        address _sender = _msgSender();\n\n        // Revert if sender is not builder or Community Contract (lender)\n        require(\n            _sender == builder || _sender == homeFi.communityContract(),\n            \"Project::!Builder&&!Community\"\n        );\n\n        // Revert if try to lend 0\n        require(_cost > 0, \"Project::!value>0\");\n\n        // Revert if try to lend more than project cost\n        uint256 _newTotalLent = totalLent + _cost;\n        require(\n            projectCost() >= uint256(_newTotalLent),\n            \"Project::value>required\"\n        );\n\n        if (_sender == builder) {\n            // Transfer assets from builder to this contract\n            currency.safeTransferFrom(_sender, address(this), _cost);\n        }\n\n        // Update total lent with added lend\n        totalLent = _newTotalLent;\n\n        emit LendToProject(_cost);\n\n        // Allocate funds to tasks and mark then as allocated\n        allocateFunds();\n    }\n\n    /// @inheritdoc IProject\n    function addTasks(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures\n            checkSignature(_data, _signature);\n        }\n\n        // Decode params from _data\n        (\n            bytes[] memory _hash,\n            uint256[] memory _taskCosts,\n            uint256 _taskCount,\n            address _projectAddress\n        ) = abi.decode(_data, (bytes[], uint256[], uint256, address));\n\n        // Revert if decoded taskCount is incorrect. This indicates wrong data.\n        require(_taskCount == taskCount, \"Project::!taskCount\");\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if IPFS hash array length is not equal to task cost array length.\n        uint256 _length = _hash.length;\n        require(_length == _taskCosts.length, \"Project::Lengths !match\");\n\n        // Loop over all the new tasks.\n        for (uint256 i = 0; i < _length; i++) {\n            // Increment local task counter.\n            _taskCount += 1;\n\n            // Check task cost precision. Revert if too precise.\n            checkPrecision(_taskCosts[i]);\n\n            // Initialize task.\n            tasks[_taskCount].initialize(_taskCosts[i]);\n        }\n\n        // Update task counter equal to local task counter.\n        taskCount = _taskCount;\n\n        emit TasksAdded(_taskCosts, _hash);\n    }\n\n    /// @inheritdoc IProject\n    function updateTaskHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (bytes memory _taskHash, uint256 _nonce, uint256 _taskID) = abi.decode(\n            _data,\n            (bytes, uint256, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // If subcontractor has confirmed then check signature using `checkSignatureTask`.\n        // Else check signature using `checkSignature`.\n        if (getAlerts(_taskID)[2]) {\n            // If subcontractor has confirmed.\n            checkSignatureTask(_data, _signature, _taskID);\n        } else {\n            // If subcontractor not has confirmed.\n            checkSignature(_data, _signature);\n        }\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit TaskHashUpdated(_taskID, _taskHash);\n    }\n\n    /// @inheritdoc IProject\n    function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)\n        external\n        override\n    {\n        // Revert if sender is neither builder nor contractor.\n        require(\n            _msgSender() == builder || _msgSender() == contractor,\n            \"Project::!Builder||!GC\"\n        );\n\n        // Revert if taskList array length not equal to scList array length.\n        uint256 _length = _taskList.length;\n        require(_length == _scList.length, \"Project::Lengths !match\");\n\n        // Invite subcontractor for each task.\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n\n        emit MultipleSCInvited(_taskList, _scList);\n    }\n\n    /// @inheritdoc IProject\n    function acceptInviteSC(uint256[] calldata _taskList) external override {\n        // Accept invitation for each task in taskList.\n        uint256 _length = _taskList.length;\n        for (uint256 i = 0; i < _length; i++) {\n            tasks[_taskList[i]].acceptInvitation(_msgSender());\n        }\n\n        emit SCConfirmed(_taskList);\n    }\n\n    /// @inheritdoc IProject\n    function setComplete(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (uint256 _taskID, address _projectAddress) = abi.decode(\n            _data,\n            (uint256, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!Project\");\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Mark task as complete. Only works when task is active.\n        tasks[_taskID].setComplete();\n\n        // Transfer funds to subcontractor.\n        currency.safeTransfer(\n            tasks[_taskID].subcontractor,\n            tasks[_taskID].cost\n        );\n\n        emit TaskComplete(_taskID);\n    }\n\n    /// @inheritdoc IProject\n    function recoverTokens(address _tokenAddress) external override {\n        /* If the token address is same as currency of this project,\n            then first check if all tasks are complete */\n        if (_tokenAddress == address(currency)) {\n            // Iterate for each task and check if it is complete.\n            uint256 _length = taskCount;\n            for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n                require(tasks[_taskID].getState() == 3, \"Project::!Complete\");\n            }\n        }\n\n        // Create token instance.\n        IDebtToken _token = IDebtToken(_tokenAddress);\n\n        // Check the balance of _token in this contract.\n        uint256 _leftOutTokens = _token.balanceOf(address(this));\n\n        // If balance is present then it to the builder.\n        if (_leftOutTokens > 0) {\n            _token.safeTransfer(builder, _leftOutTokens);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function changeOrder(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        nonReentrant\n    {\n        // Decode params from _data\n        (\n            uint256 _taskID,\n            address _newSC,\n            uint256 _newCost,\n            address _project\n        ) = abi.decode(_data, (uint256, address, uint256, address));\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        // Local variable for task cost. For gas saving.\n        uint256 _taskCost = tasks[_taskID].cost;\n\n        // Local variable indicating if subcontractor is already unapproved.\n        bool _unapproved = false;\n\n        // If task cost is to be changed.\n        if (_newCost != _taskCost) {\n            // Check new task cost precision. Revert if too precise.\n            checkPrecision(_newCost);\n\n            // Local variable for total cost allocated. For gas saving.\n            uint256 _totalAllocated = totalAllocated;\n\n            // If tasks are already allocated with old cost.\n            if (tasks[_taskID].alerts[1]) {\n                // If new task cost is less than old task cost.\n                if (_newCost < _taskCost) {\n                    // Find the difference between old - new.\n                    uint256 _withdrawDifference = _taskCost - _newCost;\n\n                    // Reduce this difference from total cost allocated.\n                    // As the same task is now allocated with lesser cost.\n                    totalAllocated -= _withdrawDifference;\n\n                    // Withdraw the difference back to builder's account.\n                    // As this additional amount may not be required by the project.\n                    autoWithdraw(_withdrawDifference);\n                }\n                // If new cost is more than task cost but total lent is enough to cover for it.\n                else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n                    // Increase the difference of new cost and old cost to total allocated.\n                    totalAllocated += _newCost - _taskCost;\n                }\n                // If new cost is more than task cost and totalLent is not enough.\n                else {\n                    // Un-confirm SC, mark task as inactive, mark allocated as false, mark lifecycle as None\n\n                    // Mark task as inactive by unapproving subcontractor.\n                    // As subcontractor can only be approved if task is allocated\n                    _unapproved = true;\n                    tasks[_taskID].unApprove();\n\n                    // Mark task as not allocated.\n                    tasks[_taskID].unAllocateFunds();\n\n                    // Reduce total allocation by old task cost.\n                    // As as needs to go though funding process again.\n                    totalAllocated -= _taskCost;\n\n                    // Add this task to _changeOrderedTask array. These tasks will be allocated first.\n                    _changeOrderedTask.push(_taskID);\n                }\n            }\n\n            // Store new cost for the task\n            tasks[_taskID].cost = _newCost;\n\n            emit ChangeOrderFee(_taskID, _newCost);\n        }\n\n        // If task subcontractor is to be changed.\n        if (_newSC != tasks[_taskID].subcontractor) {\n            // If task is not already unapproved, then un-approve it.\n            // Un-approving task means marking subcontractor as unconfirmed.\n            if (!_unapproved) {\n                tasks[_taskID].unApprove();\n            }\n\n            // If new subcontractor is not zero address.\n            if (_newSC != address(0)) {\n                // Invite the new subcontractor for the task.\n                _inviteSC(_taskID, _newSC, true);\n            }\n            // Else store zero address for the task subcontractor.\n            // This implies that a subcontractor is not invited from the task.\n            else {\n                tasks[_taskID].subcontractor = address(0);\n            }\n\n            emit ChangeOrderSC(_taskID, _newSC);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Recover the signer from the signature\n        address signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (address _project, uint256 _task, , , ) = abi.decode(\n            _data,\n            (address, uint256, uint8, bytes, bytes)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        if (_task == 0) {\n            // Revet if sender is not builder or contractor\n            require(\n                signer == builder || signer == contractor,\n                \"Project::!(GC||Builder)\"\n            );\n        } else {\n            // Revet if sender is not builder, contractor or task's subcontractor\n            require(\n                signer == builder ||\n                    signer == contractor ||\n                    signer == tasks[_task].subcontractor,\n                \"Project::!(GC||Builder||SC)\"\n            );\n\n            if (signer == tasks[_task].subcontractor) {\n                // If sender is task's subcontractor, revert if invitation is not accepted.\n                require(getAlerts(_task)[2], \"Project::!SCConfirmed\");\n            }\n        }\n\n        // Make a call to Disputes contract raiseDisputes.\n        IDisputes(disputes).raiseDispute(_data, _signature);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function getTask(uint256 id)\n        external\n        view\n        override\n        returns (\n            uint256 cost,\n            address subcontractor,\n            TaskStatus state\n        )\n    {\n        cost = tasks[id].cost;\n        subcontractor = tasks[id].subcontractor;\n        state = tasks[id].state;\n    }\n\n    /// @inheritdoc IProject\n    function changeOrderedTask()\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _changeOrderedTask;\n    }\n\n    /*******************************************************************************\n     * ----------------------------PUBLIC TRANSACTIONS---------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function allocateFunds() public override {\n        // Max amount out times this loop will run\n        // This is to ensure the transaction do not run out of gas (max gas limit)\n        uint256 _maxLoop = 50;\n\n        // Difference of totalLent and totalAllocated is what can be used to allocate new tasks\n        uint256 _costToAllocate = totalLent - totalAllocated;\n\n        // Bool if max loop limit is exceeded\n        bool _exceedLimit;\n\n        // Local instance of lastAllocatedChangeOrderTask. To save gas.\n        uint256 i = lastAllocatedChangeOrderTask;\n\n        // Local instance of lastAllocatedTask. To save gas.\n        uint256 j = lastAllocatedTask;\n\n        // Initialize empty array in which allocated tasks will be added.\n        uint256[] memory _tasksAllocated = new uint256[](\n            taskCount - j + _changeOrderedTask.length - i\n        );\n\n        // Number of times a loop has run.\n        uint256 _loopCount;\n\n        /// CHANGE ORDERED TASK FUNDING ///\n\n        // Any tasks added to _changeOrderedTask will be allocated first\n        if (_changeOrderedTask.length > 0) {\n            // Loop from lastAllocatedChangeOrderTask to _changeOrderedTask length (until _maxLoop)\n            for (; i < _changeOrderedTask.length; i++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[_changeOrderedTask[i]].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[_changeOrderedTask[i]].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = _changeOrderedTask[i];\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all the change ordered tasks are allocated, then delete\n            // the changeOrderedTask array and reset lastAllocatedChangeOrderTask.\n            if (i == _changeOrderedTask.length) {\n                lastAllocatedChangeOrderTask = 0;\n                delete _changeOrderedTask;\n            }\n            // Else store the last allocated change order task index.\n            else {\n                lastAllocatedChangeOrderTask = i;\n            }\n        }\n\n        /// TASK FUNDING ///\n\n        // If lastAllocatedTask is lesser than taskCount, that means there are un-allocated tasks\n        if (j < taskCount) {\n            // Loop from lastAllocatedTask + 1 to taskCount (until _maxLoop)\n            for (++j; j <= taskCount; j++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[j].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[j].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = j;\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all pending tasks are allocated store lastAllocatedTask equal to taskCount\n            if (j > taskCount) {\n                lastAllocatedTask = taskCount;\n            }\n            // If not all tasks are allocated store updated lastAllocatedTask\n            else {\n                lastAllocatedTask = --j;\n            }\n        }\n\n        // If any tasks is allocated, then emit event\n        if (_loopCount > 0) emit TaskAllocated(_tasksAllocated);\n\n        // If allocation was incomplete, then emit event\n        if (_exceedLimit) emit IncompleteAllocation();\n\n        // Update totalAllocated with all allocations\n        totalAllocated = totalLent - _costToAllocate;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function projectCost() public view override returns (uint256 _cost) {\n        // Local instance of taskCount. To save gas.\n        uint256 _length = taskCount;\n\n        // Iterate over all tasks to sum their cost\n        for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n            _cost += tasks[_taskID].cost;\n        }\n    }\n\n    /// @inheritdoc IProject\n    function getAlerts(uint256 _taskID)\n        public\n        view\n        override\n        returns (bool[3] memory _alerts)\n    {\n        return tasks[_taskID].getAlerts();\n    }\n\n    /// @inheritdoc IProject\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IProject)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Invite subcontractors for a single task. This can be called by builder or contractor.\n     * _taskList must not have a task which already has approved subcontractor.\n     \n     * @param _taskID uint256 task index\n     * @param _sc address addresses of subcontractor for the respective task\n     * @param _emitEvent whether to emit event for each sc added or not\n     */\n    function _inviteSC(\n        uint256 _taskID,\n        address _sc,\n        bool _emitEvent\n    ) internal {\n        // Revert if sc to invite is address 0\n        require(_sc != address(0), \"Project::0 address\");\n\n        // Internal call to tasks invite contractor\n        tasks[_taskID].inviteSubcontractor(_sc);\n\n        // If `_emitEvent` is true (called via changeOrder) then emit event\n        if (_emitEvent) {\n            emit SingleSCInvited(_taskID, _sc);\n        }\n    }\n\n    /**\n     * @dev Transfer excess funds back to builder wallet.\n     * Called internally in task changeOrder when new task cost is lower than older cost.\n\n     * @param _amount uint256 - amount of excess funds\n     */\n    function autoWithdraw(uint256 _amount) internal {\n        // Reduce amount from totalLent\n        totalLent -= _amount;\n\n        // Transfer amount to builder address\n        currency.safeTransfer(builder, _amount);\n\n        emit AutoWithdrawn(_amount);\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder and contractor address.\n     * Signatures must be in sequential order. First builder and then contractor.\n     * Reverts if signature do not match.\n     * If contractor is not assigned then only checks for builder signature.\n     * If contractor is assigned but not delegated then only checks for builder and contractor signature.\n     * If contractor is assigned and delegated then only checks for contractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     */\n    function checkSignature(bytes calldata _data, bytes calldata _signature)\n        internal\n    {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Check for builder's signature\n            checkSignatureValidity(builder, _hash, _signature, 0);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                //  Check contractor's signature\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for both B and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n            }\n        }\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder, contractor and subcontractor address for a task.\n     * Signatures must be in sequential order. First builder, then contractor, and then subcontractor.\n     * reverts if signatures do not match.\n     * If contractor is not assigned then only checks for builder and subcontractor signature.\n     * If contractor is assigned but not delegated then only checks for builder, contractor and subcontractor signature.\n     * If contractor is assigned and delegated then only checks for contractor and subcontractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     * @param _taskID index of the task.\n     */\n    function checkSignatureTask(\n        bytes calldata _data,\n        bytes calldata _signature,\n        uint256 _taskID\n    ) internal {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of subcontractor. To save gas.\n        address _sc = tasks[_taskID].subcontractor;\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Just check for B and SC sign\n            checkSignatureValidity(builder, _hash, _signature, 0);\n            checkSignatureValidity(_sc, _hash, _signature, 1);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                // Check for GC and SC sign\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n                checkSignatureValidity(_sc, _hash, _signature, 1);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for B, SC and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n                checkSignatureValidity(_sc, _hash, _signature, 2);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev Checks if the signature is approved or recovered\n     * @dev Reverts if not\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal {\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Project::invalid signature\"\n        );\n        // delete from approvedHash\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * -------------------------------INTERNAL PURE------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Check if precision is greater than 1000, if so, it reverts\n\n     * @param _amount amount needed to be checked for precision.\n     */\n    function checkPrecision(uint256 _amount) internal pure {\n        // Divide and multiply amount with 1000 should be equal to amount.\n        // This ensures the amount is not too precise.\n        require(\n            ((_amount / 1000) * 1000) == _amount,\n            \"Project::Precision>=1000\"\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {ICommunity, IDebtToken} from \"./interfaces/ICommunity.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Community Contract for HomeFi v2.5.0\n \n * @notice Module for coordinating lending groups on HomeFi protocol\n */\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ---------------------FIXED INTERNAL STORED PROPERTIES---------------------- *\n     *******************************************************************************/\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    /*******************************************************************************\n     * --------------------VARIABLE INTERNAL STORED PROPERTIES-------------------- *\n     *******************************************************************************/\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    IHomeFi public override homeFi;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    bool public override restrictedToAdmin;\n    /// @inheritdoc ICommunity\n    uint256 public override communityCount;\n    /// @inheritdoc ICommunity\n    mapping(address => uint256) public override projectPublished;\n    /// @inheritdoc ICommunity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00) (invalid)\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        // Revert if sender is not homeFi admin\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n        // Revert if sender is not _project builder\n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        // Initialize pausable. Set pause to false;\n        __Pausable_init();\n\n        // Initialize variables\n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        // Community creation is paused for non admin by default paused\n        restrictedToAdmin = true;\n    }\n\n    /// @inheritdoc ICommunity\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        // Local variable for sender. For gas saving.\n        address _sender = _msgSender();\n\n        // Revert if community creation is paused or sender is not HomeFi admin\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        // Revert if currency is not supported by HomeFi\n        homeFi.validCurrency(_currency);\n\n        // Increment community counter\n        communityCount++;\n\n        // Store community details\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        override\n    {\n        // Revert if sender is not _communityID owner\n        require(\n            _communities[_communityID].owner == _msgSender(),\n            \"Community::!owner\"\n        );\n\n        // Emit event if _hash. This way this hash needs not be stored in memory.\n        emit UpdateCommunityHash(_communityID, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _newMemberAddr,\n            bytes memory _messageHash\n        ) = abi.decode(_data, (uint256, address, bytes));\n\n        CommunityStruct storage _community = _communities[_communityID];\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\n        // Revert if new member already exists\n        require(\n            !_community.isMember[_newMemberAddr],\n            \"Community::Member Exists\"\n        );\n\n        // Store updated community details\n        uint256 _memberCount = _community.memberCount;\n        _community.memberCount = _memberCount + 1;\n        _community.members[_memberCount] = _newMemberAddr;\n        _community.isMember[_newMemberAddr] = true;\n\n        emit MemberAdded(_communityID, _newMemberAddr, _messageHash);\n    }\n\n    /// @inheritdoc ICommunity\n    function publishProject(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _project,\n            uint256 _apr,\n            uint256 _publishFee,\n            uint256 _publishNonce,\n            bytes memory _messageHash\n        ) = abi.decode(\n                _data,\n                (uint256, address, uint256, uint256, uint256, bytes)\n            );\n\n        // Local instance of community and community  project details. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(\n            _publishNonce == _community.publishNonce,\n            \"Community::invalid publishNonce\"\n        );\n\n        // Reverts if _project not originated from HomeFi\n        require(homeFi.isProjectExist(_project), \"Community::Project !Exists\");\n\n        // Local instance of variables. For saving gas.\n        IProject _projectInstance = IProject(_project);\n        address _builder = _projectInstance.builder();\n\n        // Revert if project builder is not community member\n        require(_community.isMember[_builder], \"Community::!Member\");\n\n        // Revert if project currency does not match community currency\n        require(\n            _projectInstance.currency() == _community.currency,\n            \"Community::!Currency\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be project builder\n\n        // If already published then unpublish first\n        if (projectPublished[_project] > 0) {\n            _unpublishProject(_project);\n        }\n\n        // Store updated details\n        _community.publishNonce = ++_community.publishNonce;\n        _communityProject.apr = _apr;\n        _communityProject.publishFee = _publishFee;\n        projectPublished[_project] = _communityID;\n\n        // If _publishFee is zero than mark publish fee as paid\n        if (_publishFee == 0) _communityProject.publishFeePaid = true;\n\n        emit ProjectPublished(\n            _communityID,\n            _project,\n            _apr,\n            _publishFee,\n            _communityProject.publishFeePaid,\n            _messageHash\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function unpublishProject(uint256 _communityID, address _project)\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Call internal function to unpublish project\n        _unpublishProject(_project);\n    }\n\n    /// @inheritdoc ICommunity\n    function payPublishFee(uint256 _communityID, address _project)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if publish fee already paid\n        require(\n            !_communityProject.publishFeePaid,\n            \"Community::publish fee paid\"\n        );\n\n        // Store updated detail\n        _communityProject.publishFeePaid = true;\n\n        // Transfer publishFee to community owner (lender)\n        _community.currency.safeTransferFrom(\n            _msgSender(),\n            _community.owner,\n            _communityProject.publishFee\n        );\n\n        emit PublishFeePaid(_communityID, _project);\n    }\n\n    /// @inheritdoc ICommunity\n    function toggleLendingNeeded(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingNeeded\n    )\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        // Revert if publish fee not paid\n        require(\n            _communityProject.publishFeePaid,\n            \"Community::publish fee !paid\"\n        );\n\n        // Revert if _lendingNeeded is more than projectCost or less than what is already lent\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n\n        // Store updated detail\n        _communityProject.lendingNeeded = _lendingNeeded;\n\n        emit ToggleLendingNeeded(_communityID, _project, _lendingNeeded);\n    }\n\n    /// @inheritdoc ICommunity\n    function lendToProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingAmount,\n        bytes calldata _hash\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n    {\n        // Local instance of variable. For saving gas.\n        address _sender = _msgSender();\n\n        // Revert if sender is not community owner.\n        // Only community owner can lend.\n        require(\n            _sender == _communities[_communityID].owner,\n            \"Community::!owner\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Calculate lenderFee\n        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /\n            (_projectInstance.lenderFee() + 1000);\n\n        // Calculate amount going to project. Lending amount - lending fee.\n        uint256 _amountToProject = _lendingAmount - _lenderFee;\n\n        // Revert if _amountToProject is not within further investment needed.\n        require(\n            _amountToProject <=\n                _communities[_communityID]\n                    .projectDetails[_project]\n                    .lendingNeeded -\n                    _communities[_communityID]\n                        .projectDetails[_project]\n                        .totalLent,\n            \"Community::lending>needed\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IDebtToken _currency = _communities[_communityID].currency;\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_currency))\n        );\n\n        // Update investment in Project\n        _projectInstance.lendToProject(_amountToProject);\n\n        // Update total lent by lender\n        _communities[_communityID]\n            .projectDetails[_project]\n            .totalLent += _amountToProject;\n\n        // First claim interest if principal lent > 0\n        if (\n            _communities[_communityID].projectDetails[_project].lentAmount > 0\n        ) {\n            claimInterest(_communityID, _project, _wrappedToken);\n        }\n\n        // Increment lent principal\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lentAmount += _lendingAmount;\n\n        // Update lastTimestamp\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lastTimestamp = block.timestamp;\n\n        // Transfer _lenderFee to HomeFi treasury from lender account\n        _currency.safeTransferFrom(_msgSender(), homeFi.treasury(), _lenderFee);\n\n        // Transfer _amountToProject to _project from lender account\n        _currency.safeTransferFrom(_msgSender(), _project, _amountToProject);\n\n        // Mint new _lendingAmount amount wrapped token to lender\n        _wrappedToken.mint(_sender, _lendingAmount);\n\n        emit LenderLent(_communityID, _project, _sender, _lendingAmount, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function repayLender(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        onlyProjectBuilder(_project)\n    {\n        // Internally call reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, \"0x\");\n\n        // Local instance of variable. For saving gas.\n        address _lender = _communities[_communityID].owner;\n\n        // Transfer repayment to lender\n        _communities[_communityID].currency.safeTransferFrom(\n            _msgSender(),\n            _lender,\n            _repayAmount\n        );\n\n        emit RepayLender(_communityID, _project, _lender, _repayAmount);\n    }\n\n    /// @inheritdoc ICommunity\n    function reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) external virtual override whenNotPaused {\n        // Revert if sender is not _communityID owner (lender)\n        require(\n            _msgSender() == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n    }\n\n    /// @inheritdoc ICommunity\n    function approveHash(bytes32 _hash) external virtual override {\n        // allowing anyone to sign, as its hard to add restrictions here\n        approvedHashes[_msgSender()][_hash] = true;\n\n        emit ApproveHash(_hash, _msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function escrow(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _builder,\n            address _lender,\n            address _agent,\n            address _project,\n            uint256 _repayAmount,\n            bytes memory _details\n        ) = abi.decode(\n                _data,\n                (uint256, address, address, address, address, uint256, bytes)\n            );\n\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Revert if decoded builder is not decoded project's builder\n        require(_builder == _projectInstance.builder(), \"Community::!Builder\");\n\n        // Revert if decoded _communityID's owner is not decoded _lender\n        require(\n            _lender == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder\n        checkSignatureValidity(_agent, _hash, _signature, 2); // must be agent or escrow\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n        emit DebtReducedByEscrow(_agent);\n    }\n\n    /// @inheritdoc ICommunity\n    function restrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already restricted to admin\n        require(!restrictedToAdmin, \"Community::restricted\");\n\n        // Disable community creation for non admins\n        restrictedToAdmin = true;\n\n        emit RestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function unrestrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already unrestricted to admin\n        require(restrictedToAdmin, \"Community::!restricted\");\n\n        // Allow community creation for all\n        restrictedToAdmin = false;\n\n        emit UnrestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function pause() external override onlyHomeFiAdmin {\n        _pause();\n    }\n\n    /// @inheritdoc ICommunity\n    function unpause() external override onlyHomeFiAdmin {\n        _unpause();\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function communities(uint256 _communityID)\n        external\n        view\n        override\n        returns (\n            address owner,\n            address currency,\n            uint256 memberCount,\n            uint256 publishNonce\n        )\n    {\n        CommunityStruct storage _community = _communities[_communityID];\n\n        owner = _community.owner;\n        currency = address(_community.currency);\n        memberCount = _community.memberCount;\n        publishNonce = _community.publishNonce;\n    }\n\n    /// @inheritdoc ICommunity\n    function members(uint256 _communityID)\n        external\n        view\n        virtual\n        override\n        returns (address[] memory)\n    {\n        // Initiate empty equal equal to member count length\n        address[] memory _members = new address[](\n            _communities[_communityID].memberCount\n        );\n\n        // Append member addresses in _members array\n        for (uint256 i = 0; i < _communities[_communityID].memberCount; i++) {\n            _members[i] = _communities[_communityID].members[i];\n        }\n\n        return _members;\n    }\n\n    /// @inheritdoc ICommunity\n    function projectDetails(uint256 _communityID, address _project)\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        return (\n            _communityProject.apr,\n            _communityProject.lendingNeeded,\n            _communityProject.totalLent,\n            _communityProject.publishFee,\n            _communityProject.publishFeePaid,\n            _communityProject.lentAmount,\n            _communityProject.interest,\n            _communityProject.lastTimestamp\n        );\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function returnToLender(uint256 _communityID, address _project)\n        public\n        view\n        override\n        returns (\n            uint256, // principal + interest\n            uint256, // principal\n            uint256, // total interest\n            uint256 // unclaimedInterest\n        )\n    {\n        // Local instance of variables. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n        uint256 _lentAmount = _communityProject.lentAmount;\n\n        // Calculate number of days difference current and last timestamp\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) / 86400; // 24*60*60\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000;\n\n        // Old (already rTokens claimed) + new interest\n        uint256 _totalInterest = _unclaimedInterest +\n            _communityProject.interest;\n\n        return (\n            _lentAmount + _totalInterest,\n            _lentAmount,\n            _totalInterest,\n            _unclaimedInterest\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, ICommunity)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev internal function for `unpublishProject`\n     * @param _project address - project address to unpublish\n     */\n    function _unpublishProject(address _project) internal {\n        // Locally store old community of published project\n        uint256 formerCommunityId = projectPublished[_project];\n\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[\n            formerCommunityId\n        ].projectDetails[_project];\n\n        // Reduce lending needed to total lent. So no more investment can be made to this project.\n        _communityProject.lendingNeeded = _communityProject.totalLent;\n\n        // Mark project as unpublished.\n        delete projectPublished[_project];\n\n        // Set public fee paid to false.\n        // So if this project is published again to this community,\n        // then this fee will be required to be paid again.\n        _communityProject.publishFeePaid = false;\n\n        emit ProjectUnpublished(formerCommunityId, _project);\n    }\n\n    /**\n     * @dev Internal function for reducing debt\n\n     * @param _communityID uint256 - the the uuid of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _repayAmount uint256 - the amount of funds repaid to the lender, in the project currency\n     * @param _details bytes - some details on why debt is reduced (off chain documents or images)\n     */\n    function _reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) internal virtual {\n        // Revert if repayment amount is zero.\n        require(_repayAmount > 0, \"Community::!repay\");\n\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n        address _lender = _community.owner;\n\n        // Find wrapped token for community currency\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_community.currency))\n        );\n\n        // Claim interest on existing investments\n        claimInterest(_communityID, _project, _wrappedToken);\n\n        // Local instance of variables. For saving gas.\n        uint256 _lentAmount = _communityProject.lentAmount;\n        uint256 _interest = _communityProject.interest;\n\n        if (_repayAmount > _interest) {\n            // If repayment amount is greater than interest then\n            // set lent = lent + interest - repayment.\n            // And set interest = 0.\n            uint256 _lentAndInterest = _lentAmount + _interest;\n\n            // Revert if repayment amount is greater than sum of lent and interest.\n            require(_lentAndInterest >= _repayAmount, \"Community::!Liquid\");\n            _interest = 0;\n            _lentAmount = _lentAndInterest - _repayAmount;\n        } else {\n            // If repayment amount is lesser than interest, then set\n            // interest = interest - repayment\n            _interest -= _repayAmount;\n        }\n\n        // Update community  project details\n        _communityProject.lentAmount = _lentAmount;\n        _communityProject.interest = _interest;\n\n        // Burn _repayAmount amount wrapped token from lender\n        _wrappedToken.burn(_lender, _repayAmount);\n\n        emit DebtReduced(\n            _communityID,\n            _project,\n            _lender,\n            _repayAmount,\n            _details\n        );\n    }\n\n    /**\n     * @dev claim interest of lender\n\n     * @param _communityID uint256 - uuid of community the project is held in\n     * @param _project address - address of project where debt/ loan is held\n     * @param _wrappedToken address - debt token lender is claiming\n     */\n    function claimInterest(\n        uint256 _communityID,\n        address _project,\n        IDebtToken _wrappedToken\n    ) internal {\n        // Calculate new interest\n        (, , uint256 _interest, uint256 _interestEarned) = returnToLender(\n            _communityID,\n            _project\n        );\n\n        // Local instance of variables. For saving gas.\n        address _lender = _communities[_communityID].owner;\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        if (_interestEarned > 0) {\n            // If any new interest is to be claimed.\n\n            // Increase total interest with new interest to be claimed.\n            _communityProject.interest = _interest;\n\n            // Update lastTimestamp to current time.\n            _communityProject.lastTimestamp = block.timestamp;\n\n            // Burn _interestEarned amount wrapped token to lender\n            _wrappedToken.mint(_lender, _interestEarned);\n\n            emit ClaimedInterest(\n                _communityID,\n                _project,\n                _lender,\n                _interestEarned\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev checks if the signature is approved or recovered, if not it reverts.\n\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal virtual {\n        // Decode signer\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n\n        // Revert if decoded signer does not match expected address\n        // Or if hash is not approved by the expected address.\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Community::invalid signature\"\n        );\n\n        // Delete from approvedHash. So that signature cannot be reused.\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}\n\n\n",
        "CodeNames": [
            "Project.sol",
            "Community.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Community.sol#L501-L506, Project.sol#L108-L115",
                "Type": "Smart Contract Logic",
                "Description": "There is no way to revoke a hash in approvedHashes.",
                "Repair": "Add a function to revoke hash approval"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {ICommunity, IDebtToken} from \"./interfaces/ICommunity.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Community Contract for HomeFi v2.5.0\n \n * @notice Module for coordinating lending groups on HomeFi protocol\n */\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ---------------------FIXED INTERNAL STORED PROPERTIES---------------------- *\n     *******************************************************************************/\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    /*******************************************************************************\n     * --------------------VARIABLE INTERNAL STORED PROPERTIES-------------------- *\n     *******************************************************************************/\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    IHomeFi public override homeFi;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    bool public override restrictedToAdmin;\n    /// @inheritdoc ICommunity\n    uint256 public override communityCount;\n    /// @inheritdoc ICommunity\n    mapping(address => uint256) public override projectPublished;\n    /// @inheritdoc ICommunity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00) (invalid)\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        // Revert if sender is not homeFi admin\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n        // Revert if sender is not _project builder\n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        // Initialize pausable. Set pause to false;\n        __Pausable_init();\n\n        // Initialize variables\n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        // Community creation is paused for non admin by default paused\n        restrictedToAdmin = true;\n    }\n\n    /// @inheritdoc ICommunity\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        // Local variable for sender. For gas saving.\n        address _sender = _msgSender();\n\n        // Revert if community creation is paused or sender is not HomeFi admin\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        // Revert if currency is not supported by HomeFi\n        homeFi.validCurrency(_currency);\n\n        // Increment community counter\n        communityCount++;\n\n        // Store community details\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        override\n    {\n        // Revert if sender is not _communityID owner\n        require(\n            _communities[_communityID].owner == _msgSender(),\n            \"Community::!owner\"\n        );\n\n        // Emit event if _hash. This way this hash needs not be stored in memory.\n        emit UpdateCommunityHash(_communityID, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _newMemberAddr,\n            bytes memory _messageHash\n        ) = abi.decode(_data, (uint256, address, bytes));\n\n        CommunityStruct storage _community = _communities[_communityID];\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\n        // Revert if new member already exists\n        require(\n            !_community.isMember[_newMemberAddr],\n            \"Community::Member Exists\"\n        );\n\n        // Store updated community details\n        uint256 _memberCount = _community.memberCount;\n        _community.memberCount = _memberCount + 1;\n        _community.members[_memberCount] = _newMemberAddr;\n        _community.isMember[_newMemberAddr] = true;\n\n        emit MemberAdded(_communityID, _newMemberAddr, _messageHash);\n    }\n\n    /// @inheritdoc ICommunity\n    function publishProject(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _project,\n            uint256 _apr,\n            uint256 _publishFee,\n            uint256 _publishNonce,\n            bytes memory _messageHash\n        ) = abi.decode(\n                _data,\n                (uint256, address, uint256, uint256, uint256, bytes)\n            );\n\n        // Local instance of community and community  project details. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(\n            _publishNonce == _community.publishNonce,\n            \"Community::invalid publishNonce\"\n        );\n\n        // Reverts if _project not originated from HomeFi\n        require(homeFi.isProjectExist(_project), \"Community::Project !Exists\");\n\n        // Local instance of variables. For saving gas.\n        IProject _projectInstance = IProject(_project);\n        address _builder = _projectInstance.builder();\n\n        // Revert if project builder is not community member\n        require(_community.isMember[_builder], \"Community::!Member\");\n\n        // Revert if project currency does not match community currency\n        require(\n            _projectInstance.currency() == _community.currency,\n            \"Community::!Currency\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be project builder\n\n        // If already published then unpublish first\n        if (projectPublished[_project] > 0) {\n            _unpublishProject(_project);\n        }\n\n        // Store updated details\n        _community.publishNonce = ++_community.publishNonce;\n        _communityProject.apr = _apr;\n        _communityProject.publishFee = _publishFee;\n        projectPublished[_project] = _communityID;\n\n        // If _publishFee is zero than mark publish fee as paid\n        if (_publishFee == 0) _communityProject.publishFeePaid = true;\n\n        emit ProjectPublished(\n            _communityID,\n            _project,\n            _apr,\n            _publishFee,\n            _communityProject.publishFeePaid,\n            _messageHash\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function unpublishProject(uint256 _communityID, address _project)\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Call internal function to unpublish project\n        _unpublishProject(_project);\n    }\n\n    /// @inheritdoc ICommunity\n    function payPublishFee(uint256 _communityID, address _project)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if publish fee already paid\n        require(\n            !_communityProject.publishFeePaid,\n            \"Community::publish fee paid\"\n        );\n\n        // Store updated detail\n        _communityProject.publishFeePaid = true;\n\n        // Transfer publishFee to community owner (lender)\n        _community.currency.safeTransferFrom(\n            _msgSender(),\n            _community.owner,\n            _communityProject.publishFee\n        );\n\n        emit PublishFeePaid(_communityID, _project);\n    }\n\n    /// @inheritdoc ICommunity\n    function toggleLendingNeeded(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingNeeded\n    )\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        // Revert if publish fee not paid\n        require(\n            _communityProject.publishFeePaid,\n            \"Community::publish fee !paid\"\n        );\n\n        // Revert if _lendingNeeded is more than projectCost or less than what is already lent\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n\n        // Store updated detail\n        _communityProject.lendingNeeded = _lendingNeeded;\n\n        emit ToggleLendingNeeded(_communityID, _project, _lendingNeeded);\n    }\n\n    /// @inheritdoc ICommunity\n    function lendToProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingAmount,\n        bytes calldata _hash\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n    {\n        // Local instance of variable. For saving gas.\n        address _sender = _msgSender();\n\n        // Revert if sender is not community owner.\n        // Only community owner can lend.\n        require(\n            _sender == _communities[_communityID].owner,\n            \"Community::!owner\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Calculate lenderFee\n        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /\n            (_projectInstance.lenderFee() + 1000);\n\n        // Calculate amount going to project. Lending amount - lending fee.\n        uint256 _amountToProject = _lendingAmount - _lenderFee;\n\n        // Revert if _amountToProject is not within further investment needed.\n        require(\n            _amountToProject <=\n                _communities[_communityID]\n                    .projectDetails[_project]\n                    .lendingNeeded -\n                    _communities[_communityID]\n                        .projectDetails[_project]\n                        .totalLent,\n            \"Community::lending>needed\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IDebtToken _currency = _communities[_communityID].currency;\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_currency))\n        );\n\n        // Update investment in Project\n        _projectInstance.lendToProject(_amountToProject);\n\n        // Update total lent by lender\n        _communities[_communityID]\n            .projectDetails[_project]\n            .totalLent += _amountToProject;\n\n        // First claim interest if principal lent > 0\n        if (\n            _communities[_communityID].projectDetails[_project].lentAmount > 0\n        ) {\n            claimInterest(_communityID, _project, _wrappedToken);\n        }\n\n        // Increment lent principal\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lentAmount += _lendingAmount;\n\n        // Update lastTimestamp\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lastTimestamp = block.timestamp;\n\n        // Transfer _lenderFee to HomeFi treasury from lender account\n        _currency.safeTransferFrom(_msgSender(), homeFi.treasury(), _lenderFee);\n\n        // Transfer _amountToProject to _project from lender account\n        _currency.safeTransferFrom(_msgSender(), _project, _amountToProject);\n\n        // Mint new _lendingAmount amount wrapped token to lender\n        _wrappedToken.mint(_sender, _lendingAmount);\n\n        emit LenderLent(_communityID, _project, _sender, _lendingAmount, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function repayLender(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        onlyProjectBuilder(_project)\n    {\n        // Internally call reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, \"0x\");\n\n        // Local instance of variable. For saving gas.\n        address _lender = _communities[_communityID].owner;\n\n        // Transfer repayment to lender\n        _communities[_communityID].currency.safeTransferFrom(\n            _msgSender(),\n            _lender,\n            _repayAmount\n        );\n\n        emit RepayLender(_communityID, _project, _lender, _repayAmount);\n    }\n\n    /// @inheritdoc ICommunity\n    function reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) external virtual override whenNotPaused {\n        // Revert if sender is not _communityID owner (lender)\n        require(\n            _msgSender() == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n    }\n\n    /// @inheritdoc ICommunity\n    function approveHash(bytes32 _hash) external virtual override {\n        // allowing anyone to sign, as its hard to add restrictions here\n        approvedHashes[_msgSender()][_hash] = true;\n\n        emit ApproveHash(_hash, _msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function escrow(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _builder,\n            address _lender,\n            address _agent,\n            address _project,\n            uint256 _repayAmount,\n            bytes memory _details\n        ) = abi.decode(\n                _data,\n                (uint256, address, address, address, address, uint256, bytes)\n            );\n\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Revert if decoded builder is not decoded project's builder\n        require(_builder == _projectInstance.builder(), \"Community::!Builder\");\n\n        // Revert if decoded _communityID's owner is not decoded _lender\n        require(\n            _lender == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder\n        checkSignatureValidity(_agent, _hash, _signature, 2); // must be agent or escrow\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n        emit DebtReducedByEscrow(_agent);\n    }\n\n    /// @inheritdoc ICommunity\n    function restrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already restricted to admin\n        require(!restrictedToAdmin, \"Community::restricted\");\n\n        // Disable community creation for non admins\n        restrictedToAdmin = true;\n\n        emit RestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function unrestrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already unrestricted to admin\n        require(restrictedToAdmin, \"Community::!restricted\");\n\n        // Allow community creation for all\n        restrictedToAdmin = false;\n\n        emit UnrestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function pause() external override onlyHomeFiAdmin {\n        _pause();\n    }\n\n    /// @inheritdoc ICommunity\n    function unpause() external override onlyHomeFiAdmin {\n        _unpause();\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function communities(uint256 _communityID)\n        external\n        view\n        override\n        returns (\n            address owner,\n            address currency,\n            uint256 memberCount,\n            uint256 publishNonce\n        )\n    {\n        CommunityStruct storage _community = _communities[_communityID];\n\n        owner = _community.owner;\n        currency = address(_community.currency);\n        memberCount = _community.memberCount;\n        publishNonce = _community.publishNonce;\n    }\n\n    /// @inheritdoc ICommunity\n    function members(uint256 _communityID)\n        external\n        view\n        virtual\n        override\n        returns (address[] memory)\n    {\n        // Initiate empty equal equal to member count length\n        address[] memory _members = new address[](\n            _communities[_communityID].memberCount\n        );\n\n        // Append member addresses in _members array\n        for (uint256 i = 0; i < _communities[_communityID].memberCount; i++) {\n            _members[i] = _communities[_communityID].members[i];\n        }\n\n        return _members;\n    }\n\n    /// @inheritdoc ICommunity\n    function projectDetails(uint256 _communityID, address _project)\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        return (\n            _communityProject.apr,\n            _communityProject.lendingNeeded,\n            _communityProject.totalLent,\n            _communityProject.publishFee,\n            _communityProject.publishFeePaid,\n            _communityProject.lentAmount,\n            _communityProject.interest,\n            _communityProject.lastTimestamp\n        );\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function returnToLender(uint256 _communityID, address _project)\n        public\n        view\n        override\n        returns (\n            uint256, // principal + interest\n            uint256, // principal\n            uint256, // total interest\n            uint256 // unclaimedInterest\n        )\n    {\n        // Local instance of variables. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n        uint256 _lentAmount = _communityProject.lentAmount;\n\n        // Calculate number of days difference current and last timestamp\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) / 86400; // 24*60*60\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000;\n\n        // Old (already rTokens claimed) + new interest\n        uint256 _totalInterest = _unclaimedInterest +\n            _communityProject.interest;\n\n        return (\n            _lentAmount + _totalInterest,\n            _lentAmount,\n            _totalInterest,\n            _unclaimedInterest\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, ICommunity)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev internal function for `unpublishProject`\n     * @param _project address - project address to unpublish\n     */\n    function _unpublishProject(address _project) internal {\n        // Locally store old community of published project\n        uint256 formerCommunityId = projectPublished[_project];\n\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[\n            formerCommunityId\n        ].projectDetails[_project];\n\n        // Reduce lending needed to total lent. So no more investment can be made to this project.\n        _communityProject.lendingNeeded = _communityProject.totalLent;\n\n        // Mark project as unpublished.\n        delete projectPublished[_project];\n\n        // Set public fee paid to false.\n        // So if this project is published again to this community,\n        // then this fee will be required to be paid again.\n        _communityProject.publishFeePaid = false;\n\n        emit ProjectUnpublished(formerCommunityId, _project);\n    }\n\n    /**\n     * @dev Internal function for reducing debt\n\n     * @param _communityID uint256 - the the uuid of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _repayAmount uint256 - the amount of funds repaid to the lender, in the project currency\n     * @param _details bytes - some details on why debt is reduced (off chain documents or images)\n     */\n    function _reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) internal virtual {\n        // Revert if repayment amount is zero.\n        require(_repayAmount > 0, \"Community::!repay\");\n\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n        address _lender = _community.owner;\n\n        // Find wrapped token for community currency\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_community.currency))\n        );\n\n        // Claim interest on existing investments\n        claimInterest(_communityID, _project, _wrappedToken);\n\n        // Local instance of variables. For saving gas.\n        uint256 _lentAmount = _communityProject.lentAmount;\n        uint256 _interest = _communityProject.interest;\n\n        if (_repayAmount > _interest) {\n            // If repayment amount is greater than interest then\n            // set lent = lent + interest - repayment.\n            // And set interest = 0.\n            uint256 _lentAndInterest = _lentAmount + _interest;\n\n            // Revert if repayment amount is greater than sum of lent and interest.\n            require(_lentAndInterest >= _repayAmount, \"Community::!Liquid\");\n            _interest = 0;\n            _lentAmount = _lentAndInterest - _repayAmount;\n        } else {\n            // If repayment amount is lesser than interest, then set\n            // interest = interest - repayment\n            _interest -= _repayAmount;\n        }\n\n        // Update community  project details\n        _communityProject.lentAmount = _lentAmount;\n        _communityProject.interest = _interest;\n\n        // Burn _repayAmount amount wrapped token from lender\n        _wrappedToken.burn(_lender, _repayAmount);\n\n        emit DebtReduced(\n            _communityID,\n            _project,\n            _lender,\n            _repayAmount,\n            _details\n        );\n    }\n\n    /**\n     * @dev claim interest of lender\n\n     * @param _communityID uint256 - uuid of community the project is held in\n     * @param _project address - address of project where debt/ loan is held\n     * @param _wrappedToken address - debt token lender is claiming\n     */\n    function claimInterest(\n        uint256 _communityID,\n        address _project,\n        IDebtToken _wrappedToken\n    ) internal {\n        // Calculate new interest\n        (, , uint256 _interest, uint256 _interestEarned) = returnToLender(\n            _communityID,\n            _project\n        );\n\n        // Local instance of variables. For saving gas.\n        address _lender = _communities[_communityID].owner;\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        if (_interestEarned > 0) {\n            // If any new interest is to be claimed.\n\n            // Increase total interest with new interest to be claimed.\n            _communityProject.interest = _interest;\n\n            // Update lastTimestamp to current time.\n            _communityProject.lastTimestamp = block.timestamp;\n\n            // Burn _interestEarned amount wrapped token to lender\n            _wrappedToken.mint(_lender, _interestEarned);\n\n            emit ClaimedInterest(\n                _communityID,\n                _project,\n                _lender,\n                _interestEarned\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev checks if the signature is approved or recovered, if not it reverts.\n\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal virtual {\n        // Decode signer\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n\n        // Revert if decoded signer does not match expected address\n        // Or if hash is not approved by the expected address.\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Community::invalid signature\"\n        );\n\n        // Delete from approvedHash. So that signature cannot be reused.\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}\n\n\n",
        "CodeNames": [
            "Community.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Community.sol#L206-L282",
                "Type": "Smart Contract Logic",
                "Description": "It is possible to submit a project with no total budget.",
                "Repair": "Remove the require statement that checks for a task with a budget of 0"
            },
            {
                "Location": "Community.sol#L509",
                "Type": "Reentrancy",
                "Description": "Builder can call Community.escrow again to reduce debt further using same signatures.",
                "Repair": "Add a new field into the ProjectDetails struct called escrowNonce and modify function escrow to check this nonce and update it after the debt has been reduced."
            },
            {
                "Location": "Community.sol#L187",
                "Type": "Arbitrary Community Member Addition",
                "Description": "An attacker can add as many members as they want, BEFORE the community will be created.",
                "Repair": "Add a require statement to check that the community ID is less than or equal to the community count"
            },
            {
                "Location": "Community.sol#L685-L686",
                "Type": "Interest Calculation Rounding Error",
                "Description": "A builder can halve the APR paid to a community owner by paying every 1.9999 days due to arithmetic rounding in returnToLender()",
                "Repair": "Add a scalar to noOfDays so that any rounding which occurs is negligible or remove the noOfDays calculation and calculate interest in one equation which reduces arithmetic rounding"
            },
            {
                "Location": "[H-06] Community.sol#L267",
                "Type": "Smart Contract Logic",
                "Description": "Wrong APR can be used when project is unpublished and published again",
                "Repair": "When publishing a project, if the lentAmount for the community is non-zero, calculate the interest before updating the APR."
            },
            {
                "Location": "Community.sol#L455, Community.sol#L484, Community.sol#L509",
                "Type": "Interest calculation vulnerability",
                "Description": "Builders must pay more interest when the system is paused. Builders can't repay when the system is paused so they must pay more interest for the paused period. Builders can repay to lenders using 3 functions, repayLender(), reduceDebt(), and escrow(). But they all don't work when the system is paused and builders have no way to avoid it. Furthermore, the HomeFi admin is the main lender of builders and there is no assurance that the admin would pause the community for a while to get more interest.",
                "Repair": "Think of an approach to make 3 repay functions work for paused or modify the interest calculation formula not to add interest for the paused period"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProjectFactory} from \"./interfaces/IProjectFactory.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC721URIStorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\n\n/**\n * @title HomeFi v2.5.0 HomeFi Contract.\n\n * @notice Main on-chain client.\n * Administrative controls and project deployment.\n \n * @dev\n * Adheres to -\n * IHomeFi: Allows this contract to be used by other HomeFi contracts.\n\n * @dev\n * Inherits from -\n * ReentrancyGuardUpgradeable: Contract module that helps prevent reentrant calls to a function.\n * ERC721URIStorageUpgradeable: ERC721 token with storage based token URI management.\n * ERC2771ContextUpgradeable: Context variant with ERC2771 support.\n */\ncontract HomeFi is\n    IHomeFi,\n    ReentrancyGuardUpgradeable,\n    ERC721URIStorageUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency1;\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency2;\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency3;\n    /// @inheritdoc IHomeFi\n    IProjectFactory public override projectFactoryInstance;\n    /// @inheritdoc IHomeFi\n    address public override disputesContract;\n    /// @inheritdoc IHomeFi\n    address public override communityContract;\n    /// @inheritdoc IHomeFi\n    bool public override addrSet;\n    /// @inheritdoc IHomeFi\n    address public override admin;\n    /// @inheritdoc IHomeFi\n    address public override treasury;\n    /// @inheritdoc IHomeFi\n    uint256 public override lenderFee;\n    /// @inheritdoc IHomeFi\n    uint256 public override projectCount;\n    /// @inheritdoc IHomeFi\n    address public override trustedForwarder;\n    /// @inheritdoc IHomeFi\n    mapping(uint256 => address) public override projects;\n    /// @inheritdoc IHomeFi\n    mapping(address => uint256) public override projectTokenId;\n    /// @inheritdoc IHomeFi\n    mapping(address => address) public override wrappedToken;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier onlyAdmin() {\n        require(admin == _msgSender(), \"HomeFi::!Admin\");\n        _;\n    }\n\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"HomeFi::0 address\");\n        _;\n    }\n\n    modifier noChange(address _oldAddress, address _newAddress) {\n        // Revert if new address is same as old\n        require(_oldAddress != _newAddress, \"HomeFi::!Change\");\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IHomeFi\n    function initialize(\n        address _treasury,\n        uint256 _lenderFee,\n        address _tokenCurrency1,\n        address _tokenCurrency2,\n        address _tokenCurrency3,\n        address _forwarder\n    )\n        external\n        override\n        initializer\n        nonZero(_treasury)\n        nonZero(_tokenCurrency1)\n        nonZero(_tokenCurrency2)\n        nonZero(_tokenCurrency3)\n    {\n        // Initialize ERC721 and ERC2771Context\n        __ERC721_init(\"HomeFiNFT\", \"hNFT\");\n        __ERC2771Context_init(_forwarder);\n\n        // Initialize variables\n        admin = _msgSender();\n        treasury = _treasury;\n        lenderFee = _lenderFee; // the percentage must be multiplied with 10\n        tokenCurrency1 = _tokenCurrency1;\n        tokenCurrency2 = _tokenCurrency2;\n        tokenCurrency3 = _tokenCurrency3;\n        trustedForwarder = _forwarder;\n    }\n\n    /// @inheritdoc IHomeFi\n    function setAddr(\n        address _projectFactory,\n        address _communityContract,\n        address _disputesContract,\n        address _hTokenCurrency1,\n        address _hTokenCurrency2,\n        address _hTokenCurrency3\n    )\n        external\n        override\n        onlyAdmin\n        nonZero(_projectFactory)\n        nonZero(_communityContract)\n        nonZero(_disputesContract)\n        nonZero(_hTokenCurrency1)\n        nonZero(_hTokenCurrency2)\n        nonZero(_hTokenCurrency3)\n    {\n        // Revert if addrSet is true\n        require(!addrSet, \"HomeFi::Set\");\n\n        // Initialize variables\n        projectFactoryInstance = IProjectFactory(_projectFactory);\n        communityContract = _communityContract;\n        disputesContract = _disputesContract;\n        wrappedToken[tokenCurrency1] = _hTokenCurrency1;\n        wrappedToken[tokenCurrency2] = _hTokenCurrency2;\n        wrappedToken[tokenCurrency3] = _hTokenCurrency3;\n        addrSet = true;\n\n        emit AddressSet();\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceAdmin(address _newAdmin)\n        external\n        override\n        onlyAdmin\n        nonZero(_newAdmin)\n        noChange(admin, _newAdmin)\n    {\n        // Replace admin\n        admin = _newAdmin;\n\n        emit AdminReplaced(_newAdmin);\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceTreasury(address _newTreasury)\n        external\n        override\n        onlyAdmin\n        nonZero(_newTreasury)\n        noChange(treasury, _newTreasury)\n    {\n        // Replace treasury\n        treasury = _newTreasury;\n\n        emit TreasuryReplaced(_newTreasury);\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceLenderFee(uint256 _newLenderFee)\n        external\n        override\n        onlyAdmin\n    {\n        // Revert if no change in lender fee\n        require(lenderFee != _newLenderFee, \"HomeFi::!Change\");\n\n        // Reset variables\n        lenderFee = _newLenderFee;\n\n        emit LenderFeeReplaced(_newLenderFee);\n    }\n\n    /// @inheritdoc IHomeFi\n    function setTrustedForwarder(address _newForwarder)\n        external\n        override\n        onlyAdmin\n        noChange(trustedForwarder, _newForwarder)\n    {\n        trustedForwarder = _newForwarder;\n    }\n\n    /// @inheritdoc IHomeFi\n    function createProject(bytes memory _hash, address _currency)\n        external\n        override\n        nonReentrant\n    {\n        // Revert if currency not supported by HomeFi\n        validCurrency(_currency);\n\n        address _sender = _msgSender();\n\n        // Create a new project Clone and mint a new NFT for it\n        address _project = projectFactoryInstance.createProject(\n            _currency,\n            _sender\n        );\n        mintNFT(_sender, string(_hash));\n\n        // Update project related mappings\n        projects[projectCount] = _project;\n        projectTokenId[_project] = projectCount;\n\n        emit ProjectAdded(projectCount, _project, _sender, _currency, _hash);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    function isProjectExist(address _project)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return projectTokenId[_project] > 0;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    function validCurrency(address _currency) public view override {\n        // _currency must be one of HomeFi supported currencies\n        require(\n            _currency == tokenCurrency1 ||\n                _currency == tokenCurrency2 ||\n                _currency == tokenCurrency3,\n            \"HomeFi::!Currency\"\n        );\n    }\n\n    /// @inheritdoc IHomeFi\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IHomeFi)\n        returns (bool)\n    {\n        return trustedForwarder == _forwarder;\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n    /**\n     * @dev Makes an NFT for every project\n\n     * @param _to address - NFT owner. Initially it will be the project builder.\n     * @param _tokenURI string - IPFS hash of project details like name, description etc\n\n     * @return _tokenIds NFT Id of project\n     */\n    function mintNFT(address _to, string memory _tokenURI)\n        internal\n        returns (uint256)\n    {\n        // Project count starts from 1\n        projectCount += 1;\n\n        // Mints NFT and set token URI\n        _mint(_to, projectCount);\n        _setTokenURI(projectCount, _tokenURI);\n\n        emit NftCreated(projectCount, _to);\n        return projectCount;\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}\n\n\n",
        "CodeNames": [
            "HomeFi.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "replaceLenderFee() function in HomeFi.sol",
                "Type": "Missing upper limit definition",
                "Description": "The admin of the HomeFi contract can set lenderFee to greater than 100%, forcing calls to lendToProject() to all projects created in the future to revert.",
                "Repair": "Add reasonable fee rate bounds checks in the replaceLenderFee() function"
            },
            {
                "Location": "setTrustedForwarder() function in HomeFi.sol",
                "Type": "Attacker can drain all the projects",
                "Description": "In case where the admin wallet has been hacked, the attacker can drain all funds out of the project within minutes.",
                "Repair": "Limit approveHash to contracts only, make the process of replacing the forwarder or the admin a 2 step process with a delay between the steps, and consider removing the meta tx for HomeFi onlyAdmin modifier"
            },
            {
                "Location": "HomeFi.sol#L225",
                "Type": "No Purpose",
                "Description": "Owner of project NFT has no purpose.",
                "Repair": "Consider preventing transferring the project NFT to a different address for now as long as there is no use-case for the NFT owner/holder or use the actual NFT owner as the builder of a project."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\n/*******************************************************************************\n * ----------------------------------STRUCTS---------------------------------- *\n *******************************************************************************/\n\n// Task metadata\nstruct Task {\n    // Metadata //\n    uint256 cost; // Cost of task\n    address subcontractor; // Subcontractor of task\n    // Lifecycle //\n    TaskStatus state; // Status of task\n    mapping(uint256 => bool) alerts; // Alerts of task\n}\n\n/*******************************************************************************\n * -----------------------------------ENUMS----------------------------------- *\n *******************************************************************************/\n\nenum TaskStatus {\n    None,\n    Inactive,\n    Active,\n    Complete\n}\n\nenum Lifecycle {\n    None,\n    TaskAllocated,\n    SCConfirmed\n}\n\n/**\n * @title Tasks Library for HomeFi v2.5.0\n\n * @notice Internal library used in Project. Contains functions specific to a task actions and lifecycle.\n */\nlibrary Tasks {\n    /// @dev only allow inactive tasks. Task is inactive if SC is unconfirmed.\n    modifier onlyInactive(Task storage _self) {\n        require(_self.state == TaskStatus.Inactive, \"Task::active\");\n        _;\n    }\n\n    /// @dev only allow active tasks. Task is inactive if SC is confirmed.\n    modifier onlyActive(Task storage _self) {\n        require(_self.state == TaskStatus.Active, \"Task::!Active\");\n        _;\n    }\n\n    /// @dev only allow funded tasks.\n    modifier onlyFunded(Task storage _self) {\n        require(\n            _self.alerts[uint256(Lifecycle.TaskAllocated)],\n            \"Task::!funded\"\n        );\n        _;\n    }\n\n    /// MUTABLE FUNCTIONS ///\n\n    // Task Status Changing Functions //\n\n    /**\n     * @notice Create a new Task object\n\n     * @dev cannot operate on initialized tasks\n\n     * @param _self Task the task struct being mutated\n     * @param _cost uint the number of tokens to be escrowed in this contract\n     */\n    function initialize(Task storage _self, uint256 _cost) public {\n        _self.cost = _cost;\n        _self.state = TaskStatus.Inactive;\n        _self.alerts[uint256(Lifecycle.None)] = true;\n    }\n\n    /**\n     * @notice Attempt to transition task state from Payment Pending to Complete\n\n     * @dev modifier onlyActive\n\n     * @param _self Task the task whose state is being mutated\n     */\n    function setComplete(Task storage _self)\n        internal\n        onlyActive(_self)\n        onlyFunded(_self)\n    {\n        // State/ Lifecycle //\n        _self.state = TaskStatus.Complete;\n    }\n\n    // Subcontractor Joining //\n\n    /**\n     * @dev Invite a subcontractor to the task\n     * @dev modifier onlyInactive\n\n     * @param _self Task the task being joined by subcontractor\n     * @param _sc address the subcontractor being invited\n     */\n    function inviteSubcontractor(Task storage _self, address _sc)\n        internal\n        onlyInactive(_self)\n    {\n        _self.subcontractor = _sc;\n    }\n\n    /**\n     * @dev As a subcontractor, accept an invitation to participate in a task.\n     * @dev modifier onlyInactive\n     * @param _self Task the task being joined by subcontractor\n     * @param _sc Address of sender\n     */\n    function acceptInvitation(Task storage _self, address _sc)\n        internal\n        onlyInactive(_self)\n    {\n        // Prerequisites //\n        require(_self.subcontractor == _sc, \"Task::!SC\");\n\n        // State/ lifecycle //\n        _self.alerts[uint256(Lifecycle.SCConfirmed)] = true;\n        _self.state = TaskStatus.Active;\n    }\n\n    // Task Funding //\n\n    /**\n     * @dev Set a task as funded\n\n     * @param _self Task the task being set as funded\n     */\n    function fundTask(Task storage _self) internal {\n        // State/ Lifecycle //\n        _self.alerts[uint256(Lifecycle.TaskAllocated)] = true;\n    }\n\n    /**\n     * @dev Set a task as un-funded\n\n     * @param _self Task the task being set as funded\n     */\n    function unAllocateFunds(Task storage _self) internal {\n        // State/ lifecycle //\n        _self.alerts[uint256(Lifecycle.TaskAllocated)] = false;\n    }\n\n    /**\n     * @dev Set a task as un accepted/approved for SC\n\n     * @dev modifier onlyActive\n\n     * @param _self Task the task being set as funded\n     */\n    function unApprove(Task storage _self) internal {\n        // State/ lifecycle //\n        _self.alerts[uint256(Lifecycle.SCConfirmed)] = false;\n        _self.state = TaskStatus.Inactive;\n    }\n\n    /// VIEWABLE FUNCTIONS ///\n\n    /**\n     * @dev Determine the current state of all alerts in the project\n\n     * @param _self Task the task being queried for alert status\n\n     * @return _alerts bool[3] array of bool representing whether Lifecycle alert has been reached\n     */\n    function getAlerts(Task storage _self)\n        internal\n        view\n        returns (bool[3] memory _alerts)\n    {\n        uint256 _length = _alerts.length;\n        for (uint256 i = 0; i < _length; i++) _alerts[i] = _self.alerts[i];\n    }\n\n    /**\n     * @dev Return the numerical encoding of the TaskStatus enumeration stored as state in a task\n\n     * @param _self Task the task being queried for state\n     \n     * @return _state uint 0: none, 1: inactive, 2: active, 3: complete\n     */\n    function getState(Task storage _self)\n        internal\n        view\n        returns (uint256 _state)\n    {\n        return uint256(_self.state);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDebtToken} from \"./interfaces/IDebtToken.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {Tasks, Task, TaskStatus} from \"./libraries/Tasks.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Deployable Project Contract for HomeFi v2.5.0\n\n * @notice contains the primary logic around construction project management. \n * Onboarding contractors, fund escrow, and completion tracking are all managed here. \n * Significant multi-signature and meta-transaction functionality is included here.\n\n * @dev This contract is created as a clone copy for the end user\n */\ncontract Project is\n    IProject,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using Tasks library for Task struct\n    using Tasks for Task;\n\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ------------------------FIXED INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @notice Disputes contract instance\n    address internal disputes;\n\n    /// @notice mapping of tasks index to Task struct.\n    mapping(uint256 => Task) internal tasks;\n\n    /// @notice array of indexes of change ordered tasks\n    uint256[] internal _changeOrderedTask;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    IHomeFi public override homeFi;\n    /// @inheritdoc IProject\n    IDebtToken public override currency;\n    /// @inheritdoc IProject\n    uint256 public override lenderFee;\n    /// @inheritdoc IProject\n    address public override builder;\n    /// @inheritdoc IProject\n    uint256 public constant override VERSION = 25000;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    address public override contractor;\n    /// @inheritdoc IProject\n    bool public override contractorConfirmed;\n    /// @inheritdoc IProject\n    uint256 public override hashChangeNonce;\n    /// @inheritdoc IProject\n    uint256 public override totalLent;\n    /// @inheritdoc IProject\n    uint256 public override totalAllocated;\n    /// @inheritdoc IProject\n    uint256 public override taskCount;\n    /// @inheritdoc IProject\n    bool public override contractorDelegated;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedTask;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedChangeOrderTask;\n    /// @inheritdoc IProject\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /// @dev Added to make sure master implementation cannot be initialized\n    // solhint-disable-next-line no-empty-blocks\n    constructor() initializer {}\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTION---------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    function initialize(\n        address _currency,\n        address _sender,\n        address _homeFiAddress\n    ) external override initializer {\n        // Initialize variables\n        homeFi = IHomeFi(_homeFiAddress);\n        disputes = homeFi.disputesContract();\n        lenderFee = homeFi.lenderFee();\n        builder = _sender;\n        currency = IDebtToken(_currency);\n    }\n\n    /// @inheritdoc IProject\n    function approveHash(bytes32 _hash) external override {\n        address _sender = _msgSender();\n        // Allowing anyone to sign, as its hard to add restrictions here.\n        // Store _hash as signed for sender.\n        approvedHashes[_sender][_hash] = true;\n\n        emit ApproveHash(_hash, _sender);\n    }\n\n    /// @inheritdoc IProject\n    function inviteContractor(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Revert if contractor has already confirmed his invitation\n        require(!contractorConfirmed, \"Project::GC accepted\");\n\n        // Decode params from _data\n        (address _contractor, address _projectAddress) = abi.decode(\n            _data,\n            (address, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if contractor address is invalid.\n        require(_contractor != address(0), \"Project::0 address\");\n\n        // Store new contractor\n        contractor = _contractor;\n        contractorConfirmed = true;\n\n        // Check signature for builder and contractor\n        checkSignature(_data, _signature);\n\n        emit ContractorInvited(contractor);\n    }\n\n    /// @inheritdoc IProject\n    function delegateContractor(bool _bool) external override {\n        // Revert if sender is not builder\n        require(_msgSender() == builder, \"Project::!B\");\n\n        // Revert if contract not assigned\n        require(contractor != address(0), \"Project::0 address\");\n\n        // Store new bool for contractorDelegated\n        contractorDelegated = _bool;\n\n        emit ContractorDelegated(_bool);\n    }\n\n    /// @inheritdoc IProject\n    function updateProjectHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Check for required signatures\n        checkSignature(_data, _signature);\n\n        // Decode params from _data\n        (bytes memory _hash, uint256 _nonce) = abi.decode(\n            _data,\n            (bytes, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit HashUpdated(_hash);\n    }\n\n    /// @inheritdoc IProject\n    function lendToProject(uint256 _cost) external override nonReentrant {\n        address _sender = _msgSender();\n\n        // Revert if sender is not builder or Community Contract (lender)\n        require(\n            _sender == builder || _sender == homeFi.communityContract(),\n            \"Project::!Builder&&!Community\"\n        );\n\n        // Revert if try to lend 0\n        require(_cost > 0, \"Project::!value>0\");\n\n        // Revert if try to lend more than project cost\n        uint256 _newTotalLent = totalLent + _cost;\n        require(\n            projectCost() >= uint256(_newTotalLent),\n            \"Project::value>required\"\n        );\n\n        if (_sender == builder) {\n            // Transfer assets from builder to this contract\n            currency.safeTransferFrom(_sender, address(this), _cost);\n        }\n\n        // Update total lent with added lend\n        totalLent = _newTotalLent;\n\n        emit LendToProject(_cost);\n\n        // Allocate funds to tasks and mark then as allocated\n        allocateFunds();\n    }\n\n    /// @inheritdoc IProject\n    function addTasks(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures\n            checkSignature(_data, _signature);\n        }\n\n        // Decode params from _data\n        (\n            bytes[] memory _hash,\n            uint256[] memory _taskCosts,\n            uint256 _taskCount,\n            address _projectAddress\n        ) = abi.decode(_data, (bytes[], uint256[], uint256, address));\n\n        // Revert if decoded taskCount is incorrect. This indicates wrong data.\n        require(_taskCount == taskCount, \"Project::!taskCount\");\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if IPFS hash array length is not equal to task cost array length.\n        uint256 _length = _hash.length;\n        require(_length == _taskCosts.length, \"Project::Lengths !match\");\n\n        // Loop over all the new tasks.\n        for (uint256 i = 0; i < _length; i++) {\n            // Increment local task counter.\n            _taskCount += 1;\n\n            // Check task cost precision. Revert if too precise.\n            checkPrecision(_taskCosts[i]);\n\n            // Initialize task.\n            tasks[_taskCount].initialize(_taskCosts[i]);\n        }\n\n        // Update task counter equal to local task counter.\n        taskCount = _taskCount;\n\n        emit TasksAdded(_taskCosts, _hash);\n    }\n\n    /// @inheritdoc IProject\n    function updateTaskHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (bytes memory _taskHash, uint256 _nonce, uint256 _taskID) = abi.decode(\n            _data,\n            (bytes, uint256, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // If subcontractor has confirmed then check signature using `checkSignatureTask`.\n        // Else check signature using `checkSignature`.\n        if (getAlerts(_taskID)[2]) {\n            // If subcontractor has confirmed.\n            checkSignatureTask(_data, _signature, _taskID);\n        } else {\n            // If subcontractor not has confirmed.\n            checkSignature(_data, _signature);\n        }\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit TaskHashUpdated(_taskID, _taskHash);\n    }\n\n    /// @inheritdoc IProject\n    function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)\n        external\n        override\n    {\n        // Revert if sender is neither builder nor contractor.\n        require(\n            _msgSender() == builder || _msgSender() == contractor,\n            \"Project::!Builder||!GC\"\n        );\n\n        // Revert if taskList array length not equal to scList array length.\n        uint256 _length = _taskList.length;\n        require(_length == _scList.length, \"Project::Lengths !match\");\n\n        // Invite subcontractor for each task.\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n\n        emit MultipleSCInvited(_taskList, _scList);\n    }\n\n    /// @inheritdoc IProject\n    function acceptInviteSC(uint256[] calldata _taskList) external override {\n        // Accept invitation for each task in taskList.\n        uint256 _length = _taskList.length;\n        for (uint256 i = 0; i < _length; i++) {\n            tasks[_taskList[i]].acceptInvitation(_msgSender());\n        }\n\n        emit SCConfirmed(_taskList);\n    }\n\n    /// @inheritdoc IProject\n    function setComplete(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (uint256 _taskID, address _projectAddress) = abi.decode(\n            _data,\n            (uint256, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!Project\");\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Mark task as complete. Only works when task is active.\n        tasks[_taskID].setComplete();\n\n        // Transfer funds to subcontractor.\n        currency.safeTransfer(\n            tasks[_taskID].subcontractor,\n            tasks[_taskID].cost\n        );\n\n        emit TaskComplete(_taskID);\n    }\n\n    /// @inheritdoc IProject\n    function recoverTokens(address _tokenAddress) external override {\n        /* If the token address is same as currency of this project,\n            then first check if all tasks are complete */\n        if (_tokenAddress == address(currency)) {\n            // Iterate for each task and check if it is complete.\n            uint256 _length = taskCount;\n            for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n                require(tasks[_taskID].getState() == 3, \"Project::!Complete\");\n            }\n        }\n\n        // Create token instance.\n        IDebtToken _token = IDebtToken(_tokenAddress);\n\n        // Check the balance of _token in this contract.\n        uint256 _leftOutTokens = _token.balanceOf(address(this));\n\n        // If balance is present then it to the builder.\n        if (_leftOutTokens > 0) {\n            _token.safeTransfer(builder, _leftOutTokens);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function changeOrder(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        nonReentrant\n    {\n        // Decode params from _data\n        (\n            uint256 _taskID,\n            address _newSC,\n            uint256 _newCost,\n            address _project\n        ) = abi.decode(_data, (uint256, address, uint256, address));\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        // Local variable for task cost. For gas saving.\n        uint256 _taskCost = tasks[_taskID].cost;\n\n        // Local variable indicating if subcontractor is already unapproved.\n        bool _unapproved = false;\n\n        // If task cost is to be changed.\n        if (_newCost != _taskCost) {\n            // Check new task cost precision. Revert if too precise.\n            checkPrecision(_newCost);\n\n            // Local variable for total cost allocated. For gas saving.\n            uint256 _totalAllocated = totalAllocated;\n\n            // If tasks are already allocated with old cost.\n            if (tasks[_taskID].alerts[1]) {\n                // If new task cost is less than old task cost.\n                if (_newCost < _taskCost) {\n                    // Find the difference between old - new.\n                    uint256 _withdrawDifference = _taskCost - _newCost;\n\n                    // Reduce this difference from total cost allocated.\n                    // As the same task is now allocated with lesser cost.\n                    totalAllocated -= _withdrawDifference;\n\n                    // Withdraw the difference back to builder's account.\n                    // As this additional amount may not be required by the project.\n                    autoWithdraw(_withdrawDifference);\n                }\n                // If new cost is more than task cost but total lent is enough to cover for it.\n                else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n                    // Increase the difference of new cost and old cost to total allocated.\n                    totalAllocated += _newCost - _taskCost;\n                }\n                // If new cost is more than task cost and totalLent is not enough.\n                else {\n                    // Un-confirm SC, mark task as inactive, mark allocated as false, mark lifecycle as None\n\n                    // Mark task as inactive by unapproving subcontractor.\n                    // As subcontractor can only be approved if task is allocated\n                    _unapproved = true;\n                    tasks[_taskID].unApprove();\n\n                    // Mark task as not allocated.\n                    tasks[_taskID].unAllocateFunds();\n\n                    // Reduce total allocation by old task cost.\n                    // As as needs to go though funding process again.\n                    totalAllocated -= _taskCost;\n\n                    // Add this task to _changeOrderedTask array. These tasks will be allocated first.\n                    _changeOrderedTask.push(_taskID);\n                }\n            }\n\n            // Store new cost for the task\n            tasks[_taskID].cost = _newCost;\n\n            emit ChangeOrderFee(_taskID, _newCost);\n        }\n\n        // If task subcontractor is to be changed.\n        if (_newSC != tasks[_taskID].subcontractor) {\n            // If task is not already unapproved, then un-approve it.\n            // Un-approving task means marking subcontractor as unconfirmed.\n            if (!_unapproved) {\n                tasks[_taskID].unApprove();\n            }\n\n            // If new subcontractor is not zero address.\n            if (_newSC != address(0)) {\n                // Invite the new subcontractor for the task.\n                _inviteSC(_taskID, _newSC, true);\n            }\n            // Else store zero address for the task subcontractor.\n            // This implies that a subcontractor is not invited from the task.\n            else {\n                tasks[_taskID].subcontractor = address(0);\n            }\n\n            emit ChangeOrderSC(_taskID, _newSC);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Recover the signer from the signature\n        address signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (address _project, uint256 _task, , , ) = abi.decode(\n            _data,\n            (address, uint256, uint8, bytes, bytes)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        if (_task == 0) {\n            // Revet if sender is not builder or contractor\n            require(\n                signer == builder || signer == contractor,\n                \"Project::!(GC||Builder)\"\n            );\n        } else {\n            // Revet if sender is not builder, contractor or task's subcontractor\n            require(\n                signer == builder ||\n                    signer == contractor ||\n                    signer == tasks[_task].subcontractor,\n                \"Project::!(GC||Builder||SC)\"\n            );\n\n            if (signer == tasks[_task].subcontractor) {\n                // If sender is task's subcontractor, revert if invitation is not accepted.\n                require(getAlerts(_task)[2], \"Project::!SCConfirmed\");\n            }\n        }\n\n        // Make a call to Disputes contract raiseDisputes.\n        IDisputes(disputes).raiseDispute(_data, _signature);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function getTask(uint256 id)\n        external\n        view\n        override\n        returns (\n            uint256 cost,\n            address subcontractor,\n            TaskStatus state\n        )\n    {\n        cost = tasks[id].cost;\n        subcontractor = tasks[id].subcontractor;\n        state = tasks[id].state;\n    }\n\n    /// @inheritdoc IProject\n    function changeOrderedTask()\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _changeOrderedTask;\n    }\n\n    /*******************************************************************************\n     * ----------------------------PUBLIC TRANSACTIONS---------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function allocateFunds() public override {\n        // Max amount out times this loop will run\n        // This is to ensure the transaction do not run out of gas (max gas limit)\n        uint256 _maxLoop = 50;\n\n        // Difference of totalLent and totalAllocated is what can be used to allocate new tasks\n        uint256 _costToAllocate = totalLent - totalAllocated;\n\n        // Bool if max loop limit is exceeded\n        bool _exceedLimit;\n\n        // Local instance of lastAllocatedChangeOrderTask. To save gas.\n        uint256 i = lastAllocatedChangeOrderTask;\n\n        // Local instance of lastAllocatedTask. To save gas.\n        uint256 j = lastAllocatedTask;\n\n        // Initialize empty array in which allocated tasks will be added.\n        uint256[] memory _tasksAllocated = new uint256[](\n            taskCount - j + _changeOrderedTask.length - i\n        );\n\n        // Number of times a loop has run.\n        uint256 _loopCount;\n\n        /// CHANGE ORDERED TASK FUNDING ///\n\n        // Any tasks added to _changeOrderedTask will be allocated first\n        if (_changeOrderedTask.length > 0) {\n            // Loop from lastAllocatedChangeOrderTask to _changeOrderedTask length (until _maxLoop)\n            for (; i < _changeOrderedTask.length; i++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[_changeOrderedTask[i]].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[_changeOrderedTask[i]].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = _changeOrderedTask[i];\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all the change ordered tasks are allocated, then delete\n            // the changeOrderedTask array and reset lastAllocatedChangeOrderTask.\n            if (i == _changeOrderedTask.length) {\n                lastAllocatedChangeOrderTask = 0;\n                delete _changeOrderedTask;\n            }\n            // Else store the last allocated change order task index.\n            else {\n                lastAllocatedChangeOrderTask = i;\n            }\n        }\n\n        /// TASK FUNDING ///\n\n        // If lastAllocatedTask is lesser than taskCount, that means there are un-allocated tasks\n        if (j < taskCount) {\n            // Loop from lastAllocatedTask + 1 to taskCount (until _maxLoop)\n            for (++j; j <= taskCount; j++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[j].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[j].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = j;\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all pending tasks are allocated store lastAllocatedTask equal to taskCount\n            if (j > taskCount) {\n                lastAllocatedTask = taskCount;\n            }\n            // If not all tasks are allocated store updated lastAllocatedTask\n            else {\n                lastAllocatedTask = --j;\n            }\n        }\n\n        // If any tasks is allocated, then emit event\n        if (_loopCount > 0) emit TaskAllocated(_tasksAllocated);\n\n        // If allocation was incomplete, then emit event\n        if (_exceedLimit) emit IncompleteAllocation();\n\n        // Update totalAllocated with all allocations\n        totalAllocated = totalLent - _costToAllocate;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function projectCost() public view override returns (uint256 _cost) {\n        // Local instance of taskCount. To save gas.\n        uint256 _length = taskCount;\n\n        // Iterate over all tasks to sum their cost\n        for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n            _cost += tasks[_taskID].cost;\n        }\n    }\n\n    /// @inheritdoc IProject\n    function getAlerts(uint256 _taskID)\n        public\n        view\n        override\n        returns (bool[3] memory _alerts)\n    {\n        return tasks[_taskID].getAlerts();\n    }\n\n    /// @inheritdoc IProject\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IProject)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Invite subcontractors for a single task. This can be called by builder or contractor.\n     * _taskList must not have a task which already has approved subcontractor.\n     \n     * @param _taskID uint256 task index\n     * @param _sc address addresses of subcontractor for the respective task\n     * @param _emitEvent whether to emit event for each sc added or not\n     */\n    function _inviteSC(\n        uint256 _taskID,\n        address _sc,\n        bool _emitEvent\n    ) internal {\n        // Revert if sc to invite is address 0\n        require(_sc != address(0), \"Project::0 address\");\n\n        // Internal call to tasks invite contractor\n        tasks[_taskID].inviteSubcontractor(_sc);\n\n        // If `_emitEvent` is true (called via changeOrder) then emit event\n        if (_emitEvent) {\n            emit SingleSCInvited(_taskID, _sc);\n        }\n    }\n\n    /**\n     * @dev Transfer excess funds back to builder wallet.\n     * Called internally in task changeOrder when new task cost is lower than older cost.\n\n     * @param _amount uint256 - amount of excess funds\n     */\n    function autoWithdraw(uint256 _amount) internal {\n        // Reduce amount from totalLent\n        totalLent -= _amount;\n\n        // Transfer amount to builder address\n        currency.safeTransfer(builder, _amount);\n\n        emit AutoWithdrawn(_amount);\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder and contractor address.\n     * Signatures must be in sequential order. First builder and then contractor.\n     * Reverts if signature do not match.\n     * If contractor is not assigned then only checks for builder signature.\n     * If contractor is assigned but not delegated then only checks for builder and contractor signature.\n     * If contractor is assigned and delegated then only checks for contractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     */\n    function checkSignature(bytes calldata _data, bytes calldata _signature)\n        internal\n    {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Check for builder's signature\n            checkSignatureValidity(builder, _hash, _signature, 0);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                //  Check contractor's signature\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for both B and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n            }\n        }\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder, contractor and subcontractor address for a task.\n     * Signatures must be in sequential order. First builder, then contractor, and then subcontractor.\n     * reverts if signatures do not match.\n     * If contractor is not assigned then only checks for builder and subcontractor signature.\n     * If contractor is assigned but not delegated then only checks for builder, contractor and subcontractor signature.\n     * If contractor is assigned and delegated then only checks for contractor and subcontractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     * @param _taskID index of the task.\n     */\n    function checkSignatureTask(\n        bytes calldata _data,\n        bytes calldata _signature,\n        uint256 _taskID\n    ) internal {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of subcontractor. To save gas.\n        address _sc = tasks[_taskID].subcontractor;\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Just check for B and SC sign\n            checkSignatureValidity(builder, _hash, _signature, 0);\n            checkSignatureValidity(_sc, _hash, _signature, 1);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                // Check for GC and SC sign\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n                checkSignatureValidity(_sc, _hash, _signature, 1);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for B, SC and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n                checkSignatureValidity(_sc, _hash, _signature, 2);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev Checks if the signature is approved or recovered\n     * @dev Reverts if not\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal {\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Project::invalid signature\"\n        );\n        // delete from approvedHash\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * -------------------------------INTERNAL PURE------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Check if precision is greater than 1000, if so, it reverts\n\n     * @param _amount amount needed to be checked for precision.\n     */\n    function checkPrecision(uint256 _amount) internal pure {\n        // Divide and multiply amount with 1000 should be equal to amount.\n        // This ensures the amount is not too precise.\n        require(\n            ((_amount / 1000) * 1000) == _amount,\n            \"Project::Precision>=1000\"\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "Tasks.sol",
            "Project.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "[M-16] Tasks.sol#L153-L164, Project.sol#L391-L403, Project.sol#L855-L861",
                "Type": "Smart Contract Logic",
                "Description": "New subcontractor can be set for a SCConfirmed task without current subcontractor consent",
                "Repair": "Introduce deActivate instead of unConfirm. Introduce onlyUnconfirmed modifier and set it to the inviteSubcontractor() and acceptInvitation(). Deactivate task only instead of fully resetting it in changeOrder()"
            }
        ]
    }
]