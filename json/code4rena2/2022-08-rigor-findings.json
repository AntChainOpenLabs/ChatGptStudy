[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Many places in the project (see affected code)",
                "Type": "Untyped data signing",
                "Description": "Untyped application data is directly hashed and signed, enabling different attacks such as signature reuse across different Rigor projects, signature reuse across different chains, signature reuse across Rigor functions, and signature reuse from different Ethereum projects & phishing.",
                "Repair": "Follow EIP-712 and not implement your own standard/solution. Use a battle-tested approach that people have thought in detail about. All of the mentioned attacks are not possible with EIP-712."
            },
            {
                "Location": "[Project.sol#L162]",
                "Type": "updateProjectHash does not check project address",
                "Description": "_data (which is signed by builder and/or contractor) does not contain a reference to the project address.",
                "Repair": "Check if the subcontractor address is zero, do not require a valid signature in such cases."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDebtToken} from \"./interfaces/IDebtToken.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {Tasks, Task, TaskStatus} from \"./libraries/Tasks.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Deployable Project Contract for HomeFi v2.5.0\n\n * @notice contains the primary logic around construction project management. \n * Onboarding contractors, fund escrow, and completion tracking are all managed here. \n * Significant multi-signature and meta-transaction functionality is included here.\n\n * @dev This contract is created as a clone copy for the end user\n */\ncontract Project is\n    IProject,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using Tasks library for Task struct\n    using Tasks for Task;\n\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ------------------------FIXED INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @notice Disputes contract instance\n    address internal disputes;\n\n    /// @notice mapping of tasks index to Task struct.\n    mapping(uint256 => Task) internal tasks;\n\n    /// @notice array of indexes of change ordered tasks\n    uint256[] internal _changeOrderedTask;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    IHomeFi public override homeFi;\n    /// @inheritdoc IProject\n    IDebtToken public override currency;\n    /// @inheritdoc IProject\n    uint256 public override lenderFee;\n    /// @inheritdoc IProject\n    address public override builder;\n    /// @inheritdoc IProject\n    uint256 public constant override VERSION = 25000;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    address public override contractor;\n    /// @inheritdoc IProject\n    bool public override contractorConfirmed;\n    /// @inheritdoc IProject\n    uint256 public override hashChangeNonce;\n    /// @inheritdoc IProject\n    uint256 public override totalLent;\n    /// @inheritdoc IProject\n    uint256 public override totalAllocated;\n    /// @inheritdoc IProject\n    uint256 public override taskCount;\n    /// @inheritdoc IProject\n    bool public override contractorDelegated;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedTask;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedChangeOrderTask;\n    /// @inheritdoc IProject\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /// @dev Added to make sure master implementation cannot be initialized\n    // solhint-disable-next-line no-empty-blocks\n    constructor() initializer {}\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTION---------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    function initialize(\n        address _currency,\n        address _sender,\n        address _homeFiAddress\n    ) external override initializer {\n        // Initialize variables\n        homeFi = IHomeFi(_homeFiAddress);\n        disputes = homeFi.disputesContract();\n        lenderFee = homeFi.lenderFee();\n        builder = _sender;\n        currency = IDebtToken(_currency);\n    }\n\n    /// @inheritdoc IProject\n    function approveHash(bytes32 _hash) external override {\n        address _sender = _msgSender();\n        // Allowing anyone to sign, as its hard to add restrictions here.\n        // Store _hash as signed for sender.\n        approvedHashes[_sender][_hash] = true;\n\n        emit ApproveHash(_hash, _sender);\n    }\n\n    /// @inheritdoc IProject\n    function inviteContractor(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Revert if contractor has already confirmed his invitation\n        require(!contractorConfirmed, \"Project::GC accepted\");\n\n        // Decode params from _data\n        (address _contractor, address _projectAddress) = abi.decode(\n            _data,\n            (address, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if contractor address is invalid.\n        require(_contractor != address(0), \"Project::0 address\");\n\n        // Store new contractor\n        contractor = _contractor;\n        contractorConfirmed = true;\n\n        // Check signature for builder and contractor\n        checkSignature(_data, _signature);\n\n        emit ContractorInvited(contractor);\n    }\n\n    /// @inheritdoc IProject\n    function delegateContractor(bool _bool) external override {\n        // Revert if sender is not builder\n        require(_msgSender() == builder, \"Project::!B\");\n\n        // Revert if contract not assigned\n        require(contractor != address(0), \"Project::0 address\");\n\n        // Store new bool for contractorDelegated\n        contractorDelegated = _bool;\n\n        emit ContractorDelegated(_bool);\n    }\n\n    /// @inheritdoc IProject\n    function updateProjectHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Check for required signatures\n        checkSignature(_data, _signature);\n\n        // Decode params from _data\n        (bytes memory _hash, uint256 _nonce) = abi.decode(\n            _data,\n            (bytes, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit HashUpdated(_hash);\n    }\n\n    /// @inheritdoc IProject\n    function lendToProject(uint256 _cost) external override nonReentrant {\n        address _sender = _msgSender();\n\n        // Revert if sender is not builder or Community Contract (lender)\n        require(\n            _sender == builder || _sender == homeFi.communityContract(),\n            \"Project::!Builder&&!Community\"\n        );\n\n        // Revert if try to lend 0\n        require(_cost > 0, \"Project::!value>0\");\n\n        // Revert if try to lend more than project cost\n        uint256 _newTotalLent = totalLent + _cost;\n        require(\n            projectCost() >= uint256(_newTotalLent),\n            \"Project::value>required\"\n        );\n\n        if (_sender == builder) {\n            // Transfer assets from builder to this contract\n            currency.safeTransferFrom(_sender, address(this), _cost);\n        }\n\n        // Update total lent with added lend\n        totalLent = _newTotalLent;\n\n        emit LendToProject(_cost);\n\n        // Allocate funds to tasks and mark then as allocated\n        allocateFunds();\n    }\n\n    /// @inheritdoc IProject\n    function addTasks(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures\n            checkSignature(_data, _signature);\n        }\n\n        // Decode params from _data\n        (\n            bytes[] memory _hash,\n            uint256[] memory _taskCosts,\n            uint256 _taskCount,\n            address _projectAddress\n        ) = abi.decode(_data, (bytes[], uint256[], uint256, address));\n\n        // Revert if decoded taskCount is incorrect. This indicates wrong data.\n        require(_taskCount == taskCount, \"Project::!taskCount\");\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if IPFS hash array length is not equal to task cost array length.\n        uint256 _length = _hash.length;\n        require(_length == _taskCosts.length, \"Project::Lengths !match\");\n\n        // Loop over all the new tasks.\n        for (uint256 i = 0; i < _length; i++) {\n            // Increment local task counter.\n            _taskCount += 1;\n\n            // Check task cost precision. Revert if too precise.\n            checkPrecision(_taskCosts[i]);\n\n            // Initialize task.\n            tasks[_taskCount].initialize(_taskCosts[i]);\n        }\n\n        // Update task counter equal to local task counter.\n        taskCount = _taskCount;\n\n        emit TasksAdded(_taskCosts, _hash);\n    }\n\n    /// @inheritdoc IProject\n    function updateTaskHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (bytes memory _taskHash, uint256 _nonce, uint256 _taskID) = abi.decode(\n            _data,\n            (bytes, uint256, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // If subcontractor has confirmed then check signature using `checkSignatureTask`.\n        // Else check signature using `checkSignature`.\n        if (getAlerts(_taskID)[2]) {\n            // If subcontractor has confirmed.\n            checkSignatureTask(_data, _signature, _taskID);\n        } else {\n            // If subcontractor not has confirmed.\n            checkSignature(_data, _signature);\n        }\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit TaskHashUpdated(_taskID, _taskHash);\n    }\n\n    /// @inheritdoc IProject\n    function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)\n        external\n        override\n    {\n        // Revert if sender is neither builder nor contractor.\n        require(\n            _msgSender() == builder || _msgSender() == contractor,\n            \"Project::!Builder||!GC\"\n        );\n\n        // Revert if taskList array length not equal to scList array length.\n        uint256 _length = _taskList.length;\n        require(_length == _scList.length, \"Project::Lengths !match\");\n\n        // Invite subcontractor for each task.\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n\n        emit MultipleSCInvited(_taskList, _scList);\n    }\n\n    /// @inheritdoc IProject\n    function acceptInviteSC(uint256[] calldata _taskList) external override {\n        // Accept invitation for each task in taskList.\n        uint256 _length = _taskList.length;\n        for (uint256 i = 0; i < _length; i++) {\n            tasks[_taskList[i]].acceptInvitation(_msgSender());\n        }\n\n        emit SCConfirmed(_taskList);\n    }\n\n    /// @inheritdoc IProject\n    function setComplete(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (uint256 _taskID, address _projectAddress) = abi.decode(\n            _data,\n            (uint256, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!Project\");\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Mark task as complete. Only works when task is active.\n        tasks[_taskID].setComplete();\n\n        // Transfer funds to subcontractor.\n        currency.safeTransfer(\n            tasks[_taskID].subcontractor,\n            tasks[_taskID].cost\n        );\n\n        emit TaskComplete(_taskID);\n    }\n\n    /// @inheritdoc IProject\n    function recoverTokens(address _tokenAddress) external override {\n        /* If the token address is same as currency of this project,\n            then first check if all tasks are complete */\n        if (_tokenAddress == address(currency)) {\n            // Iterate for each task and check if it is complete.\n            uint256 _length = taskCount;\n            for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n                require(tasks[_taskID].getState() == 3, \"Project::!Complete\");\n            }\n        }\n\n        // Create token instance.\n        IDebtToken _token = IDebtToken(_tokenAddress);\n\n        // Check the balance of _token in this contract.\n        uint256 _leftOutTokens = _token.balanceOf(address(this));\n\n        // If balance is present then it to the builder.\n        if (_leftOutTokens > 0) {\n            _token.safeTransfer(builder, _leftOutTokens);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function changeOrder(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        nonReentrant\n    {\n        // Decode params from _data\n        (\n            uint256 _taskID,\n            address _newSC,\n            uint256 _newCost,\n            address _project\n        ) = abi.decode(_data, (uint256, address, uint256, address));\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        // Local variable for task cost. For gas saving.\n        uint256 _taskCost = tasks[_taskID].cost;\n\n        // Local variable indicating if subcontractor is already unapproved.\n        bool _unapproved = false;\n\n        // If task cost is to be changed.\n        if (_newCost != _taskCost) {\n            // Check new task cost precision. Revert if too precise.\n            checkPrecision(_newCost);\n\n            // Local variable for total cost allocated. For gas saving.\n            uint256 _totalAllocated = totalAllocated;\n\n            // If tasks are already allocated with old cost.\n            if (tasks[_taskID].alerts[1]) {\n                // If new task cost is less than old task cost.\n                if (_newCost < _taskCost) {\n                    // Find the difference between old - new.\n                    uint256 _withdrawDifference = _taskCost - _newCost;\n\n                    // Reduce this difference from total cost allocated.\n                    // As the same task is now allocated with lesser cost.\n                    totalAllocated -= _withdrawDifference;\n\n                    // Withdraw the difference back to builder's account.\n                    // As this additional amount may not be required by the project.\n                    autoWithdraw(_withdrawDifference);\n                }\n                // If new cost is more than task cost but total lent is enough to cover for it.\n                else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n                    // Increase the difference of new cost and old cost to total allocated.\n                    totalAllocated += _newCost - _taskCost;\n                }\n                // If new cost is more than task cost and totalLent is not enough.\n                else {\n                    // Un-confirm SC, mark task as inactive, mark allocated as false, mark lifecycle as None\n\n                    // Mark task as inactive by unapproving subcontractor.\n                    // As subcontractor can only be approved if task is allocated\n                    _unapproved = true;\n                    tasks[_taskID].unApprove();\n\n                    // Mark task as not allocated.\n                    tasks[_taskID].unAllocateFunds();\n\n                    // Reduce total allocation by old task cost.\n                    // As as needs to go though funding process again.\n                    totalAllocated -= _taskCost;\n\n                    // Add this task to _changeOrderedTask array. These tasks will be allocated first.\n                    _changeOrderedTask.push(_taskID);\n                }\n            }\n\n            // Store new cost for the task\n            tasks[_taskID].cost = _newCost;\n\n            emit ChangeOrderFee(_taskID, _newCost);\n        }\n\n        // If task subcontractor is to be changed.\n        if (_newSC != tasks[_taskID].subcontractor) {\n            // If task is not already unapproved, then un-approve it.\n            // Un-approving task means marking subcontractor as unconfirmed.\n            if (!_unapproved) {\n                tasks[_taskID].unApprove();\n            }\n\n            // If new subcontractor is not zero address.\n            if (_newSC != address(0)) {\n                // Invite the new subcontractor for the task.\n                _inviteSC(_taskID, _newSC, true);\n            }\n            // Else store zero address for the task subcontractor.\n            // This implies that a subcontractor is not invited from the task.\n            else {\n                tasks[_taskID].subcontractor = address(0);\n            }\n\n            emit ChangeOrderSC(_taskID, _newSC);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Recover the signer from the signature\n        address signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (address _project, uint256 _task, , , ) = abi.decode(\n            _data,\n            (address, uint256, uint8, bytes, bytes)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        if (_task == 0) {\n            // Revet if sender is not builder or contractor\n            require(\n                signer == builder || signer == contractor,\n                \"Project::!(GC||Builder)\"\n            );\n        } else {\n            // Revet if sender is not builder, contractor or task's subcontractor\n            require(\n                signer == builder ||\n                    signer == contractor ||\n                    signer == tasks[_task].subcontractor,\n                \"Project::!(GC||Builder||SC)\"\n            );\n\n            if (signer == tasks[_task].subcontractor) {\n                // If sender is task's subcontractor, revert if invitation is not accepted.\n                require(getAlerts(_task)[2], \"Project::!SCConfirmed\");\n            }\n        }\n\n        // Make a call to Disputes contract raiseDisputes.\n        IDisputes(disputes).raiseDispute(_data, _signature);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function getTask(uint256 id)\n        external\n        view\n        override\n        returns (\n            uint256 cost,\n            address subcontractor,\n            TaskStatus state\n        )\n    {\n        cost = tasks[id].cost;\n        subcontractor = tasks[id].subcontractor;\n        state = tasks[id].state;\n    }\n\n    /// @inheritdoc IProject\n    function changeOrderedTask()\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _changeOrderedTask;\n    }\n\n    /*******************************************************************************\n     * ----------------------------PUBLIC TRANSACTIONS---------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function allocateFunds() public override {\n        // Max amount out times this loop will run\n        // This is to ensure the transaction do not run out of gas (max gas limit)\n        uint256 _maxLoop = 50;\n\n        // Difference of totalLent and totalAllocated is what can be used to allocate new tasks\n        uint256 _costToAllocate = totalLent - totalAllocated;\n\n        // Bool if max loop limit is exceeded\n        bool _exceedLimit;\n\n        // Local instance of lastAllocatedChangeOrderTask. To save gas.\n        uint256 i = lastAllocatedChangeOrderTask;\n\n        // Local instance of lastAllocatedTask. To save gas.\n        uint256 j = lastAllocatedTask;\n\n        // Initialize empty array in which allocated tasks will be added.\n        uint256[] memory _tasksAllocated = new uint256[](\n            taskCount - j + _changeOrderedTask.length - i\n        );\n\n        // Number of times a loop has run.\n        uint256 _loopCount;\n\n        /// CHANGE ORDERED TASK FUNDING ///\n\n        // Any tasks added to _changeOrderedTask will be allocated first\n        if (_changeOrderedTask.length > 0) {\n            // Loop from lastAllocatedChangeOrderTask to _changeOrderedTask length (until _maxLoop)\n            for (; i < _changeOrderedTask.length; i++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[_changeOrderedTask[i]].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[_changeOrderedTask[i]].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = _changeOrderedTask[i];\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all the change ordered tasks are allocated, then delete\n            // the changeOrderedTask array and reset lastAllocatedChangeOrderTask.\n            if (i == _changeOrderedTask.length) {\n                lastAllocatedChangeOrderTask = 0;\n                delete _changeOrderedTask;\n            }\n            // Else store the last allocated change order task index.\n            else {\n                lastAllocatedChangeOrderTask = i;\n            }\n        }\n\n        /// TASK FUNDING ///\n\n        // If lastAllocatedTask is lesser than taskCount, that means there are un-allocated tasks\n        if (j < taskCount) {\n            // Loop from lastAllocatedTask + 1 to taskCount (until _maxLoop)\n            for (++j; j <= taskCount; j++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[j].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[j].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = j;\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all pending tasks are allocated store lastAllocatedTask equal to taskCount\n            if (j > taskCount) {\n                lastAllocatedTask = taskCount;\n            }\n            // If not all tasks are allocated store updated lastAllocatedTask\n            else {\n                lastAllocatedTask = --j;\n            }\n        }\n\n        // If any tasks is allocated, then emit event\n        if (_loopCount > 0) emit TaskAllocated(_tasksAllocated);\n\n        // If allocation was incomplete, then emit event\n        if (_exceedLimit) emit IncompleteAllocation();\n\n        // Update totalAllocated with all allocations\n        totalAllocated = totalLent - _costToAllocate;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function projectCost() public view override returns (uint256 _cost) {\n        // Local instance of taskCount. To save gas.\n        uint256 _length = taskCount;\n\n        // Iterate over all tasks to sum their cost\n        for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n            _cost += tasks[_taskID].cost;\n        }\n    }\n\n    /// @inheritdoc IProject\n    function getAlerts(uint256 _taskID)\n        public\n        view\n        override\n        returns (bool[3] memory _alerts)\n    {\n        return tasks[_taskID].getAlerts();\n    }\n\n    /// @inheritdoc IProject\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IProject)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Invite subcontractors for a single task. This can be called by builder or contractor.\n     * _taskList must not have a task which already has approved subcontractor.\n     \n     * @param _taskID uint256 task index\n     * @param _sc address addresses of subcontractor for the respective task\n     * @param _emitEvent whether to emit event for each sc added or not\n     */\n    function _inviteSC(\n        uint256 _taskID,\n        address _sc,\n        bool _emitEvent\n    ) internal {\n        // Revert if sc to invite is address 0\n        require(_sc != address(0), \"Project::0 address\");\n\n        // Internal call to tasks invite contractor\n        tasks[_taskID].inviteSubcontractor(_sc);\n\n        // If `_emitEvent` is true (called via changeOrder) then emit event\n        if (_emitEvent) {\n            emit SingleSCInvited(_taskID, _sc);\n        }\n    }\n\n    /**\n     * @dev Transfer excess funds back to builder wallet.\n     * Called internally in task changeOrder when new task cost is lower than older cost.\n\n     * @param _amount uint256 - amount of excess funds\n     */\n    function autoWithdraw(uint256 _amount) internal {\n        // Reduce amount from totalLent\n        totalLent -= _amount;\n\n        // Transfer amount to builder address\n        currency.safeTransfer(builder, _amount);\n\n        emit AutoWithdrawn(_amount);\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder and contractor address.\n     * Signatures must be in sequential order. First builder and then contractor.\n     * Reverts if signature do not match.\n     * If contractor is not assigned then only checks for builder signature.\n     * If contractor is assigned but not delegated then only checks for builder and contractor signature.\n     * If contractor is assigned and delegated then only checks for contractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     */\n    function checkSignature(bytes calldata _data, bytes calldata _signature)\n        internal\n    {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Check for builder's signature\n            checkSignatureValidity(builder, _hash, _signature, 0);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                //  Check contractor's signature\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for both B and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n            }\n        }\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder, contractor and subcontractor address for a task.\n     * Signatures must be in sequential order. First builder, then contractor, and then subcontractor.\n     * reverts if signatures do not match.\n     * If contractor is not assigned then only checks for builder and subcontractor signature.\n     * If contractor is assigned but not delegated then only checks for builder, contractor and subcontractor signature.\n     * If contractor is assigned and delegated then only checks for contractor and subcontractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     * @param _taskID index of the task.\n     */\n    function checkSignatureTask(\n        bytes calldata _data,\n        bytes calldata _signature,\n        uint256 _taskID\n    ) internal {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of subcontractor. To save gas.\n        address _sc = tasks[_taskID].subcontractor;\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Just check for B and SC sign\n            checkSignatureValidity(builder, _hash, _signature, 0);\n            checkSignatureValidity(_sc, _hash, _signature, 1);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                // Check for GC and SC sign\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n                checkSignatureValidity(_sc, _hash, _signature, 1);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for B, SC and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n                checkSignatureValidity(_sc, _hash, _signature, 2);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev Checks if the signature is approved or recovered\n     * @dev Reverts if not\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal {\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Project::invalid signature\"\n        );\n        // delete from approvedHash\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * -------------------------------INTERNAL PURE------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Check if precision is greater than 1000, if so, it reverts\n\n     * @param _amount amount needed to be checked for precision.\n     */\n    function checkPrecision(uint256 _amount) internal pure {\n        // Divide and multiply amount with 1000 should be equal to amount.\n        // This ensures the amount is not too precise.\n        require(\n            ((_amount / 1000) * 1000) == _amount,\n            \"Project::Precision>=1000\"\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Disputes Contract for HomeFi v2.5.0\n\n * @dev Module for raising disputes for arbitration within HomeFi projects\n */\ncontract Disputes is\n    IDisputes,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    IHomeFi public override homeFi;\n    /// @inheritdoc IDisputes\n    uint256 public override disputeCount; //starts from 0\n    /// @inheritdoc IDisputes\n    mapping(uint256 => Dispute) public override disputes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00)\n        require(_address != address(0), \"Disputes::0 address\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        // Revert if sender is not HomeFi admin\n        // Only HomeFi admin can resolve dispute\n        require(homeFi.admin() == _msgSender(), \"Disputes::!Admin\");\n        _;\n    }\n\n    modifier onlyProject() {\n        // Revert if project not originated of HomeFi\n        require(homeFi.isProjectExist(_msgSender()), \"Disputes::!Project\");\n        _;\n    }\n\n    /**\n     * Affirm that a given dispute is currently resolvable\n     * @param _disputeID uint256 - the serial/id of the dispute\n     */\n    modifier resolvable(uint256 _disputeID) {\n        require(\n            _disputeID < disputeCount &&\n                disputes[_disputeID].status == Status.Active,\n            \"Disputes::!Resolvable\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        homeFi = IHomeFi(_homeFi);\n    }\n\n    /// @inheritdoc IDisputes\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        onlyProject\n    {\n        // Recover signer from signature\n        address _signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (\n            address _project,\n            uint256 _taskID,\n            uint8 _actionType,\n            bytes memory _actionData,\n            bytes memory _reason\n        ) = abi.decode(_data, (address, uint256, uint8, bytes, bytes));\n\n        // Revert if _actionType is invalid\n        require(\n            _actionType > 0 && _actionType <= uint8(ActionType.TaskPay),\n            \"Disputes::!ActionType\"\n        );\n\n        // Store dispute details\n        Dispute storage _dispute = disputes[disputeCount];\n        _dispute.status = Status.Active;\n        _dispute.project = _project;\n        _dispute.taskID = _taskID;\n        _dispute.raisedBy = _signer;\n        _dispute.actionType = ActionType(_actionType);\n        _dispute.actionData = _actionData;\n\n        // Increment dispute counter and emit event\n        emit DisputeRaised(disputeCount++, _reason);\n    }\n\n    /// @inheritdoc IDisputes\n    function attachDocument(uint256 _disputeID, bytes calldata _attachment)\n        external\n        override\n        resolvable(_disputeID)\n    {\n        // Local instance of variable. For saving gas.\n        Dispute storage _dispute = disputes[_disputeID];\n\n        // Check if sender is related to dispute\n        assertMember(_dispute.project, _dispute.taskID, _msgSender());\n\n        // Emit _attachment in event. To save it in logs.\n        emit DisputeAttachmentAdded(_disputeID, _msgSender(), _attachment);\n    }\n\n    /// @inheritdoc IDisputes\n    function resolveDispute(\n        uint256 _disputeID,\n        bytes calldata _judgement,\n        bool _ratify\n    ) external override onlyAdmin nonReentrant resolvable(_disputeID) {\n        // If dispute is accepted\n        if (_ratify) {\n            // Complete dispute actions\n            resolveHandler(_disputeID);\n\n            // Mark dispute as accepted\n            disputes[_disputeID].status = Status.Accepted;\n        }\n        // If dispute is rejected\n        else {\n            // Mark dispute as rejected\n            disputes[_disputeID].status = Status.Rejected;\n        }\n\n        emit DisputeResolved(_disputeID, _ratify, _judgement);\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function assertMember(\n        address _project,\n        uint256 _taskID,\n        address _address\n    ) public view override {\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Get task subcontractor\n        (, address _sc, ) = _projectInstance.getTask(_taskID);\n\n        // Revert is signer is not builder, contractor or subcontractor.\n        bool _result = _projectInstance.builder() == _address ||\n            _projectInstance.contractor() == _address ||\n            _sc == _address;\n        require(_result, \"Disputes::!Member\");\n    }\n\n    /// @inheritdoc IDisputes\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IDisputes)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice Given an id, attempt to execute the action to enforce the arbitration\n\n     * @notice logic for decoding and enforcing outcome of arbitration judgement\n\n     * @param _disputeID uint256 - the dispute to attempt to\n     */\n    function resolveHandler(uint256 _disputeID) internal {\n        // Local instance of variable. For saving gas.\n        Dispute storage dispute = disputes[_disputeID];\n\n        // If action type is add task then execute add task\n        if (dispute.actionType == ActionType.TaskAdd) {\n            executeTaskAdd(dispute.project, dispute.actionData);\n        }\n        // If action type is task change then execute task change\n        else if (dispute.actionType == ActionType.TaskChange) {\n            executeTaskChange(dispute.project, dispute.actionData);\n        }\n        // Else execute task pay\n        else {\n            executeTaskPay(dispute.project, dispute.actionData);\n        }\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task add transaction data stored when dispute was raised\n     * - _hash bytes[] - bytes IPFS hash of task details\n     * - _taskCosts uint256[] - an array of cost for each task index\n     * - _taskCount uint256 - current task count before adding these tasks. Can be fetched by taskCount.\n     *   For signature security.\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskAdd(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).addTasks(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task change order transaction data stored when dispute was raised\n     * - _taskID uint256 - index of the task\n     * - _newSC address - address of new subcontractor.\n     *   If do not want to replace subcontractor, then pass address of existing subcontractor.\n     * - _newCost uint256 - new cost for the task.\n     *   If do not want to change cost, then pass existing cost.\n     * - _project address - address of project\n     */\n    function executeTaskChange(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).changeOrder(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task payout\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task payout transaction data stored when dispute was raised\n     * - _taskID uint256 - the index of task\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskPay(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).setComplete(_actionData, bytes(\"\"));\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {Project} from \"./Project.sol\";\nimport {IProjectFactory} from \"./interfaces/IProjectFactory.sol\";\nimport {ClonesUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\nimport {Initializable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\n\n/**\n * @title ProjectFactory for HomeFi v2.5.0\n\n * @dev This contract is used by HomeFi to create cheap clones of Project contract underlying\n */\ncontract ProjectFactory is\n    IProjectFactory,\n    Initializable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProjectFactory\n    address public override underlying;\n    /// @inheritdoc IProjectFactory\n    address public override homeFi;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Ensure an address is not the zero address (0x00)\n        require(_address != address(0), \"PF::0 address\");\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProjectFactory\n    function initialize(address _underlying, address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_underlying)\n        nonZero(_homeFi)\n    {\n        // Store details\n        underlying = _underlying;\n        homeFi = _homeFi;\n    }\n\n    /// @inheritdoc IProjectFactory\n    function changeProjectImplementation(address _underlying)\n        external\n        override\n        nonZero(_underlying)\n    {\n        // Revert if sender is not HomeFi admin\n        require(\n            _msgSender() == IHomeFi(homeFi).admin(),\n            \"ProjectFactory::!Owner\"\n        );\n\n        // Update details\n        underlying = _underlying;\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProjectFactory\n    function createProject(address _currency, address _sender)\n        external\n        override\n        returns (address _clone)\n    {\n        // Revert if sender is not HomeFi\n        require(_msgSender() == homeFi, \"PF::!HomeFiContract\");\n\n        // Create clone of Project implementation\n        _clone = ClonesUpgradeable.clone(underlying);\n\n        // Initialize project\n        Project(_clone).initialize(_currency, _sender, homeFi);\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProjectFactory\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IProjectFactory)\n        returns (bool)\n    {\n        return IHomeFi(homeFi).isTrustedForwarder(_forwarder);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {TransparentUpgradeableProxy} from \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title HomeFiProxy Contract for HomeFi v2.5.0\n\n * @dev This contract provided functionality to update the core HomeFi contracts.\n */\ncontract HomeFiProxy is OwnableUpgradeable {\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @notice Address of proxy admin\n    ProxyAdmin public proxyAdmin;\n\n    /// @notice bytes2 array of upgradable contracts initials\n    bytes2[] public allContractNames;\n\n    /*******************************************************************************\n     * ------------------------INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @dev mapping that tell if a particular address is active(latest version of contract)\n    mapping(address => bool) internal contractsActive;\n\n    /// @dev mapping that maps contract initials with there implementation address\n    mapping(bytes2 => address payable) internal contractAddress;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    /// @dev check _address should not be zero address\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"Proxy::0 address\");\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice Initialize all the homeFi contract in the correct sequential order and generate upgradable proxy for them.\n\n     * @dev Can only be called by HomeFiProxy owner.\n     * @dev modifier initializer\n     * @dev if more contract are added in homeFi, then their entry can be done here. \n\n     * @param _implementations the implementation address of homeFi smart contract in correct sequence.\n     */\n    function initiateHomeFi(address[] calldata _implementations)\n        external\n        initializer\n    {\n        // Initialize ownable\n        __Ownable_init();\n\n        // Create new proxy admin contract\n        proxyAdmin = new ProxyAdmin();\n\n        // Initial contract names\n        allContractNames.push(\"HF\"); // HomeFi\n        allContractNames.push(\"CN\"); // Community\n        allContractNames.push(\"DP\"); // Disputes\n        allContractNames.push(\"PF\"); // Project Factory\n        allContractNames.push(\"DA\"); // rDAI\n        allContractNames.push(\"US\"); // rUSDC\n        allContractNames.push(\"NT\"); // native token rETH - rXDAI\n\n        // Local instance of variable. For saving gas.\n        uint256 _length = allContractNames.length;\n\n        // Revert if _implementations length is wrong. Indicating wrong set of _implementations.\n        require(_length == _implementations.length, \"Proxy::Lengths !match\");\n\n        // Mark this contract as active\n        contractsActive[address(this)] = true;\n\n        // Generate proxy for all implementation\n        for (uint256 i = 0; i < _length; i++) {\n            _generateProxy(allContractNames[i], _implementations[i]);\n        }\n    }\n\n    /**\n     * @notice Adds a new contract type/implementation to HomeFi\n\n     * @dev modifier onlyOwner\n\n     * @param _contractName initial of contract to be added\n     * @param _contractAddress address of contract implementation to be added.\n     */\n    function addNewContract(bytes2 _contractName, address _contractAddress)\n        external\n        onlyOwner\n    {\n        // Revert if _contractName is already in use.\n        require(\n            contractAddress[_contractName] == address(0),\n            \"Proxy::Name !OK\"\n        );\n\n        // Add to allContractNames\n        allContractNames.push(_contractName);\n\n        // Generate proxy\n        _generateProxy(_contractName, _contractAddress);\n    }\n\n    /**\n     * @notice Upgrades a multiple contract implementations. Replaces old implementation with new.\n\n     * @dev modifier onlyOwner\n\n     * @param _contractNames bytes2 array of contract initials that needs to be upgraded\n     * @param _contractAddresses address array of contract implementation address that needs to be upgraded\n     */\n    function upgradeMultipleImplementations(\n        bytes2[] calldata _contractNames,\n        address[] calldata _contractAddresses\n    ) external onlyOwner {\n        // Local instance of variable. For saving gas.\n        uint256 _length = _contractNames.length;\n\n        // Revert if _contractNames and _contractAddresses length mismatch\n        require(_length == _contractAddresses.length, \"Proxy::Lengths !match\");\n\n        // Replace implementations\n        for (uint256 i = 0; i < _length; i++) {\n            _replaceImplementation(_contractNames[i], _contractAddresses[i]);\n        }\n    }\n\n    /**\n     * @notice Allows HomeFiProxy owner to change the owner of proxyAdmin contract.\n     * This can be useful when trying to deploy new version of HomeFiProxy\n\n     * @dev modifier onlyOwner\n     * @dev modifier nonZero with _newAdmin\n\n     * @param _newAdmin address of new proxyAdmin owner / new version of HomeFiProxy\n     */\n    function changeProxyAdminOwner(address _newAdmin)\n        external\n        onlyOwner\n        nonZero(_newAdmin)\n    {\n        // Transfer ownership to new admin.\n        proxyAdmin.transferOwnership(_newAdmin);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice To check if we use the particular contract.\n     * @param _address The contract address to check if it is active or not.\n     * @return true if _address is active else false\n     */\n    function isActive(address _address) external view returns (bool) {\n        return contractsActive[_address];\n    }\n\n    /**\n     * @notice Gets latest contract address\n     * @param _contractName Contract name to fetch\n     * @return current implementation address corresponding to _contractName\n     */\n    function getLatestAddress(bytes2 _contractName)\n        external\n        view\n        returns (address)\n    {\n        return contractAddress[_contractName];\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Replaces the implementations of the contract.\n     * @dev modifier nonZero with _contractAddress\n\n     * @param _contractName The name of the contract.\n\n     * @param _contractAddress The address of the contract to replace the implementations for.\n     */\n    function _replaceImplementation(\n        bytes2 _contractName,\n        address _contractAddress\n    ) internal nonZero(_contractAddress) {\n        // Upgrade proxy\n        proxyAdmin.upgrade(\n            TransparentUpgradeableProxy(contractAddress[_contractName]),\n            _contractAddress\n        );\n    }\n\n    /**\n     * @dev generates upgradable proxy\n     * @dev modifier nonZero with _contractAddress\n\n     * @param _contractName initial of the contract\n\n     * @param _contractAddress of the proxy\n     */\n    function _generateProxy(bytes2 _contractName, address _contractAddress)\n        internal\n        nonZero(_contractAddress)\n    {\n        // Deploys new TransparentUpgradeableProxy for implementation\n        TransparentUpgradeableProxy tempInstance = new TransparentUpgradeableProxy(\n                _contractAddress,\n                address(proxyAdmin),\n                bytes(\"\")\n            );\n\n        // Store details\n        contractAddress[_contractName] = payable(address(tempInstance));\n        contractsActive[address(tempInstance)] = true;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {ICommunity, IDebtToken} from \"./interfaces/ICommunity.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Community Contract for HomeFi v2.5.0\n \n * @notice Module for coordinating lending groups on HomeFi protocol\n */\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ---------------------FIXED INTERNAL STORED PROPERTIES---------------------- *\n     *******************************************************************************/\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    /*******************************************************************************\n     * --------------------VARIABLE INTERNAL STORED PROPERTIES-------------------- *\n     *******************************************************************************/\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    IHomeFi public override homeFi;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    bool public override restrictedToAdmin;\n    /// @inheritdoc ICommunity\n    uint256 public override communityCount;\n    /// @inheritdoc ICommunity\n    mapping(address => uint256) public override projectPublished;\n    /// @inheritdoc ICommunity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00) (invalid)\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        // Revert if sender is not homeFi admin\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n        // Revert if sender is not _project builder\n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        // Initialize pausable. Set pause to false;\n        __Pausable_init();\n\n        // Initialize variables\n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        // Community creation is paused for non admin by default paused\n        restrictedToAdmin = true;\n    }\n\n    /// @inheritdoc ICommunity\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        // Local variable for sender. For gas saving.\n        address _sender = _msgSender();\n\n        // Revert if community creation is paused or sender is not HomeFi admin\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        // Revert if currency is not supported by HomeFi\n        homeFi.validCurrency(_currency);\n\n        // Increment community counter\n        communityCount++;\n\n        // Store community details\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        override\n    {\n        // Revert if sender is not _communityID owner\n        require(\n            _communities[_communityID].owner == _msgSender(),\n            \"Community::!owner\"\n        );\n\n        // Emit event if _hash. This way this hash needs not be stored in memory.\n        emit UpdateCommunityHash(_communityID, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _newMemberAddr,\n            bytes memory _messageHash\n        ) = abi.decode(_data, (uint256, address, bytes));\n\n        CommunityStruct storage _community = _communities[_communityID];\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\n        // Revert if new member already exists\n        require(\n            !_community.isMember[_newMemberAddr],\n            \"Community::Member Exists\"\n        );\n\n        // Store updated community details\n        uint256 _memberCount = _community.memberCount;\n        _community.memberCount = _memberCount + 1;\n        _community.members[_memberCount] = _newMemberAddr;\n        _community.isMember[_newMemberAddr] = true;\n\n        emit MemberAdded(_communityID, _newMemberAddr, _messageHash);\n    }\n\n    /// @inheritdoc ICommunity\n    function publishProject(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _project,\n            uint256 _apr,\n            uint256 _publishFee,\n            uint256 _publishNonce,\n            bytes memory _messageHash\n        ) = abi.decode(\n                _data,\n                (uint256, address, uint256, uint256, uint256, bytes)\n            );\n\n        // Local instance of community and community  project details. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(\n            _publishNonce == _community.publishNonce,\n            \"Community::invalid publishNonce\"\n        );\n\n        // Reverts if _project not originated from HomeFi\n        require(homeFi.isProjectExist(_project), \"Community::Project !Exists\");\n\n        // Local instance of variables. For saving gas.\n        IProject _projectInstance = IProject(_project);\n        address _builder = _projectInstance.builder();\n\n        // Revert if project builder is not community member\n        require(_community.isMember[_builder], \"Community::!Member\");\n\n        // Revert if project currency does not match community currency\n        require(\n            _projectInstance.currency() == _community.currency,\n            \"Community::!Currency\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be project builder\n\n        // If already published then unpublish first\n        if (projectPublished[_project] > 0) {\n            _unpublishProject(_project);\n        }\n\n        // Store updated details\n        _community.publishNonce = ++_community.publishNonce;\n        _communityProject.apr = _apr;\n        _communityProject.publishFee = _publishFee;\n        projectPublished[_project] = _communityID;\n\n        // If _publishFee is zero than mark publish fee as paid\n        if (_publishFee == 0) _communityProject.publishFeePaid = true;\n\n        emit ProjectPublished(\n            _communityID,\n            _project,\n            _apr,\n            _publishFee,\n            _communityProject.publishFeePaid,\n            _messageHash\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function unpublishProject(uint256 _communityID, address _project)\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Call internal function to unpublish project\n        _unpublishProject(_project);\n    }\n\n    /// @inheritdoc ICommunity\n    function payPublishFee(uint256 _communityID, address _project)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if publish fee already paid\n        require(\n            !_communityProject.publishFeePaid,\n            \"Community::publish fee paid\"\n        );\n\n        // Store updated detail\n        _communityProject.publishFeePaid = true;\n\n        // Transfer publishFee to community owner (lender)\n        _community.currency.safeTransferFrom(\n            _msgSender(),\n            _community.owner,\n            _communityProject.publishFee\n        );\n\n        emit PublishFeePaid(_communityID, _project);\n    }\n\n    /// @inheritdoc ICommunity\n    function toggleLendingNeeded(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingNeeded\n    )\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        // Revert if publish fee not paid\n        require(\n            _communityProject.publishFeePaid,\n            \"Community::publish fee !paid\"\n        );\n\n        // Revert if _lendingNeeded is more than projectCost or less than what is already lent\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n\n        // Store updated detail\n        _communityProject.lendingNeeded = _lendingNeeded;\n\n        emit ToggleLendingNeeded(_communityID, _project, _lendingNeeded);\n    }\n\n    /// @inheritdoc ICommunity\n    function lendToProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingAmount,\n        bytes calldata _hash\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n    {\n        // Local instance of variable. For saving gas.\n        address _sender = _msgSender();\n\n        // Revert if sender is not community owner.\n        // Only community owner can lend.\n        require(\n            _sender == _communities[_communityID].owner,\n            \"Community::!owner\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Calculate lenderFee\n        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /\n            (_projectInstance.lenderFee() + 1000);\n\n        // Calculate amount going to project. Lending amount - lending fee.\n        uint256 _amountToProject = _lendingAmount - _lenderFee;\n\n        // Revert if _amountToProject is not within further investment needed.\n        require(\n            _amountToProject <=\n                _communities[_communityID]\n                    .projectDetails[_project]\n                    .lendingNeeded -\n                    _communities[_communityID]\n                        .projectDetails[_project]\n                        .totalLent,\n            \"Community::lending>needed\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IDebtToken _currency = _communities[_communityID].currency;\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_currency))\n        );\n\n        // Update investment in Project\n        _projectInstance.lendToProject(_amountToProject);\n\n        // Update total lent by lender\n        _communities[_communityID]\n            .projectDetails[_project]\n            .totalLent += _amountToProject;\n\n        // First claim interest if principal lent > 0\n        if (\n            _communities[_communityID].projectDetails[_project].lentAmount > 0\n        ) {\n            claimInterest(_communityID, _project, _wrappedToken);\n        }\n\n        // Increment lent principal\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lentAmount += _lendingAmount;\n\n        // Update lastTimestamp\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lastTimestamp = block.timestamp;\n\n        // Transfer _lenderFee to HomeFi treasury from lender account\n        _currency.safeTransferFrom(_msgSender(), homeFi.treasury(), _lenderFee);\n\n        // Transfer _amountToProject to _project from lender account\n        _currency.safeTransferFrom(_msgSender(), _project, _amountToProject);\n\n        // Mint new _lendingAmount amount wrapped token to lender\n        _wrappedToken.mint(_sender, _lendingAmount);\n\n        emit LenderLent(_communityID, _project, _sender, _lendingAmount, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function repayLender(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        onlyProjectBuilder(_project)\n    {\n        // Internally call reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, \"0x\");\n\n        // Local instance of variable. For saving gas.\n        address _lender = _communities[_communityID].owner;\n\n        // Transfer repayment to lender\n        _communities[_communityID].currency.safeTransferFrom(\n            _msgSender(),\n            _lender,\n            _repayAmount\n        );\n\n        emit RepayLender(_communityID, _project, _lender, _repayAmount);\n    }\n\n    /// @inheritdoc ICommunity\n    function reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) external virtual override whenNotPaused {\n        // Revert if sender is not _communityID owner (lender)\n        require(\n            _msgSender() == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n    }\n\n    /// @inheritdoc ICommunity\n    function approveHash(bytes32 _hash) external virtual override {\n        // allowing anyone to sign, as its hard to add restrictions here\n        approvedHashes[_msgSender()][_hash] = true;\n\n        emit ApproveHash(_hash, _msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function escrow(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _builder,\n            address _lender,\n            address _agent,\n            address _project,\n            uint256 _repayAmount,\n            bytes memory _details\n        ) = abi.decode(\n                _data,\n                (uint256, address, address, address, address, uint256, bytes)\n            );\n\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Revert if decoded builder is not decoded project's builder\n        require(_builder == _projectInstance.builder(), \"Community::!Builder\");\n\n        // Revert if decoded _communityID's owner is not decoded _lender\n        require(\n            _lender == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder\n        checkSignatureValidity(_agent, _hash, _signature, 2); // must be agent or escrow\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n        emit DebtReducedByEscrow(_agent);\n    }\n\n    /// @inheritdoc ICommunity\n    function restrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already restricted to admin\n        require(!restrictedToAdmin, \"Community::restricted\");\n\n        // Disable community creation for non admins\n        restrictedToAdmin = true;\n\n        emit RestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function unrestrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already unrestricted to admin\n        require(restrictedToAdmin, \"Community::!restricted\");\n\n        // Allow community creation for all\n        restrictedToAdmin = false;\n\n        emit UnrestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function pause() external override onlyHomeFiAdmin {\n        _pause();\n    }\n\n    /// @inheritdoc ICommunity\n    function unpause() external override onlyHomeFiAdmin {\n        _unpause();\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function communities(uint256 _communityID)\n        external\n        view\n        override\n        returns (\n            address owner,\n            address currency,\n            uint256 memberCount,\n            uint256 publishNonce\n        )\n    {\n        CommunityStruct storage _community = _communities[_communityID];\n\n        owner = _community.owner;\n        currency = address(_community.currency);\n        memberCount = _community.memberCount;\n        publishNonce = _community.publishNonce;\n    }\n\n    /// @inheritdoc ICommunity\n    function members(uint256 _communityID)\n        external\n        view\n        virtual\n        override\n        returns (address[] memory)\n    {\n        // Initiate empty equal equal to member count length\n        address[] memory _members = new address[](\n            _communities[_communityID].memberCount\n        );\n\n        // Append member addresses in _members array\n        for (uint256 i = 0; i < _communities[_communityID].memberCount; i++) {\n            _members[i] = _communities[_communityID].members[i];\n        }\n\n        return _members;\n    }\n\n    /// @inheritdoc ICommunity\n    function projectDetails(uint256 _communityID, address _project)\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        return (\n            _communityProject.apr,\n            _communityProject.lendingNeeded,\n            _communityProject.totalLent,\n            _communityProject.publishFee,\n            _communityProject.publishFeePaid,\n            _communityProject.lentAmount,\n            _communityProject.interest,\n            _communityProject.lastTimestamp\n        );\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function returnToLender(uint256 _communityID, address _project)\n        public\n        view\n        override\n        returns (\n            uint256, // principal + interest\n            uint256, // principal\n            uint256, // total interest\n            uint256 // unclaimedInterest\n        )\n    {\n        // Local instance of variables. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n        uint256 _lentAmount = _communityProject.lentAmount;\n\n        // Calculate number of days difference current and last timestamp\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) / 86400; // 24*60*60\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000;\n\n        // Old (already rTokens claimed) + new interest\n        uint256 _totalInterest = _unclaimedInterest +\n            _communityProject.interest;\n\n        return (\n            _lentAmount + _totalInterest,\n            _lentAmount,\n            _totalInterest,\n            _unclaimedInterest\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, ICommunity)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev internal function for `unpublishProject`\n     * @param _project address - project address to unpublish\n     */\n    function _unpublishProject(address _project) internal {\n        // Locally store old community of published project\n        uint256 formerCommunityId = projectPublished[_project];\n\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[\n            formerCommunityId\n        ].projectDetails[_project];\n\n        // Reduce lending needed to total lent. So no more investment can be made to this project.\n        _communityProject.lendingNeeded = _communityProject.totalLent;\n\n        // Mark project as unpublished.\n        delete projectPublished[_project];\n\n        // Set public fee paid to false.\n        // So if this project is published again to this community,\n        // then this fee will be required to be paid again.\n        _communityProject.publishFeePaid = false;\n\n        emit ProjectUnpublished(formerCommunityId, _project);\n    }\n\n    /**\n     * @dev Internal function for reducing debt\n\n     * @param _communityID uint256 - the the uuid of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _repayAmount uint256 - the amount of funds repaid to the lender, in the project currency\n     * @param _details bytes - some details on why debt is reduced (off chain documents or images)\n     */\n    function _reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) internal virtual {\n        // Revert if repayment amount is zero.\n        require(_repayAmount > 0, \"Community::!repay\");\n\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n        address _lender = _community.owner;\n\n        // Find wrapped token for community currency\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_community.currency))\n        );\n\n        // Claim interest on existing investments\n        claimInterest(_communityID, _project, _wrappedToken);\n\n        // Local instance of variables. For saving gas.\n        uint256 _lentAmount = _communityProject.lentAmount;\n        uint256 _interest = _communityProject.interest;\n\n        if (_repayAmount > _interest) {\n            // If repayment amount is greater than interest then\n            // set lent = lent + interest - repayment.\n            // And set interest = 0.\n            uint256 _lentAndInterest = _lentAmount + _interest;\n\n            // Revert if repayment amount is greater than sum of lent and interest.\n            require(_lentAndInterest >= _repayAmount, \"Community::!Liquid\");\n            _interest = 0;\n            _lentAmount = _lentAndInterest - _repayAmount;\n        } else {\n            // If repayment amount is lesser than interest, then set\n            // interest = interest - repayment\n            _interest -= _repayAmount;\n        }\n\n        // Update community  project details\n        _communityProject.lentAmount = _lentAmount;\n        _communityProject.interest = _interest;\n\n        // Burn _repayAmount amount wrapped token from lender\n        _wrappedToken.burn(_lender, _repayAmount);\n\n        emit DebtReduced(\n            _communityID,\n            _project,\n            _lender,\n            _repayAmount,\n            _details\n        );\n    }\n\n    /**\n     * @dev claim interest of lender\n\n     * @param _communityID uint256 - uuid of community the project is held in\n     * @param _project address - address of project where debt/ loan is held\n     * @param _wrappedToken address - debt token lender is claiming\n     */\n    function claimInterest(\n        uint256 _communityID,\n        address _project,\n        IDebtToken _wrappedToken\n    ) internal {\n        // Calculate new interest\n        (, , uint256 _interest, uint256 _interestEarned) = returnToLender(\n            _communityID,\n            _project\n        );\n\n        // Local instance of variables. For saving gas.\n        address _lender = _communities[_communityID].owner;\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        if (_interestEarned > 0) {\n            // If any new interest is to be claimed.\n\n            // Increase total interest with new interest to be claimed.\n            _communityProject.interest = _interest;\n\n            // Update lastTimestamp to current time.\n            _communityProject.lastTimestamp = block.timestamp;\n\n            // Burn _interestEarned amount wrapped token to lender\n            _wrappedToken.mint(_lender, _interestEarned);\n\n            emit ClaimedInterest(\n                _communityID,\n                _project,\n                _lender,\n                _interestEarned\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev checks if the signature is approved or recovered, if not it reverts.\n\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal virtual {\n        // Decode signer\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n\n        // Revert if decoded signer does not match expected address\n        // Or if hash is not approved by the expected address.\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Community::invalid signature\"\n        );\n\n        // Delete from approvedHash. So that signature cannot be reused.\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProjectFactory} from \"./interfaces/IProjectFactory.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC721URIStorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\n\n/**\n * @title HomeFi v2.5.0 HomeFi Contract.\n\n * @notice Main on-chain client.\n * Administrative controls and project deployment.\n \n * @dev\n * Adheres to -\n * IHomeFi: Allows this contract to be used by other HomeFi contracts.\n\n * @dev\n * Inherits from -\n * ReentrancyGuardUpgradeable: Contract module that helps prevent reentrant calls to a function.\n * ERC721URIStorageUpgradeable: ERC721 token with storage based token URI management.\n * ERC2771ContextUpgradeable: Context variant with ERC2771 support.\n */\ncontract HomeFi is\n    IHomeFi,\n    ReentrancyGuardUpgradeable,\n    ERC721URIStorageUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency1;\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency2;\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency3;\n    /// @inheritdoc IHomeFi\n    IProjectFactory public override projectFactoryInstance;\n    /// @inheritdoc IHomeFi\n    address public override disputesContract;\n    /// @inheritdoc IHomeFi\n    address public override communityContract;\n    /// @inheritdoc IHomeFi\n    bool public override addrSet;\n    /// @inheritdoc IHomeFi\n    address public override admin;\n    /// @inheritdoc IHomeFi\n    address public override treasury;\n    /// @inheritdoc IHomeFi\n    uint256 public override lenderFee;\n    /// @inheritdoc IHomeFi\n    uint256 public override projectCount;\n    /// @inheritdoc IHomeFi\n    address public override trustedForwarder;\n    /// @inheritdoc IHomeFi\n    mapping(uint256 => address) public override projects;\n    /// @inheritdoc IHomeFi\n    mapping(address => uint256) public override projectTokenId;\n    /// @inheritdoc IHomeFi\n    mapping(address => address) public override wrappedToken;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier onlyAdmin() {\n        require(admin == _msgSender(), \"HomeFi::!Admin\");\n        _;\n    }\n\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"HomeFi::0 address\");\n        _;\n    }\n\n    modifier noChange(address _oldAddress, address _newAddress) {\n        // Revert if new address is same as old\n        require(_oldAddress != _newAddress, \"HomeFi::!Change\");\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IHomeFi\n    function initialize(\n        address _treasury,\n        uint256 _lenderFee,\n        address _tokenCurrency1,\n        address _tokenCurrency2,\n        address _tokenCurrency3,\n        address _forwarder\n    )\n        external\n        override\n        initializer\n        nonZero(_treasury)\n        nonZero(_tokenCurrency1)\n        nonZero(_tokenCurrency2)\n        nonZero(_tokenCurrency3)\n    {\n        // Initialize ERC721 and ERC2771Context\n        __ERC721_init(\"HomeFiNFT\", \"hNFT\");\n        __ERC2771Context_init(_forwarder);\n\n        // Initialize variables\n        admin = _msgSender();\n        treasury = _treasury;\n        lenderFee = _lenderFee; // the percentage must be multiplied with 10\n        tokenCurrency1 = _tokenCurrency1;\n        tokenCurrency2 = _tokenCurrency2;\n        tokenCurrency3 = _tokenCurrency3;\n        trustedForwarder = _forwarder;\n    }\n\n    /// @inheritdoc IHomeFi\n    function setAddr(\n        address _projectFactory,\n        address _communityContract,\n        address _disputesContract,\n        address _hTokenCurrency1,\n        address _hTokenCurrency2,\n        address _hTokenCurrency3\n    )\n        external\n        override\n        onlyAdmin\n        nonZero(_projectFactory)\n        nonZero(_communityContract)\n        nonZero(_disputesContract)\n        nonZero(_hTokenCurrency1)\n        nonZero(_hTokenCurrency2)\n        nonZero(_hTokenCurrency3)\n    {\n        // Revert if addrSet is true\n        require(!addrSet, \"HomeFi::Set\");\n\n        // Initialize variables\n        projectFactoryInstance = IProjectFactory(_projectFactory);\n        communityContract = _communityContract;\n        disputesContract = _disputesContract;\n        wrappedToken[tokenCurrency1] = _hTokenCurrency1;\n        wrappedToken[tokenCurrency2] = _hTokenCurrency2;\n        wrappedToken[tokenCurrency3] = _hTokenCurrency3;\n        addrSet = true;\n\n        emit AddressSet();\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceAdmin(address _newAdmin)\n        external\n        override\n        onlyAdmin\n        nonZero(_newAdmin)\n        noChange(admin, _newAdmin)\n    {\n        // Replace admin\n        admin = _newAdmin;\n\n        emit AdminReplaced(_newAdmin);\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceTreasury(address _newTreasury)\n        external\n        override\n        onlyAdmin\n        nonZero(_newTreasury)\n        noChange(treasury, _newTreasury)\n    {\n        // Replace treasury\n        treasury = _newTreasury;\n\n        emit TreasuryReplaced(_newTreasury);\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceLenderFee(uint256 _newLenderFee)\n        external\n        override\n        onlyAdmin\n    {\n        // Revert if no change in lender fee\n        require(lenderFee != _newLenderFee, \"HomeFi::!Change\");\n\n        // Reset variables\n        lenderFee = _newLenderFee;\n\n        emit LenderFeeReplaced(_newLenderFee);\n    }\n\n    /// @inheritdoc IHomeFi\n    function setTrustedForwarder(address _newForwarder)\n        external\n        override\n        onlyAdmin\n        noChange(trustedForwarder, _newForwarder)\n    {\n        trustedForwarder = _newForwarder;\n    }\n\n    /// @inheritdoc IHomeFi\n    function createProject(bytes memory _hash, address _currency)\n        external\n        override\n        nonReentrant\n    {\n        // Revert if currency not supported by HomeFi\n        validCurrency(_currency);\n\n        address _sender = _msgSender();\n\n        // Create a new project Clone and mint a new NFT for it\n        address _project = projectFactoryInstance.createProject(\n            _currency,\n            _sender\n        );\n        mintNFT(_sender, string(_hash));\n\n        // Update project related mappings\n        projects[projectCount] = _project;\n        projectTokenId[_project] = projectCount;\n\n        emit ProjectAdded(projectCount, _project, _sender, _currency, _hash);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    function isProjectExist(address _project)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return projectTokenId[_project] > 0;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    function validCurrency(address _currency) public view override {\n        // _currency must be one of HomeFi supported currencies\n        require(\n            _currency == tokenCurrency1 ||\n                _currency == tokenCurrency2 ||\n                _currency == tokenCurrency3,\n            \"HomeFi::!Currency\"\n        );\n    }\n\n    /// @inheritdoc IHomeFi\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IHomeFi)\n        returns (bool)\n    {\n        return trustedForwarder == _forwarder;\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n    /**\n     * @dev Makes an NFT for every project\n\n     * @param _to address - NFT owner. Initially it will be the project builder.\n     * @param _tokenURI string - IPFS hash of project details like name, description etc\n\n     * @return _tokenIds NFT Id of project\n     */\n    function mintNFT(address _to, string memory _tokenURI)\n        internal\n        returns (uint256)\n    {\n        // Project count starts from 1\n        projectCount += 1;\n\n        // Mints NFT and set token URI\n        _mint(_to, projectCount);\n        _setTokenURI(projectCount, _tokenURI);\n\n        emit NftCreated(projectCount, _to);\n        return projectCount;\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IDebtToken, IERC20Upgradeable} from \"./interfaces/IDebtToken.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/**\n * @title ERC20 for wrapping collateral currencies loaned to projects in HomeFi v2.5.0\n */\ncontract DebtToken is IDebtToken, ERC20Upgradeable {\n    /*******************************************************************************\n     * ---------------------FIXED INTERNAL STORED PROPERTIES---------------------- *\n     *******************************************************************************/\n\n    uint8 internal _decimals;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDebtToken\n    address public override communityContract;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier onlyCommunityContract() {\n        // Revert if caller is not community contract\n        require(\n            communityContract == _msgSender(),\n            \"DebtToken::!CommunityContract\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDebtToken\n    function initialize(\n        address _communityContract,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) external override initializer {\n        // Revert if _communityContract is zero address. Invalid address.\n        require(_communityContract != address(0), \"DebtToken::0 address\");\n\n        // Initialize ERC20\n        __ERC20_init(name_, symbol_);\n\n        // Store details\n        _decimals = decimals_;\n        communityContract = _communityContract;\n    }\n\n    /// @inheritdoc IDebtToken\n    function mint(address _to, uint256 _total)\n        external\n        override\n        onlyCommunityContract\n    {\n        _mint(_to, _total);\n    }\n\n    /// @inheritdoc IDebtToken\n    function burn(address _to, uint256 _total)\n        external\n        override\n        onlyCommunityContract\n    {\n        _burn(_to, _total);\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n\n    /*******************************************************************************\n     * ----------------------------PUBLIC TRANSACTIONS---------------------------- *\n     *******************************************************************************/\n\n    /// @notice blocked implementation\n    function transferFrom(\n        address, /* _sender */\n        address, /* _recipient */\n        uint256 /* _amount */\n    ) public pure override(ERC20Upgradeable, IERC20Upgradeable) returns (bool) {\n        revert(\"DebtToken::blocked\");\n    }\n\n    /// @notice blocked implementation\n    function transfer(\n        address, /* recipient */\n        uint256 /* amount */\n    ) public pure override(ERC20Upgradeable, IERC20Upgradeable) returns (bool) {\n        revert(\"DebtToken::blocked\");\n    }\n}\n\n\n",
        "CodeNames": [
            "Project.sol",
            "Disputes.sol",
            "ProjectFactory.sol",
            "HomeFiProxy.sol",
            "Community.sol",
            "HomeFi.sol",
            "DebtToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "HomeFiProxy.sol#L216-L230, Community.sol#L102-L119, DebtToken.sol#L43-L58, Disputes.sol#L74-L81, HomeFi.sol#L92-L120, Project.sol#L94-L105, ProjectFactory.sol#L45-L55",
                "Type": "Incorrect initialization of smart contracts with Access Control issue",
                "Description": "During deploy TransparentUpgradeableProxy's initialize method for initializing contracts not called. The third parameter responsible for this is an empty string. This causes the initialization process itself to be delayed. Contract initialization methods have no check over who calls them.",
                "Repair": "Carry out checks at the initialization stage or redesign the deployment process with the initialization of contracts during deployment"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDebtToken} from \"./interfaces/IDebtToken.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {Tasks, Task, TaskStatus} from \"./libraries/Tasks.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Deployable Project Contract for HomeFi v2.5.0\n\n * @notice contains the primary logic around construction project management. \n * Onboarding contractors, fund escrow, and completion tracking are all managed here. \n * Significant multi-signature and meta-transaction functionality is included here.\n\n * @dev This contract is created as a clone copy for the end user\n */\ncontract Project is\n    IProject,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using Tasks library for Task struct\n    using Tasks for Task;\n\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ------------------------FIXED INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @notice Disputes contract instance\n    address internal disputes;\n\n    /// @notice mapping of tasks index to Task struct.\n    mapping(uint256 => Task) internal tasks;\n\n    /// @notice array of indexes of change ordered tasks\n    uint256[] internal _changeOrderedTask;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    IHomeFi public override homeFi;\n    /// @inheritdoc IProject\n    IDebtToken public override currency;\n    /// @inheritdoc IProject\n    uint256 public override lenderFee;\n    /// @inheritdoc IProject\n    address public override builder;\n    /// @inheritdoc IProject\n    uint256 public constant override VERSION = 25000;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    address public override contractor;\n    /// @inheritdoc IProject\n    bool public override contractorConfirmed;\n    /// @inheritdoc IProject\n    uint256 public override hashChangeNonce;\n    /// @inheritdoc IProject\n    uint256 public override totalLent;\n    /// @inheritdoc IProject\n    uint256 public override totalAllocated;\n    /// @inheritdoc IProject\n    uint256 public override taskCount;\n    /// @inheritdoc IProject\n    bool public override contractorDelegated;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedTask;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedChangeOrderTask;\n    /// @inheritdoc IProject\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /// @dev Added to make sure master implementation cannot be initialized\n    // solhint-disable-next-line no-empty-blocks\n    constructor() initializer {}\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTION---------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    function initialize(\n        address _currency,\n        address _sender,\n        address _homeFiAddress\n    ) external override initializer {\n        // Initialize variables\n        homeFi = IHomeFi(_homeFiAddress);\n        disputes = homeFi.disputesContract();\n        lenderFee = homeFi.lenderFee();\n        builder = _sender;\n        currency = IDebtToken(_currency);\n    }\n\n    /// @inheritdoc IProject\n    function approveHash(bytes32 _hash) external override {\n        address _sender = _msgSender();\n        // Allowing anyone to sign, as its hard to add restrictions here.\n        // Store _hash as signed for sender.\n        approvedHashes[_sender][_hash] = true;\n\n        emit ApproveHash(_hash, _sender);\n    }\n\n    /// @inheritdoc IProject\n    function inviteContractor(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Revert if contractor has already confirmed his invitation\n        require(!contractorConfirmed, \"Project::GC accepted\");\n\n        // Decode params from _data\n        (address _contractor, address _projectAddress) = abi.decode(\n            _data,\n            (address, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if contractor address is invalid.\n        require(_contractor != address(0), \"Project::0 address\");\n\n        // Store new contractor\n        contractor = _contractor;\n        contractorConfirmed = true;\n\n        // Check signature for builder and contractor\n        checkSignature(_data, _signature);\n\n        emit ContractorInvited(contractor);\n    }\n\n    /// @inheritdoc IProject\n    function delegateContractor(bool _bool) external override {\n        // Revert if sender is not builder\n        require(_msgSender() == builder, \"Project::!B\");\n\n        // Revert if contract not assigned\n        require(contractor != address(0), \"Project::0 address\");\n\n        // Store new bool for contractorDelegated\n        contractorDelegated = _bool;\n\n        emit ContractorDelegated(_bool);\n    }\n\n    /// @inheritdoc IProject\n    function updateProjectHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Check for required signatures\n        checkSignature(_data, _signature);\n\n        // Decode params from _data\n        (bytes memory _hash, uint256 _nonce) = abi.decode(\n            _data,\n            (bytes, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit HashUpdated(_hash);\n    }\n\n    /// @inheritdoc IProject\n    function lendToProject(uint256 _cost) external override nonReentrant {\n        address _sender = _msgSender();\n\n        // Revert if sender is not builder or Community Contract (lender)\n        require(\n            _sender == builder || _sender == homeFi.communityContract(),\n            \"Project::!Builder&&!Community\"\n        );\n\n        // Revert if try to lend 0\n        require(_cost > 0, \"Project::!value>0\");\n\n        // Revert if try to lend more than project cost\n        uint256 _newTotalLent = totalLent + _cost;\n        require(\n            projectCost() >= uint256(_newTotalLent),\n            \"Project::value>required\"\n        );\n\n        if (_sender == builder) {\n            // Transfer assets from builder to this contract\n            currency.safeTransferFrom(_sender, address(this), _cost);\n        }\n\n        // Update total lent with added lend\n        totalLent = _newTotalLent;\n\n        emit LendToProject(_cost);\n\n        // Allocate funds to tasks and mark then as allocated\n        allocateFunds();\n    }\n\n    /// @inheritdoc IProject\n    function addTasks(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures\n            checkSignature(_data, _signature);\n        }\n\n        // Decode params from _data\n        (\n            bytes[] memory _hash,\n            uint256[] memory _taskCosts,\n            uint256 _taskCount,\n            address _projectAddress\n        ) = abi.decode(_data, (bytes[], uint256[], uint256, address));\n\n        // Revert if decoded taskCount is incorrect. This indicates wrong data.\n        require(_taskCount == taskCount, \"Project::!taskCount\");\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if IPFS hash array length is not equal to task cost array length.\n        uint256 _length = _hash.length;\n        require(_length == _taskCosts.length, \"Project::Lengths !match\");\n\n        // Loop over all the new tasks.\n        for (uint256 i = 0; i < _length; i++) {\n            // Increment local task counter.\n            _taskCount += 1;\n\n            // Check task cost precision. Revert if too precise.\n            checkPrecision(_taskCosts[i]);\n\n            // Initialize task.\n            tasks[_taskCount].initialize(_taskCosts[i]);\n        }\n\n        // Update task counter equal to local task counter.\n        taskCount = _taskCount;\n\n        emit TasksAdded(_taskCosts, _hash);\n    }\n\n    /// @inheritdoc IProject\n    function updateTaskHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (bytes memory _taskHash, uint256 _nonce, uint256 _taskID) = abi.decode(\n            _data,\n            (bytes, uint256, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // If subcontractor has confirmed then check signature using `checkSignatureTask`.\n        // Else check signature using `checkSignature`.\n        if (getAlerts(_taskID)[2]) {\n            // If subcontractor has confirmed.\n            checkSignatureTask(_data, _signature, _taskID);\n        } else {\n            // If subcontractor not has confirmed.\n            checkSignature(_data, _signature);\n        }\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit TaskHashUpdated(_taskID, _taskHash);\n    }\n\n    /// @inheritdoc IProject\n    function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)\n        external\n        override\n    {\n        // Revert if sender is neither builder nor contractor.\n        require(\n            _msgSender() == builder || _msgSender() == contractor,\n            \"Project::!Builder||!GC\"\n        );\n\n        // Revert if taskList array length not equal to scList array length.\n        uint256 _length = _taskList.length;\n        require(_length == _scList.length, \"Project::Lengths !match\");\n\n        // Invite subcontractor for each task.\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n\n        emit MultipleSCInvited(_taskList, _scList);\n    }\n\n    /// @inheritdoc IProject\n    function acceptInviteSC(uint256[] calldata _taskList) external override {\n        // Accept invitation for each task in taskList.\n        uint256 _length = _taskList.length;\n        for (uint256 i = 0; i < _length; i++) {\n            tasks[_taskList[i]].acceptInvitation(_msgSender());\n        }\n\n        emit SCConfirmed(_taskList);\n    }\n\n    /// @inheritdoc IProject\n    function setComplete(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (uint256 _taskID, address _projectAddress) = abi.decode(\n            _data,\n            (uint256, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!Project\");\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Mark task as complete. Only works when task is active.\n        tasks[_taskID].setComplete();\n\n        // Transfer funds to subcontractor.\n        currency.safeTransfer(\n            tasks[_taskID].subcontractor,\n            tasks[_taskID].cost\n        );\n\n        emit TaskComplete(_taskID);\n    }\n\n    /// @inheritdoc IProject\n    function recoverTokens(address _tokenAddress) external override {\n        /* If the token address is same as currency of this project,\n            then first check if all tasks are complete */\n        if (_tokenAddress == address(currency)) {\n            // Iterate for each task and check if it is complete.\n            uint256 _length = taskCount;\n            for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n                require(tasks[_taskID].getState() == 3, \"Project::!Complete\");\n            }\n        }\n\n        // Create token instance.\n        IDebtToken _token = IDebtToken(_tokenAddress);\n\n        // Check the balance of _token in this contract.\n        uint256 _leftOutTokens = _token.balanceOf(address(this));\n\n        // If balance is present then it to the builder.\n        if (_leftOutTokens > 0) {\n            _token.safeTransfer(builder, _leftOutTokens);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function changeOrder(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        nonReentrant\n    {\n        // Decode params from _data\n        (\n            uint256 _taskID,\n            address _newSC,\n            uint256 _newCost,\n            address _project\n        ) = abi.decode(_data, (uint256, address, uint256, address));\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        // Local variable for task cost. For gas saving.\n        uint256 _taskCost = tasks[_taskID].cost;\n\n        // Local variable indicating if subcontractor is already unapproved.\n        bool _unapproved = false;\n\n        // If task cost is to be changed.\n        if (_newCost != _taskCost) {\n            // Check new task cost precision. Revert if too precise.\n            checkPrecision(_newCost);\n\n            // Local variable for total cost allocated. For gas saving.\n            uint256 _totalAllocated = totalAllocated;\n\n            // If tasks are already allocated with old cost.\n            if (tasks[_taskID].alerts[1]) {\n                // If new task cost is less than old task cost.\n                if (_newCost < _taskCost) {\n                    // Find the difference between old - new.\n                    uint256 _withdrawDifference = _taskCost - _newCost;\n\n                    // Reduce this difference from total cost allocated.\n                    // As the same task is now allocated with lesser cost.\n                    totalAllocated -= _withdrawDifference;\n\n                    // Withdraw the difference back to builder's account.\n                    // As this additional amount may not be required by the project.\n                    autoWithdraw(_withdrawDifference);\n                }\n                // If new cost is more than task cost but total lent is enough to cover for it.\n                else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n                    // Increase the difference of new cost and old cost to total allocated.\n                    totalAllocated += _newCost - _taskCost;\n                }\n                // If new cost is more than task cost and totalLent is not enough.\n                else {\n                    // Un-confirm SC, mark task as inactive, mark allocated as false, mark lifecycle as None\n\n                    // Mark task as inactive by unapproving subcontractor.\n                    // As subcontractor can only be approved if task is allocated\n                    _unapproved = true;\n                    tasks[_taskID].unApprove();\n\n                    // Mark task as not allocated.\n                    tasks[_taskID].unAllocateFunds();\n\n                    // Reduce total allocation by old task cost.\n                    // As as needs to go though funding process again.\n                    totalAllocated -= _taskCost;\n\n                    // Add this task to _changeOrderedTask array. These tasks will be allocated first.\n                    _changeOrderedTask.push(_taskID);\n                }\n            }\n\n            // Store new cost for the task\n            tasks[_taskID].cost = _newCost;\n\n            emit ChangeOrderFee(_taskID, _newCost);\n        }\n\n        // If task subcontractor is to be changed.\n        if (_newSC != tasks[_taskID].subcontractor) {\n            // If task is not already unapproved, then un-approve it.\n            // Un-approving task means marking subcontractor as unconfirmed.\n            if (!_unapproved) {\n                tasks[_taskID].unApprove();\n            }\n\n            // If new subcontractor is not zero address.\n            if (_newSC != address(0)) {\n                // Invite the new subcontractor for the task.\n                _inviteSC(_taskID, _newSC, true);\n            }\n            // Else store zero address for the task subcontractor.\n            // This implies that a subcontractor is not invited from the task.\n            else {\n                tasks[_taskID].subcontractor = address(0);\n            }\n\n            emit ChangeOrderSC(_taskID, _newSC);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Recover the signer from the signature\n        address signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (address _project, uint256 _task, , , ) = abi.decode(\n            _data,\n            (address, uint256, uint8, bytes, bytes)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        if (_task == 0) {\n            // Revet if sender is not builder or contractor\n            require(\n                signer == builder || signer == contractor,\n                \"Project::!(GC||Builder)\"\n            );\n        } else {\n            // Revet if sender is not builder, contractor or task's subcontractor\n            require(\n                signer == builder ||\n                    signer == contractor ||\n                    signer == tasks[_task].subcontractor,\n                \"Project::!(GC||Builder||SC)\"\n            );\n\n            if (signer == tasks[_task].subcontractor) {\n                // If sender is task's subcontractor, revert if invitation is not accepted.\n                require(getAlerts(_task)[2], \"Project::!SCConfirmed\");\n            }\n        }\n\n        // Make a call to Disputes contract raiseDisputes.\n        IDisputes(disputes).raiseDispute(_data, _signature);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function getTask(uint256 id)\n        external\n        view\n        override\n        returns (\n            uint256 cost,\n            address subcontractor,\n            TaskStatus state\n        )\n    {\n        cost = tasks[id].cost;\n        subcontractor = tasks[id].subcontractor;\n        state = tasks[id].state;\n    }\n\n    /// @inheritdoc IProject\n    function changeOrderedTask()\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _changeOrderedTask;\n    }\n\n    /*******************************************************************************\n     * ----------------------------PUBLIC TRANSACTIONS---------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function allocateFunds() public override {\n        // Max amount out times this loop will run\n        // This is to ensure the transaction do not run out of gas (max gas limit)\n        uint256 _maxLoop = 50;\n\n        // Difference of totalLent and totalAllocated is what can be used to allocate new tasks\n        uint256 _costToAllocate = totalLent - totalAllocated;\n\n        // Bool if max loop limit is exceeded\n        bool _exceedLimit;\n\n        // Local instance of lastAllocatedChangeOrderTask. To save gas.\n        uint256 i = lastAllocatedChangeOrderTask;\n\n        // Local instance of lastAllocatedTask. To save gas.\n        uint256 j = lastAllocatedTask;\n\n        // Initialize empty array in which allocated tasks will be added.\n        uint256[] memory _tasksAllocated = new uint256[](\n            taskCount - j + _changeOrderedTask.length - i\n        );\n\n        // Number of times a loop has run.\n        uint256 _loopCount;\n\n        /// CHANGE ORDERED TASK FUNDING ///\n\n        // Any tasks added to _changeOrderedTask will be allocated first\n        if (_changeOrderedTask.length > 0) {\n            // Loop from lastAllocatedChangeOrderTask to _changeOrderedTask length (until _maxLoop)\n            for (; i < _changeOrderedTask.length; i++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[_changeOrderedTask[i]].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[_changeOrderedTask[i]].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = _changeOrderedTask[i];\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all the change ordered tasks are allocated, then delete\n            // the changeOrderedTask array and reset lastAllocatedChangeOrderTask.\n            if (i == _changeOrderedTask.length) {\n                lastAllocatedChangeOrderTask = 0;\n                delete _changeOrderedTask;\n            }\n            // Else store the last allocated change order task index.\n            else {\n                lastAllocatedChangeOrderTask = i;\n            }\n        }\n\n        /// TASK FUNDING ///\n\n        // If lastAllocatedTask is lesser than taskCount, that means there are un-allocated tasks\n        if (j < taskCount) {\n            // Loop from lastAllocatedTask + 1 to taskCount (until _maxLoop)\n            for (++j; j <= taskCount; j++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[j].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[j].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = j;\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all pending tasks are allocated store lastAllocatedTask equal to taskCount\n            if (j > taskCount) {\n                lastAllocatedTask = taskCount;\n            }\n            // If not all tasks are allocated store updated lastAllocatedTask\n            else {\n                lastAllocatedTask = --j;\n            }\n        }\n\n        // If any tasks is allocated, then emit event\n        if (_loopCount > 0) emit TaskAllocated(_tasksAllocated);\n\n        // If allocation was incomplete, then emit event\n        if (_exceedLimit) emit IncompleteAllocation();\n\n        // Update totalAllocated with all allocations\n        totalAllocated = totalLent - _costToAllocate;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function projectCost() public view override returns (uint256 _cost) {\n        // Local instance of taskCount. To save gas.\n        uint256 _length = taskCount;\n\n        // Iterate over all tasks to sum their cost\n        for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n            _cost += tasks[_taskID].cost;\n        }\n    }\n\n    /// @inheritdoc IProject\n    function getAlerts(uint256 _taskID)\n        public\n        view\n        override\n        returns (bool[3] memory _alerts)\n    {\n        return tasks[_taskID].getAlerts();\n    }\n\n    /// @inheritdoc IProject\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IProject)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Invite subcontractors for a single task. This can be called by builder or contractor.\n     * _taskList must not have a task which already has approved subcontractor.\n     \n     * @param _taskID uint256 task index\n     * @param _sc address addresses of subcontractor for the respective task\n     * @param _emitEvent whether to emit event for each sc added or not\n     */\n    function _inviteSC(\n        uint256 _taskID,\n        address _sc,\n        bool _emitEvent\n    ) internal {\n        // Revert if sc to invite is address 0\n        require(_sc != address(0), \"Project::0 address\");\n\n        // Internal call to tasks invite contractor\n        tasks[_taskID].inviteSubcontractor(_sc);\n\n        // If `_emitEvent` is true (called via changeOrder) then emit event\n        if (_emitEvent) {\n            emit SingleSCInvited(_taskID, _sc);\n        }\n    }\n\n    /**\n     * @dev Transfer excess funds back to builder wallet.\n     * Called internally in task changeOrder when new task cost is lower than older cost.\n\n     * @param _amount uint256 - amount of excess funds\n     */\n    function autoWithdraw(uint256 _amount) internal {\n        // Reduce amount from totalLent\n        totalLent -= _amount;\n\n        // Transfer amount to builder address\n        currency.safeTransfer(builder, _amount);\n\n        emit AutoWithdrawn(_amount);\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder and contractor address.\n     * Signatures must be in sequential order. First builder and then contractor.\n     * Reverts if signature do not match.\n     * If contractor is not assigned then only checks for builder signature.\n     * If contractor is assigned but not delegated then only checks for builder and contractor signature.\n     * If contractor is assigned and delegated then only checks for contractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     */\n    function checkSignature(bytes calldata _data, bytes calldata _signature)\n        internal\n    {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Check for builder's signature\n            checkSignatureValidity(builder, _hash, _signature, 0);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                //  Check contractor's signature\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for both B and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n            }\n        }\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder, contractor and subcontractor address for a task.\n     * Signatures must be in sequential order. First builder, then contractor, and then subcontractor.\n     * reverts if signatures do not match.\n     * If contractor is not assigned then only checks for builder and subcontractor signature.\n     * If contractor is assigned but not delegated then only checks for builder, contractor and subcontractor signature.\n     * If contractor is assigned and delegated then only checks for contractor and subcontractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     * @param _taskID index of the task.\n     */\n    function checkSignatureTask(\n        bytes calldata _data,\n        bytes calldata _signature,\n        uint256 _taskID\n    ) internal {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of subcontractor. To save gas.\n        address _sc = tasks[_taskID].subcontractor;\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Just check for B and SC sign\n            checkSignatureValidity(builder, _hash, _signature, 0);\n            checkSignatureValidity(_sc, _hash, _signature, 1);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                // Check for GC and SC sign\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n                checkSignatureValidity(_sc, _hash, _signature, 1);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for B, SC and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n                checkSignatureValidity(_sc, _hash, _signature, 2);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev Checks if the signature is approved or recovered\n     * @dev Reverts if not\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal {\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Project::invalid signature\"\n        );\n        // delete from approvedHash\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * -------------------------------INTERNAL PURE------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Check if precision is greater than 1000, if so, it reverts\n\n     * @param _amount amount needed to be checked for precision.\n     */\n    function checkPrecision(uint256 _amount) internal pure {\n        // Divide and multiply amount with 1000 should be equal to amount.\n        // This ensures the amount is not too precise.\n        require(\n            ((_amount / 1000) * 1000) == _amount,\n            \"Project::Precision>=1000\"\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "Project.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Project.sol#L770, addTasks, changeOrder",
                "Type": "Task Functionality completely sidestepped via autoWithdraw",
                "Description": "autoWithdraw will send funds to the builder, we can use this knowledge to drain all funds from Project to the builder contract. Completely sidestepping the whole Task based logic.",
                "Repair": "Consider removing autoWithdraw (keep funds inside of project), create a separate multi-sig like way to withdraw or keep a split between funds sent by Builder and by Community, and make autoWithdraw send the funds back accordingly"
            },
            {
                "Location": "[Project.sol#L219, Project.sol#L655, Project.sol#L807]",
                "Type": "Malicious delegated contractor can block funding tasks or mark tasks as complete",
                "Description": "A malicious delegated contractor can add a huge number of tasks (or one task with a huge cost). This would then pose problems in allocateFunds() as tasks could not be funded.",
                "Repair": "Create a function to update lastAllocatedTask. Add functionality for Disputes contract to be able to remove or replace the contractor."
            },
            {
                "Location": "[Project.sol#L402, Project.sol#L485]",
                "Type": "changeOrder requires subcontractor signature when the subcontractor address is 0",
                "Description": "Via changeOrder, it is possible to set the subcontractor address to 0 (and it is zero when no one is invited). However, when it is updated later again, a signature of the 'current subcontractor' (in this case address(0)) is still required.",
                "Repair": "Check if the subcontractor address is zero, do not require a valid signature in such cases."
            },
            {
                "Location": "[Community.sol#L501-L506, Project.sol#L108-L115]",
                "Type": "Project.sol and Community.sol have no way to revoke a hash in approvedHashes",
                "Description": "User is unable to revoke previously approved hash.",
                "Repair": "Add a function to revoke previously approved hash."
            },
            {
                "Location": "Project.sol#L859",
                "Type": "Hash approval issue",
                "Description": "When a contractor is also a subcontractor, it is not possible to use the hash approval feature for checkSignatureTask.",
                "Repair": "Delete the approval only when all checks are done."
            },
            {
                "Location": "Project.sol#L238",
                "Type": "Task count issue",
                "Description": "Project.addTasks() wouldn't work properly when it's called from disputes contract.",
                "Repair": "Modify not to compare taskCount when it's called from disputes contract."
            },
            {
                "Location": "Project.sol#L402",
                "Type": "Task change issue",
                "Description": "Project.changeOrder() would work unexpectedly for non SCConfirmed tasks.",
                "Repair": "Check separately in case the subcontractor is confirmed or not."
            },
            {
                "Location": "Project.sol#L887, Project.sol#L108-L115",
                "Type": "Signature Checks could be passed when SignatureDecoder.recoverKey() returns 0",
                "Description": "It is possible to pass Signature Validity check with an SignatureDecoder.recoverKey() returns 0 whenever the builder and /or contractor have an existing approved hash for a data.",
                "Repair": "Add a require check for _recoveredSignature != 0 in checkSignatureValidity()"
            },
            {
                "Location": "lendToProject() and toggleLendingNeeded() functions in Project.sol",
                "Type": "Possible DOS",
                "Description": "Unbounded loop can run out of gas in lendToProject() and toggleLendingNeeded() functions because projectCost() function did not have a mechanism to stop, only based on the taskCount.",
                "Repair": "Keep value of projectCost() in a storage variable and update it when a task is added or updated accordingly"
            },
            {
                "Location": "Project.setComplete()",
                "Type": "reused signature",
                "Description": "The signature can be reused when the first call is reverted for some reason, allowing a task to be completed when a builder doesn't want it.",
                "Repair": "Add an option to cancel the approved hash in approveHash() function"
            },
            {
                "Location": "Project.inviteSC()",
                "Type": "subcontractor change without consent",
                "Description": "A new subcontractor can be set for a SCConfirmed task without current subcontractor consent, allowing a malicious builder/contractor to steal the task budget from the subcontractor who did the job.",
                "Repair": "Call checkSignatureTask() when getAlerts(_taskID)[2] is true"
            },
            {
                "Location": "Project.sol#L443-L460",
                "Type": "Unauthorized Subcontractor Change",
                "Description": "A new subcontractor can be set for a SCConfirmed task without current subcontractor consent, allowing a dishonest contractor to call inviteSC with own subcontractor, who will receive full old_cost / 0.95 on completion.",
                "Repair": "Deactivate task only instead of fully resetting it in changeOrder() or Introduce deActivate instead of unConfirm or Introduce onlyUnconfirmed modifier and set it to the inviteSubcontractor() and acceptInvitation()"
            },
            {
                "Location": "Project.sol#L493-L536",
                "Type": "Inability to raise dispute using contracts",
                "Description": "In case users are using a contract (like a multisig wallet) to interact with a project, they can't raise a dispute. The sponsors have added the approveHash() function to support users who wish to use contracts as builder/GC/SC. However, the Project.raiseDispute() function doesn't check them, meaning if any of those users wish to raise a dispute they can't do it.",
                "Repair": "Make raiseDispute() function check for approvedHashes"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\n/*******************************************************************************\n * ----------------------------------STRUCTS---------------------------------- *\n *******************************************************************************/\n\n// Task metadata\nstruct Task {\n    // Metadata //\n    uint256 cost; // Cost of task\n    address subcontractor; // Subcontractor of task\n    // Lifecycle //\n    TaskStatus state; // Status of task\n    mapping(uint256 => bool) alerts; // Alerts of task\n}\n\n/*******************************************************************************\n * -----------------------------------ENUMS----------------------------------- *\n *******************************************************************************/\n\nenum TaskStatus {\n    None,\n    Inactive,\n    Active,\n    Complete\n}\n\nenum Lifecycle {\n    None,\n    TaskAllocated,\n    SCConfirmed\n}\n\n/**\n * @title Tasks Library for HomeFi v2.5.0\n\n * @notice Internal library used in Project. Contains functions specific to a task actions and lifecycle.\n */\nlibrary Tasks {\n    /// @dev only allow inactive tasks. Task is inactive if SC is unconfirmed.\n    modifier onlyInactive(Task storage _self) {\n        require(_self.state == TaskStatus.Inactive, \"Task::active\");\n        _;\n    }\n\n    /// @dev only allow active tasks. Task is inactive if SC is confirmed.\n    modifier onlyActive(Task storage _self) {\n        require(_self.state == TaskStatus.Active, \"Task::!Active\");\n        _;\n    }\n\n    /// @dev only allow funded tasks.\n    modifier onlyFunded(Task storage _self) {\n        require(\n            _self.alerts[uint256(Lifecycle.TaskAllocated)],\n            \"Task::!funded\"\n        );\n        _;\n    }\n\n    /// MUTABLE FUNCTIONS ///\n\n    // Task Status Changing Functions //\n\n    /**\n     * @notice Create a new Task object\n\n     * @dev cannot operate on initialized tasks\n\n     * @param _self Task the task struct being mutated\n     * @param _cost uint the number of tokens to be escrowed in this contract\n     */\n    function initialize(Task storage _self, uint256 _cost) public {\n        _self.cost = _cost;\n        _self.state = TaskStatus.Inactive;\n        _self.alerts[uint256(Lifecycle.None)] = true;\n    }\n\n    /**\n     * @notice Attempt to transition task state from Payment Pending to Complete\n\n     * @dev modifier onlyActive\n\n     * @param _self Task the task whose state is being mutated\n     */\n    function setComplete(Task storage _self)\n        internal\n        onlyActive(_self)\n        onlyFunded(_self)\n    {\n        // State/ Lifecycle //\n        _self.state = TaskStatus.Complete;\n    }\n\n    // Subcontractor Joining //\n\n    /**\n     * @dev Invite a subcontractor to the task\n     * @dev modifier onlyInactive\n\n     * @param _self Task the task being joined by subcontractor\n     * @param _sc address the subcontractor being invited\n     */\n    function inviteSubcontractor(Task storage _self, address _sc)\n        internal\n        onlyInactive(_self)\n    {\n        _self.subcontractor = _sc;\n    }\n\n    /**\n     * @dev As a subcontractor, accept an invitation to participate in a task.\n     * @dev modifier onlyInactive\n     * @param _self Task the task being joined by subcontractor\n     * @param _sc Address of sender\n     */\n    function acceptInvitation(Task storage _self, address _sc)\n        internal\n        onlyInactive(_self)\n    {\n        // Prerequisites //\n        require(_self.subcontractor == _sc, \"Task::!SC\");\n\n        // State/ lifecycle //\n        _self.alerts[uint256(Lifecycle.SCConfirmed)] = true;\n        _self.state = TaskStatus.Active;\n    }\n\n    // Task Funding //\n\n    /**\n     * @dev Set a task as funded\n\n     * @param _self Task the task being set as funded\n     */\n    function fundTask(Task storage _self) internal {\n        // State/ Lifecycle //\n        _self.alerts[uint256(Lifecycle.TaskAllocated)] = true;\n    }\n\n    /**\n     * @dev Set a task as un-funded\n\n     * @param _self Task the task being set as funded\n     */\n    function unAllocateFunds(Task storage _self) internal {\n        // State/ lifecycle //\n        _self.alerts[uint256(Lifecycle.TaskAllocated)] = false;\n    }\n\n    /**\n     * @dev Set a task as un accepted/approved for SC\n\n     * @dev modifier onlyActive\n\n     * @param _self Task the task being set as funded\n     */\n    function unApprove(Task storage _self) internal {\n        // State/ lifecycle //\n        _self.alerts[uint256(Lifecycle.SCConfirmed)] = false;\n        _self.state = TaskStatus.Inactive;\n    }\n\n    /// VIEWABLE FUNCTIONS ///\n\n    /**\n     * @dev Determine the current state of all alerts in the project\n\n     * @param _self Task the task being queried for alert status\n\n     * @return _alerts bool[3] array of bool representing whether Lifecycle alert has been reached\n     */\n    function getAlerts(Task storage _self)\n        internal\n        view\n        returns (bool[3] memory _alerts)\n    {\n        uint256 _length = _alerts.length;\n        for (uint256 i = 0; i < _length; i++) _alerts[i] = _self.alerts[i];\n    }\n\n    /**\n     * @dev Return the numerical encoding of the TaskStatus enumeration stored as state in a task\n\n     * @param _self Task the task being queried for state\n     \n     * @return _state uint 0: none, 1: inactive, 2: active, 3: complete\n     */\n    function getState(Task storage _self)\n        internal\n        view\n        returns (uint256 _state)\n    {\n        return uint256(_self.state);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDebtToken} from \"./interfaces/IDebtToken.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {Tasks, Task, TaskStatus} from \"./libraries/Tasks.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Deployable Project Contract for HomeFi v2.5.0\n\n * @notice contains the primary logic around construction project management. \n * Onboarding contractors, fund escrow, and completion tracking are all managed here. \n * Significant multi-signature and meta-transaction functionality is included here.\n\n * @dev This contract is created as a clone copy for the end user\n */\ncontract Project is\n    IProject,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using Tasks library for Task struct\n    using Tasks for Task;\n\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ------------------------FIXED INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @notice Disputes contract instance\n    address internal disputes;\n\n    /// @notice mapping of tasks index to Task struct.\n    mapping(uint256 => Task) internal tasks;\n\n    /// @notice array of indexes of change ordered tasks\n    uint256[] internal _changeOrderedTask;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    IHomeFi public override homeFi;\n    /// @inheritdoc IProject\n    IDebtToken public override currency;\n    /// @inheritdoc IProject\n    uint256 public override lenderFee;\n    /// @inheritdoc IProject\n    address public override builder;\n    /// @inheritdoc IProject\n    uint256 public constant override VERSION = 25000;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    address public override contractor;\n    /// @inheritdoc IProject\n    bool public override contractorConfirmed;\n    /// @inheritdoc IProject\n    uint256 public override hashChangeNonce;\n    /// @inheritdoc IProject\n    uint256 public override totalLent;\n    /// @inheritdoc IProject\n    uint256 public override totalAllocated;\n    /// @inheritdoc IProject\n    uint256 public override taskCount;\n    /// @inheritdoc IProject\n    bool public override contractorDelegated;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedTask;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedChangeOrderTask;\n    /// @inheritdoc IProject\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /// @dev Added to make sure master implementation cannot be initialized\n    // solhint-disable-next-line no-empty-blocks\n    constructor() initializer {}\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTION---------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    function initialize(\n        address _currency,\n        address _sender,\n        address _homeFiAddress\n    ) external override initializer {\n        // Initialize variables\n        homeFi = IHomeFi(_homeFiAddress);\n        disputes = homeFi.disputesContract();\n        lenderFee = homeFi.lenderFee();\n        builder = _sender;\n        currency = IDebtToken(_currency);\n    }\n\n    /// @inheritdoc IProject\n    function approveHash(bytes32 _hash) external override {\n        address _sender = _msgSender();\n        // Allowing anyone to sign, as its hard to add restrictions here.\n        // Store _hash as signed for sender.\n        approvedHashes[_sender][_hash] = true;\n\n        emit ApproveHash(_hash, _sender);\n    }\n\n    /// @inheritdoc IProject\n    function inviteContractor(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Revert if contractor has already confirmed his invitation\n        require(!contractorConfirmed, \"Project::GC accepted\");\n\n        // Decode params from _data\n        (address _contractor, address _projectAddress) = abi.decode(\n            _data,\n            (address, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if contractor address is invalid.\n        require(_contractor != address(0), \"Project::0 address\");\n\n        // Store new contractor\n        contractor = _contractor;\n        contractorConfirmed = true;\n\n        // Check signature for builder and contractor\n        checkSignature(_data, _signature);\n\n        emit ContractorInvited(contractor);\n    }\n\n    /// @inheritdoc IProject\n    function delegateContractor(bool _bool) external override {\n        // Revert if sender is not builder\n        require(_msgSender() == builder, \"Project::!B\");\n\n        // Revert if contract not assigned\n        require(contractor != address(0), \"Project::0 address\");\n\n        // Store new bool for contractorDelegated\n        contractorDelegated = _bool;\n\n        emit ContractorDelegated(_bool);\n    }\n\n    /// @inheritdoc IProject\n    function updateProjectHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Check for required signatures\n        checkSignature(_data, _signature);\n\n        // Decode params from _data\n        (bytes memory _hash, uint256 _nonce) = abi.decode(\n            _data,\n            (bytes, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit HashUpdated(_hash);\n    }\n\n    /// @inheritdoc IProject\n    function lendToProject(uint256 _cost) external override nonReentrant {\n        address _sender = _msgSender();\n\n        // Revert if sender is not builder or Community Contract (lender)\n        require(\n            _sender == builder || _sender == homeFi.communityContract(),\n            \"Project::!Builder&&!Community\"\n        );\n\n        // Revert if try to lend 0\n        require(_cost > 0, \"Project::!value>0\");\n\n        // Revert if try to lend more than project cost\n        uint256 _newTotalLent = totalLent + _cost;\n        require(\n            projectCost() >= uint256(_newTotalLent),\n            \"Project::value>required\"\n        );\n\n        if (_sender == builder) {\n            // Transfer assets from builder to this contract\n            currency.safeTransferFrom(_sender, address(this), _cost);\n        }\n\n        // Update total lent with added lend\n        totalLent = _newTotalLent;\n\n        emit LendToProject(_cost);\n\n        // Allocate funds to tasks and mark then as allocated\n        allocateFunds();\n    }\n\n    /// @inheritdoc IProject\n    function addTasks(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures\n            checkSignature(_data, _signature);\n        }\n\n        // Decode params from _data\n        (\n            bytes[] memory _hash,\n            uint256[] memory _taskCosts,\n            uint256 _taskCount,\n            address _projectAddress\n        ) = abi.decode(_data, (bytes[], uint256[], uint256, address));\n\n        // Revert if decoded taskCount is incorrect. This indicates wrong data.\n        require(_taskCount == taskCount, \"Project::!taskCount\");\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if IPFS hash array length is not equal to task cost array length.\n        uint256 _length = _hash.length;\n        require(_length == _taskCosts.length, \"Project::Lengths !match\");\n\n        // Loop over all the new tasks.\n        for (uint256 i = 0; i < _length; i++) {\n            // Increment local task counter.\n            _taskCount += 1;\n\n            // Check task cost precision. Revert if too precise.\n            checkPrecision(_taskCosts[i]);\n\n            // Initialize task.\n            tasks[_taskCount].initialize(_taskCosts[i]);\n        }\n\n        // Update task counter equal to local task counter.\n        taskCount = _taskCount;\n\n        emit TasksAdded(_taskCosts, _hash);\n    }\n\n    /// @inheritdoc IProject\n    function updateTaskHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (bytes memory _taskHash, uint256 _nonce, uint256 _taskID) = abi.decode(\n            _data,\n            (bytes, uint256, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // If subcontractor has confirmed then check signature using `checkSignatureTask`.\n        // Else check signature using `checkSignature`.\n        if (getAlerts(_taskID)[2]) {\n            // If subcontractor has confirmed.\n            checkSignatureTask(_data, _signature, _taskID);\n        } else {\n            // If subcontractor not has confirmed.\n            checkSignature(_data, _signature);\n        }\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit TaskHashUpdated(_taskID, _taskHash);\n    }\n\n    /// @inheritdoc IProject\n    function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)\n        external\n        override\n    {\n        // Revert if sender is neither builder nor contractor.\n        require(\n            _msgSender() == builder || _msgSender() == contractor,\n            \"Project::!Builder||!GC\"\n        );\n\n        // Revert if taskList array length not equal to scList array length.\n        uint256 _length = _taskList.length;\n        require(_length == _scList.length, \"Project::Lengths !match\");\n\n        // Invite subcontractor for each task.\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n\n        emit MultipleSCInvited(_taskList, _scList);\n    }\n\n    /// @inheritdoc IProject\n    function acceptInviteSC(uint256[] calldata _taskList) external override {\n        // Accept invitation for each task in taskList.\n        uint256 _length = _taskList.length;\n        for (uint256 i = 0; i < _length; i++) {\n            tasks[_taskList[i]].acceptInvitation(_msgSender());\n        }\n\n        emit SCConfirmed(_taskList);\n    }\n\n    /// @inheritdoc IProject\n    function setComplete(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (uint256 _taskID, address _projectAddress) = abi.decode(\n            _data,\n            (uint256, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!Project\");\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Mark task as complete. Only works when task is active.\n        tasks[_taskID].setComplete();\n\n        // Transfer funds to subcontractor.\n        currency.safeTransfer(\n            tasks[_taskID].subcontractor,\n            tasks[_taskID].cost\n        );\n\n        emit TaskComplete(_taskID);\n    }\n\n    /// @inheritdoc IProject\n    function recoverTokens(address _tokenAddress) external override {\n        /* If the token address is same as currency of this project,\n            then first check if all tasks are complete */\n        if (_tokenAddress == address(currency)) {\n            // Iterate for each task and check if it is complete.\n            uint256 _length = taskCount;\n            for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n                require(tasks[_taskID].getState() == 3, \"Project::!Complete\");\n            }\n        }\n\n        // Create token instance.\n        IDebtToken _token = IDebtToken(_tokenAddress);\n\n        // Check the balance of _token in this contract.\n        uint256 _leftOutTokens = _token.balanceOf(address(this));\n\n        // If balance is present then it to the builder.\n        if (_leftOutTokens > 0) {\n            _token.safeTransfer(builder, _leftOutTokens);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function changeOrder(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        nonReentrant\n    {\n        // Decode params from _data\n        (\n            uint256 _taskID,\n            address _newSC,\n            uint256 _newCost,\n            address _project\n        ) = abi.decode(_data, (uint256, address, uint256, address));\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        // Local variable for task cost. For gas saving.\n        uint256 _taskCost = tasks[_taskID].cost;\n\n        // Local variable indicating if subcontractor is already unapproved.\n        bool _unapproved = false;\n\n        // If task cost is to be changed.\n        if (_newCost != _taskCost) {\n            // Check new task cost precision. Revert if too precise.\n            checkPrecision(_newCost);\n\n            // Local variable for total cost allocated. For gas saving.\n            uint256 _totalAllocated = totalAllocated;\n\n            // If tasks are already allocated with old cost.\n            if (tasks[_taskID].alerts[1]) {\n                // If new task cost is less than old task cost.\n                if (_newCost < _taskCost) {\n                    // Find the difference between old - new.\n                    uint256 _withdrawDifference = _taskCost - _newCost;\n\n                    // Reduce this difference from total cost allocated.\n                    // As the same task is now allocated with lesser cost.\n                    totalAllocated -= _withdrawDifference;\n\n                    // Withdraw the difference back to builder's account.\n                    // As this additional amount may not be required by the project.\n                    autoWithdraw(_withdrawDifference);\n                }\n                // If new cost is more than task cost but total lent is enough to cover for it.\n                else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n                    // Increase the difference of new cost and old cost to total allocated.\n                    totalAllocated += _newCost - _taskCost;\n                }\n                // If new cost is more than task cost and totalLent is not enough.\n                else {\n                    // Un-confirm SC, mark task as inactive, mark allocated as false, mark lifecycle as None\n\n                    // Mark task as inactive by unapproving subcontractor.\n                    // As subcontractor can only be approved if task is allocated\n                    _unapproved = true;\n                    tasks[_taskID].unApprove();\n\n                    // Mark task as not allocated.\n                    tasks[_taskID].unAllocateFunds();\n\n                    // Reduce total allocation by old task cost.\n                    // As as needs to go though funding process again.\n                    totalAllocated -= _taskCost;\n\n                    // Add this task to _changeOrderedTask array. These tasks will be allocated first.\n                    _changeOrderedTask.push(_taskID);\n                }\n            }\n\n            // Store new cost for the task\n            tasks[_taskID].cost = _newCost;\n\n            emit ChangeOrderFee(_taskID, _newCost);\n        }\n\n        // If task subcontractor is to be changed.\n        if (_newSC != tasks[_taskID].subcontractor) {\n            // If task is not already unapproved, then un-approve it.\n            // Un-approving task means marking subcontractor as unconfirmed.\n            if (!_unapproved) {\n                tasks[_taskID].unApprove();\n            }\n\n            // If new subcontractor is not zero address.\n            if (_newSC != address(0)) {\n                // Invite the new subcontractor for the task.\n                _inviteSC(_taskID, _newSC, true);\n            }\n            // Else store zero address for the task subcontractor.\n            // This implies that a subcontractor is not invited from the task.\n            else {\n                tasks[_taskID].subcontractor = address(0);\n            }\n\n            emit ChangeOrderSC(_taskID, _newSC);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Recover the signer from the signature\n        address signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (address _project, uint256 _task, , , ) = abi.decode(\n            _data,\n            (address, uint256, uint8, bytes, bytes)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        if (_task == 0) {\n            // Revet if sender is not builder or contractor\n            require(\n                signer == builder || signer == contractor,\n                \"Project::!(GC||Builder)\"\n            );\n        } else {\n            // Revet if sender is not builder, contractor or task's subcontractor\n            require(\n                signer == builder ||\n                    signer == contractor ||\n                    signer == tasks[_task].subcontractor,\n                \"Project::!(GC||Builder||SC)\"\n            );\n\n            if (signer == tasks[_task].subcontractor) {\n                // If sender is task's subcontractor, revert if invitation is not accepted.\n                require(getAlerts(_task)[2], \"Project::!SCConfirmed\");\n            }\n        }\n\n        // Make a call to Disputes contract raiseDisputes.\n        IDisputes(disputes).raiseDispute(_data, _signature);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function getTask(uint256 id)\n        external\n        view\n        override\n        returns (\n            uint256 cost,\n            address subcontractor,\n            TaskStatus state\n        )\n    {\n        cost = tasks[id].cost;\n        subcontractor = tasks[id].subcontractor;\n        state = tasks[id].state;\n    }\n\n    /// @inheritdoc IProject\n    function changeOrderedTask()\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _changeOrderedTask;\n    }\n\n    /*******************************************************************************\n     * ----------------------------PUBLIC TRANSACTIONS---------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function allocateFunds() public override {\n        // Max amount out times this loop will run\n        // This is to ensure the transaction do not run out of gas (max gas limit)\n        uint256 _maxLoop = 50;\n\n        // Difference of totalLent and totalAllocated is what can be used to allocate new tasks\n        uint256 _costToAllocate = totalLent - totalAllocated;\n\n        // Bool if max loop limit is exceeded\n        bool _exceedLimit;\n\n        // Local instance of lastAllocatedChangeOrderTask. To save gas.\n        uint256 i = lastAllocatedChangeOrderTask;\n\n        // Local instance of lastAllocatedTask. To save gas.\n        uint256 j = lastAllocatedTask;\n\n        // Initialize empty array in which allocated tasks will be added.\n        uint256[] memory _tasksAllocated = new uint256[](\n            taskCount - j + _changeOrderedTask.length - i\n        );\n\n        // Number of times a loop has run.\n        uint256 _loopCount;\n\n        /// CHANGE ORDERED TASK FUNDING ///\n\n        // Any tasks added to _changeOrderedTask will be allocated first\n        if (_changeOrderedTask.length > 0) {\n            // Loop from lastAllocatedChangeOrderTask to _changeOrderedTask length (until _maxLoop)\n            for (; i < _changeOrderedTask.length; i++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[_changeOrderedTask[i]].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[_changeOrderedTask[i]].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = _changeOrderedTask[i];\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all the change ordered tasks are allocated, then delete\n            // the changeOrderedTask array and reset lastAllocatedChangeOrderTask.\n            if (i == _changeOrderedTask.length) {\n                lastAllocatedChangeOrderTask = 0;\n                delete _changeOrderedTask;\n            }\n            // Else store the last allocated change order task index.\n            else {\n                lastAllocatedChangeOrderTask = i;\n            }\n        }\n\n        /// TASK FUNDING ///\n\n        // If lastAllocatedTask is lesser than taskCount, that means there are un-allocated tasks\n        if (j < taskCount) {\n            // Loop from lastAllocatedTask + 1 to taskCount (until _maxLoop)\n            for (++j; j <= taskCount; j++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[j].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[j].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = j;\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all pending tasks are allocated store lastAllocatedTask equal to taskCount\n            if (j > taskCount) {\n                lastAllocatedTask = taskCount;\n            }\n            // If not all tasks are allocated store updated lastAllocatedTask\n            else {\n                lastAllocatedTask = --j;\n            }\n        }\n\n        // If any tasks is allocated, then emit event\n        if (_loopCount > 0) emit TaskAllocated(_tasksAllocated);\n\n        // If allocation was incomplete, then emit event\n        if (_exceedLimit) emit IncompleteAllocation();\n\n        // Update totalAllocated with all allocations\n        totalAllocated = totalLent - _costToAllocate;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function projectCost() public view override returns (uint256 _cost) {\n        // Local instance of taskCount. To save gas.\n        uint256 _length = taskCount;\n\n        // Iterate over all tasks to sum their cost\n        for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n            _cost += tasks[_taskID].cost;\n        }\n    }\n\n    /// @inheritdoc IProject\n    function getAlerts(uint256 _taskID)\n        public\n        view\n        override\n        returns (bool[3] memory _alerts)\n    {\n        return tasks[_taskID].getAlerts();\n    }\n\n    /// @inheritdoc IProject\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IProject)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Invite subcontractors for a single task. This can be called by builder or contractor.\n     * _taskList must not have a task which already has approved subcontractor.\n     \n     * @param _taskID uint256 task index\n     * @param _sc address addresses of subcontractor for the respective task\n     * @param _emitEvent whether to emit event for each sc added or not\n     */\n    function _inviteSC(\n        uint256 _taskID,\n        address _sc,\n        bool _emitEvent\n    ) internal {\n        // Revert if sc to invite is address 0\n        require(_sc != address(0), \"Project::0 address\");\n\n        // Internal call to tasks invite contractor\n        tasks[_taskID].inviteSubcontractor(_sc);\n\n        // If `_emitEvent` is true (called via changeOrder) then emit event\n        if (_emitEvent) {\n            emit SingleSCInvited(_taskID, _sc);\n        }\n    }\n\n    /**\n     * @dev Transfer excess funds back to builder wallet.\n     * Called internally in task changeOrder when new task cost is lower than older cost.\n\n     * @param _amount uint256 - amount of excess funds\n     */\n    function autoWithdraw(uint256 _amount) internal {\n        // Reduce amount from totalLent\n        totalLent -= _amount;\n\n        // Transfer amount to builder address\n        currency.safeTransfer(builder, _amount);\n\n        emit AutoWithdrawn(_amount);\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder and contractor address.\n     * Signatures must be in sequential order. First builder and then contractor.\n     * Reverts if signature do not match.\n     * If contractor is not assigned then only checks for builder signature.\n     * If contractor is assigned but not delegated then only checks for builder and contractor signature.\n     * If contractor is assigned and delegated then only checks for contractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     */\n    function checkSignature(bytes calldata _data, bytes calldata _signature)\n        internal\n    {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Check for builder's signature\n            checkSignatureValidity(builder, _hash, _signature, 0);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                //  Check contractor's signature\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for both B and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n            }\n        }\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder, contractor and subcontractor address for a task.\n     * Signatures must be in sequential order. First builder, then contractor, and then subcontractor.\n     * reverts if signatures do not match.\n     * If contractor is not assigned then only checks for builder and subcontractor signature.\n     * If contractor is assigned but not delegated then only checks for builder, contractor and subcontractor signature.\n     * If contractor is assigned and delegated then only checks for contractor and subcontractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     * @param _taskID index of the task.\n     */\n    function checkSignatureTask(\n        bytes calldata _data,\n        bytes calldata _signature,\n        uint256 _taskID\n    ) internal {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of subcontractor. To save gas.\n        address _sc = tasks[_taskID].subcontractor;\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Just check for B and SC sign\n            checkSignatureValidity(builder, _hash, _signature, 0);\n            checkSignatureValidity(_sc, _hash, _signature, 1);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                // Check for GC and SC sign\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n                checkSignatureValidity(_sc, _hash, _signature, 1);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for B, SC and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n                checkSignatureValidity(_sc, _hash, _signature, 2);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev Checks if the signature is approved or recovered\n     * @dev Reverts if not\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal {\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Project::invalid signature\"\n        );\n        // delete from approvedHash\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * -------------------------------INTERNAL PURE------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Check if precision is greater than 1000, if so, it reverts\n\n     * @param _amount amount needed to be checked for precision.\n     */\n    function checkPrecision(uint256 _amount) internal pure {\n        // Divide and multiply amount with 1000 should be equal to amount.\n        // This ensures the amount is not too precise.\n        require(\n            ((_amount / 1000) * 1000) == _amount,\n            \"Project::Precision>=1000\"\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "Tasks.sol",
            "Project.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "[Project.sol#L386-L490, Project.sol#L330-L359, Tasks.sol#L153-L164]",
                "Type": "Project funds can be drained by reusing signatures, in some cases",
                "Description": "Current or previous subcontractor of a task can drain the project out of its funds by running setComplete() multiple times.",
                "Repair": "Use nonce to protect setComplete() and changeOrder() from signatures reuse. Add the onlyActive() modifier to Tasks.unApprove()."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {ICommunity, IDebtToken} from \"./interfaces/ICommunity.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Community Contract for HomeFi v2.5.0\n \n * @notice Module for coordinating lending groups on HomeFi protocol\n */\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ---------------------FIXED INTERNAL STORED PROPERTIES---------------------- *\n     *******************************************************************************/\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    /*******************************************************************************\n     * --------------------VARIABLE INTERNAL STORED PROPERTIES-------------------- *\n     *******************************************************************************/\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    IHomeFi public override homeFi;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    bool public override restrictedToAdmin;\n    /// @inheritdoc ICommunity\n    uint256 public override communityCount;\n    /// @inheritdoc ICommunity\n    mapping(address => uint256) public override projectPublished;\n    /// @inheritdoc ICommunity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00) (invalid)\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        // Revert if sender is not homeFi admin\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n        // Revert if sender is not _project builder\n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        // Initialize pausable. Set pause to false;\n        __Pausable_init();\n\n        // Initialize variables\n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        // Community creation is paused for non admin by default paused\n        restrictedToAdmin = true;\n    }\n\n    /// @inheritdoc ICommunity\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        // Local variable for sender. For gas saving.\n        address _sender = _msgSender();\n\n        // Revert if community creation is paused or sender is not HomeFi admin\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        // Revert if currency is not supported by HomeFi\n        homeFi.validCurrency(_currency);\n\n        // Increment community counter\n        communityCount++;\n\n        // Store community details\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        override\n    {\n        // Revert if sender is not _communityID owner\n        require(\n            _communities[_communityID].owner == _msgSender(),\n            \"Community::!owner\"\n        );\n\n        // Emit event if _hash. This way this hash needs not be stored in memory.\n        emit UpdateCommunityHash(_communityID, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _newMemberAddr,\n            bytes memory _messageHash\n        ) = abi.decode(_data, (uint256, address, bytes));\n\n        CommunityStruct storage _community = _communities[_communityID];\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\n        // Revert if new member already exists\n        require(\n            !_community.isMember[_newMemberAddr],\n            \"Community::Member Exists\"\n        );\n\n        // Store updated community details\n        uint256 _memberCount = _community.memberCount;\n        _community.memberCount = _memberCount + 1;\n        _community.members[_memberCount] = _newMemberAddr;\n        _community.isMember[_newMemberAddr] = true;\n\n        emit MemberAdded(_communityID, _newMemberAddr, _messageHash);\n    }\n\n    /// @inheritdoc ICommunity\n    function publishProject(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _project,\n            uint256 _apr,\n            uint256 _publishFee,\n            uint256 _publishNonce,\n            bytes memory _messageHash\n        ) = abi.decode(\n                _data,\n                (uint256, address, uint256, uint256, uint256, bytes)\n            );\n\n        // Local instance of community and community  project details. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(\n            _publishNonce == _community.publishNonce,\n            \"Community::invalid publishNonce\"\n        );\n\n        // Reverts if _project not originated from HomeFi\n        require(homeFi.isProjectExist(_project), \"Community::Project !Exists\");\n\n        // Local instance of variables. For saving gas.\n        IProject _projectInstance = IProject(_project);\n        address _builder = _projectInstance.builder();\n\n        // Revert if project builder is not community member\n        require(_community.isMember[_builder], \"Community::!Member\");\n\n        // Revert if project currency does not match community currency\n        require(\n            _projectInstance.currency() == _community.currency,\n            \"Community::!Currency\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be project builder\n\n        // If already published then unpublish first\n        if (projectPublished[_project] > 0) {\n            _unpublishProject(_project);\n        }\n\n        // Store updated details\n        _community.publishNonce = ++_community.publishNonce;\n        _communityProject.apr = _apr;\n        _communityProject.publishFee = _publishFee;\n        projectPublished[_project] = _communityID;\n\n        // If _publishFee is zero than mark publish fee as paid\n        if (_publishFee == 0) _communityProject.publishFeePaid = true;\n\n        emit ProjectPublished(\n            _communityID,\n            _project,\n            _apr,\n            _publishFee,\n            _communityProject.publishFeePaid,\n            _messageHash\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function unpublishProject(uint256 _communityID, address _project)\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Call internal function to unpublish project\n        _unpublishProject(_project);\n    }\n\n    /// @inheritdoc ICommunity\n    function payPublishFee(uint256 _communityID, address _project)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if publish fee already paid\n        require(\n            !_communityProject.publishFeePaid,\n            \"Community::publish fee paid\"\n        );\n\n        // Store updated detail\n        _communityProject.publishFeePaid = true;\n\n        // Transfer publishFee to community owner (lender)\n        _community.currency.safeTransferFrom(\n            _msgSender(),\n            _community.owner,\n            _communityProject.publishFee\n        );\n\n        emit PublishFeePaid(_communityID, _project);\n    }\n\n    /// @inheritdoc ICommunity\n    function toggleLendingNeeded(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingNeeded\n    )\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        // Revert if publish fee not paid\n        require(\n            _communityProject.publishFeePaid,\n            \"Community::publish fee !paid\"\n        );\n\n        // Revert if _lendingNeeded is more than projectCost or less than what is already lent\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n\n        // Store updated detail\n        _communityProject.lendingNeeded = _lendingNeeded;\n\n        emit ToggleLendingNeeded(_communityID, _project, _lendingNeeded);\n    }\n\n    /// @inheritdoc ICommunity\n    function lendToProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingAmount,\n        bytes calldata _hash\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n    {\n        // Local instance of variable. For saving gas.\n        address _sender = _msgSender();\n\n        // Revert if sender is not community owner.\n        // Only community owner can lend.\n        require(\n            _sender == _communities[_communityID].owner,\n            \"Community::!owner\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Calculate lenderFee\n        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /\n            (_projectInstance.lenderFee() + 1000);\n\n        // Calculate amount going to project. Lending amount - lending fee.\n        uint256 _amountToProject = _lendingAmount - _lenderFee;\n\n        // Revert if _amountToProject is not within further investment needed.\n        require(\n            _amountToProject <=\n                _communities[_communityID]\n                    .projectDetails[_project]\n                    .lendingNeeded -\n                    _communities[_communityID]\n                        .projectDetails[_project]\n                        .totalLent,\n            \"Community::lending>needed\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IDebtToken _currency = _communities[_communityID].currency;\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_currency))\n        );\n\n        // Update investment in Project\n        _projectInstance.lendToProject(_amountToProject);\n\n        // Update total lent by lender\n        _communities[_communityID]\n            .projectDetails[_project]\n            .totalLent += _amountToProject;\n\n        // First claim interest if principal lent > 0\n        if (\n            _communities[_communityID].projectDetails[_project].lentAmount > 0\n        ) {\n            claimInterest(_communityID, _project, _wrappedToken);\n        }\n\n        // Increment lent principal\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lentAmount += _lendingAmount;\n\n        // Update lastTimestamp\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lastTimestamp = block.timestamp;\n\n        // Transfer _lenderFee to HomeFi treasury from lender account\n        _currency.safeTransferFrom(_msgSender(), homeFi.treasury(), _lenderFee);\n\n        // Transfer _amountToProject to _project from lender account\n        _currency.safeTransferFrom(_msgSender(), _project, _amountToProject);\n\n        // Mint new _lendingAmount amount wrapped token to lender\n        _wrappedToken.mint(_sender, _lendingAmount);\n\n        emit LenderLent(_communityID, _project, _sender, _lendingAmount, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function repayLender(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        onlyProjectBuilder(_project)\n    {\n        // Internally call reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, \"0x\");\n\n        // Local instance of variable. For saving gas.\n        address _lender = _communities[_communityID].owner;\n\n        // Transfer repayment to lender\n        _communities[_communityID].currency.safeTransferFrom(\n            _msgSender(),\n            _lender,\n            _repayAmount\n        );\n\n        emit RepayLender(_communityID, _project, _lender, _repayAmount);\n    }\n\n    /// @inheritdoc ICommunity\n    function reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) external virtual override whenNotPaused {\n        // Revert if sender is not _communityID owner (lender)\n        require(\n            _msgSender() == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n    }\n\n    /// @inheritdoc ICommunity\n    function approveHash(bytes32 _hash) external virtual override {\n        // allowing anyone to sign, as its hard to add restrictions here\n        approvedHashes[_msgSender()][_hash] = true;\n\n        emit ApproveHash(_hash, _msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function escrow(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _builder,\n            address _lender,\n            address _agent,\n            address _project,\n            uint256 _repayAmount,\n            bytes memory _details\n        ) = abi.decode(\n                _data,\n                (uint256, address, address, address, address, uint256, bytes)\n            );\n\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Revert if decoded builder is not decoded project's builder\n        require(_builder == _projectInstance.builder(), \"Community::!Builder\");\n\n        // Revert if decoded _communityID's owner is not decoded _lender\n        require(\n            _lender == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder\n        checkSignatureValidity(_agent, _hash, _signature, 2); // must be agent or escrow\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n        emit DebtReducedByEscrow(_agent);\n    }\n\n    /// @inheritdoc ICommunity\n    function restrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already restricted to admin\n        require(!restrictedToAdmin, \"Community::restricted\");\n\n        // Disable community creation for non admins\n        restrictedToAdmin = true;\n\n        emit RestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function unrestrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already unrestricted to admin\n        require(restrictedToAdmin, \"Community::!restricted\");\n\n        // Allow community creation for all\n        restrictedToAdmin = false;\n\n        emit UnrestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function pause() external override onlyHomeFiAdmin {\n        _pause();\n    }\n\n    /// @inheritdoc ICommunity\n    function unpause() external override onlyHomeFiAdmin {\n        _unpause();\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function communities(uint256 _communityID)\n        external\n        view\n        override\n        returns (\n            address owner,\n            address currency,\n            uint256 memberCount,\n            uint256 publishNonce\n        )\n    {\n        CommunityStruct storage _community = _communities[_communityID];\n\n        owner = _community.owner;\n        currency = address(_community.currency);\n        memberCount = _community.memberCount;\n        publishNonce = _community.publishNonce;\n    }\n\n    /// @inheritdoc ICommunity\n    function members(uint256 _communityID)\n        external\n        view\n        virtual\n        override\n        returns (address[] memory)\n    {\n        // Initiate empty equal equal to member count length\n        address[] memory _members = new address[](\n            _communities[_communityID].memberCount\n        );\n\n        // Append member addresses in _members array\n        for (uint256 i = 0; i < _communities[_communityID].memberCount; i++) {\n            _members[i] = _communities[_communityID].members[i];\n        }\n\n        return _members;\n    }\n\n    /// @inheritdoc ICommunity\n    function projectDetails(uint256 _communityID, address _project)\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        return (\n            _communityProject.apr,\n            _communityProject.lendingNeeded,\n            _communityProject.totalLent,\n            _communityProject.publishFee,\n            _communityProject.publishFeePaid,\n            _communityProject.lentAmount,\n            _communityProject.interest,\n            _communityProject.lastTimestamp\n        );\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function returnToLender(uint256 _communityID, address _project)\n        public\n        view\n        override\n        returns (\n            uint256, // principal + interest\n            uint256, // principal\n            uint256, // total interest\n            uint256 // unclaimedInterest\n        )\n    {\n        // Local instance of variables. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n        uint256 _lentAmount = _communityProject.lentAmount;\n\n        // Calculate number of days difference current and last timestamp\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) / 86400; // 24*60*60\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000;\n\n        // Old (already rTokens claimed) + new interest\n        uint256 _totalInterest = _unclaimedInterest +\n            _communityProject.interest;\n\n        return (\n            _lentAmount + _totalInterest,\n            _lentAmount,\n            _totalInterest,\n            _unclaimedInterest\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, ICommunity)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev internal function for `unpublishProject`\n     * @param _project address - project address to unpublish\n     */\n    function _unpublishProject(address _project) internal {\n        // Locally store old community of published project\n        uint256 formerCommunityId = projectPublished[_project];\n\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[\n            formerCommunityId\n        ].projectDetails[_project];\n\n        // Reduce lending needed to total lent. So no more investment can be made to this project.\n        _communityProject.lendingNeeded = _communityProject.totalLent;\n\n        // Mark project as unpublished.\n        delete projectPublished[_project];\n\n        // Set public fee paid to false.\n        // So if this project is published again to this community,\n        // then this fee will be required to be paid again.\n        _communityProject.publishFeePaid = false;\n\n        emit ProjectUnpublished(formerCommunityId, _project);\n    }\n\n    /**\n     * @dev Internal function for reducing debt\n\n     * @param _communityID uint256 - the the uuid of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _repayAmount uint256 - the amount of funds repaid to the lender, in the project currency\n     * @param _details bytes - some details on why debt is reduced (off chain documents or images)\n     */\n    function _reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) internal virtual {\n        // Revert if repayment amount is zero.\n        require(_repayAmount > 0, \"Community::!repay\");\n\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n        address _lender = _community.owner;\n\n        // Find wrapped token for community currency\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_community.currency))\n        );\n\n        // Claim interest on existing investments\n        claimInterest(_communityID, _project, _wrappedToken);\n\n        // Local instance of variables. For saving gas.\n        uint256 _lentAmount = _communityProject.lentAmount;\n        uint256 _interest = _communityProject.interest;\n\n        if (_repayAmount > _interest) {\n            // If repayment amount is greater than interest then\n            // set lent = lent + interest - repayment.\n            // And set interest = 0.\n            uint256 _lentAndInterest = _lentAmount + _interest;\n\n            // Revert if repayment amount is greater than sum of lent and interest.\n            require(_lentAndInterest >= _repayAmount, \"Community::!Liquid\");\n            _interest = 0;\n            _lentAmount = _lentAndInterest - _repayAmount;\n        } else {\n            // If repayment amount is lesser than interest, then set\n            // interest = interest - repayment\n            _interest -= _repayAmount;\n        }\n\n        // Update community  project details\n        _communityProject.lentAmount = _lentAmount;\n        _communityProject.interest = _interest;\n\n        // Burn _repayAmount amount wrapped token from lender\n        _wrappedToken.burn(_lender, _repayAmount);\n\n        emit DebtReduced(\n            _communityID,\n            _project,\n            _lender,\n            _repayAmount,\n            _details\n        );\n    }\n\n    /**\n     * @dev claim interest of lender\n\n     * @param _communityID uint256 - uuid of community the project is held in\n     * @param _project address - address of project where debt/ loan is held\n     * @param _wrappedToken address - debt token lender is claiming\n     */\n    function claimInterest(\n        uint256 _communityID,\n        address _project,\n        IDebtToken _wrappedToken\n    ) internal {\n        // Calculate new interest\n        (, , uint256 _interest, uint256 _interestEarned) = returnToLender(\n            _communityID,\n            _project\n        );\n\n        // Local instance of variables. For saving gas.\n        address _lender = _communities[_communityID].owner;\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        if (_interestEarned > 0) {\n            // If any new interest is to be claimed.\n\n            // Increase total interest with new interest to be claimed.\n            _communityProject.interest = _interest;\n\n            // Update lastTimestamp to current time.\n            _communityProject.lastTimestamp = block.timestamp;\n\n            // Burn _interestEarned amount wrapped token to lender\n            _wrappedToken.mint(_lender, _interestEarned);\n\n            emit ClaimedInterest(\n                _communityID,\n                _project,\n                _lender,\n                _interestEarned\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev checks if the signature is approved or recovered, if not it reverts.\n\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal virtual {\n        // Decode signer\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n\n        // Revert if decoded signer does not match expected address\n        // Or if hash is not approved by the expected address.\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Community::invalid signature\"\n        );\n\n        // Delete from approvedHash. So that signature cannot be reused.\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}\n\n\n",
        "CodeNames": [
            "Community.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Community.sol#L206-L282",
                "Type": "Missing budget check",
                "Description": "It should not submit a project with no total budget. Requires at least one task with cost > 0.",
                "Repair": "Add a new require which will check if the first task (which is at index 1), its cost is > 0."
            },
            {
                "Location": "escrow() function in Community.sol",
                "Type": "Reentrancy",
                "Description": "Builder can call Community.escrow again to reduce debt further using same signatures.",
                "Repair": "Add a new field into the ProjectDetails struct called escrowNonce and modify function escrow() to check this nonce and update it after the debt has been reduced"
            },
            {
                "Location": "Community.sol#L187, Community.sol#L179, Community.sol#L878",
                "Type": "Access Control",
                "Description": "An attacker can add as many members as they want, BEFORE the community will be created.",
                "Repair": "Add a require statement to check that the community ID is less than or equal to the community count, and modify checkSignatureValidity/recoverKey to revert the call if an address is equal to 0"
            },
            {
                "Location": "Community.sol#L685-L686",
                "Type": "Arithmetic Rounding",
                "Description": "A builder can halve the APR paid to a community owner by paying every 1.9999 days due to arithmetic rounding in returnToLender().",
                "Repair": "Add a scalar to noOfDays so that any rounding which occurs is negligible or Remove the noOfDays calculation and calculate interest in one equation which reduces arithmetic rounding"
            },
            {
                "Location": "Community.sol#L267",
                "Type": "Wrong APR calculation",
                "Description": "When a project is unpublished from a community, it can still owe money to this community (on which it needs to pay interest according to the specified APR). However, when the project is later published again in this community, the APR can be overwritten and the overwritten APR is used for the calculation of the interest for the old project (when it was unpublished).",
                "Repair": "Calculate interest before updating the APR when publishing a project"
            },
            {
                "Location": "Community.sol#L455, Community.sol#L484, Community.sol#L509",
                "Type": "Builders paying more interest when the system is paused",
                "Description": "Builders can't repay when the system is paused so they must pay more interest for the paused period. Builders can repay to lenders using 3 functions, repayLender(), reduceDebt(), and escrow(). But they all don't work when the system is paused and builders have no way to avoid it.",
                "Repair": "Modify the interest calculation formula not to add interest for the paused period or make the 3 repay functions work for paused"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProjectFactory} from \"./interfaces/IProjectFactory.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC721URIStorageUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\n\n/**\n * @title HomeFi v2.5.0 HomeFi Contract.\n\n * @notice Main on-chain client.\n * Administrative controls and project deployment.\n \n * @dev\n * Adheres to -\n * IHomeFi: Allows this contract to be used by other HomeFi contracts.\n\n * @dev\n * Inherits from -\n * ReentrancyGuardUpgradeable: Contract module that helps prevent reentrant calls to a function.\n * ERC721URIStorageUpgradeable: ERC721 token with storage based token URI management.\n * ERC2771ContextUpgradeable: Context variant with ERC2771 support.\n */\ncontract HomeFi is\n    IHomeFi,\n    ReentrancyGuardUpgradeable,\n    ERC721URIStorageUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency1;\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency2;\n    /// @inheritdoc IHomeFi\n    address public override tokenCurrency3;\n    /// @inheritdoc IHomeFi\n    IProjectFactory public override projectFactoryInstance;\n    /// @inheritdoc IHomeFi\n    address public override disputesContract;\n    /// @inheritdoc IHomeFi\n    address public override communityContract;\n    /// @inheritdoc IHomeFi\n    bool public override addrSet;\n    /// @inheritdoc IHomeFi\n    address public override admin;\n    /// @inheritdoc IHomeFi\n    address public override treasury;\n    /// @inheritdoc IHomeFi\n    uint256 public override lenderFee;\n    /// @inheritdoc IHomeFi\n    uint256 public override projectCount;\n    /// @inheritdoc IHomeFi\n    address public override trustedForwarder;\n    /// @inheritdoc IHomeFi\n    mapping(uint256 => address) public override projects;\n    /// @inheritdoc IHomeFi\n    mapping(address => uint256) public override projectTokenId;\n    /// @inheritdoc IHomeFi\n    mapping(address => address) public override wrappedToken;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier onlyAdmin() {\n        require(admin == _msgSender(), \"HomeFi::!Admin\");\n        _;\n    }\n\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"HomeFi::0 address\");\n        _;\n    }\n\n    modifier noChange(address _oldAddress, address _newAddress) {\n        // Revert if new address is same as old\n        require(_oldAddress != _newAddress, \"HomeFi::!Change\");\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IHomeFi\n    function initialize(\n        address _treasury,\n        uint256 _lenderFee,\n        address _tokenCurrency1,\n        address _tokenCurrency2,\n        address _tokenCurrency3,\n        address _forwarder\n    )\n        external\n        override\n        initializer\n        nonZero(_treasury)\n        nonZero(_tokenCurrency1)\n        nonZero(_tokenCurrency2)\n        nonZero(_tokenCurrency3)\n    {\n        // Initialize ERC721 and ERC2771Context\n        __ERC721_init(\"HomeFiNFT\", \"hNFT\");\n        __ERC2771Context_init(_forwarder);\n\n        // Initialize variables\n        admin = _msgSender();\n        treasury = _treasury;\n        lenderFee = _lenderFee; // the percentage must be multiplied with 10\n        tokenCurrency1 = _tokenCurrency1;\n        tokenCurrency2 = _tokenCurrency2;\n        tokenCurrency3 = _tokenCurrency3;\n        trustedForwarder = _forwarder;\n    }\n\n    /// @inheritdoc IHomeFi\n    function setAddr(\n        address _projectFactory,\n        address _communityContract,\n        address _disputesContract,\n        address _hTokenCurrency1,\n        address _hTokenCurrency2,\n        address _hTokenCurrency3\n    )\n        external\n        override\n        onlyAdmin\n        nonZero(_projectFactory)\n        nonZero(_communityContract)\n        nonZero(_disputesContract)\n        nonZero(_hTokenCurrency1)\n        nonZero(_hTokenCurrency2)\n        nonZero(_hTokenCurrency3)\n    {\n        // Revert if addrSet is true\n        require(!addrSet, \"HomeFi::Set\");\n\n        // Initialize variables\n        projectFactoryInstance = IProjectFactory(_projectFactory);\n        communityContract = _communityContract;\n        disputesContract = _disputesContract;\n        wrappedToken[tokenCurrency1] = _hTokenCurrency1;\n        wrappedToken[tokenCurrency2] = _hTokenCurrency2;\n        wrappedToken[tokenCurrency3] = _hTokenCurrency3;\n        addrSet = true;\n\n        emit AddressSet();\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceAdmin(address _newAdmin)\n        external\n        override\n        onlyAdmin\n        nonZero(_newAdmin)\n        noChange(admin, _newAdmin)\n    {\n        // Replace admin\n        admin = _newAdmin;\n\n        emit AdminReplaced(_newAdmin);\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceTreasury(address _newTreasury)\n        external\n        override\n        onlyAdmin\n        nonZero(_newTreasury)\n        noChange(treasury, _newTreasury)\n    {\n        // Replace treasury\n        treasury = _newTreasury;\n\n        emit TreasuryReplaced(_newTreasury);\n    }\n\n    /// @inheritdoc IHomeFi\n    function replaceLenderFee(uint256 _newLenderFee)\n        external\n        override\n        onlyAdmin\n    {\n        // Revert if no change in lender fee\n        require(lenderFee != _newLenderFee, \"HomeFi::!Change\");\n\n        // Reset variables\n        lenderFee = _newLenderFee;\n\n        emit LenderFeeReplaced(_newLenderFee);\n    }\n\n    /// @inheritdoc IHomeFi\n    function setTrustedForwarder(address _newForwarder)\n        external\n        override\n        onlyAdmin\n        noChange(trustedForwarder, _newForwarder)\n    {\n        trustedForwarder = _newForwarder;\n    }\n\n    /// @inheritdoc IHomeFi\n    function createProject(bytes memory _hash, address _currency)\n        external\n        override\n        nonReentrant\n    {\n        // Revert if currency not supported by HomeFi\n        validCurrency(_currency);\n\n        address _sender = _msgSender();\n\n        // Create a new project Clone and mint a new NFT for it\n        address _project = projectFactoryInstance.createProject(\n            _currency,\n            _sender\n        );\n        mintNFT(_sender, string(_hash));\n\n        // Update project related mappings\n        projects[projectCount] = _project;\n        projectTokenId[_project] = projectCount;\n\n        emit ProjectAdded(projectCount, _project, _sender, _currency, _hash);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    function isProjectExist(address _project)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return projectTokenId[_project] > 0;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IHomeFi\n    function validCurrency(address _currency) public view override {\n        // _currency must be one of HomeFi supported currencies\n        require(\n            _currency == tokenCurrency1 ||\n                _currency == tokenCurrency2 ||\n                _currency == tokenCurrency3,\n            \"HomeFi::!Currency\"\n        );\n    }\n\n    /// @inheritdoc IHomeFi\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IHomeFi)\n        returns (bool)\n    {\n        return trustedForwarder == _forwarder;\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n    /**\n     * @dev Makes an NFT for every project\n\n     * @param _to address - NFT owner. Initially it will be the project builder.\n     * @param _tokenURI string - IPFS hash of project details like name, description etc\n\n     * @return _tokenIds NFT Id of project\n     */\n    function mintNFT(address _to, string memory _tokenURI)\n        internal\n        returns (uint256)\n    {\n        // Project count starts from 1\n        projectCount += 1;\n\n        // Mints NFT and set token URI\n        _mint(_to, projectCount);\n        _setTokenURI(projectCount, _tokenURI);\n\n        emit NftCreated(projectCount, _to);\n        return projectCount;\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}\n\n\n",
        "CodeNames": [
            "HomeFi.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "HomeFi.sol#L184-L197",
                "Type": "Lender fee upper limit issue",
                "Description": "The admin of the HomeFi contract can set lenderFee to greater than 100%, forcing calls to lendToProject() to all projects created in the future to revert.",
                "Repair": "Consider adding a reasonable fee rate bounds checks in the replaceLenderFee() function."
            },
            {
                "Location": "HomeFi.sol#L156-L169, HomeFi.sol#L199-L208",
                "Type": "Attacker can drain all the projects within minutes, if admin account has been exposed",
                "Description": "In case where the admin wallet has been hacked, the attacker can drain all funds out of the project within minutes. All the attacker needs is the admin to sign a single meta/normal tx.",
                "Repair": "Limit approveHash to contracts only, or make it use msg.sender instead of _msgSender(), or make the process of replacing the forwarder or the admin a 2 step process with a delay between the steps, or consider removing the meta tx for HomeFi onlyAdmin modifier"
            },
            {
                "Location": "createProject() function in HomeFi.sol",
                "Type": "No Purpose",
                "Description": "Owner of project NFT has no purpose and no permissions to access authorized functions in Rigor.",
                "Repair": "Prevent transferring the project NFT to a different address or use the actual NFT owner as the builder of a project"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDebtToken} from \"./interfaces/IDebtToken.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {Tasks, Task, TaskStatus} from \"./libraries/Tasks.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Deployable Project Contract for HomeFi v2.5.0\n\n * @notice contains the primary logic around construction project management. \n * Onboarding contractors, fund escrow, and completion tracking are all managed here. \n * Significant multi-signature and meta-transaction functionality is included here.\n\n * @dev This contract is created as a clone copy for the end user\n */\ncontract Project is\n    IProject,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using Tasks library for Task struct\n    using Tasks for Task;\n\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ------------------------FIXED INTERNAL STORED PROPERTIES------------------------- *\n     *******************************************************************************/\n\n    /// @notice Disputes contract instance\n    address internal disputes;\n\n    /// @notice mapping of tasks index to Task struct.\n    mapping(uint256 => Task) internal tasks;\n\n    /// @notice array of indexes of change ordered tasks\n    uint256[] internal _changeOrderedTask;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    IHomeFi public override homeFi;\n    /// @inheritdoc IProject\n    IDebtToken public override currency;\n    /// @inheritdoc IProject\n    uint256 public override lenderFee;\n    /// @inheritdoc IProject\n    address public override builder;\n    /// @inheritdoc IProject\n    uint256 public constant override VERSION = 25000;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    address public override contractor;\n    /// @inheritdoc IProject\n    bool public override contractorConfirmed;\n    /// @inheritdoc IProject\n    uint256 public override hashChangeNonce;\n    /// @inheritdoc IProject\n    uint256 public override totalLent;\n    /// @inheritdoc IProject\n    uint256 public override totalAllocated;\n    /// @inheritdoc IProject\n    uint256 public override taskCount;\n    /// @inheritdoc IProject\n    bool public override contractorDelegated;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedTask;\n    /// @inheritdoc IProject\n    uint256 public override lastAllocatedChangeOrderTask;\n    /// @inheritdoc IProject\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /// @dev Added to make sure master implementation cannot be initialized\n    // solhint-disable-next-line no-empty-blocks\n    constructor() initializer {}\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTION---------------------------- *\n     *******************************************************************************/\n    /// @inheritdoc IProject\n    function initialize(\n        address _currency,\n        address _sender,\n        address _homeFiAddress\n    ) external override initializer {\n        // Initialize variables\n        homeFi = IHomeFi(_homeFiAddress);\n        disputes = homeFi.disputesContract();\n        lenderFee = homeFi.lenderFee();\n        builder = _sender;\n        currency = IDebtToken(_currency);\n    }\n\n    /// @inheritdoc IProject\n    function approveHash(bytes32 _hash) external override {\n        address _sender = _msgSender();\n        // Allowing anyone to sign, as its hard to add restrictions here.\n        // Store _hash as signed for sender.\n        approvedHashes[_sender][_hash] = true;\n\n        emit ApproveHash(_hash, _sender);\n    }\n\n    /// @inheritdoc IProject\n    function inviteContractor(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Revert if contractor has already confirmed his invitation\n        require(!contractorConfirmed, \"Project::GC accepted\");\n\n        // Decode params from _data\n        (address _contractor, address _projectAddress) = abi.decode(\n            _data,\n            (address, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if contractor address is invalid.\n        require(_contractor != address(0), \"Project::0 address\");\n\n        // Store new contractor\n        contractor = _contractor;\n        contractorConfirmed = true;\n\n        // Check signature for builder and contractor\n        checkSignature(_data, _signature);\n\n        emit ContractorInvited(contractor);\n    }\n\n    /// @inheritdoc IProject\n    function delegateContractor(bool _bool) external override {\n        // Revert if sender is not builder\n        require(_msgSender() == builder, \"Project::!B\");\n\n        // Revert if contract not assigned\n        require(contractor != address(0), \"Project::0 address\");\n\n        // Store new bool for contractorDelegated\n        contractorDelegated = _bool;\n\n        emit ContractorDelegated(_bool);\n    }\n\n    /// @inheritdoc IProject\n    function updateProjectHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Check for required signatures\n        checkSignature(_data, _signature);\n\n        // Decode params from _data\n        (bytes memory _hash, uint256 _nonce) = abi.decode(\n            _data,\n            (bytes, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit HashUpdated(_hash);\n    }\n\n    /// @inheritdoc IProject\n    function lendToProject(uint256 _cost) external override nonReentrant {\n        address _sender = _msgSender();\n\n        // Revert if sender is not builder or Community Contract (lender)\n        require(\n            _sender == builder || _sender == homeFi.communityContract(),\n            \"Project::!Builder&&!Community\"\n        );\n\n        // Revert if try to lend 0\n        require(_cost > 0, \"Project::!value>0\");\n\n        // Revert if try to lend more than project cost\n        uint256 _newTotalLent = totalLent + _cost;\n        require(\n            projectCost() >= uint256(_newTotalLent),\n            \"Project::value>required\"\n        );\n\n        if (_sender == builder) {\n            // Transfer assets from builder to this contract\n            currency.safeTransferFrom(_sender, address(this), _cost);\n        }\n\n        // Update total lent with added lend\n        totalLent = _newTotalLent;\n\n        emit LendToProject(_cost);\n\n        // Allocate funds to tasks and mark then as allocated\n        allocateFunds();\n    }\n\n    /// @inheritdoc IProject\n    function addTasks(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures\n            checkSignature(_data, _signature);\n        }\n\n        // Decode params from _data\n        (\n            bytes[] memory _hash,\n            uint256[] memory _taskCosts,\n            uint256 _taskCount,\n            address _projectAddress\n        ) = abi.decode(_data, (bytes[], uint256[], uint256, address));\n\n        // Revert if decoded taskCount is incorrect. This indicates wrong data.\n        require(_taskCount == taskCount, \"Project::!taskCount\");\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!projectAddress\");\n\n        // Revert if IPFS hash array length is not equal to task cost array length.\n        uint256 _length = _hash.length;\n        require(_length == _taskCosts.length, \"Project::Lengths !match\");\n\n        // Loop over all the new tasks.\n        for (uint256 i = 0; i < _length; i++) {\n            // Increment local task counter.\n            _taskCount += 1;\n\n            // Check task cost precision. Revert if too precise.\n            checkPrecision(_taskCosts[i]);\n\n            // Initialize task.\n            tasks[_taskCount].initialize(_taskCosts[i]);\n        }\n\n        // Update task counter equal to local task counter.\n        taskCount = _taskCount;\n\n        emit TasksAdded(_taskCosts, _hash);\n    }\n\n    /// @inheritdoc IProject\n    function updateTaskHash(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (bytes memory _taskHash, uint256 _nonce, uint256 _taskID) = abi.decode(\n            _data,\n            (bytes, uint256, uint256)\n        );\n\n        // Revert if decoded nonce is incorrect. This indicates wrong data.\n        require(_nonce == hashChangeNonce, \"Project::!Nonce\");\n\n        // If subcontractor has confirmed then check signature using `checkSignatureTask`.\n        // Else check signature using `checkSignature`.\n        if (getAlerts(_taskID)[2]) {\n            // If subcontractor has confirmed.\n            checkSignatureTask(_data, _signature, _taskID);\n        } else {\n            // If subcontractor not has confirmed.\n            checkSignature(_data, _signature);\n        }\n\n        // Increment to ensure a set of data and signature cannot be re-used.\n        hashChangeNonce += 1;\n\n        emit TaskHashUpdated(_taskID, _taskHash);\n    }\n\n    /// @inheritdoc IProject\n    function inviteSC(uint256[] calldata _taskList, address[] calldata _scList)\n        external\n        override\n    {\n        // Revert if sender is neither builder nor contractor.\n        require(\n            _msgSender() == builder || _msgSender() == contractor,\n            \"Project::!Builder||!GC\"\n        );\n\n        // Revert if taskList array length not equal to scList array length.\n        uint256 _length = _taskList.length;\n        require(_length == _scList.length, \"Project::Lengths !match\");\n\n        // Invite subcontractor for each task.\n        for (uint256 i = 0; i < _length; i++) {\n            _inviteSC(_taskList[i], _scList[i], false);\n        }\n\n        emit MultipleSCInvited(_taskList, _scList);\n    }\n\n    /// @inheritdoc IProject\n    function acceptInviteSC(uint256[] calldata _taskList) external override {\n        // Accept invitation for each task in taskList.\n        uint256 _length = _taskList.length;\n        for (uint256 i = 0; i < _length; i++) {\n            tasks[_taskList[i]].acceptInvitation(_msgSender());\n        }\n\n        emit SCConfirmed(_taskList);\n    }\n\n    /// @inheritdoc IProject\n    function setComplete(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Decode params from _data\n        (uint256 _taskID, address _projectAddress) = abi.decode(\n            _data,\n            (uint256, address)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_projectAddress == address(this), \"Project::!Project\");\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Mark task as complete. Only works when task is active.\n        tasks[_taskID].setComplete();\n\n        // Transfer funds to subcontractor.\n        currency.safeTransfer(\n            tasks[_taskID].subcontractor,\n            tasks[_taskID].cost\n        );\n\n        emit TaskComplete(_taskID);\n    }\n\n    /// @inheritdoc IProject\n    function recoverTokens(address _tokenAddress) external override {\n        /* If the token address is same as currency of this project,\n            then first check if all tasks are complete */\n        if (_tokenAddress == address(currency)) {\n            // Iterate for each task and check if it is complete.\n            uint256 _length = taskCount;\n            for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n                require(tasks[_taskID].getState() == 3, \"Project::!Complete\");\n            }\n        }\n\n        // Create token instance.\n        IDebtToken _token = IDebtToken(_tokenAddress);\n\n        // Check the balance of _token in this contract.\n        uint256 _leftOutTokens = _token.balanceOf(address(this));\n\n        // If balance is present then it to the builder.\n        if (_leftOutTokens > 0) {\n            _token.safeTransfer(builder, _leftOutTokens);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function changeOrder(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        nonReentrant\n    {\n        // Decode params from _data\n        (\n            uint256 _taskID,\n            address _newSC,\n            uint256 _newCost,\n            address _project\n        ) = abi.decode(_data, (uint256, address, uint256, address));\n\n        // If the sender is disputes contract, then do not check for signatures.\n        if (_msgSender() != disputes) {\n            // Check for required signatures.\n            checkSignatureTask(_data, _signature, _taskID);\n        }\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        // Local variable for task cost. For gas saving.\n        uint256 _taskCost = tasks[_taskID].cost;\n\n        // Local variable indicating if subcontractor is already unapproved.\n        bool _unapproved = false;\n\n        // If task cost is to be changed.\n        if (_newCost != _taskCost) {\n            // Check new task cost precision. Revert if too precise.\n            checkPrecision(_newCost);\n\n            // Local variable for total cost allocated. For gas saving.\n            uint256 _totalAllocated = totalAllocated;\n\n            // If tasks are already allocated with old cost.\n            if (tasks[_taskID].alerts[1]) {\n                // If new task cost is less than old task cost.\n                if (_newCost < _taskCost) {\n                    // Find the difference between old - new.\n                    uint256 _withdrawDifference = _taskCost - _newCost;\n\n                    // Reduce this difference from total cost allocated.\n                    // As the same task is now allocated with lesser cost.\n                    totalAllocated -= _withdrawDifference;\n\n                    // Withdraw the difference back to builder's account.\n                    // As this additional amount may not be required by the project.\n                    autoWithdraw(_withdrawDifference);\n                }\n                // If new cost is more than task cost but total lent is enough to cover for it.\n                else if (totalLent - _totalAllocated >= _newCost - _taskCost) {\n                    // Increase the difference of new cost and old cost to total allocated.\n                    totalAllocated += _newCost - _taskCost;\n                }\n                // If new cost is more than task cost and totalLent is not enough.\n                else {\n                    // Un-confirm SC, mark task as inactive, mark allocated as false, mark lifecycle as None\n\n                    // Mark task as inactive by unapproving subcontractor.\n                    // As subcontractor can only be approved if task is allocated\n                    _unapproved = true;\n                    tasks[_taskID].unApprove();\n\n                    // Mark task as not allocated.\n                    tasks[_taskID].unAllocateFunds();\n\n                    // Reduce total allocation by old task cost.\n                    // As as needs to go though funding process again.\n                    totalAllocated -= _taskCost;\n\n                    // Add this task to _changeOrderedTask array. These tasks will be allocated first.\n                    _changeOrderedTask.push(_taskID);\n                }\n            }\n\n            // Store new cost for the task\n            tasks[_taskID].cost = _newCost;\n\n            emit ChangeOrderFee(_taskID, _newCost);\n        }\n\n        // If task subcontractor is to be changed.\n        if (_newSC != tasks[_taskID].subcontractor) {\n            // If task is not already unapproved, then un-approve it.\n            // Un-approving task means marking subcontractor as unconfirmed.\n            if (!_unapproved) {\n                tasks[_taskID].unApprove();\n            }\n\n            // If new subcontractor is not zero address.\n            if (_newSC != address(0)) {\n                // Invite the new subcontractor for the task.\n                _inviteSC(_taskID, _newSC, true);\n            }\n            // Else store zero address for the task subcontractor.\n            // This implies that a subcontractor is not invited from the task.\n            else {\n                tasks[_taskID].subcontractor = address(0);\n            }\n\n            emit ChangeOrderSC(_taskID, _newSC);\n        }\n    }\n\n    /// @inheritdoc IProject\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n    {\n        // Recover the signer from the signature\n        address signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (address _project, uint256 _task, , , ) = abi.decode(\n            _data,\n            (address, uint256, uint8, bytes, bytes)\n        );\n\n        // Revert if decoded project address does not match this contract. Indicating incorrect _data.\n        require(_project == address(this), \"Project::!projectAddress\");\n\n        if (_task == 0) {\n            // Revet if sender is not builder or contractor\n            require(\n                signer == builder || signer == contractor,\n                \"Project::!(GC||Builder)\"\n            );\n        } else {\n            // Revet if sender is not builder, contractor or task's subcontractor\n            require(\n                signer == builder ||\n                    signer == contractor ||\n                    signer == tasks[_task].subcontractor,\n                \"Project::!(GC||Builder||SC)\"\n            );\n\n            if (signer == tasks[_task].subcontractor) {\n                // If sender is task's subcontractor, revert if invitation is not accepted.\n                require(getAlerts(_task)[2], \"Project::!SCConfirmed\");\n            }\n        }\n\n        // Make a call to Disputes contract raiseDisputes.\n        IDisputes(disputes).raiseDispute(_data, _signature);\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function getTask(uint256 id)\n        external\n        view\n        override\n        returns (\n            uint256 cost,\n            address subcontractor,\n            TaskStatus state\n        )\n    {\n        cost = tasks[id].cost;\n        subcontractor = tasks[id].subcontractor;\n        state = tasks[id].state;\n    }\n\n    /// @inheritdoc IProject\n    function changeOrderedTask()\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _changeOrderedTask;\n    }\n\n    /*******************************************************************************\n     * ----------------------------PUBLIC TRANSACTIONS---------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function allocateFunds() public override {\n        // Max amount out times this loop will run\n        // This is to ensure the transaction do not run out of gas (max gas limit)\n        uint256 _maxLoop = 50;\n\n        // Difference of totalLent and totalAllocated is what can be used to allocate new tasks\n        uint256 _costToAllocate = totalLent - totalAllocated;\n\n        // Bool if max loop limit is exceeded\n        bool _exceedLimit;\n\n        // Local instance of lastAllocatedChangeOrderTask. To save gas.\n        uint256 i = lastAllocatedChangeOrderTask;\n\n        // Local instance of lastAllocatedTask. To save gas.\n        uint256 j = lastAllocatedTask;\n\n        // Initialize empty array in which allocated tasks will be added.\n        uint256[] memory _tasksAllocated = new uint256[](\n            taskCount - j + _changeOrderedTask.length - i\n        );\n\n        // Number of times a loop has run.\n        uint256 _loopCount;\n\n        /// CHANGE ORDERED TASK FUNDING ///\n\n        // Any tasks added to _changeOrderedTask will be allocated first\n        if (_changeOrderedTask.length > 0) {\n            // Loop from lastAllocatedChangeOrderTask to _changeOrderedTask length (until _maxLoop)\n            for (; i < _changeOrderedTask.length; i++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[_changeOrderedTask[i]].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[_changeOrderedTask[i]].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = _changeOrderedTask[i];\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all the change ordered tasks are allocated, then delete\n            // the changeOrderedTask array and reset lastAllocatedChangeOrderTask.\n            if (i == _changeOrderedTask.length) {\n                lastAllocatedChangeOrderTask = 0;\n                delete _changeOrderedTask;\n            }\n            // Else store the last allocated change order task index.\n            else {\n                lastAllocatedChangeOrderTask = i;\n            }\n        }\n\n        /// TASK FUNDING ///\n\n        // If lastAllocatedTask is lesser than taskCount, that means there are un-allocated tasks\n        if (j < taskCount) {\n            // Loop from lastAllocatedTask + 1 to taskCount (until _maxLoop)\n            for (++j; j <= taskCount; j++) {\n                // Local instance of task cost. To save gas.\n                uint256 _taskCost = tasks[j].cost;\n\n                // If _maxLoop limit is reached then stop looping\n                if (_loopCount >= _maxLoop) {\n                    _exceedLimit = true;\n                    break;\n                }\n\n                // If there is enough funds to allocate this task\n                if (_costToAllocate >= _taskCost) {\n                    // Reduce task cost from _costToAllocate\n                    _costToAllocate -= _taskCost;\n\n                    // Mark the task as allocated\n                    tasks[j].fundTask();\n\n                    // Add task to _tasksAllocated array\n                    _tasksAllocated[_loopCount] = j;\n\n                    // Increment loop counter\n                    _loopCount++;\n                }\n                // If there are not enough funds to allocate this task then stop looping\n                else {\n                    break;\n                }\n            }\n\n            // If all pending tasks are allocated store lastAllocatedTask equal to taskCount\n            if (j > taskCount) {\n                lastAllocatedTask = taskCount;\n            }\n            // If not all tasks are allocated store updated lastAllocatedTask\n            else {\n                lastAllocatedTask = --j;\n            }\n        }\n\n        // If any tasks is allocated, then emit event\n        if (_loopCount > 0) emit TaskAllocated(_tasksAllocated);\n\n        // If allocation was incomplete, then emit event\n        if (_exceedLimit) emit IncompleteAllocation();\n\n        // Update totalAllocated with all allocations\n        totalAllocated = totalLent - _costToAllocate;\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IProject\n    function projectCost() public view override returns (uint256 _cost) {\n        // Local instance of taskCount. To save gas.\n        uint256 _length = taskCount;\n\n        // Iterate over all tasks to sum their cost\n        for (uint256 _taskID = 1; _taskID <= _length; _taskID++) {\n            _cost += tasks[_taskID].cost;\n        }\n    }\n\n    /// @inheritdoc IProject\n    function getAlerts(uint256 _taskID)\n        public\n        view\n        override\n        returns (bool[3] memory _alerts)\n    {\n        return tasks[_taskID].getAlerts();\n    }\n\n    /// @inheritdoc IProject\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IProject)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Invite subcontractors for a single task. This can be called by builder or contractor.\n     * _taskList must not have a task which already has approved subcontractor.\n     \n     * @param _taskID uint256 task index\n     * @param _sc address addresses of subcontractor for the respective task\n     * @param _emitEvent whether to emit event for each sc added or not\n     */\n    function _inviteSC(\n        uint256 _taskID,\n        address _sc,\n        bool _emitEvent\n    ) internal {\n        // Revert if sc to invite is address 0\n        require(_sc != address(0), \"Project::0 address\");\n\n        // Internal call to tasks invite contractor\n        tasks[_taskID].inviteSubcontractor(_sc);\n\n        // If `_emitEvent` is true (called via changeOrder) then emit event\n        if (_emitEvent) {\n            emit SingleSCInvited(_taskID, _sc);\n        }\n    }\n\n    /**\n     * @dev Transfer excess funds back to builder wallet.\n     * Called internally in task changeOrder when new task cost is lower than older cost.\n\n     * @param _amount uint256 - amount of excess funds\n     */\n    function autoWithdraw(uint256 _amount) internal {\n        // Reduce amount from totalLent\n        totalLent -= _amount;\n\n        // Transfer amount to builder address\n        currency.safeTransfer(builder, _amount);\n\n        emit AutoWithdrawn(_amount);\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder and contractor address.\n     * Signatures must be in sequential order. First builder and then contractor.\n     * Reverts if signature do not match.\n     * If contractor is not assigned then only checks for builder signature.\n     * If contractor is assigned but not delegated then only checks for builder and contractor signature.\n     * If contractor is assigned and delegated then only checks for contractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     */\n    function checkSignature(bytes calldata _data, bytes calldata _signature)\n        internal\n    {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Check for builder's signature\n            checkSignatureValidity(builder, _hash, _signature, 0);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                //  Check contractor's signature\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for both B and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n            }\n        }\n    }\n\n    /**\n     * @dev Check if recovered signatures match with builder, contractor and subcontractor address for a task.\n     * Signatures must be in sequential order. First builder, then contractor, and then subcontractor.\n     * reverts if signatures do not match.\n     * If contractor is not assigned then only checks for builder and subcontractor signature.\n     * If contractor is assigned but not delegated then only checks for builder, contractor and subcontractor signature.\n     * If contractor is assigned and delegated then only checks for contractor and subcontractor signature.\n\n     * @param _data bytes encoded parameters\n     * @param _signature bytes appended signatures\n     * @param _taskID index of the task.\n     */\n    function checkSignatureTask(\n        bytes calldata _data,\n        bytes calldata _signature,\n        uint256 _taskID\n    ) internal {\n        // Calculate hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of subcontractor. To save gas.\n        address _sc = tasks[_taskID].subcontractor;\n\n        // When there is no contractor\n        if (contractor == address(0)) {\n            // Just check for B and SC sign\n            checkSignatureValidity(builder, _hash, _signature, 0);\n            checkSignatureValidity(_sc, _hash, _signature, 1);\n        }\n        // When there is a contractor\n        else {\n            // When builder has delegated his rights to contractor\n            if (contractorDelegated) {\n                // Check for GC and SC sign\n                checkSignatureValidity(contractor, _hash, _signature, 0);\n                checkSignatureValidity(_sc, _hash, _signature, 1);\n            }\n            // When builder has not delegated rights to contractor\n            else {\n                // Check for B, SC and GC signatures\n                checkSignatureValidity(builder, _hash, _signature, 0);\n                checkSignatureValidity(contractor, _hash, _signature, 1);\n                checkSignatureValidity(_sc, _hash, _signature, 2);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev Checks if the signature is approved or recovered\n     * @dev Reverts if not\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal {\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Project::invalid signature\"\n        );\n        // delete from approvedHash\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * -------------------------------INTERNAL PURE------------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev Check if precision is greater than 1000, if so, it reverts\n\n     * @param _amount amount needed to be checked for precision.\n     */\n    function checkPrecision(uint256 _amount) internal pure {\n        // Divide and multiply amount with 1000 should be equal to amount.\n        // This ensures the amount is not too precise.\n        require(\n            ((_amount / 1000) * 1000) == _amount,\n            \"Project::Precision>=1000\"\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {IDisputes} from \"./interfaces/IDisputes.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/**\n * @title Disputes Contract for HomeFi v2.5.0\n\n * @dev Module for raising disputes for arbitration within HomeFi projects\n */\ncontract Disputes is\n    IDisputes,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    /*******************************************************************************\n     * -------------------------PUBLIC STORED PROPERTIES-------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    IHomeFi public override homeFi;\n    /// @inheritdoc IDisputes\n    uint256 public override disputeCount; //starts from 0\n    /// @inheritdoc IDisputes\n    mapping(uint256 => Dispute) public override disputes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00)\n        require(_address != address(0), \"Disputes::0 address\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        // Revert if sender is not HomeFi admin\n        // Only HomeFi admin can resolve dispute\n        require(homeFi.admin() == _msgSender(), \"Disputes::!Admin\");\n        _;\n    }\n\n    modifier onlyProject() {\n        // Revert if project not originated of HomeFi\n        require(homeFi.isProjectExist(_msgSender()), \"Disputes::!Project\");\n        _;\n    }\n\n    /**\n     * Affirm that a given dispute is currently resolvable\n     * @param _disputeID uint256 - the serial/id of the dispute\n     */\n    modifier resolvable(uint256 _disputeID) {\n        require(\n            _disputeID < disputeCount &&\n                disputes[_disputeID].status == Status.Active,\n            \"Disputes::!Resolvable\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        homeFi = IHomeFi(_homeFi);\n    }\n\n    /// @inheritdoc IDisputes\n    function raiseDispute(bytes calldata _data, bytes calldata _signature)\n        external\n        override\n        onlyProject\n    {\n        // Recover signer from signature\n        address _signer = SignatureDecoder.recoverKey(\n            keccak256(_data),\n            _signature,\n            0\n        );\n\n        // Decode params from _data\n        (\n            address _project,\n            uint256 _taskID,\n            uint8 _actionType,\n            bytes memory _actionData,\n            bytes memory _reason\n        ) = abi.decode(_data, (address, uint256, uint8, bytes, bytes));\n\n        // Revert if _actionType is invalid\n        require(\n            _actionType > 0 && _actionType <= uint8(ActionType.TaskPay),\n            \"Disputes::!ActionType\"\n        );\n\n        // Store dispute details\n        Dispute storage _dispute = disputes[disputeCount];\n        _dispute.status = Status.Active;\n        _dispute.project = _project;\n        _dispute.taskID = _taskID;\n        _dispute.raisedBy = _signer;\n        _dispute.actionType = ActionType(_actionType);\n        _dispute.actionData = _actionData;\n\n        // Increment dispute counter and emit event\n        emit DisputeRaised(disputeCount++, _reason);\n    }\n\n    /// @inheritdoc IDisputes\n    function attachDocument(uint256 _disputeID, bytes calldata _attachment)\n        external\n        override\n        resolvable(_disputeID)\n    {\n        // Local instance of variable. For saving gas.\n        Dispute storage _dispute = disputes[_disputeID];\n\n        // Check if sender is related to dispute\n        assertMember(_dispute.project, _dispute.taskID, _msgSender());\n\n        // Emit _attachment in event. To save it in logs.\n        emit DisputeAttachmentAdded(_disputeID, _msgSender(), _attachment);\n    }\n\n    /// @inheritdoc IDisputes\n    function resolveDispute(\n        uint256 _disputeID,\n        bytes calldata _judgement,\n        bool _ratify\n    ) external override onlyAdmin nonReentrant resolvable(_disputeID) {\n        // If dispute is accepted\n        if (_ratify) {\n            // Complete dispute actions\n            resolveHandler(_disputeID);\n\n            // Mark dispute as accepted\n            disputes[_disputeID].status = Status.Accepted;\n        }\n        // If dispute is rejected\n        else {\n            // Mark dispute as rejected\n            disputes[_disputeID].status = Status.Rejected;\n        }\n\n        emit DisputeResolved(_disputeID, _ratify, _judgement);\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc IDisputes\n    function assertMember(\n        address _project,\n        uint256 _taskID,\n        address _address\n    ) public view override {\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Get task subcontractor\n        (, address _sc, ) = _projectInstance.getTask(_taskID);\n\n        // Revert is signer is not builder, contractor or subcontractor.\n        bool _result = _projectInstance.builder() == _address ||\n            _projectInstance.contractor() == _address ||\n            _sc == _address;\n        require(_result, \"Disputes::!Member\");\n    }\n\n    /// @inheritdoc IDisputes\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, IDisputes)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @notice Given an id, attempt to execute the action to enforce the arbitration\n\n     * @notice logic for decoding and enforcing outcome of arbitration judgement\n\n     * @param _disputeID uint256 - the dispute to attempt to\n     */\n    function resolveHandler(uint256 _disputeID) internal {\n        // Local instance of variable. For saving gas.\n        Dispute storage dispute = disputes[_disputeID];\n\n        // If action type is add task then execute add task\n        if (dispute.actionType == ActionType.TaskAdd) {\n            executeTaskAdd(dispute.project, dispute.actionData);\n        }\n        // If action type is task change then execute task change\n        else if (dispute.actionType == ActionType.TaskChange) {\n            executeTaskChange(dispute.project, dispute.actionData);\n        }\n        // Else execute task pay\n        else {\n            executeTaskPay(dispute.project, dispute.actionData);\n        }\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task add transaction data stored when dispute was raised\n     * - _hash bytes[] - bytes IPFS hash of task details\n     * - _taskCosts uint256[] - an array of cost for each task index\n     * - _taskCount uint256 - current task count before adding these tasks. Can be fetched by taskCount.\n     *   For signature security.\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskAdd(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).addTasks(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task change orders\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task change order transaction data stored when dispute was raised\n     * - _taskID uint256 - index of the task\n     * - _newSC address - address of new subcontractor.\n     *   If do not want to replace subcontractor, then pass address of existing subcontractor.\n     * - _newCost uint256 - new cost for the task.\n     *   If do not want to change cost, then pass existing cost.\n     * - _project address - address of project\n     */\n    function executeTaskChange(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).changeOrder(_actionData, bytes(\"\"));\n    }\n\n    /**\n     * @dev Arbitration enforcement of task payout\n\n     * @param _project address - the project address of the dispute\n     * @param _actionData bytes - the task payout transaction data stored when dispute was raised\n     * - _taskID uint256 - the index of task\n     * - _projectAddress address - the address of this contract. For signature security.\n     */\n    function executeTaskPay(address _project, bytes memory _actionData)\n        internal\n    {\n        IProject(_project).setComplete(_actionData, bytes(\"\"));\n    }\n}\n\n\n",
        "CodeNames": [
            "Project.sol",
            "Disputes.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Project.sol#L498-L502, Disputes.sol#L84-L122",
                "Type": "Authorization",
                "Description": "The current implementation does not properly implement authorization, thus anyone is able to create disputes and spam the system with invalid disputes.",
                "Repair": "Check the recovered signer address in Project.raiseDispute to not equal the zero-address"
            }
        ]
    }
]