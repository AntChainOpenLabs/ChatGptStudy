[
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nabstract contract ERC721Payable {\n  uint256 public mintFee;\n  IERC20 public payableToken;\n  bool public isForSale;\n  address public royaltyVault;\n  address public splitFactory;\n  event NewPayment(\n    address from,\n    address to,\n    uint256 amount,\n    bool royaltyVaultPayment\n  );\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyVaultUninitialized() {\n    require(\n      !royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault already initialized'\n    );\n    _;\n  }\n\n  modifier onlyVaultInitialized() {\n    require(\n      royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault not initialized'\n    );\n    _;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function royaltyVaultInitialized() public view returns (bool) {\n    return royaltyVault != address(0);\n  }\n\n  // ---------------- INTERNAL ----------------\n\n  /**\n   * @notice Handles the transfer of ERC20 tokens when a token gets minted\n   * @dev Tokens are transferred to the Royalty Vault if the vault is set\n   * Otherwise, tokens get transferred to the ERC721 collection contract\n   * @param _amount The amount of ERC20 to be transferred\n   */\n  function _handlePayment(uint256 _amount) internal {\n    address recipient = royaltyVaultInitialized()\n      ? royaltyVault\n      : address(this);\n    payableToken.transferFrom(msg.sender, recipient, _amount);\n    emit NewPayment(msg.sender, recipient, _amount, royaltyVaultInitialized());\n  }\n}\n\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\n\ncontract CoreCollection is\n    Ownable,\n    ERC721Claimable,\n    ERC721Enumerable,\n    ERC721Payable\n{\n    bool public initialized;\n    string private _name;\n    string private _symbol;\n    string private _baseUri;\n    uint256 public maxSupply;\n    uint256 public startingIndex;\n    uint256 public startingIndexBlock;\n    string public HASHED_PROOF = \"\";\n\n    event ClaimInitialized(bytes32 root);\n    event NewCollectionMeta(string name, string symbol);\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\n    event StartingIndexSet(uint256 index);\n    event RoyaltyVaultInitialized(address royaltyVault);\n    event NewHashedProof(string proof);\n    event NewWithdrawal(address to, uint256 amount);\n\n    constructor() ERC721(\"\", \"\") {}\n\n    // ----------------- MODIFIER -----------------\n\n    modifier onlyInitialized() {\n        require(initialized, \"CoreCollection: Not initialized\");\n        _;\n    }\n\n    modifier onlyUnInitialized() {\n        require(!initialized, \"CoreCollection: Already initialized\");\n        _;\n    }\n\n    modifier onlyValidSupply(uint256 _maxSupply) {\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n        _;\n    }\n\n    modifier tokenExists(uint256 _tokenId) {\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\n        _;\n    }\n\n    // ----------------- EXTERNAL -----------------\n\n    /**\n     * @notice Initializes the collection\n     * @dev This method is being called from the CoreFactory contract\n     * @param _collectionName Name of the collection\n     * @param _collectionSymbol Symbol of the collection\n     * @param _collectionURI Base URI for the collection\n     * @param _maxSupply The maximum number of tokens that can be minted\n     * @param _mintFee The price of a token in this collection\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\n     * @param _splitFactory base URI for the collection\n     */\n    function initialize(\n        string memory _collectionName,\n        string memory _collectionSymbol,\n        string memory _collectionURI,\n        uint256 _maxSupply,\n        uint256 _mintFee,\n        address _payableToken,\n        bool _isForSale,\n        address _splitFactory\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        _baseUri = _collectionURI;\n        maxSupply = _maxSupply;\n        mintFee = _mintFee;\n        payableToken = IERC20(_payableToken);\n        isForSale = _isForSale;\n        splitFactory = _splitFactory;\n        initialized = true;\n    }\n\n    /**\n     * @notice Allows the collection owner to airdrop tokens\n     * @dev The Merkle tree defines for each address how much token can be claimed\n     * @dev This method can only be called once\n     * @param _root A Merkle root\n     */\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n    {\n        _setMerkelRoot(_root);\n        emit ClaimInitialized(_root);\n    }\n\n    /**\n     * @notice Allows the collection owner to change the collection's name and symbol\n     * @dev This function is only callable by the collection's owner\n     * @param _collectionName A collection name\n     * @param _collectionSymbol A collection symbol\n     */\n    function setCollectionMeta(\n        string memory _collectionName,\n        string memory _collectionSymbol\n    ) external onlyOwner {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\n    }\n\n    /**\n     * @notice This function is called to mint tokens from this ERC721 collection\n     * @dev The collection must be initialized first\n     * @param to Token recipient\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\n     * @param claimableAmount The amount of tokens the user has been airdropped\n     * @param amount The amount of tokens the user wants to mint\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\n     */\n    function mintToken(\n        address to,\n        bool isClaim,\n        uint256 claimableAmount,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external onlyInitialized {\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n        require(\n            totalSupply() + amount <= maxSupply,\n            \"CoreCollection: Over Max Supply\"\n        );\n\n        if (isClaim) {\n            require(claimableSet(), \"CoreCollection: No claimable\");\n            require(\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\n                \"CoreCollection: Can't claim\"\n            );\n            _claim(msg.sender, amount);\n        } else {\n            require(isForSale, \"CoreCollection: Not for sale\");\n            if (mintFee > 0) {\n                _handlePayment(mintFee * amount);\n            }\n        }\n\n        batchMint(to, amount, isClaim);\n    }\n\n    /**\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\n     */\n    function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.transferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Set royalty vault address for collection\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \n     * from the collection are transferred to the vault when the vault is initialized\n     * @param _royaltyVault The address of the royalty vault\n     */\n    function setRoyaltyVault(address _royaltyVault)\n        external\n        onlyVaultUninitialized\n    {\n        require(\n            msg.sender == splitFactory || msg.sender == owner(),\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\n        );\n        royaltyVault = _royaltyVault;\n        emit RoyaltyVaultInitialized(_royaltyVault);\n    }\n\n    /**\n     * @notice Set a provenance hash\n     * @dev This hash is used to verify the minting ordering of a collection (\u00e0 la BAYC)\n     * This hash is generated off-chain\n     * @param _proof The SHA256 generated hash\n     */\n    function setHashedProof(string calldata _proof) external onlyOwner {\n        require(\n            bytes(HASHED_PROOF).length == 0,\n            \"CoreCollection: Hashed Proof is set\"\n        );\n\n        HASHED_PROOF = _proof;\n        emit NewHashedProof(_proof);\n    }\n\n    // ----------------- PUBLIC -----------------\n\n    /**\n     * @notice Set the mint starting index\n     * @dev The starting index can only be generated once\n     */\n    function setStartingIndex() public {\n        require(\n            startingIndex == 0,\n            \"CoreCollection: Starting index is already set\"\n        );\n\n        startingIndex =\n            (uint256(\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\n            ) % maxSupply) +\n            1;\n        startingIndexBlock = uint256(block.number);\n        emit StartingIndexSet(startingIndex);\n    }\n\n    // ---------------- VIEW ----------------\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseUri;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return _baseUri;\n    }\n\n    // ---------------- PRIVATE ----------------\n\n    /**\n     * @notice Mint token\n     * @dev A starting index is calculated at the time of first mint\n     * returns a tokenId\n     * @param _to Token recipient\n     */\n    function mint(address _to) private returns (uint256 tokenId) {\n        if (startingIndex == 0) {\n            setStartingIndex();\n        }\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\n        _mint(_to, tokenId);\n    }\n\n    /**\n     * @notice Mint tokens in batch\n     * @param _to Token recipient\n     * @param _amount Number of tokens to include in batch\n     * @param _isClaim Whether the batch mint is an airdrop or not\n     */\n    function batchMint(\n        address _to,\n        uint256 _amount,\n        bool _isClaim\n    ) private {\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 tokenId = mint(_to);\n            if (_isClaim) {\n                emit NewClaim(msg.sender, _to, tokenId);\n            }\n        }\n    }\n\n    // ---------------- INTERNAL ----------------\n\n    /**\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\n     * @dev The split contract is a contract that allows a team to share revenue together\n     * @param _from Transfer sender\n     * @param _to Transfer recipient\n     * @param _tokenId TokenId of token being transferred\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _tokenId);\n\n        if (\n            royaltyVault != address(0) &&\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\n        ) {\n            IRoyaltyVault(royaltyVault).sendToSplitter();\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "ERC721Payable.sol",
            "CoreCollection.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CoreCollection.sol and ERC721Payable.sol contracts",
                "Type": "Not handling return value",
                "Description": "Not handling return value of transferFrom command can create inconsistency",
                "Repair": "Add a require statement to check the return value of transferFrom command"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "transferFrom() function",
                "Type": "ERC20 transferFrom return values not checked",
                "Description": "ERC20 transferFrom return values not checked",
                "Repair": "Check the success boolean of all transferFrom() calls or use OZ\u2019s SafeERC20\u2019s safeTransferFrom() function"
            },
            {
                "Location": "predictStartingIndexes() function in FortuneTeller.sol",
                "Type": "Gameable NFT Launches",
                "Description": "The pseudo-random generation of the starting index for NFT launches can be gamed/exploited.",
                "Repair": "Explore the use of commit-reveal schemes or VRFs to generate the starting index for NFT launches."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IRoyaltyVault} from \"../interfaces/IRoyaltyVault.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\nimport {ISplitter} from \"../interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {\n    /**** Events ****/\n    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);\n    event FeeSentToPlatform(\n        address indexed platformFeeRecipient,\n        uint256 amount\n    );\n    event NewRoyaltyVaultPlatformFee(uint256 platformFee);\n    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);\n\n    /**\n     * @dev Getting royaltyAsset balance of Vault.\n     */\n    function getVaultBalance() public view override returns (uint256) {\n        return IERC20(royaltyAsset).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Send accumulated royalty to splitter.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n        require(splitterProxy != address(0), \"Splitter is not set\");\n\n        uint256 platformShare = (balanceOfVault * platformFee) / 10000;\n        uint256 splitterShare = balanceOfVault - platformShare;\n\n        require(\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n            \"Failed to transfer royalty Asset to splitter\"\n        );\n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n        require(\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n            \"Failed to transfer royalty Asset to platform fee recipient\"\n        );\n\n        emit RoyaltySentToSplitter(splitterProxy, splitterShare);\n        emit FeeSentToPlatform(platformFeeRecipient, platformShare);\n    }\n\n    /**\n     * @dev Set Platform fee for collection contract.\n     * @param _platformFee Platform fee in scaled percentage.\n     */\n    function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n        platformFee = _platformFee;\n        emit NewRoyaltyVaultPlatformFee(_platformFee);\n    }\n\n    /**\n     * @dev Set Platform fee recipient for collection.\n     * @param _platformFeeRecipient Platform fee recipient address\n     */\n    function setPlatformFeeRecipient(address _platformFeeRecipient)\n        external\n        override\n        onlyOwner\n    {\n        platformFeeRecipient = _platformFeeRecipient;\n        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);\n    }\n\n    /**\n     * @dev Get Splitter address of proxyVault.\n     */\n    function getSplitter() public view override returns (address) {\n        return splitterProxy;\n    }\n\n    /**\n     * @dev Checks for support of IRoyaltyVault.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IRoyaltyVault, ERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IRoyaltyVault).interfaceId;\n    }\n}\n\n\n",
        "CodeNames": [
            "RoyaltyVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RoyaltyVault.sol contract",
                "Type": "ERC20 tokens with no return value",
                "Description": "ERC20 tokens with no return value will fail to transfer",
                "Repair": "Use SafeERC20"
            },
            {
                "Location": "setPlatformFee() function in RoyaltyVault.sol",
                "Type": "Centralization Risk",
                "Description": "The owner of RoyaltyVault can set platformFee to any arbitrary value and steal the entire contract balance and any future balances avoiding the splitter.",
                "Repair": "Add a maximum value for the platformFee or only allow the fee to be reduced. Protect NFT holders by ensuring platformFee cannot be set to a value that would cause sendToSplitter() to fail or don't have sendToSplitter() be called on NFT transfers. Protect royalty split recipients by putting an arbitrary max to the fee."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SplitStorage} from \"./SplitStorage.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Splitter\n * Building on the work from the Uniswap team at Uniswap and Mirror.xyz Team\n */\ncontract Splitter is SplitStorage {\n    /**** Mutable variables ****/\n    uint256 public constant PERCENTAGE_SCALE = 10e5;\n    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;\n\n    // The TransferETH event is emitted after each eth transfer in the split is attempted.\n    event TransferETH(\n        // The account to which the transfer was attempted.\n        address account,\n        // The amount for transfer that was attempted.\n        uint256 amount,\n        // Whether or not the transfer succeeded.\n        bool success\n    );\n\n    // Emits when a window is incremented.\n    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);\n\n    /**\n     * @dev Claim the funds from the all windows.\n     * @param percentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claimForAllWindows(\n        uint256 percentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        // Make sure that the user has this allocation granted.\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, percentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        uint256 amount = 0;\n        for (uint256 i = 0; i < currentWindow; i++) {\n            if (!isClaimed(msg.sender, i)) {\n                setClaimed(msg.sender, i);\n\n                amount += scaleAmountByPercentage(\n                    balanceForWindow[i],\n                    percentageAllocation\n                );\n            }\n        }\n\n        transferSplitAsset(msg.sender, amount);\n    }\n\n    /**\n     * @dev get Node hash of given data.\n     * @param who {address} whitelisted user address\n     * @param percentageAllocation {uint256} percentage of allocation\n     * @return {bytes32} node hash\n     */\n    function getNode(\n        address who,\n        uint256 percentageAllocation\n    ) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    who,\n                    percentageAllocation\n                )\n            );\n    }\n\n    /**\n     * @dev get scaled amount from given amount and percentage.\n     * @param amount {uint256} amount\n     * @param scaledPercent {uint256} scaled percentage\n     * @return scaledAmount {uint256} scaled amount\n     */\n    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)\n        public\n        pure\n        returns (uint256 scaledAmount)\n    {\n        /*\n            Example:\n                If there is 100 ETH in the account, and someone has \n                an allocation of 2%, we call this with 100 as the amount, and 200\n                as the scaled percent.\n\n                To find out the amount we use, for example: (100 * 200) / (100 * 100)\n                which returns 2 -- i.e. 2% of the 100 ETH balance.\n         */\n        scaledAmount = (amount * scaledPercent) / (10000);\n    }\n\n    /**\n     * @dev claim for the given window.\n     * @param window {uint256} Window to claim\n     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claim(\n        uint256 window,\n        uint256 scaledPercentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        require(currentWindow > window, \"cannot claim for a future window\");\n        require(\n            !isClaimed(msg.sender, window),\n            \"NFT has already claimed the given window\"\n        );\n\n        setClaimed(msg.sender, window);\n\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, scaledPercentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        transferSplitAsset(\n            msg.sender,\n            // The absolute amount that's claimable.\n            scaleAmountByPercentage(\n                balanceForWindow[window],\n                scaledPercentageAllocation\n            )\n        );\n    }\n\n    /**\n     * @dev Function which handles increment window and puts amount to current window\n     * @param royaltyAmount {uint256} Amount needs to be added in window.\n     * @return {bool} Whether or not the window was incremented.\n     */\n    function incrementWindow(uint256 royaltyAmount) public returns (bool) {\n        uint256 wethBalance;\n\n        require(\n            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),\n            \"Royalty Vault not supported\"\n        );\n        require(\n            IRoyaltyVault(msg.sender).getSplitter() == address(this),\n            \"Unauthorised to increment window\"\n        );\n\n        wethBalance = IERC20(splitAsset).balanceOf(address(this));\n        require(wethBalance >= royaltyAmount, \"Insufficient funds\");\n\n        require(royaltyAmount > 0, \"No additional funds for window\");\n        balanceForWindow.push(royaltyAmount);\n        currentWindow += 1;\n        emit WindowIncremented(currentWindow, royaltyAmount);\n        return true;\n    }\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bool} Whether or not the window has been claimed.\n     */\n    function isClaimed(\n        address who,\n        uint256 window\n    ) public view returns (bool) {\n        return claimed[getClaimHash(who, window)];\n    }\n\n    /**** Private Functions ****/\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     */\n    function setClaimed(\n        address who,\n        uint256 window\n    ) private {\n        claimed[getClaimHash(who, window)] = true;\n    }\n\n    /**\n     * @dev Function which returns the hash of the given window, tokenId and membershipContract.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bytes32} Hash of the given window, tokenId and membershipContract.\n     */\n    function getClaimHash(\n        address who,\n        uint256 window\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(who, window));\n    }\n\n    /**\n     * @dev Function to convert output amount from percentages.\n     * @param amount {uint256} Amount for which percentage is to be calculated.\n     * @param percent {uint256} Percentage\n     * @return {uint256} Output amount.\n     */\n    function amountFromPercent(uint256 amount, uint32 percent)\n        private\n        pure\n        returns (uint256)\n    {\n        // Solidity 0.8.0 lets us do this without SafeMath.\n        return (amount * percent) / 100;\n    }\n\n    /**\n     * @dev Function to transfer split asset to the given address.\n     * @param to {address} Address to transfer the split asset to.\n     * @param value {uint256} Amount to transfer.\n     */\n    function transferSplitAsset(address to, uint256 value)\n        private\n        returns (bool didSucceed)\n    {\n        // Try to transfer ETH to the given recipient.\n        didSucceed = IERC20(splitAsset).transfer(to, value);\n        require(didSucceed, \"Failed to transfer ETH\");\n\n        emit TransferETH(to, value, didSucceed);\n    }\n\n    /**\n     * @dev transfer given amount of ETH in contract to the given address.\n     * @param to {address} Address to transfer asset\n     * @param value {uint256} Amount to transfer\n     * @return {bool} Whether or not the transfer was successful.\n     */\n    function attemptETHTransfer(address to, uint256 value)\n        private\n        returns (bool)\n    {\n        // Here increase the gas limit a reasonable amount above the default, and try\n        // to send ETH to the recipient.\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n        (bool success, ) = to.call{value: value, gas: 30000}(\"\");\n        return success;\n    }\n\n    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol\n    /**\n     * @dev Function to verify the given proof.\n     * @param proof {bytes32[]} Proof to verify\n     * @param root {bytes32} Root of the Merkle tree\n     * @param leaf {bytes32} Leaf to verify\n     * @return {bool} Whether or not the proof is valid.\n     */\n    function verifyProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) private pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(\n                    abi.encodePacked(computedHash, proofElement)\n                );\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(\n                    abi.encodePacked(proofElement, computedHash)\n                );\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IRoyaltyVault} from \"../interfaces/IRoyaltyVault.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\nimport {ISplitter} from \"../interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {\n    /**** Events ****/\n    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);\n    event FeeSentToPlatform(\n        address indexed platformFeeRecipient,\n        uint256 amount\n    );\n    event NewRoyaltyVaultPlatformFee(uint256 platformFee);\n    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);\n\n    /**\n     * @dev Getting royaltyAsset balance of Vault.\n     */\n    function getVaultBalance() public view override returns (uint256) {\n        return IERC20(royaltyAsset).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Send accumulated royalty to splitter.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n        require(splitterProxy != address(0), \"Splitter is not set\");\n\n        uint256 platformShare = (balanceOfVault * platformFee) / 10000;\n        uint256 splitterShare = balanceOfVault - platformShare;\n\n        require(\n            IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,\n            \"Failed to transfer royalty Asset to splitter\"\n        );\n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n        require(\n            IERC20(royaltyAsset).transfer(\n                platformFeeRecipient,\n                platformShare\n            ) == true,\n            \"Failed to transfer royalty Asset to platform fee recipient\"\n        );\n\n        emit RoyaltySentToSplitter(splitterProxy, splitterShare);\n        emit FeeSentToPlatform(platformFeeRecipient, platformShare);\n    }\n\n    /**\n     * @dev Set Platform fee for collection contract.\n     * @param _platformFee Platform fee in scaled percentage.\n     */\n    function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n        platformFee = _platformFee;\n        emit NewRoyaltyVaultPlatformFee(_platformFee);\n    }\n\n    /**\n     * @dev Set Platform fee recipient for collection.\n     * @param _platformFeeRecipient Platform fee recipient address\n     */\n    function setPlatformFeeRecipient(address _platformFeeRecipient)\n        external\n        override\n        onlyOwner\n    {\n        platformFeeRecipient = _platformFeeRecipient;\n        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);\n    }\n\n    /**\n     * @dev Get Splitter address of proxyVault.\n     */\n    function getSplitter() public view override returns (address) {\n        return splitterProxy;\n    }\n\n    /**\n     * @dev Checks for support of IRoyaltyVault.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IRoyaltyVault, ERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IRoyaltyVault).interfaceId;\n    }\n}\n\n\n//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\n\ncontract CoreCollection is\n    Ownable,\n    ERC721Claimable,\n    ERC721Enumerable,\n    ERC721Payable\n{\n    bool public initialized;\n    string private _name;\n    string private _symbol;\n    string private _baseUri;\n    uint256 public maxSupply;\n    uint256 public startingIndex;\n    uint256 public startingIndexBlock;\n    string public HASHED_PROOF = \"\";\n\n    event ClaimInitialized(bytes32 root);\n    event NewCollectionMeta(string name, string symbol);\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\n    event StartingIndexSet(uint256 index);\n    event RoyaltyVaultInitialized(address royaltyVault);\n    event NewHashedProof(string proof);\n    event NewWithdrawal(address to, uint256 amount);\n\n    constructor() ERC721(\"\", \"\") {}\n\n    // ----------------- MODIFIER -----------------\n\n    modifier onlyInitialized() {\n        require(initialized, \"CoreCollection: Not initialized\");\n        _;\n    }\n\n    modifier onlyUnInitialized() {\n        require(!initialized, \"CoreCollection: Already initialized\");\n        _;\n    }\n\n    modifier onlyValidSupply(uint256 _maxSupply) {\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n        _;\n    }\n\n    modifier tokenExists(uint256 _tokenId) {\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\n        _;\n    }\n\n    // ----------------- EXTERNAL -----------------\n\n    /**\n     * @notice Initializes the collection\n     * @dev This method is being called from the CoreFactory contract\n     * @param _collectionName Name of the collection\n     * @param _collectionSymbol Symbol of the collection\n     * @param _collectionURI Base URI for the collection\n     * @param _maxSupply The maximum number of tokens that can be minted\n     * @param _mintFee The price of a token in this collection\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\n     * @param _splitFactory base URI for the collection\n     */\n    function initialize(\n        string memory _collectionName,\n        string memory _collectionSymbol,\n        string memory _collectionURI,\n        uint256 _maxSupply,\n        uint256 _mintFee,\n        address _payableToken,\n        bool _isForSale,\n        address _splitFactory\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        _baseUri = _collectionURI;\n        maxSupply = _maxSupply;\n        mintFee = _mintFee;\n        payableToken = IERC20(_payableToken);\n        isForSale = _isForSale;\n        splitFactory = _splitFactory;\n        initialized = true;\n    }\n\n    /**\n     * @notice Allows the collection owner to airdrop tokens\n     * @dev The Merkle tree defines for each address how much token can be claimed\n     * @dev This method can only be called once\n     * @param _root A Merkle root\n     */\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n    {\n        _setMerkelRoot(_root);\n        emit ClaimInitialized(_root);\n    }\n\n    /**\n     * @notice Allows the collection owner to change the collection's name and symbol\n     * @dev This function is only callable by the collection's owner\n     * @param _collectionName A collection name\n     * @param _collectionSymbol A collection symbol\n     */\n    function setCollectionMeta(\n        string memory _collectionName,\n        string memory _collectionSymbol\n    ) external onlyOwner {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\n    }\n\n    /**\n     * @notice This function is called to mint tokens from this ERC721 collection\n     * @dev The collection must be initialized first\n     * @param to Token recipient\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\n     * @param claimableAmount The amount of tokens the user has been airdropped\n     * @param amount The amount of tokens the user wants to mint\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\n     */\n    function mintToken(\n        address to,\n        bool isClaim,\n        uint256 claimableAmount,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external onlyInitialized {\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n        require(\n            totalSupply() + amount <= maxSupply,\n            \"CoreCollection: Over Max Supply\"\n        );\n\n        if (isClaim) {\n            require(claimableSet(), \"CoreCollection: No claimable\");\n            require(\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\n                \"CoreCollection: Can't claim\"\n            );\n            _claim(msg.sender, amount);\n        } else {\n            require(isForSale, \"CoreCollection: Not for sale\");\n            if (mintFee > 0) {\n                _handlePayment(mintFee * amount);\n            }\n        }\n\n        batchMint(to, amount, isClaim);\n    }\n\n    /**\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\n     */\n    function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.transferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Set royalty vault address for collection\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \n     * from the collection are transferred to the vault when the vault is initialized\n     * @param _royaltyVault The address of the royalty vault\n     */\n    function setRoyaltyVault(address _royaltyVault)\n        external\n        onlyVaultUninitialized\n    {\n        require(\n            msg.sender == splitFactory || msg.sender == owner(),\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\n        );\n        royaltyVault = _royaltyVault;\n        emit RoyaltyVaultInitialized(_royaltyVault);\n    }\n\n    /**\n     * @notice Set a provenance hash\n     * @dev This hash is used to verify the minting ordering of a collection (\u00e0 la BAYC)\n     * This hash is generated off-chain\n     * @param _proof The SHA256 generated hash\n     */\n    function setHashedProof(string calldata _proof) external onlyOwner {\n        require(\n            bytes(HASHED_PROOF).length == 0,\n            \"CoreCollection: Hashed Proof is set\"\n        );\n\n        HASHED_PROOF = _proof;\n        emit NewHashedProof(_proof);\n    }\n\n    // ----------------- PUBLIC -----------------\n\n    /**\n     * @notice Set the mint starting index\n     * @dev The starting index can only be generated once\n     */\n    function setStartingIndex() public {\n        require(\n            startingIndex == 0,\n            \"CoreCollection: Starting index is already set\"\n        );\n\n        startingIndex =\n            (uint256(\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\n            ) % maxSupply) +\n            1;\n        startingIndexBlock = uint256(block.number);\n        emit StartingIndexSet(startingIndex);\n    }\n\n    // ---------------- VIEW ----------------\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseUri;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return _baseUri;\n    }\n\n    // ---------------- PRIVATE ----------------\n\n    /**\n     * @notice Mint token\n     * @dev A starting index is calculated at the time of first mint\n     * returns a tokenId\n     * @param _to Token recipient\n     */\n    function mint(address _to) private returns (uint256 tokenId) {\n        if (startingIndex == 0) {\n            setStartingIndex();\n        }\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\n        _mint(_to, tokenId);\n    }\n\n    /**\n     * @notice Mint tokens in batch\n     * @param _to Token recipient\n     * @param _amount Number of tokens to include in batch\n     * @param _isClaim Whether the batch mint is an airdrop or not\n     */\n    function batchMint(\n        address _to,\n        uint256 _amount,\n        bool _isClaim\n    ) private {\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 tokenId = mint(_to);\n            if (_isClaim) {\n                emit NewClaim(msg.sender, _to, tokenId);\n            }\n        }\n    }\n\n    // ---------------- INTERNAL ----------------\n\n    /**\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\n     * @dev The split contract is a contract that allows a team to share revenue together\n     * @param _from Transfer sender\n     * @param _to Transfer recipient\n     * @param _tokenId TokenId of token being transferred\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _tokenId);\n\n        if (\n            royaltyVault != address(0) &&\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\n        ) {\n            IRoyaltyVault(royaltyVault).sendToSplitter();\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Splitter.sol",
            "RoyaltyVault.sol",
            "CoreCollection.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CoreCollection.sol, RoyaltyVault.sol, and Splitter.sol contracts",
                "Type": "CoreCollection's token transfer can be disabled",
                "Description": "CoreCollection's token transfer can be disabled",
                "Repair": "Try to send the fees and record the amounts not yet distributed, or introduce an action threshold to sendToSplitter() function"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {ERC721Payable} from \"./ERC721Payable.sol\";\nimport {ERC721Claimable} from \"./ERC721Claimable.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\n\ncontract CoreCollection is\n    Ownable,\n    ERC721Claimable,\n    ERC721Enumerable,\n    ERC721Payable\n{\n    bool public initialized;\n    string private _name;\n    string private _symbol;\n    string private _baseUri;\n    uint256 public maxSupply;\n    uint256 public startingIndex;\n    uint256 public startingIndexBlock;\n    string public HASHED_PROOF = \"\";\n\n    event ClaimInitialized(bytes32 root);\n    event NewCollectionMeta(string name, string symbol);\n    event NewClaim(address claimedBy, address to, uint256 tokenId);\n    event StartingIndexSet(uint256 index);\n    event RoyaltyVaultInitialized(address royaltyVault);\n    event NewHashedProof(string proof);\n    event NewWithdrawal(address to, uint256 amount);\n\n    constructor() ERC721(\"\", \"\") {}\n\n    // ----------------- MODIFIER -----------------\n\n    modifier onlyInitialized() {\n        require(initialized, \"CoreCollection: Not initialized\");\n        _;\n    }\n\n    modifier onlyUnInitialized() {\n        require(!initialized, \"CoreCollection: Already initialized\");\n        _;\n    }\n\n    modifier onlyValidSupply(uint256 _maxSupply) {\n        require(\n            _maxSupply > 0,\n            \"CoreCollection: Max supply should be greater than 0\"\n        );\n        _;\n    }\n\n    modifier tokenExists(uint256 _tokenId) {\n        require(_exists(_tokenId), \"CoreCollection: Invalid token id\");\n        _;\n    }\n\n    // ----------------- EXTERNAL -----------------\n\n    /**\n     * @notice Initializes the collection\n     * @dev This method is being called from the CoreFactory contract\n     * @param _collectionName Name of the collection\n     * @param _collectionSymbol Symbol of the collection\n     * @param _collectionURI Base URI for the collection\n     * @param _maxSupply The maximum number of tokens that can be minted\n     * @param _mintFee The price of a token in this collection\n     * @param _payableToken The address of the ERC20 this collection uses to settle transactions\n     * @param _isForSale Whether or not tokens from this collection can be purchased. If false, tokens can only be claimed\n     * @param _splitFactory base URI for the collection\n     */\n    function initialize(\n        string memory _collectionName,\n        string memory _collectionSymbol,\n        string memory _collectionURI,\n        uint256 _maxSupply,\n        uint256 _mintFee,\n        address _payableToken,\n        bool _isForSale,\n        address _splitFactory\n    ) external onlyOwner onlyValidSupply(_maxSupply) {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        _baseUri = _collectionURI;\n        maxSupply = _maxSupply;\n        mintFee = _mintFee;\n        payableToken = IERC20(_payableToken);\n        isForSale = _isForSale;\n        splitFactory = _splitFactory;\n        initialized = true;\n    }\n\n    /**\n     * @notice Allows the collection owner to airdrop tokens\n     * @dev The Merkle tree defines for each address how much token can be claimed\n     * @dev This method can only be called once\n     * @param _root A Merkle root\n     */\n    function initializeClaims(bytes32 _root)\n        external\n        onlyOwner\n        onlyNotClaimableSet\n        onlyValidRoot(_root)\n    {\n        _setMerkelRoot(_root);\n        emit ClaimInitialized(_root);\n    }\n\n    /**\n     * @notice Allows the collection owner to change the collection's name and symbol\n     * @dev This function is only callable by the collection's owner\n     * @param _collectionName A collection name\n     * @param _collectionSymbol A collection symbol\n     */\n    function setCollectionMeta(\n        string memory _collectionName,\n        string memory _collectionSymbol\n    ) external onlyOwner {\n        _name = _collectionName;\n        _symbol = _collectionSymbol;\n        emit NewCollectionMeta(_collectionName, _collectionSymbol);\n    }\n\n    /**\n     * @notice This function is called to mint tokens from this ERC721 collection\n     * @dev The collection must be initialized first\n     * @param to Token recipient\n     * @param isClaim Whether the user want claim a token that has been airdropped to him or want to purchase the token\n     * @param claimableAmount The amount of tokens the user has been airdropped\n     * @param amount The amount of tokens the user wants to mint\n     * @param merkleProof A merkle proof. Needed to verify if the user can claim a token\n     */\n    function mintToken(\n        address to,\n        bool isClaim,\n        uint256 claimableAmount,\n        uint256 amount,\n        bytes32[] calldata merkleProof\n    ) external onlyInitialized {\n        require(amount > 0, \"CoreCollection: Amount should be greater than 0\");\n        require(\n            totalSupply() + amount <= maxSupply,\n            \"CoreCollection: Over Max Supply\"\n        );\n\n        if (isClaim) {\n            require(claimableSet(), \"CoreCollection: No claimable\");\n            require(\n                canClaim(msg.sender, claimableAmount, amount, merkleProof),\n                \"CoreCollection: Can't claim\"\n            );\n            _claim(msg.sender, amount);\n        } else {\n            require(isForSale, \"CoreCollection: Not for sale\");\n            if (mintFee > 0) {\n                _handlePayment(mintFee * amount);\n            }\n        }\n\n        batchMint(to, amount, isClaim);\n    }\n\n    /**\n     * @notice Allows the contract owner to withdraw the funds generated by the token sales\n     * @dev If a royalty vault isn't set, tokens are kept within this contract and can be withdrawn by the token owner\n     */\n    function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.transferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n    }\n\n    /**\n     * @notice Set royalty vault address for collection\n     * @dev All revenue (Primary sales + royalties from secondardy sales) \n     * from the collection are transferred to the vault when the vault is initialized\n     * @param _royaltyVault The address of the royalty vault\n     */\n    function setRoyaltyVault(address _royaltyVault)\n        external\n        onlyVaultUninitialized\n    {\n        require(\n            msg.sender == splitFactory || msg.sender == owner(),\n            \"CoreCollection: Only Split Factory or owner can initialize vault.\"\n        );\n        royaltyVault = _royaltyVault;\n        emit RoyaltyVaultInitialized(_royaltyVault);\n    }\n\n    /**\n     * @notice Set a provenance hash\n     * @dev This hash is used to verify the minting ordering of a collection (\u00e0 la BAYC)\n     * This hash is generated off-chain\n     * @param _proof The SHA256 generated hash\n     */\n    function setHashedProof(string calldata _proof) external onlyOwner {\n        require(\n            bytes(HASHED_PROOF).length == 0,\n            \"CoreCollection: Hashed Proof is set\"\n        );\n\n        HASHED_PROOF = _proof;\n        emit NewHashedProof(_proof);\n    }\n\n    // ----------------- PUBLIC -----------------\n\n    /**\n     * @notice Set the mint starting index\n     * @dev The starting index can only be generated once\n     */\n    function setStartingIndex() public {\n        require(\n            startingIndex == 0,\n            \"CoreCollection: Starting index is already set\"\n        );\n\n        startingIndex =\n            (uint256(\n                keccak256(abi.encodePacked(\"CoreCollection\", block.number))\n            ) % maxSupply) +\n            1;\n        startingIndexBlock = uint256(block.number);\n        emit StartingIndexSet(startingIndex);\n    }\n\n    // ---------------- VIEW ----------------\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function baseURI() public view returns (string memory) {\n        return _baseUri;\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return _baseUri;\n    }\n\n    // ---------------- PRIVATE ----------------\n\n    /**\n     * @notice Mint token\n     * @dev A starting index is calculated at the time of first mint\n     * returns a tokenId\n     * @param _to Token recipient\n     */\n    function mint(address _to) private returns (uint256 tokenId) {\n        if (startingIndex == 0) {\n            setStartingIndex();\n        }\n        tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;\n        _mint(_to, tokenId);\n    }\n\n    /**\n     * @notice Mint tokens in batch\n     * @param _to Token recipient\n     * @param _amount Number of tokens to include in batch\n     * @param _isClaim Whether the batch mint is an airdrop or not\n     */\n    function batchMint(\n        address _to,\n        uint256 _amount,\n        bool _isClaim\n    ) private {\n        for (uint256 i = 0; i < _amount; i++) {\n            uint256 tokenId = mint(_to);\n            if (_isClaim) {\n                emit NewClaim(msg.sender, _to, tokenId);\n            }\n        }\n    }\n\n    // ---------------- INTERNAL ----------------\n\n    /**\n     * @notice This hook transfers tokens sitting in the royalty vault to the split contract\n     * @dev The split contract is a contract that allows a team to share revenue together\n     * @param _from Transfer sender\n     * @param _to Transfer recipient\n     * @param _tokenId TokenId of token being transferred\n     */\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(_from, _to, _tokenId);\n\n        if (\n            royaltyVault != address(0) &&\n            IRoyaltyVault(royaltyVault).getVaultBalance() > 0\n        ) {\n            IRoyaltyVault(royaltyVault).sendToSplitter();\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "CoreCollection.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CoreCollection.initialize function",
                "Type": "Reinitialization",
                "Description": "Reinitialization is possible for CoreCollection as initialize function sets initialized flag, but doesn't control for it, so the function can be rerun multiple times.",
                "Repair": "Add onlyUnInitialized modifier to the initialize function"
            },
            {
                "Location": "CoreCollection.mintToken function",
                "Type": "Duplicate NFTs",
                "Description": "Duplicate NFTs can be minted if payableToken has a callback attached to it.",
                "Repair": "Add reentrancy protections to prevent users from abusing this behaviour. It may also be useful to follow the checks-effects pattern such that all external/state changing calls are made at the end."
            },
            {
                "Location": "CoreCollection.setRoyaltyVault function",
                "Type": "Permanent Lock of PayableTokens",
                "Description": "CoreCollection.setRoyaltyVault doesn't check royaltyVault.royaltyAsset against payableToken, resulting in potential permanent lock of payableTokens in royaltyVault.",
                "Repair": "While assigning vaults to CoreProxy, check if payableToken is the same as royaltyVault.royaltyAsset"
            },
            {
                "Location": "CoreCollection.setRoyaltyVault function",
                "Type": "Mismatched Token Pairing",
                "Description": "CoreProxy paired with an incompatible RoyaltyVault might result in minting tokens being permanently stuck in RoyaltyVault.",
                "Repair": "While assigning vaults to CoreProxy, check if payableToken is the same as royaltyVault.royaltyAsset"
            },
            {
                "Location": "CoreCollection.withdraw function",
                "Type": "Incorrect use of transferFrom",
                "Description": "The usage of transferFrom can result in serious issues. In this case, the call to the withdraw function will revert as the allowance[CoreCollection][CoreCollection] == 0 and therefore the funds cannot be withdrawn and will be locked forever in the contract.",
                "Repair": "Replace transferFrom with transfer"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {ICoreFactory} from \"../interfaces/ICoreFactory.sol\";\n\ncontract CoreProxy is Ownable {\n    address private immutable _implement;\n\n    constructor(address _imp) {\n        _implement = _imp;\n    }\n\n    fallback() external {\n        address _impl = implement();\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n\n    function implement() public view returns (address) {\n        return _implement;\n    }\n}\n\n\n",
        "CodeNames": [
            "CoreProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CoreProxy contract",
                "Type": "Storage Collision",
                "Description": "Storage collision because of lack of EIP1967 could cause conflicts and override sensible variables.",
                "Repair": "Use EIP1967 to set proxy variables at fixed positions to avoid storage conflicts"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {CoreProxy} from './CoreProxy.sol';\nimport './utils/structs/Collection.sol';\nimport {CoreCollection} from './CoreCollection.sol';\nimport {ICoreCollection} from '../interfaces/ICoreCollection.sol';\n\ncontract CoreFactory {\n  struct Project {\n    string id;\n    address creator;\n  }\n\n  event NewProject(string id, address creator);\n  event NewCollection(\n    string collectionId,\n    address collection,\n    string projectId\n  );\n\n  address public immutable collection;\n  address public immutable splitFactory;\n  mapping(string => Project) public projects;\n  mapping(string => address) public collections;\n\n  constructor(address _collection, address _splitFactory) {\n    collection = _collection;\n    splitFactory = _splitFactory;\n  }\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyAvailableProject(string memory _projectId) {\n    require(\n      projects[_projectId].creator == address(0),\n      'CoreFactory: Unavailable project id'\n    );\n    _;\n  }\n\n  modifier onlyProjectOwner(string memory _projectId) {\n    require(\n      projects[_projectId].creator == msg.sender,\n      'CoreFactory: Not an owner of the project'\n    );\n    _;\n  }\n\n  modifier onlyAvailableCollection(string memory _collectionId) {\n    require(\n      collections[_collectionId] == address(0),\n      'CoreFactory: Unavailable collection id'\n    );\n    _;\n  }\n\n  // ---------------- EXTERNAL ----------------\n\n  /**\n   * @notice Allows to create a project as well as deploy its collection(s)\n   * For adding a collection to a project, use the addCollection() method.\n   * @dev Projects have unique identifiers.\n   * Collections are deployed using a proxy pattern. This is mainly for gas optimization purposes\n   * and to support future contract upgrades.\n   * Collections ownership are transferred to the caller.\n   * @param _projectId Project id which is a unique identifier\n   * @param _collections An array of Collection that needs to be deployed\n   */\n  function createProject(\n    string memory _projectId,\n    Collection[] memory _collections\n  ) external onlyAvailableProject(_projectId) {\n    require(\n      _collections.length > 0,\n      'CoreFactory: should have more at least one collection'\n    );\n\n    for (uint256 i; i < _collections.length; i++) {\n      Collection memory _collection = _collections[i];\n      address coreCollection = _createCollection(_collection);\n\n      if (_collection.claimsMerkleRoot != bytes32(0)) {\n        ICoreCollection(coreCollection).initializeClaims(\n          _collection.claimsMerkleRoot\n        );\n      }\n\n      emit NewCollection(_collection.id, coreCollection, _projectId);\n\n      ICoreCollection(coreCollection).transferOwnership(msg.sender);\n    }\n    Project memory project;\n    project.id = _projectId;\n    project.creator = msg.sender;\n    projects[_projectId] = project;\n\n    emit NewProject(_projectId, msg.sender);\n  }\n\n  /**\n   * @notice Allows to add a collection to a project\n   * @dev Can only be called by project creator\n   * Collection's ownership is transferred to the caller\n   * @param _projectId Project id which is a unique identifier\n   * @param _collection Collection that needs to be deployed\n   */\n  function addCollection(\n    string memory _projectId,\n    Collection memory _collection\n  ) external onlyProjectOwner(_projectId) returns (address) {\n    address coreCollection = _createCollection(_collection);\n\n    if (_collection.claimsMerkleRoot != bytes32(0)) {\n      ICoreCollection(coreCollection).initializeClaims(\n        _collection.claimsMerkleRoot\n      );\n    }\n\n    emit NewCollection(_collection.id, coreCollection, _projectId);\n\n    ICoreCollection(coreCollection).transferOwnership(msg.sender);\n    return coreCollection;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function getProject(string memory _projectId)\n    external\n    view\n    returns (Project memory)\n  {\n    return projects[_projectId];\n  }\n\n  // ---------------- PRIVATE ----------------\n\n  /**\n   * @notice Instanciates/Deploys a collection\n   * @param _collection Collection that needs to be deployed\n   */\n  function _createCollection(Collection memory _collection)\n    private\n    onlyAvailableCollection(_collection.id)\n    returns (address)\n  {\n    address coreCollection = address(\n      new CoreProxy{salt: keccak256(abi.encodePacked(_collection.id))}(\n        collection\n      )\n    );\n\n    ICoreCollection(coreCollection).initialize(\n      _collection.name,\n      _collection.symbol,\n      _collection.baseURI,\n      _collection.maxSupply,\n      _collection.mintFee,\n      _collection.payableToken,\n      _collection.isForSale,\n      splitFactory\n    );\n\n    collections[_collection.id] = coreCollection;\n    return coreCollection;\n  }\n}\n\n\n",
        "CodeNames": [
            "CoreFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "createProject function in CoreFactory.sol",
                "Type": "Frontrunning",
                "Description": "Malicious user can frontrun and become the owner of the collection by calling createProject function.",
                "Repair": "Consider using a whitelist on project creation or ask users to sign their address and check the signature against msg.sender"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SplitStorage} from \"./SplitStorage.sol\";\n\ninterface ISplitFactory {\n    function splitter() external returns (address);\n\n    function splitAsset() external returns (address);\n\n    function merkleRoot() external returns (bytes32);\n}\n\n/**\n * @title SplitProxy\n */\ncontract SplitProxy is SplitStorage {\n    constructor() {\n        _splitter = ISplitFactory(msg.sender).splitter();\n        splitAsset = ISplitFactory(msg.sender).splitAsset();\n        merkleRoot = ISplitFactory(msg.sender).merkleRoot();\n    }\n\n    fallback() external payable {\n        address _impl = splitter();\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 {\n                revert(ptr, size)\n            }\n            default {\n                return(ptr, size)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the address of the splitter contract.\n     * @return address\n     */\n    function splitter() public view returns (address) {\n        return _splitter;\n    }\n\n    receive() external payable {}\n}\n\n\n",
        "CodeNames": [
            "SplitProxy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "createSplit function in SplitProxy.sol",
                "Type": "DoS",
                "Description": "Attacker may front-run any createSplit transaction in the mem pool and create another createSplit transaction with a higher gas price that uses the same merkleRoot but changes the other fields.",
                "Repair": "Remove the salt parameter from the contract deployment or concatenate msg.sender to the merkleRoot"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ProxyVault} from '@chestrnft/royalty-vault/contracts/ProxyVault.sol';\nimport {SplitProxy} from './SplitProxy.sol';\nimport {IRoyaltyVault} from '@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol';\nimport {ICoreCollection} from '../interfaces/ICoreCollection.sol';\n\ncontract SplitFactory is Ownable {\n  /**** Immutable storage ****/\n\n  address public immutable splitter;\n  address public immutable royaltyVault;\n\n  /**** Mmutable storage ****/\n  // Gets set within the block, and then deleted.\n\n  bytes32 public merkleRoot;\n  address public splitAsset;\n  address public royaltyAsset;\n  address public splitterProxy;\n  uint256 public platformFee;\n  address public platformFeeRecipient;\n\n  mapping(string => address) public splits;\n\n  /**** Events ****/\n\n  event SplitCreated(address indexed splitter, string splitId);\n\n  event VaultCreated(\n    address indexed vault,\n    address indexed splitter,\n    uint256 platformFee,\n    address platformFeeRecipient\n  );\n\n  event VaultAssignedToCollection(\n    address indexed vault,\n    address indexed splitter,\n    address indexed collectionContract\n  );\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyAvailableSplit(string memory _splitId) {\n    require(\n      splits[_splitId] == address(0),\n      'SplitFactory : Split ID already in use'\n    );\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   * @param _splitter The address of the Splitter contract.\n   */\n  constructor(address _splitter, address _royaltyVault) {\n    splitter = _splitter;\n    royaltyVault = _royaltyVault;\n    platformFee = 500; // 5%\n    platformFeeRecipient = 0x70388C130222eae55a0527a2367486bF5D12d6e7;\n  }\n\n  // ---------------- EXTERNAL ----------------\n\n  /**\n   * @dev Deploys a new SplitProxy and initializes collection's royalty vault.\n   * @param _merkleRoot The merkle root of the asset.\n   * @param _splitAsset The address of the asset to split.\n   * @param _collectionContract The address of the collection contract.\n   * @param _splitId The split identifier.\n   */\n  function createSplit(\n    bytes32 _merkleRoot,\n    address _splitAsset,\n    address _collectionContract,\n    string memory _splitId\n  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {\n    require(\n      ICoreCollection(_collectionContract).owner() == msg.sender,\n      'Transaction sender is not collection owner'\n    );\n    merkleRoot = _merkleRoot;\n    splitAsset = _splitAsset;\n    royaltyAsset = _splitAsset;\n\n    splitProxy = createSplitProxy(_splitId);\n    address vault = createVaultProxy(splitProxy);\n\n    ICoreCollection(_collectionContract).setRoyaltyVault(vault);\n    emit VaultAssignedToCollection(vault, splitter, _collectionContract);\n  }\n\n  /**\n   * @dev Deploys a new SplitProxy.\n   * @param _merkleRoot The merkle root of the asset.\n   * @param _splitAsset The address of the asset to split.\n   * @param _splitId The split identifier.\n   */\n  function createSplit(\n    bytes32 _merkleRoot,\n    address _splitAsset,\n    string memory _splitId\n  ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {\n    merkleRoot = _merkleRoot;\n    splitAsset = _splitAsset;\n    royaltyAsset = _splitAsset;\n\n    splitProxy = createSplitProxy(_splitId);\n    createVaultProxy(splitProxy);\n  }\n\n  /**\n   * @dev Set Platform fee for collection contract.\n   * @param _platformFee Platform fee in scaled percentage. (5% = 200)\n   * @param _vault vault address.\n   */\n  function setPlatformFee(address _vault, uint256 _platformFee)\n    external\n    onlyOwner\n  {\n    IRoyaltyVault(_vault).setPlatformFee(_platformFee);\n  }\n\n  /**\n   * @dev Set Platform fee recipient for collection contract.\n   * @param _vault vault address.\n   * @param _platformFeeRecipient Platform fee recipient.\n   */\n  function setPlatformFeeRecipient(\n    address _vault,\n    address _platformFeeRecipient\n  ) external onlyOwner {\n    require(_vault != address(0), 'Invalid vault');\n    require(\n      _platformFeeRecipient != address(0),\n      'Invalid platform fee recipient'\n    );\n    IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);\n  }\n\n  // ---------------- PRIVATE ----------------\n\n  /**\n   * @dev Creates a new SplitProxy.\n   */\n  function createSplitProxy(string memory _splitId)\n    private\n    returns (address splitProxy)\n  {\n    splitProxy = address(\n      new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()\n    );\n\n    splits[_splitId] = splitProxy;\n\n    emit SplitCreated(splitProxy, _splitId);\n\n    delete merkleRoot;\n    delete splitAsset;\n  }\n\n  function createVaultProxy(address splitProxy)\n    private\n    returns (address vault)\n  {\n    splitterProxy = splitProxy;\n    vault = address(new ProxyVault{salt: keccak256(abi.encode(splitProxy))}());\n    delete splitterProxy;\n    delete royaltyAsset;\n    emit VaultCreated(vault, splitProxy, platformFee, platformFeeRecipient);\n  }\n}\n\n\n",
        "CodeNames": [
            "SplitFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "setPlatformFee() function in SplitFactory.sol",
                "Type": "Missing Timelock",
                "Description": "The absence of a timelock in setPlatformFee() function can impact multiple users enough to make them want to react/be notified ahead of time.",
                "Repair": "Add a timelock to setPlatformFee() function to give users time to react and adjust to critical changes. Consider adding a maximum value for the platformFee and calling sendToSplitter() before adjusting the platformFee."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {SplitStorage} from \"./SplitStorage.sol\";\nimport {IRoyaltyVault} from \"@chestrnft/royalty-vault/interfaces/IRoyaltyVault.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Splitter\n * Building on the work from the Uniswap team at Uniswap and Mirror.xyz Team\n */\ncontract Splitter is SplitStorage {\n    /**** Mutable variables ****/\n    uint256 public constant PERCENTAGE_SCALE = 10e5;\n    bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;\n\n    // The TransferETH event is emitted after each eth transfer in the split is attempted.\n    event TransferETH(\n        // The account to which the transfer was attempted.\n        address account,\n        // The amount for transfer that was attempted.\n        uint256 amount,\n        // Whether or not the transfer succeeded.\n        bool success\n    );\n\n    // Emits when a window is incremented.\n    event WindowIncremented(uint256 currentWindow, uint256 fundsAvailable);\n\n    /**\n     * @dev Claim the funds from the all windows.\n     * @param percentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claimForAllWindows(\n        uint256 percentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        // Make sure that the user has this allocation granted.\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, percentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        uint256 amount = 0;\n        for (uint256 i = 0; i < currentWindow; i++) {\n            if (!isClaimed(msg.sender, i)) {\n                setClaimed(msg.sender, i);\n\n                amount += scaleAmountByPercentage(\n                    balanceForWindow[i],\n                    percentageAllocation\n                );\n            }\n        }\n\n        transferSplitAsset(msg.sender, amount);\n    }\n\n    /**\n     * @dev get Node hash of given data.\n     * @param who {address} whitelisted user address\n     * @param percentageAllocation {uint256} percentage of allocation\n     * @return {bytes32} node hash\n     */\n    function getNode(\n        address who,\n        uint256 percentageAllocation\n    ) private pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    who,\n                    percentageAllocation\n                )\n            );\n    }\n\n    /**\n     * @dev get scaled amount from given amount and percentage.\n     * @param amount {uint256} amount\n     * @param scaledPercent {uint256} scaled percentage\n     * @return scaledAmount {uint256} scaled amount\n     */\n    function scaleAmountByPercentage(uint256 amount, uint256 scaledPercent)\n        public\n        pure\n        returns (uint256 scaledAmount)\n    {\n        /*\n            Example:\n                If there is 100 ETH in the account, and someone has \n                an allocation of 2%, we call this with 100 as the amount, and 200\n                as the scaled percent.\n\n                To find out the amount we use, for example: (100 * 200) / (100 * 100)\n                which returns 2 -- i.e. 2% of the 100 ETH balance.\n         */\n        scaledAmount = (amount * scaledPercent) / (10000);\n    }\n\n    /**\n     * @dev claim for the given window.\n     * @param window {uint256} Window to claim\n     * @param scaledPercentageAllocation {uint256} percentage of allocation to be claimed\n     * @param merkleProof {bytes32} The Merkle proof of the allocation\n     */\n    function claim(\n        uint256 window,\n        uint256 scaledPercentageAllocation,\n        bytes32[] calldata merkleProof\n    ) external {\n        require(currentWindow > window, \"cannot claim for a future window\");\n        require(\n            !isClaimed(msg.sender, window),\n            \"NFT has already claimed the given window\"\n        );\n\n        setClaimed(msg.sender, window);\n\n        require(\n            verifyProof(\n                merkleProof,\n                merkleRoot,\n                getNode(msg.sender, scaledPercentageAllocation)\n            ),\n            \"Invalid proof\"\n        );\n\n        transferSplitAsset(\n            msg.sender,\n            // The absolute amount that's claimable.\n            scaleAmountByPercentage(\n                balanceForWindow[window],\n                scaledPercentageAllocation\n            )\n        );\n    }\n\n    /**\n     * @dev Function which handles increment window and puts amount to current window\n     * @param royaltyAmount {uint256} Amount needs to be added in window.\n     * @return {bool} Whether or not the window was incremented.\n     */\n    function incrementWindow(uint256 royaltyAmount) public returns (bool) {\n        uint256 wethBalance;\n\n        require(\n            IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),\n            \"Royalty Vault not supported\"\n        );\n        require(\n            IRoyaltyVault(msg.sender).getSplitter() == address(this),\n            \"Unauthorised to increment window\"\n        );\n\n        wethBalance = IERC20(splitAsset).balanceOf(address(this));\n        require(wethBalance >= royaltyAmount, \"Insufficient funds\");\n\n        require(royaltyAmount > 0, \"No additional funds for window\");\n        balanceForWindow.push(royaltyAmount);\n        currentWindow += 1;\n        emit WindowIncremented(currentWindow, royaltyAmount);\n        return true;\n    }\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bool} Whether or not the window has been claimed.\n     */\n    function isClaimed(\n        address who,\n        uint256 window\n    ) public view returns (bool) {\n        return claimed[getClaimHash(who, window)];\n    }\n\n    /**** Private Functions ****/\n\n    /**\n     * @dev Function checks if the given window and tokenId has been claimed.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     */\n    function setClaimed(\n        address who,\n        uint256 window\n    ) private {\n        claimed[getClaimHash(who, window)] = true;\n    }\n\n    /**\n     * @dev Function which returns the hash of the given window, tokenId and membershipContract.\n     * @param who {address} whitelisted user address\n     * @param window {uint256} Window to check\n     * @return {bytes32} Hash of the given window, tokenId and membershipContract.\n     */\n    function getClaimHash(\n        address who,\n        uint256 window\n    ) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(who, window));\n    }\n\n    /**\n     * @dev Function to convert output amount from percentages.\n     * @param amount {uint256} Amount for which percentage is to be calculated.\n     * @param percent {uint256} Percentage\n     * @return {uint256} Output amount.\n     */\n    function amountFromPercent(uint256 amount, uint32 percent)\n        private\n        pure\n        returns (uint256)\n    {\n        // Solidity 0.8.0 lets us do this without SafeMath.\n        return (amount * percent) / 100;\n    }\n\n    /**\n     * @dev Function to transfer split asset to the given address.\n     * @param to {address} Address to transfer the split asset to.\n     * @param value {uint256} Amount to transfer.\n     */\n    function transferSplitAsset(address to, uint256 value)\n        private\n        returns (bool didSucceed)\n    {\n        // Try to transfer ETH to the given recipient.\n        didSucceed = IERC20(splitAsset).transfer(to, value);\n        require(didSucceed, \"Failed to transfer ETH\");\n\n        emit TransferETH(to, value, didSucceed);\n    }\n\n    /**\n     * @dev transfer given amount of ETH in contract to the given address.\n     * @param to {address} Address to transfer asset\n     * @param value {uint256} Amount to transfer\n     * @return {bool} Whether or not the transfer was successful.\n     */\n    function attemptETHTransfer(address to, uint256 value)\n        private\n        returns (bool)\n    {\n        // Here increase the gas limit a reasonable amount above the default, and try\n        // to send ETH to the recipient.\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n        (bool success, ) = to.call{value: value, gas: 30000}(\"\");\n        return success;\n    }\n\n    // From https://github.com/protofire/zeppelin-solidity/blob/master/contracts/MerkleProof.sol\n    /**\n     * @dev Function to verify the given proof.\n     * @param proof {bytes32[]} Proof to verify\n     * @param root {bytes32} Root of the Merkle tree\n     * @param leaf {bytes32} Leaf to verify\n     * @return {bool} Whether or not the proof is valid.\n     */\n    function verifyProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) private pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(\n                    abi.encodePacked(computedHash, proofElement)\n                );\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(\n                    abi.encodePacked(proofElement, computedHash)\n                );\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n\n\n",
        "CodeNames": [
            "Splitter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Splitter.sol",
                "Type": "Confusing Percentage Denominators",
                "Description": "Differing percentage denominators can cause confusion and potentially brick claims.",
                "Repair": "Remove PERCENTAGE_SCALE because it is unused, or replace its value with 10_000 and use that instead."
            },
            {
                "Location": "attemptETHTransfer() function in Splitter.sol",
                "Type": "Insufficient Gas Sent in Call",
                "Description": "The fixed amount of gas sent in the call may be insufficient and result in the user being unable to receive funds from this function.",
                "Repair": "Remove the gas field to use the default amount and protect from reentrancy by using reentrancy guards and the check-effects-interaction pattern."
            }
        ]
    }
]