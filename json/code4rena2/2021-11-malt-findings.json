[
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/lib/contracts/libraries/Babylonian.sol';\nimport '@uniswap/lib/contracts/libraries/FullMath.sol';\n\nimport \"../Permissions.sol\";\nimport \"../libraries/UniswapV2Library.sol\";\n\n\n/// @title Uniswap Interaction Handler\n/// @author 0xScotch <scotch@malt.money>\n/// @notice A simple contract to make interacting with UniswapV2 pools easier.\n/// @notice The buyMalt method is locked down to avoid circumventing recovery mode\n/// @dev Makes use of UniswapV2Router02. Would be more efficient to go direct\ncontract UniswapHandler is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant BUYER_ROLE = keccak256(\"BUYER_ROLE\");\n\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public lpToken;\n  IUniswapV2Router02 public router;\n  address public uniswapV2Factory;\n\n  address[] public buyers;\n  mapping(address => bool) public buyersActive;\n\n  event AddMaltBuyer(address buyer);\n  event RemoveMaltBuyer(address buyer);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _maltToken,\n    address _rewardToken,\n    address _lpToken,\n    address _router,\n    address _uniswapV2Factory\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setRoleAdmin(BUYER_ROLE, ADMIN_ROLE);\n\n    malt = ERC20(_maltToken);\n    rewardToken = ERC20(_rewardToken);\n    router = IUniswapV2Router02(_router);\n\n    lpToken = ERC20(_lpToken);\n    uniswapV2Factory = _uniswapV2Factory;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function calculateMintingTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(malt), address(rewardToken), priceTarget);\n  }\n\n  function calculateBurningTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(rewardToken), address(malt), priceTarget);\n  }\n\n  function reserves() public view returns (uint256 maltSupply, uint256 rewardSupply) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (maltSupply, rewardSupply) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n  }\n\n  function maltMarketPrice() public view returns (uint256 price, uint256 decimals) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 maltReserves, uint256 rewardReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n\n    if (maltReserves == 0 || rewardReserves == 0) {\n      price = 0;\n      decimals = 18;\n      return (price, decimals);\n    }\n\n    uint256 rewardDecimals = rewardToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n\n    if (rewardDecimals > maltDecimals) {\n      uint256 diff = rewardDecimals - maltDecimals;\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves.mul(10**diff));\n      decimals = rewardDecimals;\n    } else if (rewardDecimals < maltDecimals) {\n      uint256 diff = maltDecimals - rewardDecimals;\n      price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);\n      decimals = maltDecimals;\n    } else {\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves);\n      decimals = rewardDecimals;\n    }\n  }\n\n  function getOptimalLiquidity(address tokenA, address tokenB, uint256 liquidityB)\n    external view returns (uint256 liquidityA)\n  {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      tokenA,\n      tokenB\n    );\n\n    liquidityA = UniswapV2Library.quote(\n      liquidityB,\n      reservesB,\n      reservesA\n    );\n  }\n\n  /*\n   * MUTATION FUNCTIONS\n   */\n  function buyMalt()\n    external\n    onlyRole(BUYER_ROLE, \"Must have buyer privs\")\n    returns (uint256 purchased)\n  {\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (rewardBalance == 0) {\n      return 0;\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(rewardToken);\n    path[1] = address(malt);\n\n    router.swapExactTokensForTokens(\n      rewardBalance,\n      0, // amountOutMin\n      path,\n      address(this),\n      now\n    );\n\n    purchased = malt.balanceOf(address(this));\n    malt.safeTransfer(msg.sender, purchased);\n  }\n\n  function sellMalt() external returns (uint256 rewards) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n\n    if (maltBalance == 0) {\n      return 0;\n    }\n\n    malt.approve(address(router), maltBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(malt);\n    path[1] = address(rewardToken);\n\n    router.swapExactTokensForTokens(\n      maltBalance,\n      0,\n      path,\n      address(this),\n      now\n    );\n\n    rewards = rewardToken.balanceOf(address(this));\n    rewardToken.safeTransfer(msg.sender, rewards);\n  }\n\n  function addLiquidity() external returns (\n    uint256 maltUsed,\n    uint256 rewardUsed,\n    uint256 liquidityCreated\n  ) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (maltBalance == 0 || rewardBalance == 0) {\n      return (0, 0, 0);\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n    malt.approve(address(router), maltBalance);\n\n    // TODO maybe make slippage tolerance here adjustable Fri 19 Nov 2021 16:45:57 GMT\n    (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(\n      address(malt),\n      address(rewardToken),\n      maltBalance,\n      rewardBalance,\n      maltBalance.mul(95).div(100),\n      rewardBalance.mul(95).div(100),\n      msg.sender, // transfer LP tokens to sender\n      now\n    );\n\n    if (maltUsed < maltBalance) {\n      malt.safeTransfer(msg.sender, maltBalance.sub(maltUsed));\n    }\n\n    if (rewardUsed < rewardBalance) {\n      rewardToken.safeTransfer(msg.sender, rewardBalance.sub(rewardUsed));\n    }\n  }\n\n  function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward) {\n    uint256 liquidityBalance = lpToken.balanceOf(address(this));\n\n    if (liquidityBalance == 0) {\n      return (0, 0);\n    }\n\n    lpToken.approve(address(router), liquidityBalance);\n\n    (amountMalt, amountReward) = router.removeLiquidity(\n      address(malt),\n      address(rewardToken),\n      liquidityBalance,\n      0,\n      0,\n      msg.sender, // transfer broken LP tokens to sender\n      now\n    );\n\n    if (amountMalt == 0 || amountReward == 0) {\n      liquidityBalance = lpToken.balanceOf(address(this));\n      lpToken.safeTransfer(msg.sender, liquidityBalance);\n      return (amountMalt, amountReward);\n    }\n  }\n\n  /*\n   * PRIVATE METHODS\n   */\n  function _calculateTradeSize(address sellToken, address buyToken, uint256 priceTarget) private view returns (uint256) {\n    // TODO use data lab average Tue 05 Oct 2021 20:40:23 BST\n    (uint256 sellReserves, uint256 buyReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      sellToken,\n      buyToken\n    );\n\n    uint256 invariant = sellReserves.mul(buyReserves);\n\n    uint256 buyBase = 10**uint256(ERC20(buyToken).decimals());\n\n    uint256 leftSide = Babylonian.sqrt(\n      FullMath.mulDiv(\n        invariant.mul(1000),\n        priceTarget,\n        buyBase.div(priceTarget).mul(buyBase).mul(997)\n      )\n    );\n\n    uint256 rightSide = sellReserves.mul(1000).div(997);\n\n    if (leftSide < rightSide) return 0;\n\n    return leftSide.sub(rightSide);\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function addNewBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    require(_buyer != address(0), \"Cannot use address 0\");\n\n    if (buyersActive[_buyer]) {\n      return;\n    }\n\n    buyersActive[_buyer] = true;\n    buyers.push(_buyer);\n\n    _setupRole(BUYER_ROLE, _buyer);\n\n    emit AddMaltBuyer(_buyer);\n  }\n\n  function removeBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    if (buyers.length == 0 || !buyersActive[_buyer]) {\n      return;\n    }\n\n    address buyer;\n    buyersActive[_buyer] = false;\n\n    emit RemoveMaltBuyer(_buyer);\n    revokeRole(BUYER_ROLE, _buyer);\n\n    // Loop until the second last element\n    for (uint i = 0; i < buyers.length - 1; i = i + 1) {\n      if (buyers[i] == _buyer) {\n        // Replace the current item with the last and pop the last away.\n        buyers[i] = buyers[buyers.length - 1];\n        buyers.pop();\n        return;\n      }\n    }\n\n    // If we made it here then the buyers being removed is the last item\n    buyers.pop();\n  }\n\n  // TODO ensure this contract is whitelisted for under peg transfers Mon 06 Sep 2021 23:49:31 BST\n}\n\n\n",
        "CodeNames": [
            "UniswapHandler.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "UniswapHandler calls to UniswapV2Router",
                "Type": "Frontrunning",
                "Description": "UniswapHandler calls to UniswapV2Router are vulnerable to frontrunning attacks due to lack of price slippage checks and anyone having access to UniswapV2Router contract.",
                "Repair": "Implement price slippage checks whenever removing liquidity or swapping tokens. Ensure that only the UniswapHandler contract can call UniswapV2Router and UniswapV2Pair contract."
            },
            {
                "Location": "UniswapHandler.sol addLiquidity function",
                "Type": "Medium Severity",
                "Description": "addLiquidity function in UniswapHandler.sol does not reset approval if not all tokens were added to the liquidity pool, leading to large Uniswap approval amounts by the UniswapHandler contract.",
                "Repair": "Reset approval amount if not all tokens were added to liquidity pool"
            },
            {
                "Location": "UniswapHandler.maltMarketPrice function",
                "Type": "Incorrect return value",
                "Description": "The returned decimals do not match the computed price for the rewardDecimals < maltDecimals branch, resulting in callers receiving a price in unexpected decimals and potentially inflating or deflating the actual amount.",
                "Repair": "Return rewardDecimals instead of maltDecimals in the rewardDecimals < maltDecimals branch"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Abstract Reward Mine\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The base functionality for tracking user reward ownership, withdrawals etc\n/// @dev The contract is abstract so needs to be inherited\nabstract contract AbstractRewardMine is Permissions {\n  using SafeMath for uint256;\n\n  bytes32 public constant REWARD_MANAGER_ROLE = keccak256(\"REWARD_MANAGER_ROLE\");\n  bytes32 public constant MINING_SERVICE_ROLE = keccak256(\"MINING_SERVICE_ROLE\");\n\n  ERC20 public rewardToken;\n  address public miningService;\n\n  uint256 internal _globalStakePadding;\n  uint256 internal _globalWithdrawn;\n  mapping(address => uint256) internal _userStakePadding;\n  mapping(address => uint256) internal _userWithdrawn;\n\n  event Withdraw(address indexed account, uint256 rewarded, address indexed to);\n\n  function onBond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeBond(account, amount);\n    _handleStakePadding(account, amount);\n    _afterBond(account, amount);\n  }\n\n  function onUnbond(address account, uint256 amount)\n    virtual\n    public\n    onlyRole(MINING_SERVICE_ROLE, \"Must having mining service privilege\")\n  {\n    _beforeUnbond(account, amount);\n    // Withdraw all current rewards\n    // Done now before we change stake padding below\n    uint256 rewardEarned = earned(account);\n    _handleWithdrawForAccount(account, rewardEarned, account);\n\n    uint256 bondedBalance = balanceOfBonded(account);\n\n    if (bondedBalance == 0) {\n      return;\n    }\n\n    uint256 lessStakePadding = balanceOfStakePadding(account).mul(amount).div(bondedBalance);\n\n    _reconcileWithdrawn(account, amount, bondedBalance);\n    _removeFromStakePadding(account, lessStakePadding, \"< stake padding\");\n    _afterUnbond(account, amount);\n  }\n\n  function _initialSetup(address _rewardToken, address _miningService) internal {\n    _roleSetup(MINING_SERVICE_ROLE, _miningService);\n    _roleSetup(REWARD_MANAGER_ROLE, _miningService);\n\n    rewardToken = ERC20(_rewardToken);\n    miningService = _miningService;\n  }\n\n  function withdrawAll() public {\n    uint256 rewardEarned = earned(msg.sender);\n\n    _handleWithdrawForAccount(msg.sender, rewardEarned, msg.sender);\n  }\n\n  function withdraw(uint256 rewardAmount) external {\n    uint256 rewardEarned = earned(msg.sender);\n\n    require(rewardAmount <= rewardEarned, \"< earned\");\n    \n    _handleWithdrawForAccount(msg.sender, rewardAmount, msg.sender);\n  }\n\n  /*\n   * METHODS TO OVERRIDE\n   */\n  function totalBonded() virtual public view returns (uint256);\n  function balanceOfBonded(address account) virtual public view returns (uint256);\n\n  /*\n   * totalReleasedReward and totalDeclaredReward will often be the same. However, in the case\n   * of vesting rewards they are different. In that case totalDeclaredReward is total\n   * reward, including unvested. totalReleasedReward is just the rewards that have completed\n   * the vesting schedule.\n   */\n  function totalDeclaredReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this));\n  }\n  function totalReleasedReward() virtual public view returns (uint256) {\n    return rewardToken.balanceOf(address(this)) + _globalWithdrawn;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function totalStakePadding() public view returns(uint256) {\n    return _globalStakePadding;  \n  }\n\n  function balanceOfStakePadding(address account) public view returns (uint256) {\n    return _userStakePadding[account];\n  }\n\n  function totalWithdrawn() public view returns (uint256) {\n    return _globalWithdrawn;\n  }\n\n  function withdrawnBalance(address account) public view returns (uint256) {\n    return _userWithdrawn[account];\n  }\n\n  function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {\n    numerator = balanceOfRewards(account);\n    denominator = totalDeclaredReward();\n  }\n\n  function balanceOfRewards(address account) public view returns (uint256) {\n    /*\n     * This represents the rewards allocated to a given account but does not\n     * mean all these rewards are unlocked yet. The earned method will\n     * fetch the balance that is unlocked for an account\n     */\n    uint256 balanceOfRewardedWithStakePadding = _getFullyPaddedReward(account);\n\n    uint256 stakePaddingBalance = balanceOfStakePadding(account);\n\n    if (balanceOfRewardedWithStakePadding > stakePaddingBalance) {\n      return balanceOfRewardedWithStakePadding - stakePaddingBalance;\n    }\n    return 0;\n  }\n\n  function earned(address account) public view returns (uint256 earnedReward) {\n    (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);\n\n    if (rewardDenominator > 0) {\n      earnedReward = totalReleasedReward().mul(rewardNumerator).div(rewardDenominator).sub(_userWithdrawn[account]);\n    }\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _getFullyPaddedReward(address account) internal view returns (uint256) {\n    uint256 globalBondedTotal = totalBonded();\n    if (globalBondedTotal == 0) {\n      return 0;\n    }\n\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n    \n    return totalRewardedWithStakePadding\n      .mul(balanceOfBonded(account))\n      .div(globalBondedTotal);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _withdraw(address account, uint256 amountReward, address to) internal {\n    rewardToken.safeTransfer(to, amountReward);\n    _userWithdrawn[account] += amountReward;\n    _globalWithdrawn += amountReward;\n\n    emit Withdraw(account, amountReward, to);\n  }\n\n  function _handleStakePadding(address account, uint256 amount) internal {\n    uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());\n\n    uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;\n\n    uint256 bondedTotal = totalBonded();\n\n    uint256 newStakePadding = bondedTotal == 0 ?\n      totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :\n      totalRewardedWithStakePadding.mul(amount).div(bondedTotal);\n\n    _addToStakePadding(account, newStakePadding);\n  }\n\n  function _addToStakePadding(address account, uint256 amount) internal {\n    _userStakePadding[account] = _userStakePadding[account].add(amount);\n\n    _globalStakePadding = _globalStakePadding.add(amount);\n  }\n\n  function _removeFromStakePadding(\n    address account,\n    uint256 amount,\n    string memory reason\n  ) internal {\n    _userStakePadding[account] = _userStakePadding[account].sub(amount, reason);\n\n    _globalStakePadding = _globalStakePadding.sub(amount, reason);\n  }\n\n  function _reconcileWithdrawn(\n    address account,\n    uint256 amount,\n    uint256 bondedBalance\n  ) internal {\n    uint256 withdrawDiff = _userWithdrawn[account].mul(amount) / bondedBalance;\n    _userWithdrawn[account] = _userWithdrawn[account].sub(withdrawDiff, \"< withdrawn\");\n    _globalWithdrawn = _globalWithdrawn.sub(withdrawDiff, \"< global withdrawn\");\n  }\n\n  function _handleWithdrawForAccount(address account, uint256 rewardAmount, address to) internal {\n    _beforeWithdraw(account, rewardAmount);\n\n    _withdraw(account, rewardAmount, to);\n\n    _afterWithdraw(account, rewardAmount);\n  }\n\n  /*\n   * HOOKS\n   */\n  function _beforeWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterWithdraw(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterBond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _beforeUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  function _afterUnbond(address account, uint256 amount) virtual internal {\n    // hook\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function withdrawForAccount(address account, uint256 amount, address to)\n    external\n    onlyRole(REWARD_MANAGER_ROLE, \"Must have reward manager privs\")\n    returns (uint256)\n  {\n    uint256 rewardEarned = earned(account);\n\n    if (rewardEarned < amount) {\n      amount = rewardEarned;\n    }\n    \n    _handleWithdrawForAccount(account, amount, to);\n\n    return amount;\n  }\n\n  function setRewardToken(address _token)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    rewardToken = ERC20(_token);\n  }\n\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _swapRole(_miningService, miningService, MINING_SERVICE_ROLE);\n    _swapRole(_miningService, miningService, REWARD_MANAGER_ROLE);\n    miningService = _miningService;\n  }\n}\n\n\n",
        "CodeNames": [
            "AbstractRewardMine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AbstractRewardMine.sol#setRewardToken",
                "Type": "Admin Privilege",
                "Description": "Changing the reward token in AbstractRewardMine.sol#setRewardToken can result in totalDeclaredReward being changed to 0 and create problems with accumulated padding variables.",
                "Repair": "Remove the function or use it with a timelock contract and ensure that the new token is distributed in a way that padding variables still make sense. Alternatively, make the rewardToken immutable."
            },
            {
                "Location": "AbstractRewardMine contract, _withdraw method",
                "Type": "Re-entrancy",
                "Description": "The _withdraw method in AbstractRewardMine contract is vulnerable to re-entrancy attacks due to lack of proper internal accounting before the transfer occurs.",
                "Repair": "Update internal accounting before the transfer occurs to prevent re-entrancy attacks."
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\n/// @title Permissions\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Inherited by almost all Malt contracts to provide access control\ncontract Permissions is AccessControl {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  // Timelock has absolute power across the system\n  bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n  bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n\n  // Can mint/burn Malt\n  bytes32 public constant MONETARY_BURNER_ROLE = keccak256(\"MONETARY_BURNER_ROLE\");\n  bytes32 public constant MONETARY_MINTER_ROLE = keccak256(\"MONETARY_MINTER_ROLE\");\n\n  // Contract types\n  bytes32 public constant STABILIZER_NODE_ROLE = keccak256(\"STABILIZER_NODE_ROLE\");\n  bytes32 public constant LIQUIDITY_MINE_ROLE = keccak256(\"LIQUIDITY_MINE_ROLE\");\n  bytes32 public constant AUCTION_ROLE = keccak256(\"AUCTION_ROLE\");\n  bytes32 public constant REWARD_THROTTLE_ROLE = keccak256(\"REWARD_THROTTLE_ROLE\");\n\n  address internal globalAdmin;\n\n  mapping(address => uint256) public lastBlock; // protect against reentrancy\n\n  function _adminSetup(address _timelock) internal {\n    _roleSetup(TIMELOCK_ROLE, _timelock);\n    _roleSetup(ADMIN_ROLE, _timelock);\n    _roleSetup(GOVERNOR_ROLE, _timelock);\n    _roleSetup(MONETARY_BURNER_ROLE, _timelock);\n    _roleSetup(MONETARY_MINTER_ROLE, _timelock);\n    _roleSetup(STABILIZER_NODE_ROLE, _timelock);\n    _roleSetup(LIQUIDITY_MINE_ROLE, _timelock);\n    _roleSetup(AUCTION_ROLE, _timelock);\n    _roleSetup(REWARD_THROTTLE_ROLE, _timelock);\n\n    globalAdmin = _timelock;\n  }\n\n  function assignRole(bytes32 role, address _assignee)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _setupRole(role, _assignee);\n  }\n\n  function removeRole(bytes32 role, address _entity)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can revoke roles\")\n  {\n    revokeRole(role, _entity);\n  }\n\n  function reassignGlobalAdmin(address _admin)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _swapRole(_admin, globalAdmin, TIMELOCK_ROLE);\n    _swapRole(_admin, globalAdmin, ADMIN_ROLE);\n    _swapRole(_admin, globalAdmin, GOVERNOR_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_BURNER_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_MINTER_ROLE);\n    _swapRole(_admin, globalAdmin, STABILIZER_NODE_ROLE);\n    _swapRole(_admin, globalAdmin, LIQUIDITY_MINE_ROLE);\n    _swapRole(_admin, globalAdmin, AUCTION_ROLE);\n    _swapRole(_admin, globalAdmin, REWARD_THROTTLE_ROLE);\n\n    globalAdmin = _admin;\n  }\n\n  function emergencyWithdrawGAS(address payable destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    // Transfers the entire balance of the Gas token to destination\n    destination.call{value: address(this).balance}('');\n  }\n\n  function emergencyWithdraw(address _token, address destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    // Transfers the entire balance of an ERC20 token at _token to destination\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, token.balanceOf(address(this)));\n  }\n\n  function partialWithdrawGAS(address payable destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    destination.call{value: amount}('');\n  }\n\n  function partialWithdraw(address _token, address destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, amount);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _swapRole(address newAccount, address oldAccount, bytes32 role) internal {\n    revokeRole(role, oldAccount);\n    _setupRole(role, newAccount);\n  }\n\n  function _roleSetup(bytes32 role, address account) internal {\n    _setupRole(role, account);\n    _setRoleAdmin(role, ADMIN_ROLE);\n  }\n\n  function _onlyRole(bytes32 role, string memory reason) internal view {\n    require(\n      hasRole(\n        role,\n        _msgSender()\n      ),\n      reason\n    );\n  }\n\n  function _notSameBlock() internal {\n    require(\n      block.number > lastBlock[_msgSender()],\n      \"Can't carry out actions in the same block\"\n    );\n    lastBlock[_msgSender()] = block.number;\n  }\n\n  // Using internal function calls here reduces compiled bytecode size\n  modifier onlyRole(bytes32 role, string memory reason) {\n    _onlyRole(role, reason);\n    _;\n  }\n\n  modifier notSameBlock() {\n    _notSameBlock();\n    _;\n  }\n}\n\n\n",
        "CodeNames": [
            "Permissions.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Permissions contract, lines 85 and 101",
                "Type": "Unchecked return value",
                "Description": "ETH transfer using .call function in Permissions contract can appear successful even if it failed due to lack of verification of the return value.",
                "Repair": "Check the return value of the .call function to ensure that the transfer succeeded."
            },
            {
                "Location": "Permissions.reassignGlobalAdmin function",
                "Type": "Incorrect permissions",
                "Description": "The TIMELOCK_ROLE is not the admin of all the reassigned roles, and the revokeRole calls will fail as it requires the ADMIN_ROLE, making it impossible to call reassignGlobalAdmin if the caller only has the TIMELOCK_ROLE role.",
                "Repair": "Ensure that the caller has both the TIMELOCK_ROLE and ADMIN_ROLE roles"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AuctionEschapeHatch.sol#exitEarly",
                "Type": "Incorrect state update",
                "Description": "AuctionEschapeHatch.sol#exitEarly updates the state of the auction wrongly, allowing users to claim more malt with less commitment and reducing profit penalties.",
                "Repair": "Rethink how to track values of an auction correctly and ensure that the correct values are used for the correct calculations."
            },
            {
                "Location": "TIMELOCK_ROLE Can Withdraw All FUND from the Contracts via emergencyWithdrawGAS(), emergencyWithdraw(), partialWithdrawGAS(), partialWithdraw()",
                "Type": "Admin Privilege",
                "Description": "TIMELOCK_ROLE has absolute power to withdraw all funds from the contracts which may raise red flags for investors.",
                "Repair": "Pause the Contract and Disable All Functions when Bad Thing Happen rather than Withdraw All Fund to a random address. If Withdraw Fund can't avoid, a Multi Sig ETH Address should be hardcoded into the contract to ensure the fund move to a safe wallet."
            },
            {
                "Location": "liquidity removed is directly sent to msg.sender, which would revert if it is not whitelisted",
                "Type": "Whitelisting",
                "Description": "Unable to remove liquidity in Recovery Mode due to whitelisting on verifyTransfer.",
                "Repair": "Liquidity should be removed to UniswapHandler contract, then the proceed is sent to msg.sender. Whitelisting should be avoided as anyone could deploy similar swapping contracts."
            },
            {
                "Location": "setReplenishingIndex mistake could freeze unclaimed tokens",
                "Type": "Admin Privilege",
                "Description": "setReplenishingIndex mistake could freeze unclaimed tokens.",
                "Repair": "Remove the require statement on line 136, so that an admin can set the index to a smaller value."
            },
            {
                "Location": "Dutch auction can be manipulated",
                "Type": "Smart Contract Vulnerability",
                "Description": "The Dutch auction can be manipulated by preventing _endAuction() from being called, allowing an attacker to purchase tokens at a lower price.",
                "Repair": "Incentivize stabilize() or incentivize a permission-less call to _endAuction(). Lock-in auction price when user commit purchase"
            },
            {
                "Location": "Slippage checks when adding liquidity are too strict",
                "Type": "Smart Contract Vulnerability",
                "Description": "The slippage checks when adding liquidity are too strict, causing the function to revert and fail. An attacker can even send tokens to the contract to make them unbalanced and revert, resulting in a griefing attack.",
                "Repair": "Ensure that the balances in the contract are always balanced and match the current reserve ratio. Accept parameters instead of how many tokens to provide liquidity with from the caller side"
            },
            {
                "Location": "stabilize function",
                "Type": "smart contract vulnerability",
                "Description": "Theft of system profit.",
                "Repair": "In _beforeTokenTransfer, if the price is above 1$ and the receiver is the AMM pool, stabilize it."
            },
            {
                "Location": "purchaseArbitrageTokens function",
                "Type": "smart contract vulnerability",
                "Description": "Users can contribute to an auction without directly committing collateral tokens.",
                "Repair": "Consider adding a check to ensure that realCommitment != 0 in purchaseArbitrageTokens."
            },
            {
                "Location": "_calculateMaltRequiredForExit function",
                "Type": "smart contract vulnerability",
                "Description": "_calculateMaltRequiredForExit uses spot price to calculate Malt quantity in exitEarly.",
                "Repair": "Consider implementing/integrating a TWAP oracle to track the price of Malt."
            },
            {
                "Location": "setBonding function",
                "Type": "smart contract vulnerability",
                "Description": "MiningService.setBonding should use BONDING role instead of REINVESTOR one.",
                "Repair": "Set BONDING_ROLE instead of REINVESTOR_ROLE in setBonding function."
            },
            {
                "Location": "_distributeRewards function",
                "Type": "Incorrect token approval",
                "Description": "The allocateArbRewards function does not necessarily utilize the entire amount approved by the StabilizerNode contract, resulting in dust token approval amounts accruing within the StabilizerNode contract.",
                "Repair": "Reset approval amount if the input rewarded amount to allocateArbRewards is less than the output amount"
            },
            {
                "Location": "_shouldAdjustSupply function",
                "Type": "Incentive abuse",
                "Description": "An auction which is inactive but exists would satisfy the edge case and result in triggerAuction simply returning, allowing the caller to be rewarded for their call to stabilize even if an auction exists already.",
                "Repair": "Use auctionExists and auctionActive consistently in StabilizerNode and Auction to ensure the edge case cannot be abused"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./Permissions.sol\";\n\n\n/// @title Malt DAO\n/// @author 0xScotch <scotch@malt.money>\n/// @notice In essence a contract that is the oracle for the current epoch\ncontract MaltDAO is Initializable, Permissions {\n  using SafeMath for uint256;\n\n  IBurnMintableERC20 public malt;\n  uint256 public epoch = 0;\n  uint256 public epochLength;\n  uint256 public genesisTime;\n  uint256 public advanceIncentive = 100; // 100 Malt\n\n  event Advance(uint256 indexed epoch, uint256 block, uint256 timestamp);\n  event Mint(address recipient, uint256 amount);\n  event SetMaltToken(address maltToken);\n  event SetEpochLength(uint256 length);\n  event SetAdvanceIncentive(uint256 incentive);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    uint256 _epochLength,\n    uint256 _genesisTime,\n    address offering,\n    uint256 offeringMint\n  ) external initializer {\n    _setMaltToken(_malt);\n    _setEpochLength(_epochLength);\n\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    genesisTime = _genesisTime;\n\n    if (offeringMint > 0) {\n      // Tokens minted to Community Whitelist contract\n      malt.mint(offering, offeringMint);\n    }\n  }\n\n  receive() external payable {}\n\n  function advance() external {\n    require(block.timestamp >= getEpochStartTime(epoch + 1), \"Cannot advance epoch until start of new epoch\");\n\n    incrementEpoch();\n\n    malt.mint(msg.sender, advanceIncentive * 1e18);\n\n    emit Advance(epoch, block.number, block.timestamp);\n  }\n\n  function getEpochStartTime(uint256 _epoch) public view returns (uint256) {\n    return genesisTime.add(epochLength.mul(_epoch));\n  }\n\n  function epochsPerYear() public view returns (uint256) {\n    // 31557600 = seconds in a year\n    return 31557600 / epochLength;\n  }\n\n  function mint(address to, uint256 amount)\n    public\n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    require(amount > 0, \"Cannot have zero amount\");\n    malt.mint(to, amount);\n    emit Mint(to, amount);\n  }\n\n  function setMaltToken(address _malt)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    _setMaltToken(_malt);\n  }\n\n  function setEpochLength(uint256 _length)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_length > 0, \"Cannot have zero length epochs\");\n    _setEpochLength(_length);\n  }\n\n  function setAdvanceIncentive(uint256 incentive)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    advanceIncentive = incentive;\n    emit SetAdvanceIncentive(incentive);\n  }\n\n  /* Internal methods */\n  function incrementEpoch() internal {\n    epoch = epoch.add(1);\n  }\n  \n  function _setEpochLength(uint256 length) internal {\n    epochLength = length;\n    emit SetEpochLength(length);\n  }\n\n  function _setMaltToken(address _malt) internal {\n    malt = IBurnMintableERC20(_malt);\n    emit SetMaltToken(_malt);\n  }\n}\n\n\n",
        "CodeNames": [
            "DAO.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "DAO.sol incentives outside parties to advance the epoch by minting 100 MALT tokens for calling the advance function",
                "Type": "Leak of Value",
                "Description": "Reducing the epoch length results in leaking value from advancement incentives.",
                "Repair": "Rather than calculating from the genesis timestamp, store the last time that the epoch length was modified and calculate from there."
            },
            {
                "Location": "DAO.sol setAdvanceIncentive function",
                "Type": "Medium Severity",
                "Description": "setAdvanceIncentive function of DAO.sol doesn't check for a maximum value of incentive, which can result in a large amount of malt being minted if incentivewould be very large.",
                "Repair": "Check for a reasonable maximum value in advance() function"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/lib/contracts/libraries/Babylonian.sol';\nimport '@uniswap/lib/contracts/libraries/FullMath.sol';\n\nimport \"../Permissions.sol\";\nimport \"../libraries/UniswapV2Library.sol\";\n\n\n/// @title Uniswap Interaction Handler\n/// @author 0xScotch <scotch@malt.money>\n/// @notice A simple contract to make interacting with UniswapV2 pools easier.\n/// @notice The buyMalt method is locked down to avoid circumventing recovery mode\n/// @dev Makes use of UniswapV2Router02. Would be more efficient to go direct\ncontract UniswapHandler is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant BUYER_ROLE = keccak256(\"BUYER_ROLE\");\n\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public lpToken;\n  IUniswapV2Router02 public router;\n  address public uniswapV2Factory;\n\n  address[] public buyers;\n  mapping(address => bool) public buyersActive;\n\n  event AddMaltBuyer(address buyer);\n  event RemoveMaltBuyer(address buyer);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _maltToken,\n    address _rewardToken,\n    address _lpToken,\n    address _router,\n    address _uniswapV2Factory\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setRoleAdmin(BUYER_ROLE, ADMIN_ROLE);\n\n    malt = ERC20(_maltToken);\n    rewardToken = ERC20(_rewardToken);\n    router = IUniswapV2Router02(_router);\n\n    lpToken = ERC20(_lpToken);\n    uniswapV2Factory = _uniswapV2Factory;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function calculateMintingTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(malt), address(rewardToken), priceTarget);\n  }\n\n  function calculateBurningTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(rewardToken), address(malt), priceTarget);\n  }\n\n  function reserves() public view returns (uint256 maltSupply, uint256 rewardSupply) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (maltSupply, rewardSupply) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n  }\n\n  function maltMarketPrice() public view returns (uint256 price, uint256 decimals) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 maltReserves, uint256 rewardReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n\n    if (maltReserves == 0 || rewardReserves == 0) {\n      price = 0;\n      decimals = 18;\n      return (price, decimals);\n    }\n\n    uint256 rewardDecimals = rewardToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n\n    if (rewardDecimals > maltDecimals) {\n      uint256 diff = rewardDecimals - maltDecimals;\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves.mul(10**diff));\n      decimals = rewardDecimals;\n    } else if (rewardDecimals < maltDecimals) {\n      uint256 diff = maltDecimals - rewardDecimals;\n      price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);\n      decimals = maltDecimals;\n    } else {\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves);\n      decimals = rewardDecimals;\n    }\n  }\n\n  function getOptimalLiquidity(address tokenA, address tokenB, uint256 liquidityB)\n    external view returns (uint256 liquidityA)\n  {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      tokenA,\n      tokenB\n    );\n\n    liquidityA = UniswapV2Library.quote(\n      liquidityB,\n      reservesB,\n      reservesA\n    );\n  }\n\n  /*\n   * MUTATION FUNCTIONS\n   */\n  function buyMalt()\n    external\n    onlyRole(BUYER_ROLE, \"Must have buyer privs\")\n    returns (uint256 purchased)\n  {\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (rewardBalance == 0) {\n      return 0;\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(rewardToken);\n    path[1] = address(malt);\n\n    router.swapExactTokensForTokens(\n      rewardBalance,\n      0, // amountOutMin\n      path,\n      address(this),\n      now\n    );\n\n    purchased = malt.balanceOf(address(this));\n    malt.safeTransfer(msg.sender, purchased);\n  }\n\n  function sellMalt() external returns (uint256 rewards) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n\n    if (maltBalance == 0) {\n      return 0;\n    }\n\n    malt.approve(address(router), maltBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(malt);\n    path[1] = address(rewardToken);\n\n    router.swapExactTokensForTokens(\n      maltBalance,\n      0,\n      path,\n      address(this),\n      now\n    );\n\n    rewards = rewardToken.balanceOf(address(this));\n    rewardToken.safeTransfer(msg.sender, rewards);\n  }\n\n  function addLiquidity() external returns (\n    uint256 maltUsed,\n    uint256 rewardUsed,\n    uint256 liquidityCreated\n  ) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (maltBalance == 0 || rewardBalance == 0) {\n      return (0, 0, 0);\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n    malt.approve(address(router), maltBalance);\n\n    // TODO maybe make slippage tolerance here adjustable Fri 19 Nov 2021 16:45:57 GMT\n    (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(\n      address(malt),\n      address(rewardToken),\n      maltBalance,\n      rewardBalance,\n      maltBalance.mul(95).div(100),\n      rewardBalance.mul(95).div(100),\n      msg.sender, // transfer LP tokens to sender\n      now\n    );\n\n    if (maltUsed < maltBalance) {\n      malt.safeTransfer(msg.sender, maltBalance.sub(maltUsed));\n    }\n\n    if (rewardUsed < rewardBalance) {\n      rewardToken.safeTransfer(msg.sender, rewardBalance.sub(rewardUsed));\n    }\n  }\n\n  function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward) {\n    uint256 liquidityBalance = lpToken.balanceOf(address(this));\n\n    if (liquidityBalance == 0) {\n      return (0, 0);\n    }\n\n    lpToken.approve(address(router), liquidityBalance);\n\n    (amountMalt, amountReward) = router.removeLiquidity(\n      address(malt),\n      address(rewardToken),\n      liquidityBalance,\n      0,\n      0,\n      msg.sender, // transfer broken LP tokens to sender\n      now\n    );\n\n    if (amountMalt == 0 || amountReward == 0) {\n      liquidityBalance = lpToken.balanceOf(address(this));\n      lpToken.safeTransfer(msg.sender, liquidityBalance);\n      return (amountMalt, amountReward);\n    }\n  }\n\n  /*\n   * PRIVATE METHODS\n   */\n  function _calculateTradeSize(address sellToken, address buyToken, uint256 priceTarget) private view returns (uint256) {\n    // TODO use data lab average Tue 05 Oct 2021 20:40:23 BST\n    (uint256 sellReserves, uint256 buyReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      sellToken,\n      buyToken\n    );\n\n    uint256 invariant = sellReserves.mul(buyReserves);\n\n    uint256 buyBase = 10**uint256(ERC20(buyToken).decimals());\n\n    uint256 leftSide = Babylonian.sqrt(\n      FullMath.mulDiv(\n        invariant.mul(1000),\n        priceTarget,\n        buyBase.div(priceTarget).mul(buyBase).mul(997)\n      )\n    );\n\n    uint256 rightSide = sellReserves.mul(1000).div(997);\n\n    if (leftSide < rightSide) return 0;\n\n    return leftSide.sub(rightSide);\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function addNewBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    require(_buyer != address(0), \"Cannot use address 0\");\n\n    if (buyersActive[_buyer]) {\n      return;\n    }\n\n    buyersActive[_buyer] = true;\n    buyers.push(_buyer);\n\n    _setupRole(BUYER_ROLE, _buyer);\n\n    emit AddMaltBuyer(_buyer);\n  }\n\n  function removeBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    if (buyers.length == 0 || !buyersActive[_buyer]) {\n      return;\n    }\n\n    address buyer;\n    buyersActive[_buyer] = false;\n\n    emit RemoveMaltBuyer(_buyer);\n    revokeRole(BUYER_ROLE, _buyer);\n\n    // Loop until the second last element\n    for (uint i = 0; i < buyers.length - 1; i = i + 1) {\n      if (buyers[i] == _buyer) {\n        // Replace the current item with the last and pop the last away.\n        buyers[i] = buyers[buyers.length - 1];\n        buyers.pop();\n        return;\n      }\n    }\n\n    // If we made it here then the buyers being removed is the last item\n    buyers.pop();\n  }\n\n  // TODO ensure this contract is whitelisted for under peg transfers Mon 06 Sep 2021 23:49:31 BST\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./ERC20Permit.sol\";\nimport \"./Permissions.sol\";\nimport \"./interfaces/ITransferService.sol\";\n\n\n/// @title Malt V2 Token\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The ERC20 token contract for Malt V2\ncontract Malt is ERC20Permit, Initializable, Permissions {\n  using SafeMath for uint256;\n\n  ITransferService public transferService;\n\n  constructor(string memory name, string memory ticker) public ERC20Permit(name, ticker) {}\n\n  event SetTransferService(address service);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _transferService,\n    address[] calldata minters,\n    address[] calldata burners\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    transferService = ITransferService(_transferService);\n\n    for (uint256 i = 0; i < minters.length; i = i + 1) {\n      _setupRole(MONETARY_MINTER_ROLE, minters[i]);\n    }\n    for (uint256 i = 0; i < burners.length; i = i + 1) {\n      _setupRole(MONETARY_BURNER_ROLE, burners[i]);\n    }\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n    (bool success, string memory reason) = transferService.verifyTransfer(from, to, amount);\n    require(success, reason);\n  }\n\n  function mint(address to, uint256 amount)\n    public\n    onlyRole(MONETARY_MINTER_ROLE, \"Must have monetary minter role\")\n  {\n    _mint(to, amount);\n  }\n\n  function burn(address from, uint256 amount)\n    public\n    onlyRole(MONETARY_BURNER_ROLE, \"Must have monetary burner role\")\n  {\n    _burn(from, amount);\n  }\n\n  function setTransferService(address _service)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_service != address(0), \"Cannot use address 0 as transfer service\");\n    transferService = ITransferService(_service);\n    emit SetTransferService(_service);\n  }\n}\n\n\n",
        "CodeNames": [
            "UniswapHandler.sol",
            "Malt.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "One of the innovative feature of Malt is to block buying while under peg. The buy block can be bypassed by swapping to the whitelisted UniswapHandler",
                "Type": "Bypassing Restrictions",
                "Description": "User can bypass Recovery Mode via UniswapHandler to buy Malt.",
                "Repair": "This exploit can be mitigated by disabling addLiquidity() when the protocol is in recovery mode."
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./Auction.sol\";\n\n\nstruct EarlyExitData {\n  uint256 exitedEarly;\n  uint256 earlyExitReturn;\n  uint256 maltUsed;\n}\n\nstruct AuctionExits {\n  uint256 exitedEarly;\n  uint256 earlyExitReturn;\n  uint256 maltUsed;\n  mapping(address => EarlyExitData) accountExits;\n}\n\n\n/// @title Auction Escape Hatch\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Functionality to reduce risk profile of holding arbitrage tokens by allowing early exit\ncontract AuctionEscapeHatch is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  IAuction public auction;\n  IDexHandler public dexHandler;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  uint256 public maxEarlyExitBps = 200; // 20%\n  uint256 public cooloffPeriod = 60 * 60 * 24; // 24 hours\n\n  mapping(uint256 => AuctionExits) internal auctionEarlyExits;\n\n  event EarlyExit(address account, uint256 amount, uint256 received);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    address _auction,\n    address _handler\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auction = IAuction(_auction);\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function exitEarly(uint256 _auctionId, uint256 amount, uint256 minOut) external notSameBlock {\n    uint256 maltQuantity = _calculateMaltRequiredForExit(_auctionId, amount);\n\n    // TODO ensure this contract is added as a mint requester Sat 06 Nov 2021 20:13:49 GMT\n    malt.mint(address(dexHandler), maltQuantity);\n    uint256 amountOut = dexHandler.sellMalt();\n\n    require(amountOut > minOut, \"EarlyExit: Insufficient output\");\n\n    AuctionExits storage auctionExits = auctionEarlyExits[_auctionId];\n\n    auctionExits.exitedEarly = auctionExits.exitedEarly + amount;\n    auctionExits.earlyExitReturn = auctionExits.earlyExitReturn + amountOut;\n    auctionExits.maltUsed = auctionExits.maltUsed + maltQuantity;\n    auctionExits.accountExits[msg.sender].exitedEarly = auctionExits.accountExits[msg.sender].exitedEarly + amount; \n    auctionExits.accountExits[msg.sender].earlyExitReturn = auctionExits.accountExits[msg.sender].earlyExitReturn + amountOut; \n    auctionExits.accountExits[msg.sender].maltUsed = auctionExits.accountExits[msg.sender].maltUsed + maltQuantity; \n\n    auction.amendAccountParticipation(\n      msg.sender,\n      _auctionId,\n      amount,\n      maltQuantity\n    );\n\n    collateralToken.safeTransfer(msg.sender, amountOut);\n    emit EarlyExit(msg.sender, amount, amountOut);\n  }\n\n  function earlyExitReturn(address account, uint256 _auctionId, uint256 amount) public view returns(uint256) {\n    // We don't need all the values\n    (,,,,,\n     uint256 pegPrice,\n     ,\n     uint256 auctionEndTime,\n     bool active\n    ) = auction.getAuctionCore(_auctionId);\n\n    if(active || block.timestamp < auctionEndTime) {\n      return 0;\n    }\n\n    (\n      uint256 userCommitment,\n      uint256 userRedeemed,\n      uint256 userMaltPurchased\n    ) = auction.getAuctionParticipationForAccount(account, _auctionId);\n\n    // This should never overflow due to guards in redemption code\n    uint256 userOutstanding = userCommitment - userRedeemed;\n\n    if (amount > userOutstanding) {\n      amount = userOutstanding;\n    }\n\n    if (amount == 0) {\n      return 0;\n    }\n\n    (uint256 currentPrice,) = dexHandler.maltMarketPrice();\n\n    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\n    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;\n\n    // setCooloffPeriod guards against cooloffPeriod ever being 0\n    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;\n    if (progressionBps > 10000) {\n      progressionBps = 10000;\n    }\n\n    if (fullReturn > amount) {\n      // Allow a % of profit to be realised\n      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;\n      return amount + maxProfit;\n    } \n\n    return fullReturn;\n  }\n\n  function accountAuctionExits(address account, uint256 auctionId) external view returns (\n    uint256 exitedEarly,\n    uint256 earlyExitReturn,\n    uint256 maltUsed\n  ) {\n    EarlyExitData storage accountExits = auctionEarlyExits[auctionId].accountExits[account];\n\n    return (accountExits.exitedEarly, accountExits.earlyExitReturn, accountExits.maltUsed);\n  }\n\n  function globalAuctionExits(uint256 auctionId) external view returns (\n    uint256 exitedEarly,\n    uint256 earlyExitReturn,\n    uint256 maltUsed\n  ) {\n    AuctionExits storage auctionExits = auctionEarlyExits[auctionId];\n\n    return (auctionExits.exitedEarly, auctionExits.earlyExitReturn, auctionExits.maltUsed);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _calculateMaltRequiredForExit(uint256 _auctionId, uint256 amount) internal returns(uint256) {\n    // We don't need all the values\n    (,,,,,\n     uint256 pegPrice,\n     ,\n     uint256 auctionEndTime,\n     bool active\n    ) = auction.getAuctionCore(_auctionId);\n\n    require(!active, \"Cannot exit early on an active auction\");\n    require(block.timestamp > auctionEndTime, \"Auction not over\");\n\n    (\n      uint256 userCommitment,\n      uint256 userRedeemed,\n      uint256 userMaltPurchased\n    ) = auction.getAuctionParticipationForAccount(msg.sender, _auctionId);\n\n    // This should never overflow due to guards in redemption code\n    if (amount > (userCommitment - userRedeemed)) {\n      amount = userCommitment - userRedeemed;\n    }\n\n    require(amount > 0, \"Nothing to claim\");\n\n    (uint256 currentPrice,) = dexHandler.maltMarketPrice();\n\n    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\n    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;\n\n    // setCooloffPeriod guards against cooloffPeriod ever being 0\n    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;\n    if (progressionBps > 10000) {\n      progressionBps = 10000;\n    }\n\n    if (fullReturn > amount) {\n      // Allow a % of profit to be realised\n      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;\n      uint256 desiredReturn = amount + maxProfit;\n      maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;\n    } \n\n    return maltQuantity;\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function setEarlyExitBps(uint256 _earlyExitBps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_earlyExitBps > 0 && _earlyExitBps <= 1000, \"Must be between 0-100%\");\n    maxEarlyExitBps = _earlyExitBps;\n  }\n\n  function setCooloffPeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_period > 0, \"Cannot have 0 lookback period\");\n    cooloffPeriod = _period;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n}\n\n\n",
        "CodeNames": [
            "AuctionEscapeHatch.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AuctionEscapeHatch.sol",
                "Type": "Wrong return values",
                "Description": "The getAuctionCore() function returns wrong values out of order, leading to potential loss of user funds.",
                "Repair": "Add a missing comma in the function calls to getAuctionCore() to ensure the correct return values are used"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\n\n\n/// @title Auction Participant\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Will generally be inherited to give another contract the ability to use its capital to buy arbitrage tokens\ncontract AuctionParticipant is Permissions {\n  bytes32 public constant IMPLIED_COLLATERAL_SERVICE_ROLE = keccak256(\"IMPLIED_COLLATERAL_SERVICE_ROLE\");\n\n  IAuction public auction;\n  ERC20 public auctionRewardToken;\n\n  uint256 public replenishingIndex;\n  uint256[] public auctionIds;\n  uint256 public claimableRewards;\n\n  bool internal setupCompleted;\n\n  function setupParticipant(\n    address _impliedCollateralService,\n    address _rewardToken,\n    address _auction\n  ) public {\n    require(!setupCompleted, \"Can only call setup once\");\n\n    _roleSetup(IMPLIED_COLLATERAL_SERVICE_ROLE, _impliedCollateralService);\n    auctionRewardToken = ERC20(_rewardToken);\n    auction = IAuction(_auction);\n\n    setupCompleted = true;\n  }\n\n  function purchaseArbitrageTokens(uint256 maxAmount)\n    external\n    onlyRole(IMPLIED_COLLATERAL_SERVICE_ROLE, \"Must have implied collateral service privs\")\n    returns (uint256 remaining)\n  {\n    uint256 balance = usableBalance();\n\n    if (maxAmount < balance) {\n      balance = maxAmount;\n    }\n\n    uint256 currentAuction = auction.currentAuctionId();\n    \n    if (!auction.auctionActive(currentAuction)) {\n      return maxAmount;\n    }\n\n    auctionIds.push(currentAuction);\n\n    auctionRewardToken.approve(address(auction), balance);\n    auction.purchaseArbitrageTokens(balance);\n    \n    return maxAmount - balance;\n  }\n\n  function claim() external {\n    if (auctionIds.length == 0 || replenishingIndex >= auctionIds.length) {\n      return;\n    }\n\n    uint256 auctionId = auctionIds[replenishingIndex];\n    uint256 replenishingId = auction.replenishingAuctionId();\n\n    if (auctionId > replenishingId) {\n      // Not yet replenishing this auction\n      return;\n    }\n    uint256 claimableTokens = auction.userClaimableArbTokens(address(this), auctionId);\n\n    if (claimableTokens == 0) {\n      // Nothing to claim yet\n      return;\n    }\n\n    uint256 balance = auctionRewardToken.balanceOf(address(this));\n\n    auction.claimArbitrage(auctionId);\n\n    uint256 finalBalance = auctionRewardToken.balanceOf(address(this));\n    uint256 rewardedAmount = finalBalance - balance;\n\n    claimableRewards = claimableRewards.add(rewardedAmount);\n\n    uint256 claimable = auction.userClaimableArbTokens(address(this), auctionId);\n\n    if (replenishingId > auctionId && claimable == 0) {\n      // Don't increment replenishingIndex if replenishingAuctionId == auctionId as\n      // claimable could be 0 due to the debt not being 100% replenished.\n      replenishingIndex = replenishingIndex + 1;\n    }\n\n    _handleRewardDistribution(rewardedAmount);\n  }\n\n  function outstandingArbTokens() public view returns (uint256 outstanding) {\n    outstanding = 0;\n\n    for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) {\n      uint256 claimable = auction.balanceOfArbTokens(\n        auctionIds[i],\n        address(this)\n      );\n\n      outstanding = outstanding + claimable;\n    }\n\n    return outstanding;\n  }\n\n  function getAllAuctionIds() public view returns (uint256[] memory) {\n    return auctionIds;\n  }\n\n  function usableBalance() virtual public view returns(uint256) {\n    return auctionRewardToken.balanceOf(address(this));\n  }\n\n  function _handleRewardDistribution(uint256 rewarded) virtual internal {\n    // Do nothing\n    return;\n  }\n\n  function setReplenishingIndex(uint256 _index)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_index > replenishingIndex, \"Cannot replenishingIndex to old value\");\n    replenishingIndex = _index;\n  }\n}\n\n\n",
        "CodeNames": [
            "AuctionParticipant.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AuctionParticipant.sol",
                "Type": "Duplicate auction ids",
                "Description": "The purchaseArbitrageTokens() function in AuctionParticipant.sol pushes duplicate auction ids to an array, causing issues with the replenishingIndex variable and potentially breaking claiming of incentives.",
                "Repair": "Add a check to the purchaseArbitrageTokens() function to ensure that duplicate ids are not added, for example by changing auctionIds to a mapping instead of an array"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/lib/contracts/libraries/Babylonian.sol';\nimport '@uniswap/lib/contracts/libraries/FullMath.sol';\n\nimport \"../Permissions.sol\";\nimport \"../libraries/UniswapV2Library.sol\";\n\n\n/// @title Uniswap Interaction Handler\n/// @author 0xScotch <scotch@malt.money>\n/// @notice A simple contract to make interacting with UniswapV2 pools easier.\n/// @notice The buyMalt method is locked down to avoid circumventing recovery mode\n/// @dev Makes use of UniswapV2Router02. Would be more efficient to go direct\ncontract UniswapHandler is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant BUYER_ROLE = keccak256(\"BUYER_ROLE\");\n\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public lpToken;\n  IUniswapV2Router02 public router;\n  address public uniswapV2Factory;\n\n  address[] public buyers;\n  mapping(address => bool) public buyersActive;\n\n  event AddMaltBuyer(address buyer);\n  event RemoveMaltBuyer(address buyer);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _maltToken,\n    address _rewardToken,\n    address _lpToken,\n    address _router,\n    address _uniswapV2Factory\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setRoleAdmin(BUYER_ROLE, ADMIN_ROLE);\n\n    malt = ERC20(_maltToken);\n    rewardToken = ERC20(_rewardToken);\n    router = IUniswapV2Router02(_router);\n\n    lpToken = ERC20(_lpToken);\n    uniswapV2Factory = _uniswapV2Factory;\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function calculateMintingTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(malt), address(rewardToken), priceTarget);\n  }\n\n  function calculateBurningTradeSize(uint256 priceTarget) external view returns (uint256) {\n    return _calculateTradeSize(address(rewardToken), address(malt), priceTarget);\n  }\n\n  function reserves() public view returns (uint256 maltSupply, uint256 rewardSupply) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (maltSupply, rewardSupply) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n  }\n\n  function maltMarketPrice() public view returns (uint256 price, uint256 decimals) {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 maltReserves, uint256 rewardReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      address(malt),\n      address(rewardToken)\n    );\n\n    if (maltReserves == 0 || rewardReserves == 0) {\n      price = 0;\n      decimals = 18;\n      return (price, decimals);\n    }\n\n    uint256 rewardDecimals = rewardToken.decimals();\n    uint256 maltDecimals = malt.decimals();\n\n    if (rewardDecimals > maltDecimals) {\n      uint256 diff = rewardDecimals - maltDecimals;\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves.mul(10**diff));\n      decimals = rewardDecimals;\n    } else if (rewardDecimals < maltDecimals) {\n      uint256 diff = maltDecimals - rewardDecimals;\n      price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);\n      decimals = maltDecimals;\n    } else {\n      price = rewardReserves.mul(10**rewardDecimals).div(maltReserves);\n      decimals = rewardDecimals;\n    }\n  }\n\n  function getOptimalLiquidity(address tokenA, address tokenB, uint256 liquidityB)\n    external view returns (uint256 liquidityA)\n  {\n    // TODO use datalab anywhere that calls this Tue 05 Oct 2021 20:56:41 BST\n    (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      tokenA,\n      tokenB\n    );\n\n    liquidityA = UniswapV2Library.quote(\n      liquidityB,\n      reservesB,\n      reservesA\n    );\n  }\n\n  /*\n   * MUTATION FUNCTIONS\n   */\n  function buyMalt()\n    external\n    onlyRole(BUYER_ROLE, \"Must have buyer privs\")\n    returns (uint256 purchased)\n  {\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (rewardBalance == 0) {\n      return 0;\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(rewardToken);\n    path[1] = address(malt);\n\n    router.swapExactTokensForTokens(\n      rewardBalance,\n      0, // amountOutMin\n      path,\n      address(this),\n      now\n    );\n\n    purchased = malt.balanceOf(address(this));\n    malt.safeTransfer(msg.sender, purchased);\n  }\n\n  function sellMalt() external returns (uint256 rewards) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n\n    if (maltBalance == 0) {\n      return 0;\n    }\n\n    malt.approve(address(router), maltBalance);\n\n    address[] memory path = new address[](2);\n    path[0] = address(malt);\n    path[1] = address(rewardToken);\n\n    router.swapExactTokensForTokens(\n      maltBalance,\n      0,\n      path,\n      address(this),\n      now\n    );\n\n    rewards = rewardToken.balanceOf(address(this));\n    rewardToken.safeTransfer(msg.sender, rewards);\n  }\n\n  function addLiquidity() external returns (\n    uint256 maltUsed,\n    uint256 rewardUsed,\n    uint256 liquidityCreated\n  ) {\n    uint256 maltBalance = malt.balanceOf(address(this));\n    uint256 rewardBalance = rewardToken.balanceOf(address(this));\n\n    if (maltBalance == 0 || rewardBalance == 0) {\n      return (0, 0, 0);\n    }\n\n    rewardToken.approve(address(router), rewardBalance);\n    malt.approve(address(router), maltBalance);\n\n    // TODO maybe make slippage tolerance here adjustable Fri 19 Nov 2021 16:45:57 GMT\n    (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(\n      address(malt),\n      address(rewardToken),\n      maltBalance,\n      rewardBalance,\n      maltBalance.mul(95).div(100),\n      rewardBalance.mul(95).div(100),\n      msg.sender, // transfer LP tokens to sender\n      now\n    );\n\n    if (maltUsed < maltBalance) {\n      malt.safeTransfer(msg.sender, maltBalance.sub(maltUsed));\n    }\n\n    if (rewardUsed < rewardBalance) {\n      rewardToken.safeTransfer(msg.sender, rewardBalance.sub(rewardUsed));\n    }\n  }\n\n  function removeLiquidity() external returns (uint256 amountMalt, uint256 amountReward) {\n    uint256 liquidityBalance = lpToken.balanceOf(address(this));\n\n    if (liquidityBalance == 0) {\n      return (0, 0);\n    }\n\n    lpToken.approve(address(router), liquidityBalance);\n\n    (amountMalt, amountReward) = router.removeLiquidity(\n      address(malt),\n      address(rewardToken),\n      liquidityBalance,\n      0,\n      0,\n      msg.sender, // transfer broken LP tokens to sender\n      now\n    );\n\n    if (amountMalt == 0 || amountReward == 0) {\n      liquidityBalance = lpToken.balanceOf(address(this));\n      lpToken.safeTransfer(msg.sender, liquidityBalance);\n      return (amountMalt, amountReward);\n    }\n  }\n\n  /*\n   * PRIVATE METHODS\n   */\n  function _calculateTradeSize(address sellToken, address buyToken, uint256 priceTarget) private view returns (uint256) {\n    // TODO use data lab average Tue 05 Oct 2021 20:40:23 BST\n    (uint256 sellReserves, uint256 buyReserves) = UniswapV2Library.getReserves(\n      uniswapV2Factory,\n      sellToken,\n      buyToken\n    );\n\n    uint256 invariant = sellReserves.mul(buyReserves);\n\n    uint256 buyBase = 10**uint256(ERC20(buyToken).decimals());\n\n    uint256 leftSide = Babylonian.sqrt(\n      FullMath.mulDiv(\n        invariant.mul(1000),\n        priceTarget,\n        buyBase.div(priceTarget).mul(buyBase).mul(997)\n      )\n    );\n\n    uint256 rightSide = sellReserves.mul(1000).div(997);\n\n    if (leftSide < rightSide) return 0;\n\n    return leftSide.sub(rightSide);\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function addNewBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    require(_buyer != address(0), \"Cannot use address 0\");\n\n    if (buyersActive[_buyer]) {\n      return;\n    }\n\n    buyersActive[_buyer] = true;\n    buyers.push(_buyer);\n\n    _setupRole(BUYER_ROLE, _buyer);\n\n    emit AddMaltBuyer(_buyer);\n  }\n\n  function removeBuyer(address _buyer)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n    notSameBlock\n  {\n    if (buyers.length == 0 || !buyersActive[_buyer]) {\n      return;\n    }\n\n    address buyer;\n    buyersActive[_buyer] = false;\n\n    emit RemoveMaltBuyer(_buyer);\n    revokeRole(BUYER_ROLE, _buyer);\n\n    // Loop until the second last element\n    for (uint i = 0; i < buyers.length - 1; i = i + 1) {\n      if (buyers[i] == _buyer) {\n        // Replace the current item with the last and pop the last away.\n        buyers[i] = buyers[buyers.length - 1];\n        buyers.pop();\n        return;\n      }\n    }\n\n    // If we made it here then the buyers being removed is the last item\n    buyers.pop();\n  }\n\n  // TODO ensure this contract is whitelisted for under peg transfers Mon 06 Sep 2021 23:49:31 BST\n}\n\n\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IRewardThrottle.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ISwingTrader.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/ISupplyDistributionController.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\n/// @title Stabilizer Node\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The backbone of the Malt stability system. In charge of triggering actions to stabilize price\ncontract StabilizerNode is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  uint256 internal stabilizeWindowEnd;\n  uint256 public stabilizeBackoffPeriod = 5 * 60; // 5 minutes\n  uint256 public upperStabilityThreshold = (10**18) / 100; // 1%\n  uint256 public lowerStabilityThreshold = (10**18) / 100;\n  uint256 public maxContributionBps = 70;\n  uint256 public priceAveragePeriod = 5 minutes;\n  uint256 public fastAveragePeriod = 30; // 30 seconds\n  uint256 public overrideDistance = 20; // 2%\n\n  uint256 public expansionDampingFactor = 1;\n\n  uint256 public defaultIncentive = 100;\n\n  uint256 public daoRewardCut;\n  uint256 public lpRewardCut = 417;\n  uint256 public auctionPoolRewardCut = 113;\n  uint256 public swingTraderRewardCut = 417;\n  uint256 public treasuryRewardCut = 50;\n  uint256 public callerRewardCut = 3;\n\n  uint256 public lastStabilize;\n\n  ERC20 public rewardToken;\n  IBurnMintableERC20 public malt;\n  IAuction public auction;\n  IDexHandler public dexHandler;\n  IDAO public dao;\n  address public uniswapV2Factory;\n  ILiquidityExtension public liquidityExtension;\n  IMaltDataLab public maltDataLab;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n  IRewardThrottle public rewardThrottle;\n  ISwingTrader public swingTrader;\n  IImpliedCollateralService public impliedCollateralService;\n\n  address payable public treasuryMultisig;\n  address public auctionPool;\n  address public supplyDistributionController;\n  address public auctionStartController;\n\n  event MintMalt(uint256 amount);\n  event Stabilize(uint256 timestamp, uint256 exchangeRate);\n  event RewardDistribution(uint256 rewarded);\n  event SetAnnualYield(uint256 yield);\n  event SetStabilizeBackoff(uint256 period);\n  event SetAuctionBurnSkew(address auctionBurnReserveSkew);\n  event SetRewardCut(uint256 daoCut, uint256 lpCut, uint256 callerCut, uint256 treasuryCut, uint256 auctionPoolCut, uint256 swingTraderCut);\n  event SetTreasury(address newTreasury);\n  event SetDefaultIncentive(uint256 incentive);\n  event SetExpansionDamping(uint256 amount);\n  event SetNewMaltDataLab(address dataLab);\n  event SetAuctionContract(address auction);\n  event SetDexHandler(address dexHandler);\n  event SetDao(address dao);\n  event SetLiquidityExtension(address liquidityExtension);\n  event SetRewardThrottle(address rewardThrottle);\n  event SetSwingTrader(address swingTrader);\n  event SetPriceAveragePeriod(uint256 period);\n  event SetOverrideDistance(uint256 distance);\n  event SetFastAveragePeriod(uint256 period);\n  event SetStabilityThresholds(uint256 upper, uint256 lower);\n  event SetAuctionPool(address auctionPool);\n  event SetMaxContribution(uint256 maxContribution);\n  event SetImpliedCollateralService(address impliedCollateralService);\n  event SetSupplyDistributionController(address _controller);\n  event SetAuctionStartController(address _controller);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _rewardToken,\n    address _malt,\n    address _auction,\n    address _uniswapV2Factory,\n    address payable _treasuryMultisig,\n    address _auctionPool\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(AUCTION_ROLE, _auction);\n\n    rewardToken = ERC20(_rewardToken);\n    malt = IBurnMintableERC20(_malt);\n    auction = IAuction(_auction);\n\n    uniswapV2Factory = _uniswapV2Factory;\n    treasuryMultisig = _treasuryMultisig;\n    auctionPool = _auctionPool;\n\n    lastStabilize = block.timestamp;\n  }\n\n  function setupContracts(\n    address _dexHandler,\n    address _maltDataLab,\n    address _auctionBurnReserveSkew,\n    address _rewardThrottle,\n    address _dao,\n    address _swingTrader,\n    address _liquidityExtension,\n    address _impliedCollateralService\n  ) external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    dexHandler = IDexHandler(_dexHandler);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    dao = IDAO(_dao);\n    swingTrader = ISwingTrader(_swingTrader);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function stabilize() external notSameBlock {\n    auction.checkAuctionFinalization();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n    stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;\n\n    rewardThrottle.checkRewardUnderflow();\n\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);\n\n    if (!_shouldAdjustSupply(exchangeRate)) {\n      maltDataLab.trackReserveRatio();\n\n      lastStabilize = block.timestamp;\n      return;\n    }\n\n    emit Stabilize(block.timestamp, exchangeRate);\n\n    if (exchangeRate > maltDataLab.priceTarget()) {\n      _distributeSupply();\n    } else {\n      _startAuction();\n    }\n\n    lastStabilize = block.timestamp;\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _stabilityWindowOverride() internal view returns (bool) {\n    if (hasRole(ADMIN_ROLE, _msgSender())) {\n      // Admin can always stabilize\n      return true;\n    }\n    // Must have elapsed at least one period of the moving average before we stabilize again\n    if (block.timestamp < lastStabilize + fastAveragePeriod) {\n      return false;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 exchangeRate = maltDataLab.maltPriceAverage(fastAveragePeriod);\n\n    uint256 upperThreshold = priceTarget.mul(1000 + overrideDistance).div(1000);\n    uint256 lowerThreshold = priceTarget.mul(1000 - overrideDistance).div(1000);\n\n    return exchangeRate <= lowerThreshold || exchangeRate >= upperThreshold;\n  }\n\n  function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {\n    uint256 decimals = rewardToken.decimals();\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals);\n    uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals);\n\n    return (exchangeRate <= priceTarget.sub(lowerThreshold) && !auction.auctionActive(auction.currentAuctionId())) || exchangeRate >= priceTarget.add(upperThreshold);\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _distributeSupply() internal {\n    if (supplyDistributionController != address(0)) {\n      bool success = ISupplyDistributionController(supplyDistributionController).check();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget).div(expansionDampingFactor);\n\n    if (tradeSize == 0) {\n      return;\n    }\n\n    uint256 swingAmount = swingTrader.sellMalt(tradeSize);\n\n    if (swingAmount >= tradeSize) {\n      return;\n    }\n\n    tradeSize = tradeSize - swingAmount;\n\n    malt.mint(address(dexHandler), tradeSize);\n    emit MintMalt(tradeSize);\n    uint256 rewards = dexHandler.sellMalt();\n\n    auctionBurnReserveSkew.addAbovePegObservation(tradeSize);\n\n    uint256 remaining = _replenishLiquidityExtension(rewards);\n\n    _distributeRewards(remaining);\n\n    maltDataLab.trackReserveRatio();\n    impliedCollateralService.claim();\n  }\n\n  function _distributeRewards(uint256 rewarded) internal {\n    if (rewarded == 0) {\n      return;\n    }\n    rewardToken.approve(address(auction), rewarded);\n    rewarded = auction.allocateArbRewards(rewarded);\n\n    if (rewarded == 0) {\n      return;\n    }\n\n    uint256 callerCut = rewarded.mul(callerRewardCut).div(1000);\n    uint256 lpCut = rewarded.mul(lpRewardCut).div(1000);\n    uint256 daoCut = rewarded.mul(daoRewardCut).div(1000);\n    uint256 auctionPoolCut = rewarded.mul(auctionPoolRewardCut).div(1000);\n    uint256 swingTraderCut = rewarded.mul(swingTraderRewardCut).div(1000);\n\n    // Treasury gets paid after everyone else\n    uint256 treasuryCut = rewarded - daoCut - lpCut - callerCut - auctionPoolCut - swingTraderCut;\n\n    assert(treasuryCut <= rewarded);\n\n    if (callerCut > 0) {\n      rewardToken.safeTransfer(msg.sender, callerCut);\n    }\n\n    if (auctionPoolCut > 0) {\n      rewardToken.safeTransfer(auctionPool, auctionPoolCut);\n    }\n\n    if (swingTraderCut > 0) {\n      rewardToken.safeTransfer(address(swingTrader), swingTraderCut);\n    }\n\n    if (treasuryCut > 0) {\n      rewardToken.safeTransfer(treasuryMultisig, treasuryCut);\n    }\n\n    if (daoCut > 0) {\n      rewardToken.safeTransfer(address(dao), daoCut);\n    }\n\n    if (lpCut > 0) {\n      rewardToken.safeTransfer(address(rewardThrottle), lpCut);\n      rewardThrottle.handleReward();\n    }\n\n    emit RewardDistribution(rewarded);\n  }\n\n  function _replenishLiquidityExtension(uint256 rewards) internal returns (uint256 remaining) {\n    if (liquidityExtension.hasMinimumReserves() || rewards == 0) {\n      return rewards;\n    }\n\n    (uint256 deficit,) = liquidityExtension.collateralDeficit();\n\n    uint256 maxContrib = rewards.mul(maxContributionBps).div(100);\n\n    if (deficit >= maxContrib) {\n      rewardToken.safeTransfer(address(liquidityExtension), maxContrib);\n      return rewards - maxContrib;\n    }\n\n    rewardToken.safeTransfer(address(liquidityExtension), deficit);\n\n    return rewards - deficit;\n  }\n\n  function _startAuction() internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 purchaseAmount = dexHandler.calculateBurningTradeSize(priceTarget);\n\n    if (purchaseAmount == 0) {\n      return;\n    }\n\n    uint256 decimals = rewardToken.decimals();\n\n    uint256 amountUsed = swingTrader.buyMalt(purchaseAmount);\n\n    purchaseAmount = purchaseAmount - amountUsed;\n\n    if (purchaseAmount < 10**decimals) {\n      return;\n    }\n\n    auction.triggerAuction(priceTarget, purchaseAmount);\n\n    malt.mint(msg.sender, defaultIncentive*10**18);\n    emit MintMalt(defaultIncentive*10**18);\n\n    auctionBurnReserveSkew.addBelowPegObservation(purchaseAmount);\n\n    maltDataLab.trackReserveRatio();\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function setStabilizeBackoff(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Must be greater than 0\");\n    stabilizeBackoffPeriod = _period;\n    emit SetStabilizeBackoff(_period);\n  }\n\n  function setAuctionBurnSkew(address _auctionBurnReserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    emit SetAuctionBurnSkew(_auctionBurnReserveSkew);\n  }\n\n  function setRewardCut(\n    uint256 _daoCut,\n    uint256 _lpCut,\n    uint256 _callerCut,\n    uint256 _auctionPoolCut,\n    uint256 _swingTraderCut\n  )\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    uint256 sum = _daoCut.add(_lpCut).add(_callerCut).add(_auctionPoolCut).add(_swingTraderCut);\n    require(sum <= 1000, \"Reward cut must be <= 100%\");\n    daoRewardCut = _daoCut;\n    lpRewardCut = _lpCut;\n    callerRewardCut = _callerCut;\n    auctionPoolRewardCut = _auctionPoolCut;\n    swingTraderRewardCut = _swingTraderCut;\n    treasuryRewardCut = 1000 - sum;\n\n    emit SetRewardCut(_daoCut, _lpCut, _callerCut, treasuryRewardCut, _auctionPoolCut, _swingTraderCut);\n  }\n\n  function setTreasury(address payable _newTreasury)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    treasuryMultisig = _newTreasury;\n    emit SetTreasury(_newTreasury);\n  }\n\n  function setDefaultIncentive(uint256 _incentive)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_incentive > 0, \"No negative incentive\");\n\n    defaultIncentive = _incentive;\n\n    emit SetDefaultIncentive(_incentive);\n  }\n\n  function setExpansionDamping(uint256 amount)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(amount > 0, \"No negative damping\");\n\n    expansionDampingFactor = amount;\n    emit SetExpansionDamping(amount);\n  }\n\n  function setNewDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetNewMaltDataLab(_dataLab);\n  }\n\n  function setAuctionContract(address _auction)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n\n    if (address(auction) != address(0)) {\n      revokeRole(AUCTION_ROLE, address(auction));\n    }\n\n    auction = IAuction(_auction);\n    _setupRole(AUCTION_ROLE, _auction);\n    emit SetAuctionContract(_auction);\n  }\n\n  function setStabilityThresholds(uint256 _upper, uint256 _lower)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_upper > 0 && _lower > 0, \"Must be above 0\");\n\n    upperStabilityThreshold = _upper;\n    lowerStabilityThreshold = _lower;\n    emit SetStabilityThresholds(_upper, _lower);\n  }\n\n  function setAuctionPool(address _auctionPool)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_auctionPool != address(0), \"Not address 0\");\n\n    auctionPool = _auctionPool;\n    emit SetAuctionPool(_auctionPool);\n  }\n\n  function setSupplyDistributionController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    supplyDistributionController = _controller;\n    emit SetSupplyDistributionController(_controller);\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n    emit SetAuctionStartController(_controller);\n  }\n\n  function setMaxContribution(uint256 _maxContribution)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_maxContribution > 0 && _maxContribution <= 100, \"Must be between 0 and 100\");\n\n    maxContributionBps = _maxContribution;\n    emit SetMaxContribution(_maxContribution);\n  }\n\n  function setDexHandler(address _dexHandler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dexHandler != address(0), \"Not address 0\");\n    dexHandler = IDexHandler(_dexHandler);\n    emit SetDexHandler(_dexHandler);\n  }\n\n  function setDao(address _dao)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_dao != address(0), \"Not address 0\");\n    dao = IDAO(_dao);\n    emit SetDao(_dao);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_liquidityExtension != address(0), \"Not address 0\");\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    emit SetLiquidityExtension(_liquidityExtension);\n  }\n\n  function setRewardThrottle(address _rewardThrottle)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_rewardThrottle != address(0), \"Not address 0\");\n    rewardThrottle = IRewardThrottle(_rewardThrottle);\n    emit SetRewardThrottle(_rewardThrottle);\n  }\n\n  function setSwingTrader(address _swingTrader)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_swingTrader != address(0), \"Not address 0\");\n    swingTrader = ISwingTrader(_swingTrader);\n    emit SetSwingTrader(_swingTrader);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_impliedCollateralService != address(0), \"Not address 0\");\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    emit SetImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setPriceAveragePeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    priceAveragePeriod = _period;\n    emit SetPriceAveragePeriod(_period);\n  }\n\n  function setOverrideDistance(uint256 _distance)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_distance > 0 && _distance < 1000, \"Override must be between 0-100%\");\n    overrideDistance = _distance;\n    emit SetOverrideDistance(_distance);\n  }\n\n  function setFastAveragePeriod(uint256 _period)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_period > 0, \"Cannot have 0 period\");\n    fastAveragePeriod = _period;\n    emit SetFastAveragePeriod(_period);\n  }\n}\n\n\n",
        "CodeNames": [
            "UniswapHandler.sol",
            "StabilizerNode.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "UniswapHandler.sol, StabilizerNode.sol",
                "Type": "Flashloan attack",
                "Description": "The AMM pool can be drained using a flashloan and calling stabilize due to the vulnerability in the trade size calculation in UniswapHandler.sol and StabilizerNode.sol.",
                "Repair": "Use a short TWAP to calculate the trade size instead of reading directly from the pool"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IMiningService.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\n\nimport \"./Permissions.sol\";\n\n\nstruct UserState {\n  uint256 bonded;\n\n  // TODO calculate average bonded period for log calc Tue 03 Aug 2021 11:22:39 BST\n  uint256 bondedEpoch;\n}\n\nstruct EpochState {\n  uint256 lastTotalBonded;\n  uint256 lastUpdateTime;\n  uint256 cumulativeTotalBonded;\n}\n\n\n/// @title LP Bonding\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The contract which LP tokens are bonded to to make a user eligible for protocol rewards\ncontract Bonding is Initializable, Permissions {\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public stakeToken;\n  IDAO public dao;\n  IMiningService public miningService;\n  IDexHandler public dexHandler;\n  IMaltDataLab public maltDataLab;\n\n  uint256 internal _globalBonded;\n  uint256 internal _currentEpoch;\n  address internal offering;\n  mapping(address => UserState) internal userState;\n  mapping(uint256 => EpochState) internal epochState;\n\n  event Bond(address indexed account, uint256 value);\n  event Unbond(address indexed account, uint256 value);\n  event UnbondAndBreak(address indexed account, uint256 amountLPToken, uint256 amountMalt, uint256 amountReward);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    address _rewardToken,\n    address _stakeToken,\n    address _dao,\n    address _miningService,\n    address _offering,\n    address _dexHandler,\n    address _maltDataLab\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    dao = IDAO(_dao);\n    offering = _offering;\n    stakeToken = ERC20(_stakeToken);\n    miningService = IMiningService(_miningService);\n    dexHandler = IDexHandler(_dexHandler);\n    malt = ERC20(_malt);\n    rewardToken = ERC20(_rewardToken);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n  }\n\n  function bond(uint256 amount) external {\n    bondToAccount(msg.sender, amount);\n  }\n\n  function bondToAccount(address account, uint256 amount)\n    public\n  {\n    if (msg.sender != offering) {\n      _notSameBlock();\n    }\n    require(amount > 0, \"Cannot bond 0\");\n\n    miningService.onBond(account, amount);\n\n    _bond(account, amount);\n  }\n\n  function unbond(uint256 amount)\n    external\n  {\n    require(amount > 0, \"Cannot unbond 0\");\n\n    uint256 bondedBalance = balanceOfBonded(msg.sender);\n\n    require(bondedBalance > 0, \"< bonded balance\");\n    require(amount <= bondedBalance, \"< bonded balance\");\n\n    // Avoid leaving dust behind\n    if (amount.add(1e16) > bondedBalance) {\n      amount = bondedBalance;\n    }\n\n    miningService.onUnbond(msg.sender, amount);\n\n    _unbond(amount);\n  }\n\n  function unbondAndBreak(uint256 amount)\n    external\n  {\n    require(amount > 0, \"Cannot unbond 0\");\n\n    uint256 bondedBalance = balanceOfBonded(msg.sender);\n\n    require(bondedBalance > 0, \"< bonded balance\");\n    require(amount <= bondedBalance, \"< bonded balance\");\n\n    // Avoid leaving dust behind\n    if (amount.add(1e16) > bondedBalance) {\n      amount = bondedBalance;\n    }\n\n    miningService.onUnbond(msg.sender, amount);\n\n    _unbondAndBreak(amount);\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function averageBondedValue(uint256 epoch) public view returns (uint256) {\n    EpochState storage state = epochState[epoch];\n    uint256 epochLength = dao.epochLength();\n    uint256 timeElapsed = epochLength;\n    uint256 epochStartTime = dao.getEpochStartTime(epoch);\n    uint256 diff;\n    uint256 lastUpdateTime = state.lastUpdateTime;\n    uint256 lastTotalBonded = state.lastTotalBonded;\n\n    if (lastUpdateTime == 0) {\n      lastUpdateTime = epochStartTime;\n    }\n\n    if (lastTotalBonded == 0) {\n      lastTotalBonded = _globalBonded;\n    }\n\n    if (block.timestamp < epochStartTime) {\n      return 0;\n    }\n\n    if (epochStartTime + epochLength <= lastUpdateTime) {\n      return maltDataLab.realValueOfLPToken((state.cumulativeTotalBonded) / epochLength);\n    }\n\n    if (epochStartTime + epochLength < block.timestamp) {\n      // The desired epoch is in the past\n      diff = (epochStartTime + epochLength) - lastUpdateTime;\n    } else {\n      diff = block.timestamp - lastUpdateTime;\n      timeElapsed = block.timestamp - epochStartTime;\n    }\n\n    if (timeElapsed == 0) {\n      // Only way timeElapsed should == 0 is when block.timestamp == epochStartTime\n      // Therefore just return the lastTotalBonded value\n      return maltDataLab.realValueOfLPToken(lastTotalBonded);\n    }\n\n    uint256 endValue = state.cumulativeTotalBonded + (lastTotalBonded.mul(diff));\n    return maltDataLab.realValueOfLPToken((endValue) / timeElapsed);\n  }\n\n  function totalBonded() public view returns (uint256) {\n    return _globalBonded;\n  }\n\n  function balanceOfBonded(address account) public view returns (uint256) {\n    return userState[account].bonded;\n  }\n\n  function bondedEpoch(address account) public view returns (uint256) {\n    return userState[account].bondedEpoch;\n  }\n\n  function epochData(uint256 epoch) public view returns(uint256, uint256, uint256) {\n    return (epochState[epoch].lastTotalBonded, epochState[epoch].lastUpdateTime, epochState[epoch].cumulativeTotalBonded);\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _balanceCheck() internal view {\n    require(stakeToken.balanceOf(address(this)) >= totalBonded(), \"Balance inconsistency\");\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _bond(address account, uint256 amount) internal {\n    stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n\n    _addToBonded(account, amount);\n\n    _balanceCheck();\n\n    emit Bond(account, amount);\n  }\n\n  function _unbond(uint256 amountLPToken) internal notSameBlock {\n    _removeFromBonded(msg.sender, amountLPToken, \"LP: Insufficient bonded balance\");\n\n    stakeToken.safeTransfer(msg.sender, amountLPToken);\n\n    _balanceCheck();\n\n    emit Unbond(msg.sender, amountLPToken);\n  }\n\n  function _unbondAndBreak(uint256 amountLPToken) internal notSameBlock {\n    _removeFromBonded(msg.sender, amountLPToken, \"LP: Insufficient bonded balance\");\n\n    stakeToken.safeTransfer(address(dexHandler), amountLPToken);\n\n    (uint256 amountMalt, uint256 amountReward) = dexHandler.removeLiquidity();\n\n    malt.safeTransfer(msg.sender, amountMalt);\n    rewardToken.safeTransfer(msg.sender, amountReward);\n\n    _balanceCheck();\n\n    emit UnbondAndBreak(msg.sender, amountLPToken, amountMalt, amountReward);\n  }\n\n  function _addToBonded(address account, uint256 amount) internal {\n    userState[account].bonded = userState[account].bonded.add(amount);\n\n    _updateEpochState(_globalBonded.add(amount));\n\n    if (userState[account].bondedEpoch == 0) {\n      userState[account].bondedEpoch = dao.epoch();\n    }\n  }\n\n  function _removeFromBonded(address account, uint256 amount, string memory reason) internal {\n    userState[account].bonded = userState[account].bonded.sub(amount, reason);\n\n    _updateEpochState(_globalBonded.sub(amount, reason));\n  }\n\n  function _updateEpochState(uint256 newTotalBonded) internal {\n    EpochState storage state = epochState[_currentEpoch];\n    uint256 epoch = dao.epoch();\n    uint256 epochStartTime = dao.getEpochStartTime(_currentEpoch);\n    uint256 lastUpdateTime = state.lastUpdateTime;\n    uint256 lengthOfEpoch = dao.epochLength();\n    uint256 epochEndTime = epochStartTime + lengthOfEpoch;\n\n    if (lastUpdateTime == 0) {\n      lastUpdateTime = epochStartTime;\n    }\n\n    if (lastUpdateTime > epochEndTime) {\n      lastUpdateTime = epochEndTime;\n    }\n\n    if (epoch == _currentEpoch) {\n      // We are still in the same epoch. Just update\n      uint256 finalTime = block.timestamp;\n      if (block.timestamp > epochEndTime) {\n        // We are past the end of the epoch so cap to end of epoch\n        finalTime = epochEndTime;\n      } \n\n      uint256 diff = finalTime - lastUpdateTime;\n\n      if (diff > 0) {\n        state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));\n\n        state.lastUpdateTime = finalTime;\n        state.lastTotalBonded = newTotalBonded;\n      }\n    } else {\n      // We have crossed at least 1 epoch boundary\n\n      // Won't underflow due to check on lastUpdateTime above\n      uint256 diff = epochEndTime - lastUpdateTime;\n\n      state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));\n      state.lastUpdateTime = epochEndTime;\n      state.lastTotalBonded = _globalBonded;\n\n      for (uint256 i = _currentEpoch + 1; i <= epoch; i += 1) {\n        state = epochState[i];\n        epochStartTime = dao.getEpochStartTime(i);\n        epochEndTime = epochStartTime + lengthOfEpoch;\n        state.lastTotalBonded = _globalBonded;\n\n        if (epochEndTime < block.timestamp) {\n          // The desired epoch is in the past\n          diff = lengthOfEpoch;\n          state.lastUpdateTime = epochEndTime;\n        } else {\n          diff = block.timestamp - epochStartTime;\n          state.lastUpdateTime = block.timestamp;\n        }\n\n        state.cumulativeTotalBonded = state.lastTotalBonded.mul(diff);\n      }\n\n      state.lastTotalBonded = newTotalBonded;\n      _currentEpoch = epoch;\n    } \n\n    _globalBonded = newTotalBonded;\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_miningService != address(0), \"Cannot set 0 address\");\n    miningService = IMiningService(_miningService);\n  }\n\n  function setDAO(address _dao)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_dao != address(0), \"Cannot set 0 address\");\n    dao = IDAO(_dao);\n  }\n\n  function setDexHandler(address _dexHandler)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_dexHandler != address(0), \"Cannot set 0 address\");\n    dexHandler = IDexHandler(_dexHandler);\n  }\n\n  function setCurrentEpoch(uint256 _epoch)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _currentEpoch = _epoch;\n  }\n}\n\n\n",
        "CodeNames": [
            "Bonding.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Bonding.sol",
                "Type": "Reentrancy",
                "Description": "The _notSameBlock() function in Bonding.sol can be circumvented in bondToAccount() by calling it via a smart contract, leading to potential risks from reentrancy attacks.",
                "Repair": "Add access controls to the function bondToAccount() to prevent reentrancy attacks"
            },
            {
                "Location": "Bonding doesn't work with fee-on transfer tokens",
                "Type": "Smart Contract Vulnerability",
                "Description": "The bonding function does not account for fee-on-transfer tokens, causing the function to revert and fail.",
                "Repair": "Measure the asset change right before and after the asset-transferring calls and use the difference as the actual bonded amount"
            },
            {
                "Location": "Bonding.sol _unbondAndBreak",
                "Type": "smart contract vulnerability",
                "Description": "Bonding.sol _unbondAndBreak does not account for edge case where no tokens are returned.",
                "Repair": "Add a similar edge case check to _unbondAndBreak. In the case where LP tokens are transferred back to Bonding.sol instead of malt/reward, these LP tokens should be forwarded back to the user since the value is rightfully theirs."
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\nimport \"./interfaces/IStabilizerNode.sol\";\nimport \"./interfaces/IMovingAverage.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\n\nimport \"./libraries/UniswapV2Library.sol\";\nimport \"./libraries/SafeBurnMintableERC20.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Malt Data Lab\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The central source of all of Malt protocol's internal data needs\n/// @dev Over time usage of MovingAverage will likely be replaced with more reliable oracles\ncontract MaltDataLab is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeBurnMintableERC20 for IBurnMintableERC20;\n\n  bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n  IBurnMintableERC20 public rewardToken;\n  IBurnMintableERC20 public malt;\n  ILiquidityExtension public liquidityExtension;\n  IUniswapV2Pair public stakeToken;\n\n  IMovingAverage public reserveRatioMA;\n  IMovingAverage public maltPriceMA;\n  IMovingAverage public poolMaltReserveMA;\n\n  uint256 public priceTarget = 10**18; // $1\n  uint256 public reserveRatioLookback = 10 minutes;\n  uint256 public maltPriceLookback = 10 minutes;\n  uint256 public reserveLookback = 10 minutes;\n\n  event TrackMaltPrice(uint256 price);\n  event TrackPoolReserves(uint256 maltReserves, uint256 rewardReserves);\n  event TrackReserveRatio(uint256 rRatio, uint256 decimals);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    address _rewardToken,\n    address _stakeToken,\n    uint256 _priceTarget,\n    address _liquidityExtension,\n    address _reserveRatioMA,\n    address _maltPriceMA,\n    address _poolMaltReserveMA,\n    address _updater\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _roleSetup(UPDATER_ROLE, _updater);\n    _roleSetup(UPDATER_ROLE, initialAdmin);\n\n    stakeToken = IUniswapV2Pair(_stakeToken);\n    malt = IBurnMintableERC20(_malt);\n    rewardToken = IBurnMintableERC20(_rewardToken);\n    priceTarget = _priceTarget;\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    reserveRatioMA = IMovingAverage(_reserveRatioMA);\n    maltPriceMA = IMovingAverage(_maltPriceMA);\n    poolMaltReserveMA = IMovingAverage(_poolMaltReserveMA);\n  }\n\n  function smoothedReserveRatio() public view returns (uint256) {\n    return reserveRatioMA.getValueWithLookback(reserveRatioLookback);\n  }\n\n  function smoothedMaltPrice() public view returns (uint256) {\n    return maltPriceMA.getValueWithLookback(maltPriceLookback);\n  }\n\n  function smoothedMaltInPool() public view returns (uint256) {\n    return poolMaltReserveMA.getValueWithLookback(reserveLookback);\n  }\n\n  function smoothedReserves() public view returns (uint256 maltReserves, uint256 collateralReserves) {\n    maltReserves = poolMaltReserveMA.getValueWithLookback(reserveLookback);\n    uint256 price = smoothedMaltPrice();\n    return (maltReserves, maltReserves.mul(price).div(priceTarget));\n  }\n\n  function reserveRatioAverage(uint256 _lookback) public view returns (uint256) {\n    return reserveRatioMA.getValueWithLookback(_lookback);\n  }\n\n  function maltPriceAverage(uint256 _lookback) public view returns (uint256) {\n    return maltPriceMA.getValueWithLookback(_lookback);\n  }\n\n  function maltInPoolAverage(uint256 _lookback) public view returns (uint256) {\n    return poolMaltReserveMA.getValueWithLookback(_lookback);\n  }\n\n  function realValueOfLPToken(uint256 amount) external view returns (uint256) {\n    uint256 maltPrice = smoothedMaltPrice();\n    (uint256 maltReserves, uint256 rewardReserves) = smoothedReserves();\n\n    if (maltReserves == 0) {\n      return 0;\n    }\n\n    uint256 totalLPSupply = stakeToken.totalSupply();\n\n    uint256 maltValue = amount.mul(maltReserves).div(totalLPSupply);\n    uint256 rewardValue = amount.mul(rewardReserves).div(totalLPSupply);\n\n    return rewardValue.add(maltValue.mul(maltPrice).div(priceTarget));\n  }\n\n  /*\n   * Public mutation methods\n   */\n  function trackReserveRatio() public {\n    (uint256 reserveRatio, uint256 decimals) = liquidityExtension.reserveRatio();\n\n    reserveRatioMA.update(reserveRatio);\n\n    emit TrackReserveRatio(reserveRatio, decimals);\n  }\n\n  function trackMaltPrice()\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater role\")\n  {\n    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();\n    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));\n    uint256 rewardDecimals = rewardToken.decimals();\n\n    if (token0 == address(rewardToken)) {\n      uint256 price = _normalizedPrice(reserve0, reserve1, rewardDecimals);\n      maltPriceMA.update(price);\n      emit TrackMaltPrice(price);\n    } else {\n      uint256 price = _normalizedPrice(reserve1, reserve0, rewardDecimals);\n      maltPriceMA.update(price);\n\n      emit TrackMaltPrice(price);\n    }\n  }\n\n  function trackPoolReserves()\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater role\")\n  {\n    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();\n    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));\n    uint256 rewardDecimals = rewardToken.decimals();\n\n    if (token0 == address(rewardToken)) {\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve1);\n      emit TrackPoolReserves(reserve1, reserve0);\n    } else {\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve0);\n      emit TrackPoolReserves(reserve0, reserve1);\n    }\n  }\n\n  function trackPool()\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater role\")\n  {\n    (uint256 reserve0, uint256 reserve1,) = stakeToken.getReserves();\n    (address token0,) = UniswapV2Library.sortTokens(address(malt), address(rewardToken));\n    uint256 rewardDecimals = rewardToken.decimals();\n\n    if (token0 == address(rewardToken)) {\n      uint256 price = _normalizedPrice(reserve0, reserve1, rewardDecimals);\n      maltPriceMA.update(price);\n\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve1);\n      emit TrackMaltPrice(price);\n      emit TrackPoolReserves(reserve1, reserve0);\n    } else {\n      uint256 price = _normalizedPrice(reserve1, reserve0, rewardDecimals);\n      maltPriceMA.update(price);\n\n      // Args are (maltReserve)\n      poolMaltReserveMA.update(reserve0);\n      emit TrackMaltPrice(price);\n      emit TrackPoolReserves(reserve0, reserve1);\n    }\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _normalizedPrice(\n    uint256 numerator,\n    uint256 denominator,\n    uint256 decimals\n  ) internal view returns(uint256 price) {\n    // Malt is 18 decimals\n    if (decimals > 18) {\n      uint256 diff = decimals - 18;\n      price = numerator.mul(10**decimals).div(denominator.mul(10**diff));\n    } else if (decimals < 18) {\n      uint256 diff = 18 - decimals;\n      price = (numerator.mul(10**diff)).mul(10**decimals).div(denominator);\n    } else {\n      price = numerator.mul(10**decimals).div(denominator);\n    }\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function setLiquidityExtension(address _liquidityExtension) \n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_liquidityExtension != address(0), \"Must be a valid address\");\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setPriceTarget(uint256 _price)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_price > 0, \"Cannot have 0 price\");\n    priceTarget = _price;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have 0 lookback\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setMaltPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have 0 lookback\");\n    maltPriceLookback = _lookback;\n  }\n\n  function setReserveLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have 0 lookback\");\n    reserveLookback = _lookback;\n  }\n\n  function setReserveAverageContract(address _reserveRatioMA)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_reserveRatioMA != address(0), \"Cannot use 0 address\");\n    reserveRatioMA = IMovingAverage(_reserveRatioMA);\n  }\n\n  function setMaltPriceAverageContract(address _maltPriceMA)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_maltPriceMA != address(0), \"Cannot use 0 address\");\n    maltPriceMA = IMovingAverage(_maltPriceMA);\n  }\n\n  function setMaltReservesAverageContract(address _poolMaltReserveMA)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_poolMaltReserveMA != address(0), \"Cannot use 0 address\");\n    poolMaltReserveMA = IMovingAverage(_poolMaltReserveMA);\n  }\n}\n\n\n",
        "CodeNames": [
            "MaltDataLab.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MaltDataLab",
                "Type": "Outdated data",
                "Description": "Malt Protocol uses stale results from MaltDataLab which can be abused by users, leading to potential risks from miners censoring calls and extracting value from other areas of the protocol which use outdated values.",
                "Repair": "Add calls to trackMaltPrice(), trackPoolReserves, and trackPool wherever the values are impacted by the protocol to ensure the most up-to-date values are used"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"./Permissions.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBurnMintableERC20.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/ILiquidityExtension.sol\";\nimport \"./interfaces/IImpliedCollateralService.sol\";\nimport \"./interfaces/IAuctionBurnReserveSkew.sol\";\nimport \"./interfaces/IAuctionStartController.sol\";\n\n\nstruct AccountCommitment {\n  uint256 commitment;\n  uint256 redeemed;\n  uint256 maltPurchased;\n}\n\nstruct AuctionData {\n  // The full amount of commitments required to return to peg\n  uint256 fullRequirement;\n  // total maximum desired commitments to this auction\n  uint256 maxCommitments;\n  // Quantity of sale currency committed to this auction\n  uint256 commitments;\n  // Malt purchased and burned using current commitments\n  uint256 maltPurchased;\n  // Desired starting price for the auction\n  uint256 startingPrice;\n  // Desired lowest price for the arbitrage token\n  uint256 endingPrice;\n  // Price of arbitrage tokens at conclusion of auction. This is either\n  // when the duration elapses or the maxCommitments is reached\n  uint256 finalPrice;\n  // The peg price for the liquidity pool\n  uint256 pegPrice;\n  // Time when auction started\n  uint256 startingTime;\n  uint256 endingTime;\n  // Is the auction currently accepting commitments?\n  bool active;\n  // The reserve ratio at the start of the auction\n  uint256 preAuctionReserveRatio;\n  // Has this auction been finalized? Meaning any additional stabilizing\n  // has been done\n  bool finalized;\n  // The amount of arb tokens that have been executed and are now claimable\n  uint256 claimableTokens;\n  // The finally calculated realBurnBudget\n  uint256 finalBurnBudget;\n  // The amount of Malt purchased with realBurnBudget\n  uint256 finalPurchased;\n  // A map of all commitments to this auction by specific accounts\n  mapping(address => AccountCommitment) accountCommitments;\n}\n\n\n/// @title Malt Arbitrage Auction\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The under peg Malt mechanism of dutch arbitrage auctions is implemented here\ncontract Auction is Initializable, Permissions {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  bytes32 public constant AUCTION_AMENDER_ROLE = keccak256(\"AUCTION_AMENDER_ROLE\");\n\n  address public stabilizerNode;\n  address public amender;\n  IMaltDataLab public maltDataLab;\n  ERC20 public collateralToken;\n  IBurnMintableERC20 public malt;\n  IDexHandler public dexHandler;\n  ILiquidityExtension public liquidityExtension;\n  IImpliedCollateralService public impliedCollateralService;\n  IAuctionBurnReserveSkew public auctionBurnReserveSkew;\n\n  uint256 public unclaimedArbTokens;\n  uint256 public replenishingAuctionId;\n  uint256 public currentAuctionId;\n  uint256 public claimableArbitrageRewards;\n  uint256 public nextCommitmentId;\n  uint256 public auctionLength = 600; // 10 minutes\n  uint256 public arbTokenReplenishSplit = 7000; // 70%\n  uint256 public maxAuctionEnd = 900; // 90% of target price\n  uint256 public auctionEndReserveBps = 900; // 90% of collateral\n  uint256 public priceLookback = 2 minutes;\n  uint256 public reserveRatioLookback = 30; // 30 seconds\n  uint256 public dustThreshold = 1e4;\n\n  address public auctionStartController;\n\n  mapping (uint256 => AuctionData) internal idToAuction;\n  mapping(address => uint256[]) internal accountCommitmentEpochs;\n\n  event AuctionCommitment(\n    uint256 commitmentId,\n    uint256 auctionId,\n    address account,\n    uint256 commitment,\n    uint256 purchased\n  );\n\n  event ClaimArbTokens(\n    uint256 auctionId,\n    address account,\n    uint256 amountTokens\n  );\n\n  event AuctionEnded(\n    uint256 id,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 maltPurchased\n  );\n\n  event AuctionStarted(\n    uint256 id,\n    uint256 maxCommitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 startingTime,\n    uint256 endingTime\n  );\n\n  event ArbTokenAllocation(\n    uint256 replenishingAuctionId,\n    uint256 maxArbAllocation\n  );\n\n  event SetAuctionLength(uint256 length);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetMaltDataLab(address dataLab);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _collateralToken,\n    address _malt,\n    uint256 _auctionLength,\n    address _stabilizerNode,\n    address _maltDataLab,\n    address _dexHandler,\n    address _liquidityExtension,\n    address _impliedCollateralService,\n    address _auctionBurnReserveSkew,\n    address _amender\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _roleSetup(AUCTION_AMENDER_ROLE, _amender);\n\n    collateralToken = ERC20(_collateralToken);\n    malt = IBurnMintableERC20(_malt);\n    auctionLength = _auctionLength;\n    stabilizerNode = _stabilizerNode;\n    maltDataLab = IMaltDataLab(_maltDataLab);\n    dexHandler = IDexHandler(_dexHandler);\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_auctionBurnReserveSkew);\n    amender = _amender;\n  }\n\n  /*\n   * PUBLIC METHODS\n   */\n  function purchaseArbitrageTokens(uint256 amount) external notSameBlock {\n    require(auctionActive(currentAuctionId), \"No auction running\");\n\n    uint256 realCommitment = _capCommitment(currentAuctionId, amount);\n\n    collateralToken.safeTransferFrom(msg.sender, address(liquidityExtension), realCommitment);\n\n    uint256 purchased = liquidityExtension.purchaseAndBurn(realCommitment);\n    \n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    require(auction.startingTime <= now, \"Auction hasn't started yet\");\n    require(auction.endingTime >= now, \"Auction is already over\");\n    require(auction.active == true, \"Auction is not active\");\n\n    auction.commitments = auction.commitments.add(realCommitment);\n\n    if (auction.accountCommitments[msg.sender].commitment == 0) {\n      accountCommitmentEpochs[msg.sender].push(currentAuctionId);\n    }\n    auction.accountCommitments[msg.sender].commitment = auction.accountCommitments[msg.sender].commitment.add(realCommitment);\n    auction.accountCommitments[msg.sender].maltPurchased = auction.accountCommitments[msg.sender].maltPurchased.add(purchased);\n    auction.maltPurchased = auction.maltPurchased.add(purchased);\n\n    emit AuctionCommitment(\n      nextCommitmentId,\n      currentAuctionId,\n      msg.sender,\n      realCommitment,\n      purchased\n    );\n\n    nextCommitmentId = nextCommitmentId + 1;\n\n    if (auction.commitments >= auction.maxCommitments) {\n      _endAuction(currentAuctionId) ;\n    }\n  }\n\n  function claimArbitrage(uint256 _auctionId) external notSameBlock {\n    uint256 amountTokens = userClaimableArbTokens(msg.sender, _auctionId);\n\n    require(amountTokens > 0, \"No claimable Arb tokens\");\n\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    require(!auction.active, \"Cannot claim tokens on an active auction\");\n\n    AccountCommitment storage commitment = auction.accountCommitments[msg.sender];\n\n    uint256 redemption = amountTokens.mul(auction.finalPrice).div(auction.pegPrice);\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\");\n\n    commitment.redeemed = commitment.redeemed.add(redemption);\n\n    // Unclaimed represents total outstanding, but not necessarily\n    // claimable yet.\n    // claimableArbitrageRewards represents total amount that is now\n    // available to be claimed\n    if (amountTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);\n    }\n\n    if (amountTokens > claimableArbitrageRewards) {\n      claimableArbitrageRewards = 0;\n    } else {\n      claimableArbitrageRewards = claimableArbitrageRewards.sub(amountTokens);\n    }\n\n    collateralToken.safeTransfer(msg.sender, amountTokens);\n\n    emit ClaimArbTokens(\n      _auctionId,\n      msg.sender,\n      amountTokens\n    );\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function isAuctionFinished(uint256 _id) public view returns(bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments);\n  }\n\n  function auctionActive(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    \n    return auction.active && now >= auction.startingTime;\n  }\n\n  function isAuctionFinalized(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n    return auction.finalized;\n  }\n\n  function userClaimableArbTokens(\n    address account,\n    uint256 auctionId\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[auctionId];\n\n    if (auction.claimableTokens == 0 || auction.finalPrice == 0 || auction.commitments == 0) {\n      return 0;\n    }\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n\n    uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(auctionId);\n    }\n\n    uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price);\n    uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price);\n\n    uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens);\n\n    // Avoid leaving dust behind\n    if (amountOut < dustThreshold) {\n      return 0;\n    }\n\n    return amountOut;\n  }\n\n  function balanceOfArbTokens(\n    uint256 _auctionId,\n    address account\n  ) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_auctionId];\n\n    AccountCommitment storage commitment = auction.accountCommitments[account];\n\n    uint256 remaining = commitment.commitment.sub(commitment.redeemed);\n\n    uint256 price = auction.finalPrice;\n\n    if (auction.finalPrice == 0) {\n      price = currentPrice(_auctionId);\n    }\n\n    return remaining.mul(auction.pegPrice).div(price);\n  }\n\n  function averageMaltPrice(uint256 _id) external view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.maltPurchased == 0) {\n      return 0;\n    }\n\n    return auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n  }\n\n  function currentPrice(uint256 _id) public view returns (uint256) {\n    AuctionData storage auction = idToAuction[_id];\n\n    if (auction.startingTime == 0) {\n      return maltDataLab.priceTarget();\n    }\n\n    uint256 secondsSinceStart = 0;\n\n    if (now > auction.startingTime) {\n      secondsSinceStart = now - auction.startingTime;\n    }\n\n    uint256 auctionDuration = auction.endingTime - auction.startingTime;\n\n    if (secondsSinceStart >= auctionDuration) {\n      return auction.endingPrice;\n    }\n\n    uint256 totalPriceDelta = auction.startingPrice.sub(auction.endingPrice);\n\n    uint256 currentPriceDelta = totalPriceDelta.mul(secondsSinceStart).div(auctionDuration);\n\n    return auction.startingPrice.sub(currentPriceDelta);\n  }\n\n  function getAuctionCommitments(uint256 _id) public view returns (uint256 commitments, uint256 maxCommitments) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.commitments, auction.maxCommitments);\n  }\n\n  function getAuctionPrices(uint256 _id) public view returns (uint256 startingPrice, uint256 endingPrice, uint256 finalPrice) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (auction.startingPrice, auction.endingPrice, auction.finalPrice);\n  }\n\n  function auctionExists(uint256 _id) public view returns (bool) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return auction.startingTime > 0;\n  }\n\n  function getAccountCommitments(address account) external view returns (\n    uint256[] memory auctions,\n    uint256[] memory commitments,\n    uint256[] memory awardedTokens,\n    uint256[] memory redeemedTokens,\n    uint256[] memory finalPrice,\n    uint256[] memory claimable,\n    bool[] memory finished\n  ) {\n    uint256[] memory epochCommitments = accountCommitmentEpochs[account];\n\n    auctions = new uint256[](epochCommitments.length);\n    commitments = new uint256[](epochCommitments.length);\n    awardedTokens = new uint256[](epochCommitments.length);\n    redeemedTokens = new uint256[](epochCommitments.length);\n    finalPrice = new uint256[](epochCommitments.length);\n    claimable = new uint256[](epochCommitments.length);\n    finished = new bool[](epochCommitments.length);\n\n    for (uint i = 0; i < epochCommitments.length; ++i) {\n      AuctionData storage auction = idToAuction[epochCommitments[i]];\n\n      AccountCommitment storage commitment = auction.accountCommitments[account];\n\n      uint256 price = auction.finalPrice;\n\n      if (auction.finalPrice == 0) {\n        price = currentPrice(epochCommitments[i]);\n      }\n\n      auctions[i] = epochCommitments[i];\n      commitments[i] = commitment.commitment;\n      awardedTokens[i] = commitment.commitment.mul(auction.pegPrice).div(price);\n      redeemedTokens[i] = commitment.redeemed.mul(auction.pegPrice).div(price);\n      finalPrice[i] = price;\n      claimable[i] = userClaimableArbTokens(account, epochCommitments[i]);\n      finished[i] = isAuctionFinished(epochCommitments[i]);\n    }\n  }\n\n  function getAccountCommitmentAuctions(address account) external view returns (uint[] memory) {\n    return accountCommitmentEpochs[account];\n  }\n\n  function getAuctionParticipationForAccount(address account, uint256 auctionId) external view returns (\n    uint256 commitment,\n    uint256 redeemed,\n    uint256 maltPurchased\n  ) {\n    AccountCommitment storage commitment = idToAuction[auctionId].accountCommitments[account];\n\n    return (commitment.commitment, commitment.redeemed, commitment.maltPurchased);\n  }\n\n  function getActiveAuction() external view returns (\n    uint256 auctionId,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    return (\n      currentAuctionId,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuction(uint256 _id) public view returns (\n    uint256 fullRequirement,\n    uint256 maxCommitments,\n    uint256 commitments,\n    uint256 startingPrice,\n    uint256 endingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 finalBurnBudget,\n    uint256 finalPurchased\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      auction.fullRequirement,\n      auction.maxCommitments,\n      auction.commitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.finalBurnBudget,\n      auction.finalPurchased\n    );\n  }\n\n  function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _triggerAuction(\n    uint256 pegPrice,\n    uint256 rRatio,\n    uint256 purchaseAmount\n  ) internal {\n    if (auctionStartController != address(0)) {\n      bool success = IAuctionStartController(auctionStartController).checkForStart();\n      if (!success) {\n        return;\n      }\n    }\n    (uint256 startingPrice, uint256 endingPrice) = _calculateAuctionPricing(rRatio);\n\n    AuctionData memory auction = AuctionData(\n      purchaseAmount, // fullRequirement\n      purchaseAmount, // maxCommitments\n      0, // commitments\n      0, // maltPurchased\n      startingPrice,\n      endingPrice,\n      0, // finalPrice\n      pegPrice,\n      now, // startingTime\n      now.add(auctionLength), // endingTime\n      true, // active\n      rRatio, // preAuctionReserveRatio\n      false, // finalized\n      0, // claimableTokens\n      0, // finalBurnBudget\n      0 // finalPurchased\n    );\n\n    _createAuction(\n      currentAuctionId,\n      auction\n    );\n  }\n\n  function _capCommitment(uint256 _id, uint256 _commitment) internal view returns (uint256 realCommitment) {\n    AuctionData storage auction = idToAuction[_id];\n\n    realCommitment = _commitment;\n\n    if (auction.commitments.add(_commitment) >= auction.maxCommitments) {\n      realCommitment = auction.maxCommitments.sub(auction.commitments);\n    }\n  }\n\n  function _endAuction(uint256 _id) internal {\n    AuctionData storage auction = idToAuction[_id];\n\n    require(auction.active == true, \"Auction is already over\");\n\n    auction.active = false;\n    auction.finalPrice = currentPrice(_id);\n\n    uint256 amountArbTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n    unclaimedArbTokens = unclaimedArbTokens.add(amountArbTokens);\n\n    emit AuctionEnded(\n      _id,\n      auction.commitments,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.maltPurchased\n    );\n  }\n\n  function _finalizeAuction(uint256 auctionId) internal {\n    (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    ) = _setupAuctionFinalization(auctionId);\n\n    if (commitments >= fullRequirement) {\n      return;\n    }\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n\n    // priceTarget.sub(preAuctionReserveRatio) represents maximum deficit per token\n    // priceTarget divided by the max deficit is equivalent to 1 over the max deficit given we are in uint decimal\n    // (commitments * 1/maxDeficit) - commitments\n    uint256 maxBurnSpend = (commitments.mul(priceTarget).div(priceTarget.sub(preAuctionReserveRatio))).sub(commitments);\n\n    uint256 totalTokens = commitments.mul(priceTarget).div(finalPrice);\n\n    uint256 premiumExcess = 0;\n\n    // The assumption here is that each token will be worth 1 Malt when redeemed.\n    // Therefore if totalTokens is greater than the malt purchased then there is a net supply growth\n    // After the tokens are repaid. We want this process to be neutral to supply at the very worst.\n    if (totalTokens >= maltPurchased) {\n      // This also assumes current purchase price of Malt is $1, which is higher than it will be in practice.\n      // So the premium excess will actually ensure slight net negative supply growth.\n      premiumExcess = totalTokens - maltPurchased;\n    }\n\n    uint256 realBurnBudget = auctionBurnReserveSkew.getRealBurnBudget(maxBurnSpend, premiumExcess);\n\n    if (realBurnBudget > 0) {\n      AuctionData storage auction = idToAuction[auctionId];\n\n      auction.finalBurnBudget = realBurnBudget;\n      auction.finalPurchased = liquidityExtension.purchaseAndBurn(realBurnBudget);\n    }\n  }\n\n  function _setupAuctionFinalization(uint256 auctionId)\n    internal\n    returns (\n      uint256 avgMaltPrice,\n      uint256 commitments,\n      uint256 fullRequirement,\n      uint256 maltPurchased,\n      uint256 finalPrice,\n      uint256 preAuctionReserveRatio\n    )\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.startingTime > 0, \"No auction available for the given id\");\n\n    auction.finalized = true;\n\n    if (auction.maltPurchased > 0) {\n      avgMaltPrice = auction.commitments.mul(auction.pegPrice).div(auction.maltPurchased);\n    }\n    \n    return (\n      avgMaltPrice,\n      auction.commitments,\n      auction.fullRequirement,\n      auction.maltPurchased,\n      auction.finalPrice,\n      auction.preAuctionReserveRatio\n    );\n  }\n\n  function _createAuction(\n    uint256 _id,\n    AuctionData memory auction\n  ) internal {\n    require(auction.endingTime == uint256(uint64(auction.endingTime)));\n\n    idToAuction[_id] = auction;\n\n    emit AuctionStarted(\n      _id,\n      auction.maxCommitments,\n      auction.startingPrice,\n      auction.endingPrice,\n      auction.startingTime,\n      auction.endingTime\n    );\n  }\n\n  function _calcRealMaxRaise(uint256 purchaseAmount, uint256 rRatio, uint256 decimals) internal pure returns (uint256) {\n    uint256 realBurn = purchaseAmount.mul(\n      Math.min(\n        rRatio,\n        10**decimals\n      )\n    ).div(10**decimals);\n\n    return purchaseAmount.sub(realBurn);\n  }\n\n  function _calculateAuctionPricing(uint256 rRatio) internal view returns (\n    uint256 startingPrice,\n    uint256 endingPrice\n  ) {\n    startingPrice = maltDataLab.maltPriceAverage(priceLookback);\n\n    if (startingPrice < rRatio) {\n      startingPrice = rRatio;\n    }\n\n    // TODO use global intrinsic value instead of rRatio Fri 12 Nov 2021 11:51:28 GMT\n\n    // rRatio should never be large enough for this to overflow\n    uint256 absoluteBottom = rRatio * auctionEndReserveBps / 1000;\n\n    uint256 priceTarget = maltDataLab.priceTarget();\n    uint256 idealBottom = 1; // 1wei just to avoid any issues with it being 0\n\n    // This should always be true\n    if (priceTarget > rRatio) {\n      idealBottom = priceTarget - rRatio;\n    }\n\n    assert(priceTarget >= startingPrice);\n    assert(startingPrice > endingPrice);\n\n    if (idealBottom < startingPrice) {\n      endingPrice = idealBottom;\n    } else {\n      endingPrice = absoluteBottom;\n    } \n\n    // priceTarget should never be large enough to overflow here\n    uint256 maxPrice = priceTarget * maxAuctionEnd / 1000;\n\n    if (endingPrice > maxPrice) {\n      endingPrice = maxPrice;\n    }\n  }\n\n  function _checkAuctionFinalization(bool isInternal) internal {\n    if (isInternal && !isAuctionFinished(currentAuctionId)) {\n      // Auction is still in progress after internal auction purchasing.\n      _resetAuctionMaxCommitments();\n    }\n\n    if (isAuctionFinished(currentAuctionId)) {\n      if (auctionActive(currentAuctionId)) {\n        _endAuction(currentAuctionId);\n      }\n\n      if (!isAuctionFinalized(currentAuctionId)) {\n        _finalizeAuction(currentAuctionId);\n      }\n      currentAuctionId = currentAuctionId + 1;\n    }\n  }\n\n  function _resetAuctionMaxCommitments() internal {\n    AuctionData storage auction = idToAuction[currentAuctionId];\n\n    uint256 decimals = collateralToken.decimals();\n\n    uint256 realMaxRaise = _calcRealMaxRaise(auction.fullRequirement, auction.preAuctionReserveRatio, decimals);\n\n    if (auction.commitments <= realMaxRaise) {\n      auction.maxCommitments = realMaxRaise;\n    }\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function checkAuctionFinalization()\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    _checkAuctionFinalization(false);\n  }\n\n  function amendAccountParticipation(address account, uint256 auctionId, uint256 amount, uint256 maltPurchase)\n    external\n    onlyRole(AUCTION_AMENDER_ROLE, \"Only auction amender\")\n  {\n    AuctionData storage auction = idToAuction[auctionId];\n    require(auction.accountCommitments[account].commitment >= amount, \"amend: amount underflows\");\n    require(auction.accountCommitments[account].maltPurchased >= maltPurchase, \"amend: maltPurchase underflows\");\n\n    auction.commitments = auction.commitments - amount;\n    auction.maltPurchased = auction.maltPurchased - maltPurchase;\n\n    auction.accountCommitments[account].commitment = auction.accountCommitments[account].commitment - amount; \n    auction.accountCommitments[account].maltPurchased = auction.accountCommitments[account].maltPurchased - maltPurchase;\n\n    uint256 amountArbTokens = amount.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (amountArbTokens > unclaimedArbTokens) {\n      unclaimedArbTokens = 0;\n    } else {\n      unclaimedArbTokens = unclaimedArbTokens.sub(amountArbTokens);\n    }\n  }\n\n  function allocateArbRewards(uint256 rewarded)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n    returns (uint256)\n  {\n    AuctionData storage auction = idToAuction[replenishingAuctionId];\n\n    if (auction.finalPrice == 0 || auction.startingTime == 0) {\n      return rewarded;\n    }\n\n    if (auction.commitments == 0) {\n      replenishingAuctionId = replenishingAuctionId + 1;\n      return rewarded;\n    }\n\n    uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice);\n\n    if (auction.claimableTokens < totalTokens) {\n      uint256 requirement = totalTokens.sub(auction.claimableTokens);\n      uint256 maxArbAllocation = rewarded.mul(arbTokenReplenishSplit).div(10000);\n\n      if (requirement >= maxArbAllocation) {\n        auction.claimableTokens = auction.claimableTokens.add(maxArbAllocation);\n        rewarded = rewarded.sub(maxArbAllocation);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(maxArbAllocation);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), maxArbAllocation);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          maxArbAllocation\n        );\n      } else {\n        auction.claimableTokens = auction.claimableTokens.add(requirement);\n        rewarded = rewarded.sub(requirement);\n        claimableArbitrageRewards = claimableArbitrageRewards.add(requirement);\n\n        collateralToken.safeTransferFrom(stabilizerNode, address(this), requirement);\n\n        emit ArbTokenAllocation(\n          replenishingAuctionId,\n          requirement\n        );\n      }\n\n      if (auction.claimableTokens == totalTokens) {\n        uint256 count = 1;\n\n        while (true) {\n          auction = idToAuction[replenishingAuctionId + count];\n\n          if (auction.commitments > 0 || !auction.finalized) {\n            replenishingAuctionId = replenishingAuctionId + count;\n            break;\n          }\n          count += 1;\n        }\n      }\n    }\n\n    return rewarded;\n  }\n\n  function triggerAuction(uint256 pegPrice, uint256 purchaseAmount)\n    external\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be stabilizer node\")\n  {\n    if (purchaseAmount == 0 || auctionExists(currentAuctionId)) {\n      return;\n    }\n\n    uint256 rRatio = maltDataLab.reserveRatioAverage(reserveRatioLookback);\n\n    _triggerAuction(pegPrice, rRatio, purchaseAmount);\n\n    impliedCollateralService.handleDeficit(purchaseAmount);\n\n    _checkAuctionFinalization(true);\n  }\n\n  function setAuctionLength(uint256 _length)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_length > 0, \"Length must be larger than 0\");\n    auctionLength = _length;\n    emit SetAuctionLength(_length);\n  }\n\n  function setStabilizerNode(address _stabilizerNode)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    _swapRole(_stabilizerNode, stabilizerNode, STABILIZER_NODE_ROLE);\n    stabilizerNode = _stabilizerNode;\n    emit SetStabilizerNode(_stabilizerNode);\n  }\n\n  function setMaltDataLab(address _dataLab)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    maltDataLab = IMaltDataLab(_dataLab);\n    emit SetMaltDataLab(_dataLab);\n  }\n\n  function setAuctionReplenishId(uint256 _id)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    replenishingAuctionId = _id;\n  }\n\n  function setDexHandler(address _handler)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    dexHandler = IDexHandler(_handler);\n  }\n\n  function setLiquidityExtension(address _liquidityExtension)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    liquidityExtension = ILiquidityExtension(_liquidityExtension);\n  }\n\n  function setImpliedCollateralService(address _impliedCollateralService)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    impliedCollateralService = IImpliedCollateralService(_impliedCollateralService);\n  }\n\n  function setAuctionBurnReserveSkew(address _reserveSkew)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    auctionBurnReserveSkew = IAuctionBurnReserveSkew(_reserveSkew);\n  }\n\n  function setAuctionAmender(address _amender)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_amender != address(0), \"Cannot set 0 address\");\n    _swapRole(_amender, amender, AUCTION_AMENDER_ROLE);\n    amender = _amender;\n  }\n\n  function setAuctionStartController(address _controller)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    // This is allowed to be set to address(0) as its checked before calling methods on it\n    auctionStartController = _controller;\n  }\n\n  function setTokenReplenishSplit(uint256 _split)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\");\n    arbTokenReplenishSplit = _split;\n  }\n\n  function setMaxAuctionEnd(uint256 _maxEnd)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\");\n    maxAuctionEnd = _maxEnd;\n  }\n\n  function setPriceLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    priceLookback = _lookback;\n  }\n\n  function setReserveRatioLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_lookback > 0, \"Must be above 0\");\n    reserveRatioLookback = _lookback;\n  }\n\n  function setAuctionEndReserveBps(uint256 _bps)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\");\n    auctionEndReserveBps = _bps;\n  }\n\n  function setDustThreshold(uint256 _threshold)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privilege\")\n  {\n    require(_threshold > 0, \"Must be between greater than 0\");\n    dustThreshold = _threshold;\n  }\n}\n\n\n",
        "CodeNames": [
            "Auction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Auction collateralToken won't work if token is fee-on-transfer token",
                "Type": "Smart Contract Vulnerability",
                "Description": "The smart contract does not account for fee-on-transfer tokens when transferring tokens, which can cause the contract to revert and fail.",
                "Repair": "Add logic to transfers/transferFroms to calculate exactly how many tokens were actually sent to a specific address"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./ERC20Permit.sol\";\nimport \"./Permissions.sol\";\nimport \"./interfaces/ITransferService.sol\";\n\n\n/// @title Malt V2 Token\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The ERC20 token contract for Malt V2\ncontract Malt is ERC20Permit, Initializable, Permissions {\n  using SafeMath for uint256;\n\n  ITransferService public transferService;\n\n  constructor(string memory name, string memory ticker) public ERC20Permit(name, ticker) {}\n\n  event SetTransferService(address service);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _transferService,\n    address[] calldata minters,\n    address[] calldata burners\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    transferService = ITransferService(_transferService);\n\n    for (uint256 i = 0; i < minters.length; i = i + 1) {\n      _setupRole(MONETARY_MINTER_ROLE, minters[i]);\n    }\n    for (uint256 i = 0; i < burners.length; i = i + 1) {\n      _setupRole(MONETARY_BURNER_ROLE, burners[i]);\n    }\n  }\n\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n    (bool success, string memory reason) = transferService.verifyTransfer(from, to, amount);\n    require(success, reason);\n  }\n\n  function mint(address to, uint256 amount)\n    public\n    onlyRole(MONETARY_MINTER_ROLE, \"Must have monetary minter role\")\n  {\n    _mint(to, amount);\n  }\n\n  function burn(address from, uint256 amount)\n    public\n    onlyRole(MONETARY_BURNER_ROLE, \"Must have monetary burner role\")\n  {\n    _burn(from, amount);\n  }\n\n  function setTransferService(address _service)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_service != address(0), \"Cannot use address 0 as transfer service\");\n    transferService = ITransferService(_service);\n    emit SetTransferService(_service);\n  }\n}\n\n\n",
        "CodeNames": [
            "Malt.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "roles in Malt Finance",
                "Type": "smart contract vulnerability",
                "Description": "The power structure is too centralized and protocol may break if anything happens to Admin.",
                "Repair": "1. Some tasks don't really need a special role like StabilizerNode. Should allow any community members to run their own StabilizerNode without approval needed. 2. Consider transfer Admin to Multisig or DAO."
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\n\nimport \"./Permissions.sol\";\n\n\n/// @title Moving Average\n/// @author 0xScotch <scotch@malt.money>\n/// @notice For tracking the average of a data stream over time\n/// @dev Based on the cumulativeValue mechanism for TWAP in uniswapV2\ncontract MovingAverage is Initializable, Permissions {\n  using FixedPoint for *;\n  using SafeMath for uint256;\n\n  struct Sample {\n    uint64 timestamp;\n    uint256 value;\n    uint256 cumulativeValue;\n    uint256 lastValue;\n  }\n\n  bytes32 public constant UPDATER_ROLE = keccak256(\"UPDATER_ROLE\");\n\n  uint256 public sampleLength;\n  uint256 public cumulativeValue;\n  uint256 public sampleMemory;\n  uint256 public defaultValue;\n\n  uint64 public blockTimestampLast;\n\n  uint256 private counter;\n  uint256 private activeSamples;\n\n  Sample[] private samples;\n\n  event Update(uint256 value, uint256 cumulativeValue);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    uint256 _sampleLength, // eg 5min represented as seconds\n    uint256 _sampleMemory,\n    address _updater,\n    uint256 _defaultValue\n  ) external initializer {\n    require(_sampleMemory > 1, 'MA: SampleMemory > 1');\n\n    _adminSetup(_timelock);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n    _roleSetup(UPDATER_ROLE, _updater);\n    _roleSetup(UPDATER_ROLE, initialAdmin);\n\n    sampleLength = _sampleLength;\n    sampleMemory = _sampleMemory;\n    defaultValue = _defaultValue;\n\n    for (uint i = 0; i < sampleMemory; i++) {\n      samples.push();\n    }\n  }\n\n  /*\n   * PUBLIC VIEW METHODS\n   */\n  function getValue() public view returns (uint256) {\n    if (activeSamples < 2) {\n      return defaultValue;\n    } else if (activeSamples == 2) {\n      Sample storage currentSample = _getCurrentSample();\n      return currentSample.value;\n    } else if (activeSamples < sampleMemory) {\n      // Subtract 2 because this is a lookback from the current sample.\n      // activeSamples - 1 is the in progress sample. - 2 is the active sample\n      // IE if there are 2 samples, we are on one and want to lookback 1.\n      // If there are 3 samples, we are on one and want to lookback 2 etc\n      uint256 lookback = (activeSamples - 2) * sampleLength;\n      return getValueWithLookback(lookback);\n    }\n    Sample storage currentSample = _getCurrentSample();\n    Sample storage firstSample = _getFirstSample();\n\n    uint256 timeElapsed = currentSample.timestamp - firstSample.timestamp;\n    uint256 sampleDiff = currentSample.cumulativeValue - firstSample.cumulativeValue;\n\n    if (timeElapsed == 0) {\n      return currentSample.value;\n    } \n\n    FixedPoint.uq112x112 memory sampleAverage = FixedPoint.fraction(sampleDiff, timeElapsed);\n\n    return sampleAverage.decode();\n  }\n\n  function getValueWithLookback(uint256 _lookbackTime) public view returns (uint256) {\n    // _lookbackTime in is seconds\n    uint256 lookbackSamples;\n    if (_lookbackTime % sampleLength == 0) {\n      // If it divides equally just divide down\n      lookbackSamples = _lookbackTime / sampleLength;\n\n      if (lookbackSamples == 0) {\n        lookbackSamples = 1;\n      }\n    } else {\n      // If it doesn't divide equally, divide and add 1.\n      // Creates a Math.ceil() situation\n      lookbackSamples = (_lookbackTime / sampleLength) + 1;\n    }\n\n    if (activeSamples < 2) {\n      return defaultValue;\n    } else if (activeSamples == 2) {\n      Sample storage currentSample = _getCurrentSample();\n      return currentSample.value;\n    } else if (lookbackSamples >= activeSamples - 1) {\n      // Looking for longer lookback than sampleMemory allows.\n      // Just return the full memory average\n      return getValue();\n    }\n\n    Sample storage currentSample = _getCurrentSample();\n    Sample storage nthSample = _getNthSample(lookbackSamples);\n\n    uint256 timeElapsed = currentSample.timestamp - nthSample.timestamp;\n    uint256 sampleDiff = currentSample.cumulativeValue - nthSample.cumulativeValue;\n\n    if (timeElapsed == 0) {\n      return currentSample.value;\n    } \n\n    FixedPoint.uq112x112 memory sampleAverage = FixedPoint.fraction(sampleDiff, timeElapsed);\n\n    return sampleAverage.decode();\n  }\n\n  /*\n   * MUTATION METHODS\n   */\n  function update(uint256 newValue)\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater privs\")\n  {\n    /* \n     * This function only creates a sample at the end of the sample period.\n     * The current sample period just updates the cumulativeValue but doesn't\n     * Actually create a sample until the end of the period.\n     * This is to protect against flashloan attacks that could try manipulate\n     * the samples.\n     */\n    Sample storage liveSample = samples[_getIndexOfSample(counter)];\n    uint64 blockTimestamp = uint64(block.timestamp % 2**64); \n\n    // Deal with first ever sample\n    if (liveSample.timestamp == 0) {\n      liveSample.timestamp = uint64(block.timestamp);\n      liveSample.value = newValue;\n      liveSample.lastValue = newValue;\n      liveSample.cumulativeValue = newValue;\n\n      cumulativeValue = newValue;\n      blockTimestampLast = blockTimestamp;\n\n      activeSamples = activeSamples + 1;\n      return;\n    }\n\n    uint64 timeElapsed = blockTimestamp - liveSample.timestamp;\n\n    if (timeElapsed < sampleLength) {\n      cumulativeValue += liveSample.lastValue.mul(blockTimestamp - blockTimestampLast);\n      liveSample.cumulativeValue = cumulativeValue;\n      liveSample.lastValue = newValue;\n\n      blockTimestampLast = blockTimestamp;\n      return;\n    } else if (timeElapsed >= (sampleLength - 1) * sampleMemory) {\n      // More than total sample memory has elapsed. Reset with new values\n      uint256 addition = liveSample.lastValue.mul(sampleLength);\n\n      uint256 currentCumulative = cumulativeValue;\n      uint64 currentTimestamp = blockTimestamp - uint64(sampleLength * sampleMemory);\n\n      uint256 tempCount = counter;\n      for (uint256 i = 0; i < sampleMemory; i++ ) {\n        tempCount += 1;\n        liveSample = samples[_getIndexOfSample(tempCount)];\n        liveSample.timestamp = currentTimestamp;\n        liveSample.cumulativeValue = currentCumulative;\n\n        currentCumulative += addition;\n        currentTimestamp += uint64(sampleLength);\n      }\n\n      // Reset the adding of 'addition' in the final loop\n      currentCumulative = liveSample.cumulativeValue;\n\n      tempCount += 1;\n      liveSample = samples[_getIndexOfSample(tempCount)];\n      liveSample.timestamp = blockTimestamp;\n      // Only the most recent values really matter here\n      liveSample.value = newValue;\n      liveSample.lastValue = newValue;\n      liveSample.cumulativeValue = currentCumulative;\n\n      counter = tempCount;\n      cumulativeValue = currentCumulative;\n      blockTimestampLast = blockTimestamp;\n      activeSamples = sampleMemory;\n      return;\n    }\n\n    uint64 nextSampleTime = liveSample.timestamp + uint64(sampleLength);\n\n    // Finish out the current sample\n    cumulativeValue += liveSample.lastValue.mul(nextSampleTime - blockTimestampLast);\n    liveSample.cumulativeValue = cumulativeValue;\n\n    liveSample = _createNewSample(nextSampleTime, cumulativeValue);\n    timeElapsed = timeElapsed - uint64(sampleLength);\n\n    uint256 elapsedSamples = timeElapsed / sampleLength;\n\n    for (uint256 i = 1; i <= elapsedSamples; i = i + 1) {\n      // update\n      cumulativeValue += liveSample.lastValue.mul(sampleLength);\n      liveSample.cumulativeValue = cumulativeValue;\n\n      uint64 sampleTime = liveSample.timestamp + uint64(sampleLength);\n\n      liveSample = _createNewSample(sampleTime, cumulativeValue);\n    }\n\n    cumulativeValue += liveSample.lastValue.mul(timeElapsed % sampleLength);\n\n    // Now set the value of the current sample to the new value\n    liveSample.value = newValue;\n    liveSample.lastValue = newValue;\n    liveSample.cumulativeValue = cumulativeValue;\n\n    blockTimestampLast = blockTimestamp;\n\n    emit Update(newValue, cumulativeValue);\n  }\n\n  function updateCumulative(uint256 _cumulative)\n    external \n    onlyRole(UPDATER_ROLE, \"Must have updater privs\")\n  {\n    require(_cumulative >= cumulativeValue, \"Cumulative value can only go up\");\n\n    Sample storage liveSample = samples[_getIndexOfSample(counter)];\n    uint64 blockTimestamp = uint64(block.timestamp % 2**64); \n\n    if (liveSample.timestamp == 0) {\n      cumulativeValue = _cumulative;\n      blockTimestampLast = blockTimestamp;\n\n      liveSample.timestamp = blockTimestamp;\n      liveSample.cumulativeValue = _cumulative;\n      liveSample.value = _cumulative;\n      liveSample.lastValue = _cumulative;\n\n      activeSamples = activeSamples + 1;\n      return;\n    }\n\n    uint64 timeElapsed = blockTimestamp - liveSample.timestamp;\n    uint64 timeElapsedSinceUpdate = blockTimestamp - blockTimestampLast;\n    uint256 newLastValue = (_cumulative - cumulativeValue).div(timeElapsedSinceUpdate);\n\n    if (timeElapsed < sampleLength) {\n      // The current sample isn't over. Just update\n      liveSample.cumulativeValue = _cumulative;\n      liveSample.value = newLastValue;\n      liveSample.lastValue = newLastValue;\n\n      blockTimestampLast = blockTimestamp;\n      cumulativeValue = _cumulative;\n      return;\n    } else if (timeElapsed >= sampleLength * (sampleMemory - 1)) {\n      // More than total sample memory has elapsed. Reset with new values\n\n      uint256 addition = newLastValue.mul(sampleLength);\n\n      uint256 currentCumulative = _cumulative.sub(addition * (sampleMemory - 1));\n      uint64 currentTimestamp = blockTimestamp - uint64(sampleLength * (sampleMemory));\n\n      uint256 tempCount = counter;\n      for (uint256 i = 0; i < sampleMemory; i++ ) {\n        tempCount += 1;\n        liveSample = samples[_getIndexOfSample(tempCount)];\n        liveSample.timestamp = currentTimestamp;\n        liveSample.cumulativeValue = currentCumulative;\n\n        currentCumulative += addition;\n        currentTimestamp += uint64(sampleLength);\n      }\n\n      tempCount += 1;\n      liveSample = samples[_getIndexOfSample(tempCount)];\n      liveSample.timestamp = blockTimestamp;\n      // Only the most recent values really matter here\n      liveSample.value = newLastValue;\n      liveSample.lastValue = newLastValue;\n      liveSample.cumulativeValue = _cumulative;\n\n      counter = tempCount;\n      cumulativeValue = _cumulative;\n      blockTimestampLast = blockTimestamp;\n      activeSamples = sampleMemory;\n      return;\n    }\n\n    // One or more sample boundaries have been crossed.\n    uint64 nextSampleTime = liveSample.timestamp + uint64(sampleLength);\n    // Finish out the current sample\n    cumulativeValue += newLastValue.mul(nextSampleTime - blockTimestampLast);\n    liveSample.cumulativeValue = cumulativeValue;\n    liveSample.lastValue = newLastValue;\n\n    liveSample = _createNewSample(nextSampleTime, cumulativeValue);\n    timeElapsed = timeElapsed - uint64(sampleLength);\n\n    uint256 elapsedSamples = timeElapsed / sampleLength;\n\n    for (uint256 i = 1; i <= elapsedSamples; i = i + 1) {\n      // update\n      cumulativeValue += newLastValue.mul(sampleLength);\n      liveSample.cumulativeValue = cumulativeValue;\n\n      uint64 sampleTime = liveSample.timestamp + uint64(sampleLength);\n\n      liveSample = _createNewSample(sampleTime, cumulativeValue);\n    }\n\n    liveSample.value = newLastValue;\n    liveSample.lastValue = newLastValue;\n    liveSample.cumulativeValue = _cumulative;\n\n    cumulativeValue = _cumulative;\n    blockTimestampLast = blockTimestamp;\n\n    emit Update(newLastValue, cumulativeValue);\n  }\n\n  /*\n   * INTERNAL VIEW METHODS\n   */\n  function _getIndexOfSample(uint _count) internal view returns (uint32 index) {\n    return uint32(_count % sampleMemory);\n  }\n\n  function _getCurrentSample() private view returns (Sample storage currentSample) {\n    // Active sample is always counter - 1. Counter is the in progress sample\n    uint32 currentSampleIndex = _getIndexOfSample(counter - 1);\n    currentSample = samples[currentSampleIndex];\n  }\n\n  function _getFirstSample() private view returns (Sample storage firstSample) {\n    uint32 sampleIndex = _getIndexOfSample(counter);\n    // no overflow issue. if sampleIndex + 1 overflows, result is still zero.\n    uint32 firstSampleIndex = uint32((sampleIndex + 1) % sampleMemory);\n    firstSample = samples[firstSampleIndex];\n  }\n\n  function _getNthSample(uint256 n) private view returns (Sample storage sample) {\n    require(n < activeSamples - 1, \"Not enough samples\");\n    uint32 sampleIndex = _getIndexOfSample(counter - 1 - n);\n    sample = samples[sampleIndex];\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _createNewSample(uint64 sampleTime, uint256 cumulativeValue)\n    internal\n    returns(Sample storage liveSample)\n  {\n    Sample storage oldSample = samples[_getIndexOfSample(counter - 1)];\n    Sample storage previousSample = samples[_getIndexOfSample(counter)];\n\n    if (oldSample.timestamp > 0 && activeSamples > 1) {\n      previousSample.value = (previousSample.cumulativeValue - oldSample.cumulativeValue).div(sampleLength);\n    }\n\n    counter += 1;\n    liveSample = samples[_getIndexOfSample(counter)];\n    liveSample.timestamp = sampleTime;\n    liveSample.cumulativeValue = cumulativeValue;\n    liveSample.value = previousSample.value;\n    liveSample.lastValue = previousSample.lastValue;\n\n    if (activeSamples < sampleMemory) {\n      // Active samples is how we keep track of how many real samples we have vs default 0 values\n      // This is useful for providing data even when full sample set isn't populated yet\n      activeSamples = activeSamples + 1;\n    }\n\n    blockTimestampLast = sampleTime;\n  }\n\n  /*\n   * PRIVILEDGED METHODS\n   */\n  function setSampleLength(uint256 _sampleLength)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_sampleLength > 0, \"Cannot have 0 second sample length\");\n    sampleLength = _sampleLength;\n  }\n\n  function resetLiveSampleTime()\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    Sample storage liveSample = samples[_getIndexOfSample(counter)];\n    liveSample.timestamp = uint64(block.timestamp % 2**64); \n  }\n\n  function setSampleMemory(uint256 _sampleMemory)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_sampleMemory > 0, \"Cannot have sample memroy of 0\");\n\n    if (_sampleMemory > sampleMemory) {\n      for (uint i = sampleMemory; i < _sampleMemory; i++) {\n        samples.push();\n      }\n      counter = counter % _sampleMemory;\n    } else {\n      activeSamples = _sampleMemory;\n\n      // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST\n    }\n\n    sampleMemory = _sampleMemory;\n  }\n}\n\n\n",
        "CodeNames": [
            "MovingAverage.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MovingAverage.sol setSampleMemory function",
                "Type": "Medium Severity",
                "Description": "setSampleMemory function of MovingAverage.sol can break MovingAverage, making the value of exchangeRate in StabilizerNode.stabilize() being extremely wrong.",
                "Repair": "Check for count < sampleMemory in _getFirstSample function"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./interfaces/IStabilizerNode.sol\";\nimport \"./Auction.sol\";\nimport \"./Permissions.sol\";\n\n\n/// @title Auction Burn Reserve Skew\n/// @author 0xScotch <scotch@malt.money>\n/// @notice This contract makes decisions about what do to with excess Liquidity Extension balance at the end of an auction. Burn additional Malt or retain capital in LE\ncontract AuctionBurnReserveSkew is Initializable, Permissions {\n  using SafeMath for uint256;\n\n  // An array of 0s or 1s that track if active stabilization was \n  // needed above or below peg.\n  // 0 = below peg\n  // 1 = above peg\n  //\n  // By doing this we can average the array to get a value that\n  // indicates if we are more frequently over or under peg.\n  uint256[] public pegObservations;\n  uint256 public auctionAverageLookback = 10;\n\n  IStabilizerNode public stabilizerNode;\n  IAuction public auction;\n\n  // This is the total number of stabilization observation we have seen\n  uint256 public count;\n\n  event SetAuctionAverageLookback(uint256 lookback);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetAuction(address auction);\n  event AbovePegObservation(uint256 amount);\n  event BelowPegObservation(uint256 amount);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _stabilizerNode,\n    address _auction,\n    uint256 _period\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    stabilizerNode = IStabilizerNode(_stabilizerNode);\n    auction = IAuction(_auction);\n    auctionAverageLookback = _period;\n\n    for (uint i = 0; i < _period; i++) {\n      pegObservations.push(0);\n    }\n  }\n\n  function consult(uint256 excess) public view returns (uint256) {\n    uint256 frequency = getPegDeltaFrequency();\n    uint256 participation = getAverageParticipation();\n\n    // Weight participation higher than frequency\n    uint256 skew = (frequency + (participation * 2)) / 3;\n\n    return excess.mul(skew).div(10000);\n  }\n\n  function getRealBurnBudget(\n    uint256 maxBurnSpend,\n    uint256 premiumExcess\n  ) public view returns(uint256) {\n    // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement\n    // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn\n\n    if (premiumExcess > maxBurnSpend) {\n      return premiumExcess;\n    }\n\n    uint256 usableExcess = maxBurnSpend.sub(premiumExcess);\n\n    if (usableExcess == 0) {\n      return premiumExcess;\n    }\n\n    uint256 burnable = consult(usableExcess);\n\n    return premiumExcess + burnable;\n  }\n\n  function getAverageParticipation() public view returns (uint256) {\n    uint256 initialAuction = 0;\n    uint256 currentAuctionId = auction.currentAuctionId();\n\n    if (currentAuctionId > auctionAverageLookback) {\n      initialAuction = currentAuctionId - auctionAverageLookback;\n    }\n\n    // Use the existing struct to avoid filling the stack with temp vars\n    AuctionData memory aggregate;\n\n    for (uint256 i = initialAuction; i < currentAuctionId; ++i) {\n      (uint256 commitments, uint256 maxCommitments) = auction.getAuctionCommitments(i);\n      aggregate.maxCommitments = aggregate.maxCommitments + maxCommitments;\n      aggregate.commitments = aggregate.commitments + commitments;\n    }\n\n    uint256 participation = 0;\n    if (aggregate.maxCommitments > 0) {\n      participation = aggregate.commitments.mul(10000).div(aggregate.maxCommitments);\n    }\n\n    return participation;\n  }\n\n  function getPegDeltaFrequency() public view returns (uint256) {\n    uint256 initialIndex = 0;\n    uint256 index;\n\n    if (count > auctionAverageLookback) {\n      initialIndex = count - auctionAverageLookback;\n    }\n\n    uint256 total = 0;\n\n    for (uint256 i = initialIndex; i < count; ++i) {\n      index = _getIndexOfObservation(i);\n      total = total + pegObservations[index];\n    }\n\n    return total * 10000 / auctionAverageLookback;\n  }\n\n  function _getIndexOfObservation(uint _index) internal view returns (uint index) {\n    return _index % auctionAverageLookback;\n  }\n\n  /*\n   * The arguments passed into these observation functions are not currently used but they are added\n   * incase future versions to this contract want to use them. In that case the stabilizernode\n   * won't have to be changed as it is already passing in this argument.\n   */\n  function addAbovePegObservation(uint256 amount)\n    public\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be a stabilizer node to call this method\")\n  {\n    uint256 index = _getIndexOfObservation(count);\n    // above peg\n    pegObservations[index] = 1;\n\n    count = count + 1;\n    emit AbovePegObservation(amount);\n  }\n\n  function addBelowPegObservation(uint256 amount)\n    public\n    onlyRole(STABILIZER_NODE_ROLE, \"Must be a stabilizer node to call this method\")\n  {\n    uint256 index = _getIndexOfObservation(count);\n    // below peg\n    pegObservations[index] = 0;\n\n    count = count + 1;\n    emit BelowPegObservation(amount);\n  }\n\n  function setNewStabilizerNode(address _node)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_node != address(0), \"Cannot set 0 address\");\n    _swapRole(_node, address(stabilizerNode), STABILIZER_NODE_ROLE);\n    stabilizerNode = IStabilizerNode(_node);\n    emit SetStabilizerNode(_node);\n  }\n\n  function setNewAuction(address _auction)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_auction != address(0), \"Cannot set 0 address\");\n    auction = IAuction(_auction);\n    emit SetAuction(_auction);\n  }\n\n  function setAuctionAverageLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have zero lookback period\");\n\n    if (_lookback > auctionAverageLookback) {\n      for (uint i = auctionAverageLookback; i < _lookback; i++) {\n        pegObservations.push(0);\n      }\n    }\n\n    auctionAverageLookback = _lookback;\n    emit SetAuctionAverageLookback(_lookback);\n  }\n}\n\n\n",
        "CodeNames": [
            "AuctionBurnReserveSkew.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "AuctionBurnReserveSkew.sol getPegDeltaFrequency function",
                "Type": "High Severity",
                "Description": "getPegDeltaFrequency function in AuctionBurnReserveSkew.sol has an incorrect logic, which can limit its functionality and can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.",
                "Repair": "Change the logic in getPegDeltaFrequency function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"./Permissions.sol\";\n\n\n/// @title Timelock\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Fairly basic timelock contract\ncontract Timelock is Initializable, Permissions {\n  using SafeMath for uint256;\n\n  // The amount of delay after which a delay can a queued can be executed.\n  uint256 public delay = 2 days;\n  // The the period within which an queued proposal can be executed.\n  uint256 public gracePeriod = 7 days;\n\n  mapping(bytes32 => bool) public queuedTransactions;\n\n  event NewDelay(uint256 indexed newDelay_);\n  event NewGracePeriod(uint256 indexed newGracePerios_);\n  event NewGovernor(address newGovernor);\n  event CancelTransaction(\n    bytes32 indexed txHash_,\n    address indexed target_,\n    uint256 value_,\n    string signature_,\n    bytes data_,\n    uint256 eta_\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash_,\n    address indexed target_,\n    uint256 value_,\n    string signature_,\n    bytes data_,\n    uint256 eta_\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash_,\n    address indexed target_,\n    uint256 value_,\n    string signature_,\n    bytes data_,\n    uint256 eta_\n  );\n\n  address public governor;\n\n  function initialize(address _admin, address _governor) external initializer {\n    _adminSetup(_admin);\n    _setupRole(GOVERNOR_ROLE, address(this));\n    _setupRole(GOVERNOR_ROLE, _governor);\n    _setRoleAdmin(GOVERNOR_ROLE, TIMELOCK_ROLE);\n\n    governor = _governor;\n  }\n\n  receive() external payable {}\n\n  /**\n   * @notice Sets the amount of time after which a proposal that has been queued can be executed.\n   */\n  function setDelay(uint256 _delay)\n    public\n    onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")\n  {\n    require(\n      _delay >= 0 && _delay < gracePeriod,\n      \"Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod\"\n    );\n    delay = _delay;\n\n    emit NewDelay(delay);\n  }\n\n  /**\n   * @notice Sets the amount of time within which a queued proposal can be executed.\n   */\n  function setGracePeriod(uint256 _gracePeriod)\n    public\n    onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")\n  {\n    require(\n      _gracePeriod > delay,\n      \"Timelock::gracePeriod: Grace period must be greater than delay\"\n    );\n    gracePeriod = _gracePeriod;\n\n    emit NewGracePeriod(gracePeriod);\n  }\n\n  /**\n   * @notice Sets the governor address that is allowed to make proposals\n   */\n  function setGovernor(address _governor)\n    public\n    onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")\n  {\n    _swapRole(_governor, governor, GOVERNOR_ROLE);\n    governor = _governor;\n    emit NewGovernor(_governor);\n  }\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  )\n    public\n    onlyRole(GOVERNOR_ROLE, \"Timelock::queueTransaction: Call must come from governor.\")\n    returns (bytes32)\n  {\n    require(\n      eta >= block.timestamp.add(delay),\n      \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(\n      abi.encode(target, value, signature, data, eta)\n    );\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  )\n    public\n    onlyRole(GOVERNOR_ROLE, \"Timelock::cancelTransaction: Call must come from governor.\")\n  {\n    bytes32 txHash = keccak256(\n      abi.encode(target, value, signature, data, eta)\n    );\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  )\n    public\n    payable\n    onlyRole(GOVERNOR_ROLE, \"Timelock::executeTransaction: Call must come from governor.\")\n    returns (bytes memory)\n  {\n    bytes32 txHash = keccak256(\n      abi.encode(target, value, signature, data, eta)\n    );\n    require(\n      queuedTransactions[txHash],\n      \"Timelock::executeTransaction: Transaction hasn't been queued.\"\n    );\n    require(\n      block.timestamp >= eta,\n      \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\"\n    );\n    require(\n      block.timestamp <= eta.add(gracePeriod),\n      \"Timelock::executeTransaction: Transaction is stale.\"\n    );\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(\n        bytes4(keccak256(bytes(signature))),\n        data\n      );\n    }\n\n    (bool success, bytes memory returnData) = target.call{value: value}(\n      callData\n    );\n\n    require(\n      success,\n      \"Timelock::executeTransaction: Transaction execution reverted.\"\n    );\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n}\n\n\n",
        "CodeNames": [
            "Timelock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Timelock.sol setGovernor and setDelay functions",
                "Type": "High Severity",
                "Description": "The current implementation of Timelock contract allows the governor to execute any transactions without any constraints, which can result in granting minter role to any address and mint unlimited amount of MALT.",
                "Repair": "Make setGovernor and setDelay only callable from the Timelock contract itself"
            }
        ]
    }
]