[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TokenManagerERC20.sol",
                "Type": "Use of transferFrom() instead of safeTransferFrom()",
                "Description": "Tokens that don\u2019t correctly implement the latest EIP20 spec will be unusable in the protocol as they revert the transaction because of the missing return value.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens."
            },
            {
                "Location": "MessageProxy.sol",
                "Type": "Transactions can be replayed when a connectedChain is removed and then reconnected",
                "Description": "Once the incomingMessageCounter resets to 0, all the past messages (transactions) can be replayed with the old signatures.",
                "Repair": "Instead of delete/reset the counter, consider leaving the counter as it is when removeConnectedChain, _addConnectedChain also should not reset the counter."
            },
            {
                "Location": "TokenManagerERC20.exitToMainERC20()",
                "Type": "Token transfer vulnerability",
                "Description": "Tokens on the schain will be frozen on TokenManagerERC20, but they will not receive tokens on Ethereum.",
                "Repair": "Prevent moving schain native tokens to Ethereum MAINNET by adding require(chainHash != MAINNET_HASH)"
            },
            {
                "Location": "ERC721OnChain.setTokenURI()",
                "Type": "NFT URI change vulnerability",
                "Description": "A user that owns an NFT can just spoof any other NFT data by changing the token URI to any of the other NFTs.",
                "Repair": "Disallow the owner of an NFT to change its token URI"
            },
            {
                "Location": "DepositBoxEth.sol, DepositBoxERC20.sol, DepositBoxERC721.sol, DepositBoxERC1155.sol, TokenManagerERC20.sol",
                "Type": "Smart contract vulnerability",
                "Description": "Various vulnerabilities in the smart contracts including rug pull, frozen funds, centralization risk, and arbitrary burning of tokens.",
                "Repair": "Add a long time lock for killing, cache whether automaticDeploy is enabled on a certain schain, remove setEthErc20Address() function, update forceBurn function for only owner can burn his tokens"
            },
            {
                "Location": "CommunityPool.sol",
                "Type": "Gas price extortion",
                "Description": "The function refundGasByUser() can be exploited by the message sender to drain nodes and SChain owners of their balances when processing incoming messages.",
                "Repair": "Use a gas price oracle rather than tx.gasprice or set a maximum gas price and have incentives for nodes submitting at a lower gas price"
            },
            {
                "Location": "DepositBoxERC20 contract",
                "Type": "Incompatibility with rebasing/deflationary/inflationary tokens",
                "Description": "The DepositBoxERC20 contract does not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time.",
                "Repair": "Add support for such tokens before accepting user-supplied tokens or check before/after balance on the vault"
            },
            {
                "Location": "MessageProxyForSchain contract",
                "Type": "Reentrancy",
                "Description": "The postIncomingMessages function calls _callReceiverContract(fromChainHash, messages[i], startingCounter + 1) which gives control to a contract that is potentially attacker controlled before updating the incomingMessageCounter.",
                "Repair": "Add a messageInProgressLocker modifier to postIncomingMessages"
            },
            {
                "Location": "MessageProxy.sol",
                "Type": "Loss of pending messages",
                "Description": "If there are any unprocessed messages to be executed or processed while removeConnectedChain is called, then they may be stuck from getting processed on the other end.",
                "Repair": "Check if there are any pending or unprocessed messages while removeConnectedChain is called and revert in that case or implement some functionality like pause just locally for the chain to be removed before the actual removeConnectedChain is called"
            }
        ]
    }
]