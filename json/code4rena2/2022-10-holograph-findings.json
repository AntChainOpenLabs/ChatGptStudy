[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 HOLOGRAPH \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                                                             \u2551\n\u2551                            / ^ \\                            \u2551\n\u2551                            ~~*~~            \u00b8               \u2551\n\u2551                         [ '<>:<>' ]         \u2502\u2591\u2591\u2591            \u2551\n\u2551               \u2554\u2557           _/\"\\_           \u2554\u2563               \u2551\n\u2551             \u250c\u2500\u256c\u256c\u2500\u2510          \"\"\"          \u250c\u2500\u256c\u256c\u2500\u2510             \u2551\n\u2551          \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510       \\_/       \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510          \u2551\n\u2551       \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510           \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510       \u2551\n\u2551    \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510     \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510    \u2551\n\u2551 \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2510 \u250c\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2500\u2510 \u2551\n\u2560\u252c\u2518 \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502\u2514\u00a4\u2518\u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502 \u2514\u252c\u2563\n\u2551\u2502  \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502   \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502  \u2502\u2551\n\u2560\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2563\n\u2560\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2563\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551    ,          \u2560\u2563     ,        ,'      *    \u2560\u2563               \u2551\n\u2551~~~~~^~~~~~~~~\u250c\u256c\u256c\u2510~~~^~~~~~~~~^^~~~~~~~~^~~\u250c\u256c\u256c\u2510~~~~~~~^~~~~~~\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor\u2019s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors\u2019 name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed \u201cas-is.\u201d You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/EIP712.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/NonReentrant.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../enum/HolographERC20Event.sol\";\nimport \"../enum/InterfaceType.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/ERC20Burnable.sol\";\nimport \"../interface/HolographERC20Interface.sol\";\nimport \"../interface/ERC20Metadata.sol\";\nimport \"../interface/ERC20Permit.sol\";\nimport \"../interface/ERC20Receiver.sol\";\nimport \"../interface/ERC20Safer.sol\";\nimport \"../interface/ERC165.sol\";\nimport \"../interface/Holographable.sol\";\nimport \"../interface/HolographedERC20.sol\";\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\nimport \"../interface/HolographRegistryInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/Ownable.sol\";\n\nimport \"../library/ECDSA.sol\";\n\n/**\n * @title Holograph Bridgeable ERC-20 Token\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC20 Tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract HolographERC20 is Admin, Owner, Initializable, NonReentrant, EIP712, HolographERC20Interface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.sourceContract')) - 1)\n   */\n  bytes32 constant _sourceContractSlot = 0x27d542086d1e831d40b749e7f5509a626c3047a36d160781c40d5acc83e5b074;\n\n  /**\n   * @dev Configuration for events to trigger for source smart contract.\n   */\n  uint256 private _eventConfig;\n\n  /**\n   * @dev Mapping of all the addresse's balances.\n   */\n  mapping(address => uint256) private _balances;\n\n  /**\n   * @dev Mapping of all authorized operators, and capped amounts.\n   */\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  /**\n   * @dev Total number of token in circulation.\n   */\n  uint256 private _totalSupply;\n\n  /**\n   * @dev Token name.\n   */\n  string private _name;\n\n  /**\n   * @dev Token ticker symbol.\n   */\n  string private _symbol;\n\n  /**\n   * @dev Token number of decimal places.\n   */\n  uint8 private _decimals;\n\n  /**\n   * @dev List of used up nonces. Used in the ERC20Permit interface functionality.\n   */\n  mapping(address => uint256) private _nonces;\n\n  /**\n   * @notice Only allow calls from bridge smart contract.\n   */\n  modifier onlyBridge() {\n    require(msg.sender == _holograph().getBridge(), \"ERC20: bridge only call\");\n    _;\n  }\n\n  /**\n   * @notice Only allow calls from source smart contract.\n   */\n  modifier onlySource() {\n    address sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    require(msg.sender == sourceContract, \"ERC20: source only call\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"ERC20: already initialized\");\n    InitializableInterface sourceContract;\n    assembly {\n      sstore(_reentrantSlot, 0x0000000000000000000000000000000000000000000000000000000000000001)\n      sstore(_ownerSlot, caller())\n      sourceContract := sload(_sourceContractSlot)\n    }\n    (\n      string memory contractName,\n      string memory contractSymbol,\n      uint8 contractDecimals,\n      uint256 eventConfig,\n      string memory domainSeperator,\n      string memory domainVersion,\n      bool skipInit,\n      bytes memory initCode\n    ) = abi.decode(initPayload, (string, string, uint8, uint256, string, string, bool, bytes));\n    _name = contractName;\n    _symbol = contractSymbol;\n    _decimals = contractDecimals;\n    _eventConfig = eventConfig;\n    if (!skipInit) {\n      require(sourceContract.init(initCode) == InitializableInterface.init.selector, \"ERC20: could not init source\");\n    }\n    _setInitialized();\n    _eip712_init(domainSeperator, domainVersion);\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  /**\n   * @notice Fallback to the source contract.\n   * @dev Any function call that is not covered here, will automatically be sent over to the source contract.\n   */\n  fallback() external payable {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      mstore(calldatasize(), caller())\n      let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev Although EIP-165 is not required for ERC20 contracts, we still decided to implement it.\n   *\n   * This makes it easier for external smart contracts to easily identify a valid ERC20 token contract.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    HolographInterfacesInterface interfaces = HolographInterfacesInterface(_interfaces());\n    ERC165 erc165Contract;\n    assembly {\n      erc165Contract := sload(_sourceContractSlot)\n    }\n    if (\n      interfaces.supportsInterface(InterfaceType.ERC20, interfaceId) || erc165Contract.supportsInterface(interfaceId) // check global interfaces // check if source supports interface\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function allowance(address account, address spender) public view returns (uint256) {\n    return _allowances[account][spender];\n  }\n\n  function balanceOf(address account) public view returns (uint256) {\n    return _balances[account];\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() public view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function nonces(address account) public view returns (uint256) {\n    return _nonces[account];\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(SourceERC20().beforeApprove(msg.sender, spender, amount));\n    }\n    _approve(msg.sender, spender, amount);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(SourceERC20().afterApprove(msg.sender, spender, amount));\n    }\n    return true;\n  }\n\n  function burn(uint256 amount) public {\n    if (_isEventRegistered(HolographERC20Event.beforeBurn)) {\n      require(SourceERC20().beforeBurn(msg.sender, amount));\n    }\n    _burn(msg.sender, amount);\n    if (_isEventRegistered(HolographERC20Event.afterBurn)) {\n      require(SourceERC20().afterBurn(msg.sender, amount));\n    }\n  }\n\n  function burnFrom(address account, uint256 amount) public returns (bool) {\n    uint256 currentAllowance = _allowances[account][msg.sender];\n    require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n    unchecked {\n      _allowances[account][msg.sender] = currentAllowance - amount;\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeBurn)) {\n      require(SourceERC20().beforeBurn(account, amount));\n    }\n    _burn(account, amount);\n    if (_isEventRegistered(HolographERC20Event.afterBurn)) {\n      require(SourceERC20().afterBurn(account, amount));\n    }\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased below zero\");\n    uint256 newAllowance;\n    unchecked {\n      newAllowance = currentAllowance - subtractedValue;\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(SourceERC20().beforeApprove(msg.sender, spender, newAllowance));\n    }\n    _approve(msg.sender, spender, newAllowance);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(SourceERC20().afterApprove(msg.sender, spender, newAllowance));\n    }\n    return true;\n  }\n\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external onlyBridge returns (bytes4) {\n    (address from, address to, uint256 amount, bytes memory data) = abi.decode(\n      payload,\n      (address, address, uint256, bytes)\n    );\n    _mint(to, amount);\n    if (_isEventRegistered(HolographERC20Event.bridgeIn)) {\n      require(SourceERC20().bridgeIn(fromChain, from, to, amount, data), \"HOLOGRAPH: bridge in failed\");\n    }\n    return Holographable.bridgeIn.selector;\n  }\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external onlyBridge returns (bytes4 selector, bytes memory data) {\n    (address from, address to, uint256 amount) = abi.decode(payload, (address, address, uint256));\n    if (sender != from) {\n      uint256 currentAllowance = _allowances[from][sender];\n      require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n      unchecked {\n        _allowances[from][sender] = currentAllowance - amount;\n      }\n    }\n    if (_isEventRegistered(HolographERC20Event.bridgeOut)) {\n      data = SourceERC20().bridgeOut(toChain, from, to, amount);\n    }\n    _burn(from, amount);\n    return (Holographable.bridgeOut.selector, abi.encode(from, to, amount, data));\n  }\n\n  /**\n   * @dev Allows the bridge to mint tokens (used for hTokens only).\n   */\n  function holographBridgeMint(address to, uint256 amount) external onlyBridge returns (bytes4) {\n    _mint(to, amount);\n    return HolographERC20Interface.holographBridgeMint.selector;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    uint256 newAllowance;\n    unchecked {\n      newAllowance = currentAllowance + addedValue;\n    }\n    unchecked {\n      require(newAllowance >= currentAllowance, \"ERC20: increased above max value\");\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(SourceERC20().beforeApprove(msg.sender, spender, newAllowance));\n    }\n    _approve(msg.sender, spender, newAllowance);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(SourceERC20().afterApprove(msg.sender, spender, newAllowance));\n    }\n    return true;\n  }\n\n  function onERC20Received(\n    address account,\n    address sender,\n    uint256 amount,\n    bytes calldata data\n  ) public returns (bytes4) {\n    require(_isContract(account), \"ERC20: operator not contract\");\n    if (_isEventRegistered(HolographERC20Event.beforeOnERC20Received)) {\n      require(SourceERC20().beforeOnERC20Received(account, sender, address(this), amount, data));\n    }\n    try ERC20(account).balanceOf(address(this)) returns (uint256 balance) {\n      require(balance >= amount, \"ERC20: balance check failed\");\n    } catch {\n      revert(\"ERC20: failed getting balance\");\n    }\n    if (_isEventRegistered(HolographERC20Event.afterOnERC20Received)) {\n      require(SourceERC20().afterOnERC20Received(account, sender, address(this), amount, data));\n    }\n    return ERC20Receiver.onERC20Received.selector;\n  }\n\n  function permit(\n    address account,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    require(block.timestamp <= deadline, \"ERC20: expired deadline\");\n    bytes32 structHash = keccak256(\n      abi.encode(\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,\n        account,\n        spender,\n        amount,\n        _useNonce(account),\n        deadline\n      )\n    );\n    bytes32 hash = _hashTypedDataV4(structHash);\n    address signer = ECDSA.recover(hash, v, r, s);\n    require(signer == account, \"ERC20: invalid signature\");\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(SourceERC20().beforeApprove(account, spender, amount));\n    }\n    _approve(account, spender, amount);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(SourceERC20().afterApprove(account, spender, amount));\n    }\n  }\n\n  function safeTransfer(address recipient, uint256 amount) public returns (bool) {\n    return safeTransfer(recipient, amount, \"\");\n  }\n\n  function safeTransfer(\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) public returns (bool) {\n    if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {\n      require(SourceERC20().beforeSafeTransfer(msg.sender, recipient, amount, data));\n    }\n    _transfer(msg.sender, recipient, amount);\n    require(_checkOnERC20Received(msg.sender, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n    if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {\n      require(SourceERC20().afterSafeTransfer(msg.sender, recipient, amount, data));\n    }\n    return true;\n  }\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount\n  ) public returns (bool) {\n    return safeTransferFrom(account, recipient, amount, \"\");\n  }\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) public returns (bool) {\n    if (account != msg.sender) {\n      if (msg.sender != _holograph().getBridge() && msg.sender != _holograph().getOperator()) {\n        uint256 currentAllowance = _allowances[account][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n        unchecked {\n          _allowances[account][msg.sender] = currentAllowance - amount;\n        }\n      }\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {\n      require(SourceERC20().beforeSafeTransfer(account, recipient, amount, data));\n    }\n    _transfer(account, recipient, amount);\n    require(_checkOnERC20Received(account, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n    if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {\n      require(SourceERC20().afterSafeTransfer(account, recipient, amount, data));\n    }\n    return true;\n  }\n\n  /**\n   * @dev Allows for source smart contract to burn tokens.\n   */\n  function sourceBurn(address from, uint256 amount) external onlySource {\n    _burn(from, amount);\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint tokens.\n   */\n  function sourceMint(address to, uint256 amount) external onlySource {\n    _mint(to, amount);\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of token amounts.\n   */\n  function sourceMintBatch(address[] calldata wallets, uint256[] calldata amounts) external onlySource {\n    for (uint256 i = 0; i < wallets.length; i++) {\n      _mint(wallets[i], amounts[i]);\n    }\n  }\n\n  /**\n   * @dev Allows for source smart contract to transfer tokens.\n   */\n  function sourceTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) external onlySource {\n    _transfer(from, to, amount);\n  }\n\n  function transfer(address recipient, uint256 amount) public returns (bool) {\n    if (_isEventRegistered(HolographERC20Event.beforeTransfer)) {\n      require(SourceERC20().beforeTransfer(msg.sender, recipient, amount));\n    }\n    _transfer(msg.sender, recipient, amount);\n    if (_isEventRegistered(HolographERC20Event.afterTransfer)) {\n      require(SourceERC20().afterTransfer(msg.sender, recipient, amount));\n    }\n    return true;\n  }\n\n  function transferFrom(\n    address account,\n    address recipient,\n    uint256 amount\n  ) public returns (bool) {\n    if (account != msg.sender) {\n      if (msg.sender != _holograph().getBridge() && msg.sender != _holograph().getOperator()) {\n        uint256 currentAllowance = _allowances[account][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n        unchecked {\n          _allowances[account][msg.sender] = currentAllowance - amount;\n        }\n      }\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeTransfer)) {\n      require(SourceERC20().beforeTransfer(account, recipient, amount));\n    }\n    _transfer(account, recipient, amount);\n    if (_isEventRegistered(HolographERC20Event.afterTransfer)) {\n      require(SourceERC20().afterTransfer(account, recipient, amount));\n    }\n    return true;\n  }\n\n  function _approve(\n    address account,\n    address spender,\n    uint256 amount\n  ) private {\n    require(account != address(0), \"ERC20: account is zero address\");\n    require(spender != address(0), \"ERC20: spender is zero address\");\n    _allowances[account][spender] = amount;\n    emit Approval(account, spender, amount);\n  }\n\n  function _burn(address account, uint256 amount) private {\n    require(account != address(0), \"ERC20: account is zero address\");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _checkOnERC20Received(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) private nonReentrant returns (bool) {\n    if (_isContract(recipient)) {\n      try ERC165(recipient).supportsInterface(ERC165.supportsInterface.selector) returns (bool erc165support) {\n        require(erc165support, \"ERC20: no ERC165 support\");\n        // we have erc165 support\n        if (ERC165(recipient).supportsInterface(0x534f5876)) {\n          // we have eip-4524 support\n          try ERC20Receiver(recipient).onERC20Received(address(this), account, amount, data) returns (bytes4 retval) {\n            return retval == ERC20Receiver.onERC20Received.selector;\n          } catch (bytes memory reason) {\n            if (reason.length == 0) {\n              revert(\"ERC20: non ERC20Receiver\");\n            } else {\n              assembly {\n                revert(add(32, reason), mload(reason))\n              }\n            }\n          }\n        } else {\n          revert(\"ERC20: eip-4524 not supported\");\n        }\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC20: no ERC165 support\");\n        } else {\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * @notice Mints tokens.\n   * @dev Mint a specific amount of tokens to a specific address.\n   * @param to Address to mint to.\n   * @param amount Amount of tokens to mint.\n   */\n  function _mint(address to, uint256 amount) private {\n    require(to != address(0), \"ERC20: minting to burn address\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _transfer(\n    address account,\n    address recipient,\n    uint256 amount\n  ) private {\n    require(account != address(0), \"ERC20: account is zero address\");\n    require(recipient != address(0), \"ERC20: recipient is zero address\");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _balances[recipient] += amount;\n    emit Transfer(account, recipient, amount);\n  }\n\n  /**\n   * @dev \"Consume a nonce\": return the current value and increment.\n   *\n   * _Available since v4.1._\n   */\n  function _useNonce(address account) private returns (uint256 current) {\n    current = _nonces[account];\n    _nonces[account]++;\n  }\n\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Get the source smart contract as bridgeable interface.\n   */\n  function SourceERC20() private view returns (HolographedERC20 sourceContract) {\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n  }\n\n  /**\n   * @dev Get the interfaces contract address.\n   */\n  function _interfaces() private view returns (address) {\n    return _holograph().getInterfaces();\n  }\n\n  function owner() public view override returns (address) {\n    Ownable ownableContract;\n    assembly {\n      ownableContract := sload(_sourceContractSlot)\n    }\n    return ownableContract.owner();\n  }\n\n  function _holograph() private view returns (HolographInterface holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function _isEventRegistered(HolographERC20Event _eventName) private view returns (bool) {\n    return ((_eventConfig >> uint256(_eventName)) & uint256(1) == 1 ? true : false);\n  }\n}\n\n\n",
        "CodeNames": [
            "HolographERC20.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "HolographERC20.sol#L539",
                "Type": "Composability",
                "Description": "HolographERC20 breaks composability by forcing usage of draft proposal EIP-4524",
                "Repair": "Remove the EIP-4524 requirements altogether"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "contracts/HolographOperator.sol#crossChainMessage",
                "Type": "Biased distribution",
                "Description": "An attacker can manipulate each pod and gain an advantage over the remainder Operators.",
                "Repair": "Use two random numbers for pod and Operator selection. Ideally, an independent source for randomness should be used, but following the assumption that the one used in L499 is safe enough, using the most significant bits (e.g. random  128) should guarantee an unbiased distribution."
            },
            {
                "Location": "ERC721/ERC20 implementations using isOwner/onlyOwner modifiers",
                "Type": "Access Control",
                "Description": "The isOwner/onlyOwner checks can be bypassed by an attacker in ERC721/ERC20 implementations due to confusion between calls coming from HolographERC721's fallback function and calls from actually implemented functions. This can result in owner-specific functionality being initiated on NFT/ERC20 implementation contracts, potentially resulting in real damage to the protocol.",
                "Repair": "Refactor the code to represent msg.sender information in a bug-free way"
            },
            {
                "Location": "_getBaseBondAmount",
                "Type": "Incorrect slashing calculation",
                "Description": "Documentation states that only a portion should be slashed and the number of slashes should be noted down.",
                "Repair": "Implement the correct percentage of slashing and include a mapping to note down the number of slashes that an operator has"
            },
            {
                "Location": "PA1D#bidSharesForToken",
                "Type": "Incorrect value returned",
                "Description": "bidShares returned are incorrect leading to incorrect royalties.",
                "Repair": "Convert from basis points to percentage by dividing by 10 ** 2 (100) then scale to 18 decimals. The final result it to multiple the basis point by 10 ** (18 2) or 10 ** 16"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 HOLOGRAPH \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                                                             \u2551\n\u2551                            / ^ \\                            \u2551\n\u2551                            ~~*~~            \u00b8               \u2551\n\u2551                         [ '<>:<>' ]         \u2502\u2591\u2591\u2591            \u2551\n\u2551               \u2554\u2557           _/\"\\_           \u2554\u2563               \u2551\n\u2551             \u250c\u2500\u256c\u256c\u2500\u2510          \"\"\"          \u250c\u2500\u256c\u256c\u2500\u2510             \u2551\n\u2551          \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510       \\_/       \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510          \u2551\n\u2551       \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510           \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510       \u2551\n\u2551    \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510     \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510    \u2551\n\u2551 \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2510 \u250c\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2500\u2510 \u2551\n\u2560\u252c\u2518 \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502\u2514\u00a4\u2518\u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502 \u2514\u252c\u2563\n\u2551\u2502  \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502   \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502  \u2502\u2551\n\u2560\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2563\n\u2560\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2563\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551    ,          \u2560\u2563     ,        ,'      *    \u2560\u2563               \u2551\n\u2551~~~~~^~~~~~~~~\u250c\u256c\u256c\u2510~~~^~~~~~~~~^^~~~~~~~~^~~\u250c\u256c\u256c\u2510~~~~~~~^~~~~~~\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor\u2019s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors\u2019 name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed \u201cas-is.\u201d You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/CrossChainMessageInterface.sol\";\nimport \"./interface/HolographBridgeInterface.sol\";\nimport \"./interface/HolographERC20Interface.sol\";\nimport \"./interface/HolographInterface.sol\";\nimport \"./interface/HolographOperatorInterface.sol\";\nimport \"./interface/HolographRegistryInterface.sol\";\nimport \"./interface/InitializableInterface.sol\";\nimport \"./interface/HolographInterfacesInterface.sol\";\nimport \"./interface/Ownable.sol\";\n\nimport \"./struct/OperatorJob.sol\";\n\n/**\n * @title Holograph Operator\n * @author https://github.com/holographxyz\n * @notice Participate in the Holograph Protocol by becoming an Operator\n * @dev This contract allows operators to bond utility tokens and help execute operator jobs\n */\ncontract HolographOperator is Admin, Initializable, HolographOperatorInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.bridge')) - 1)\n   */\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.interfaces')) - 1)\n   */\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.jobNonce')) - 1)\n   */\n  bytes32 constant _jobNonceSlot = 0x1cda64803f3b43503042e00863791e8d996666552d5855a78d53ee1dd4b3286d;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.messagingModule')) - 1)\n   */\n  bytes32 constant _messagingModuleSlot = 0x54176250282e65985d205704ffce44a59efe61f7afd99e29fda50f55b48c061a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.utilityToken')) - 1)\n   */\n  bytes32 constant _utilityTokenSlot = 0xbf76518d46db472b71aa7677a0908b8016f3dee568415ffa24055f9a670f9c37;\n\n  /**\n   * @dev Internal number (in seconds), used for defining a window for operator to execute the job\n   */\n  uint256 private _blockTime;\n\n  /**\n   * @dev Minimum amount of tokens needed for bonding\n   */\n  uint256 private _baseBondAmount;\n\n  /**\n   * @dev The multiplier used for calculating bonding amount for pods\n   */\n  uint256 private _podMultiplier;\n\n  /**\n   * @dev The threshold used for limiting number of operators in a pod\n   */\n  uint256 private _operatorThreshold;\n\n  /**\n   * @dev The threshold step used for increasing bond amount once threshold is reached\n   */\n  uint256 private _operatorThresholdStep;\n\n  /**\n   * @dev The threshold divisor used for increasing bond amount once threshold is reached\n   */\n  uint256 private _operatorThresholdDivisor;\n\n  /**\n   * @dev Internal counter of all cross-chain messages received\n   */\n  uint256 private _inboundMessageCounter;\n\n  /**\n   * @dev Internal mapping of operator job details for a specific job hash\n   */\n  mapping(bytes32 => uint256) private _operatorJobs;\n\n  /**\n   * @dev Internal mapping of operator job details for a specific job hash\n   */\n  mapping(bytes32 => bool) private _failedJobs;\n\n  /**\n   * @dev Internal mapping of operator addresses, used for temp storage when defining an operator job\n   */\n  mapping(uint256 => address) private _operatorTempStorage;\n\n  /**\n   * @dev Internal index used for storing/referencing operator temp storage\n   */\n  uint32 private _operatorTempStorageCounter;\n\n  /**\n   * @dev Multi-dimensional array of available operators\n   */\n  address[][] private _operatorPods;\n\n  /**\n   * @dev Internal mapping of bonded operators, to prevent double bonding\n   */\n  mapping(address => uint256) private _bondedOperators;\n\n  /**\n   * @dev Internal mapping of bonded operators, to prevent double bonding\n   */\n  mapping(address => uint256) private _operatorPodIndex;\n\n  /**\n   * @dev Internal mapping of bonded operator amounts\n   */\n  mapping(address => uint256) private _bondedAmounts;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address bridge, address holograph, address interfaces, address registry, address utilityToken) = abi.decode(\n      initPayload,\n      (address, address, address, address, address)\n    );\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_bridgeSlot, bridge)\n      sstore(_holographSlot, holograph)\n      sstore(_interfacesSlot, interfaces)\n      sstore(_registrySlot, registry)\n      sstore(_utilityTokenSlot, utilityToken)\n    }\n    _blockTime = 60; // 60 seconds allowed for execution\n    unchecked {\n      _baseBondAmount = 100 * (10**18); // one single token unit * 100\n    }\n    // how much to increase bond amount per pod\n    _podMultiplier = 2; // 1, 4, 16, 64\n    // starting pod max amount\n    _operatorThreshold = 1000;\n    // how often to increase price per each operator\n    _operatorThresholdStep = 10;\n    // we want to multiply by decimals, but instead will have to divide\n    _operatorThresholdDivisor = 100; // == * 0.01\n    // set first operator for each pod as zero address\n    _operatorPods = [[address(0)]];\n    // mark zero address as bonded operator, to prevent abuse\n    _bondedOperators[address(0)] = 1;\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev temp function, used for quicker updates/resets during development\n   *      NOT PART OF FINAL CODE !!!\n   */\n  function resetOperator(\n    uint256 blockTime,\n    uint256 baseBondAmount,\n    uint256 podMultiplier,\n    uint256 operatorThreshold,\n    uint256 operatorThresholdStep,\n    uint256 operatorThresholdDivisor\n  ) external onlyAdmin {\n    _blockTime = blockTime;\n    _baseBondAmount = baseBondAmount;\n    _podMultiplier = podMultiplier;\n    _operatorThreshold = operatorThreshold;\n    _operatorThresholdStep = operatorThresholdStep;\n    _operatorThresholdDivisor = operatorThresholdDivisor;\n    _operatorPods = [[address(0)]];\n    _bondedOperators[address(0)] = 1;\n  }\n\n  /**\n   * @notice Execute an available operator job\n   * @dev When making this call, if operating criteria is not met, the call will revert\n   * @param bridgeInRequestPayload the entire cross chain message payload\n   */\n  function executeJob(bytes calldata bridgeInRequestPayload) external payable {\n    /**\n     * @dev derive the payload hash for use in mappings\n     */\n    bytes32 hash = keccak256(bridgeInRequestPayload);\n    /**\n     * @dev check that job exists\n     */\n    require(_operatorJobs[hash] > 0, \"HOLOGRAPH: invalid job\");\n    uint256 gasLimit = 0;\n    uint256 gasPrice = 0;\n    assembly {\n      /**\n       * @dev extract gasLimit\n       */\n      gasLimit := calldataload(sub(add(bridgeInRequestPayload.offset, bridgeInRequestPayload.length), 0x40))\n      /**\n       * @dev extract gasPrice\n       */\n      gasPrice := calldataload(sub(add(bridgeInRequestPayload.offset, bridgeInRequestPayload.length), 0x20))\n    }\n    /**\n     * @dev unpack bitwise packed operator job details\n     */\n    OperatorJob memory job = getJobDetails(hash);\n    /**\n     * @dev to prevent replay attacks, remove job from mapping\n     */\n    delete _operatorJobs[hash];\n    /**\n     * @dev check that a specific operator was selected for the job\n     */\n    if (job.operator != address(0)) {\n      /**\n       * @dev switch pod to index based value\n       */\n      uint256 pod = job.pod - 1;\n      /**\n       * @dev check if sender is not the selected primary operator\n       */\n      if (job.operator != msg.sender) {\n        /**\n         * @dev sender is not selected operator, need to check if allowed to do job\n         */\n        uint256 elapsedTime = block.timestamp - uint256(job.startTimestamp);\n        uint256 timeDifference = elapsedTime / job.blockTimes;\n        /**\n         * @dev validate that initial selected operator time slot is still active\n         */\n        require(timeDifference > 0, \"HOLOGRAPH: operator has time\");\n        /**\n         * @dev check that the selected missed the time slot due to a gas spike\n         */\n        require(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\");\n        /**\n         * @dev check if time is within fallback operator slots\n         */\n        if (timeDifference < 6) {\n          uint256 podIndex = uint256(job.fallbackOperators[timeDifference - 1]);\n          /**\n           * @dev do a quick sanity check to make sure operator did not leave from index or is a zero address\n           */\n          if (podIndex > 0 && podIndex < _operatorPods[pod].length) {\n            address fallbackOperator = _operatorPods[pod][podIndex];\n            /**\n             * @dev ensure that sender is currently valid backup operator\n             */\n            require(fallbackOperator == msg.sender, \"HOLOGRAPH: invalid fallback\");\n          }\n        }\n        /**\n         * @dev time to reward the current operator\n         */\n        uint256 amount = _getBaseBondAmount(pod);\n        /**\n         * @dev select operator that failed to do the job, is slashed the pod base fee\n         */\n        _bondedAmounts[job.operator] -= amount;\n        /**\n         * @dev the slashed amount is sent to current operator\n         */\n        _bondedAmounts[msg.sender] += amount;\n        /**\n         * @dev check if slashed operator has enough tokens bonded to stay\n         */\n        if (_bondedAmounts[job.operator] >= amount) {\n          /**\n           * @dev enough bond amount leftover, put operator back in\n           */\n          _operatorPods[pod].push(job.operator);\n          _operatorPodIndex[job.operator] = _operatorPods[pod].length - 1;\n          _bondedOperators[job.operator] = job.pod;\n        } else {\n          /**\n           * @dev slashed operator does not have enough tokens bonded, return remaining tokens only\n           */\n          uint256 leftovers = _bondedAmounts[job.operator];\n          if (leftovers > 0) {\n            _bondedAmounts[job.operator] = 0;\n            _utilityToken().transfer(job.operator, leftovers);\n          }\n        }\n      } else {\n        /**\n         * @dev the selected operator is executing the job\n         */\n        _operatorPods[pod].push(msg.sender);\n        _operatorPodIndex[job.operator] = _operatorPods[pod].length - 1;\n        _bondedOperators[msg.sender] = job.pod;\n      }\n    }\n    /**\n     * @dev ensure that there is enough has left for the job\n     */\n    require(gasleft() > gasLimit, \"HOLOGRAPH: not enough gas left\");\n    /**\n     * @dev execute the job\n     */\n    try\n      HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(\n        msg.sender,\n        bridgeInRequestPayload\n      )\n    {\n      /// @dev do nothing\n    } catch {\n      _failedJobs[hash] = true;\n      emit FailedOperatorJob(hash);\n    }\n    /**\n     * @dev every executed job (even if failed) increments total message counter by one\n     */\n    ++_inboundMessageCounter;\n    /**\n     * @dev reward operator (with HLG) for executing the job\n     * @dev this is out of scope and is purposefully omitted from code\n     */\n    ////  _bondedOperators[msg.sender] += reward;\n  }\n\n  /*\n   * @dev Purposefully made to be external so that Operator can call it during executeJob function\n   *      Check the executeJob function to understand it's implementation\n   */\n  function nonRevertingBridgeCall(address msgSender, bytes calldata payload) external payable {\n    require(msg.sender == address(this), \"HOLOGRAPH: operator only call\");\n    assembly {\n      /**\n       * @dev remove gas price from end\n       */\n      calldatacopy(0, payload.offset, sub(payload.length, 0x20))\n      /**\n       * @dev hToken recipient is injected right before making the call\n       */\n      mstore(0x84, msgSender)\n      /**\n       * @dev make non-reverting call\n       */\n      let result := call(\n        /// @dev gas limit is retrieved from last 32 bytes of payload in-memory value\n        mload(sub(payload.length, 0x40)),\n        /// @dev destination is bridge contract\n        sload(_bridgeSlot),\n        /// @dev any value is passed along\n        callvalue(),\n        /// @dev data is retrieved from 0 index memory position\n        0,\n        /// @dev everything except for last 32 bytes (gas limit) is sent\n        sub(payload.length, 0x40),\n        0,\n        0\n      )\n      if eq(result, 0) {\n        revert(0, 0)\n      }\n      return(0, 0)\n    }\n  }\n\n  /**\n   * @notice Receive a cross-chain message\n   * @dev This function is restricted for use by Holograph Messaging Module only\n   */\n  function crossChainMessage(bytes calldata bridgeInRequestPayload) external payable {\n    require(msg.sender == address(_messagingModule()), \"HOLOGRAPH: messaging only call\");\n    /**\n     * @dev would be a good idea to check payload gas price here and if it is significantly lower than current amount\n     *      to set zero address as operator to not lock-up an operator unnecessarily\n     */\n    unchecked {\n      bytes32 jobHash = keccak256(bridgeInRequestPayload);\n      /**\n       * @dev load and increment operator temp storage in one call\n       */\n      ++_operatorTempStorageCounter;\n      /**\n       * @dev use job hash, job nonce, block number, and block timestamp for generating a random number\n       */\n      uint256 random = uint256(keccak256(abi.encodePacked(jobHash, _jobNonce(), block.number, block.timestamp)));\n      /**\n       * @dev divide by total number of pods, use modulus/remainder\n       */\n      uint256 pod = random % _operatorPods.length;\n      /**\n       * @dev identify the total number of available operators in pod\n       */\n      uint256 podSize = _operatorPods[pod].length;\n      /**\n       * @dev select a primary operator\n       */\n      uint256 operatorIndex = random % podSize;\n      /**\n       * @dev If operator index is 0, then it's open season! Anyone can execute this job. First come first serve\n       *      pop operator to ensure that they cannot be selected for any other job until this one completes\n       *      decrease pod size to accomodate popped operator\n       */\n      _operatorTempStorage[_operatorTempStorageCounter] = _operatorPods[pod][operatorIndex];\n      _popOperator(pod, operatorIndex);\n      if (podSize > 1) {\n        podSize--;\n      }\n      _operatorJobs[jobHash] = uint256(\n        ((pod + 1) << 248) |\n          (uint256(_operatorTempStorageCounter) << 216) |\n          (block.number << 176) |\n          (_randomBlockHash(random, podSize, 1) << 160) |\n          (_randomBlockHash(random, podSize, 2) << 144) |\n          (_randomBlockHash(random, podSize, 3) << 128) |\n          (_randomBlockHash(random, podSize, 4) << 112) |\n          (_randomBlockHash(random, podSize, 5) << 96) |\n          (block.timestamp << 16) |\n          0\n      ); // 80 next available bit position && so far 176 bits used with only 128 left\n      /**\n       * @dev emit event to signal to operators that a job has become available\n       */\n      emit AvailableOperatorJob(jobHash, bridgeInRequestPayload);\n    }\n  }\n\n  /**\n   * @notice Calculate the amount of gas needed to execute a bridgeInRequest\n   * @dev Use this function to estimate the amount of gas that will be used by the bridgeInRequest function\n   *      Set a specific gas limit when making this call, subtract return value, to get total gas used\n   *      Only use this with a static call\n   * @param bridgeInRequestPayload abi encoded bytes making up the bridgeInRequest payload\n   * @return the gas amount remaining after the static call is returned\n   */\n  function jobEstimator(bytes calldata bridgeInRequestPayload) external payable returns (uint256) {\n    assembly {\n      calldatacopy(0, bridgeInRequestPayload.offset, sub(bridgeInRequestPayload.length, 0x40))\n      /**\n       * @dev bridgeInRequest doNotRevert is purposefully set to false so a rever would happen\n       */\n      mstore8(0xE3, 0x00)\n      let result := call(gas(), sload(_bridgeSlot), callvalue(), 0, sub(bridgeInRequestPayload.length, 0x40), 0, 0)\n      /**\n       * @dev if for some reason the call does not revert, it is force reverted\n       */\n      if eq(result, 1) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n      /**\n       * @dev remaining gas is set as the return value\n       */\n      mstore(0x00, gas())\n      return(0x00, 0x20)\n    }\n  }\n\n  /**\n   * @notice Send cross chain bridge request message\n   * @dev This function is restricted to only be callable by Holograph Bridge\n   * @param gasLimit maximum amount of gas to spend for executing the beam on destination chain\n   * @param gasPrice maximum amount of gas price (in destination chain native gas token) to pay on destination chain\n   * @param toChain Holograph Chain ID where the beam is being sent to\n   * @param nonce incremented number used to ensure job hashes are unique\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param bridgeOutPayload bytes made up of the bridgeOutRequest payload\n   */\n  function send(\n    uint256 gasLimit,\n    uint256 gasPrice,\n    uint32 toChain,\n    address msgSender,\n    uint256 nonce,\n    address holographableContract,\n    bytes calldata bridgeOutPayload\n  ) external payable {\n    require(msg.sender == _bridge(), \"HOLOGRAPH: bridge only call\");\n    CrossChainMessageInterface messagingModule = _messagingModule();\n    uint256 hlgFee = messagingModule.getHlgFee(toChain, gasLimit, gasPrice);\n    address hToken = _registry().getHToken(_holograph().getHolographChainId());\n    require(hlgFee < msg.value, \"HOLOGRAPH: not enough value\");\n    payable(hToken).transfer(hlgFee);\n    bytes memory encodedData = abi.encodeWithSelector(\n      HolographBridgeInterface.bridgeInRequest.selector,\n      /**\n       * @dev job nonce is an incremented value that is assigned to each bridge request to guarantee unique hashes\n       */\n      nonce,\n      /**\n       * @dev including the current holograph chain id (origin chain)\n       */\n      _holograph().getHolographChainId(),\n      /**\n       * @dev holographable contract have the same address across all chains, so our destination address will be the same\n       */\n      holographableContract,\n      /**\n       * @dev get the current chain's hToken for native gas token\n       */\n      hToken,\n      /**\n       * @dev recipient will be defined when operator picks up the job\n       */\n      address(0),\n      /**\n       * @dev value is set to zero for now\n       */\n      hlgFee,\n      /**\n       * @dev specify that function call should not revert\n       */\n      true,\n      /**\n       * @dev attach actual holographableContract function call\n       */\n      bridgeOutPayload\n    );\n    /**\n     * @dev add gas variables to the back for later extraction\n     */\n    encodedData = abi.encodePacked(encodedData, gasLimit, gasPrice);\n    /**\n     * @dev Send the data to the current Holograph Messaging Module\n     *      This will be changed to dynamically select which messaging module to use based on destination network\n     */\n    messagingModule.send{value: msg.value - hlgFee}(\n      gasLimit,\n      gasPrice,\n      toChain,\n      msgSender,\n      msg.value - hlgFee,\n      encodedData\n    );\n    /**\n     * @dev for easy indexing, an event is emitted with the payload hash for status tracking\n     */\n    emit CrossChainMessageSent(keccak256(encodedData));\n  }\n\n  /**\n   * @notice Get the fees associated with sending specific payload\n   * @dev Will provide exact costs on protocol and message side, combine the two to get total\n   * @dev @param toChain holograph chain id of destination chain for payload\n   * @dev @param gasLimit amount of gas to provide for executing payload on destination chain\n   * @dev @param gasPrice maximum amount to pay for gas price, can be set to 0 and will be chose automatically\n   * @dev @param crossChainPayload the entire packet being sent cross-chain\n   * @return hlgFee the amount (in wei) of native gas token that will cost for finalizing job on destiantion chain\n   * @return msgFee the amount (in wei) of native gas token that will cost for sending message to destiantion chain\n   */\n  function getMessageFee(\n    uint32,\n    uint256,\n    uint256,\n    bytes calldata\n  ) external view returns (uint256, uint256) {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := staticcall(gas(), sload(_messagingModuleSlot), 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @notice Get the details for an available operator job\n   * @dev The job hash is a keccak256 hash of the entire job payload\n   * @param jobHash keccak256 hash of the job\n   * @return an OperatorJob struct with details about a specific job\n   */\n  function getJobDetails(bytes32 jobHash) public view returns (OperatorJob memory) {\n    uint256 packed = _operatorJobs[jobHash];\n    /**\n     * @dev The job is bitwise packed into a single 32 byte slot, this unpacks it before returning the struct\n     */\n    return\n      OperatorJob(\n        uint8(packed >> 248),\n        uint16(_blockTime),\n        _operatorTempStorage[uint32(packed >> 216)],\n        uint40(packed >> 176),\n        // TODO: move the bit-shifting around to have it be sequential\n        uint64(packed >> 16),\n        [\n          uint16(packed >> 160),\n          uint16(packed >> 144),\n          uint16(packed >> 128),\n          uint16(packed >> 112),\n          uint16(packed >> 96)\n        ]\n      );\n  }\n\n  /**\n   * @notice Get number of pods available\n   * @dev This returns number of pods that have been opened via bonding\n   */\n  function getTotalPods() external view returns (uint256 totalPods) {\n    return _operatorPods.length;\n  }\n\n  /**\n   * @notice Get total number of operators in a pod\n   * @dev Use in conjunction with paginated getPodOperators function\n   * @param pod the pod to query\n   * @return total operators in a pod\n   */\n  function getPodOperatorsLength(uint256 pod) external view returns (uint256) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    return _operatorPods[pod - 1].length;\n  }\n\n  /**\n   * @notice Get list of operators in a pod\n   * @dev Use paginated getPodOperators function instead if list gets too long\n   * @param pod the pod to query\n   * @return operators array list of operators in a pod\n   */\n  function getPodOperators(uint256 pod) external view returns (address[] memory operators) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    operators = _operatorPods[pod - 1];\n  }\n\n  /**\n   * @notice Get paginated list of operators in a pod\n   * @dev Use in conjunction with getPodOperatorsLength to know the total length of results\n   * @param pod the pod to query\n   * @param index the array index to start from\n   * @param length the length of result set to be (will be shorter if reached end of array)\n   * @return operators a paginated array of operators\n   */\n  function getPodOperators(\n    uint256 pod,\n    uint256 index,\n    uint256 length\n  ) external view returns (address[] memory operators) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    /**\n     * @dev if pod 0 is selected, this will create a revert\n     */\n    pod--;\n    /**\n     * @dev get total length of pod operators\n     */\n    uint256 supply = _operatorPods[pod].length;\n    /**\n     * @dev check if length is out of bounds for this result set\n     */\n    if (index + length > supply) {\n      /**\n       * @dev adjust length to return remainder of the results\n       */\n      length = supply - index;\n    }\n    /**\n     * @dev create in-memory array\n     */\n    operators = new address[](length);\n    /**\n     * @dev add operators to result set\n     */\n    for (uint256 i = 0; i < length; i++) {\n      operators[i] = _operatorPods[pod][index + i];\n    }\n  }\n\n  /**\n   * @notice Check the base and current price for bonding to a particular pod\n   * @dev Useful for understanding what is required for bonding to a pod\n   * @param pod the pod to get bonding amounts for\n   * @return base the base bond amount required for a pod\n   * @return current the current bond amount required for a pod\n   */\n  function getPodBondAmounts(uint256 pod) external view returns (uint256 base, uint256 current) {\n    base = _getBaseBondAmount(pod - 1);\n    current = _getCurrentBondAmount(pod - 1);\n  }\n\n  /**\n   * @notice Get an operator's currently bonded amount\n   * @dev Useful for checking how much an operator has bonded\n   * @param operator address of operator to check\n   * @return amount total number of utility token bonded\n   */\n  function getBondedAmount(address operator) external view returns (uint256 amount) {\n    return _bondedAmounts[operator];\n  }\n\n  /**\n   * @notice Get an operator's currently bonded pod\n   * @dev Useful for checking if an operator is currently bonded\n   * @param operator address of operator to check\n   * @return pod number that operator is bonded on, returns zero if not bonded or selected for job\n   */\n  function getBondedPod(address operator) external view returns (uint256 pod) {\n    return _bondedOperators[operator];\n  }\n\n  /**\n   * @notice Topup a bonded operator with more utility tokens\n   * @dev Useful function if an operator got slashed and wants to add a safety buffer to not get unbonded\n   *      This function will not work if operator has currently been selected for a job\n   * @param operator address of operator to topup\n   * @param amount utility token amount to add\n   */\n  function topupUtilityToken(address operator, uint256 amount) external {\n    /**\n     * @dev check that an operator is currently bonded\n     */\n    require(_bondedOperators[operator] != 0, \"HOLOGRAPH: operator not bonded\");\n    unchecked {\n      /**\n       * @dev add the additional amount to operator\n       */\n      _bondedAmounts[operator] += amount;\n    }\n    /**\n     * @dev transfer tokens last, to prevent reentrancy attacks\n     */\n    require(_utilityToken().transferFrom(msg.sender, address(this), amount), \"HOLOGRAPH: token transfer failed\");\n  }\n\n  /**\n   * @notice Bond utility tokens and become an operator\n   * @dev An operator can only bond to one pod at a time, per network\n   * @param operator address of operator to bond (can be an ownable smart contract)\n   * @param amount utility token amount to bond (can be greater than minimum)\n   * @param pod number of pod to bond to (can be for one that does not exist yet)\n   */\n  function bondUtilityToken(\n    address operator,\n    uint256 amount,\n    uint256 pod\n  ) external {\n    /**\n     * @dev an operator can only bond to one pod at any give time per network\n     */\n    require(_bondedOperators[operator] == 0 && _bondedAmounts[operator] == 0, \"HOLOGRAPH: operator is bonded\");\n    unchecked {\n      /**\n       * @dev get the current bonding minimum for selected pod\n       */\n      uint256 current = _getCurrentBondAmount(pod - 1);\n      require(current <= amount, \"HOLOGRAPH: bond amount too small\");\n      /**\n       * @dev check if selected pod is greater than currently existing pods\n       */\n      if (_operatorPods.length < pod) {\n        /**\n         * @dev activate pod(s) up until the selected pod\n         */\n        for (uint256 i = _operatorPods.length; i <= pod; i++) {\n          /**\n           * @dev add zero address into pod to mitigate empty pod issues\n           */\n          _operatorPods.push([address(0)]);\n        }\n      }\n      /**\n       * @dev prevent bonding to a pod with more than uint16 max value\n       */\n      require(_operatorPods[pod - 1].length < type(uint16).max, \"HOLOGRAPH: too many operators\");\n      _operatorPods[pod - 1].push(operator);\n      _operatorPodIndex[operator] = _operatorPods[pod - 1].length - 1;\n      _bondedOperators[operator] = pod;\n      _bondedAmounts[operator] = amount;\n      /**\n       * @dev transfer tokens last, to prevent reentrancy attacks\n       */\n      require(_utilityToken().transferFrom(msg.sender, address(this), amount), \"HOLOGRAPH: token transfer failed\");\n    }\n  }\n\n  /**\n   * @notice Unbond HLG utility tokens and stop being an operator\n   * @dev A bonded operator selected for a job cannot unbond until they complete the job, or are slashed\n   * @param operator address of operator to unbond\n   * @param recipient address where to send the bonded tokens\n   */\n  function unbondUtilityToken(address operator, address recipient) external {\n    /**\n     * @dev validate that operator is currently bonded\n     */\n    require(_bondedOperators[operator] != 0, \"HOLOGRAPH: operator not bonded\");\n    /**\n     * @dev check if sender is not actual operator\n     */\n    if (msg.sender != operator) {\n      /**\n       * @dev check if operator is a smart contract\n       */\n      require(_isContract(operator), \"HOLOGRAPH: operator not contract\");\n      /**\n       * @dev check if smart contract is owned by sender\n       */\n      require(Ownable(operator).isOwner(msg.sender), \"HOLOGRAPH: sender not owner\");\n    }\n    /**\n     * @dev get current bonded amount by operator\n     */\n    uint256 amount = _bondedAmounts[operator];\n    /**\n     * @dev unset operator bond amount before making a transfer\n     */\n    _bondedAmounts[operator] = 0;\n    /**\n     * @dev remove all operator references\n     */\n    _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]);\n    /**\n     * @dev transfer tokens to recipient\n     */\n    require(_utilityToken().transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\");\n  }\n\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external onlyAdmin {\n    assembly {\n      sstore(_interfacesSlot, interfaces)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Messaging Module\n   * @dev All cross-chain message requests will get forwarded to this adress\n   */\n  function getMessagingModule() external view returns (address messagingModule) {\n    assembly {\n      messagingModule := sload(_messagingModuleSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Messaging Module address\n   * @param messagingModule address of the LayerZero Endpoint to use\n   */\n  function setMessagingModule(address messagingModule) external onlyAdmin {\n    assembly {\n      sstore(_messagingModuleSlot, messagingModule)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Utility Token address\n   * @dev This is the official utility token of the Holograph Protocol\n   */\n  function getUtilityToken() external view returns (address utilityToken) {\n    assembly {\n      utilityToken := sload(_utilityTokenSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Utility Token address\n   * @param utilityToken address of the Holograph Utility Token smart contract to use\n   */\n  function setUtilityToken(address utilityToken) external onlyAdmin {\n    assembly {\n      sstore(_utilityTokenSlot, utilityToken)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Bridge Interface\n   */\n  function _bridge() private view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interface\n   */\n  function _holograph() private view returns (HolographInterface holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interfaces Interface\n   */\n  function _interfaces() private view returns (HolographInterfacesInterface interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Messaging Module Interface\n   */\n  function _messagingModule() private view returns (CrossChainMessageInterface messagingModule) {\n    assembly {\n      messagingModule := sload(_messagingModuleSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Registry Interface\n   */\n  function _registry() private view returns (HolographRegistryInterface registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Utility Token Interface\n   */\n  function _utilityToken() private view returns (HolographERC20Interface utilityToken) {\n    assembly {\n      utilityToken := sload(_utilityTokenSlot)\n    }\n  }\n\n  /**\n   * @dev Internal nonce, that increments on each call, used for randomness\n   */\n  function _jobNonce() private returns (uint256 jobNonce) {\n    assembly {\n      jobNonce := add(sload(_jobNonceSlot), 0x0000000000000000000000000000000000000000000000000000000000000001)\n      sstore(_jobNonceSlot, jobNonce)\n    }\n  }\n\n  /**\n   * @dev Internal function used to remove an operator from a particular pod\n   */\n  function _popOperator(uint256 pod, uint256 operatorIndex) private {\n    /**\n     * @dev only pop the operator if it's not a zero address\n     */\n    if (operatorIndex > 0) {\n      unchecked {\n        address operator = _operatorPods[pod][operatorIndex];\n        /**\n         * @dev mark operator as no longer bonded\n         */\n        _bondedOperators[operator] = 0;\n        /**\n         * @dev remove pod reference for operator\n         */\n        _operatorPodIndex[operator] = 0;\n        uint256 lastIndex = _operatorPods[pod].length - 1;\n        if (lastIndex != operatorIndex) {\n          /**\n           * @dev if operator is not last index, move last index to operator's current index\n           */\n          _operatorPods[pod][operatorIndex] = _operatorPods[pod][lastIndex];\n          _operatorPodIndex[_operatorPods[pod][operatorIndex]] = operatorIndex;\n        }\n        /**\n         * @dev delete last index\n         */\n        delete _operatorPods[pod][lastIndex];\n        /**\n         * @dev shorten array length\n         */\n        _operatorPods[pod].pop();\n      }\n    }\n  }\n\n  /**\n   * @dev Internal function used for calculating the base bonding amount for a pod\n   */\n  function _getBaseBondAmount(uint256 pod) private view returns (uint256) {\n    return (_podMultiplier**pod) * _baseBondAmount;\n  }\n\n  /**\n   * @dev Internal function used for calculating the current bonding amount for a pod\n   */\n  function _getCurrentBondAmount(uint256 pod) private view returns (uint256) {\n    uint256 current = (_podMultiplier**pod) * _baseBondAmount;\n    if (pod >= _operatorPods.length) {\n      return current;\n    }\n    uint256 threshold = _operatorThreshold / (2**pod);\n    uint256 position = _operatorPods[pod].length;\n    if (position > threshold) {\n      position -= threshold;\n      //       current += (current / _operatorThresholdDivisor) * position;\n      current += (current / _operatorThresholdDivisor) * (position / _operatorThresholdStep);\n    }\n    return current;\n  }\n\n  /**\n   * @dev Internal function used for generating a random pod operator selection by using previously mined blocks\n   */\n  function _randomBlockHash(\n    uint256 random,\n    uint256 podSize,\n    uint256 n\n  ) private view returns (uint256) {\n    unchecked {\n      return (random + uint256(blockhash(block.number - n))) % podSize;\n    }\n  }\n\n  /**\n   * @dev Internal function used for checking if a contract has been deployed at address\n   */\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Purposefully left empty to ensure ether transfers use least amount of gas possible\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n}\n\n\n",
        "CodeNames": [
            "HolographOperator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "HolographOperator.sol#L491-L511",
                "Type": "Bad source of randomness",
                "Description": "Using block.number and block.timestamp as a source of randomness is commonly advised against, as the outcome can be manipulated by calling contracts.",
                "Repair": "Consider using a decentralized oracle for the generation of random numbers, such as Chainlinks VRF."
            },
            {
                "Location": "HolographOperator.sol#L329",
                "Type": "Failed job can't be recovered",
                "Description": "Failed job can't be recovered. NFT may be lost.",
                "Repair": "Move delete _operatorJobs[hash]; to the end of function executeJob covered in if (!_failedJobs[hash])"
            },
            {
                "Location": "HolographOperator.sol#L419-L429",
                "Type": "Loss of sent ETH",
                "Description": "It is possible that operator loses sent ETH after calling HolographOperator contract's executeJob function.",
                "Repair": "Transfer the msg.value amount of ETH back to the operator in the catch block of the try ... {...} catch {...} code"
            },
            {
                "Location": "HolographOperator.sol#L875",
                "Type": "Chaotic operator behavior",
                "Description": "Any user can force chaotic 'open season' operator behavior.",
                "Repair": "Pay special attention to the scheduling algorithm to make sure different pods are given execution time according to the desired heuristics"
            },
            {
                "Location": "HolographOperator.sol#L354",
                "Type": "Gas price spikes",
                "Description": "Gas price spikes cause the selected operator to be vulnerable to frontrunning and be slashed.",
                "Repair": "Modify operator node software to queue transactions immediately with gasPrice in bridgeInRequestPayload if a gas price spike happened or allow gas fee loss tradeoff to prevent being slashed"
            },
            {
                "Location": "HolographOperator.sol#L354",
                "Type": "MEV",
                "Description": "Operator can bribe miner and steal honest operator's bond amount if gas price went high",
                "Repair": "Do not use current tx.gasprice amount to infer gas price in a previous block. Probably best to use gas price oracle."
            },
            {
                "Location": "HolographOperator.executeJob",
                "Type": "Bond tokens getting stuck",
                "Description": "Bond tokens (HLG) equal to the slash amount will get permanently stuck in the HolographOperator each time a job gets executed by someone who is not an (fallback-)operator.",
                "Repair": "Remove the requirement that _bondedAmounts need to be 0 prior to bonding and becoming an operator"
            },
            {
                "Location": "HolographOperator.executeJob",
                "Type": "Freezing of beaming job",
                "Description": "If the selected operator doesn't complete the job and gas price has spiked, the bridging request wouldn't complete and the token owner would lose access to the token till the gas price goes back down again.",
                "Repair": "Add a force-fail after EXPIRY_NUM blocks passed, without executing the TX"
            },
            {
                "Location": "HolographOperator.sol#L415",
                "Type": "Lockout vulnerability",
                "Description": "An attacker can lock operator out of the pod by setting gas limit that's higher than the block gas limit of dest chain",
                "Repair": "Limit the maximum gas allowed in an operator job"
            },
            {
                "Location": "HolographOperator.sol#L316",
                "Type": "Inaccurate gas limit check",
                "Description": "An attacker can use the gap between the gas limit check and the actual amount of gas left during the call to fail the job while still having the executeJob() function complete. The owner of the bridged token would lose access to the token since the job failed.",
                "Repair": "Modify the required amount of gas left to gasLimit + any amount of gas spent before reaching the call(), then multiply it by 32/30 to mitigate the 1/64 rule (+ some margin of safety maybe)."
            },
            {
                "Location": "HolographOperator.sol#L899, HolographOperator.sol#L920, HolographOperator.sol#L924, HolographOperator.sol#L928, HolographOperator.sol#L932",
                "Type": "Implementation code does not align with business requirement",
                "Description": "Users are not charged with withdrawn fee when user unbound token in HolographOperator.sol",
                "Repair": "Charge the 0.1% unstaking fee to make the code align with the business requirement in the doc."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 HOLOGRAPH \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                                                             \u2551\n\u2551                            / ^ \\                            \u2551\n\u2551                            ~~*~~            \u00b8               \u2551\n\u2551                         [ '<>:<>' ]         \u2502\u2591\u2591\u2591            \u2551\n\u2551               \u2554\u2557           _/\"\\_           \u2554\u2563               \u2551\n\u2551             \u250c\u2500\u256c\u256c\u2500\u2510          \"\"\"          \u250c\u2500\u256c\u256c\u2500\u2510             \u2551\n\u2551          \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510       \\_/       \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510          \u2551\n\u2551       \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510           \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510       \u2551\n\u2551    \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510     \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510    \u2551\n\u2551 \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2510 \u250c\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2500\u2510 \u2551\n\u2560\u252c\u2518 \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502\u2514\u00a4\u2518\u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502 \u2514\u252c\u2563\n\u2551\u2502  \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502   \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502  \u2502\u2551\n\u2560\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2563\n\u2560\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2563\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551    ,          \u2560\u2563     ,        ,'      *    \u2560\u2563               \u2551\n\u2551~~~~~^~~~~~~~~\u250c\u256c\u256c\u2510~~~^~~~~~~~~^^~~~~~~~~^~~\u250c\u256c\u256c\u2510~~~~~~~^~~~~~~\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor\u2019s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors\u2019 name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed \u201cas-is.\u201d You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../enum/HolographERC721Event.sol\";\nimport \"../enum/InterfaceType.sol\";\n\nimport \"../interface/ERC165.sol\";\nimport \"../interface/ERC721.sol\";\nimport \"../interface/HolographERC721Interface.sol\";\nimport \"../interface/ERC721Metadata.sol\";\nimport \"../interface/ERC721TokenReceiver.sol\";\nimport \"../interface/Holographable.sol\";\nimport \"../interface/HolographedERC721.sol\";\nimport \"../interface/HolographInterface.sol\";\nimport \"../interface/HolographerInterface.sol\";\nimport \"../interface/HolographRegistryInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/PA1DInterface.sol\";\nimport \"../interface/Ownable.sol\";\n\n/**\n * @title Holograph Bridgeable ERC-721 Collection\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC721 NFTs.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract HolographERC721 is Admin, Owner, HolographERC721Interface, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.sourceContract')) - 1)\n   */\n  bytes32 constant _sourceContractSlot = 0x27d542086d1e831d40b749e7f5509a626c3047a36d160781c40d5acc83e5b074;\n\n  /**\n   * @dev Configuration for events to trigger for source smart contract.\n   */\n  uint256 private _eventConfig;\n\n  /**\n   * @dev Collection name.\n   */\n  string private _name;\n\n  /**\n   * @dev Collection symbol.\n   */\n  string private _symbol;\n\n  /**\n   * @dev Collection royalty base points.\n   */\n  uint16 private _bps;\n\n  /**\n   * @dev Array of all token ids in collection.\n   */\n  uint256[] private _allTokens;\n\n  /**\n   * @dev Map of token id to array index of _ownedTokens.\n   */\n  mapping(uint256 => uint256) private _ownedTokensIndex;\n\n  /**\n   * @dev Token id to wallet (owner) address map.\n   */\n  mapping(uint256 => address) private _tokenOwner;\n\n  /**\n   * @dev 1-to-1 map of token id that was assigned an approved operator address.\n   */\n  mapping(uint256 => address) private _tokenApprovals;\n\n  /**\n   * @dev Map of total tokens owner by a specific address.\n   */\n  mapping(address => uint256) private _ownedTokensCount;\n\n  /**\n   * @dev Map of array of token ids owned by a specific address.\n   */\n  mapping(address => uint256[]) private _ownedTokens;\n\n  /**\n   * @notice Map of full operator approval for a particular address.\n   * @dev Usually utilised for supporting marketplace proxy wallets.\n   */\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n  /**\n   * @dev Mapping from token id to position in the allTokens array.\n   */\n  mapping(uint256 => uint256) private _allTokensIndex;\n\n  /**\n   * @dev Mapping of all token ids that have been burned. This is to prevent re-minting of same token ids.\n   */\n  mapping(uint256 => bool) private _burnedTokens;\n\n  /**\n   * @notice Only allow calls from bridge smart contract.\n   */\n  modifier onlyBridge() {\n    require(msg.sender == _holograph().getBridge(), \"ERC721: bridge only call\");\n    _;\n  }\n\n  /**\n   * @notice Only allow calls from source smart contract.\n   */\n  modifier onlySource() {\n    address sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    require(msg.sender == sourceContract, \"ERC721: source only call\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"ERC721: already initialized\");\n    InitializableInterface sourceContract;\n    assembly {\n      sstore(_ownerSlot, caller())\n      sourceContract := sload(_sourceContractSlot)\n    }\n    (\n      string memory contractName,\n      string memory contractSymbol,\n      uint16 contractBps,\n      uint256 eventConfig,\n      bool skipInit,\n      bytes memory initCode\n    ) = abi.decode(initPayload, (string, string, uint16, uint256, bool, bytes));\n    _name = contractName;\n    _symbol = contractSymbol;\n    _bps = contractBps;\n    _eventConfig = eventConfig;\n    if (!skipInit) {\n      require(sourceContract.init(initCode) == InitializableInterface.init.selector, \"ERC721: could not init source\");\n      (bool success, bytes memory returnData) = _royalties().delegatecall(\n        abi.encodeWithSignature(\"initPA1D(bytes)\", abi.encode(address(this), uint256(contractBps)))\n      );\n      bytes4 selector = abi.decode(returnData, (bytes4));\n      require(success && selector == InitializableInterface.init.selector, \"ERC721: coud not init PA1D\");\n    }\n\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Gets a base64 encoded contract JSON file.\n   * @return string The URI.\n   */\n  function contractURI() external view returns (string memory) {\n    return HolographInterfacesInterface(_interfaces()).contractURI(_name, \"\", \"\", _bps, address(this));\n  }\n\n  /**\n   * @notice Gets the name of the collection.\n   * @return string The collection name.\n   */\n  function name() external view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @notice Shows the interfaces the contracts support\n   * @dev Must add new 4 byte interface Ids here to acknowledge support\n   * @param interfaceId ERC165 style 4 byte interfaceId.\n   * @return bool True if supported.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    HolographInterfacesInterface interfaces = HolographInterfacesInterface(_interfaces());\n    ERC165 erc165Contract;\n    assembly {\n      erc165Contract := sload(_sourceContractSlot)\n    }\n    if (\n      interfaces.supportsInterface(InterfaceType.ERC721, interfaceId) || // check global interfaces\n      interfaces.supportsInterface(InterfaceType.PA1D, interfaceId) || // check if royalties supports interface\n      erc165Contract.supportsInterface(interfaceId) // check if source supports interface\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Gets the collection's symbol.\n   * @return string The symbol.\n   */\n  function symbol() external view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @notice Get's the URI of the token.\n   * @dev Defaults the the Arweave URI\n   * @return string The URI.\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory) {\n    require(_exists(tokenId), \"ERC721: token does not exist\");\n    ERC721Metadata sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    return sourceContract.tokenURI(tokenId);\n  }\n\n  /**\n   * @notice Get list of tokens owned by wallet.\n   * @param wallet The wallet address to get tokens for.\n   * @return uint256[] Returns an array of token ids owned by wallet.\n   */\n  function tokensOfOwner(address wallet) external view returns (uint256[] memory) {\n    return _ownedTokens[wallet];\n  }\n\n  /**\n   * @notice Get set length list, starting from index, for tokens owned by wallet.\n   * @param wallet The wallet address to get tokens for.\n   * @param index The index to start enumeration from.\n   * @param length The length of returned results.\n   * @return tokenIds uint256[] Returns a set length array of token ids owned by wallet.\n   */\n  function tokensOfOwner(\n    address wallet,\n    uint256 index,\n    uint256 length\n  ) external view returns (uint256[] memory tokenIds) {\n    uint256 supply = _ownedTokensCount[wallet];\n    if (index + length > supply) {\n      length = supply - index;\n    }\n    tokenIds = new uint256[](length);\n    for (uint256 i = 0; i < length; i++) {\n      tokenIds[i] = _ownedTokens[wallet][index + i];\n    }\n  }\n\n  /**\n   * @notice Adds a new address to the token's approval list.\n   * @dev Requires the sender to be in the approved addresses.\n   * @param to The address to approve.\n   * @param tokenId The affected token.\n   */\n  function approve(address to, uint256 tokenId) external payable {\n    address tokenOwner = _tokenOwner[tokenId];\n    require(to != tokenOwner, \"ERC721: cannot approve self\");\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    if (_isEventRegistered(HolographERC721Event.beforeApprove)) {\n      require(SourceERC721().beforeApprove(tokenOwner, to, tokenId));\n    }\n    _tokenApprovals[tokenId] = to;\n    emit Approval(tokenOwner, to, tokenId);\n    if (_isEventRegistered(HolographERC721Event.afterApprove)) {\n      require(SourceERC721().afterApprove(tokenOwner, to, tokenId));\n    }\n  }\n\n  /**\n   * @notice Burns the token.\n   * @dev The sender must be the owner or approved.\n   * @param tokenId The token to burn.\n   */\n  function burn(uint256 tokenId) external {\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    address wallet = _tokenOwner[tokenId];\n    if (_isEventRegistered(HolographERC721Event.beforeBurn)) {\n      require(SourceERC721().beforeBurn(wallet, tokenId));\n    }\n    _burn(wallet, tokenId);\n    if (_isEventRegistered(HolographERC721Event.afterBurn)) {\n      require(SourceERC721().afterBurn(wallet, tokenId));\n    }\n  }\n\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external onlyBridge returns (bytes4) {\n    (address from, address to, uint256 tokenId, bytes memory data) = abi.decode(\n      payload,\n      (address, address, uint256, bytes)\n    );\n    require(!_exists(tokenId), \"ERC721: token already exists\");\n    delete _burnedTokens[tokenId];\n    _mint(to, tokenId);\n    if (_isEventRegistered(HolographERC721Event.bridgeIn)) {\n      require(SourceERC721().bridgeIn(fromChain, from, to, tokenId, data), \"HOLOGRAPH: bridge in failed\");\n    }\n    return Holographable.bridgeIn.selector;\n  }\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external onlyBridge returns (bytes4 selector, bytes memory data) {\n    (address from, address to, uint256 tokenId) = abi.decode(payload, (address, address, uint256));\n    require(to != address(0), \"ERC721: zero address\");\n    require(_isApproved(sender, tokenId), \"ERC721: sender not approved\");\n    require(from == _tokenOwner[tokenId], \"ERC721: from is not owner\");\n    if (_isEventRegistered(HolographERC721Event.bridgeOut)) {\n      data = SourceERC721().bridgeOut(toChain, from, to, tokenId);\n    }\n    _burn(from, tokenId);\n    return (Holographable.bridgeOut.selector, abi.encode(from, to, tokenId, data));\n  }\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   * @param from cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must exist and be owned by `from`.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external payable {\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   * @param from cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must exist and be owned by `from`.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory data\n  ) public payable {\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    if (_isEventRegistered(HolographERC721Event.beforeSafeTransfer)) {\n      require(SourceERC721().beforeSafeTransfer(from, to, tokenId, data));\n    }\n    _transferFrom(from, to, tokenId);\n    if (_isContract(to)) {\n      require(\n        (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&\n          ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&\n          ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==\n          ERC721TokenReceiver.onERC721Received.selector),\n        \"ERC721: onERC721Received fail\"\n      );\n    }\n    if (_isEventRegistered(HolographERC721Event.afterSafeTransfer)) {\n      require(SourceERC721().afterSafeTransfer(from, to, tokenId, data));\n    }\n  }\n\n  /**\n   * @notice Adds a new approved operator.\n   * @dev Allows platforms to sell/transfer all your NFTs. Used with proxy contracts like OpenSea/Rarible.\n   * @param to The address to approve.\n   * @param approved Turn on or off approval status.\n   */\n  function setApprovalForAll(address to, bool approved) external {\n    require(to != msg.sender, \"ERC721: cannot approve self\");\n    if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {\n      require(SourceERC721().beforeApprovalAll(to, approved));\n    }\n    _operatorApprovals[msg.sender][to] = approved;\n    emit ApprovalForAll(msg.sender, to, approved);\n    if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {\n      require(SourceERC721().afterApprovalAll(to, approved));\n    }\n  }\n\n  /**\n   * @dev Allows for source smart contract to burn a token.\n   *  Note: this is put in place to make sure that custom logic could be implemented for merging, gamification, etc.\n   *  Note: token cannot be burned if it's locked by bridge.\n   */\n  function sourceBurn(uint256 tokenId) external onlySource {\n    address wallet = _tokenOwner[tokenId];\n    _burn(wallet, tokenId);\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a token.\n   */\n  function sourceMint(address to, uint224 tokenId) external onlySource {\n    // uint32 is reserved for chain id to be used\n    // we need to get current chain id, and prepend it to tokenId\n    // this will prevent possible tokenId overlap if minting simultaneously on multiple chains is possible\n    uint256 token = uint256(bytes32(abi.encodePacked(_chain(), tokenId)));\n    require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n    _mint(to, token);\n  }\n\n  /**\n   * @dev Allows source to get the prepend for their tokenIds.\n   */\n  function sourceGetChainPrepend() external view onlySource returns (uint256) {\n    return uint256(bytes32(abi.encodePacked(_chain(), uint224(0))));\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  //   function sourceMintBatch(address to, uint224[] calldata tokenIds) external onlySource {\n  //     require(tokenIds.length < 1000, \"ERC721: max batch size is 1000\");\n  //     uint32 chain = _chain();\n  //     uint256 token;\n  //     for (uint256 i = 0; i < tokenIds.length; i++) {\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       token = uint256(bytes32(abi.encodePacked(chain, tokenIds[i])));\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       _mint(to, token);\n  //     }\n  //   }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  //   function sourceMintBatch(address[] calldata wallets, uint224[] calldata tokenIds) external onlySource {\n  //     require(wallets.length == tokenIds.length, \"ERC721: array length missmatch\");\n  //     require(tokenIds.length < 1000, \"ERC721: max batch size is 1000\");\n  //     uint32 chain = _chain();\n  //     uint256 token;\n  //     for (uint256 i = 0; i < tokenIds.length; i++) {\n  //       token = uint256(bytes32(abi.encodePacked(chain, tokenIds[i])));\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       _mint(wallets[i], token);\n  //     }\n  //   }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  //   function sourceMintBatchIncremental(\n  //     address to,\n  //     uint224 startingTokenId,\n  //     uint256 length\n  //   ) external onlySource {\n  //     uint32 chain = _chain();\n  //     uint256 token;\n  //     for (uint256 i = 0; i < length; i++) {\n  //       token = uint256(bytes32(abi.encodePacked(chain, startingTokenId)));\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       _mint(to, token);\n  //       startingTokenId++;\n  //     }\n  //   }\n\n  /**\n   * @dev Allows for source smart contract to transfer a token.\n   *  Note: this is put in place to make sure that custom logic could be implemented for merging, gamification, etc.\n   *  Note: token cannot be transfered if it's locked by bridge.\n   */\n  function sourceTransfer(address to, uint256 tokenId) external onlySource {\n    address wallet = _tokenOwner[tokenId];\n    _transferFrom(wallet, to, tokenId);\n  }\n\n  /**\n   * @notice Transfers `tokenId` token from `msg.sender` to `to`.\n   * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * @param to cannot be the zero address.\n   * @param tokenId token must be owned by `from`.\n   */\n  function transfer(address to, uint256 tokenId) external payable {\n    transferFrom(msg.sender, to, tokenId, \"\");\n  }\n\n  /**\n   * @notice Transfers `tokenId` token from `from` to `to`.\n   * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * @param from  cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must be owned by `from`.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public payable {\n    transferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @notice Transfers `tokenId` token from `from` to `to`.\n   * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n   * @param from  cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must be owned by `from`.\n   * @param data additional data to pass.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory data\n  ) public payable {\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    if (_isEventRegistered(HolographERC721Event.beforeTransfer)) {\n      require(SourceERC721().beforeTransfer(from, to, tokenId, data));\n    }\n    _transferFrom(from, to, tokenId);\n    if (_isEventRegistered(HolographERC721Event.afterTransfer)) {\n      require(SourceERC721().afterTransfer(from, to, tokenId, data));\n    }\n  }\n\n  /**\n   * @notice Get total number of tokens owned by wallet.\n   * @dev Used to see total amount of tokens owned by a specific wallet.\n   * @param wallet Address for which to get token balance.\n   * @return uint256 Returns an integer, representing total amount of tokens held by address.\n   */\n  function balanceOf(address wallet) public view returns (uint256) {\n    require(wallet != address(0), \"ERC721: zero address\");\n    return _ownedTokensCount[wallet];\n  }\n\n  function burned(uint256 tokenId) public view returns (bool) {\n    return _burnedTokens[tokenId];\n  }\n\n  /**\n   * @notice Decimal places to have for totalSupply.\n   * @dev Since ERC721s are single, we use 0 as the decimal places to make sure a round number for totalSupply.\n   * @return uint256 Returns the number of decimal places to have for totalSupply.\n   */\n  function decimals() external pure returns (uint256) {\n    return 0;\n  }\n\n  function exists(uint256 tokenId) public view returns (bool) {\n    return _tokenOwner[tokenId] != address(0);\n  }\n\n  /**\n   * @notice Gets the approved address for the token.\n   * @dev Single operator set for a specific token. Usually used for one-time very specific authorisations.\n   * @param tokenId Token id to get approved operator for.\n   * @return address Approved address for token.\n   */\n  function getApproved(uint256 tokenId) external view returns (address) {\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @notice Checks if the address is approved.\n   * @dev Includes references to OpenSea and Rarible marketplace proxies.\n   * @param wallet Address of the wallet.\n   * @param operator Address of the marketplace operator.\n   * @return bool True if approved.\n   */\n  function isApprovedForAll(address wallet, address operator) external view returns (bool) {\n    return _operatorApprovals[wallet][operator];\n  }\n\n  /**\n   * @notice Checks who the owner of a token is.\n   * @dev The token must exist.\n   * @param tokenId The token to look up.\n   * @return address Owner of the token.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address) {\n    address tokenOwner = _tokenOwner[tokenId];\n    require(tokenOwner != address(0), \"ERC721: token does not exist\");\n    return tokenOwner;\n  }\n\n  /**\n   * @notice Get token by index.\n   * @dev Used in conjunction with totalSupply function to iterate over all tokens in collection.\n   * @param index Index of token in array.\n   * @return uint256 Returns the token id of token located at that index.\n   */\n  function tokenByIndex(uint256 index) external view returns (uint256) {\n    require(index < _allTokens.length, \"ERC721: index out of bounds\");\n    return _allTokens[index];\n  }\n\n  /**\n   * @notice Get set length list, starting from index, for all tokens.\n   * @param index The index to start enumeration from.\n   * @param length The length of returned results.\n   * @return tokenIds uint256[] Returns a set length array of token ids minted.\n   */\n  function tokens(uint256 index, uint256 length) external view returns (uint256[] memory tokenIds) {\n    uint256 supply = _allTokens.length;\n    if (index + length > supply) {\n      length = supply - index;\n    }\n    tokenIds = new uint256[](length);\n    for (uint256 i = 0; i < length; i++) {\n      tokenIds[i] = _allTokens[index + i];\n    }\n  }\n\n  /**\n   * @notice Get token from wallet by index instead of token id.\n   * @dev Helpful for wallet token enumeration where token id info is not yet available. Use in conjunction with balanceOf function.\n   * @param wallet Specific address for which to get token for.\n   * @param index Index of token in array.\n   * @return uint256 Returns the token id of token located at that index in specified wallet.\n   */\n  function tokenOfOwnerByIndex(address wallet, uint256 index) external view returns (uint256) {\n    require(index < balanceOf(wallet), \"ERC721: index out of bounds\");\n    return _ownedTokens[wallet][index];\n  }\n\n  /**\n   * @notice Total amount of tokens in the collection.\n   * @dev Ignores burned tokens.\n   * @return uint256 Returns the total number of active (not burned) tokens.\n   */\n  function totalSupply() external view returns (uint256) {\n    return _allTokens.length;\n  }\n\n  /**\n   * @notice Empty function that is triggered by external contract on NFT transfer.\n   * @dev We have this blank function in place to make sure that external contract sending in NFTs don't error out.\n   * @dev Since it's not being used, the _operator variable is commented out to avoid compiler warnings.\n   * @dev Since it's not being used, the _from variable is commented out to avoid compiler warnings.\n   * @dev Since it's not being used, the _tokenId variable is commented out to avoid compiler warnings.\n   * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n   * @return bytes4 Returns the interfaceId of onERC721Received.\n   */\n  function onERC721Received(\n    address _operator,\n    address _from,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bytes4) {\n    require(_isContract(_operator), \"ERC721: operator not contract\");\n    if (_isEventRegistered(HolographERC721Event.beforeOnERC721Received)) {\n      require(SourceERC721().beforeOnERC721Received(_operator, _from, address(this), _tokenId, _data));\n    }\n    try HolographERC721Interface(_operator).ownerOf(_tokenId) returns (address tokenOwner) {\n      require(tokenOwner == address(this), \"ERC721: contract not token owner\");\n    } catch {\n      revert(\"ERC721: token does not exist\");\n    }\n    if (_isEventRegistered(HolographERC721Event.afterOnERC721Received)) {\n      require(SourceERC721().afterOnERC721Received(_operator, _from, address(this), _tokenId, _data));\n    }\n    return ERC721TokenReceiver.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Add a newly minted token into managed list of tokens.\n   * @param to Address of token owner for which to add the token.\n   * @param tokenId Id of token to add.\n   */\n  function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n    _ownedTokensIndex[tokenId] = _ownedTokensCount[to];\n    _ownedTokensCount[to]++;\n    _ownedTokens[to].push(tokenId);\n    _allTokensIndex[tokenId] = _allTokens.length;\n    _allTokens.push(tokenId);\n  }\n\n  /**\n   * @notice Burns the token.\n   * @dev All validation needs to be done before calling this function.\n   * @param wallet Address of current token owner.\n   * @param tokenId The token to burn.\n   */\n  function _burn(address wallet, uint256 tokenId) private {\n    _clearApproval(tokenId);\n    _tokenOwner[tokenId] = address(0);\n    emit Transfer(wallet, address(0), tokenId);\n    _removeTokenFromOwnerEnumeration(wallet, tokenId);\n    _burnedTokens[tokenId] = true;\n  }\n\n  /**\n   * @notice Deletes a token from the approval list.\n   * @dev Removes from count.\n   * @param tokenId T.\n   */\n  function _clearApproval(uint256 tokenId) private {\n    delete _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @notice Mints an NFT.\n   * @dev Can to mint the token to the zero address and the token cannot already exist.\n   * @param to Address to mint to.\n   * @param tokenId The new token.\n   */\n  function _mint(address to, uint256 tokenId) private {\n    require(tokenId > 0, \"ERC721: token id cannot be zero\");\n    require(to != address(0), \"ERC721: minting to burn address\");\n    require(!_exists(tokenId), \"ERC721: token already exists\");\n    require(!_burnedTokens[tokenId], \"ERC721: token has been burned\");\n    _tokenOwner[tokenId] = to;\n    emit Transfer(address(0), to, tokenId);\n    _addTokenToOwnerEnumeration(to, tokenId);\n  }\n\n  function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n    uint256 lastTokenIndex = _allTokens.length - 1;\n    uint256 tokenIndex = _allTokensIndex[tokenId];\n    uint256 lastTokenId = _allTokens[lastTokenIndex];\n    _allTokens[tokenIndex] = lastTokenId;\n    _allTokensIndex[lastTokenId] = tokenIndex;\n    delete _allTokensIndex[tokenId];\n    delete _allTokens[lastTokenIndex];\n    _allTokens.pop();\n  }\n\n  /**\n   * @dev Remove a token from managed list of tokens.\n   * @param from Address of token owner for which to remove the token.\n   * @param tokenId Id of token to remove.\n   */\n  function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n    _removeTokenFromAllTokensEnumeration(tokenId);\n    _ownedTokensCount[from]--;\n    uint256 lastTokenIndex = _ownedTokensCount[from];\n    uint256 tokenIndex = _ownedTokensIndex[tokenId];\n    if (tokenIndex != lastTokenIndex) {\n      uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n      _ownedTokens[from][tokenIndex] = lastTokenId;\n      _ownedTokensIndex[lastTokenId] = tokenIndex;\n    }\n    if (lastTokenIndex == 0) {\n      delete _ownedTokens[from];\n    } else {\n      delete _ownedTokens[from][lastTokenIndex];\n      _ownedTokens[from].pop();\n    }\n  }\n\n  /**\n   * @dev Primary private function that handles the transfer/mint/burn functionality.\n   * @param from Address from where token is being transferred. Zero address means it is being minted.\n   * @param to Address to whom the token is being transferred. Zero address means it is being burned.\n   * @param tokenId Id of token that is being transferred/minted/burned.\n   */\n  function _transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) private {\n    require(_tokenOwner[tokenId] == from, \"ERC721: token not owned\");\n    require(to != address(0), \"ERC721: use burn instead\");\n    _clearApproval(tokenId);\n    _tokenOwner[tokenId] = to;\n    emit Transfer(from, to, tokenId);\n    _removeTokenFromOwnerEnumeration(from, tokenId);\n    _addTokenToOwnerEnumeration(to, tokenId);\n  }\n\n  function _chain() private view returns (uint32) {\n    uint32 currentChain = HolographInterface(HolographerInterface(payable(address(this))).getHolograph())\n      .getHolographChainId();\n    if (currentChain != HolographerInterface(payable(address(this))).getOriginChain()) {\n      return currentChain;\n    }\n    return uint32(0);\n  }\n\n  /**\n   * @notice Checks if the token owner exists.\n   * @dev If the address is the zero address no owner exists.\n   * @param tokenId The affected token.\n   * @return bool True if it exists.\n   */\n  function _exists(uint256 tokenId) private view returns (bool) {\n    address tokenOwner = _tokenOwner[tokenId];\n    return tokenOwner != address(0);\n  }\n\n  /**\n   * @notice Checks if the address is an approved one.\n   * @dev Uses inlined checks for different usecases of approval.\n   * @param spender Address of the spender.\n   * @param tokenId The affected token.\n   * @return bool True if approved.\n   */\n  function _isApproved(address spender, uint256 tokenId) private view returns (bool) {\n    require(_exists(tokenId), \"ERC721: token does not exist\");\n    address tokenOwner = _tokenOwner[tokenId];\n    return (spender == tokenOwner || _tokenApprovals[tokenId] == spender || _operatorApprovals[tokenOwner][spender]);\n  }\n\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Get the source smart contract as bridgeable interface.\n   */\n  function SourceERC721() private view returns (HolographedERC721 sourceContract) {\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n  }\n\n  /**\n   * @dev Get the interfaces contract address.\n   */\n  function _interfaces() private view returns (address) {\n    return _holograph().getInterfaces();\n  }\n\n  function owner() public view override returns (address) {\n    Ownable ownableContract;\n    assembly {\n      ownableContract := sload(_sourceContractSlot)\n    }\n    return ownableContract.owner();\n  }\n\n  function _holograph() private view returns (HolographInterface holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @dev Get the bridge contract address.\n   */\n  function _royalties() private view returns (address) {\n    return\n      HolographRegistryInterface(_holograph().getRegistry()).getContractTypeAddress(\n        0x0000000000000000000000000000000000000000000000000000000050413144\n      );\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  /**\n   * @notice Fallback to the source contract.\n   * @dev Any function call that is not covered here, will automatically be sent over to the source contract.\n   */\n  fallback() external payable {\n    // we check if royalties support the function, send there, otherwise revert to source\n    address _target;\n    if (HolographInterfacesInterface(_interfaces()).supportsInterface(InterfaceType.PA1D, msg.sig)) {\n      _target = _royalties();\n      assembly {\n        calldatacopy(0, 0, calldatasize())\n        let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n        returndatacopy(0, 0, returndatasize())\n        switch result\n        case 0 {\n          revert(0, returndatasize())\n        }\n        default {\n          return(0, returndatasize())\n        }\n      }\n    } else {\n      assembly {\n        calldatacopy(0, 0, calldatasize())\n        mstore(calldatasize(), caller())\n        let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)\n        returndatacopy(0, 0, returndatasize())\n        switch result\n        case 0 {\n          revert(0, returndatasize())\n        }\n        default {\n          return(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  function _isEventRegistered(HolographERC721Event _eventName) private view returns (bool) {\n    return ((_eventConfig >> uint256(_eventName)) & uint256(1) == 1 ? true : false);\n  }\n}\n\n\n",
        "CodeNames": [
            "HolographERC721.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "HolographERC721.sol#L962",
                "Type": "Leak of value",
                "Description": "Leak of value when interacting with an NFT using the receive() or fallback() callback.",
                "Repair": "Update receive() function to pass value down like the fallback function"
            },
            {
                "Location": "HolographERC721.sol#L500, HolographERC721.sol#L577",
                "Type": "NFT theft",
                "Description": "A source contract can burn and transfer NFTs of users without their permission.",
                "Repair": "Remove sourceBurn and sourceTransfer functions of HolographERC721 and require user approval to transfer or burn their tokens"
            },
            {
                "Location": "HolographERC721.safeTransferFrom",
                "Type": "ERC-721 compliance",
                "Description": "The safeTransferFrom function does not always call onERC721Received, leading to failed transfers when they should not fail.",
                "Repair": "Remove the ERC-165 check in the require statement"
            },
            {
                "Location": "HolographERC721.sol#L392",
                "Type": "missing parameter in event",
                "Description": "ApprovalAll event is missing parameters.",
                "Repair": "Add parameter: owner"
            },
            {
                "Location": "HolographERC721.sol#L467",
                "Type": "incorrect implementation of ERC721",
                "Description": "Incorrect implementation of ERC721 may have bad consequences for receiver.",
                "Repair": "Pass the msg.sender parameter, as the ERC721 standard requires."
            },
            {
                "Location": "HolographERC721.approve",
                "Type": "Non-compliance with EIP-721",
                "Description": "HolographERC721.approve not EIP-721 compliant",
                "Repair": "Follow the EIP, i.e. do not allow approved addresses to approve other addresses"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 HOLOGRAPH \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                                                             \u2551\n\u2551                            / ^ \\                            \u2551\n\u2551                            ~~*~~            \u00b8               \u2551\n\u2551                         [ '<>:<>' ]         \u2502\u2591\u2591\u2591            \u2551\n\u2551               \u2554\u2557           _/\"\\_           \u2554\u2563               \u2551\n\u2551             \u250c\u2500\u256c\u256c\u2500\u2510          \"\"\"          \u250c\u2500\u256c\u256c\u2500\u2510             \u2551\n\u2551          \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510       \\_/       \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510          \u2551\n\u2551       \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510           \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510       \u2551\n\u2551    \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510     \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510    \u2551\n\u2551 \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2510 \u250c\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2500\u2510 \u2551\n\u2560\u252c\u2518 \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502\u2514\u00a4\u2518\u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502 \u2514\u252c\u2563\n\u2551\u2502  \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502   \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502  \u2502\u2551\n\u2560\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2563\n\u2560\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2563\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551    ,          \u2560\u2563     ,        ,'      *    \u2560\u2563               \u2551\n\u2551~~~~~^~~~~~~~~\u250c\u256c\u256c\u2510~~~^~~~~~~~~^^~~~~~~~~^~~\u250c\u256c\u256c\u2510~~~~~~~^~~~~~~\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor\u2019s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors\u2019 name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed \u201cas-is.\u201d You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../enum/ChainIdType.sol\";\n\nimport \"../interface/CrossChainMessageInterface.sol\";\nimport \"../interface/HolographOperatorInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/LayerZeroModuleInterface.sol\";\nimport \"../interface/LayerZeroOverrides.sol\";\n\n/**\n * @title Holograph LayerZero Module\n * @author https://github.com/holographxyz\n * @notice Holograph module for enabling LayerZero cross-chain messaging\n * @dev This contract abstracts all of the LayerZero specific logic into an isolated module\n */\ncontract LayerZeroModule is Admin, Initializable, CrossChainMessageInterface, LayerZeroModuleInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.bridge')) - 1)\n   */\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.interfaces')) - 1)\n   */\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.lZEndpoint')) - 1)\n   */\n  bytes32 constant _lZEndpointSlot = 0x56825e447adf54cdde5f04815fcf9b1dd26ef9d5c053625147c18b7c13091686;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _operatorSlot = 0x7caba557ad34138fa3b7e43fb574e0e6cc10481c3073e0dffbc560db81b5c60f;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _baseGasSlot = 0x1eaa99919d5563fbfdd75d9d906ff8de8cf52beab1ed73875294c8a0c9e9d83a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _gasPerByteSlot = 0x99d8b07d37c89d4c4f4fa0fd9b7396caeb5d1d4e58b41c61c71e3cf7d424a625;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address bridge, address interfaces, address operator, uint256 baseGas, uint256 gasPerByte) = abi.decode(\n      initPayload,\n      (address, address, address, uint256, uint256)\n    );\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_bridgeSlot, bridge)\n      sstore(_interfacesSlot, interfaces)\n      sstore(_operatorSlot, operator)\n      sstore(_baseGasSlot, baseGas)\n      sstore(_gasPerByteSlot, gasPerByte)\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Receive cross-chain message from LayerZero\n   * @dev This function only allows calls from the configured LayerZero endpoint address\n   */\n  function lzReceive(\n    uint16, /* _srcChainId*/\n    bytes calldata _srcAddress,\n    uint64, /* _nonce*/\n    bytes calldata _payload\n  ) external payable {\n    assembly {\n      /**\n       * @dev check if msg.sender is LayerZero Endpoint\n       */\n      switch eq(sload(_lZEndpointSlot), caller())\n      case 0 {\n        /**\n         * @dev this is the assembly version of -> revert(\"HOLOGRAPH: LZ only endpoint\");\n         */\n        mstore(0x80, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        mstore(0xa0, 0x0000002000000000000000000000000000000000000000000000000000000000)\n        mstore(0xc0, 0x0000001b484f4c4f47524150483a204c5a206f6e6c7920656e64706f696e7400)\n        mstore(0xe0, 0x0000000000000000000000000000000000000000000000000000000000000000)\n        revert(0x80, 0xc4)\n      }\n      let ptr := mload(0x40)\n      calldatacopy(add(ptr, 0x0c), _srcAddress.offset, _srcAddress.length)\n      /**\n       * @dev check if LZ from address is same as address(this)\n       */\n      switch eq(mload(ptr), address())\n      case 0 {\n        /**\n         * @dev this is the assembly version of -> revert(\"HOLOGRAPH: unauthorized sender\");\n         */\n        mstore(0x80, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        mstore(0xa0, 0x0000002000000000000000000000000000000000000000000000000000000000)\n        mstore(0xc0, 0x0000001e484f4c4f47524150483a20756e617574686f72697a65642073656e64)\n        mstore(0xe0, 0x6572000000000000000000000000000000000000000000000000000000000000)\n        revert(0x80, 0xc4)\n      }\n    }\n    /**\n     * @dev if validation has passed, submit payload to Holograph Operator for converting into an operator job\n     */\n    _operator().crossChainMessage(_payload);\n  }\n\n  /**\n   * @dev Need to add an extra function to get LZ gas amount needed for their internal cross-chain message verification\n   */\n  function send(\n    uint256, /* gasLimit*/\n    uint256, /* gasPrice*/\n    uint32 toChain,\n    address msgSender,\n    uint256 msgValue,\n    bytes calldata crossChainPayload\n  ) external payable {\n    require(msg.sender == address(_operator()), \"HOLOGRAPH: operator only call\");\n    LayerZeroOverrides lZEndpoint;\n    assembly {\n      lZEndpoint := sload(_lZEndpointSlot)\n    }\n    // need to recalculate the gas amounts for LZ to deliver message\n    lZEndpoint.send{value: msgValue}(\n      uint16(_interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)),\n      abi.encodePacked(address(this), address(this)),\n      crossChainPayload,\n      payable(msgSender),\n      address(this),\n      abi.encodePacked(uint16(1), uint256(_baseGas() + (crossChainPayload.length * _gasPerByte())))\n    );\n  }\n\n  function getMessageFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee, uint256 msgFee) {\n    uint16 lzDestChain = uint16(\n      _interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)\n    );\n    LayerZeroOverrides lz;\n    assembly {\n      lz := sload(_lZEndpointSlot)\n    }\n    // convert holograph chain id to lz chain id\n    (uint128 dstPriceRatio, uint128 dstGasPriceInWei) = _getPricing(lz, lzDestChain);\n    if (gasPrice == 0) {\n      gasPrice = dstGasPriceInWei;\n    }\n    bytes memory adapterParams = abi.encodePacked(\n      uint16(1),\n      uint256(_baseGas() + (crossChainPayload.length * _gasPerByte()))\n    );\n    (uint256 nativeFee, ) = lz.estimateFees(lzDestChain, address(this), crossChainPayload, false, adapterParams);\n    return (((gasPrice * (gasLimit + (gasLimit / 10))) * dstPriceRatio) / (10**10), nativeFee);\n  }\n\n  function getHlgFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice\n  ) external view returns (uint256 hlgFee) {\n    LayerZeroOverrides lz;\n    assembly {\n      lz := sload(_lZEndpointSlot)\n    }\n    uint16 lzDestChain = uint16(\n      _interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)\n    );\n    (uint128 dstPriceRatio, uint128 dstGasPriceInWei) = _getPricing(lz, lzDestChain);\n    if (gasPrice == 0) {\n      gasPrice = dstGasPriceInWei;\n    }\n    return ((gasPrice * (gasLimit + (gasLimit / 10))) * dstPriceRatio) / (10**10);\n  }\n\n  function _getPricing(LayerZeroOverrides lz, uint16 lzDestChain)\n    private\n    view\n    returns (uint128 dstPriceRatio, uint128 dstGasPriceInWei)\n  {\n    return\n      LayerZeroOverrides(LayerZeroOverrides(lz.defaultSendLibrary()).getAppConfig(lzDestChain, address(this)).relayer)\n        .dstPriceLookup(lzDestChain);\n  }\n\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external onlyAdmin {\n    assembly {\n      sstore(_interfacesSlot, interfaces)\n    }\n  }\n\n  /**\n   * @notice Get the address of the approved LayerZero Endpoint\n   * @dev All lzReceive function calls allow only requests from this address\n   */\n  function getLZEndpoint() external view returns (address lZEndpoint) {\n    assembly {\n      lZEndpoint := sload(_lZEndpointSlot)\n    }\n  }\n\n  /**\n   * @notice Update the approved LayerZero Endpoint address\n   * @param lZEndpoint address of the LayerZero Endpoint to use\n   */\n  function setLZEndpoint(address lZEndpoint) external onlyAdmin {\n    assembly {\n      sstore(_lZEndpointSlot, lZEndpoint)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external onlyAdmin {\n    assembly {\n      sstore(_operatorSlot, operator)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Bridge Interface\n   */\n  function _bridge() private view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interfaces Interface\n   */\n  function _interfaces() private view returns (HolographInterfacesInterface interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Operator Interface\n   */\n  function _operator() private view returns (HolographOperatorInterface operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent having any type of ether transfered into the contract\n   */\n  receive() external payable {\n    revert();\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n\n  /**\n   * @notice Get the baseGas value\n   * @dev Cross-chain messages require at least this much gas\n   */\n  function getBaseGas() external view returns (uint256 baseGas) {\n    assembly {\n      baseGas := sload(_baseGasSlot)\n    }\n  }\n\n  /**\n   * @notice Update the baseGas value\n   * @param baseGas minimum gas amount that a message requires\n   */\n  function setBaseGas(uint256 baseGas) external onlyAdmin {\n    assembly {\n      sstore(_baseGasSlot, baseGas)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the baseGas value\n   */\n  function _baseGas() private view returns (uint256 baseGas) {\n    assembly {\n      baseGas := sload(_baseGasSlot)\n    }\n  }\n\n  /**\n   * @notice Get the gasPerByte value\n   * @dev Cross-chain messages require at least this much gas (per payload byte)\n   */\n  function getGasPerByte() external view returns (uint256 gasPerByte) {\n    assembly {\n      gasPerByte := sload(_gasPerByteSlot)\n    }\n  }\n\n  /**\n   * @notice Update the gasPerByte value\n   * @param gasPerByte minimum gas amount (per payload byte) that a message requires\n   */\n  function setGasPerByte(uint256 gasPerByte) external onlyAdmin {\n    assembly {\n      sstore(_gasPerByteSlot, gasPerByte)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the gasPerByte value\n   */\n  function _gasPerByte() private view returns (uint256 gasPerByte) {\n    assembly {\n      gasPerByte := sload(_gasPerByteSlot)\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "LayerZeroModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LayerZeroModule.sol#L431-L445",
                "Type": "miscalculates gas",
                "Description": "LayerZeroModule miscalculates gas, risking loss of assets.",
                "Repair": "Use the target gas costs. Re-engineer lzReceive to be fault-proof, i.e. save some gas to emit result event. Add destination chain-specific _baseGas and _gasPerByte to mitigate EVM differences in opcode costs."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 HOLOGRAPH \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                                                             \u2551\n\u2551                            / ^ \\                            \u2551\n\u2551                            ~~*~~            \u00b8               \u2551\n\u2551                         [ '<>:<>' ]         \u2502\u2591\u2591\u2591            \u2551\n\u2551               \u2554\u2557           _/\"\\_           \u2554\u2563               \u2551\n\u2551             \u250c\u2500\u256c\u256c\u2500\u2510          \"\"\"          \u250c\u2500\u256c\u256c\u2500\u2510             \u2551\n\u2551          \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510       \\_/       \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510          \u2551\n\u2551       \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510           \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510       \u2551\n\u2551    \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510     \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510    \u2551\n\u2551 \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2510 \u250c\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2500\u2510 \u2551\n\u2560\u252c\u2518 \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502\u2514\u00a4\u2518\u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502 \u2514\u252c\u2563\n\u2551\u2502  \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502   \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502  \u2502\u2551\n\u2560\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2563\n\u2560\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2563\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551    ,          \u2560\u2563     ,        ,'      *    \u2560\u2563               \u2551\n\u2551~~~~~^~~~~~~~~\u250c\u256c\u256c\u2510~~~^~~~~~~~~^^~~~~~~~~^~~\u250c\u256c\u256c\u2510~~~~~~~^~~~~~~\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor\u2019s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors\u2019 name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed \u201cas-is.\u201d You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\nimport \"../abstract/Owner.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/PA1DInterface.sol\";\n\nimport \"../struct/ZoraBidShares.sol\";\n\n/**\n * @title PA1D (CXIP)\n * @author CXIP-Labs\n * @notice A smart contract for providing royalty info, collecting royalties, and distributing it to configured payout wallets.\n * @dev This smart contract is not intended to be used directly. Apply it to any of your ERC721 or ERC1155 smart contracts through a delegatecall fallback.\n */\ncontract PA1D is Admin, Owner, Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.defaultBp')) - 1)\n   */\n  bytes32 constant _defaultBpSlot = 0x3ab91e3c2ba71a57537d782545f8feb1d402b604f5e070fa6c3b911fc2f18f75;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.defaultReceiver')) - 1)\n   */\n  bytes32 constant _defaultReceiverSlot = 0xfd430e1c7265cc31dbd9a10ce657e68878a41cfe179c80cd68c5edf961516848;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.initialized')) - 1)\n   */\n  bytes32 constant _initializedPaidSlot = 0x33a44e907d5bf333e203bebc20bb8c91c00375213b80f466a908f3d50b337c6c;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.payout.addresses')) - 1)\n   */\n  bytes32 constant _payoutAddressesSlot = 0x700a541bc37f227b0d36d34e7b77cc0108bde768297c6f80f448f380387371df;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.PA1D.payout.bps')) - 1)\n   */\n  bytes32 constant _payoutBpsSlot = 0x7a62e8104cd2cc2ef6bd3a26bcb71428108fbe0e0ead6a5bfb8676781e2ed28d;\n\n  string constant _bpString = \"eip1967.Holograph.PA1D.bp\";\n  string constant _receiverString = \"eip1967.Holograph.PA1D.receiver\";\n  string constant _tokenAddressString = \"eip1967.Holograph.PA1D.tokenAddress\";\n\n  /**\n   * @notice Event emitted when setting/updating royalty info/fees. This is used by Rarible V1.\n   * @dev Emits event in order to comply with Rarible V1 royalty spec.\n   * @param tokenId Specific token id for which royalty info is being set, set as 0 for all tokens inside of the smart contract.\n   * @param recipients Address array of wallets that will receive tha royalties.\n   * @param bps Uint256 array of base points(percentages) that each wallet(specified in recipients) will receive from the royalty payouts. Make sure that all the base points add up to a total of 10000.\n   */\n  event SecondarySaleFees(uint256 tokenId, address[] recipients, uint256[] bps);\n\n  /**\n   * @dev Use this modifier to lock public functions that should not be accesible to non-owners.\n   */\n  modifier onlyOwner() override {\n    require(isOwner(), \"PA1D: caller not an owner\");\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"PA1D: already initialized\");\n    assembly {\n      sstore(_adminSlot, caller())\n      sstore(_ownerSlot, caller())\n    }\n    (address receiver, uint256 bp) = abi.decode(initPayload, (address, uint256));\n    setRoyalties(0, payable(receiver), bp);\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  function initPA1D(bytes memory initPayload) external returns (bytes4) {\n    uint256 initialized;\n    assembly {\n      initialized := sload(_initializedPaidSlot)\n    }\n    require(initialized == 0, \"PA1D: already initialized\");\n    (address receiver, uint256 bp) = abi.decode(initPayload, (address, uint256));\n    setRoyalties(0, payable(receiver), bp);\n    initialized = 1;\n    assembly {\n      sstore(_initializedPaidSlot, initialized)\n    }\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Check if message sender is a legitimate owner of the smart contract\n   * @dev We check owner, admin, and identity for a more comprehensive coverage.\n   * @return Returns true is message sender is an owner.\n   */\n  function isOwner() private view returns (bool) {\n    return (msg.sender == getOwner() ||\n      msg.sender == getAdmin() ||\n      msg.sender == Owner(address(this)).getOwner() ||\n      msg.sender == Admin(address(this)).getAdmin());\n  }\n\n  /**\n   * @dev Gets the default royalty payment receiver address from storage slot.\n   * @return receiver Wallet or smart contract that will receive the initial royalty payouts.\n   */\n  function _getDefaultReceiver() private view returns (address payable receiver) {\n    assembly {\n      receiver := sload(_defaultReceiverSlot)\n    }\n  }\n\n  /**\n   * @dev Sets the default royalty payment receiver address to storage slot.\n   * @param receiver Wallet or smart contract that will receive the initial royalty payouts.\n   */\n  function _setDefaultReceiver(address receiver) private {\n    assembly {\n      sstore(_defaultReceiverSlot, receiver)\n    }\n  }\n\n  /**\n   * @dev Gets the default royalty base points(percentage) from storage slot.\n   * @return bp Royalty base points(percentage) for royalty payouts.\n   */\n  function _getDefaultBp() private view returns (uint256 bp) {\n    assembly {\n      bp := sload(_defaultBpSlot)\n    }\n  }\n\n  /**\n   * @dev Sets the default royalty base points(percentage) to storage slot.\n   * @param bp Uint256 of royalty percentage, provided in base points format.\n   */\n  function _setDefaultBp(uint256 bp) private {\n    assembly {\n      sstore(_defaultBpSlot, bp)\n    }\n  }\n\n  /**\n   * @dev Gets the royalty payment receiver address, for a particular token id, from storage slot.\n   * @return receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n   */\n  function _getReceiver(uint256 tokenId) private view returns (address payable receiver) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_receiverString, tokenId))) - 1);\n    assembly {\n      receiver := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the royalty payment receiver address, for a particular token id, to storage slot.\n   * @param tokenId Uint256 of the token id to set the receiver for.\n   * @param receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n   */\n  function _setReceiver(uint256 tokenId, address receiver) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_receiverString, tokenId))) - 1);\n    assembly {\n      sstore(slot, receiver)\n    }\n  }\n\n  /**\n   * @dev Gets the royalty base points(percentage), for a particular token id, from storage slot.\n   * @return bp Royalty base points(percentage) for the royalty payouts of a specific token id.\n   */\n  function _getBp(uint256 tokenId) private view returns (uint256 bp) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_bpString, tokenId))) - 1);\n    assembly {\n      bp := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the royalty base points(percentage), for a particular token id, to storage slot.\n   * @param tokenId Uint256 of the token id to set the base points for.\n   * @param bp Uint256 of royalty percentage, provided in base points format, for a particular token id.\n   */\n  function _setBp(uint256 tokenId, uint256 bp) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_bpString, tokenId))) - 1);\n    assembly {\n      sstore(slot, bp)\n    }\n  }\n\n  function _getPayoutAddresses() private view returns (address payable[] memory addresses) {\n    // The slot hash has been precomputed for gas optimizaion\n    bytes32 slot = _payoutAddressesSlot;\n    uint256 length;\n    assembly {\n      length := sload(slot)\n    }\n    addresses = new address payable[](length);\n    address payable value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      assembly {\n        value := sload(slot)\n      }\n      addresses[i] = value;\n    }\n  }\n\n  function _setPayoutAddresses(address payable[] memory addresses) private {\n    bytes32 slot = _payoutAddressesSlot;\n    uint256 length = addresses.length;\n    assembly {\n      sstore(slot, length)\n    }\n    address payable value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      value = addresses[i];\n      assembly {\n        sstore(slot, value)\n      }\n    }\n  }\n\n  function _getPayoutBps() private view returns (uint256[] memory bps) {\n    bytes32 slot = _payoutBpsSlot;\n    uint256 length;\n    assembly {\n      length := sload(slot)\n    }\n    bps = new uint256[](length);\n    uint256 value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      assembly {\n        value := sload(slot)\n      }\n      bps[i] = value;\n    }\n  }\n\n  function _setPayoutBps(uint256[] memory bps) private {\n    bytes32 slot = _payoutBpsSlot;\n    uint256 length = bps.length;\n    assembly {\n      sstore(slot, length)\n    }\n    uint256 value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      value = bps[i];\n      assembly {\n        sstore(slot, value)\n      }\n    }\n  }\n\n  function _getTokenAddress(string memory tokenName) private view returns (address tokenAddress) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_tokenAddressString, tokenName))) - 1);\n    assembly {\n      tokenAddress := sload(slot)\n    }\n  }\n\n  function _setTokenAddress(string memory tokenName, address tokenAddress) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_tokenAddressString, tokenName))) - 1);\n    assembly {\n      sstore(slot, tokenAddress)\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers ETH to all payout recipients.\n   */\n  function _payoutEth() private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    // accommodating the 2300 gas stipend\n    // adding 1x for each item in array to accomodate rounding errors\n    uint256 gasCost = (23300 * length) + length;\n    uint256 balance = address(this).balance;\n    require(balance - gasCost > 10000, \"PA1D: Not enough ETH to transfer\");\n    balance = balance - gasCost;\n    uint256 sending;\n    // uint256 sent;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      addresses[i].transfer(sending);\n      // sent = sent + sending;\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers tokens to all payout recipients.\n   * @param tokenAddress Smart contract address of ERC20 token.\n   */\n  function _payoutToken(address tokenAddress) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    ERC20 erc20 = ERC20(tokenAddress);\n    uint256 balance = erc20.balanceOf(address(this));\n    require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n    uint256 sending;\n    //uint256 sent;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n      // sent = sent + sending;\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers multiple tokens to all payout recipients.\n   * @dev Try to use _payoutToken and handle each token individually.\n   * @param tokenAddresses Array of smart contract addresses of ERC20 tokens.\n   */\n  function _payoutTokens(address[] memory tokenAddresses) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    ERC20 erc20;\n    uint256 balance;\n    uint256 sending;\n    for (uint256 t = 0; t < tokenAddresses.length; t++) {\n      erc20 = ERC20(tokenAddresses[t]);\n      balance = erc20.balanceOf(address(this));\n      require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n      // uint256 sent;\n      for (uint256 i = 0; i < addresses.length; i++) {\n        sending = ((bps[i] * balance) / 10000);\n        require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n        // sent = sent + sending;\n      }\n    }\n  }\n\n  /**\n   * @dev This function validates that the call is being made by an authorised wallet.\n   * @dev Will revert entire tranaction if it fails.\n   */\n  function _validatePayoutRequestor() private view {\n    if (!isOwner()) {\n      bool matched;\n      address payable[] memory addresses = _getPayoutAddresses();\n      address payable sender = payable(msg.sender);\n      for (uint256 i = 0; i < addresses.length; i++) {\n        if (addresses[i] == sender) {\n          matched = true;\n          break;\n        }\n      }\n      require(matched, \"PA1D: sender not authorized\");\n    }\n  }\n\n  /**\n   * @notice Set the wallets and percentages for royalty payouts.\n   * @dev Function can only we called by owner, admin, or identity wallet.\n   * @dev Addresses and bps arrays must be equal length. Bps values added together must equal 10000 exactly.\n   * @param addresses An array of all the addresses that will be receiving royalty payouts.\n   * @param bps An array of the percentages that each address will receive from the royalty payouts.\n   */\n  function configurePayouts(address payable[] memory addresses, uint256[] memory bps) public onlyOwner {\n    require(addresses.length == bps.length, \"PA1D: missmatched array lenghts\");\n    uint256 totalBp;\n    for (uint256 i = 0; i < addresses.length; i++) {\n      totalBp = totalBp + bps[i];\n    }\n    require(totalBp == 10000, \"PA1D: bps down't equal 10000\");\n    _setPayoutAddresses(addresses);\n    _setPayoutBps(bps);\n  }\n\n  /**\n   * @notice Show the wallets and percentages of payout recipients.\n   * @dev These are the recipients that will be getting royalty payouts.\n   * @return addresses An array of all the addresses that will be receiving royalty payouts.\n   * @return bps An array of the percentages that each address will receive from the royalty payouts.\n   */\n  function getPayoutInfo() public view returns (address payable[] memory addresses, uint256[] memory bps) {\n    addresses = _getPayoutAddresses();\n    bps = _getPayoutBps();\n  }\n\n  /**\n   * @notice Get payout of all ETH in smart contract.\n   * @dev Distribute all the ETH(minus gas fees) to payout recipients.\n   */\n  function getEthPayout() public {\n    _validatePayoutRequestor();\n    _payoutEth();\n  }\n\n  /**\n   * @notice Get payout for a specific token address. Token must have a positive balance!\n   * @dev Contract owner, admin, identity wallet, and payout recipients can call this function.\n   * @param tokenAddress An address of the token for which to issue payouts for.\n   */\n  function getTokenPayout(address tokenAddress) public {\n    _validatePayoutRequestor();\n    _payoutToken(tokenAddress);\n  }\n\n  /**\n   * @notice Get payouts for tokens listed by address. Tokens must have a positive balance!\n   * @dev Each token balance must be equal or greater than 10000. Otherwise calculating BP is difficult.\n   * @param tokenAddresses An address array of tokens to issue payouts for.\n   */\n  function getTokensPayout(address[] memory tokenAddresses) public {\n    _validatePayoutRequestor();\n    _payoutTokens(tokenAddresses);\n  }\n\n  /**\n   * @notice Set the royalty information for entire contract, or a specific token.\n   * @dev Take great care to not make this function accessible by other public functions in your overlying smart contract.\n   * @param tokenId Set a specific token id, or leave at 0 to set as default parameters.\n   * @param receiver Wallet or smart contract that will receive the royalty payouts.\n   * @param bp Uint256 of royalty percentage, provided in base points format.\n   */\n  function setRoyalties(\n    uint256 tokenId,\n    address payable receiver,\n    uint256 bp\n  ) public onlyOwner {\n    if (tokenId == 0) {\n      _setDefaultReceiver(receiver);\n      _setDefaultBp(bp);\n    } else {\n      _setReceiver(tokenId, receiver);\n      _setBp(tokenId, bp);\n    }\n    address[] memory receivers = new address[](1);\n    receivers[0] = address(receiver);\n    uint256[] memory bps = new uint256[](1);\n    bps[0] = bp;\n    emit SecondarySaleFees(tokenId, receivers, bps);\n  }\n\n  // IEIP2981\n  function royaltyInfo(uint256 tokenId, uint256 value) public view returns (address, uint256) {\n    if (_getReceiver(tokenId) == address(0)) {\n      return (_getDefaultReceiver(), (_getDefaultBp() * value) / 10000);\n    } else {\n      return (_getReceiver(tokenId), (_getBp(tokenId) * value) / 10000);\n    }\n  }\n\n  // Rarible V1\n  function getFeeBps(uint256 tokenId) public view returns (uint256[] memory) {\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      bps[0] = _getDefaultBp();\n    } else {\n      bps[0] = _getBp(tokenId);\n    }\n    return bps;\n  }\n\n  // Rarible V1\n  function getFeeRecipients(uint256 tokenId) public view returns (address payable[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n    }\n    return receivers;\n  }\n\n  // Rarible V2(not being used since it creates a conflict with Manifold royalties)\n  // struct Part {\n  //     address payable account;\n  //     uint96 value;\n  // }\n\n  // function getRoyalties(uint256 tokenId) public view returns (Part[] memory) {\n  //     return royalties[id];\n  // }\n\n  // Manifold\n  function getRoyalties(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n      bps[0] = _getDefaultBp();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n      bps[0] = _getBp(tokenId);\n    }\n    return (receivers, bps);\n  }\n\n  // Foundation\n  function getFees(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n      bps[0] = _getDefaultBp();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n      bps[0] = _getBp(tokenId);\n    }\n    return (receivers, bps);\n  }\n\n  // SuperRare\n  // Hint taken from Manifold's RoyaltyEngine(https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/RoyaltyEngineV1.sol)\n  // To be quite honest, SuperRare is a closed marketplace. They're working on opening it up but looks like they want to use private smart contracts.\n  // We'll just leave this here for just in case they open the flood gates.\n  function tokenCreator(\n    address,\n    /* contractAddress*/\n    uint256 tokenId\n  ) public view returns (address) {\n    address receiver = _getReceiver(tokenId);\n    if (receiver == address(0)) {\n      return _getDefaultReceiver();\n    }\n    return receiver;\n  }\n\n  // SuperRare\n  function calculateRoyaltyFee(\n    address,\n    /* contractAddress */\n    uint256 tokenId,\n    uint256 amount\n  ) public view returns (uint256) {\n    if (_getReceiver(tokenId) == address(0)) {\n      return (_getDefaultBp() * amount) / 10000;\n    } else {\n      return (_getBp(tokenId) * amount) / 10000;\n    }\n  }\n\n  // Zora\n  // we indicate that this contract operates market functions\n  function marketContract() public view returns (address) {\n    return address(this);\n  }\n\n  // Zora\n  // we indicate that the receiver is the creator, to convince the smart contract to pay\n  function tokenCreators(uint256 tokenId) public view returns (address) {\n    address receiver = _getReceiver(tokenId);\n    if (receiver == address(0)) {\n      return _getDefaultReceiver();\n    }\n    return receiver;\n  }\n\n  // Zora\n  // we provide the percentage that needs to be paid out from the sale\n  function bidSharesForToken(uint256 tokenId) public view returns (ZoraBidShares memory bidShares) {\n    // this information is outside of the scope of our\n    bidShares.prevOwner.value = 0;\n    bidShares.owner.value = 0;\n    if (_getReceiver(tokenId) == address(0)) {\n      bidShares.creator.value = _getDefaultBp();\n    } else {\n      bidShares.creator.value = _getBp(tokenId);\n    }\n    return bidShares;\n  }\n\n  /**\n   * @notice Get the smart contract address of a token by common name.\n   * @dev Used only to identify really major/common tokens. Avoid using due to gas usages.\n   * @param tokenName The ticker symbol of the token. For example \"USDC\" or \"DAI\".\n   * @return The smart contract address of the token ticker symbol. Or zero address if not found.\n   */\n  function getTokenAddress(string memory tokenName) public view returns (address) {\n    return _getTokenAddress(tokenName);\n  }\n}\n\n\n",
        "CodeNames": [
            "PA1D.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PA1D.sol#L317, PA1D.sol#L340",
                "Type": "missing return value check",
                "Description": "_payoutToken[s is blocked and tokens are stuck in contract.",
                "Repair": "Use OpenZeppelin's SafeERC20, which handles the return value check as well as non-standard-compliant tokens."
            },
            {
                "Location": "PA1D.sol#L391, PA1D.sol#L395",
                "Type": "Dust left in contract",
                "Description": "_payoutEth() calculates balance with an offset, always leaving dust ETH in the contract",
                "Repair": "Transfers should be done based on address(this).balance. The gasCost is redundant as the gas amount is specified by the caller of getEthPayout(), the contract does not have to provide gas."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 HOLOGRAPH \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                                                             \u2551\n\u2551                            / ^ \\                            \u2551\n\u2551                            ~~*~~            \u00b8               \u2551\n\u2551                         [ '<>:<>' ]         \u2502\u2591\u2591\u2591            \u2551\n\u2551               \u2554\u2557           _/\"\\_           \u2554\u2563               \u2551\n\u2551             \u250c\u2500\u256c\u256c\u2500\u2510          \"\"\"          \u250c\u2500\u256c\u256c\u2500\u2510             \u2551\n\u2551          \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510       \\_/       \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510          \u2551\n\u2551       \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510           \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510       \u2551\n\u2551    \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510     \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510    \u2551\n\u2551 \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2510 \u250c\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2500\u2510 \u2551\n\u2560\u252c\u2518 \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502\u2514\u00a4\u2518\u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502 \u2514\u252c\u2563\n\u2551\u2502  \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502   \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502  \u2502\u2551\n\u2560\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2563\n\u2560\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2563\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551    ,          \u2560\u2563     ,        ,'      *    \u2560\u2563               \u2551\n\u2551~~~~~^~~~~~~~~\u250c\u256c\u256c\u2510~~~^~~~~~~~~^^~~~~~~~~^~~\u250c\u256c\u256c\u2510~~~~~~~^~~~~~~\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor\u2019s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors\u2019 name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed \u201cas-is.\u201d You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/CrossChainMessageInterface.sol\";\nimport \"./interface/HolographBridgeInterface.sol\";\nimport \"./interface/HolographERC20Interface.sol\";\nimport \"./interface/HolographInterface.sol\";\nimport \"./interface/HolographOperatorInterface.sol\";\nimport \"./interface/HolographRegistryInterface.sol\";\nimport \"./interface/InitializableInterface.sol\";\nimport \"./interface/HolographInterfacesInterface.sol\";\nimport \"./interface/Ownable.sol\";\n\nimport \"./struct/OperatorJob.sol\";\n\n/**\n * @title Holograph Operator\n * @author https://github.com/holographxyz\n * @notice Participate in the Holograph Protocol by becoming an Operator\n * @dev This contract allows operators to bond utility tokens and help execute operator jobs\n */\ncontract HolographOperator is Admin, Initializable, HolographOperatorInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.bridge')) - 1)\n   */\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.interfaces')) - 1)\n   */\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.jobNonce')) - 1)\n   */\n  bytes32 constant _jobNonceSlot = 0x1cda64803f3b43503042e00863791e8d996666552d5855a78d53ee1dd4b3286d;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.messagingModule')) - 1)\n   */\n  bytes32 constant _messagingModuleSlot = 0x54176250282e65985d205704ffce44a59efe61f7afd99e29fda50f55b48c061a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.utilityToken')) - 1)\n   */\n  bytes32 constant _utilityTokenSlot = 0xbf76518d46db472b71aa7677a0908b8016f3dee568415ffa24055f9a670f9c37;\n\n  /**\n   * @dev Internal number (in seconds), used for defining a window for operator to execute the job\n   */\n  uint256 private _blockTime;\n\n  /**\n   * @dev Minimum amount of tokens needed for bonding\n   */\n  uint256 private _baseBondAmount;\n\n  /**\n   * @dev The multiplier used for calculating bonding amount for pods\n   */\n  uint256 private _podMultiplier;\n\n  /**\n   * @dev The threshold used for limiting number of operators in a pod\n   */\n  uint256 private _operatorThreshold;\n\n  /**\n   * @dev The threshold step used for increasing bond amount once threshold is reached\n   */\n  uint256 private _operatorThresholdStep;\n\n  /**\n   * @dev The threshold divisor used for increasing bond amount once threshold is reached\n   */\n  uint256 private _operatorThresholdDivisor;\n\n  /**\n   * @dev Internal counter of all cross-chain messages received\n   */\n  uint256 private _inboundMessageCounter;\n\n  /**\n   * @dev Internal mapping of operator job details for a specific job hash\n   */\n  mapping(bytes32 => uint256) private _operatorJobs;\n\n  /**\n   * @dev Internal mapping of operator job details for a specific job hash\n   */\n  mapping(bytes32 => bool) private _failedJobs;\n\n  /**\n   * @dev Internal mapping of operator addresses, used for temp storage when defining an operator job\n   */\n  mapping(uint256 => address) private _operatorTempStorage;\n\n  /**\n   * @dev Internal index used for storing/referencing operator temp storage\n   */\n  uint32 private _operatorTempStorageCounter;\n\n  /**\n   * @dev Multi-dimensional array of available operators\n   */\n  address[][] private _operatorPods;\n\n  /**\n   * @dev Internal mapping of bonded operators, to prevent double bonding\n   */\n  mapping(address => uint256) private _bondedOperators;\n\n  /**\n   * @dev Internal mapping of bonded operators, to prevent double bonding\n   */\n  mapping(address => uint256) private _operatorPodIndex;\n\n  /**\n   * @dev Internal mapping of bonded operator amounts\n   */\n  mapping(address => uint256) private _bondedAmounts;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address bridge, address holograph, address interfaces, address registry, address utilityToken) = abi.decode(\n      initPayload,\n      (address, address, address, address, address)\n    );\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_bridgeSlot, bridge)\n      sstore(_holographSlot, holograph)\n      sstore(_interfacesSlot, interfaces)\n      sstore(_registrySlot, registry)\n      sstore(_utilityTokenSlot, utilityToken)\n    }\n    _blockTime = 60; // 60 seconds allowed for execution\n    unchecked {\n      _baseBondAmount = 100 * (10**18); // one single token unit * 100\n    }\n    // how much to increase bond amount per pod\n    _podMultiplier = 2; // 1, 4, 16, 64\n    // starting pod max amount\n    _operatorThreshold = 1000;\n    // how often to increase price per each operator\n    _operatorThresholdStep = 10;\n    // we want to multiply by decimals, but instead will have to divide\n    _operatorThresholdDivisor = 100; // == * 0.01\n    // set first operator for each pod as zero address\n    _operatorPods = [[address(0)]];\n    // mark zero address as bonded operator, to prevent abuse\n    _bondedOperators[address(0)] = 1;\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev temp function, used for quicker updates/resets during development\n   *      NOT PART OF FINAL CODE !!!\n   */\n  function resetOperator(\n    uint256 blockTime,\n    uint256 baseBondAmount,\n    uint256 podMultiplier,\n    uint256 operatorThreshold,\n    uint256 operatorThresholdStep,\n    uint256 operatorThresholdDivisor\n  ) external onlyAdmin {\n    _blockTime = blockTime;\n    _baseBondAmount = baseBondAmount;\n    _podMultiplier = podMultiplier;\n    _operatorThreshold = operatorThreshold;\n    _operatorThresholdStep = operatorThresholdStep;\n    _operatorThresholdDivisor = operatorThresholdDivisor;\n    _operatorPods = [[address(0)]];\n    _bondedOperators[address(0)] = 1;\n  }\n\n  /**\n   * @notice Execute an available operator job\n   * @dev When making this call, if operating criteria is not met, the call will revert\n   * @param bridgeInRequestPayload the entire cross chain message payload\n   */\n  function executeJob(bytes calldata bridgeInRequestPayload) external payable {\n    /**\n     * @dev derive the payload hash for use in mappings\n     */\n    bytes32 hash = keccak256(bridgeInRequestPayload);\n    /**\n     * @dev check that job exists\n     */\n    require(_operatorJobs[hash] > 0, \"HOLOGRAPH: invalid job\");\n    uint256 gasLimit = 0;\n    uint256 gasPrice = 0;\n    assembly {\n      /**\n       * @dev extract gasLimit\n       */\n      gasLimit := calldataload(sub(add(bridgeInRequestPayload.offset, bridgeInRequestPayload.length), 0x40))\n      /**\n       * @dev extract gasPrice\n       */\n      gasPrice := calldataload(sub(add(bridgeInRequestPayload.offset, bridgeInRequestPayload.length), 0x20))\n    }\n    /**\n     * @dev unpack bitwise packed operator job details\n     */\n    OperatorJob memory job = getJobDetails(hash);\n    /**\n     * @dev to prevent replay attacks, remove job from mapping\n     */\n    delete _operatorJobs[hash];\n    /**\n     * @dev check that a specific operator was selected for the job\n     */\n    if (job.operator != address(0)) {\n      /**\n       * @dev switch pod to index based value\n       */\n      uint256 pod = job.pod - 1;\n      /**\n       * @dev check if sender is not the selected primary operator\n       */\n      if (job.operator != msg.sender) {\n        /**\n         * @dev sender is not selected operator, need to check if allowed to do job\n         */\n        uint256 elapsedTime = block.timestamp - uint256(job.startTimestamp);\n        uint256 timeDifference = elapsedTime / job.blockTimes;\n        /**\n         * @dev validate that initial selected operator time slot is still active\n         */\n        require(timeDifference > 0, \"HOLOGRAPH: operator has time\");\n        /**\n         * @dev check that the selected missed the time slot due to a gas spike\n         */\n        require(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\");\n        /**\n         * @dev check if time is within fallback operator slots\n         */\n        if (timeDifference < 6) {\n          uint256 podIndex = uint256(job.fallbackOperators[timeDifference - 1]);\n          /**\n           * @dev do a quick sanity check to make sure operator did not leave from index or is a zero address\n           */\n          if (podIndex > 0 && podIndex < _operatorPods[pod].length) {\n            address fallbackOperator = _operatorPods[pod][podIndex];\n            /**\n             * @dev ensure that sender is currently valid backup operator\n             */\n            require(fallbackOperator == msg.sender, \"HOLOGRAPH: invalid fallback\");\n          }\n        }\n        /**\n         * @dev time to reward the current operator\n         */\n        uint256 amount = _getBaseBondAmount(pod);\n        /**\n         * @dev select operator that failed to do the job, is slashed the pod base fee\n         */\n        _bondedAmounts[job.operator] -= amount;\n        /**\n         * @dev the slashed amount is sent to current operator\n         */\n        _bondedAmounts[msg.sender] += amount;\n        /**\n         * @dev check if slashed operator has enough tokens bonded to stay\n         */\n        if (_bondedAmounts[job.operator] >= amount) {\n          /**\n           * @dev enough bond amount leftover, put operator back in\n           */\n          _operatorPods[pod].push(job.operator);\n          _operatorPodIndex[job.operator] = _operatorPods[pod].length - 1;\n          _bondedOperators[job.operator] = job.pod;\n        } else {\n          /**\n           * @dev slashed operator does not have enough tokens bonded, return remaining tokens only\n           */\n          uint256 leftovers = _bondedAmounts[job.operator];\n          if (leftovers > 0) {\n            _bondedAmounts[job.operator] = 0;\n            _utilityToken().transfer(job.operator, leftovers);\n          }\n        }\n      } else {\n        /**\n         * @dev the selected operator is executing the job\n         */\n        _operatorPods[pod].push(msg.sender);\n        _operatorPodIndex[job.operator] = _operatorPods[pod].length - 1;\n        _bondedOperators[msg.sender] = job.pod;\n      }\n    }\n    /**\n     * @dev ensure that there is enough has left for the job\n     */\n    require(gasleft() > gasLimit, \"HOLOGRAPH: not enough gas left\");\n    /**\n     * @dev execute the job\n     */\n    try\n      HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(\n        msg.sender,\n        bridgeInRequestPayload\n      )\n    {\n      /// @dev do nothing\n    } catch {\n      _failedJobs[hash] = true;\n      emit FailedOperatorJob(hash);\n    }\n    /**\n     * @dev every executed job (even if failed) increments total message counter by one\n     */\n    ++_inboundMessageCounter;\n    /**\n     * @dev reward operator (with HLG) for executing the job\n     * @dev this is out of scope and is purposefully omitted from code\n     */\n    ////  _bondedOperators[msg.sender] += reward;\n  }\n\n  /*\n   * @dev Purposefully made to be external so that Operator can call it during executeJob function\n   *      Check the executeJob function to understand it's implementation\n   */\n  function nonRevertingBridgeCall(address msgSender, bytes calldata payload) external payable {\n    require(msg.sender == address(this), \"HOLOGRAPH: operator only call\");\n    assembly {\n      /**\n       * @dev remove gas price from end\n       */\n      calldatacopy(0, payload.offset, sub(payload.length, 0x20))\n      /**\n       * @dev hToken recipient is injected right before making the call\n       */\n      mstore(0x84, msgSender)\n      /**\n       * @dev make non-reverting call\n       */\n      let result := call(\n        /// @dev gas limit is retrieved from last 32 bytes of payload in-memory value\n        mload(sub(payload.length, 0x40)),\n        /// @dev destination is bridge contract\n        sload(_bridgeSlot),\n        /// @dev any value is passed along\n        callvalue(),\n        /// @dev data is retrieved from 0 index memory position\n        0,\n        /// @dev everything except for last 32 bytes (gas limit) is sent\n        sub(payload.length, 0x40),\n        0,\n        0\n      )\n      if eq(result, 0) {\n        revert(0, 0)\n      }\n      return(0, 0)\n    }\n  }\n\n  /**\n   * @notice Receive a cross-chain message\n   * @dev This function is restricted for use by Holograph Messaging Module only\n   */\n  function crossChainMessage(bytes calldata bridgeInRequestPayload) external payable {\n    require(msg.sender == address(_messagingModule()), \"HOLOGRAPH: messaging only call\");\n    /**\n     * @dev would be a good idea to check payload gas price here and if it is significantly lower than current amount\n     *      to set zero address as operator to not lock-up an operator unnecessarily\n     */\n    unchecked {\n      bytes32 jobHash = keccak256(bridgeInRequestPayload);\n      /**\n       * @dev load and increment operator temp storage in one call\n       */\n      ++_operatorTempStorageCounter;\n      /**\n       * @dev use job hash, job nonce, block number, and block timestamp for generating a random number\n       */\n      uint256 random = uint256(keccak256(abi.encodePacked(jobHash, _jobNonce(), block.number, block.timestamp)));\n      /**\n       * @dev divide by total number of pods, use modulus/remainder\n       */\n      uint256 pod = random % _operatorPods.length;\n      /**\n       * @dev identify the total number of available operators in pod\n       */\n      uint256 podSize = _operatorPods[pod].length;\n      /**\n       * @dev select a primary operator\n       */\n      uint256 operatorIndex = random % podSize;\n      /**\n       * @dev If operator index is 0, then it's open season! Anyone can execute this job. First come first serve\n       *      pop operator to ensure that they cannot be selected for any other job until this one completes\n       *      decrease pod size to accomodate popped operator\n       */\n      _operatorTempStorage[_operatorTempStorageCounter] = _operatorPods[pod][operatorIndex];\n      _popOperator(pod, operatorIndex);\n      if (podSize > 1) {\n        podSize--;\n      }\n      _operatorJobs[jobHash] = uint256(\n        ((pod + 1) << 248) |\n          (uint256(_operatorTempStorageCounter) << 216) |\n          (block.number << 176) |\n          (_randomBlockHash(random, podSize, 1) << 160) |\n          (_randomBlockHash(random, podSize, 2) << 144) |\n          (_randomBlockHash(random, podSize, 3) << 128) |\n          (_randomBlockHash(random, podSize, 4) << 112) |\n          (_randomBlockHash(random, podSize, 5) << 96) |\n          (block.timestamp << 16) |\n          0\n      ); // 80 next available bit position && so far 176 bits used with only 128 left\n      /**\n       * @dev emit event to signal to operators that a job has become available\n       */\n      emit AvailableOperatorJob(jobHash, bridgeInRequestPayload);\n    }\n  }\n\n  /**\n   * @notice Calculate the amount of gas needed to execute a bridgeInRequest\n   * @dev Use this function to estimate the amount of gas that will be used by the bridgeInRequest function\n   *      Set a specific gas limit when making this call, subtract return value, to get total gas used\n   *      Only use this with a static call\n   * @param bridgeInRequestPayload abi encoded bytes making up the bridgeInRequest payload\n   * @return the gas amount remaining after the static call is returned\n   */\n  function jobEstimator(bytes calldata bridgeInRequestPayload) external payable returns (uint256) {\n    assembly {\n      calldatacopy(0, bridgeInRequestPayload.offset, sub(bridgeInRequestPayload.length, 0x40))\n      /**\n       * @dev bridgeInRequest doNotRevert is purposefully set to false so a rever would happen\n       */\n      mstore8(0xE3, 0x00)\n      let result := call(gas(), sload(_bridgeSlot), callvalue(), 0, sub(bridgeInRequestPayload.length, 0x40), 0, 0)\n      /**\n       * @dev if for some reason the call does not revert, it is force reverted\n       */\n      if eq(result, 1) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n      /**\n       * @dev remaining gas is set as the return value\n       */\n      mstore(0x00, gas())\n      return(0x00, 0x20)\n    }\n  }\n\n  /**\n   * @notice Send cross chain bridge request message\n   * @dev This function is restricted to only be callable by Holograph Bridge\n   * @param gasLimit maximum amount of gas to spend for executing the beam on destination chain\n   * @param gasPrice maximum amount of gas price (in destination chain native gas token) to pay on destination chain\n   * @param toChain Holograph Chain ID where the beam is being sent to\n   * @param nonce incremented number used to ensure job hashes are unique\n   * @param holographableContract address of the contract for which the bridge request is being made\n   * @param bridgeOutPayload bytes made up of the bridgeOutRequest payload\n   */\n  function send(\n    uint256 gasLimit,\n    uint256 gasPrice,\n    uint32 toChain,\n    address msgSender,\n    uint256 nonce,\n    address holographableContract,\n    bytes calldata bridgeOutPayload\n  ) external payable {\n    require(msg.sender == _bridge(), \"HOLOGRAPH: bridge only call\");\n    CrossChainMessageInterface messagingModule = _messagingModule();\n    uint256 hlgFee = messagingModule.getHlgFee(toChain, gasLimit, gasPrice);\n    address hToken = _registry().getHToken(_holograph().getHolographChainId());\n    require(hlgFee < msg.value, \"HOLOGRAPH: not enough value\");\n    payable(hToken).transfer(hlgFee);\n    bytes memory encodedData = abi.encodeWithSelector(\n      HolographBridgeInterface.bridgeInRequest.selector,\n      /**\n       * @dev job nonce is an incremented value that is assigned to each bridge request to guarantee unique hashes\n       */\n      nonce,\n      /**\n       * @dev including the current holograph chain id (origin chain)\n       */\n      _holograph().getHolographChainId(),\n      /**\n       * @dev holographable contract have the same address across all chains, so our destination address will be the same\n       */\n      holographableContract,\n      /**\n       * @dev get the current chain's hToken for native gas token\n       */\n      hToken,\n      /**\n       * @dev recipient will be defined when operator picks up the job\n       */\n      address(0),\n      /**\n       * @dev value is set to zero for now\n       */\n      hlgFee,\n      /**\n       * @dev specify that function call should not revert\n       */\n      true,\n      /**\n       * @dev attach actual holographableContract function call\n       */\n      bridgeOutPayload\n    );\n    /**\n     * @dev add gas variables to the back for later extraction\n     */\n    encodedData = abi.encodePacked(encodedData, gasLimit, gasPrice);\n    /**\n     * @dev Send the data to the current Holograph Messaging Module\n     *      This will be changed to dynamically select which messaging module to use based on destination network\n     */\n    messagingModule.send{value: msg.value - hlgFee}(\n      gasLimit,\n      gasPrice,\n      toChain,\n      msgSender,\n      msg.value - hlgFee,\n      encodedData\n    );\n    /**\n     * @dev for easy indexing, an event is emitted with the payload hash for status tracking\n     */\n    emit CrossChainMessageSent(keccak256(encodedData));\n  }\n\n  /**\n   * @notice Get the fees associated with sending specific payload\n   * @dev Will provide exact costs on protocol and message side, combine the two to get total\n   * @dev @param toChain holograph chain id of destination chain for payload\n   * @dev @param gasLimit amount of gas to provide for executing payload on destination chain\n   * @dev @param gasPrice maximum amount to pay for gas price, can be set to 0 and will be chose automatically\n   * @dev @param crossChainPayload the entire packet being sent cross-chain\n   * @return hlgFee the amount (in wei) of native gas token that will cost for finalizing job on destiantion chain\n   * @return msgFee the amount (in wei) of native gas token that will cost for sending message to destiantion chain\n   */\n  function getMessageFee(\n    uint32,\n    uint256,\n    uint256,\n    bytes calldata\n  ) external view returns (uint256, uint256) {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := staticcall(gas(), sload(_messagingModuleSlot), 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @notice Get the details for an available operator job\n   * @dev The job hash is a keccak256 hash of the entire job payload\n   * @param jobHash keccak256 hash of the job\n   * @return an OperatorJob struct with details about a specific job\n   */\n  function getJobDetails(bytes32 jobHash) public view returns (OperatorJob memory) {\n    uint256 packed = _operatorJobs[jobHash];\n    /**\n     * @dev The job is bitwise packed into a single 32 byte slot, this unpacks it before returning the struct\n     */\n    return\n      OperatorJob(\n        uint8(packed >> 248),\n        uint16(_blockTime),\n        _operatorTempStorage[uint32(packed >> 216)],\n        uint40(packed >> 176),\n        // TODO: move the bit-shifting around to have it be sequential\n        uint64(packed >> 16),\n        [\n          uint16(packed >> 160),\n          uint16(packed >> 144),\n          uint16(packed >> 128),\n          uint16(packed >> 112),\n          uint16(packed >> 96)\n        ]\n      );\n  }\n\n  /**\n   * @notice Get number of pods available\n   * @dev This returns number of pods that have been opened via bonding\n   */\n  function getTotalPods() external view returns (uint256 totalPods) {\n    return _operatorPods.length;\n  }\n\n  /**\n   * @notice Get total number of operators in a pod\n   * @dev Use in conjunction with paginated getPodOperators function\n   * @param pod the pod to query\n   * @return total operators in a pod\n   */\n  function getPodOperatorsLength(uint256 pod) external view returns (uint256) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    return _operatorPods[pod - 1].length;\n  }\n\n  /**\n   * @notice Get list of operators in a pod\n   * @dev Use paginated getPodOperators function instead if list gets too long\n   * @param pod the pod to query\n   * @return operators array list of operators in a pod\n   */\n  function getPodOperators(uint256 pod) external view returns (address[] memory operators) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    operators = _operatorPods[pod - 1];\n  }\n\n  /**\n   * @notice Get paginated list of operators in a pod\n   * @dev Use in conjunction with getPodOperatorsLength to know the total length of results\n   * @param pod the pod to query\n   * @param index the array index to start from\n   * @param length the length of result set to be (will be shorter if reached end of array)\n   * @return operators a paginated array of operators\n   */\n  function getPodOperators(\n    uint256 pod,\n    uint256 index,\n    uint256 length\n  ) external view returns (address[] memory operators) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    /**\n     * @dev if pod 0 is selected, this will create a revert\n     */\n    pod--;\n    /**\n     * @dev get total length of pod operators\n     */\n    uint256 supply = _operatorPods[pod].length;\n    /**\n     * @dev check if length is out of bounds for this result set\n     */\n    if (index + length > supply) {\n      /**\n       * @dev adjust length to return remainder of the results\n       */\n      length = supply - index;\n    }\n    /**\n     * @dev create in-memory array\n     */\n    operators = new address[](length);\n    /**\n     * @dev add operators to result set\n     */\n    for (uint256 i = 0; i < length; i++) {\n      operators[i] = _operatorPods[pod][index + i];\n    }\n  }\n\n  /**\n   * @notice Check the base and current price for bonding to a particular pod\n   * @dev Useful for understanding what is required for bonding to a pod\n   * @param pod the pod to get bonding amounts for\n   * @return base the base bond amount required for a pod\n   * @return current the current bond amount required for a pod\n   */\n  function getPodBondAmounts(uint256 pod) external view returns (uint256 base, uint256 current) {\n    base = _getBaseBondAmount(pod - 1);\n    current = _getCurrentBondAmount(pod - 1);\n  }\n\n  /**\n   * @notice Get an operator's currently bonded amount\n   * @dev Useful for checking how much an operator has bonded\n   * @param operator address of operator to check\n   * @return amount total number of utility token bonded\n   */\n  function getBondedAmount(address operator) external view returns (uint256 amount) {\n    return _bondedAmounts[operator];\n  }\n\n  /**\n   * @notice Get an operator's currently bonded pod\n   * @dev Useful for checking if an operator is currently bonded\n   * @param operator address of operator to check\n   * @return pod number that operator is bonded on, returns zero if not bonded or selected for job\n   */\n  function getBondedPod(address operator) external view returns (uint256 pod) {\n    return _bondedOperators[operator];\n  }\n\n  /**\n   * @notice Topup a bonded operator with more utility tokens\n   * @dev Useful function if an operator got slashed and wants to add a safety buffer to not get unbonded\n   *      This function will not work if operator has currently been selected for a job\n   * @param operator address of operator to topup\n   * @param amount utility token amount to add\n   */\n  function topupUtilityToken(address operator, uint256 amount) external {\n    /**\n     * @dev check that an operator is currently bonded\n     */\n    require(_bondedOperators[operator] != 0, \"HOLOGRAPH: operator not bonded\");\n    unchecked {\n      /**\n       * @dev add the additional amount to operator\n       */\n      _bondedAmounts[operator] += amount;\n    }\n    /**\n     * @dev transfer tokens last, to prevent reentrancy attacks\n     */\n    require(_utilityToken().transferFrom(msg.sender, address(this), amount), \"HOLOGRAPH: token transfer failed\");\n  }\n\n  /**\n   * @notice Bond utility tokens and become an operator\n   * @dev An operator can only bond to one pod at a time, per network\n   * @param operator address of operator to bond (can be an ownable smart contract)\n   * @param amount utility token amount to bond (can be greater than minimum)\n   * @param pod number of pod to bond to (can be for one that does not exist yet)\n   */\n  function bondUtilityToken(\n    address operator,\n    uint256 amount,\n    uint256 pod\n  ) external {\n    /**\n     * @dev an operator can only bond to one pod at any give time per network\n     */\n    require(_bondedOperators[operator] == 0 && _bondedAmounts[operator] == 0, \"HOLOGRAPH: operator is bonded\");\n    unchecked {\n      /**\n       * @dev get the current bonding minimum for selected pod\n       */\n      uint256 current = _getCurrentBondAmount(pod - 1);\n      require(current <= amount, \"HOLOGRAPH: bond amount too small\");\n      /**\n       * @dev check if selected pod is greater than currently existing pods\n       */\n      if (_operatorPods.length < pod) {\n        /**\n         * @dev activate pod(s) up until the selected pod\n         */\n        for (uint256 i = _operatorPods.length; i <= pod; i++) {\n          /**\n           * @dev add zero address into pod to mitigate empty pod issues\n           */\n          _operatorPods.push([address(0)]);\n        }\n      }\n      /**\n       * @dev prevent bonding to a pod with more than uint16 max value\n       */\n      require(_operatorPods[pod - 1].length < type(uint16).max, \"HOLOGRAPH: too many operators\");\n      _operatorPods[pod - 1].push(operator);\n      _operatorPodIndex[operator] = _operatorPods[pod - 1].length - 1;\n      _bondedOperators[operator] = pod;\n      _bondedAmounts[operator] = amount;\n      /**\n       * @dev transfer tokens last, to prevent reentrancy attacks\n       */\n      require(_utilityToken().transferFrom(msg.sender, address(this), amount), \"HOLOGRAPH: token transfer failed\");\n    }\n  }\n\n  /**\n   * @notice Unbond HLG utility tokens and stop being an operator\n   * @dev A bonded operator selected for a job cannot unbond until they complete the job, or are slashed\n   * @param operator address of operator to unbond\n   * @param recipient address where to send the bonded tokens\n   */\n  function unbondUtilityToken(address operator, address recipient) external {\n    /**\n     * @dev validate that operator is currently bonded\n     */\n    require(_bondedOperators[operator] != 0, \"HOLOGRAPH: operator not bonded\");\n    /**\n     * @dev check if sender is not actual operator\n     */\n    if (msg.sender != operator) {\n      /**\n       * @dev check if operator is a smart contract\n       */\n      require(_isContract(operator), \"HOLOGRAPH: operator not contract\");\n      /**\n       * @dev check if smart contract is owned by sender\n       */\n      require(Ownable(operator).isOwner(msg.sender), \"HOLOGRAPH: sender not owner\");\n    }\n    /**\n     * @dev get current bonded amount by operator\n     */\n    uint256 amount = _bondedAmounts[operator];\n    /**\n     * @dev unset operator bond amount before making a transfer\n     */\n    _bondedAmounts[operator] = 0;\n    /**\n     * @dev remove all operator references\n     */\n    _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]);\n    /**\n     * @dev transfer tokens to recipient\n     */\n    require(_utilityToken().transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\");\n  }\n\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external onlyAdmin {\n    assembly {\n      sstore(_interfacesSlot, interfaces)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Messaging Module\n   * @dev All cross-chain message requests will get forwarded to this adress\n   */\n  function getMessagingModule() external view returns (address messagingModule) {\n    assembly {\n      messagingModule := sload(_messagingModuleSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Messaging Module address\n   * @param messagingModule address of the LayerZero Endpoint to use\n   */\n  function setMessagingModule(address messagingModule) external onlyAdmin {\n    assembly {\n      sstore(_messagingModuleSlot, messagingModule)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Utility Token address\n   * @dev This is the official utility token of the Holograph Protocol\n   */\n  function getUtilityToken() external view returns (address utilityToken) {\n    assembly {\n      utilityToken := sload(_utilityTokenSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Utility Token address\n   * @param utilityToken address of the Holograph Utility Token smart contract to use\n   */\n  function setUtilityToken(address utilityToken) external onlyAdmin {\n    assembly {\n      sstore(_utilityTokenSlot, utilityToken)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Bridge Interface\n   */\n  function _bridge() private view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interface\n   */\n  function _holograph() private view returns (HolographInterface holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interfaces Interface\n   */\n  function _interfaces() private view returns (HolographInterfacesInterface interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Messaging Module Interface\n   */\n  function _messagingModule() private view returns (CrossChainMessageInterface messagingModule) {\n    assembly {\n      messagingModule := sload(_messagingModuleSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Registry Interface\n   */\n  function _registry() private view returns (HolographRegistryInterface registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Utility Token Interface\n   */\n  function _utilityToken() private view returns (HolographERC20Interface utilityToken) {\n    assembly {\n      utilityToken := sload(_utilityTokenSlot)\n    }\n  }\n\n  /**\n   * @dev Internal nonce, that increments on each call, used for randomness\n   */\n  function _jobNonce() private returns (uint256 jobNonce) {\n    assembly {\n      jobNonce := add(sload(_jobNonceSlot), 0x0000000000000000000000000000000000000000000000000000000000000001)\n      sstore(_jobNonceSlot, jobNonce)\n    }\n  }\n\n  /**\n   * @dev Internal function used to remove an operator from a particular pod\n   */\n  function _popOperator(uint256 pod, uint256 operatorIndex) private {\n    /**\n     * @dev only pop the operator if it's not a zero address\n     */\n    if (operatorIndex > 0) {\n      unchecked {\n        address operator = _operatorPods[pod][operatorIndex];\n        /**\n         * @dev mark operator as no longer bonded\n         */\n        _bondedOperators[operator] = 0;\n        /**\n         * @dev remove pod reference for operator\n         */\n        _operatorPodIndex[operator] = 0;\n        uint256 lastIndex = _operatorPods[pod].length - 1;\n        if (lastIndex != operatorIndex) {\n          /**\n           * @dev if operator is not last index, move last index to operator's current index\n           */\n          _operatorPods[pod][operatorIndex] = _operatorPods[pod][lastIndex];\n          _operatorPodIndex[_operatorPods[pod][operatorIndex]] = operatorIndex;\n        }\n        /**\n         * @dev delete last index\n         */\n        delete _operatorPods[pod][lastIndex];\n        /**\n         * @dev shorten array length\n         */\n        _operatorPods[pod].pop();\n      }\n    }\n  }\n\n  /**\n   * @dev Internal function used for calculating the base bonding amount for a pod\n   */\n  function _getBaseBondAmount(uint256 pod) private view returns (uint256) {\n    return (_podMultiplier**pod) * _baseBondAmount;\n  }\n\n  /**\n   * @dev Internal function used for calculating the current bonding amount for a pod\n   */\n  function _getCurrentBondAmount(uint256 pod) private view returns (uint256) {\n    uint256 current = (_podMultiplier**pod) * _baseBondAmount;\n    if (pod >= _operatorPods.length) {\n      return current;\n    }\n    uint256 threshold = _operatorThreshold / (2**pod);\n    uint256 position = _operatorPods[pod].length;\n    if (position > threshold) {\n      position -= threshold;\n      //       current += (current / _operatorThresholdDivisor) * position;\n      current += (current / _operatorThresholdDivisor) * (position / _operatorThresholdStep);\n    }\n    return current;\n  }\n\n  /**\n   * @dev Internal function used for generating a random pod operator selection by using previously mined blocks\n   */\n  function _randomBlockHash(\n    uint256 random,\n    uint256 podSize,\n    uint256 n\n  ) private view returns (uint256) {\n    unchecked {\n      return (random + uint256(blockhash(block.number - n))) % podSize;\n    }\n  }\n\n  /**\n   * @dev Internal function used for checking if a contract has been deployed at address\n   */\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Purposefully left empty to ensure ether transfers use least amount of gas possible\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 HOLOGRAPH \u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                                                             \u2551\n\u2551                            / ^ \\                            \u2551\n\u2551                            ~~*~~            \u00b8               \u2551\n\u2551                         [ '<>:<>' ]         \u2502\u2591\u2591\u2591            \u2551\n\u2551               \u2554\u2557           _/\"\\_           \u2554\u2563               \u2551\n\u2551             \u250c\u2500\u256c\u256c\u2500\u2510          \"\"\"          \u250c\u2500\u256c\u256c\u2500\u2510             \u2551\n\u2551          \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510       \\_/       \u250c\u2500\u252c\u2518 \u2560\u2563 \u2514\u252c\u2500\u2510          \u2551\n\u2551       \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510           \u250c\u2500\u252c\u2518 \u2502  \u2560\u2563  \u2502 \u2514\u252c\u2500\u2510       \u2551\n\u2551    \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510     \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2560\u2563  \u2502  \u2502 \u2514\u252c\u2500\u2510    \u2551\n\u2551 \u250c\u2500\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2510 \u250c\u252c\u2518 \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502 \u2514\u252c\u2500\u2510 \u2551\n\u2560\u252c\u2518 \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502\u2514\u00a4\u2518\u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502 \u2514\u252c\u2563\n\u2551\u2502  \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502   \u2502  \u2502  \u2502  \u2502  \u2560\u2563  \u2502  \u2502  \u2502  \u2502  \u2502\u2551\n\u2560\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u256c\u256c\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2563\n\u2560\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u256c\u256c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2563\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551               \u2560\u2563                           \u2560\u2563               \u2551\n\u2551    ,          \u2560\u2563     ,        ,'      *    \u2560\u2563               \u2551\n\u2551~~~~~^~~~~~~~~\u250c\u256c\u256c\u2510~~~^~~~~~~~~^^~~~~~~~~^~~\u250c\u256c\u256c\u2510~~~~~~~^~~~~~~\u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2569\u2569\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor\u2019s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors\u2019 name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed \u201cas-is.\u201d You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../enum/ChainIdType.sol\";\n\nimport \"../interface/CrossChainMessageInterface.sol\";\nimport \"../interface/HolographOperatorInterface.sol\";\nimport \"../interface/InitializableInterface.sol\";\nimport \"../interface/HolographInterfacesInterface.sol\";\nimport \"../interface/LayerZeroModuleInterface.sol\";\nimport \"../interface/LayerZeroOverrides.sol\";\n\n/**\n * @title Holograph LayerZero Module\n * @author https://github.com/holographxyz\n * @notice Holograph module for enabling LayerZero cross-chain messaging\n * @dev This contract abstracts all of the LayerZero specific logic into an isolated module\n */\ncontract LayerZeroModule is Admin, Initializable, CrossChainMessageInterface, LayerZeroModuleInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.bridge')) - 1)\n   */\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.interfaces')) - 1)\n   */\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.lZEndpoint')) - 1)\n   */\n  bytes32 constant _lZEndpointSlot = 0x56825e447adf54cdde5f04815fcf9b1dd26ef9d5c053625147c18b7c13091686;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _operatorSlot = 0x7caba557ad34138fa3b7e43fb574e0e6cc10481c3073e0dffbc560db81b5c60f;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _baseGasSlot = 0x1eaa99919d5563fbfdd75d9d906ff8de8cf52beab1ed73875294c8a0c9e9d83a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.operator')) - 1)\n   */\n  bytes32 constant _gasPerByteSlot = 0x99d8b07d37c89d4c4f4fa0fd9b7396caeb5d1d4e58b41c61c71e3cf7d424a625;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address bridge, address interfaces, address operator, uint256 baseGas, uint256 gasPerByte) = abi.decode(\n      initPayload,\n      (address, address, address, uint256, uint256)\n    );\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_bridgeSlot, bridge)\n      sstore(_interfacesSlot, interfaces)\n      sstore(_operatorSlot, operator)\n      sstore(_baseGasSlot, baseGas)\n      sstore(_gasPerByteSlot, gasPerByte)\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Receive cross-chain message from LayerZero\n   * @dev This function only allows calls from the configured LayerZero endpoint address\n   */\n  function lzReceive(\n    uint16, /* _srcChainId*/\n    bytes calldata _srcAddress,\n    uint64, /* _nonce*/\n    bytes calldata _payload\n  ) external payable {\n    assembly {\n      /**\n       * @dev check if msg.sender is LayerZero Endpoint\n       */\n      switch eq(sload(_lZEndpointSlot), caller())\n      case 0 {\n        /**\n         * @dev this is the assembly version of -> revert(\"HOLOGRAPH: LZ only endpoint\");\n         */\n        mstore(0x80, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        mstore(0xa0, 0x0000002000000000000000000000000000000000000000000000000000000000)\n        mstore(0xc0, 0x0000001b484f4c4f47524150483a204c5a206f6e6c7920656e64706f696e7400)\n        mstore(0xe0, 0x0000000000000000000000000000000000000000000000000000000000000000)\n        revert(0x80, 0xc4)\n      }\n      let ptr := mload(0x40)\n      calldatacopy(add(ptr, 0x0c), _srcAddress.offset, _srcAddress.length)\n      /**\n       * @dev check if LZ from address is same as address(this)\n       */\n      switch eq(mload(ptr), address())\n      case 0 {\n        /**\n         * @dev this is the assembly version of -> revert(\"HOLOGRAPH: unauthorized sender\");\n         */\n        mstore(0x80, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        mstore(0xa0, 0x0000002000000000000000000000000000000000000000000000000000000000)\n        mstore(0xc0, 0x0000001e484f4c4f47524150483a20756e617574686f72697a65642073656e64)\n        mstore(0xe0, 0x6572000000000000000000000000000000000000000000000000000000000000)\n        revert(0x80, 0xc4)\n      }\n    }\n    /**\n     * @dev if validation has passed, submit payload to Holograph Operator for converting into an operator job\n     */\n    _operator().crossChainMessage(_payload);\n  }\n\n  /**\n   * @dev Need to add an extra function to get LZ gas amount needed for their internal cross-chain message verification\n   */\n  function send(\n    uint256, /* gasLimit*/\n    uint256, /* gasPrice*/\n    uint32 toChain,\n    address msgSender,\n    uint256 msgValue,\n    bytes calldata crossChainPayload\n  ) external payable {\n    require(msg.sender == address(_operator()), \"HOLOGRAPH: operator only call\");\n    LayerZeroOverrides lZEndpoint;\n    assembly {\n      lZEndpoint := sload(_lZEndpointSlot)\n    }\n    // need to recalculate the gas amounts for LZ to deliver message\n    lZEndpoint.send{value: msgValue}(\n      uint16(_interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)),\n      abi.encodePacked(address(this), address(this)),\n      crossChainPayload,\n      payable(msgSender),\n      address(this),\n      abi.encodePacked(uint16(1), uint256(_baseGas() + (crossChainPayload.length * _gasPerByte())))\n    );\n  }\n\n  function getMessageFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata crossChainPayload\n  ) external view returns (uint256 hlgFee, uint256 msgFee) {\n    uint16 lzDestChain = uint16(\n      _interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)\n    );\n    LayerZeroOverrides lz;\n    assembly {\n      lz := sload(_lZEndpointSlot)\n    }\n    // convert holograph chain id to lz chain id\n    (uint128 dstPriceRatio, uint128 dstGasPriceInWei) = _getPricing(lz, lzDestChain);\n    if (gasPrice == 0) {\n      gasPrice = dstGasPriceInWei;\n    }\n    bytes memory adapterParams = abi.encodePacked(\n      uint16(1),\n      uint256(_baseGas() + (crossChainPayload.length * _gasPerByte()))\n    );\n    (uint256 nativeFee, ) = lz.estimateFees(lzDestChain, address(this), crossChainPayload, false, adapterParams);\n    return (((gasPrice * (gasLimit + (gasLimit / 10))) * dstPriceRatio) / (10**10), nativeFee);\n  }\n\n  function getHlgFee(\n    uint32 toChain,\n    uint256 gasLimit,\n    uint256 gasPrice\n  ) external view returns (uint256 hlgFee) {\n    LayerZeroOverrides lz;\n    assembly {\n      lz := sload(_lZEndpointSlot)\n    }\n    uint16 lzDestChain = uint16(\n      _interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)\n    );\n    (uint128 dstPriceRatio, uint128 dstGasPriceInWei) = _getPricing(lz, lzDestChain);\n    if (gasPrice == 0) {\n      gasPrice = dstGasPriceInWei;\n    }\n    return ((gasPrice * (gasLimit + (gasLimit / 10))) * dstPriceRatio) / (10**10);\n  }\n\n  function _getPricing(LayerZeroOverrides lz, uint16 lzDestChain)\n    private\n    view\n    returns (uint128 dstPriceRatio, uint128 dstGasPriceInWei)\n  {\n    return\n      LayerZeroOverrides(LayerZeroOverrides(lz.defaultSendLibrary()).getAppConfig(lzDestChain, address(this)).relayer)\n        .dstPriceLookup(lzDestChain);\n  }\n\n  /**\n   * @notice Get the address of the Holograph Bridge module\n   * @dev Used for beaming holographable assets cross-chain\n   */\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Bridge module address\n   * @param bridge address of the Holograph Bridge smart contract to use\n   */\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Interfaces module\n   * @dev Holograph uses this contract to store data that needs to be accessed by a large portion of the modules\n   */\n  function getInterfaces() external view returns (address interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Interfaces module address\n   * @param interfaces address of the Holograph Interfaces smart contract to use\n   */\n  function setInterfaces(address interfaces) external onlyAdmin {\n    assembly {\n      sstore(_interfacesSlot, interfaces)\n    }\n  }\n\n  /**\n   * @notice Get the address of the approved LayerZero Endpoint\n   * @dev All lzReceive function calls allow only requests from this address\n   */\n  function getLZEndpoint() external view returns (address lZEndpoint) {\n    assembly {\n      lZEndpoint := sload(_lZEndpointSlot)\n    }\n  }\n\n  /**\n   * @notice Update the approved LayerZero Endpoint address\n   * @param lZEndpoint address of the LayerZero Endpoint to use\n   */\n  function setLZEndpoint(address lZEndpoint) external onlyAdmin {\n    assembly {\n      sstore(_lZEndpointSlot, lZEndpoint)\n    }\n  }\n\n  /**\n   * @notice Get the address of the Holograph Operator module\n   * @dev All cross-chain Holograph Bridge beams are handled by the Holograph Operator module\n   */\n  function getOperator() external view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Operator module address\n   * @param operator address of the Holograph Operator smart contract to use\n   */\n  function setOperator(address operator) external onlyAdmin {\n    assembly {\n      sstore(_operatorSlot, operator)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Bridge Interface\n   */\n  function _bridge() private view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Interfaces Interface\n   */\n  function _interfaces() private view returns (HolographInterfacesInterface interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the Holograph Operator Interface\n   */\n  function _operator() private view returns (HolographOperatorInterface operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent having any type of ether transfered into the contract\n   */\n  receive() external payable {\n    revert();\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n\n  /**\n   * @notice Get the baseGas value\n   * @dev Cross-chain messages require at least this much gas\n   */\n  function getBaseGas() external view returns (uint256 baseGas) {\n    assembly {\n      baseGas := sload(_baseGasSlot)\n    }\n  }\n\n  /**\n   * @notice Update the baseGas value\n   * @param baseGas minimum gas amount that a message requires\n   */\n  function setBaseGas(uint256 baseGas) external onlyAdmin {\n    assembly {\n      sstore(_baseGasSlot, baseGas)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the baseGas value\n   */\n  function _baseGas() private view returns (uint256 baseGas) {\n    assembly {\n      baseGas := sload(_baseGasSlot)\n    }\n  }\n\n  /**\n   * @notice Get the gasPerByte value\n   * @dev Cross-chain messages require at least this much gas (per payload byte)\n   */\n  function getGasPerByte() external view returns (uint256 gasPerByte) {\n    assembly {\n      gasPerByte := sload(_gasPerByteSlot)\n    }\n  }\n\n  /**\n   * @notice Update the gasPerByte value\n   * @param gasPerByte minimum gas amount (per payload byte) that a message requires\n   */\n  function setGasPerByte(uint256 gasPerByte) external onlyAdmin {\n    assembly {\n      sstore(_gasPerByteSlot, gasPerByte)\n    }\n  }\n\n  /**\n   * @dev Internal function used for getting the gasPerByte value\n   */\n  function _gasPerByte() private view returns (uint256 gasPerByte) {\n    assembly {\n      gasPerByte := sload(_gasPerByteSlot)\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "HolographOperator.sol",
            "LayerZeroModule.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "HolographOperator.sol#L202-L340, HolographOperator.sol#L593-L596, LayerZeroModule.sol#L277-L294",
                "Type": "Low gasPrice vulnerability",
                "Description": "If user sets a low gasPrice the operator would have to choose between being locked out of the pod or executing the job anyway",
                "Repair": "Allow operator to opt out of executing the job if the gasPrice is higher than the current gas price"
            }
        ]
    }
]