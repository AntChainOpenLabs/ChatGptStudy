[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.3;\n\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { IVotingEscrow } from \"./interfaces/IVotingEscrow.sol\";\nimport { IBlocklist } from \"./interfaces/IBlocklist.sol\";\n\n/// @title  VotingEscrow\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///           (see https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n///         mStable (AGPL) - forking Curve's Vyper contract and porting to Solidity\n///           (see https://github.com/mstable/mStable-contracts/blob/master/contracts/governance/IncentivisedVotingLockup.sol)\n///         FIAT DAO (AGPL) - this version\n/// @notice Plain Curve VotingEscrow mechanics with following adjustments:\n///            1) Delegation of lock and voting power\n///            2) Quit an existing lock and pay a penalty\n///            3) Whitelisting of SmartWallets outside the VotingEscrow\n///            4) Reduced pointHistory array size and, as a result, lifetime of the contract\n///            5) Removed public deposit_for and Aragon compatibility (no use case)\ncontract VotingEscrow is IVotingEscrow, ReentrancyGuard {\n    // Shared Events\n    event Deposit(\n        address indexed provider,\n        uint256 value,\n        uint256 locktime,\n        LockAction indexed action,\n        uint256 ts\n    );\n    event Withdraw(\n        address indexed provider,\n        uint256 value,\n        LockAction indexed action,\n        uint256 ts\n    );\n    event TransferOwnership(address owner);\n    event UpdateBlocklist(address blocklist);\n    event UpdatePenaltyRecipient(address recipient);\n    event CollectPenalty(uint256 amount, address recipient);\n    event Unlock();\n\n    // Shared global state\n    IERC20 public token;\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MAXTIME = 365 days;\n    uint256 public constant MULTIPLIER = 10**18;\n    address public owner;\n    address public penaltyRecipient; // receives collected penalty payments\n    uint256 public maxPenalty = 10**18; // penalty for quitters with MAXTIME remaining lock\n    uint256 public penaltyAccumulated; // accumulated and unwithdrawn penalty payments\n    address public blocklist;\n\n    // Lock state\n    uint256 public globalEpoch;\n    Point[1000000000000000000] public pointHistory; // 1e9 * userPointHistory-length, so sufficient for 1e9 users\n    mapping(address => Point[1000000000]) public userPointHistory;\n    mapping(address => uint256) public userPointEpoch;\n    mapping(uint256 => int128) public slopeChanges;\n    mapping(address => LockedBalance) public locked;\n\n    // Voting token\n    string public name;\n    string public symbol;\n    uint256 public decimals = 18;\n\n    // Structs\n    struct Point {\n        int128 bias;\n        int128 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n    struct LockedBalance {\n        int128 amount;\n        uint256 end;\n        int128 delegated;\n        address delegatee;\n    }\n\n    // Miscellaneous\n    enum LockAction {\n        CREATE,\n        INCREASE_AMOUNT,\n        INCREASE_AMOUNT_AND_DELEGATION,\n        INCREASE_TIME,\n        WITHDRAW,\n        QUIT,\n        DELEGATE,\n        UNDELEGATE\n    }\n\n    /// @notice Initializes state\n    /// @param _owner The owner is able to update `owner`, `penaltyRecipient` and `penaltyRate`\n    /// @param _penaltyRecipient The recipient of penalty paid by lock quitters\n    /// @param _token The token locked in order to obtain voting power\n    /// @param _name The name of the voting token\n    /// @param _symbol The symbol of the voting token\n    constructor(\n        address _owner,\n        address _penaltyRecipient,\n        address _token,\n        string memory _name,\n        string memory _symbol\n    ) {\n        token = IERC20(_token);\n        pointHistory[0] = Point({\n            bias: int128(0),\n            slope: int128(0),\n            ts: block.timestamp,\n            blk: block.number\n        });\n\n        decimals = IERC20(_token).decimals();\n        require(decimals <= 18, \"Exceeds max decimals\");\n\n        name = _name;\n        symbol = _symbol;\n        owner = _owner;\n        penaltyRecipient = _penaltyRecipient;\n    }\n\n    modifier checkBlocklist() {\n        require(\n            !IBlocklist(blocklist).isBlocked(msg.sender),\n            \"Blocked contract\"\n        );\n        _;\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///       Owner Functions       ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Transfers ownership to a new owner\n    /// @param _addr The new owner\n    /// @dev Owner should always be a timelock contract\n    function transferOwnership(address _addr) external {\n        require(msg.sender == owner, \"Only owner\");\n        owner = _addr;\n        emit TransferOwnership(_addr);\n    }\n\n    /// @notice Updates the blocklist contract\n    function updateBlocklist(address _addr) external {\n        require(msg.sender == owner, \"Only owner\");\n        blocklist = _addr;\n        emit UpdateBlocklist(_addr);\n    }\n\n    /// @notice Updates the recipient of the accumulated penalty paid by quitters\n    function updatePenaltyRecipient(address _addr) external {\n        require(msg.sender == owner, \"Only owner\");\n        penaltyRecipient = _addr;\n        emit UpdatePenaltyRecipient(_addr);\n    }\n\n    /// @notice Removes quitlock penalty by setting it to zero\n    /// @dev This is an irreversible action\n    function unlock() external {\n        require(msg.sender == owner, \"Only owner\");\n        maxPenalty = 0;\n        emit Unlock();\n    }\n\n    /// @notice Forces an undelegation of virtual balance for a blocked locker\n    /// @dev Can only be called by the Blocklist contract (as part of a block)\n    /// @dev This is an irreversible action\n    function forceUndelegate(address _addr) external override {\n        require(msg.sender == blocklist, \"Only Blocklist\");\n        LockedBalance memory locked_ = locked[_addr];\n        address delegatee = locked_.delegatee;\n        int128 value = locked_.amount;\n\n        if (delegatee != _addr && value > 0) {\n            LockedBalance memory fromLocked;\n            locked_.delegatee = _addr;\n            fromLocked = locked[delegatee];\n            _delegate(delegatee, fromLocked, value, LockAction.UNDELEGATE);\n            _delegate(_addr, locked_, value, LockAction.DELEGATE);\n        }\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///       LOCK MANAGEMENT       ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Returns a user's lock expiration\n    /// @param _addr The address of the user\n    /// @return Expiration of the user's lock\n    function lockEnd(address _addr) external view returns (uint256) {\n        return locked[_addr].end;\n    }\n\n    /// @notice Returns the last available user point for a user\n    /// @param _addr User address\n    /// @return bias i.e. y\n    /// @return slope i.e. linear gradient\n    /// @return ts i.e. time point was logged\n    function getLastUserPoint(address _addr)\n        external\n        view\n        returns (\n            int128 bias,\n            int128 slope,\n            uint256 ts\n        )\n    {\n        uint256 uepoch = userPointEpoch[_addr];\n        if (uepoch == 0) {\n            return (0, 0, 0);\n        }\n        Point memory point = userPointHistory[_addr][uepoch];\n        return (point.bias, point.slope, point.ts);\n    }\n\n    /// @notice Records a checkpoint of both individual and global slope\n    /// @param _addr User address, or address(0) for only global\n    /// @param _oldLocked Old amount that user had locked, or null for global\n    /// @param _newLocked new amount that user has locked, or null for global\n    function _checkpoint(\n        address _addr,\n        LockedBalance memory _oldLocked,\n        LockedBalance memory _newLocked\n    ) internal {\n        Point memory userOldPoint;\n        Point memory userNewPoint;\n        int128 oldSlopeDelta = 0;\n        int128 newSlopeDelta = 0;\n        uint256 epoch = globalEpoch;\n\n        if (_addr != address(0)) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_oldLocked.end > block.timestamp && _oldLocked.delegated > 0) {\n                userOldPoint.slope =\n                    _oldLocked.delegated /\n                    int128(int256(MAXTIME));\n                userOldPoint.bias =\n                    userOldPoint.slope *\n                    int128(int256(_oldLocked.end - block.timestamp));\n            }\n            if (_newLocked.end > block.timestamp && _newLocked.delegated > 0) {\n                userNewPoint.slope =\n                    _newLocked.delegated /\n                    int128(int256(MAXTIME));\n                userNewPoint.bias =\n                    userNewPoint.slope *\n                    int128(int256(_newLocked.end - block.timestamp));\n            }\n\n            // Moved from bottom final if statement to resolve stack too deep err\n            // start {\n            // Now handle user history\n            uint256 uEpoch = userPointEpoch[_addr];\n            if (uEpoch == 0) {\n                userPointHistory[_addr][uEpoch + 1] = userOldPoint;\n            }\n\n            userPointEpoch[_addr] = uEpoch + 1;\n            userNewPoint.ts = block.timestamp;\n            userNewPoint.blk = block.number;\n            userPointHistory[_addr][uEpoch + 1] = userNewPoint;\n\n            // } end\n\n            // Read values of scheduled changes in the slope\n            // oldLocked.end can be in the past and in the future\n            // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldSlopeDelta = slopeChanges[_oldLocked.end];\n            if (_newLocked.end != 0) {\n                if (_newLocked.end == _oldLocked.end) {\n                    newSlopeDelta = oldSlopeDelta;\n                } else {\n                    newSlopeDelta = slopeChanges[_newLocked.end];\n                }\n            }\n        }\n\n        Point memory lastPoint =\n            Point({\n                bias: 0,\n                slope: 0,\n                ts: block.timestamp,\n                blk: block.number\n            });\n        if (epoch > 0) {\n            lastPoint = pointHistory[epoch];\n        }\n        uint256 lastCheckpoint = lastPoint.ts;\n\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory initialLastPoint =\n            Point({ bias: 0, slope: 0, ts: lastPoint.ts, blk: lastPoint.blk });\n        uint256 blockSlope = 0; // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope =\n                (MULTIPLIER * (block.number - lastPoint.blk)) /\n                (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        uint256 iterativeTime = _floorToWeek(lastCheckpoint);\n        for (uint256 i = 0; i < 255; i++) {\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            if (iterativeTime > block.timestamp) {\n                iterativeTime = block.timestamp;\n            } else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n            int128 biasDelta =\n                lastPoint.slope *\n                    int128(int256((iterativeTime - lastCheckpoint)));\n            lastPoint.bias = lastPoint.bias - biasDelta;\n            lastPoint.slope = lastPoint.slope + dSlope;\n            // This can happen\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            // This cannot happen - just in case\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            lastCheckpoint = iterativeTime;\n            lastPoint.ts = iterativeTime;\n            lastPoint.blk =\n                initialLastPoint.blk +\n                (blockSlope * (iterativeTime - initialLastPoint.ts)) /\n                MULTIPLIER;\n\n            // when epoch is incremented, we either push here or after slopes updated below\n            epoch = epoch + 1;\n            if (iterativeTime == block.timestamp) {\n                lastPoint.blk = block.number;\n                break;\n            } else {\n                pointHistory[epoch] = lastPoint;\n            }\n        }\n\n        globalEpoch = epoch;\n        // Now pointHistory is filled until t=now\n\n        if (_addr != address(0)) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            lastPoint.slope =\n                lastPoint.slope +\n                userNewPoint.slope -\n                userOldPoint.slope;\n            lastPoint.bias =\n                lastPoint.bias +\n                userNewPoint.bias -\n                userOldPoint.bias;\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n        }\n\n        // Record the changed point into history\n        pointHistory[epoch] = lastPoint;\n\n        if (_addr != address(0)) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [new_locked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (_oldLocked.end > block.timestamp) {\n                // oldSlopeDelta was <something> - userOldPoint.slope, so we cancel that\n                oldSlopeDelta = oldSlopeDelta + userOldPoint.slope;\n                if (_newLocked.end == _oldLocked.end) {\n                    oldSlopeDelta = oldSlopeDelta - userNewPoint.slope; // It was a new deposit, not extension\n                }\n                slopeChanges[_oldLocked.end] = oldSlopeDelta;\n            }\n            if (_newLocked.end > block.timestamp) {\n                if (_newLocked.end > _oldLocked.end) {\n                    newSlopeDelta = newSlopeDelta - userNewPoint.slope; // old slope disappeared at this point\n                    slopeChanges[_newLocked.end] = newSlopeDelta;\n                }\n                // else: we recorded it already in oldSlopeDelta\n            }\n        }\n    }\n\n    /// @notice Public function to trigger global checkpoint\n    function checkpoint() external {\n        LockedBalance memory empty;\n        _checkpoint(address(0), empty, empty);\n    }\n\n    // See IVotingEscrow for documentation\n    function createLock(uint256 _value, uint256 _unlockTime)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        uint256 unlock_time = _floorToWeek(_unlockTime); // Locktime is rounded down to weeks\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(_value > 0, \"Only non zero amount\");\n        require(locked_.amount == 0, \"Lock exists\");\n        require(unlock_time >= locked_.end, \"Only increase lock end\"); // from using quitLock, user should increaseAmount instead\n        require(unlock_time > block.timestamp, \"Only future lock end\");\n        require(unlock_time <= block.timestamp + MAXTIME, \"Exceeds maxtime\");\n        // Update lock and voting power (checkpoint)\n        locked_.amount += int128(int256(_value));\n        locked_.end = unlock_time;\n        locked_.delegated += int128(int256(_value));\n        locked_.delegatee = msg.sender;\n        locked[msg.sender] = locked_;\n        _checkpoint(msg.sender, LockedBalance(0, 0, 0, address(0)), locked_);\n        // Deposit locked tokens\n        require(\n            token.transferFrom(msg.sender, address(this), _value),\n            \"Transfer failed\"\n        );\n        emit Deposit(\n            msg.sender,\n            _value,\n            unlock_time,\n            LockAction.CREATE,\n            block.timestamp\n        );\n    }\n\n    // See IVotingEscrow for documentation\n    // @dev A lock is active until both lock.amount==0 and lock.end<=block.timestamp\n    function increaseAmount(uint256 _value)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(_value > 0, \"Only non zero amount\");\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        // Update lock\n        address delegatee = locked_.delegatee;\n        uint256 unlockTime = locked_.end;\n        LockAction action = LockAction.INCREASE_AMOUNT;\n        LockedBalance memory newLocked;\n        if (delegatee == msg.sender) {\n            // Undelegated lock\n            action = LockAction.INCREASE_AMOUNT_AND_DELEGATION;\n            newLocked = _copyLock(locked_);\n            newLocked.amount += int128(int256(_value));\n            newLocked.delegated += int128(int256(_value));\n            locked[msg.sender] = newLocked;\n        } else {\n            // Delegated lock, update sender's lock first\n            locked_.amount += int128(int256(_value));\n            locked[msg.sender] = locked_;\n            // Then, update delegatee's lock and voting power (checkpoint)\n            locked_ = locked[delegatee];\n            require(locked_.amount > 0, \"Delegatee has no lock\");\n            require(locked_.end > block.timestamp, \"Delegatee lock expired\");\n            newLocked = _copyLock(locked_);\n            newLocked.delegated += int128(int256(_value));\n            locked[delegatee] = newLocked;\n            emit Deposit(\n                delegatee,\n                _value,\n                newLocked.end,\n                LockAction.DELEGATE,\n                block.timestamp\n            );\n        }\n        // Checkpoint only for delegatee\n        _checkpoint(delegatee, locked_, newLocked);\n        // Deposit locked tokens\n        require(\n            token.transferFrom(msg.sender, address(this), _value),\n            \"Transfer failed\"\n        );\n        emit Deposit(msg.sender, _value, unlockTime, action, block.timestamp);\n    }\n\n    // See IVotingEscrow for documentation\n    function increaseUnlockTime(uint256 _unlockTime)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        uint256 unlock_time = _floorToWeek(_unlockTime); // Locktime is rounded down to weeks\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(unlock_time > locked_.end, \"Only increase lock end\");\n        require(unlock_time <= block.timestamp + MAXTIME, \"Exceeds maxtime\");\n        // Update lock\n        uint256 oldUnlockTime = locked_.end;\n        locked_.end = unlock_time;\n        locked[msg.sender] = locked_;\n        if (locked_.delegatee == msg.sender) {\n            // Undelegated lock\n            require(oldUnlockTime > block.timestamp, \"Lock expired\");\n            LockedBalance memory oldLocked = _copyLock(locked_);\n            oldLocked.end = unlock_time;\n            _checkpoint(msg.sender, oldLocked, locked_);\n        }\n        emit Deposit(\n            msg.sender,\n            0,\n            unlock_time,\n            LockAction.INCREASE_TIME,\n            block.timestamp\n        );\n    }\n\n    // See IVotingEscrow for documentation\n    function withdraw() external override nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end <= block.timestamp, \"Lock not expired\");\n        require(locked_.delegatee == msg.sender, \"Lock delegated\");\n        // Update lock\n        uint256 value = uint256(uint128(locked_.amount));\n        LockedBalance memory newLocked = _copyLock(locked_);\n        newLocked.amount = 0;\n        newLocked.end = 0;\n        newLocked.delegated -= int128(int256(value));\n        newLocked.delegatee = address(0);\n        locked[msg.sender] = newLocked;\n        newLocked.delegated = 0;\n        // oldLocked can have either expired <= timestamp or zero end\n        // currentLock has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, locked_, newLocked);\n        // Send back deposited tokens\n        require(token.transfer(msg.sender, value), \"Transfer failed\");\n        emit Withdraw(msg.sender, value, LockAction.WITHDRAW, block.timestamp);\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///         DELEGATION         ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // See IVotingEscrow for documentation\n    function delegate(address _addr)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(!IBlocklist(blocklist).isBlocked(_addr), \"Blocked contract\");\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.delegatee != _addr, \"Already delegated\");\n        // Update locks\n        int128 value = locked_.amount;\n        address delegatee = locked_.delegatee;\n        LockedBalance memory fromLocked;\n        LockedBalance memory toLocked;\n        locked_.delegatee = _addr;\n        if (delegatee == msg.sender) {\n            // Delegate\n            fromLocked = locked_;\n            toLocked = locked[_addr];\n        } else if (_addr == msg.sender) {\n            // Undelegate\n            fromLocked = locked[delegatee];\n            toLocked = locked_;\n        } else {\n            // Re-delegate\n            fromLocked = locked[delegatee];\n            toLocked = locked[_addr];\n            // Update owner lock if not involved in delegation\n            locked[msg.sender] = locked_;\n        }\n        require(toLocked.amount > 0, \"Delegatee has no lock\");\n        require(toLocked.end > block.timestamp, \"Delegatee lock expired\");\n        require(toLocked.end >= fromLocked.end, \"Only delegate to longer lock\");\n        _delegate(delegatee, fromLocked, value, LockAction.UNDELEGATE);\n        _delegate(_addr, toLocked, value, LockAction.DELEGATE);\n    }\n\n    // Delegates from/to lock and voting power\n    function _delegate(\n        address addr,\n        LockedBalance memory _locked,\n        int128 value,\n        LockAction action\n    ) internal {\n        LockedBalance memory newLocked = _copyLock(_locked);\n        if (action == LockAction.DELEGATE) {\n            newLocked.delegated += value;\n            emit Deposit(\n                addr,\n                uint256(int256(value)),\n                newLocked.end,\n                action,\n                block.timestamp\n            );\n        } else {\n            newLocked.delegated -= value;\n            emit Withdraw(\n                addr,\n                uint256(int256(value)),\n                action,\n                block.timestamp\n            );\n        }\n        locked[addr] = newLocked;\n        if (newLocked.amount > 0) {\n            // Only if lock (from lock) hasn't been withdrawn/quitted\n            _checkpoint(addr, _locked, newLocked);\n        }\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///         QUIT LOCK          ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // See IVotingEscrow for documentation\n    function quitLock() external override nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        require(locked_.delegatee == msg.sender, \"Lock delegated\");\n        // Update lock\n        uint256 value = uint256(uint128(locked_.amount));\n        LockedBalance memory newLocked = _copyLock(locked_);\n        newLocked.amount = 0;\n        newLocked.delegated -= int128(int256(value));\n        newLocked.delegatee = address(0);\n        locked[msg.sender] = newLocked;\n        newLocked.end = 0;\n        newLocked.delegated = 0;\n        // oldLocked can have either expired <= timestamp or zero end\n        // currentLock has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, locked_, newLocked);\n        // apply penalty\n        uint256 penaltyRate = _calculatePenaltyRate(locked_.end);\n        uint256 penaltyAmount = (value * penaltyRate) / 10**18; // quitlock_penalty is in 18 decimals precision\n        penaltyAccumulated += penaltyAmount;\n        uint256 remainingAmount = value - penaltyAmount;\n        // Send back remaining tokens\n        require(token.transfer(msg.sender, remainingAmount), \"Transfer failed\");\n        emit Withdraw(msg.sender, value, LockAction.QUIT, block.timestamp);\n    }\n\n    // Calculate penalty rate (decreasing linearly)\n    function _calculatePenaltyRate(uint256 end)\n        internal\n        view\n        returns (uint256)\n    {\n        // We know that end > block.timestamp because expired locks cannot be quitted\n        return ((end - block.timestamp) * maxPenalty) / MAXTIME;\n    }\n\n    /// @notice Collect accumulated penalty from quitters\n    /// @dev Everyone can collect but penalty is sent to `penaltyRecipient`\n    function collectPenalty() external {\n        uint256 amount = penaltyAccumulated;\n        penaltyAccumulated = 0;\n        require(token.transfer(penaltyRecipient, amount), \"Transfer failed\");\n        emit CollectPenalty(amount, penaltyRecipient);\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///            GETTERS         ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // Creates a copy of a lock\n    function _copyLock(LockedBalance memory _locked)\n        internal\n        pure\n        returns (LockedBalance memory)\n    {\n        return\n            LockedBalance({\n                amount: _locked.amount,\n                end: _locked.end,\n                delegatee: _locked.delegatee,\n                delegated: _locked.delegated\n            });\n    }\n\n    // @dev Floors a timestamp to the nearest weekly increment\n    // @param _t Timestamp to floor\n    function _floorToWeek(uint256 _t) internal pure returns (uint256) {\n        return (_t / WEEK) * WEEK;\n    }\n\n    // @dev Uses binarysearch to find the most recent point history preceeding block\n    // @param _block Find the most recent point history before this block\n    // @param _maxEpoch Do not search pointHistories past this index\n    function _findBlockEpoch(uint256 _block, uint256 _maxEpoch)\n        internal\n        view\n        returns (uint256)\n    {\n        // Binary search\n        uint256 min = 0;\n        uint256 max = _maxEpoch;\n        // Will be always enough for 128-bit numbers\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) break;\n            uint256 mid = (min + max + 1) / 2;\n            if (pointHistory[mid].blk <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // @dev Uses binarysearch to find the most recent user point history preceeding block\n    // @param _addr User for which to search\n    // @param _block Find the most recent point history before this block\n    function _findUserBlockEpoch(address _addr, uint256 _block)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 min = 0;\n        uint256 max = userPointEpoch[_addr];\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) {\n                break;\n            }\n            uint256 mid = (min + max + 1) / 2;\n            if (userPointHistory[_addr][mid].blk <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // See IVotingEscrow for documentation\n    function balanceOf(address _owner) public view override returns (uint256) {\n        uint256 epoch = userPointEpoch[_owner];\n        if (epoch == 0) {\n            return 0;\n        }\n        Point memory lastPoint = userPointHistory[_owner][epoch];\n        lastPoint.bias =\n            lastPoint.bias -\n            (lastPoint.slope * int128(int256(block.timestamp - lastPoint.ts)));\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(uint128(lastPoint.bias));\n    }\n\n    // See IVotingEscrow for documentation\n    function balanceOfAt(address _owner, uint256 _blockNumber)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(_blockNumber <= block.number, \"Only past block number\");\n\n        // Get most recent user Point to block\n        uint256 userEpoch = _findUserBlockEpoch(_owner, _blockNumber);\n        if (userEpoch == 0) {\n            return 0;\n        }\n        Point memory upoint = userPointHistory[_owner][userEpoch];\n\n        // Get most recent global Point to block\n        uint256 maxEpoch = globalEpoch;\n        uint256 epoch = _findBlockEpoch(_blockNumber, maxEpoch);\n        Point memory point0 = pointHistory[epoch];\n\n        // Calculate delta (block & time) between user Point and target block\n        // Allowing us to calculate the average seconds per block between\n        // the two points\n        uint256 dBlock = 0;\n        uint256 dTime = 0;\n        if (epoch < maxEpoch) {\n            Point memory point1 = pointHistory[epoch + 1];\n            dBlock = point1.blk - point0.blk;\n            dTime = point1.ts - point0.ts;\n        } else {\n            dBlock = block.number - point0.blk;\n            dTime = block.timestamp - point0.ts;\n        }\n        // (Deterministically) Estimate the time at which block _blockNumber was mined\n        uint256 blockTime = point0.ts;\n        if (dBlock != 0) {\n            blockTime =\n                blockTime +\n                ((dTime * (_blockNumber - point0.blk)) / dBlock);\n        }\n        // Current Bias = most recent bias - (slope * time since update)\n        upoint.bias =\n            upoint.bias -\n            (upoint.slope * int128(int256(blockTime - upoint.ts)));\n        if (upoint.bias >= 0) {\n            return uint256(uint128(upoint.bias));\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Calculate total supply of voting power at a given time _t\n    /// @param _point Most recent point before time _t\n    /// @param _t Time at which to calculate supply\n    /// @return totalSupply at given point in time\n    function _supplyAt(Point memory _point, uint256 _t)\n        internal\n        view\n        returns (uint256)\n    {\n        Point memory lastPoint = _point;\n        // Floor the timestamp to weekly interval\n        uint256 iterativeTime = _floorToWeek(lastPoint.ts);\n        // Iterate through all weeks between _point & _t to account for slope changes\n        for (uint256 i = 0; i < 255; i++) {\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            // If week end is after timestamp, then truncate & leave dSlope to 0\n            if (iterativeTime > _t) {\n                iterativeTime = _t;\n            }\n            // else get most recent slope change\n            else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n\n            lastPoint.bias =\n                lastPoint.bias -\n                (lastPoint.slope *\n                    int128(int256(iterativeTime - lastPoint.ts)));\n            if (iterativeTime == _t) {\n                break;\n            }\n            lastPoint.slope = lastPoint.slope + dSlope;\n            lastPoint.ts = iterativeTime;\n        }\n\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(uint128(lastPoint.bias));\n    }\n\n    // See IVotingEscrow for documentation\n    function totalSupply() public view override returns (uint256) {\n        uint256 epoch_ = globalEpoch;\n        Point memory lastPoint = pointHistory[epoch_];\n        return _supplyAt(lastPoint, block.timestamp);\n    }\n\n    // See IVotingEscrow for documentation\n    function totalSupplyAt(uint256 _blockNumber)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(_blockNumber <= block.number, \"Only past block number\");\n\n        uint256 epoch = globalEpoch;\n        uint256 targetEpoch = _findBlockEpoch(_blockNumber, epoch);\n\n        Point memory point = pointHistory[targetEpoch];\n\n        // If point.blk > _blockNumber that means we got the initial epoch & contract did not yet exist\n        if (point.blk > _blockNumber) {\n            return 0;\n        }\n\n        uint256 dTime = 0;\n        if (targetEpoch < epoch) {\n            Point memory pointNext = pointHistory[targetEpoch + 1];\n            if (point.blk != pointNext.blk) {\n                dTime =\n                    ((_blockNumber - point.blk) * (pointNext.ts - point.ts)) /\n                    (pointNext.blk - point.blk);\n            }\n        } else if (point.blk != block.number) {\n            dTime =\n                ((_blockNumber - point.blk) * (block.timestamp - point.ts)) /\n                (block.number - point.blk);\n        }\n        // Now dTime contains info on how far are we beyond point\n        return _supplyAt(point, point.ts + dTime);\n    }\n}\n\n\n",
        "CodeNames": [
            "VotingEscrow.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "quitLock function in VotingEscrow.sol",
                "Type": "Flashloan attack",
                "Description": "Attackers can abuse the quitLock function to get a very large amount of votes by using a flashloan and the quitLock function to achieve a large amount of votes for one transaction. It can be used to pass malicious proposals or exploit any feature that depends on the voting balance.",
                "Repair": "Implement a mechanism that prevents users from creating a lock and quitting it in the same transaction"
            },
            {
                "Location": "increaseUnlockTime function in VotingEscrow.sol",
                "Type": "Error",
                "Description": "The error in updating _checkpoint in the increaseUnlockTime function can give wrong voting power to a user at a given block, give wrong total voting power at a given block, and give wrong total voting power.",
                "Repair": "Update the code to set oldLocked.end to oldUnlockTime instead of unlock_time"
            },
            {
                "Location": "VotingEscrow.sol contract",
                "Type": "Unsafe usage of ERC20 transfer and transferFrom",
                "Description": "The unsafe usage of ERC20 transfer and transferFrom functions can cause the VotingEscrow contract to not work with tokens that don't return a boolean, such as BNB and USDT.",
                "Repair": "Replace require() statements that check for successful transfers with calls to OpenZeppelin's safeTransfer() and safeTransferFrom() functions"
            },
            {
                "Location": "VotingEscrow.sol",
                "Type": "Unsafe casting",
                "Description": "Unsafe casting from int128 can cause wrong accounting of locked amounts.",
                "Repair": "Make sure that the values fit in the variables you are trying to assign them to when casting variables to smaller types"
            },
            {
                "Location": "VotingEscrow.sol",
                "Type": "Inconsistent logic",
                "Description": "Inconsistent logic of increase unlock time to the expired locks.",
                "Repair": "Remove line VotingEscrow.sol#L511 to allow expired locks to be extended"
            },
            {
                "Location": "VotingEscrow contract",
                "Type": "Accounting",
                "Description": "The current implementation of the VotingEscrow contract doesn't support fee on transfer tokens.",
                "Repair": "Calculate the amount to add to the locked amount by the difference between the balances before and after the transfer instead of using the supplied value."
            },
            {
                "Location": "VotingEscrow contract",
                "Type": "Inflation of Voting Power",
                "Description": "Delegators can Avoid Lock Commitments if they can Reliably get Themselves Blocked when Needed.",
                "Repair": "Use the delegatee's lock endpoint in the re-delegation to self, rather than using the delegator's existing endpoint, since that endpoint may be far in the past. The delegate() and undelegate() functions have checks to ensure that the target for the votes always has at least as long a duration as the source of the votes. The fix enforces the same requirement for forceUndelegate() by assigning a longer duration."
            },
            {
                "Location": "VotingEscrow.sol line 509-515",
                "Type": "increaseUnlockTime missing _checkpoint for delegated values",
                "Description": "If a user is both a delegator and a delegatee, the original code did not create a checkpoint for calls to increaseUnlockTime(). This results in no change in voting power for the delegator, even though they have delegated funds.",
                "Repair": "Move the _checkpoint outside of the if statement on line 514"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\nimport { IVotingEscrow } from \"../interfaces/IVotingEscrow.sol\";\n\n/// @title Blocklist Checker implementation.\n/// @notice Checks if an address is blocklisted\n/// @dev This is a basic implementation using a mapping for address => bool\ncontract Blocklist {\n    mapping(address => bool) private _blocklist;\n    address public manager;\n    address public ve;\n\n    constructor(address _manager, address _ve) {\n        manager = _manager;\n        ve = _ve;\n    }\n\n    /// @notice Add address to blocklist\n    /// @dev only callable by owner.\n    /// @dev Allows blocklisting only of smart contracts\n    /// @param addr The contract address to blocklist\n    function block(address addr) external {\n        require(msg.sender == manager, \"Only manager\");\n        require(_isContract(addr), \"Only contracts\");\n        _blocklist[addr] = true;\n        IVotingEscrow(ve).forceUndelegate(addr);\n    }\n\n    /// @notice Check an address\n    /// @dev This method will be called by the VotingEscrow contract\n    /// @param addr The contract address to check\n    function isBlocked(address addr) public view returns (bool) {\n        return _blocklist[addr];\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}\n\n\n",
        "CodeNames": [
            "Blocklist.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Blocklist.sol",
                "Type": "Smart contract bypass",
                "Description": "Attacker contract can avoid being blocked by BlockList.sol by self-destructing and recreating at the same address using CREATE2.",
                "Repair": "Blacklist addresses without checking if they are contracts"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.3;\n\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { IERC20 } from \"./interfaces/IERC20.sol\";\nimport { IVotingEscrow } from \"./interfaces/IVotingEscrow.sol\";\nimport { IBlocklist } from \"./interfaces/IBlocklist.sol\";\n\n/// @title  VotingEscrow\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///           (see https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n///         mStable (AGPL) - forking Curve's Vyper contract and porting to Solidity\n///           (see https://github.com/mstable/mStable-contracts/blob/master/contracts/governance/IncentivisedVotingLockup.sol)\n///         FIAT DAO (AGPL) - this version\n/// @notice Plain Curve VotingEscrow mechanics with following adjustments:\n///            1) Delegation of lock and voting power\n///            2) Quit an existing lock and pay a penalty\n///            3) Whitelisting of SmartWallets outside the VotingEscrow\n///            4) Reduced pointHistory array size and, as a result, lifetime of the contract\n///            5) Removed public deposit_for and Aragon compatibility (no use case)\ncontract VotingEscrow is IVotingEscrow, ReentrancyGuard {\n    // Shared Events\n    event Deposit(\n        address indexed provider,\n        uint256 value,\n        uint256 locktime,\n        LockAction indexed action,\n        uint256 ts\n    );\n    event Withdraw(\n        address indexed provider,\n        uint256 value,\n        LockAction indexed action,\n        uint256 ts\n    );\n    event TransferOwnership(address owner);\n    event UpdateBlocklist(address blocklist);\n    event UpdatePenaltyRecipient(address recipient);\n    event CollectPenalty(uint256 amount, address recipient);\n    event Unlock();\n\n    // Shared global state\n    IERC20 public token;\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MAXTIME = 365 days;\n    uint256 public constant MULTIPLIER = 10**18;\n    address public owner;\n    address public penaltyRecipient; // receives collected penalty payments\n    uint256 public maxPenalty = 10**18; // penalty for quitters with MAXTIME remaining lock\n    uint256 public penaltyAccumulated; // accumulated and unwithdrawn penalty payments\n    address public blocklist;\n\n    // Lock state\n    uint256 public globalEpoch;\n    Point[1000000000000000000] public pointHistory; // 1e9 * userPointHistory-length, so sufficient for 1e9 users\n    mapping(address => Point[1000000000]) public userPointHistory;\n    mapping(address => uint256) public userPointEpoch;\n    mapping(uint256 => int128) public slopeChanges;\n    mapping(address => LockedBalance) public locked;\n\n    // Voting token\n    string public name;\n    string public symbol;\n    uint256 public decimals = 18;\n\n    // Structs\n    struct Point {\n        int128 bias;\n        int128 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n    struct LockedBalance {\n        int128 amount;\n        uint256 end;\n        int128 delegated;\n        address delegatee;\n    }\n\n    // Miscellaneous\n    enum LockAction {\n        CREATE,\n        INCREASE_AMOUNT,\n        INCREASE_AMOUNT_AND_DELEGATION,\n        INCREASE_TIME,\n        WITHDRAW,\n        QUIT,\n        DELEGATE,\n        UNDELEGATE\n    }\n\n    /// @notice Initializes state\n    /// @param _owner The owner is able to update `owner`, `penaltyRecipient` and `penaltyRate`\n    /// @param _penaltyRecipient The recipient of penalty paid by lock quitters\n    /// @param _token The token locked in order to obtain voting power\n    /// @param _name The name of the voting token\n    /// @param _symbol The symbol of the voting token\n    constructor(\n        address _owner,\n        address _penaltyRecipient,\n        address _token,\n        string memory _name,\n        string memory _symbol\n    ) {\n        token = IERC20(_token);\n        pointHistory[0] = Point({\n            bias: int128(0),\n            slope: int128(0),\n            ts: block.timestamp,\n            blk: block.number\n        });\n\n        decimals = IERC20(_token).decimals();\n        require(decimals <= 18, \"Exceeds max decimals\");\n\n        name = _name;\n        symbol = _symbol;\n        owner = _owner;\n        penaltyRecipient = _penaltyRecipient;\n    }\n\n    modifier checkBlocklist() {\n        require(\n            !IBlocklist(blocklist).isBlocked(msg.sender),\n            \"Blocked contract\"\n        );\n        _;\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///       Owner Functions       ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Transfers ownership to a new owner\n    /// @param _addr The new owner\n    /// @dev Owner should always be a timelock contract\n    function transferOwnership(address _addr) external {\n        require(msg.sender == owner, \"Only owner\");\n        owner = _addr;\n        emit TransferOwnership(_addr);\n    }\n\n    /// @notice Updates the blocklist contract\n    function updateBlocklist(address _addr) external {\n        require(msg.sender == owner, \"Only owner\");\n        blocklist = _addr;\n        emit UpdateBlocklist(_addr);\n    }\n\n    /// @notice Updates the recipient of the accumulated penalty paid by quitters\n    function updatePenaltyRecipient(address _addr) external {\n        require(msg.sender == owner, \"Only owner\");\n        penaltyRecipient = _addr;\n        emit UpdatePenaltyRecipient(_addr);\n    }\n\n    /// @notice Removes quitlock penalty by setting it to zero\n    /// @dev This is an irreversible action\n    function unlock() external {\n        require(msg.sender == owner, \"Only owner\");\n        maxPenalty = 0;\n        emit Unlock();\n    }\n\n    /// @notice Forces an undelegation of virtual balance for a blocked locker\n    /// @dev Can only be called by the Blocklist contract (as part of a block)\n    /// @dev This is an irreversible action\n    function forceUndelegate(address _addr) external override {\n        require(msg.sender == blocklist, \"Only Blocklist\");\n        LockedBalance memory locked_ = locked[_addr];\n        address delegatee = locked_.delegatee;\n        int128 value = locked_.amount;\n\n        if (delegatee != _addr && value > 0) {\n            LockedBalance memory fromLocked;\n            locked_.delegatee = _addr;\n            fromLocked = locked[delegatee];\n            _delegate(delegatee, fromLocked, value, LockAction.UNDELEGATE);\n            _delegate(_addr, locked_, value, LockAction.DELEGATE);\n        }\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///       LOCK MANAGEMENT       ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    /// @notice Returns a user's lock expiration\n    /// @param _addr The address of the user\n    /// @return Expiration of the user's lock\n    function lockEnd(address _addr) external view returns (uint256) {\n        return locked[_addr].end;\n    }\n\n    /// @notice Returns the last available user point for a user\n    /// @param _addr User address\n    /// @return bias i.e. y\n    /// @return slope i.e. linear gradient\n    /// @return ts i.e. time point was logged\n    function getLastUserPoint(address _addr)\n        external\n        view\n        returns (\n            int128 bias,\n            int128 slope,\n            uint256 ts\n        )\n    {\n        uint256 uepoch = userPointEpoch[_addr];\n        if (uepoch == 0) {\n            return (0, 0, 0);\n        }\n        Point memory point = userPointHistory[_addr][uepoch];\n        return (point.bias, point.slope, point.ts);\n    }\n\n    /// @notice Records a checkpoint of both individual and global slope\n    /// @param _addr User address, or address(0) for only global\n    /// @param _oldLocked Old amount that user had locked, or null for global\n    /// @param _newLocked new amount that user has locked, or null for global\n    function _checkpoint(\n        address _addr,\n        LockedBalance memory _oldLocked,\n        LockedBalance memory _newLocked\n    ) internal {\n        Point memory userOldPoint;\n        Point memory userNewPoint;\n        int128 oldSlopeDelta = 0;\n        int128 newSlopeDelta = 0;\n        uint256 epoch = globalEpoch;\n\n        if (_addr != address(0)) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_oldLocked.end > block.timestamp && _oldLocked.delegated > 0) {\n                userOldPoint.slope =\n                    _oldLocked.delegated /\n                    int128(int256(MAXTIME));\n                userOldPoint.bias =\n                    userOldPoint.slope *\n                    int128(int256(_oldLocked.end - block.timestamp));\n            }\n            if (_newLocked.end > block.timestamp && _newLocked.delegated > 0) {\n                userNewPoint.slope =\n                    _newLocked.delegated /\n                    int128(int256(MAXTIME));\n                userNewPoint.bias =\n                    userNewPoint.slope *\n                    int128(int256(_newLocked.end - block.timestamp));\n            }\n\n            // Moved from bottom final if statement to resolve stack too deep err\n            // start {\n            // Now handle user history\n            uint256 uEpoch = userPointEpoch[_addr];\n            if (uEpoch == 0) {\n                userPointHistory[_addr][uEpoch + 1] = userOldPoint;\n            }\n\n            userPointEpoch[_addr] = uEpoch + 1;\n            userNewPoint.ts = block.timestamp;\n            userNewPoint.blk = block.number;\n            userPointHistory[_addr][uEpoch + 1] = userNewPoint;\n\n            // } end\n\n            // Read values of scheduled changes in the slope\n            // oldLocked.end can be in the past and in the future\n            // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            oldSlopeDelta = slopeChanges[_oldLocked.end];\n            if (_newLocked.end != 0) {\n                if (_newLocked.end == _oldLocked.end) {\n                    newSlopeDelta = oldSlopeDelta;\n                } else {\n                    newSlopeDelta = slopeChanges[_newLocked.end];\n                }\n            }\n        }\n\n        Point memory lastPoint =\n            Point({\n                bias: 0,\n                slope: 0,\n                ts: block.timestamp,\n                blk: block.number\n            });\n        if (epoch > 0) {\n            lastPoint = pointHistory[epoch];\n        }\n        uint256 lastCheckpoint = lastPoint.ts;\n\n        // initialLastPoint is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        Point memory initialLastPoint =\n            Point({ bias: 0, slope: 0, ts: lastPoint.ts, blk: lastPoint.blk });\n        uint256 blockSlope = 0; // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            blockSlope =\n                (MULTIPLIER * (block.number - lastPoint.blk)) /\n                (block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        uint256 iterativeTime = _floorToWeek(lastCheckpoint);\n        for (uint256 i = 0; i < 255; i++) {\n            // Hopefully it won't happen that this won't get used in 5 years!\n            // If it does, users will be able to withdraw but vote weight will be broken\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            if (iterativeTime > block.timestamp) {\n                iterativeTime = block.timestamp;\n            } else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n            int128 biasDelta =\n                lastPoint.slope *\n                    int128(int256((iterativeTime - lastCheckpoint)));\n            lastPoint.bias = lastPoint.bias - biasDelta;\n            lastPoint.slope = lastPoint.slope + dSlope;\n            // This can happen\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n            // This cannot happen - just in case\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            lastCheckpoint = iterativeTime;\n            lastPoint.ts = iterativeTime;\n            lastPoint.blk =\n                initialLastPoint.blk +\n                (blockSlope * (iterativeTime - initialLastPoint.ts)) /\n                MULTIPLIER;\n\n            // when epoch is incremented, we either push here or after slopes updated below\n            epoch = epoch + 1;\n            if (iterativeTime == block.timestamp) {\n                lastPoint.blk = block.number;\n                break;\n            } else {\n                pointHistory[epoch] = lastPoint;\n            }\n        }\n\n        globalEpoch = epoch;\n        // Now pointHistory is filled until t=now\n\n        if (_addr != address(0)) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            lastPoint.slope =\n                lastPoint.slope +\n                userNewPoint.slope -\n                userOldPoint.slope;\n            lastPoint.bias =\n                lastPoint.bias +\n                userNewPoint.bias -\n                userOldPoint.bias;\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n        }\n\n        // Record the changed point into history\n        pointHistory[epoch] = lastPoint;\n\n        if (_addr != address(0)) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [new_locked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (_oldLocked.end > block.timestamp) {\n                // oldSlopeDelta was <something> - userOldPoint.slope, so we cancel that\n                oldSlopeDelta = oldSlopeDelta + userOldPoint.slope;\n                if (_newLocked.end == _oldLocked.end) {\n                    oldSlopeDelta = oldSlopeDelta - userNewPoint.slope; // It was a new deposit, not extension\n                }\n                slopeChanges[_oldLocked.end] = oldSlopeDelta;\n            }\n            if (_newLocked.end > block.timestamp) {\n                if (_newLocked.end > _oldLocked.end) {\n                    newSlopeDelta = newSlopeDelta - userNewPoint.slope; // old slope disappeared at this point\n                    slopeChanges[_newLocked.end] = newSlopeDelta;\n                }\n                // else: we recorded it already in oldSlopeDelta\n            }\n        }\n    }\n\n    /// @notice Public function to trigger global checkpoint\n    function checkpoint() external {\n        LockedBalance memory empty;\n        _checkpoint(address(0), empty, empty);\n    }\n\n    // See IVotingEscrow for documentation\n    function createLock(uint256 _value, uint256 _unlockTime)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        uint256 unlock_time = _floorToWeek(_unlockTime); // Locktime is rounded down to weeks\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(_value > 0, \"Only non zero amount\");\n        require(locked_.amount == 0, \"Lock exists\");\n        require(unlock_time >= locked_.end, \"Only increase lock end\"); // from using quitLock, user should increaseAmount instead\n        require(unlock_time > block.timestamp, \"Only future lock end\");\n        require(unlock_time <= block.timestamp + MAXTIME, \"Exceeds maxtime\");\n        // Update lock and voting power (checkpoint)\n        locked_.amount += int128(int256(_value));\n        locked_.end = unlock_time;\n        locked_.delegated += int128(int256(_value));\n        locked_.delegatee = msg.sender;\n        locked[msg.sender] = locked_;\n        _checkpoint(msg.sender, LockedBalance(0, 0, 0, address(0)), locked_);\n        // Deposit locked tokens\n        require(\n            token.transferFrom(msg.sender, address(this), _value),\n            \"Transfer failed\"\n        );\n        emit Deposit(\n            msg.sender,\n            _value,\n            unlock_time,\n            LockAction.CREATE,\n            block.timestamp\n        );\n    }\n\n    // See IVotingEscrow for documentation\n    // @dev A lock is active until both lock.amount==0 and lock.end<=block.timestamp\n    function increaseAmount(uint256 _value)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(_value > 0, \"Only non zero amount\");\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        // Update lock\n        address delegatee = locked_.delegatee;\n        uint256 unlockTime = locked_.end;\n        LockAction action = LockAction.INCREASE_AMOUNT;\n        LockedBalance memory newLocked;\n        if (delegatee == msg.sender) {\n            // Undelegated lock\n            action = LockAction.INCREASE_AMOUNT_AND_DELEGATION;\n            newLocked = _copyLock(locked_);\n            newLocked.amount += int128(int256(_value));\n            newLocked.delegated += int128(int256(_value));\n            locked[msg.sender] = newLocked;\n        } else {\n            // Delegated lock, update sender's lock first\n            locked_.amount += int128(int256(_value));\n            locked[msg.sender] = locked_;\n            // Then, update delegatee's lock and voting power (checkpoint)\n            locked_ = locked[delegatee];\n            require(locked_.amount > 0, \"Delegatee has no lock\");\n            require(locked_.end > block.timestamp, \"Delegatee lock expired\");\n            newLocked = _copyLock(locked_);\n            newLocked.delegated += int128(int256(_value));\n            locked[delegatee] = newLocked;\n            emit Deposit(\n                delegatee,\n                _value,\n                newLocked.end,\n                LockAction.DELEGATE,\n                block.timestamp\n            );\n        }\n        // Checkpoint only for delegatee\n        _checkpoint(delegatee, locked_, newLocked);\n        // Deposit locked tokens\n        require(\n            token.transferFrom(msg.sender, address(this), _value),\n            \"Transfer failed\"\n        );\n        emit Deposit(msg.sender, _value, unlockTime, action, block.timestamp);\n    }\n\n    // See IVotingEscrow for documentation\n    function increaseUnlockTime(uint256 _unlockTime)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        uint256 unlock_time = _floorToWeek(_unlockTime); // Locktime is rounded down to weeks\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(unlock_time > locked_.end, \"Only increase lock end\");\n        require(unlock_time <= block.timestamp + MAXTIME, \"Exceeds maxtime\");\n        // Update lock\n        uint256 oldUnlockTime = locked_.end;\n        locked_.end = unlock_time;\n        locked[msg.sender] = locked_;\n        if (locked_.delegatee == msg.sender) {\n            // Undelegated lock\n            require(oldUnlockTime > block.timestamp, \"Lock expired\");\n            LockedBalance memory oldLocked = _copyLock(locked_);\n            oldLocked.end = unlock_time;\n            _checkpoint(msg.sender, oldLocked, locked_);\n        }\n        emit Deposit(\n            msg.sender,\n            0,\n            unlock_time,\n            LockAction.INCREASE_TIME,\n            block.timestamp\n        );\n    }\n\n    // See IVotingEscrow for documentation\n    function withdraw() external override nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end <= block.timestamp, \"Lock not expired\");\n        require(locked_.delegatee == msg.sender, \"Lock delegated\");\n        // Update lock\n        uint256 value = uint256(uint128(locked_.amount));\n        LockedBalance memory newLocked = _copyLock(locked_);\n        newLocked.amount = 0;\n        newLocked.end = 0;\n        newLocked.delegated -= int128(int256(value));\n        newLocked.delegatee = address(0);\n        locked[msg.sender] = newLocked;\n        newLocked.delegated = 0;\n        // oldLocked can have either expired <= timestamp or zero end\n        // currentLock has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, locked_, newLocked);\n        // Send back deposited tokens\n        require(token.transfer(msg.sender, value), \"Transfer failed\");\n        emit Withdraw(msg.sender, value, LockAction.WITHDRAW, block.timestamp);\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///         DELEGATION         ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // See IVotingEscrow for documentation\n    function delegate(address _addr)\n        external\n        override\n        nonReentrant\n        checkBlocklist\n    {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(!IBlocklist(blocklist).isBlocked(_addr), \"Blocked contract\");\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.delegatee != _addr, \"Already delegated\");\n        // Update locks\n        int128 value = locked_.amount;\n        address delegatee = locked_.delegatee;\n        LockedBalance memory fromLocked;\n        LockedBalance memory toLocked;\n        locked_.delegatee = _addr;\n        if (delegatee == msg.sender) {\n            // Delegate\n            fromLocked = locked_;\n            toLocked = locked[_addr];\n        } else if (_addr == msg.sender) {\n            // Undelegate\n            fromLocked = locked[delegatee];\n            toLocked = locked_;\n        } else {\n            // Re-delegate\n            fromLocked = locked[delegatee];\n            toLocked = locked[_addr];\n            // Update owner lock if not involved in delegation\n            locked[msg.sender] = locked_;\n        }\n        require(toLocked.amount > 0, \"Delegatee has no lock\");\n        require(toLocked.end > block.timestamp, \"Delegatee lock expired\");\n        require(toLocked.end >= fromLocked.end, \"Only delegate to longer lock\");\n        _delegate(delegatee, fromLocked, value, LockAction.UNDELEGATE);\n        _delegate(_addr, toLocked, value, LockAction.DELEGATE);\n    }\n\n    // Delegates from/to lock and voting power\n    function _delegate(\n        address addr,\n        LockedBalance memory _locked,\n        int128 value,\n        LockAction action\n    ) internal {\n        LockedBalance memory newLocked = _copyLock(_locked);\n        if (action == LockAction.DELEGATE) {\n            newLocked.delegated += value;\n            emit Deposit(\n                addr,\n                uint256(int256(value)),\n                newLocked.end,\n                action,\n                block.timestamp\n            );\n        } else {\n            newLocked.delegated -= value;\n            emit Withdraw(\n                addr,\n                uint256(int256(value)),\n                action,\n                block.timestamp\n            );\n        }\n        locked[addr] = newLocked;\n        if (newLocked.amount > 0) {\n            // Only if lock (from lock) hasn't been withdrawn/quitted\n            _checkpoint(addr, _locked, newLocked);\n        }\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///         QUIT LOCK          ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // See IVotingEscrow for documentation\n    function quitLock() external override nonReentrant {\n        LockedBalance memory locked_ = locked[msg.sender];\n        // Validate inputs\n        require(locked_.amount > 0, \"No lock\");\n        require(locked_.end > block.timestamp, \"Lock expired\");\n        require(locked_.delegatee == msg.sender, \"Lock delegated\");\n        // Update lock\n        uint256 value = uint256(uint128(locked_.amount));\n        LockedBalance memory newLocked = _copyLock(locked_);\n        newLocked.amount = 0;\n        newLocked.delegated -= int128(int256(value));\n        newLocked.delegatee = address(0);\n        locked[msg.sender] = newLocked;\n        newLocked.end = 0;\n        newLocked.delegated = 0;\n        // oldLocked can have either expired <= timestamp or zero end\n        // currentLock has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, locked_, newLocked);\n        // apply penalty\n        uint256 penaltyRate = _calculatePenaltyRate(locked_.end);\n        uint256 penaltyAmount = (value * penaltyRate) / 10**18; // quitlock_penalty is in 18 decimals precision\n        penaltyAccumulated += penaltyAmount;\n        uint256 remainingAmount = value - penaltyAmount;\n        // Send back remaining tokens\n        require(token.transfer(msg.sender, remainingAmount), \"Transfer failed\");\n        emit Withdraw(msg.sender, value, LockAction.QUIT, block.timestamp);\n    }\n\n    // Calculate penalty rate (decreasing linearly)\n    function _calculatePenaltyRate(uint256 end)\n        internal\n        view\n        returns (uint256)\n    {\n        // We know that end > block.timestamp because expired locks cannot be quitted\n        return ((end - block.timestamp) * maxPenalty) / MAXTIME;\n    }\n\n    /// @notice Collect accumulated penalty from quitters\n    /// @dev Everyone can collect but penalty is sent to `penaltyRecipient`\n    function collectPenalty() external {\n        uint256 amount = penaltyAccumulated;\n        penaltyAccumulated = 0;\n        require(token.transfer(penaltyRecipient, amount), \"Transfer failed\");\n        emit CollectPenalty(amount, penaltyRecipient);\n    }\n\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n    ///            GETTERS         ///\n    /// ~~~~~~~~~~~~~~~~~~~~~~~~~~ ///\n\n    // Creates a copy of a lock\n    function _copyLock(LockedBalance memory _locked)\n        internal\n        pure\n        returns (LockedBalance memory)\n    {\n        return\n            LockedBalance({\n                amount: _locked.amount,\n                end: _locked.end,\n                delegatee: _locked.delegatee,\n                delegated: _locked.delegated\n            });\n    }\n\n    // @dev Floors a timestamp to the nearest weekly increment\n    // @param _t Timestamp to floor\n    function _floorToWeek(uint256 _t) internal pure returns (uint256) {\n        return (_t / WEEK) * WEEK;\n    }\n\n    // @dev Uses binarysearch to find the most recent point history preceeding block\n    // @param _block Find the most recent point history before this block\n    // @param _maxEpoch Do not search pointHistories past this index\n    function _findBlockEpoch(uint256 _block, uint256 _maxEpoch)\n        internal\n        view\n        returns (uint256)\n    {\n        // Binary search\n        uint256 min = 0;\n        uint256 max = _maxEpoch;\n        // Will be always enough for 128-bit numbers\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) break;\n            uint256 mid = (min + max + 1) / 2;\n            if (pointHistory[mid].blk <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // @dev Uses binarysearch to find the most recent user point history preceeding block\n    // @param _addr User for which to search\n    // @param _block Find the most recent point history before this block\n    function _findUserBlockEpoch(address _addr, uint256 _block)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 min = 0;\n        uint256 max = userPointEpoch[_addr];\n        for (uint256 i = 0; i < 128; i++) {\n            if (min >= max) {\n                break;\n            }\n            uint256 mid = (min + max + 1) / 2;\n            if (userPointHistory[_addr][mid].blk <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return min;\n    }\n\n    // See IVotingEscrow for documentation\n    function balanceOf(address _owner) public view override returns (uint256) {\n        uint256 epoch = userPointEpoch[_owner];\n        if (epoch == 0) {\n            return 0;\n        }\n        Point memory lastPoint = userPointHistory[_owner][epoch];\n        lastPoint.bias =\n            lastPoint.bias -\n            (lastPoint.slope * int128(int256(block.timestamp - lastPoint.ts)));\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(uint128(lastPoint.bias));\n    }\n\n    // See IVotingEscrow for documentation\n    function balanceOfAt(address _owner, uint256 _blockNumber)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(_blockNumber <= block.number, \"Only past block number\");\n\n        // Get most recent user Point to block\n        uint256 userEpoch = _findUserBlockEpoch(_owner, _blockNumber);\n        if (userEpoch == 0) {\n            return 0;\n        }\n        Point memory upoint = userPointHistory[_owner][userEpoch];\n\n        // Get most recent global Point to block\n        uint256 maxEpoch = globalEpoch;\n        uint256 epoch = _findBlockEpoch(_blockNumber, maxEpoch);\n        Point memory point0 = pointHistory[epoch];\n\n        // Calculate delta (block & time) between user Point and target block\n        // Allowing us to calculate the average seconds per block between\n        // the two points\n        uint256 dBlock = 0;\n        uint256 dTime = 0;\n        if (epoch < maxEpoch) {\n            Point memory point1 = pointHistory[epoch + 1];\n            dBlock = point1.blk - point0.blk;\n            dTime = point1.ts - point0.ts;\n        } else {\n            dBlock = block.number - point0.blk;\n            dTime = block.timestamp - point0.ts;\n        }\n        // (Deterministically) Estimate the time at which block _blockNumber was mined\n        uint256 blockTime = point0.ts;\n        if (dBlock != 0) {\n            blockTime =\n                blockTime +\n                ((dTime * (_blockNumber - point0.blk)) / dBlock);\n        }\n        // Current Bias = most recent bias - (slope * time since update)\n        upoint.bias =\n            upoint.bias -\n            (upoint.slope * int128(int256(blockTime - upoint.ts)));\n        if (upoint.bias >= 0) {\n            return uint256(uint128(upoint.bias));\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Calculate total supply of voting power at a given time _t\n    /// @param _point Most recent point before time _t\n    /// @param _t Time at which to calculate supply\n    /// @return totalSupply at given point in time\n    function _supplyAt(Point memory _point, uint256 _t)\n        internal\n        view\n        returns (uint256)\n    {\n        Point memory lastPoint = _point;\n        // Floor the timestamp to weekly interval\n        uint256 iterativeTime = _floorToWeek(lastPoint.ts);\n        // Iterate through all weeks between _point & _t to account for slope changes\n        for (uint256 i = 0; i < 255; i++) {\n            iterativeTime = iterativeTime + WEEK;\n            int128 dSlope = 0;\n            // If week end is after timestamp, then truncate & leave dSlope to 0\n            if (iterativeTime > _t) {\n                iterativeTime = _t;\n            }\n            // else get most recent slope change\n            else {\n                dSlope = slopeChanges[iterativeTime];\n            }\n\n            lastPoint.bias =\n                lastPoint.bias -\n                (lastPoint.slope *\n                    int128(int256(iterativeTime - lastPoint.ts)));\n            if (iterativeTime == _t) {\n                break;\n            }\n            lastPoint.slope = lastPoint.slope + dSlope;\n            lastPoint.ts = iterativeTime;\n        }\n\n        if (lastPoint.bias < 0) {\n            lastPoint.bias = 0;\n        }\n        return uint256(uint128(lastPoint.bias));\n    }\n\n    // See IVotingEscrow for documentation\n    function totalSupply() public view override returns (uint256) {\n        uint256 epoch_ = globalEpoch;\n        Point memory lastPoint = pointHistory[epoch_];\n        return _supplyAt(lastPoint, block.timestamp);\n    }\n\n    // See IVotingEscrow for documentation\n    function totalSupplyAt(uint256 _blockNumber)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(_blockNumber <= block.number, \"Only past block number\");\n\n        uint256 epoch = globalEpoch;\n        uint256 targetEpoch = _findBlockEpoch(_blockNumber, epoch);\n\n        Point memory point = pointHistory[targetEpoch];\n\n        // If point.blk > _blockNumber that means we got the initial epoch & contract did not yet exist\n        if (point.blk > _blockNumber) {\n            return 0;\n        }\n\n        uint256 dTime = 0;\n        if (targetEpoch < epoch) {\n            Point memory pointNext = pointHistory[targetEpoch + 1];\n            if (point.blk != pointNext.blk) {\n                dTime =\n                    ((_blockNumber - point.blk) * (pointNext.ts - point.ts)) /\n                    (pointNext.blk - point.blk);\n            }\n        } else if (point.blk != block.number) {\n            dTime =\n                ((_blockNumber - point.blk) * (block.timestamp - point.ts)) /\n                (block.number - point.blk);\n        }\n        // Now dTime contains info on how far are we beyond point\n        return _supplyAt(point, point.ts + dTime);\n    }\n}\n\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.3;\n\nimport { IVotingEscrow } from \"../interfaces/IVotingEscrow.sol\";\n\n/// @title Blocklist Checker implementation.\n/// @notice Checks if an address is blocklisted\n/// @dev This is a basic implementation using a mapping for address => bool\ncontract Blocklist {\n    mapping(address => bool) private _blocklist;\n    address public manager;\n    address public ve;\n\n    constructor(address _manager, address _ve) {\n        manager = _manager;\n        ve = _ve;\n    }\n\n    /// @notice Add address to blocklist\n    /// @dev only callable by owner.\n    /// @dev Allows blocklisting only of smart contracts\n    /// @param addr The contract address to blocklist\n    function block(address addr) external {\n        require(msg.sender == manager, \"Only manager\");\n        require(_isContract(addr), \"Only contracts\");\n        _blocklist[addr] = true;\n        IVotingEscrow(ve).forceUndelegate(addr);\n    }\n\n    /// @notice Check an address\n    /// @dev This method will be called by the VotingEscrow contract\n    /// @param addr The contract address to check\n    function isBlocked(address addr) public view returns (bool) {\n        return _blocklist[addr];\n    }\n\n    function _isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}\n\n\n",
        "CodeNames": [
            "VotingEscrow.sol",
            "Blocklist.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Blocklist.sol line 27, VotingEscrow.sol line 531, VotingEscrow.sol line 637",
                "Type": "Blocking Through Change of Blocklist Could Trap Tokens",
                "Description": "If the value of blocklist is changed to an address which returns True for isBlocked() and if this account was not previously blocked, the account's tokens will be rendered irretrievable.",
                "Repair": "Add an unblock functionality to the blocklist contract"
            }
        ]
    }
]