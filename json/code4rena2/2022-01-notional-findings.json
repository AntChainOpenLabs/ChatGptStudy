[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {BoringOwnable} from \"./utils/BoringOwnable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport \"@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol\";\nimport {IVault, IAsset} from \"interfaces/balancer/IVault.sol\";\nimport \"interfaces/balancer/IWeightedPool.sol\";\nimport \"interfaces/balancer/IPriceOracle.sol\";\n\ncontract sNOTE is ERC20Upgradeable, ERC20VotesUpgradeable, BoringOwnable, UUPSUpgradeable, ReentrancyGuard {\n    using SafeERC20 for ERC20;\n\n    IVault public immutable BALANCER_VAULT;\n    ERC20 public immutable NOTE;\n    ERC20 public immutable BALANCER_POOL_TOKEN;\n    ERC20 public immutable WETH;\n    bytes32 public immutable NOTE_ETH_POOL_ID;\n\n    /// @notice Maximum shortfall withdraw of 50%\n    uint256 public constant MAX_SHORTFALL_WITHDRAW = 50;\n    uint256 public constant BPT_TOKEN_PRECISION = 1e18;\n\n    /// @notice Redemption window in seconds\n    uint256 public constant REDEEM_WINDOW_SECONDS = 3 days;\n\n    /// @notice Tracks an account's redemption window\n    struct AccountCoolDown {\n        uint32 redeemWindowBegin;\n        uint32 redeemWindowEnd;\n    }\n\n    /// @notice Number of seconds that need to pass before sNOTE can be redeemed\n    uint32 public coolDownTimeInSeconds;\n\n    /// @notice Mapping between sNOTE holders and their current cooldown status\n    mapping(address => AccountCoolDown) public accountCoolDown;\n\n    /// @notice Emitted when a cool down begins\n    event CoolDownStarted(address account, uint256 redeemWindowBegin, uint256 redeemWindowEnd);\n\n    /// @notice Emitted when a cool down ends\n    event CoolDownEnded(address account);\n\n    /// @notice Emitted when cool down time is updated\n    event GlobalCoolDownUpdated(uint256 newCoolDownTimeSeconds);\n\n    /// @notice Constructor sets immutable contract addresses\n    constructor(\n        IVault _balancerVault,\n        bytes32 _noteETHPoolId,\n        ERC20 _note,\n        ERC20 _weth\n    ) initializer { \n        // Validate that the pool exists\n        (address poolAddress, /* */) = _balancerVault.getPool(_noteETHPoolId);\n        require(poolAddress != address(0));\n\n        WETH = _weth;\n        NOTE = _note;\n        NOTE_ETH_POOL_ID = _noteETHPoolId;\n        BALANCER_VAULT = _balancerVault;\n        BALANCER_POOL_TOKEN = ERC20(poolAddress);\n    }\n\n    /// @notice Initializes sNOTE ERC20 metadata and owner\n    function initialize(\n        address _owner,\n        uint32 _coolDownTimeInSeconds\n    ) external initializer {\n        string memory _name = \"Staked NOTE\";\n        string memory _symbol = \"sNOTE\";\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(_name);\n\n        coolDownTimeInSeconds = _coolDownTimeInSeconds;\n        owner = _owner;\n        NOTE.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n        WETH.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /** Governance Methods **/\n\n    /// @notice Authorizes the DAO to upgrade this contract\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    /// @notice Updates the required cooldown time to redeem\n    function setCoolDownTime(uint32 _coolDownTimeInSeconds) external onlyOwner {\n        coolDownTimeInSeconds = _coolDownTimeInSeconds;\n        emit GlobalCoolDownUpdated(_coolDownTimeInSeconds);\n    }\n\n    /// @notice Allows the DAO to extract up to 50% of the BPT tokens during a collateral shortfall event\n    function extractTokensForCollateralShortfall(uint256 requestedWithdraw) external nonReentrant onlyOwner {\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        uint256 maxBPTWithdraw = (bptBalance * MAX_SHORTFALL_WITHDRAW) / 100;\n        // Do not allow a withdraw of more than the MAX_SHORTFALL_WITHDRAW percentage. Specifically don't\n        // revert here since there may be a delay between when governance issues the token amount and when\n        // the withdraw actually occurs.\n        uint256 bptExitAmount = requestedWithdraw > maxBPTWithdraw ? maxBPTWithdraw : requestedWithdraw;\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(WETH));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory minAmountsOut = new uint256[](2);\n        minAmountsOut[0] = 0;\n        minAmountsOut[1] = 0;\n\n        BALANCER_VAULT.exitPool(\n            NOTE_ETH_POOL_ID,\n            address(this),\n            payable(owner), // Owner will receive the NOTE and WETH\n            IVault.ExitPoolRequest(\n                assets,\n                minAmountsOut,\n                abi.encode(\n                    IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n                    bptExitAmount\n                ),\n                false // Don't use internal balances\n            )\n        );\n    }\n\n    /// @notice Allows the DAO to set the swap fee on the BPT\n    function setSwapFeePercentage(uint256 swapFeePercentage) external onlyOwner {\n        IWeightedPool(address(BALANCER_POOL_TOKEN)).setSwapFeePercentage(swapFeePercentage);\n    }\n\n    /** User Methods **/\n\n    /// @notice Mints sNOTE from the underlying BPT token.\n    /// @param bptAmount is the amount of BPT to transfer from the msg.sender.\n    function mintFromBPT(uint256 bptAmount) external nonReentrant {\n        // _mint logic requires that tokens are transferred first\n        BALANCER_POOL_TOKEN.safeTransferFrom(msg.sender, address(this), bptAmount);\n        _mint(msg.sender, bptAmount);\n    }\n\n    /// @notice Mints sNOTE from some amount of NOTE tokens.\n    /// @param noteAmount amount of NOTE to transfer into the sNOTE contract\n    function mintFromNOTE(uint256 noteAmount) external nonReentrant {\n        // Transfer the NOTE balance into sNOTE first\n        NOTE.safeTransferFrom(msg.sender, address(this), noteAmount);\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(0));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = 0;\n        maxAmountsIn[1] = noteAmount;\n\n        _mintFromAssets(assets, maxAmountsIn);\n    }\n\n    /// @notice Mints sNOTE from some amount of ETH\n    function mintFromETH() payable external nonReentrant {\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(0));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = msg.value;\n        maxAmountsIn[1] = 0;\n\n        _mintFromAssets(assets, maxAmountsIn);\n    }\n\n    /// @notice Mints sNOTE from some amount of WETH\n    /// @param wethAmount amount of WETH to transfer into the sNOTE contract\n    function mintFromWETH(uint256 wethAmount) external nonReentrant {\n        // Transfer the NOTE balance into sNOTE first\n        WETH.safeTransferFrom(msg.sender, address(this), wethAmount);\n\n        IAsset[] memory assets = new IAsset[](2);\n        assets[0] = IAsset(address(WETH));\n        assets[1] = IAsset(address(NOTE));\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[0] = wethAmount;\n        maxAmountsIn[1] = 0;\n\n        _mintFromAssets(assets, maxAmountsIn);\n    }\n\n    function _mintFromAssets(IAsset[] memory assets, uint256[] memory maxAmountsIn) internal {\n        uint256 bptBefore = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        // Set msgValue when joining via ETH\n        uint256 msgValue = assets[0] == IAsset(address(0)) ? maxAmountsIn[0] : 0;\n\n        BALANCER_VAULT.joinPool{value: msgValue}(\n            NOTE_ETH_POOL_ID,\n            address(this),\n            address(this), // sNOTE will receive the BPT\n            IVault.JoinPoolRequest(\n                assets,\n                maxAmountsIn,\n                abi.encode(\n                    IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n                    maxAmountsIn,\n                    0 // Accept however much BPT the pool will give us\n                ),\n                false // Don't use internal balances\n            )\n        );\n        uint256 bptAfter = BALANCER_POOL_TOKEN.balanceOf(address(this));\n\n        // Balancer pool token amounts must increase\n        _mint(msg.sender, bptAfter - bptBefore);\n    }\n\n    /// @notice Begins a cool down period for the sender, this is required to redeem tokens\n    function startCoolDown() external {\n        // Cannot start a cool down if there is already one in effect\n        _requireAccountNotInCoolDown(msg.sender);\n        uint256 redeemWindowBegin = block.timestamp + coolDownTimeInSeconds;\n        uint256 redeemWindowEnd = redeemWindowBegin + REDEEM_WINDOW_SECONDS;\n\n        accountCoolDown[msg.sender] = AccountCoolDown(_safe32(redeemWindowBegin), _safe32(redeemWindowEnd));\n\n        emit CoolDownStarted(msg.sender, redeemWindowBegin, redeemWindowEnd);\n    }\n\n    /// @notice Stops a cool down for the sender\n    function stopCoolDown() public {\n        // Reset the cool down back to zero so that the account must initiate it again to redeem\n        delete accountCoolDown[msg.sender];\n        emit CoolDownEnded(msg.sender);\n    }\n\n    /// @notice Redeems some amount of sNOTE to underlying BPT tokens (which can then be sold for\n    /// NOTE or ETH). An account must have passed its cool down expiration before they can redeem\n    /// @param sNOTEAmount amount of sNOTE to redeem\n    function redeem(uint256 sNOTEAmount) external nonReentrant {\n        AccountCoolDown memory coolDown = accountCoolDown[msg.sender];\n        require(sNOTEAmount <= balanceOf(msg.sender), \"Insufficient balance\");\n        require(\n            coolDown.redeemWindowBegin != 0 &&\n            coolDown.redeemWindowBegin < block.timestamp &&\n            block.timestamp < coolDown.redeemWindowEnd,\n            \"Not in Redemption Window\"\n        );\n\n        uint256 bptToRedeem = getPoolTokenShare(sNOTEAmount);\n        _burn(msg.sender, bptToRedeem);\n\n        BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem);\n    }\n\n    /** External View Methods **/\n\n    /// @notice Returns how many Balancer pool tokens an sNOTE token amount has a claim on\n    function getPoolTokenShare(uint256 sNOTEAmount) public view returns (uint256 bptClaim) {\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        // BPT and sNOTE are both in 18 decimal precision so no conversion required\n        return (bptBalance * sNOTEAmount) / totalSupply();\n    }\n\n    /// @notice Returns the pool token share of a specific account\n    function poolTokenShareOf(address account) public view returns (uint256 bptClaim) {\n        return getPoolTokenShare(balanceOf(account));\n    }\n\n    /// @notice Calculates voting power for a given amount of sNOTE\n    /// @param sNOTEAmount amount of sNOTE to calculate voting power for\n    /// @return corresponding NOTE voting power\n    function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {\n        // Gets the BPT token price (in ETH)\n        uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);\n        // Gets the NOTE token price (in ETH)\n        uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);\n        \n        // Since both bptPrice and notePrice are denominated in ETH, we can use\n        // this formula to calculate noteAmount\n        // bptBalance * bptPrice = notePrice * noteAmount\n        // noteAmount = bptPrice/notePrice * bptBalance\n        uint256 priceRatio = bptPrice * 1e18 / notePrice;\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n\n        // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)\n        uint256 noteAmount = priceRatio * bptBalance * 80 / 100;\n\n        // Reduce precision down to 1e8 (NOTE token)\n        // priceRatio and bptBalance are both 1e18 (1e36 total)\n        // we divide by 1e28 to get to 1e8\n        noteAmount /= 1e28;\n\n        return (noteAmount * sNOTEAmount) / totalSupply();\n    }\n\n    /// @notice Calculates voting power for a given account\n    /// @param account a given sNOTE holding account\n    /// @return corresponding NOTE voting power\n    function votingPowerOf(address account) external view returns (uint256) {\n        return getVotingPower(balanceOf(account));\n    }\n\n    /** Internal Methods **/\n\n    function _requireAccountNotInCoolDown(address account) internal view {\n        AccountCoolDown memory coolDown = accountCoolDown[account];\n        // An account is in cool down if the redeem window has begun and the window end has not\n        // passed yet.\n        bool isInCoolDown = (0 < coolDown.redeemWindowBegin && block.timestamp < coolDown.redeemWindowEnd);\n        require(!isInCoolDown, \"Account in Cool Down\");\n    }\n\n    /// @notice Burns sNOTE tokens when they are redeemed\n    /// @param account account to burn tokens on\n    /// @param bptToRedeem the number of BPT tokens being redeemed by the account\n    function _burn(address account, uint256 bptToRedeem) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        uint256 poolTokenShare = poolTokenShareOf(account);\n        require(bptToRedeem <= poolTokenShare, \"Invalid Redeem Amount\");\n\n        // Burns the portion of the sNOTE corresponding to the bptToRedeem\n        uint256 sNOTEToBurn = balanceOf(account) * bptToRedeem / poolTokenShare;\n        // Handles event emission, balance update and total supply update\n        super._burn(account, sNOTEToBurn);\n    }\n\n    /// @notice Mints sNOTE tokens given a bptAmount\n    /// @param account account to mint tokens to\n    /// @param bptAmount the number of BPT tokens being minted by the account\n    function _mint(address account, uint256 bptAmount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        // Cannot mint if a cooldown is already in effect. If an account mints during a cool down period then they will\n        // be able to redeem the tokens immediately, bypassing the cool down.\n        _requireAccountNotInCoolDown(account);\n\n        // Immediately after minting, we need to satisfy the equality:\n        // (sNOTEToMint * bptBalance) / (totalSupply + sNOTEToMint) == bptAmount\n\n        // Rearranging to get sNOTEToMint on one side:\n        // (sNOTEToMint * bptBalance) = (totalSupply + sNOTEToMint) * bptAmount\n        // (sNOTEToMint * bptBalance) = totalSupply * bptAmount + sNOTEToMint * bptAmount\n        // (sNOTEToMint * bptBalance) - (sNOTEToMint * bptAmount) = totalSupply * bptAmount\n        // sNOTEToMint * (bptBalance - bptAmount) = totalSupply * bptAmount\n        // sNOTEToMint = (totalSupply * bptAmount) / (bptBalance - bptAmount)\n\n        // NOTE: at this point the BPT has already been transferred into the sNOTE contract, so this\n        // bptBalance amount includes bptAmount.\n        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 sNOTEToMint;\n        if (_totalSupply == 0) {\n            sNOTEToMint = bptAmount;\n        } else {\n            sNOTEToMint = (_totalSupply * bptAmount) / (bptBalance - bptAmount);\n        }\n\n        // Handles event emission, balance update and total supply update\n        super._mint(account, sNOTEToMint);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable) {\n        // Cannot send or receive tokens if a cool down is in effect or else accounts\n        // can bypass the cool down. It's not clear if sending tokens can be used to bypass\n        // the cool down but we restrict it here anyway, there's no clear use case for sending\n        // sNOTE tokens during a cool down.\n        if (to != address(0)) {\n            // Run these checks only when we are not burning tokens. (OZ ERC20 does not allow transfers\n            // to address(0), to == address(0) only when _burn is called).\n            _requireAccountNotInCoolDown(from);\n            _requireAccountNotInCoolDown(to);\n        }\n\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {\n        // Moves sNOTE checkpoints\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    function _safe32(uint256 x) internal pure returns (uint32) {\n        require (x <= type(uint32).max);\n        return uint32(x);\n    }\n}\n\n",
        "CodeNames": [
            "sNOTE.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "sNOTE contract",
                "Type": "Smart contract vulnerability",
                "Description": "Cooldown and redeem windows can be rendered useless.",
                "Repair": "Remove the cooldown/redeem period or bind the cooldown/redeem window to the amount that was minted at that time by the account"
            },
            {
                "Location": "sNOTE contract",
                "Type": "Smart contract vulnerability",
                "Description": "sNOTE holders are not incentivized to vote on proposals to call extractTokensForCollateralShortfall.",
                "Repair": "Redesign the mechanism to better align stakers with the health of the protocol, such as allocating a percentage of generated fees to an insurance fund"
            },
            {
                "Location": "sNOTE contract",
                "Type": "Smart contract vulnerability",
                "Description": "Lack of slippage control in _mintFromAssets() function.",
                "Repair": "Add a minAmountOut parameter for mintFromNOTE(), mintFromETH(), and mintFromWETH() functions"
            },
            {
                "Location": "extractTokensForCollateralShortfall() function in sNOTE.sol",
                "Type": "Lack of Enforcement",
                "Description": "The function extractTokensForCollateralShortfall() allows the owner of the sNote contract to withdraw up to 50% of the total amount of BPT. This limit is easily circumvented as the function can simply be called a second, third and fourth time, to withdraw almost all of the BPT.",
                "Repair": "Rewrite the logic and enforce a limit during a time period i.e. do not allow to withdraw over 50% *per week* (or any time period that is longer than the cooldown period, so that users have time to withdraw their collateral)"
            },
            {
                "Location": "startCooldown() function in sNOTE.sol",
                "Type": "Lack of Limitation",
                "Description": "It's possible for the owner of the sNOTE contract to choose a value for coolDownTimeInSeconds which always causes the startCooldown() function to revert. Should ownership over sNOTE become compromised then all of the users' assets may be locked indefinitely.",
                "Repair": "Provide a sensible upper limit to coolDownTimeInSeconds of, say, a month"
            },
            {
                "Location": "getVotingPower() function in sNOTE.sol",
                "Type": "Lack of Checkpointing",
                "Description": "getVotingPower is a useful function in tracking the relative voting power a staker has, however, it does not utilise any checkpointing mechanism to ensure the user's voting power is a snapshot of a specific block number.",
                "Repair": "Implement a getPriorVotingPower function which takes in a blockNumber argument and returns the correct balance at that specific block"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Treasury manager contract",
                "Type": "Smart contract vulnerability",
                "Description": "A malicious treasury manager can burn treasury tokens by setting makerFee to the amount the maker receives.",
                "Repair": "Check that makerFee and takerFee are set to zero in _validateOrder function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin-0.7/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin-0.7/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./ActionGuards.sol\";\nimport \"./math/SafeInt256.sol\";\nimport \"./stubs/BalanceHandler.sol\";\nimport \"./stubs/TokenHandler.sol\";\nimport \"./global/StorageLayoutV2.sol\";\nimport \"./global/Constants.sol\";\nimport \"interfaces/notional/NotionalTreasury.sol\";\nimport \"interfaces/compound/ComptrollerInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport {WETH9_07 as WETH9} from \"interfaces/WETH9_07.sol\";\n\ncontract TreasuryAction is StorageLayoutV2, ActionGuards, NotionalTreasury {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n    using SafeERC20 for IERC20;\n    using TokenHandler for Token;\n\n    IERC20 public immutable COMP;\n    Comptroller public immutable COMPTROLLER;\n    WETH9 public immutable WETH;\n\n    /// @dev Emitted when treasury manager is updated\n    event TreasuryManagerChanged(address indexed previousManager, address indexed newManager);\n    /// @dev Emitted when reserve buffer value is updated\n    event ReserveBufferUpdated(uint16 currencyId, uint256 bufferAmount);\n\n    /// @dev Throws if called by any account other than the owner.\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /// @dev Harvest methods are only callable by the authorized treasury manager contract\n    modifier onlyManagerContract() {\n        require(treasuryManagerContract == msg.sender, \"Caller is not the treasury manager\");\n        _;\n    }\n\n    /// @dev Checks if the currency ID is valid\n    function _checkValidCurrency(uint16 currencyId) internal view {\n        require(0 < currencyId && currencyId <= maxCurrencyId, \"Invalid currency id\");\n    }\n\n    constructor(Comptroller _comptroller, WETH9 _weth) {\n        COMPTROLLER = _comptroller;\n        COMP = IERC20(_comptroller.getCompAddress());\n        WETH = _weth;\n    }\n\n    /// @notice Sets the new treasury manager contract\n    function setTreasuryManager(address manager) external override onlyOwner {\n        emit TreasuryManagerChanged(treasuryManagerContract, manager);\n        treasuryManagerContract = manager;\n    }\n\n    /// @notice Sets the reserve buffer. This is the amount of reserve balance to keep denominated in 1e8 \n    /// The reserve cannot be harvested if it's below this amount. This portion of the reserve will remain on \n    /// the contract to act as a buffer against potential insolvency.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param bufferAmount reserve buffer amount to keep in internal token precision (1e8)\n    function setReserveBuffer(uint16 currencyId, uint256 bufferAmount)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        reserveBuffer[currencyId] = bufferAmount;\n        emit ReserveBufferUpdated(currencyId, bufferAmount);\n    }\n\n    /// @notice This is used in the case of insolvency. It allows the owner to re-align the reserve with its correct balance.\n    /// @param currencyId refers to the currency of the reserve\n    /// @param newBalance new reserve balance to set, must be less than the current balance\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        // prettier-ignore\n        (int256 reserveBalance, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n        require(newBalance < reserveBalance, \"cannot increase reserve balance\");\n        // newBalance cannot be negative and is checked inside BalanceHandler.setReserveCashBalance\n        BalanceHandler.setReserveCashBalance(currencyId, newBalance);\n    }\n\n    /// @notice Claims COMP incentives earned and transfers to the treasury manager contract.\n    /// @param cTokens a list of cTokens to claim incentives for\n    /// @return the balance of COMP claimed\n    function claimCOMPAndTransfer(address[] calldata cTokens)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256)\n    {\n        // Take a snasphot of the COMP balance before we claim COMP so that we don't inadvertently transfer\n        // something we shouldn't.\n        uint256 balanceBefore = COMP.balanceOf(address(this));\n        COMPTROLLER.claimComp(address(this), cTokens);\n        // NOTE: If Notional ever lists COMP as a collateral asset it will be cCOMP instead and it\n        // will never hold COMP balances directly. In this case we can always transfer all the COMP\n        // off of the contract.\n        uint256 balanceAfter = COMP.balanceOf(address(this));\n        uint256 amountClaimed = balanceAfter.sub(balanceBefore);\n        // NOTE: the onlyManagerContract modifier prevents a transfer to address(0) here\n        COMP.safeTransfer(treasuryManagerContract, amountClaimed);\n        // NOTE: TreasuryManager contract will emit a COMPHarvested event\n        return amountClaimed;\n    }\n\n    /// @notice redeems and transfers tokens to the treasury manager contract\n    function _redeemAndTransfer(\n        uint16 currencyId,\n        Token memory asset,\n        int256 assetInternalRedeemAmount\n    ) private returns (uint256) {\n        Token memory underlying = TokenHandler.getUnderlyingToken(currencyId);\n        int256 assetExternalRedeemAmount = asset.convertToExternal(assetInternalRedeemAmount);\n\n        // This is the actual redeemed amount in underlying external precision\n        uint256 redeemedExternalUnderlying = asset\n            .redeem(underlying, assetExternalRedeemAmount.toUint())\n            .toUint();\n\n        // NOTE: cETH redeems to ETH, converting it to WETH\n        if (underlying.tokenAddress == address(0)) {\n            WETH9(WETH).deposit{value: address(this).balance}();\n        }\n\n        address underlyingAddress = underlying.tokenAddress == address(0)\n            ? address(WETH)\n            : underlying.tokenAddress;\n        IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);\n\n        return redeemedExternalUnderlying;\n    }\n\n    /// @notice Transfers some amount of reserve assets to the treasury manager contract to be invested\n    /// into the sNOTE pool.\n    /// @param currencies an array of currencies to transfer from Notional\n    function transferReserveToTreasury(uint16[] calldata currencies)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        uint256[] memory amountsTransferred = new uint256[](currencies.length);\n\n        for (uint256 i; i < currencies.length; i++) {\n            // Prevents duplicate currency IDs\n            if (i > 0) require(currencies[i] > currencies[i - 1], \"IDs must be sorted\");\n\n            uint16 currencyId = currencies[i];\n\n            _checkValidCurrency(currencyId);\n\n            // Reserve buffer amount in INTERNAL_TOKEN_PRECISION\n            int256 bufferInternal = SafeInt256.toInt(reserveBuffer[currencyId]);\n\n            // Reserve requirement not defined\n            if (bufferInternal == 0) continue;\n\n            // prettier-ignore\n            (int256 reserveInternal, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n\n            // Do not withdraw anything if reserve is below or equal to reserve requirement\n            if (reserveInternal <= bufferInternal) continue;\n\n            Token memory asset = TokenHandler.getAssetToken(currencyId);\n\n            // Actual reserve amount allowed to be redeemed and transferred\n            int256 assetInternalRedeemAmount = reserveInternal.subNoNeg(bufferInternal);\n\n            // Redeems cTokens and transfer underlying to treasury manager contract\n            amountsTransferred[i] = _redeemAndTransfer(\n                currencyId,\n                asset,\n                assetInternalRedeemAmount\n            );\n\n            // Updates the reserve balance\n            BalanceHandler.harvestExcessReserveBalance(\n                currencyId,\n                reserveInternal,\n                assetInternalRedeemAmount\n            );\n        }\n\n        // NOTE: TreasuryManager contract will emit an AssetsHarvested event\n        return amountsTransferred;\n    }\n}\n\n",
        "CodeNames": [
            "TreasuryAction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TreasuryAction.claimCOMPAndTransfer function",
                "Type": "Smart contract vulnerability",
                "Description": "Treasury cannot claim COMP tokens & COMP tokens are stuck.",
                "Repair": "Don't use pre-and post-balances, use the entire balance"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {WETH9} from \"interfaces/WETH9.sol\";\nimport {AggregatorV2V3Interface} from \"interfaces/chainlink/AggregatorV2V3Interface.sol\";\n\ncontract EIP1271Wallet {\n    // 0x order encoding is implemented in _encodeEIP1271OrderWithHash\n    // https://github.com/0xProject/0x-monorepo/blob/development/contracts/exchange/contracts/src/MixinSignatureValidator.sol\n    uint256 internal constant ORDER_HASH_OFFSET = 36;\n    uint256 internal constant FEE_RECIPIENT_OFFSET = 144;\n    uint256 internal constant MAKER_AMOUNT_OFFSET = 196;\n    uint256 internal constant TAKER_AMOUNT_OFFSET = 228;\n    uint256 internal constant MAKER_TOKEN_OFFSET = 564;\n    uint256 internal constant TAKER_TOKEN_OFFSET = 660;\n    uint256 internal constant SLIPPAGE_LIMIT_PRECISION = 1e8;\n    uint256 internal constant ETH_PRECISION = 1e18;\n\n    bytes4 internal constant EIP1271_MAGIC_NUM = 0x20c13b0b;\n    bytes4 internal constant EIP1271_INVALID_SIG = 0xffffffff;\n    WETH9 public immutable WETH;\n    mapping(address => address) public priceOracles;\n    mapping(address => uint256) public slippageLimits;\n\n    event PriceOracleUpdated(address tokenAddress, address oracleAddress);\n    event SlippageLimitUpdated(address tokenAddress, uint256 slippageLimit);\n\n    constructor(WETH9 _weth) {\n        WETH = _weth;\n    }\n\n    function _toAddress(bytes memory _bytes, uint256 _start)\n        private\n        pure\n        returns (address)\n    {\n        // _bytes.length checked by the caller\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    function _toUint256(bytes memory _bytes, uint256 _start)\n        private\n        pure\n        returns (uint256)\n    {\n        // _bytes.length checked by the caller\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function _toBytes32(bytes memory _bytes, uint256 _start)\n        private\n        pure\n        returns (bytes32)\n    {\n        // _bytes.length checked by the caller\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function _toUint(int256 x) private pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    /// @notice extracts order information from the encoded 0x order object\n    function _extractOrderInfo(bytes memory encoded)\n        private\n        pure\n        returns (\n            address makerToken,\n            address takerToken,\n            address feeRecipient,\n            uint256 makerAmount,\n            uint256 takerAmount\n        )\n    {\n        require(\n            encoded.length >= TAKER_TOKEN_OFFSET + 32,\n            \"encoded: invalid length\"\n        );\n        feeRecipient = _toAddress(encoded, FEE_RECIPIENT_OFFSET);\n        makerAmount = _toUint256(encoded, MAKER_AMOUNT_OFFSET);\n        takerAmount = _toUint256(encoded, TAKER_AMOUNT_OFFSET);\n        makerToken = _toAddress(encoded, MAKER_TOKEN_OFFSET);\n        takerToken = _toAddress(encoded, TAKER_TOKEN_OFFSET);\n    }\n\n    /// @notice extracts the order hash from the encoded 0x order object\n    function _extractOrderHash(bytes memory encoded)\n        private\n        pure\n        returns (bytes32)\n    {\n        require(\n            encoded.length >= ORDER_HASH_OFFSET + 32,\n            \"encoded: invalid length\"\n        );\n\n        return _toBytes32(encoded, ORDER_HASH_OFFSET);\n    }\n\n    /// @notice sets the price oracle for a given token\n    function _setPriceOracle(address tokenAddress, address oracleAddress)\n        internal\n    {\n        priceOracles[tokenAddress] = oracleAddress;\n        emit PriceOracleUpdated(tokenAddress, oracleAddress);\n    }\n\n    /// @notice slippage limit sets the price floor of the maker token based on the oracle price\n    /// SLIPPAGE_LIMIT_PRECISION = 1e8 = 100% of the current oracle price\n    function _setSlippageLimit(address tokenAddress, uint256 slippageLimit)\n        internal\n    {\n        require(\n            slippageLimit <= SLIPPAGE_LIMIT_PRECISION,\n            \"invalid slippage limit\"\n        );\n        slippageLimits[tokenAddress] = slippageLimit;\n        emit SlippageLimitUpdated(tokenAddress, slippageLimit);\n    }\n\n    /// @notice make sure the order satisfies some pre-defined constraints\n    function _validateOrder(bytes memory order) private view {\n        (\n            address makerToken,\n            address takerToken,\n            address feeRecipient,\n            uint256 makerAmount,\n            uint256 takerAmount\n        ) = _extractOrderInfo(order);\n\n        // No fee recipient allowed\n        require(feeRecipient == address(0), \"no fee recipient allowed\");\n\n        // MakerToken should never be WETH\n        require(makerToken != address(WETH), \"maker token must not be WETH\");\n\n        // TakerToken (proceeds) should always be WETH\n        require(takerToken == address(WETH), \"taker token must be WETH\");\n\n        address priceOracle = priceOracles[makerToken];\n\n        // Price oracle not defined\n        require(priceOracle != address(0), \"price oracle not defined\");\n\n        uint256 slippageLimit = slippageLimits[makerToken];\n\n        // Slippage limit not defined\n        require(slippageLimit != 0, \"slippage limit not defined\");\n\n        uint256 oraclePrice = _toUint(\n            AggregatorV2V3Interface(priceOracle).latestAnswer()\n        );\n\n        uint256 priceFloor = (oraclePrice * slippageLimit) /\n            SLIPPAGE_LIMIT_PRECISION;\n\n        uint256 makerDecimals = 10**ERC20(makerToken).decimals();\n\n        // makerPrice = takerAmount / makerAmount\n        uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;\n\n        require(makerPrice >= priceFloor, \"slippage is too high\");\n    }\n\n    /**\n     * @notice Verifies that the signer is the owner of the signing contract.\n     */\n    function _isValidSignature(\n        bytes calldata data,\n        bytes calldata signature,\n        address signer\n    ) internal view returns (bytes4) {\n        _validateOrder(data);\n\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    _extractOrderHash(data)\n                )\n            ),\n            signature\n        );\n\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\n            return EIP1271_MAGIC_NUM;\n        }\n\n        return EIP1271_INVALID_SIG;\n    }\n}\n\n\n",
        "CodeNames": [
            "EIP1271Wallet.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_validateOrder() function in EIP1271Wallet.sol",
                "Type": "Lack of Validation",
                "Description": "The _validateOrder function does not ensure that the takerAddress and senderAddress are set to the zero address. As a result, it is possible for the manager to have sole rights to an off-chain order and due to the flexibility in makerPrice, the manager is able to extract value from the treasury by maximising the allowed slippage.",
                "Repair": "Add require(takerAddress == address(0), 'manager cannot set taker'); and require(senderAddress == address(0), 'manager cannot set sender'); statements to _validateOrder"
            },
            {
                "Location": "Chainlink API in EIP1271Wallet.sol",
                "Type": "Deprecated API Usage",
                "Description": "The Chainlink API (latestAnswer) used in the EIP1271Wallet contract is deprecated. This function does not error if no answer has been reached but returns 0.",
                "Repair": "Use the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete"
            }
        ]
    }
]