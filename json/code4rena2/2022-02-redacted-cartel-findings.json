[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "depositBribeERC20 function in BriveVault",
                "Type": "Reentrancy",
                "Description": "A bad actor that has DEPOSITOR_ROLE and is a contract can execute a following attack by creating a dummy token contract, reentrant in the transferFrom() function.",
                "Repair": "Enforce a bribeIdentifier to be used for a specific token (and it being enforced), as well as adding nonReentrant modifier"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ninterface IRewardDistributor {\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external;\n}\n\ncontract BribeVault is AccessControl {\n    using SafeERC20 for IERC20;\n\n    struct Bribe {\n        address token;\n        uint256 amount;\n    }\n\n    uint256 public fee; // 5000 = 0.5%\n    address public feeRecipient; // Protocol treasury\n    address public distributor; // RewardDistributor contract\n    uint256 public constant feeDivisor = 1000000;\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    // Bribe identifiers mapped to Bribe structs\n    // A bribe identifier is composed of different info (e.g. protocol, voting round, etc.)\n    mapping(bytes32 => Bribe) public bribes;\n\n    // Protocol-specific reward identifiers mapped to bribe identifiers\n    // Allows us to group bribes by reward tokens (one token may be used across many bribes)\n    mapping(bytes32 => bytes32[]) public rewardToBribes;\n\n    event GrantDepositorRole(address depositor);\n    event RevokeDepositorRole(address depositor);\n    event SetFee(uint256 _fee);\n    event SetFeeRecipient(address _feeRecipient);\n    event SetDistributor(address _distributor);\n    event DepositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        uint256 totalAmount,\n        address briber\n    );\n    event TransferBribe(\n        bytes32 rewardIdentifier,\n        address token,\n        bytes32 proof,\n        uint256 feeAmount,\n        uint256 distributorAmount\n    );\n    event EmergencyWithdrawal(address token, uint256 amount, address admin);\n\n    constructor(\n        uint256 _fee,\n        address _feeRecipient,\n        address _distributor\n    ) {\n        require(_fee <= feeDivisor, \"Invalid fee\");\n        fee = _fee;\n\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Grant the depositor role to an address\n        @param  depositor  address  Address to grant the depositor role\n     */\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n    /**\n        @notice Revoke the depositor role from an address\n        @param  depositor  address  Address to revoke the depositor role\n     */\n    function revokeDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\");\n        _revokeRole(DEPOSITOR_ROLE, depositor);\n\n        emit RevokeDepositorRole(depositor);\n    }\n\n    /**\n        @notice Set the fee collected by the protocol\n        @param  _fee  uint256  Fee\n     */\n    function setFee(uint256 _fee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_fee <= feeDivisor, \"Invalid _fee\");\n        fee = _fee;\n\n        emit SetFee(_fee);\n    }\n\n    /**\n        @notice Set the protocol address where fees will be transferred\n        @param  _feeRecipient  address  Fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        emit SetFeeRecipient(_feeRecipient);\n    }\n\n    /**\n        @notice Set the RewardDistributor contract address\n        @param  _distributor  address  Distributor\n     */\n    function setDistributor(address _distributor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        emit SetDistributor(_distributor);\n    }\n\n    /**\n        @notice Get bribe information based on the specified identifier\n        @param  bribeIdentifier  bytes32  The specified bribe identifier\n     */\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount)\n    {\n        Bribe memory b = bribes[bribeIdentifier];\n        return (b.token, b.amount);\n    }\n\n    /**\n        @notice Deposit bribe (ERC20 only)\n        @param  bribeIdentifier   bytes32  Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32  Unique identifier related to reward\n        @param  token             address  Bribe token\n        @param  amount            uint256  Bribe token amount\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n        IERC20(token).safeTransferFrom(briber, address(this), amount);\n\n        b.amount += amount; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = token;\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Deposit bribe (native token only)\n        @param  bribeIdentifier   bytes32 Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32 Unique identifier related to reward\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Transfer fees to fee recipient and bribes to distributor and update rewards metadata\n        @param  distributions    Distribution[] List of distribution details\n        @param  amounts          uint256[] List of amounts for distributor\n        @param  fees             uint256[] List of fee amounts for fee recipient\n     */\n    function transferBribes(\n        Common.Distribution[] calldata distributions,\n        uint256[] calldata amounts,\n        uint256[] calldata fees\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(distributions.length > 0, \"Invalid distributions\");\n        require(\n            distributions.length == amounts.length &&\n                distributions.length == fees.length,\n            \"Distributions, amounts, and fees must contain the same # of elements\"\n        );\n\n        // Transfer the bribe funds to fee recipient and reward distributor\n        for (uint256 i = 0; i < distributions.length; i++) {\n            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;\n            uint256 distributorAmount = amounts[i];\n            uint256 feeAmount = fees[i];\n            address token = distributions[i].token;\n            require(\n                rewardToBribes[rewardIdentifier].length > 0,\n                \"Invalid reward identifier\"\n            );\n            require(token != address(0), \"Invalid token address\");\n            require(distributorAmount > 0, \"Invalid pending reward amount\");\n\n            // Check whether it's a native token reward\n            if (token == address(this)) {\n                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(\n                    \"\"\n                );\n                require(\n                    sentFeeRecipient,\n                    \"Failed to transfer to fee recipient\"\n                );\n\n                (bool sentDistributor, ) = distributor.call{\n                    value: distributorAmount\n                }(\"\");\n                require(sentDistributor, \"Failed to transfer to distributor\");\n            } else {\n                IERC20(token).transfer(feeRecipient, feeAmount);\n                IERC20(token).transfer(distributor, distributorAmount);\n            }\n\n            emit TransferBribe(\n                rewardIdentifier,\n                token,\n                distributions[i].proof,\n                feeAmount,\n                distributorAmount\n            );\n        }\n\n        // Update the rewards' metadata\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Update the rewards metadata of the specified identifiers (only if absolutely needed)\n        @param  distributions    Distribution[] List of distribution details\n     */\n    function updateRewardsMetadata(Common.Distribution[] calldata distributions)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(distributions.length > 0, \"Invalid distributions\");\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Withdraw ERC20 tokens to the admin address\n        @param  token   address  Token address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdrawERC20(address token, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Invalid amount\");\n\n        IERC20(token).transfer(msg.sender, amount);\n\n        emit EmergencyWithdrawal(token, amount, msg.sender);\n    }\n\n    /**\n        @notice Withdraw native tokens to the admin address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdraw(uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(amount > 0, \"Invalid amount\");\n\n        (bool sentAdmin, ) = msg.sender.call{value: amount}(\"\");\n        require(sentAdmin, \"Failed to withdraw\");\n\n        emit EmergencyWithdrawal(address(this), amount, msg.sender);\n    }\n}\n\n\n",
        "CodeNames": [
            "BribeVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "grantDepositorRole function in BribeVault",
                "Type": "Unauthorized fund transfer",
                "Description": "The current design/implementation allows the DEFAULT_ADMIN_ROLE of BribeVault to steal funds from any address that approved this contract up to allowance.",
                "Repair": "Consider using TokemakBribe instead of BribeVault to hold users' allowances; make sure that the from parameter of transferFrom can only be msg.sender; use a multi-sig for the DEFAULT_ADMIN_ROLE of BribeVault"
            },
            {
                "Location": "BribeVault.sol#L256",
                "Type": "Transfer of Bribes Before Proposal Deadline and Input Validation",
                "Description": "Admin can call transferBribes even when proposals belonging to this rewardIdentifier have not expired. Also, due to lack of input validation, token in distributions[i].rewardIdentifier might differ from distributions[i].token and also amount is not validated.",
                "Repair": "Perform input validation to ensure that the sum amount of all proposals under rewardToBribes[rewardIdentifier] is equal to the amount provided by admin in argument and that token under distributions[i].rewardIdentifier is equal to the one provided by admin in argument"
            },
            {
                "Location": "BribeVault.sol, transferBribes() function",
                "Type": "Unused library",
                "Description": "SafeERC20.sol is imported but not used in the transferBribes() function.",
                "Repair": "Use OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens."
            },
            {
                "Location": "BribeVault.sol, updateRewardsMetadata() function",
                "Type": "Improper control over metadata versions",
                "Description": "Improper control over the versions of distributions' metadata may lead to repeated claims of rewards.",
                "Repair": "Require the previous updateCount to match the current updateCount before updating the metadata."
            },
            {
                "Location": "BribeVault.sol#L104-L113, BribeVault.sol#L164, BribeVault.sol#L213, BribeVault.sol#L256",
                "Type": "Manipulation",
                "Description": "The admin can set the fee up to 100%, which is bad for users. Tokens are transferred in a separate function, so an admin can change fees for already made deposits. Even if a fee would be applied in depositBribe, function setFee could frontrun user deposits.",
                "Repair": "Set an upper limit for fees, use a timelock to prevent frontrunning, and minimize external trust. "
            },
            {
                "Location": "BribeVault.sol#L23",
                "Type": "Incorrect fee calculation",
                "Description": "The fees amounts might be wrong as the function trusts the Admin input instead of using the storage variable, giving less security guarantees as to the fairness of the Distribution of the Bribes.",
                "Repair": "Use the storage variable fee instead of user input for calculating fees."
            },
            {
                "Location": "BribeVault.sol#L164",
                "Type": "Unauthorized fund transfer",
                "Description": "One depositor can spend funds of another depositor. Depositor can deposit in expired proposal. rewardIdentifier and bribeIdentifier can point to different rounds/tokens.",
                "Repair": "depositBribeERC20 should only be allowed to be called via TokemakBribe.sol"
            },
            {
                "Location": "BribeVault.sol#L187",
                "Type": "Manipulation of b.amount value",
                "Description": "Malicious DEPOSITOR_ROLE can doing self transfer and manipulate b.amount",
                "Repair": "Validate that bribe != Address(this)"
            },
            {
                "Location": "BribeVault.transferBribes",
                "Type": "Mismatch between distributions and actual bribes",
                "Description": "Distributions must not match actual bribes",
                "Repair": "Validate the distributions, amounts, and fees parameters against the deposited bribes"
            },
            {
                "Location": "BribeVault.sol#L164-L205",
                "Type": "DEPOSITOR_ROLE can transfer briber's approved ERC20 tokens",
                "Description": "DEPOSITOR_ROLE can be granted by the deployer of BribeVault and transfer briber's approved ERC20 tokens to bribeVault by specifying any bribeIdentifier and rewardIdentifier",
                "Repair": "Transfer the briber's tokens to the TokemakBribe contract first, and then transfer the tokens to the bribeVault contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ncontract RewardDistributor is AccessControl, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct Reward {\n        address token;\n        bytes32 merkleRoot;\n        bytes32 proof;\n        uint256 updateCount;\n    }\n\n    struct Claim {\n        bytes32 identifier;\n        address account;\n        uint256 index;\n        uint256 amount;\n        bytes32[] merkleProof;\n    }\n\n    address public bribeVault;\n    mapping(bytes32 => Reward) public rewards; // Maps each of the reward identifier to its metadata\n    mapping(bytes32 => mapping(uint256 => mapping(uint256 => uint256)))\n        private claimed; // Tracks whether a specific reward claim has been done\n\n    event SetBribeVault(address _bribeVault);\n    event RewardClaimed(\n        bytes32 indexed identifier,\n        address indexed tokenAddress,\n        address indexed account,\n        uint256 updateCount,\n        uint256 index,\n        uint256 amount\n    );\n    event RewardMetadataUpdated(\n        bytes32 indexed identifier,\n        address indexed token,\n        bytes32 merkleRoot,\n        bytes32 proof,\n        uint256 indexed updateCount\n    );\n\n    constructor(address _bribeVault) {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    // Enables BribeVault to transfer native tokens\n    receive() external payable {}\n\n    /**\n        @notice Set bribe vault\n        @param  _bribeVault address New address of the bribe vault\n     */\n    function setBribeVault(address _bribeVault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_bribeVault != address(0), \"Invalid bribeVault\");\n        bribeVault = _bribeVault;\n\n        emit SetBribeVault(bribeVault);\n    }\n\n    /**\n        @notice Claim rewards based on the specified metadata\n        @param  _claims   Claim[] List of claim metadata\n     */\n    function claim(Claim[] calldata _claims) external nonReentrant {\n        require(_claims.length > 0, \"Invalid _claims\");\n\n        for (uint256 i = 0; i < _claims.length; i++) {\n            _claim(\n                _claims[i].identifier,\n                _claims[i].index,\n                _claims[i].account,\n                _claims[i].amount,\n                _claims[i].merkleProof\n            );\n        }\n    }\n\n    /**\n        @notice Update the overall metadata of the specified reward identifiers\n        @param  _distributions    Distribution[] List of reward distribution details\n     */\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external {\n        require(msg.sender == bribeVault, \"Invalid access\");\n        require(_distributions.length > 0, \"Invalid _distributions\");\n\n        for (uint256 i = 0; i < _distributions.length; i++) {\n            // Update the metadata and also increment the update to reset the claimed tracker\n            Reward storage reward = rewards[_distributions[i].rewardIdentifier];\n            reward.token = _distributions[i].token;\n            reward.merkleRoot = _distributions[i].merkleRoot;\n            reward.proof = _distributions[i].proof;\n            reward.updateCount += 1;\n\n            emit RewardMetadataUpdated(\n                _distributions[i].rewardIdentifier,\n                _distributions[i].token,\n                _distributions[i].merkleRoot,\n                _distributions[i].proof,\n                reward.updateCount\n            );\n        }\n    }\n\n    /**\n        @notice Check if the reward on the specified identifier and index has been claimed\n        @param  _identifier    bytes32 The specified identifier\n        @param  _index         bytes32 The specified index\n        @return  claimed       bool    Whether reward has been claimed\n     */\n    function isRewardClaimed(bytes32 _identifier, uint256 _index)\n        public\n        view\n        returns (bool)\n    {\n        // Get the group index for the specified index along with the bit index\n        // and check if the corresponding bit index is flipped\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n        uint256 claimedGroupState = claimed[_identifier][reward.updateCount][\n            claimedGroup\n        ];\n        uint256 mask = (1 << claimedIndex);\n        return claimedGroupState & mask == mask;\n    }\n\n    /**\n        @notice Claim a reward\n        @param  _rewardIdentifier  bytes32    Reward identifier\n        @param  _index             uint256    Node index\n        @param  _account           address    Eligible user account\n        @param  _amount            bytes32    Reward amount\n        @param  _merkleProof       bytes32[]  Merkle proof\n     */\n    function _claim(\n        bytes32 _rewardIdentifier,\n        uint256 _index,\n        address _account,\n        uint256 _amount,\n        bytes32[] calldata _merkleProof\n    ) internal {\n        Reward memory reward = rewards[_rewardIdentifier];\n        require(reward.merkleRoot != 0, \"Distribution not enabled\");\n        require(\n            !isRewardClaimed(_rewardIdentifier, _index),\n            \"Reward already claimed\"\n        );\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(abi.encodePacked(_index, _account, _amount));\n        require(\n            MerkleProof.verify(_merkleProof, reward.merkleRoot, node),\n            \"Invalid proof\"\n        );\n\n        _setClaimed(_rewardIdentifier, _index);\n\n        // Check whether the reward is in the form of native tokens or ERC20\n        // by checking if the token address is set to the bribe vault or not\n        address token = reward.token;\n        if (token != bribeVault) {\n            IERC20(token).safeTransfer(_account, _amount);\n        } else {\n            payable(_account).transfer(_amount);\n        }\n\n        emit RewardClaimed(\n            _rewardIdentifier,\n            token,\n            _account,\n            reward.updateCount,\n            _index,\n            _amount\n        );\n    }\n\n    /**\n        @notice Set a reward as claimed\n        @param  _identifier  bytes32    Reward identifier\n        @param  _index       uint256    Node index\n     */\n    function _setClaimed(bytes32 _identifier, uint256 _index) internal {\n        Reward memory reward = rewards[_identifier];\n        uint256 claimedGroup = _index / 256;\n        uint256 claimedIndex = _index % 256;\n\n        // Flip the bit state to mark the corresponding index as claimed\n        claimed[_identifier][reward.updateCount][claimedGroup] =\n            claimed[_identifier][reward.updateCount][claimedGroup] |\n            (1 << claimedIndex);\n    }\n}\n\n\n",
        "CodeNames": [
            "RewardDistributor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "updateRewardsMetadata function in RewardDistributor",
                "Type": "Double claiming rewards",
                "Description": "There is potential for misuse if users frontrun calls to updateRewardsMetadata and claim their reward after the new merkle root has been calculated and updated by the admin role.",
                "Repair": "Implement a delay where users cannot claim rewards before a call to updateRewardsMetadata is made"
            },
            {
                "Location": "RewardDistributor.sol#L178-#L182",
                "Type": "Locking of ETH Rewards",
                "Description": "If the bribeVault is modified in setBribeVault(), then users who have ETH rewards will now be considered to have ERC20(bribeVault) tokens. Since bribeVault is not an ERC20 token, the transfer() call will fail and the users will not be able to claim their funds.",
                "Repair": "Remove the functionality to change the bribeVault or ensure all funds have been withdrawn before changing the bribeVault"
            },
            {
                "Location": "RewardDistributor.sol#L97",
                "Type": "Reward loss",
                "Description": "Reward can be lost if bribeVault calls the updateRewardsMetadata on same rewardIdentifier again before user can claim his reward.",
                "Repair": "bribeVault should only make second call to updateRewardsMetadata on same rewardIdentifier when all claimers have made their claims."
            },
            {
                "Location": "RewardDistributor.sol#L181",
                "Type": "Sending ether with transfer",
                "Description": "Sending ether with the transfer is no longer recommended.",
                "Repair": "Use call instead of transfer to send ether and check return value"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBTRFLY is IERC20 {\n    function burn(uint256 amount) external;\n\n    function decimals() external view returns (uint8);\n}\n\ninterface IRedactedTreasury {\n    function manage(address _token, uint256 _amount) external;\n}\n\ninterface ICurveCryptoPool {\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount)\n        external\n        payable;\n\n    function calc_token_amount(uint256[2] calldata amounts)\n        external\n        view\n        returns (uint256);\n\n    // Would be replaced by Chainlink based oracle\n    function price_oracle() external view returns (uint256);\n\n    function token() external view returns (address);\n}\n\ncontract ThecosomataETH is Ownable {\n    address public immutable BTRFLY;\n    address public immutable WETH;\n    address public immutable CURVEPOOL;\n    address public immutable TREASURY;\n\n    uint256 private immutable _btrflyDecimals;\n    uint256 private immutable _ethDecimals;\n\n    uint256 public slippage = 5; // in 1000th\n\n    event AddLiquidity(\n        uint256 ethLiquidity,\n        uint256 btrflyLiquidity,\n        uint256 btrflyBurned\n    );\n\n    constructor(\n        address _BTRFLY,\n        address _WETH,\n        address _TREASURY,\n        address _CURVEPOOL\n    ) {\n        require(_BTRFLY != address(0), \"Invalid BTRFLY address\");\n        BTRFLY = _BTRFLY;\n\n        require(_WETH != address(0), \"Invalid WETH address\");\n        WETH = _WETH;\n\n        require(_CURVEPOOL != address(0), \"Invalid POOL address\");\n        CURVEPOOL = _CURVEPOOL;\n\n        require(_TREASURY != address(0), \"Invalid TREASURY address\");\n        TREASURY = _TREASURY;\n\n        IERC20(_BTRFLY).approve(_CURVEPOOL, 2**256 - 1);\n        IERC20(_WETH).approve(_CURVEPOOL, 2**256 - 1);\n\n        _btrflyDecimals = IBTRFLY(_BTRFLY).decimals();\n        _ethDecimals = IBTRFLY(_WETH).decimals();\n    }\n\n    // Update slippage percentage (in 1000th)\n    function setSlippage(uint256 _slippage) external onlyOwner {\n        // Make sure the slippage is less than 10%\n        require(_slippage < 100, \"Slippage too high\");\n        slippage = _slippage;\n    }\n\n    // Return whether we should perform an upkeep based on the contract's BTRFLY balance\n    function checkUpkeep()\n        public\n        view\n        returns (bool upkeepNeeded)\n    {\n        if (IBTRFLY(BTRFLY).balanceOf(address(this)) > 0) {\n            return true;\n        }\n    }\n\n    // Fetch the equivalent value of either specified BTRFLY/ETH amount\n    function calculateAmountRequiredForLP(uint256 amount, bool isBTRFLY)\n        internal\n        view\n        returns (uint256)\n    {\n        // Default price is based off \"1 BTRFLY = X ETH\", in 10^18 format\n        uint256 priceOracle = ICurveCryptoPool(CURVEPOOL).price_oracle();\n\n        if (isBTRFLY) {\n            return (((amount * priceOracle) / (10**18)) * (10**_ethDecimals)) /\n                (10**_btrflyDecimals);\n        }\n\n        return\n            (((amount * (10**18)) / priceOracle) *\n                (10**_btrflyDecimals)) / (10**_ethDecimals);\n    }\n\n    // Calculate the min. LP token amount (after slippage) and attempt to add liquidity\n    function addLiquidity(uint256 ethAmount, uint256 btrflyAmount) internal {\n        uint256[2] memory amounts = [ethAmount, btrflyAmount];\n        uint256 expectedAmount = ICurveCryptoPool(CURVEPOOL).calc_token_amount(\n            amounts\n        );\n        uint256 minAmount = expectedAmount - ((expectedAmount * slippage) / 1000);\n\n        ICurveCryptoPool(CURVEPOOL).add_liquidity(amounts, minAmount);\n    }\n\n    // Perform the actual upkeep flow\n    function performUpkeep() external onlyOwner {\n        require(checkUpkeep(), \"Invalid upkeep state\");\n\n        uint256 btrfly = IBTRFLY(BTRFLY).balanceOf(address(this));\n        uint256 ethAmount = calculateAmountRequiredForLP(btrfly, true);\n        uint256 ethCap = IERC20(WETH).balanceOf(TREASURY);\n        uint256 ethLiquidity = ethCap > ethAmount ? ethAmount : ethCap;\n\n        // Use BTRFLY balance if remaining capacity is enough, otherwise, calculate BTRFLY amount\n        uint256 btrflyLiquidity = ethCap > ethAmount\n            ? btrfly\n            : calculateAmountRequiredForLP(ethLiquidity, false);\n\n        IRedactedTreasury(TREASURY).manage(WETH, ethLiquidity);\n\n        // Only complete upkeep only on sufficient amounts\n        require(ethLiquidity > 0 && btrflyLiquidity > 0, \"Insufficient amounts\");\n        addLiquidity(ethLiquidity, btrflyLiquidity);\n\n        // Transfer out the pool token to treasury\n        address token = ICurveCryptoPool(CURVEPOOL).token();\n        uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n        IERC20(token).transfer(TREASURY, tokenBalance);\n\n        uint256 unusedBTRFLY = IBTRFLY(BTRFLY).balanceOf(address(this));\n\n        if (unusedBTRFLY > 0) {\n            IBTRFLY(BTRFLY).burn(unusedBTRFLY);\n        }\n\n        emit AddLiquidity(ethLiquidity, btrflyLiquidity, unusedBTRFLY);\n    }\n\n    // Withdraw arbitrary token and amount owned by the contract\n    function withdraw(\n        address token,\n        uint256 amount,\n        address recipient\n    ) external onlyOwner {\n        require(recipient != address(0), \"Invalid recipient\");\n        IERC20(token).transfer(recipient, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "ThecosomataETH.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ThecosomataETH.withdraw",
                "Type": "Admin Privilege",
                "Description": "The function withdraw is a clear rug-vector, allowing the owner to steal all funds. The multisig can move the funds at any time, technically can frontrun the keeper and steal the funds. It is recommended to limit the withdrawal to specific tokens and roles to reduce trust.",
                "Repair": "Limit the tokens or the amounts that the owner can withdraw and disclose the level of admin privilege and the risk it can cause to your users and depositors. Refactor the code to reduce it."
            },
            {
                "Location": "ThecosomataETH.addLiquidity function",
                "Type": "Wrong slippage check",
                "Description": "The slippage check is unnecessary and can lead to value extraction. The calc_token_amount function already takes slippage into account. If the pool is imbalanced, the calc_token_amount will already return a wrong amount and the additional slippage check on the wrong amount is unnecessary.",
                "Repair": "Compute the minimum expected LP tokens off-chain and pass them to the performUpkeep function as a parameter to prevent sandwich attacks. Use Chainlink Price Feed to get an accurate price or provide the price as a parameter."
            },
            {
                "Location": "ThecosomataETH.sol#L94-L110",
                "Type": "Oracle manipulation",
                "Description": "It is unclear how resistant the EMA oracle is against manipulation. Flash loan attacks, while possible, will be ineffective because t will be zero (pLast will be ignored in the update). However, a sophisticated attacker could possibly skew the price oracle by inflating the price of BTRFLY a couple of blocks before the performUpkeep() transaction to get the treasury to deposit more ETH / burn more BTRFLY than necessary.",
                "Repair": "1. Ensuring that the price was updated within a certain limit. 2. Checking that the last reported price pLast has not deviated too far from the current oracle price p_old."
            }
        ]
    }
]