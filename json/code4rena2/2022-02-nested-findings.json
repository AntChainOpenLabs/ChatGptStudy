[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    using SafeERC20 for IERC20;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 operatorsLength = operators.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operators[i] == operator) {\n                operators[i] = operators[operatorsLength - 1];\n                operators.pop();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        _token.safeTransfer(owner(), amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(tokens[i]), amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = amountBought / 100; // 1% Fee\n        amountBought -= amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = nestedRecords.getAssetHolding(_nftId, token);\n        reserve.withdraw(IERC20(token), amount);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = amountSpent / 100; // 1% Fee\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n\n        uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n        if (underSpentAmount != 0) {\n            tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n        }\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                _inputToken.safeTransfer(address(reserve), underSpentAmount);\n            }\n\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n        feesAmount = amountBought / 100; // 1% Fee\n\n        if (_toReserve) {\n            _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\");\n            if (_amountToSpend > amounts[1]) {\n                IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        _token.safeTransfer(reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    ///         The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(IERC20(_inputToken), _inputTokenAmount);\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _amount / 100; // 1% Fee\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NestedFactory.sol#L71, NestedFactory.sol#L286-L296, NestedFactory.sol#L370-L375, NestedFactory.sol#L482-L492",
                "Type": "Accidental ETH transfer",
                "Description": "Should a user accidentally send ETH to the NestedFactory, anyone can utilise it to their own benefit by calling processOutputOrders() / processInputAndOutputOrders().",
                "Repair": "Restrict the sender to be 'weth' in receive() function or add a check that _fromReserve is false in the scenario address(_inputToken) == ETH"
            },
            {
                "Location": "NestedFactory.sol#L446",
                "Type": "Fee avoidance",
                "Description": "A user can destroy their NFTs and not pay fees on most of their assets.",
                "Repair": "Replace the safeTransfer with your safeTransferWithFees function or set a maximum 'slippage' amount in the safeSubmitOrder function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"./abstracts/OwnableFactoryHandler.sol\";\n\n/// @title Tracks data for underlying assets of NestedNFTs\ncontract NestedRecords is OwnableFactoryHandler {\n    /* ------------------------------ EVENTS ------------------------------ */\n\n    /// @dev Emitted when maxHoldingsCount is updated\n    /// @param maxHoldingsCount The new value\n    event MaxHoldingsChanges(uint256 maxHoldingsCount);\n\n    /// @dev Emitted when the lock timestamp of an NFT is increased\n    /// @param nftId The NFT ID\n    /// @param timestamp The new lock timestamp of the portfolio\n    event LockTimestampIncreased(uint256 nftId, uint256 timestamp);\n\n    /// @dev Emitted when the reserve is updated for a specific portfolio\n    /// @param nftId The NFT ID\n    /// @param newReserve The new reserve address\n    event reserveUpdated(uint256 nftId, address newReserve);\n\n    /* ------------------------------ STRUCTS ------------------------------ */\n\n    /// @dev Store user asset informations\n    struct NftRecord {\n        mapping(address => uint256) holdings;\n        address[] tokens;\n        address reserve;\n        uint256 lockTimestamp;\n    }\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    /// @dev stores for each NFT ID an asset record\n    mapping(uint256 => NftRecord) public records;\n\n    /// @dev The maximum number of holdings for an NFT record\n    uint256 public maxHoldingsCount;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(uint256 _maxHoldingsCount) {\n        maxHoldingsCount = _maxHoldingsCount;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @notice Sets the maximum number of holdings for an NFT record\n    /// @param _maxHoldingsCount The new maximum number of holdings\n    function setMaxHoldingsCount(uint256 _maxHoldingsCount) external onlyOwner {\n        require(_maxHoldingsCount != 0, \"NRC: INVALID_MAX_HOLDINGS\");\n        maxHoldingsCount = _maxHoldingsCount;\n        emit MaxHoldingsChanges(maxHoldingsCount);\n    }\n\n    /* ------------------------- FACTORY FUNCTIONS ------------------------- */\n\n    /// @notice Update the amount for a specific holding and delete\n    /// the holding if the amount is zero.\n    /// @param _nftId The id of the NFT\n    /// @param _token The token/holding address\n    /// @param _amount Updated amount for this asset\n    function updateHoldingAmount(\n        uint256 _nftId,\n        address _token,\n        uint256 _amount\n    ) public onlyFactory {\n        if (_amount == 0) {\n            uint256 tokenIndex = 0;\n            address[] memory tokens = getAssetTokens(_nftId);\n            while (tokenIndex < tokens.length) {\n                if (tokens[tokenIndex] == _token) {\n                    deleteAsset(_nftId, tokenIndex);\n                    break;\n                }\n                tokenIndex++;\n            }\n        } else {\n            records[_nftId].holdings[_token] = _amount;\n        }\n    }\n\n    /// @notice Fully delete a holding record for an NFT\n    /// @param _nftId The id of the NFT\n    /// @param _tokenIndex The token index in holdings array\n    function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory {\n        address[] storage tokens = records[_nftId].tokens;\n        address token = tokens[_tokenIndex];\n\n        require(records[_nftId].holdings[token] != 0, \"NRC: HOLDING_INACTIVE\");\n\n        delete records[_nftId].holdings[token];\n        tokens[_tokenIndex] = tokens[tokens.length - 1];\n        tokens.pop();\n    }\n\n    /// @notice Delete a holding item in holding mapping. Does not remove token in NftRecord.tokens array\n    /// @param _nftId NFT's identifier\n    /// @param _token Token address for holding to remove\n    function freeHolding(uint256 _nftId, address _token) public onlyFactory {\n        delete records[_nftId].holdings[_token];\n    }\n\n    /// @notice Helper function that creates a record or add the holding if record already exists\n    /// @param _nftId The NFT's identifier\n    /// @param _token The token/holding address\n    /// @param _amount Amount to add for this asset\n    /// @param _reserve Reserve address\n    function store(\n        uint256 _nftId,\n        address _token,\n        uint256 _amount,\n        address _reserve\n    ) external onlyFactory {\n        uint256 amount = records[_nftId].holdings[_token];\n        if (amount != 0) {\n            require(records[_nftId].reserve == _reserve, \"NRC: RESERVE_MISMATCH\");\n            updateHoldingAmount(_nftId, _token, amount + _amount);\n            return;\n        }\n        require(records[_nftId].tokens.length < maxHoldingsCount, \"NRC: TOO_MANY_TOKENS\");\n        require(\n            _reserve != address(0) && (_reserve == records[_nftId].reserve || records[_nftId].reserve == address(0)),\n            \"NRC: INVALID_RESERVE\"\n        );\n\n        records[_nftId].holdings[_token] = _amount;\n        records[_nftId].tokens.push(_token);\n        records[_nftId].reserve = _reserve;\n    }\n\n    /// @notice The factory can update the lock timestamp of a NFT record\n    /// The new timestamp must be greater than the records lockTimestamp\n    //  if block.timestamp > actual lock timestamp\n    /// @param _nftId The NFT id to get the record\n    /// @param _timestamp The new timestamp\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external onlyFactory {\n        require(_timestamp > records[_nftId].lockTimestamp, \"NRC: LOCK_PERIOD_CANT_DECREASE\");\n        records[_nftId].lockTimestamp = _timestamp;\n        emit LockTimestampIncreased(_nftId, _timestamp);\n    }\n\n    /// @notice Delete from mapping assetTokens\n    /// @param _nftId The id of the NFT\n    function removeNFT(uint256 _nftId) external onlyFactory {\n        delete records[_nftId];\n    }\n\n    /// @notice Set the reserve where assets are stored\n    /// @param _nftId The NFT ID to update\n    /// @param _nextReserve Address for the new reserve\n    function setReserve(uint256 _nftId, address _nextReserve) external onlyFactory {\n        records[_nftId].reserve = _nextReserve;\n        emit reserveUpdated(_nftId, _nextReserve);\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get content of assetTokens mapping\n    /// @param _nftId The id of the NFT>\n    function getAssetTokens(uint256 _nftId) public view returns (address[] memory) {\n        return records[_nftId].tokens;\n    }\n\n    /// @notice Get reserve the assets are stored in\n    /// @param _nftId The NFT ID\n    /// @return The reserve address these assets are stored in\n    function getAssetReserve(uint256 _nftId) external view returns (address) {\n        return records[_nftId].reserve;\n    }\n\n    /// @notice Get how many tokens are in a portfolio/NFT\n    /// @param _nftId NFT ID to examine\n    /// @return The array length\n    function getAssetTokensLength(uint256 _nftId) public view returns (uint256) {\n        return records[_nftId].tokens.length;\n    }\n\n    /// @notice Get holding object for this NFT ID\n    /// @param _nftId The id of the NFT\n    /// @param _token The address of the token\n    function getAssetHolding(uint256 _nftId, address _token) public view returns (uint256) {\n        return records[_nftId].holdings[_token];\n    }\n\n    /// @notice Returns the holdings associated to a NestedAsset\n    /// @param _nftId the id of the NestedAsset\n    /// @return The holdings\n    function tokenHoldings(uint256 _nftId) public view returns (address[] memory, uint256[] memory) {\n        address[] memory tokens = getAssetTokens(_nftId);\n        uint256 tokensCount = tokens.length;\n        uint256[] memory amounts = new uint256[](tokensCount);\n\n        for (uint256 i = 0; i < tokensCount; i++) {\n            amounts[i] = getAssetHolding(_nftId, tokens[i]);\n        }\n        return (tokens, amounts);\n    }\n\n    /// @notice Get the lock timestamp of a portfolio/NFT\n    /// @param _nftId The NFT ID\n    /// @return The lock timestamp from the NftRecord\n    function getLockTimestamp(uint256 _nftId) external view returns (uint256) {\n        return records[_nftId].lockTimestamp;\n    }\n}\n\n\n",
        "CodeNames": [
            "NestedRecords.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NestedRecords.sol#L117-L131",
                "Type": "Undesired behavior",
                "Description": "You push a parameter into an array of tokens without checking if it already exists. And, if at first it's added with amount 0, it can later on be pushed with a greater amount and be twice in the array.",
                "Repair": "Check if the parameter already exists before pushing it into the array of tokens"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"./interfaces/IOperatorResolver.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Operator Resolver implementation\n/// @notice Resolve the operators address\ncontract OperatorResolver is IOperatorResolver, Ownable {\n    /// @dev Operators map of the name and address\n    mapping(bytes32 => Operator) public operators;\n\n    /// @inheritdoc IOperatorResolver\n    function getOperator(bytes32 name) external view override returns (Operator memory) {\n        return operators[name];\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function requireAndGetOperator(bytes32 name, string calldata reason)\n        external\n        view\n        override\n        returns (Operator memory)\n    {\n        Operator memory _foundOperator = operators[name];\n        require(_foundOperator.implementation != address(0), reason);\n        return _foundOperator;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\n        external\n        view\n        override\n        returns (bool)\n    {\n        uint256 namesLength = names.length;\n        require(namesLength == destinations.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        for (uint256 i = 0; i < namesLength; i++) {\n            if (\n                operators[names[i]].implementation != destinations[i].implementation &&\n                operators[names[i]].selector != destinations[i].selector\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @inheritdoc IOperatorResolver\n    function importOperators(\n        bytes32[] calldata names,\n        Operator[] calldata operatorsToImport,\n        MixinOperatorResolver[] calldata destinations\n    ) external override onlyOwner {\n        require(names.length == operatorsToImport.length, \"OR: INPUTS_LENGTH_MUST_MATCH\");\n        bytes32 name;\n        Operator calldata destination;\n        for (uint256 i = 0; i < names.length; i++) {\n            name = names[i];\n            destination = operatorsToImport[i];\n            operators[name] = destination;\n            emit OperatorImported(name, destination);\n        }\n\n        // rebuild caches atomically\n        // see. https://github.com/code-423n4/2021-11-nested-findings/issues/217\n        rebuildCaches(destinations);\n    }\n\n    /// @notice rebuild the caches of mixin smart contracts\n    /// @param destinations The list of mixinOperatorResolver to rebuild\n    function rebuildCaches(MixinOperatorResolver[] calldata destinations) public {\n        for (uint256 i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "OperatorResolver.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "OperatorResolver.sol#L42-L43",
                "Type": "Incorrect logic",
                "Description": "The logic related to the areOperatorsImported method is incorrect and can cause an operator not to be updated because the owner thinks it is already updated, and a vulnerable or defective one can be used.",
                "Repair": "Change && by ||"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"../OperatorResolver.sol\";\nimport \"../interfaces/IOperatorResolver.sol\";\nimport \"../interfaces/INestedFactory.sol\";\n\n/// @title Mixin operator resolver\n/// @notice Store in cache operators name and address/selector\nabstract contract MixinOperatorResolver {\n    /// @notice Emitted when cache is updated\n    /// @param name The operator name\n    /// @param destination The operator address\n    event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination);\n\n    /// @dev The OperatorResolver used to build the cache\n    OperatorResolver public immutable resolver;\n\n    /// @dev Cache operators map of the name and Operator struct (address/selector)\n    mapping(bytes32 => IOperatorResolver.Operator) private operatorCache;\n\n    constructor(address _resolver) {\n        resolver = OperatorResolver(_resolver);\n    }\n\n    /// @dev This function is public not external in order for it to be overridden and\n    ///      invoked via super in subclasses\n    function resolverOperatorsRequired() public view virtual returns (bytes32[] memory) {}\n\n    /// @notice Rebuild the operatorCache\n    function rebuildCache() external {\n        bytes32[] memory requiredOperators = resolverOperatorsRequired();\n        bytes32 name;\n        IOperatorResolver.Operator memory destination;\n        // The resolver must call this function whenever it updates its state\n        for (uint256 i = 0; i < requiredOperators.length; i++) {\n            name = requiredOperators[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            destination = resolver.getOperator(name);\n            if (destination.implementation != address(0)) {\n                operatorCache[name] = destination;\n            } else {\n                delete operatorCache[name];\n            }\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /// @notice Check the state of operatorCache\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredOperators = resolverOperatorsRequired();\n        bytes32 name;\n        IOperatorResolver.Operator memory cacheTmp;\n        IOperatorResolver.Operator memory actualValue;\n        for (uint256 i = 0; i < requiredOperators.length; i++) {\n            name = requiredOperators[i];\n            cacheTmp = operatorCache[name];\n            actualValue = resolver.getOperator(name);\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (\n                actualValue.implementation != cacheTmp.implementation ||\n                actualValue.selector != cacheTmp.selector ||\n                cacheTmp.implementation == address(0)\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @dev Get operator address in cache and require (if exists)\n    /// @param name The operator name\n    /// @return The operator address\n    function requireAndGetAddress(bytes32 name) internal view returns (IOperatorResolver.Operator memory) {\n        IOperatorResolver.Operator memory _foundAddress = operatorCache[name];\n        require(_foundAddress.implementation != address(0), string(abi.encodePacked(\"MOR: MISSING_OPERATOR: \", name)));\n        return _foundAddress;\n    }\n\n    /// @dev Build the calldata (with safe datas) and call the Operator\n    /// @param _order The order to execute\n    /// @return success If the operator call is successful\n    /// @return amounts The amounts from the execution (used and received)\n    ///         - amounts[0] : The amount of output token\n    ///         - amounts[1] : The amount of input token USED by the operator (can be different than expected)\n    function callOperator(\n        INestedFactory.Order calldata _order,\n        address _inputToken,\n        address _outputToken\n    ) internal returns (bool success, uint256[] memory amounts) {\n        IOperatorResolver.Operator memory _operator = requireAndGetAddress(_order.operator);\n        // Parameters are concatenated and padded to 32 bytes.\n        // We are concatenating the selector + given params\n        bytes memory data;\n        (success, data) = _operator.implementation.delegatecall(bytes.concat(_operator.selector, _order.callData));\n\n        if (success) {\n            address[] memory tokens;\n            (amounts, tokens) = abi.decode(data, (uint256[], address[]));\n            require(tokens[0] == _outputToken, \"OH: INVALID_OUTPUT_TOKEN\");\n            require(tokens[1] == _inputToken, \"OH: INVALID_OUTPUT_TOKEN\");\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.11;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./abstracts/OwnableProxyDelegation.sol\";\nimport \"./abstracts/MixinOperatorResolver.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets (portfolios).\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\n    using SafeERC20 for IERC20;\n\n    /* ----------------------------- VARIABLES ----------------------------- */\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public immutable reserve;\n\n    /// @dev Current nested asset (ERC721) contract/address\n    NestedAsset public immutable nestedAsset;\n\n    /// @dev Wrapped Ether contract/address\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\n    IWETH public immutable weth;\n\n    /// @dev Current records contract/address\n    NestedRecords public immutable nestedRecords;\n\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        NestedReserve _reserve,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        require(\n            address(_nestedAsset) != address(0) &&\n                address(_nestedRecords) != address(0) &&\n                address(_reserve) != address(0) &&\n                address(_feeSplitter) != address(0) &&\n                address(_weth) != address(0) &&\n                _operatorResolver != address(0),\n            \"NF: INVALID_ADDRESS\"\n        );\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        reserve = _reserve;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /* ------------------------------ MODIFIERS ---------------------------- */\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NF: CALLER_NOT_OWNER\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NF: LOCKED_NFT\");\n        _;\n    }\n\n    /* ------------------------------- VIEWS ------------------------------- */\n\n    /// @notice Get the required operators\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\n        return operators;\n    }\n\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");\n        bytes32[] memory operatorsCache = operators;\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\n            require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");\n        }\n        operators.push(operator);\n        emit OperatorAdded(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 operatorsLength = operators.length;\n        for (uint256 i = 0; i < operatorsLength; i++) {\n            if (operators[i] == operator) {\n                operators[i] = operators[operatorsLength - 1];\n                operators.pop();\n                emit OperatorRemoved(operator);\n                return;\n            }\n        }\n        revert(\"NF: NON_EXISTENT_OPERATOR\");\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NF: INVALID_FEE_SPLITTER_ADDRESS\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function unlockTokens(IERC20 _token) external override onlyOwner {\n        uint256 amount = _token.balanceOf(address(this));\n        _token.safeTransfer(owner(), amount);\n        emit TokensUnlocked(address(_token), amount);\n    }\n\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\n\n    /// @inheritdoc INestedFactory\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n\n        _checkMsgValue(_batchedOrders);\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        }\n\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\n        external\n        payable\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _checkMsgValue(_batchedOrders);\n        _processInputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        _processOutputOrders(_nftId, _batchedOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function processInputAndOutputOrders(\n        uint256 _nftId,\n        BatchedInputOrders[] calldata _batchedInputOrders,\n        BatchedOutputOrders[] calldata _batchedOutputOrders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        _checkMsgValue(_batchedInputOrders);\n        _processInputOrders(_nftId, _batchedInputOrders);\n        _processOutputOrders(_nftId, _batchedOutputOrders);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        uint256 tokensLength = tokens.length;\n        require(_orders.length != 0, \"NF: INVALID_ORDERS\");\n        require(tokensLength == _orders.length, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokensLength; i++) {\n            uint256 amount = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(tokens[i]), amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = amountBought / 100; // 1% Fee\n        amountBought -= amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NF: INVALID_TOKEN_INDEX\");\n        // Use destroy instead if NFT has a single holding\n        require(assetTokensLength > 1, \"NF: UNALLOWED_EMPTY_PORTFOLIO\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\n\n        uint256 amount = nestedRecords.getAssetHolding(_nftId, token);\n        reserve.withdraw(IERC20(token), amount);\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\n\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\n    }\n\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\n\n    /// @dev Internal logic extraction of processInputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].fromReserve\n            );\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        }\n    }\n\n    /// @dev Internal logic extraction of processOutputOrders()\n    /// @param _nftId The id of the NFT to update\n    /// @param _batchedOrders The order to execute\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\n        uint256 batchedOrdersLength = _batchedOrders.length;\n        require(batchedOrdersLength != 0, \"NF: INVALID_MULTI_ORDERS\");\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"NF: RESERVE_MISMATCH\");\n\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n                _nftId,\n                _batchedOrders[i],\n                _batchedOrders[i].toReserve\n            );\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\n            if (!_batchedOrders[i].toReserve) {\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\n            }\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit orders (where the input is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\n    /// @return feesAmount The total amount of fees on the input\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\n    function _submitInOrders(\n        uint256 _nftId,\n        BatchedInputOrders calldata _batchedOrders,\n        bool _fromReserve\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        uint256 _inputTokenAmount;\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\n            _nftId,\n            _batchedOrders.inputToken,\n            _batchedOrders.amount,\n            _fromReserve\n        );\n\n        uint256 amountSpent;\n        for (uint256 i = 0; i < batchLength; i++) {\n            amountSpent += _submitOrder(\n                address(tokenSold),\n                _batchedOrders.orders[i].token,\n                _nftId,\n                _batchedOrders.orders[i],\n                true // always to the reserve\n            );\n        }\n        feesAmount = amountSpent / 100; // 1% Fee\n        require(amountSpent <= _inputTokenAmount - feesAmount, \"NF: OVERSPENT\");\n\n        uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\n        if (underSpentAmount != 0) {\n            tokenSold.safeTransfer(_fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\n        }\n\n        // If input is from the reserve, update the records\n        if (_fromReserve) {\n            _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\n        }\n    }\n\n    /// @dev For every orders, call the operator with the calldata\n    /// to submit sell orders (where the output is one asset).\n    /// @param _nftId The id of the NFT impacted by the orders\n    /// @param _batchedOrders The order to process\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\n    /// @return feesAmount The total amount of fees on the output\n    /// @return amountBought The total amount bought\n    function _submitOutOrders(\n        uint256 _nftId,\n        BatchedOutputOrders calldata _batchedOrders,\n        bool _toReserve\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\n        uint256 batchLength = _batchedOrders.orders.length;\n        require(batchLength != 0, \"NF: INVALID_ORDERS\");\n        require(_batchedOrders.amounts.length == batchLength, \"NF: INPUTS_LENGTH_MUST_MATCH\");\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\n\n        IERC20 _inputToken;\n        uint256 _inputTokenAmount;\n        for (uint256 i = 0; i < _batchedOrders.orders.length; i++) {\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\n                _nftId,\n                IERC20(_batchedOrders.orders[i].token),\n                _batchedOrders.amounts[i],\n                true\n            );\n\n            // Submit order and update holding of spent token\n            uint256 amountSpent = _submitOrder(\n                address(_inputToken),\n                address(_batchedOrders.outputToken),\n                _nftId,\n                _batchedOrders.orders[i],\n                false\n            );\n            require(amountSpent <= _inputTokenAmount, \"NF: OVERSPENT\");\n\n            uint256 underSpentAmount = _inputTokenAmount - amountSpent;\n            if (underSpentAmount != 0) {\n                _inputToken.safeTransfer(address(reserve), underSpentAmount);\n            }\n\n            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\n        }\n\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\n        feesAmount = amountBought / 100; // 1% Fee\n\n        if (_toReserve) {\n            _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\n        }\n    }\n\n    /// @dev Call the operator to submit the order and add the output\n    /// assets to the reserve (if needed).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\n    function _submitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _nftId,\n        Order calldata _order,\n        bool _toReserve\n    ) private returns (uint256 amountSpent) {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        require(success, \"NF: OPERATOR_CALL_FAILED\");\n\n        if (_toReserve) {\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\n        }\n        amountSpent = amounts[1];\n    }\n\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\n    ///      It will send the input token back to the msg.sender.\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\n    ///        useless for the only use case (destroy).\n    /// @param _inputToken Token used to make the orders\n    /// @param _outputToken Expected output token\n    /// @param _amountToSpend The input amount available (to spend)\n    /// @param _nftId The nftId\n    /// @param _order The order calldata\n    function _safeSubmitOrder(\n        address _inputToken,\n        address _outputToken,\n        uint256 _amountToSpend,\n        uint256 _nftId,\n        Order calldata _order\n    ) private {\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\n        if (success) {\n            require(amounts[1] <= _amountToSpend, \"NestedFactory::_safeSubmitOrder: Overspent\");\n            if (_amountToSpend > amounts[1]) {\n                IERC20(_inputToken).safeTransfer(_msgSender(), _amountToSpend - amounts[1]);\n            }\n        } else {\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\n        }\n    }\n\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\n    /// in the records. We need to know the amount received in case of deflationary tokens.\n    /// @param _token The token to transfer (IERC20)\n    /// @param _amount The amount to send to the reserve\n    /// @param _nftId The Token ID to store the assets\n    function _transferToReserveAndStore(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _nftId\n    ) private {\n        address reserveAddr = address(reserve);\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\n\n        // Send output to reserve\n        _token.safeTransfer(reserveAddr, _amount);\n\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\n\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\n    }\n\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\n    ///      or the user wallet, to the factory.\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token to receive\n    /// @param _inputTokenAmount Amount to transfer\n    /// @param _fromReserve True to transfer from the reserve\n    /// @return Token transfered (in case of ETH)\n    ///         The real amount received after the transfer to the factory\n    function _transferInputTokens(\n        uint256 _nftId,\n        IERC20 _inputToken,\n        uint256 _inputTokenAmount,\n        bool _fromReserve\n    ) private returns (IERC20, uint256) {\n        if (address(_inputToken) == ETH) {\n            require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");\n            weth.deposit{ value: _inputTokenAmount }();\n            return (IERC20(address(weth)), _inputTokenAmount);\n        }\n\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\n        if (_fromReserve) {\n            require(\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\n                \"NF: INSUFFICIENT_AMOUNT_IN\"\n            );\n            // Get input from reserve\n            reserve.withdraw(IERC20(_inputToken), _inputTokenAmount);\n        } else {\n            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);\n        }\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\n    }\n\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\n    /// @param _amount Amount to send\n    /// @param _token Token to send\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\n    function _transferFeeWithRoyalty(\n        uint256 _amount,\n        IERC20 _token,\n        uint256 _nftId\n    ) private {\n        address originalOwner = nestedAsset.originalOwner(_nftId);\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\n        if (originalOwner != address(0)) {\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\n        } else {\n            feeSplitter.sendFees(_token, _amount);\n        }\n    }\n\n    /// @dev Decrease the amount of a NFT holding\n    /// @param _nftId The NFT id\n    /// @param _inputToken The token holding\n    /// @param _amount The amount to subtract from the actual holding amount\n    function _decreaseHoldingAmount(\n        uint256 _nftId,\n        address _inputToken,\n        uint256 _amount\n    ) private {\n        nestedRecords.updateHoldingAmount(\n            _nftId,\n            _inputToken,\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\n        );\n    }\n\n    /// @dev Transfer a token amount from the factory to the recipient.\n    ///      The token is unwrapped if WETH.\n    /// @param _token The token to transfer\n    /// @param _amount The amount to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferAndUnwrap(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest\n    ) private {\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\n        if (address(_token) == address(weth)) {\n            IWETH(weth).withdraw(_amount);\n            (bool success, ) = _dest.call{ value: _amount }(\"\");\n            require(success, \"NF: ETH_TRANSFER_ERROR\");\n        } else {\n            _token.safeTransfer(_dest, _amount);\n        }\n    }\n\n    /// @dev Transfer from factory and collect fees\n    /// @param _token The token to transfer\n    /// @param _amount The amount (with fees) to transfer\n    /// @param _dest The address receiving the funds\n    function _safeTransferWithFees(\n        IERC20 _token,\n        uint256 _amount,\n        address _dest,\n        uint256 _nftId\n    ) private {\n        uint256 feeAmount = _amount / 100; // 1% Fee\n        _transferFeeWithRoyalty(feeAmount, _token, _nftId);\n        _token.safeTransfer(_dest, _amount - feeAmount);\n    }\n\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\n    /// @param _batchedOrders The batched input orders\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\n        uint256 ethNeeded;\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\n            if (address(_batchedOrders[i].inputToken) == ETH) {\n                ethNeeded += _batchedOrders[i].amount;\n            }\n        }\n        require(msg.value == ethNeeded, \"NF: WRONG_MSG_VALUE\");\n    }\n}\n\n\n",
        "CodeNames": [
            "MixinOperatorResolver.sol",
            "NestedFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NestedFactory.sol#L99-L108, MixinOperatorResolver.sol#L30-L47, NestedFactory.sol#L110-L122, MixinOperatorResolver.sol#L49-L55",
                "Type": "Operator tracking problem",
                "Description": "The NestedFactory does not track operators properly, causing inconsistency issues in the cache and leading to incorrect assumptions in core operations.",
                "Repair": "Add calls to rebuildCache() in addOperator() and removeOperator(), have INestedFactory also track operators that have been removed with a new array, and have isResolverCached() also check whether this new array is empty or not."
            }
        ]
    }
]