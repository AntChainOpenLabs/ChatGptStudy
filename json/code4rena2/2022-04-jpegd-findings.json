[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault\n/// @notice Allows users to deposit fungible assets into autocompounding strategy contracts (e.g. {StrategyPUSDConvex}).\n/// Non whitelisted contracts can't deposit/withdraw.\n/// Owner is DAO\ncontract YVault is ERC20, Ownable {\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    event Deposit(address indexed depositor, uint256 wantAmount);\n    event Withdrawal(address indexed withdrawer, uint256 wantAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    ERC20 public immutable token;\n    IController public controller;\n    \n    address public farm;\n    \n    Rate internal availableTokensRate;\n\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _token The token managed by this vault\n    /// @param _controller The JPEG'd strategies controller\n    constructor(\n        address _token,\n        address _controller,\n        Rate memory _availableTokensRate\n    )\n        ERC20(\n            string(\n                abi.encodePacked(\"JPEG\\xE2\\x80\\x99d \", ERC20(_token).name())\n            ),\n            string(abi.encodePacked(\"JPEGD\", ERC20(_token).symbol()))\n        )\n    {\n        setController(_controller);\n        setAvailableTokensRate(_availableTokensRate);\n        token = ERC20(_token);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the vault.\n    /// Prevents non-whitelisted 3rd party contracts from diluting stakers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts not allowed\"\n        );\n        _;\n    }\n\n    /// @inheritdoc ERC20\n    function decimals() public view virtual override returns (uint8) {\n        return token.decimals();\n    }\n\n    /// @return The total amount of tokens managed by this vault and the underlying strategy\n    function balance() public view returns (uint256) {\n        return\n            token.balanceOf(address(this)) +\n            controller.balanceOf(address(token));\n    }\n\n    // @return The amount of JPEG tokens claimable by {YVaultLPFarming}\n    function balanceOfJPEG() external view returns (uint256) {\n        return controller.balanceOfJPEG(address(token));\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to set the rate of tokens held by this contract that the underlying strategy should be able to borrow\n    /// @param _rate The new rate\n    function setAvailableTokensRate(Rate memory _rate) public onlyOwner {\n        require(\n            _rate.numerator > 0 && _rate.denominator >= _rate.numerator,\n            \"INVALID_RATE\"\n        );\n        availableTokensRate = _rate;\n    }\n\n    /// @notice ALlows the owner to set this vault's controller\n    /// @param _controller The new controller\n    function setController(address _controller) public onlyOwner {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        controller = IController(_controller);\n    }\n\n    /// @notice Allows the owner to set the yVault LP farm\n    /// @param _farm The new farm\n    function setFarmingPool(address _farm) public onlyOwner {\n        require(_farm != address(0), \"INVALID_FARMING_POOL\");\n        farm = _farm;\n    }\n\n    /// @return How much the vault allows to be borrowed by the underlying strategy.\n    /// Sets minimum required on-hand to keep small withdrawals cheap\n    function available() public view returns (uint256) {\n        return\n            (token.balanceOf(address(this)) * availableTokensRate.numerator) /\n            availableTokensRate.denominator;\n    }\n\n    /// @notice Deposits `token` into the underlying strategy\n    function earn() external {\n        uint256 _bal = available();\n        token.safeTransfer(address(controller), _bal);\n        controller.earn(address(token), _bal);\n    }\n\n    /// @notice Allows users to deposit their entire `token` balance\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to deposit `token`. Contracts can't call this function\n    /// @param _amount The amount to deposit\n    function deposit(uint256 _amount) public noContract(msg.sender) {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        uint256 balanceBefore = balance();\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 supply = totalSupply();\n        uint256 shares;\n        if (supply == 0) {\n            shares = _amount;\n        } else {\n            //balanceBefore can't be 0 if totalSupply is > 0\n            shares = (_amount * supply) / balanceBefore;\n        }\n        _mint(msg.sender, shares);\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw all their deposited balance\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to withdraw tokens. Contracts can't call this function\n    /// @param _shares The amount of shares to burn\n    function withdraw(uint256 _shares) public noContract(msg.sender) {\n        require(_shares > 0, \"INVALID_AMOUNT\");\n\n        uint256 supply = totalSupply();\n        require(supply > 0, \"NO_TOKENS_DEPOSITED\");\n\n        uint256 backingTokens = (balance() * _shares) / supply;\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 vaultBalance = token.balanceOf(address(this));\n        if (vaultBalance < backingTokens) {\n            uint256 toWithdraw = backingTokens - vaultBalance;\n            controller.withdraw(address(token), toWithdraw);\n        }\n\n        token.safeTransfer(msg.sender, backingTokens);\n        emit Withdrawal(msg.sender, backingTokens);\n    }\n\n    /// @notice Allows anyone to withdraw JPEG to `farm` \n    function withdrawJPEG() external {\n        require(farm != address(0), \"NO_FARM\");\n        controller.withdrawJPEG(address(token), farm);\n    }\n\n    /// @return The underlying tokens per share\n    function getPricePerFullShare() external view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) return 0;\n        return (balance() * 1e18) / supply;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n",
        "CodeNames": [
            "yVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "yVault.sol#L144-L145",
                "Type": "Reentrancy",
                "Description": "In deposit, the balance is cached and then a token.transferFrom is triggered which can lead to exploits if the token is a token that gives control to the sender, like ERC777 tokens.",
                "Repair": "Make safeTransferFrom the last call in deposit"
            },
            {
                "Location": "yVault.sol#L148-L153",
                "Type": "Share Dilution",
                "Description": "yVault: First depositor can break minting of shares.",
                "Repair": "Send the first min liquidity LP tokens to the zero address to enable share dilution. Ensure the number of shares to be minted is non-zero: require(_shares != 0, \"zero shares minted\");"
            },
            {
                "Location": "yVault.getPricePerFullShare() function",
                "Type": "Wrong calculation for yVault price per share if decimals != 18",
                "Description": "The price per share calculation does not return the correct price for underlying tokens that do not have 18 decimals. This could lead to paying out too little or too much and therefore to a loss for either the protocol or the user.",
                "Repair": "Use vault decimals() instead of hardcoded 1e18 decimals"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault token farm\n/// @notice Users can stake their JPEG'd vault tokens and earn JPEG rewards\n/// @dev The rewards are taken from the PUSD Convex pool and distributed to stakers based on their share of the total staked tokens.\ncontract YVaultLPFarming is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IYVault;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Claim(address indexed user, uint256 rewards);\n\n    IYVault public immutable vault;\n    IERC20 public immutable jpeg;\n\n    uint256 public totalStaked;\n\n    uint256 internal lastRewardBlock;\n    uint256 internal previousBalance;\n    uint256 internal accRewardPerShare;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => uint256) private userLastAccRewardPerShare;\n    mapping(address => uint256) private userPendingRewards;\n\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    ///@param _vault The yVault address\n    ///@param _jpeg The JPEG token address\n    constructor(address _vault, address _jpeg) {\n        require(_vault != address(0), \"INVALID_VAULT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n\n        vault = IYVault(_vault);\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting farmers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable by user `_user`\n    function pendingReward(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 rewardShare = accRewardPerShare;\n        uint256 staked = totalStaked;\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (block.number > lastRewardBlock && staked > 0) {\n            (rewardShare, ) = _computeUpdate();\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userPendingRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (balanceOf[_user] * (rewardShare - userLastAccRewardPerShare[_user])) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _amount The amount of tokens to deposit\n    function deposit(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        vault.safeTransferFrom(msg.sender, address(this), _amount);\n\n        balanceOf[msg.sender] += _amount;\n        totalStaked += _amount;\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _amount The amount of tokens to withdraw\n    function withdraw(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n        require(balanceOf[msg.sender] >= _amount, \"insufficient_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        balanceOf[msg.sender] -= _amount;\n        totalStaked -= _amount;\n\n        vault.safeTransfer(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to claim rewards. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    function claim() external noContract(msg.sender) {\n        _update();\n        _withdrawReward(msg.sender);\n\n        uint256 rewards = userPendingRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        userPendingRewards[msg.sender] = 0;\n        //we are subtracting the claimed rewards from the previous to have a consistent value next time\n        //{_update is called}\n        previousBalance -= rewards;\n\n        if (jpeg.balanceOf(address(this)) < rewards)\n            vault.withdrawJPEG();\n\n        jpeg.safeTransfer(msg.sender, rewards);\n\n        emit Claim(msg.sender, rewards);\n    }\n\n    /// @dev Updates this contract's rewards state\n    function _update() internal {\n        if (block.number <= lastRewardBlock) return;\n\n        lastRewardBlock = block.number;\n\n        if (totalStaked == 0) return;\n\n        (accRewardPerShare, previousBalance) = _computeUpdate();\n    }\n\n    /// @dev Computes the updated contract state without writing storage\n    /// @return newAccRewardsPerShare The new value of `accRewardsPerShare`\n    /// @return currentBalance The new value of `previousBalance`\n    function _computeUpdate() internal view returns (uint256 newAccRewardsPerShare, uint256 currentBalance) {\n        currentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\n        uint256 newRewards = currentBalance - previousBalance;\n\n        newAccRewardsPerShare = accRewardPerShare + newRewards * 1e36 / totalStaked;\n    }\n\n    /// @dev Updates `account`'s claimable rewards by adding pending rewards\n    /// @param account The account to update\n    function _withdrawReward(address account) internal returns (uint256) {\n        uint256 pending = (balanceOf[account] *\n            (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36;\n\n        if (pending > 0) userPendingRewards[account] += pending;\n\n        userLastAccRewardPerShare[account] = accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault\n/// @notice Allows users to deposit fungible assets into autocompounding strategy contracts (e.g. {StrategyPUSDConvex}).\n/// Non whitelisted contracts can't deposit/withdraw.\n/// Owner is DAO\ncontract YVault is ERC20, Ownable {\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    event Deposit(address indexed depositor, uint256 wantAmount);\n    event Withdrawal(address indexed withdrawer, uint256 wantAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    ERC20 public immutable token;\n    IController public controller;\n    \n    address public farm;\n    \n    Rate internal availableTokensRate;\n\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _token The token managed by this vault\n    /// @param _controller The JPEG'd strategies controller\n    constructor(\n        address _token,\n        address _controller,\n        Rate memory _availableTokensRate\n    )\n        ERC20(\n            string(\n                abi.encodePacked(\"JPEG\\xE2\\x80\\x99d \", ERC20(_token).name())\n            ),\n            string(abi.encodePacked(\"JPEGD\", ERC20(_token).symbol()))\n        )\n    {\n        setController(_controller);\n        setAvailableTokensRate(_availableTokensRate);\n        token = ERC20(_token);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the vault.\n    /// Prevents non-whitelisted 3rd party contracts from diluting stakers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts not allowed\"\n        );\n        _;\n    }\n\n    /// @inheritdoc ERC20\n    function decimals() public view virtual override returns (uint8) {\n        return token.decimals();\n    }\n\n    /// @return The total amount of tokens managed by this vault and the underlying strategy\n    function balance() public view returns (uint256) {\n        return\n            token.balanceOf(address(this)) +\n            controller.balanceOf(address(token));\n    }\n\n    // @return The amount of JPEG tokens claimable by {YVaultLPFarming}\n    function balanceOfJPEG() external view returns (uint256) {\n        return controller.balanceOfJPEG(address(token));\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to set the rate of tokens held by this contract that the underlying strategy should be able to borrow\n    /// @param _rate The new rate\n    function setAvailableTokensRate(Rate memory _rate) public onlyOwner {\n        require(\n            _rate.numerator > 0 && _rate.denominator >= _rate.numerator,\n            \"INVALID_RATE\"\n        );\n        availableTokensRate = _rate;\n    }\n\n    /// @notice ALlows the owner to set this vault's controller\n    /// @param _controller The new controller\n    function setController(address _controller) public onlyOwner {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        controller = IController(_controller);\n    }\n\n    /// @notice Allows the owner to set the yVault LP farm\n    /// @param _farm The new farm\n    function setFarmingPool(address _farm) public onlyOwner {\n        require(_farm != address(0), \"INVALID_FARMING_POOL\");\n        farm = _farm;\n    }\n\n    /// @return How much the vault allows to be borrowed by the underlying strategy.\n    /// Sets minimum required on-hand to keep small withdrawals cheap\n    function available() public view returns (uint256) {\n        return\n            (token.balanceOf(address(this)) * availableTokensRate.numerator) /\n            availableTokensRate.denominator;\n    }\n\n    /// @notice Deposits `token` into the underlying strategy\n    function earn() external {\n        uint256 _bal = available();\n        token.safeTransfer(address(controller), _bal);\n        controller.earn(address(token), _bal);\n    }\n\n    /// @notice Allows users to deposit their entire `token` balance\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to deposit `token`. Contracts can't call this function\n    /// @param _amount The amount to deposit\n    function deposit(uint256 _amount) public noContract(msg.sender) {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        uint256 balanceBefore = balance();\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 supply = totalSupply();\n        uint256 shares;\n        if (supply == 0) {\n            shares = _amount;\n        } else {\n            //balanceBefore can't be 0 if totalSupply is > 0\n            shares = (_amount * supply) / balanceBefore;\n        }\n        _mint(msg.sender, shares);\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw all their deposited balance\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to withdraw tokens. Contracts can't call this function\n    /// @param _shares The amount of shares to burn\n    function withdraw(uint256 _shares) public noContract(msg.sender) {\n        require(_shares > 0, \"INVALID_AMOUNT\");\n\n        uint256 supply = totalSupply();\n        require(supply > 0, \"NO_TOKENS_DEPOSITED\");\n\n        uint256 backingTokens = (balance() * _shares) / supply;\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 vaultBalance = token.balanceOf(address(this));\n        if (vaultBalance < backingTokens) {\n            uint256 toWithdraw = backingTokens - vaultBalance;\n            controller.withdraw(address(token), toWithdraw);\n        }\n\n        token.safeTransfer(msg.sender, backingTokens);\n        emit Withdrawal(msg.sender, backingTokens);\n    }\n\n    /// @notice Allows anyone to withdraw JPEG to `farm` \n    function withdrawJPEG() external {\n        require(farm != address(0), \"NO_FARM\");\n        controller.withdrawJPEG(address(token), farm);\n    }\n\n    /// @return The underlying tokens per share\n    function getPricePerFullShare() external view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) return 0;\n        return (balance() * 1e18) / supply;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n",
        "CodeNames": [
            "yVaultLPFarming.sol",
            "yVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "yVault.sol#L61, yVaultLPFarming.sol#L54",
                "Type": "Improper Access Control",
                "Description": "The noContract modifier does not work as expected.",
                "Repair": "Modify the code to require(msg.sender == tx.origin);"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../interfaces/ISwapRouter.sol\";\nimport \"../../../interfaces/IUniswapV2Router.sol\";\nimport \"../../../interfaces/ICurve.sol\";\nimport \"../../../interfaces/IBooster.sol\";\nimport \"../../../interfaces/IBaseRewardPool.sol\";\n\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IFungibleAssetVaultForDAO.sol\";\n\n/// @title JPEG'd PUSD Convex autocompounding strategy\n/// @notice This strategy autocompounds Convex rewards from the PUSD/USDC/USDT/MIM Curve pool.\n/// @dev The strategy deposits either USDC or PUSD in the Curve pool depending on which one has lower liquidity.\n/// The strategy sells reward tokens for USDC. If the pool has less PUSD than USDC, this contract uses the\n/// USDC {FungibleAssetVaultForDAO} to mint PUSD using USDC as collateral\ncontract StrategyPUSDConvex is AccessControl {\n    using SafeERC20 for IERC20;\n\n    event Harvested(uint256 wantEarned);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    /// @param booster Convex Booster's address\n    /// @param baseRewardPool Convex BaseRewardPool's address\n    /// @param pid The Convex pool id for PUSD/USDC/USDT/MIM LP tokens\n    struct ConvexConfig {\n        IBooster booster;\n        IBaseRewardPool baseRewardPool;\n        uint256 pid;\n    }\n\n    /// @param curve Curve's PUSD/USDC/USDT/MIM pool address\n    /// @param usdcIndex The USDC token index in curve's pool\n    /// @param pusdIndex The PUSD token index in curve's pool\n    struct CurveConfig {\n        ICurve curve;\n        uint256 usdcIndex;\n        uint256 pusdIndex;\n    }\n\n    /// @param uniswapV2 The UniswapV2 (or Sushiswap) router address\n    /// @param uniswapV3 The UniswapV3 router address\n    struct DexConfig {\n        IUniswapV2Router uniswapV2;\n        ISwapRouter uniswapV3;\n    }\n\n    /// @param rewardTokens The Convex reward tokens\n    /// @param controller The strategy controller\n    /// @param usdcVault The JPEG'd USDC {FungibleAssetVaultForDAO} address\n    struct StrategyConfig {\n        IERC20[] rewardTokens;\n        IController controller;\n        IFungibleAssetVaultForDAO usdcVault;\n    }\n\n    bytes32 public constant STRATEGIST_ROLE = keccak256(\"STRATEGIST_ROLE\");\n\n    /// @notice The PUSD/USDC/USDT/MIM Curve LP token\n    IERC20 public immutable want;\n    IERC20 public immutable jpeg;\n    IERC20 public immutable pusd;\n    IERC20 public immutable weth;\n    IERC20 public immutable usdc;\n\n    DexConfig public dexConfig;\n    CurveConfig public curveConfig;\n    ConvexConfig public convexConfig;\n    StrategyConfig public strategyConfig;\n\n    /// @notice The performance fee to be sent to the DAO/strategists\n    Rate public performanceFee;\n\n    /// @notice lifetime strategy earnings denominated in `want` token\n    uint256 public earned;\n\n    /// @param _want The PUSD/USDC/USDT/MIM Curve LP token\n    /// @param _jpeg The JPEG token address\n    /// @param _pusd The PUSD token address\n    /// @param _weth The WETH token address\n    /// @param _usdc The USDC token address\n    /// @param _dexConfig See {DexConfig} struct\n    /// @param _curveConfig See {CurveConfig} struct\n    /// @param _convexConfig See {ConvexConfig} struct\n    /// @param _strategyConfig See {StrategyConfig} struct\n    /// @param _performanceFee The rate of USDC to be sent to the DAO/strategists\n    constructor(\n        address _want,\n        address _jpeg,\n        address _pusd,\n        address _weth,\n        address _usdc,\n        DexConfig memory _dexConfig,\n        CurveConfig memory _curveConfig,\n        ConvexConfig memory _convexConfig,\n        StrategyConfig memory _strategyConfig,\n        Rate memory _performanceFee\n    ) {\n        require(_want != address(0), \"INVALID_WANT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n        require(_pusd != address(0), \"INVALID_PUSD\");\n        require(_weth != address(0), \"INVALID_WETH\");\n        require(_usdc != address(0), \"INVALID_USDC\");\n        require(\n            address(_dexConfig.uniswapV2) != address(0),\n            \"INVALID_UNISWAP_V2\"\n        );\n        require(\n            address(_dexConfig.uniswapV3) != address(0),\n            \"INVALID_UNISWAP_V3\"\n        );\n        require(address(_curveConfig.curve) != address(0), \"INVALID_CURVE\");\n        require(\n            _curveConfig.pusdIndex != _curveConfig.usdcIndex,\n            \"INVALID_CURVE_INDEXES\"\n        );\n        require(_curveConfig.pusdIndex < 4, \"INVALID_PUSD_CURVE_INDEX\");\n        require(_curveConfig.usdcIndex < 4, \"INVALID_USDC_CURVE_INDEX\");\n        require(\n            address(_convexConfig.booster) != address(0),\n            \"INVALID_CONVEX_BOOSTER\"\n        );\n        require(\n            address(_convexConfig.baseRewardPool) != address(0),\n            \"INVALID_CONVEX_BASE_REWARD_POOL\"\n        );\n        require(\n            address(_strategyConfig.controller) != address(0),\n            \"INVALID_CONTROLLER\"\n        );\n        require(\n            address(_strategyConfig.usdcVault) != address(0),\n            \"INVALID_USDC_VAULT\"\n        );\n\n        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\n            require(\n                address(_strategyConfig.rewardTokens[i]) != address(0),\n                \"INVALID_REWARD_TOKEN\"\n            );\n        }\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        setPerformanceFee(_performanceFee);\n\n        want = IERC20(_want);\n        jpeg = IERC20(_jpeg);\n        pusd = IERC20(_pusd);\n        weth = IERC20(_weth);\n        usdc = IERC20(_usdc);\n\n        dexConfig = _dexConfig;\n        curveConfig = _curveConfig;\n        convexConfig = _convexConfig;\n        strategyConfig = _strategyConfig;\n    }\n\n    modifier onlyController() {\n        require(\n            msg.sender == address(strategyConfig.controller),\n            \"NOT_CONTROLLER\"\n        );\n        _;\n    }\n\n    /// @notice Allows the DAO to set the performance fee\n    /// @param _performanceFee The new performance fee\n    function setPerformanceFee(Rate memory _performanceFee)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(\n            _performanceFee.denominator > 0 &&\n                _performanceFee.denominator >= _performanceFee.numerator,\n            \"INVALID_RATE\"\n        );\n        performanceFee = _performanceFee;\n    }\n\n    /// @notice Allows the DAO to set the strategy controller\n    /// @param _controller The new strategy controller\n    function setController(address _controller)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        strategyConfig.controller = IController(_controller);\n    }\n\n    /// @notice Allows the DAO to set the USDC vault\n    /// @param _vault The new USDC vault\n    function setUSDCVault(address _vault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_vault != address(0), \"INVALID_USDC_VAULT\");\n        strategyConfig.usdcVault = IFungibleAssetVaultForDAO(_vault);\n    }\n\n    /// @return The strategy's name\n    function getName() external pure returns (string memory) {\n        return \"StrategyPUSDConvex\";\n    }\n\n    /// @return The amount of `want` tokens held by this contract\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    /// @return The amount of `want` tokens deposited in the Convex pool by this contract\n    function balanceOfPool() public view returns (uint256) {\n        return convexConfig.baseRewardPool.balanceOf(address(this));\n    }\n\n    /// @return The amount of JPEG currently held by this contract and the amount of JPEG\n    /// rewards available from Convex\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned();\n                //we found jpeg, no need to continue the loop\n                break;\n            }\n        }\n\n        return availableBalance;\n    }\n\n    /// @return The total amount of `want` tokens this contract manages (held + deposited)\n    function balanceOf() external view returns (uint256) {\n        return balanceOfWant() + balanceOfPool();\n    }\n\n    /// @notice Allows anyone to deposit the total amount of `want` tokens in this contract into Convex\n    function deposit() public {\n        uint256 balance = want.balanceOf(address(this));\n        ConvexConfig memory convex = convexConfig;\n        want.safeIncreaseAllowance(address(convex.booster), balance);\n        convex.booster.depositAll(convex.pid, true);\n    }\n\n    /// @notice Controller only function that allows to withdraw non-strategy tokens (e.g tokens sent accidentally)\n    function withdraw(IERC20 _asset)\n        external\n        onlyController\n        returns (uint256 balance)\n    {\n        require(want != _asset, \"want\");\n        require(pusd != _asset, \"pusd\");\n        require(usdc != _asset, \"usdc\");\n        require(weth != _asset, \"weth\");\n        require(jpeg != _asset, \"jpeg\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(address(strategyConfig.controller), balance);\n    }\n\n    /// @notice Allows the controller to withdraw `want` tokens. Normally used with a vault withdrawal\n    /// @param _amount The amount of `want` tokens to withdraw\n    function withdraw(uint256 _amount) external onlyController {\n        address vault = strategyConfig.controller.vaults(address(want));\n        require(vault != address(0), \"ZERO_VAULT\"); // additional protection so we don't burn the funds\n\n        uint256 balance = want.balanceOf(address(this));\n        //if the contract doesn't have enough want, withdraw from Convex\n        if (balance < _amount)\n            convexConfig.baseRewardPool.withdrawAndUnwrap(\n                _amount - balance,\n                false\n            );\n\n        want.safeTransfer(vault, _amount);\n    }\n\n    /// @notice Allows the controller to withdraw all `want` tokens. Normally used when migrating strategies\n    /// @return balance The total amount of funds that have been withdrawn\n    function withdrawAll() external onlyController returns (uint256 balance) {\n        address vault = strategyConfig.controller.vaults(address(want));\n        require(vault != address(0), \"ZERO_VAULT\"); // additional protection so we don't burn the funds\n\n        convexConfig.baseRewardPool.withdrawAllAndUnwrap(false);\n\n        balance = want.balanceOf(address(this));\n        want.safeTransfer(vault, balance);\n    }\n\n    /// @notice Allows the controller to claim JPEG rewards from Convex\n    /// and withdraw JPEG to the `_to` address\n    /// @param _to The address to send JPEG to\n    function withdrawJPEG(address _to) external onlyController {\n        // claim from convex rewards pool\n        convexConfig.baseRewardPool.getReward(address(this), true);\n        jpeg.safeTransfer(_to, jpeg.balanceOf(address(this)));\n    }\n\n    /// @notice Allows members of the `STRATEGIST_ROLE` to compound Convex rewards into Curve\n    /// @param minOutCurve The minimum amount of `want` tokens to receive\n    function harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) {\n        convexConfig.baseRewardPool.getReward(address(this), true);\n\n        //Prevent `Stack too deep` errors\n        {\n            DexConfig memory dex = dexConfig;\n            IERC20[] memory rewardTokens = strategyConfig.rewardTokens;\n            IERC20 _weth = weth;\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\n                uint256 balance = rewardTokens[i].balanceOf(address(this));\n\n                if (balance > 0)\n                    //minOut is not needed here, we already have it on the Curve deposit\n                    _swapUniswapV2(\n                        dex.uniswapV2,\n                        rewardTokens[i],\n                        _weth,\n                        balance,\n                        0\n                    );\n            }\n\n            uint256 wethBalance = _weth.balanceOf(address(this));\n            require(wethBalance > 0, \"NOOP\");\n\n            //handle sending jpeg here\n\n            _weth.safeIncreaseAllowance(address(dex.uniswapV3), wethBalance);\n\n            //minOut is not needed here, we already have it on the Curve deposit\n            ISwapRouter.ExactInputParams memory params = ISwapRouter\n                .ExactInputParams(\n                    abi.encodePacked(weth, uint24(500), usdc),\n                    address(this),\n                    block.timestamp,\n                    wethBalance,\n                    0\n                );\n\n            dex.uniswapV3.exactInput(params);\n        }\n\n        StrategyConfig memory strategy = strategyConfig;\n        CurveConfig memory curve = curveConfig;\n\n        uint256 usdcBalance = usdc.balanceOf(address(this));\n\n        //take the performance fee\n        uint256 fee = (usdcBalance * performanceFee.numerator) /\n            performanceFee.denominator;\n        usdc.safeTransfer(strategy.controller.feeAddress(), fee);\n        usdcBalance -= fee;\n\n        uint256 pusdCurveBalance = curve.curve.balances(curve.pusdIndex);\n        //USDC has 6 decimals while PUSD has 18. We need to convert the USDC\n        //balance to 18 decimals to compare it with the PUSD balance\n        uint256 usdcCurveBalance = curve.curve.balances(curve.usdcIndex) *\n            10**12;\n\n        //The curve pool has 4 tokens, we are doing a single asset deposit with either USDC or PUSD\n        uint256[4] memory liquidityAmounts = [uint256(0), 0, 0, 0];\n        if (usdcCurveBalance > pusdCurveBalance) {\n            //if there's more USDC than PUSD in the pool, use USDC as collateral to mint PUSD\n            //and deposit it into the Curve pool\n            usdc.safeIncreaseAllowance(\n                address(strategy.usdcVault),\n                usdcBalance\n            );\n            strategy.usdcVault.deposit(usdcBalance);\n\n            //check the vault's credit limit, it should be 1:1 for USDC\n            uint256 toBorrow = strategy.usdcVault.getCreditLimit(usdcBalance);\n\n            strategy.usdcVault.borrow(toBorrow);\n            liquidityAmounts[curve.pusdIndex] = toBorrow;\n\n            pusd.safeIncreaseAllowance(address(curve.curve), toBorrow);\n        } else {\n            //if there's more PUSD than USDC in the pool, deposit USDC\n            liquidityAmounts[curve.usdcIndex] = usdcBalance;\n            usdc.safeIncreaseAllowance(address(curve.curve), usdcBalance);\n        }\n\n        curve.curve.add_liquidity(liquidityAmounts, minOutCurve);\n\n        uint256 wantBalance = balanceOfWant();\n\n        deposit();\n\n        earned += wantBalance;\n        emit Harvested(wantBalance);\n    }\n\n    /// @dev Swaps `tokenIn` for `tokenOut` on UniswapV2 (or Sushiswap)\n    /// @param router The UniswapV2 (or Sushiswap) router\n    /// @param tokenIn The input token for the swap\n    /// @param tokenOut The output token for the swap\n    /// @param amountIn The amount of `tokenIn` to swap\n    /// @param minOut The minimum amount of `tokenOut` to receive for the TX not to revert\n    function _swapUniswapV2(\n        IUniswapV2Router router,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 amountIn,\n        uint256 minOut\n    ) internal {\n        tokenIn.safeIncreaseAllowance(address(router), amountIn);\n\n        address[] memory path = new address[](2);\n        path[0] = address(tokenIn);\n        path[1] = address(tokenOut);\n\n        router.swapExactTokensForTokens(\n            amountIn,\n            minOut,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "StrategyPUSDConvex.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "StrategyPUSDConvex.sol#L311-L334, StrategyPUSDConvex.sol#L410-L430",
                "Type": "Improper Path",
                "Description": "_swapUniswapV2 may use an improper path which can cause a loss of the majority of the rewardTokens.",
                "Repair": "Consider allowing the admin to set a path for the rewardTokens"
            },
            {
                "Location": "StrategyPUSDConvex.balanceOfJPEG",
                "Type": "incorrect function signature",
                "Description": "StrategyPUSDConvex.balanceOfJPEG uses incorrect function signature while calling extraReward.earned, causing the function to unexpectedly revert everytime.",
                "Repair": "Pass address(this) as argument of earned"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "package.json#L18-L19",
                "Type": "Smart Contract Vulnerability",
                "Description": "Update initializer modifier to prevent reentrancy during initialization.",
                "Repair": "Upgrade @openzeppelin/contracts and @openzeppelin/contracts-upgradeable to version 4.4.1 or higher."
            },
            {
                "Location": "_collateralPriceUsd() function",
                "Type": "Insufficient validation",
                "Description": "Oracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong answer return value.",
                "Repair": "Add validation for stale price and round completeness"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault token farm\n/// @notice Users can stake their JPEG'd vault tokens and earn JPEG rewards\n/// @dev The rewards are taken from the PUSD Convex pool and distributed to stakers based on their share of the total staked tokens.\ncontract YVaultLPFarming is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IYVault;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Claim(address indexed user, uint256 rewards);\n\n    IYVault public immutable vault;\n    IERC20 public immutable jpeg;\n\n    uint256 public totalStaked;\n\n    uint256 internal lastRewardBlock;\n    uint256 internal previousBalance;\n    uint256 internal accRewardPerShare;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => uint256) private userLastAccRewardPerShare;\n    mapping(address => uint256) private userPendingRewards;\n\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    ///@param _vault The yVault address\n    ///@param _jpeg The JPEG token address\n    constructor(address _vault, address _jpeg) {\n        require(_vault != address(0), \"INVALID_VAULT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n\n        vault = IYVault(_vault);\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting farmers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable by user `_user`\n    function pendingReward(address _user)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 rewardShare = accRewardPerShare;\n        uint256 staked = totalStaked;\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (block.number > lastRewardBlock && staked > 0) {\n            (rewardShare, ) = _computeUpdate();\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userPendingRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (balanceOf[_user] * (rewardShare - userLastAccRewardPerShare[_user])) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _amount The amount of tokens to deposit\n    function deposit(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        vault.safeTransferFrom(msg.sender, address(this), _amount);\n\n        balanceOf[msg.sender] += _amount;\n        totalStaked += _amount;\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of vault tokens. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _amount The amount of tokens to withdraw\n    function withdraw(uint256 _amount) external noContract(msg.sender) {\n        require(_amount > 0, \"invalid_amount\");\n        require(balanceOf[msg.sender] >= _amount, \"insufficient_amount\");\n\n        _update();\n        _withdrawReward(msg.sender);\n\n        balanceOf[msg.sender] -= _amount;\n        totalStaked -= _amount;\n\n        vault.safeTransfer(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to claim rewards. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    function claim() external noContract(msg.sender) {\n        _update();\n        _withdrawReward(msg.sender);\n\n        uint256 rewards = userPendingRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        userPendingRewards[msg.sender] = 0;\n        //we are subtracting the claimed rewards from the previous to have a consistent value next time\n        //{_update is called}\n        previousBalance -= rewards;\n\n        if (jpeg.balanceOf(address(this)) < rewards)\n            vault.withdrawJPEG();\n\n        jpeg.safeTransfer(msg.sender, rewards);\n\n        emit Claim(msg.sender, rewards);\n    }\n\n    /// @dev Updates this contract's rewards state\n    function _update() internal {\n        if (block.number <= lastRewardBlock) return;\n\n        lastRewardBlock = block.number;\n\n        if (totalStaked == 0) return;\n\n        (accRewardPerShare, previousBalance) = _computeUpdate();\n    }\n\n    /// @dev Computes the updated contract state without writing storage\n    /// @return newAccRewardsPerShare The new value of `accRewardsPerShare`\n    /// @return currentBalance The new value of `previousBalance`\n    function _computeUpdate() internal view returns (uint256 newAccRewardsPerShare, uint256 currentBalance) {\n        currentBalance = vault.balanceOfJPEG() + jpeg.balanceOf(address(this));\n        uint256 newRewards = currentBalance - previousBalance;\n\n        newAccRewardsPerShare = accRewardPerShare + newRewards * 1e36 / totalStaked;\n    }\n\n    /// @dev Updates `account`'s claimable rewards by adding pending rewards\n    /// @param account The account to update\n    function _withdrawReward(address account) internal returns (uint256) {\n        uint256 pending = (balanceOf[account] *\n            (accRewardPerShare - userLastAccRewardPerShare[account])) / 1e36;\n\n        if (pending > 0) userPendingRewards[account] += pending;\n\n        userLastAccRewardPerShare[account] = accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n",
        "CodeNames": [
            "yVaultLPFarming.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "yVaultLPFarming",
                "Type": "trust assumption",
                "Description": "yVaultLPFarming: No guarantee JPEG currentBalance > previousBalance.",
                "Repair": "Return if currentBalance \u2264 previousBalance or properly handle potential shortfall"
            },
            {
                "Location": "yVaultLPFarming",
                "Type": "accrual failure",
                "Description": "Setting new controller can break YVaultLPFarming.",
                "Repair": "Set a new controller on a vault carefully and requires a migration"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title JPEG Locker contract\n/// @notice Contract used by {NFTVault} to lock JPEG to increase the value of an NFT\ncontract JPEGLock is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    event Lock(address indexed user, uint256 indexed nftIndex, uint256 amount);\n    event Unlock(address indexed user, uint256 indexed nftIndex, uint256 amount);\n\n    struct LockPosition {\n        address owner;\n        uint256 unlockAt;\n        uint256 lockAmount;\n    }\n\n    /// @notice The token to lock, JPEG\n    IERC20 public immutable jpeg;\n    /// @notice The amount of time to lock JPEG tokens for\n    uint256 public lockTime;\n    /// @notice Positions by NFT index\n    mapping(uint256 => LockPosition) public positions;\n\n    /// @param _jpeg The token to lock\n    constructor(IERC20 _jpeg) Ownable() ReentrancyGuard() {\n        jpeg = _jpeg;\n        lockTime = 365 days;\n    }\n\n    /// @notice Allows the owner to change the amount of time JPEG tokens are locked for.\n    /// The lock duration of already existing locked tokens won't change\n    /// @param _newTime The new lock duration in seconds\n    function setLockTime(uint256 _newTime) external onlyOwner {\n        require(_newTime > 0, \"Invalid lock time\");\n        lockTime = _newTime;\n    }\n\n    /// @notice Locks `_lockAmount` tokens for account `_account` and NFT `_nftIndex` for 1 year. \n    /// @dev Emits a {Lock} event\n    /// @param _account The account to lock tokens for\n    /// @param _nftIndex The NFT to lock tokens for\n    /// @param _lockAmount The amount of tokens to lock\n    function lockFor(\n        address _account,\n        uint256 _nftIndex,\n        uint256 _lockAmount\n    ) external onlyOwner nonReentrant {\n        jpeg.safeTransferFrom(_account, address(this), _lockAmount);\n\n        positions[_nftIndex] = LockPosition({\n            owner: _account,\n            unlockAt: block.timestamp + lockTime,\n            lockAmount: _lockAmount\n        });\n\n        emit Lock(_account, _nftIndex, _lockAmount);\n    }\n\n    /// @notice Unlocks tokens for the position relative to NFT `_nftIndex`\n    /// @dev Emits an {Unlock} event\n    /// @param _nftIndex the NFT to unlock \n    function unlock(uint256 _nftIndex) external nonReentrant {\n        LockPosition memory position = positions[_nftIndex];\n        require(position.owner == msg.sender, \"unauthorized\");\n        require(position.unlockAt <= block.timestamp, \"locked\");\n\n        delete positions[_nftIndex];\n\n        jpeg.safeTransfer(msg.sender, position.lockAmount);\n\n        emit Unlock(msg.sender, _nftIndex, position.lockAmount);\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/IAggregatorV3Interface.sol\";\nimport \"../interfaces/IStableCoin.sol\";\nimport \"../interfaces/IJPEGLock.sol\";\n\n/// @title NFT lending vault\n/// @notice This contracts allows users to borrow PUSD using NFTs as collateral.\n/// The floor price of the NFT collection is fetched using a chainlink oracle, while some other more valuable traits\n/// can have an higher price set by the DAO. Users can also increase the price (and thus the borrow limit) of their\n/// NFT by submitting a governance proposal. If the proposal is approved the user can lock a percentage of the new price\n/// worth of JPEG to make it effective\ncontract NFTVault is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    event PositionOpened(address indexed owner, uint256 indexed index);\n    event Borrowed(\n        address indexed owner,\n        uint256 indexed index,\n        uint256 amount\n    );\n    event Repaid(address indexed owner, uint256 indexed index, uint256 amount);\n    event PositionClosed(address indexed owner, uint256 indexed index);\n    event Liquidated(\n        address indexed liquidator,\n        address indexed owner,\n        uint256 indexed index,\n        bool insured\n    );\n    event Repurchased(address indexed owner, uint256 indexed index);\n    event InsuranceExpired(address indexed owner, uint256 indexed index);\n\n    enum BorrowType {\n        NOT_CONFIRMED,\n        NON_INSURANCE,\n        USE_INSURANCE\n    }\n\n    struct Position {\n        BorrowType borrowType;\n        uint256 debtPrincipal;\n        uint256 debtPortion;\n        uint256 debtAmountForRepurchase;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    struct VaultSettings {\n        Rate debtInterestApr;\n        Rate creditLimitRate;\n        Rate liquidationLimitRate;\n        Rate valueIncreaseLockRate;\n        Rate organizationFeeRate;\n        Rate insurancePurchaseRate;\n        Rate insuranceLiquidationPenaltyRate;\n        uint256 insuraceRepurchaseTimeLimit;\n        uint256 borrowAmountCap;\n    }\n\n    bytes32 public constant DAO_ROLE = keccak256(\"DAO_ROLE\");\n    bytes32 public constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\n\n    bytes32 public constant CUSTOM_NFT_HASH = keccak256(\"CUSTOM\");\n\n    IStableCoin public stablecoin;\n    /// @notice Chainlink ETH/USD price feed\n    IAggregatorV3Interface public ethAggregator;\n    /// @notice Chainlink JPEG/USD price feed\n    IAggregatorV3Interface public jpegAggregator;\n    /// @notice Chainlink NFT floor oracle\n    IAggregatorV3Interface public floorOracle;\n    /// @notice Chainlink NFT fallback floor oracle\n    IAggregatorV3Interface public fallbackOracle;\n    /// @notice JPEGLocker, used by this contract to lock JPEG and increase the value of an NFT\n    IJPEGLock public jpegLocker;\n    IERC721Upgradeable public nftContract;\n\n    /// @notice If true, the floor price won't be fetched using the Chainlink oracle but\n    /// a value set by the DAO will be used instead\n    bool public daoFloorOverride;\n    // @notice If true, the floor price will be fetched using the fallback oracle\n    bool public useFallbackOracle;\n    /// @notice Total outstanding debt\n    uint256 public totalDebtAmount;\n    /// @dev Last time debt was accrued. See {accrue} for more info\n    uint256 public totalDebtAccruedAt;\n    uint256 public totalFeeCollected;\n    uint256 internal totalDebtPortion;\n\n    VaultSettings public settings;\n\n    /// @dev Keeps track of all the NFTs used as collateral for positions\n    EnumerableSetUpgradeable.UintSet private positionIndexes;\n\n    mapping(uint256 => Position) private positions;\n    mapping(uint256 => address) public positionOwner;\n    mapping(bytes32 => uint256) public nftTypeValueETH;\n    mapping(uint256 => uint256) public nftValueETH;\n    //bytes32(0) is floor\n    mapping(uint256 => bytes32) public nftTypes;\n    mapping(uint256 => uint256) public pendingNFTValueETH;\n\n    /// @dev Checks if the provided NFT index is valid\n    /// @param nftIndex The index to check\n    modifier validNFTIndex(uint256 nftIndex) {\n        //The standard OZ ERC721 implementation of ownerOf reverts on a non existing nft isntead of returning address(0)\n        require(nftContract.ownerOf(nftIndex) != address(0), \"invalid_nft\");\n        _;\n    }\n\n    struct NFTCategoryInitializer {\n        bytes32 hash;\n        uint256 valueETH;\n        uint256[] nfts;\n    }\n\n    /// @param _stablecoin PUSD address\n    /// @param _nftContract The NFT contrat address. It could also be the address of an helper contract\n    /// if the target NFT isn't an ERC721 (CryptoPunks as an example)\n    /// @param _ethAggregator Chainlink ETH/USD price feed address\n    /// @param _jpegAggregator Chainlink JPEG/USD price feed address\n    /// @param _floorOracle Chainlink floor oracle address\n    /// @param _fallbackOracle Chainlink fallback floor oracle address\n    /// @param _typeInitializers Used to initialize NFT categories with their value and NFT indexes.\n    /// Floor NFT shouldn't be initialized this way\n    /// @param _jpegLocker JPEGLock address\n    /// @param _settings Initial settings used by the contract\n    function initialize(\n        IStableCoin _stablecoin,\n        IERC721Upgradeable _nftContract,\n        IAggregatorV3Interface _ethAggregator,\n        IAggregatorV3Interface _jpegAggregator,\n        IAggregatorV3Interface _floorOracle,\n        IAggregatorV3Interface _fallbackOracle,\n        NFTCategoryInitializer[] memory _typeInitializers,\n        IJPEGLock _jpegLocker,\n        VaultSettings memory _settings\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DAO_ROLE, msg.sender);\n        _setRoleAdmin(LIQUIDATOR_ROLE, DAO_ROLE);\n        _setRoleAdmin(DAO_ROLE, DAO_ROLE);\n\n        _validateRate(_settings.debtInterestApr);\n        _validateRate(_settings.creditLimitRate);\n        _validateRate(_settings.liquidationLimitRate);\n        _validateRate(_settings.valueIncreaseLockRate);\n        _validateRate(_settings.organizationFeeRate);\n        _validateRate(_settings.insurancePurchaseRate);\n        _validateRate(_settings.insuranceLiquidationPenaltyRate);\n\n        _validateCreditLimitAndLiquidationRate(\n            _settings.creditLimitRate,\n            _settings.liquidationLimitRate\n        );\n\n        stablecoin = _stablecoin;\n        jpegLocker = _jpegLocker;\n        ethAggregator = _ethAggregator;\n        jpegAggregator = _jpegAggregator;\n        floorOracle = _floorOracle;\n        fallbackOracle = _fallbackOracle;\n        nftContract = _nftContract;\n\n        settings = _settings;\n\n        //initializing the categories\n        for (uint256 i = 0; i < _typeInitializers.length; i++) {\n            NFTCategoryInitializer memory initializer = _typeInitializers[i];\n            nftTypeValueETH[initializer.hash] = initializer.valueETH;\n            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n                nftTypes[initializer.nfts[j]] = initializer.hash;\n            }\n        }\n    }\n\n    /// @dev The {accrue} function updates the contract's state by calculating\n    /// the additional interest accrued since the last state update\n    function accrue() public {\n        uint256 additionalInterest = _calculateAdditionalInterest();\n\n        totalDebtAccruedAt = block.timestamp;\n\n        totalDebtAmount += additionalInterest;\n        totalFeeCollected += additionalInterest;\n    }\n\n    /// @notice Allows the DAO to change the total debt cap\n    /// @param _borrowAmountCap New total debt cap\n    function setBorrowAmountCap(uint256 _borrowAmountCap)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        settings.borrowAmountCap = _borrowAmountCap;\n    }\n\n    /// @notice Allows the DAO to change the interest APR on borrows\n    /// @param _debtInterestApr The new interest rate\n    function setDebtInterestApr(Rate memory _debtInterestApr)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_debtInterestApr);\n        settings.debtInterestApr = _debtInterestApr;\n    }\n\n    /// @notice Allows the DAO to change the amount of JPEG needed to increase the value of an NFT relative to the desired value\n    /// @param _valueIncreaseLockRate The new rate\n    function setValueIncreaseLockRate(Rate memory _valueIncreaseLockRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_valueIncreaseLockRate);\n        settings.valueIncreaseLockRate = _valueIncreaseLockRate;\n    }\n\n    /// @notice Allows the DAO to change the max debt to collateral rate for a position\n    /// @param _creditLimitRate The new rate\n    function setCreditLimitRate(Rate memory _creditLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_creditLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            _creditLimitRate,\n            settings.liquidationLimitRate\n        );\n\n        settings.creditLimitRate = _creditLimitRate;\n    }\n\n    /// @notice Allows the DAO to change the minimum debt to collateral rate for a position to be market as liquidatable\n    /// @param _liquidationLimitRate The new rate\n    function setLiquidationLimitRate(Rate memory _liquidationLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_liquidationLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            settings.creditLimitRate,\n            _liquidationLimitRate\n        );\n\n        settings.liquidationLimitRate = _liquidationLimitRate;\n    }\n\n    /// @notice Allows the DAO to toggle the fallback oracle\n    /// @param _useFallback Whether to use the fallback oracle\n    function toggleFallbackOracle(bool _useFallback)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        useFallbackOracle = _useFallback;\n    }\n\n    /// @notice Allows the DAO to change the amount of time JPEG tokens need to be locked to change the value of an NFT\n    /// @param _newLockTime The amount new lock time amount\n    function setJPEGLockTime(uint256 _newLockTime) external onlyRole(DAO_ROLE) {\n        jpegLocker.setLockTime(_newLockTime);\n    }\n\n    /// @notice Allows the DAO to bypass the floor oracle and override the NFT floor value\n    /// @param _newFloor The new floor\n    function overrideFloor(uint256 _newFloor) external onlyRole(DAO_ROLE) {\n        require(_newFloor > 0, \"Invalid floor\");\n        nftTypeValueETH[bytes32(0)] = _newFloor;\n        daoFloorOverride = true;\n    }\n\n    /// @notice Allows the DAO to stop overriding floor\n    function disableFloorOverride() external onlyRole(DAO_ROLE) {\n        daoFloorOverride = false;\n    }\n\n    /// @notice Allows the DAO to change the static borrow fee\n    /// @param _organizationFeeRate The new fee rate\n    function setOrganizationFeeRate(Rate memory _organizationFeeRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_organizationFeeRate);\n        settings.organizationFeeRate = _organizationFeeRate;\n    }\n\n    /// @notice Allows the DAO to change the cost of insurance\n    /// @param _insurancePurchaseRate The new insurance fee rate\n    function setInsurancePurchaseRate(Rate memory _insurancePurchaseRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_insurancePurchaseRate);\n        settings.insurancePurchaseRate = _insurancePurchaseRate;\n    }\n\n    /// @notice Allows the DAO to change the repurchase penalty rate in case of liquidation of an insured NFT\n    /// @param _insuranceLiquidationPenaltyRate The new rate\n    function setInsuranceLiquidationPenaltyRate(\n        Rate memory _insuranceLiquidationPenaltyRate\n    ) external onlyRole(DAO_ROLE) {\n        _validateRate(_insuranceLiquidationPenaltyRate);\n        settings\n            .insuranceLiquidationPenaltyRate = _insuranceLiquidationPenaltyRate;\n    }\n\n    /// @notice Allows the DAO to add an NFT to a specific price category\n    /// @param _nftIndex The index to add to the category\n    /// @param _type The category hash\n    function setNFTType(uint256 _nftIndex, bytes32 _type)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        require(\n            _type == bytes32(0) || nftTypeValueETH[_type] > 0,\n            \"invalid_nftType\"\n        );\n        nftTypes[_nftIndex] = _type;\n    }\n\n    /// @notice Allows the DAO to change the value of an NFT category\n    /// @param _type The category hash\n    /// @param _amountETH The new value, in ETH\n    function setNFTTypeValueETH(bytes32 _type, uint256 _amountETH)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        nftTypeValueETH[_type] = _amountETH;\n    }\n\n    /// @notice Allows the DAO to set the value in ETH of the NFT at index `_nftIndex`.\n    /// A JPEG deposit by a user is required afterwards. See {finalizePendingNFTValueETH} for more details\n    /// @param _nftIndex The index of the NFT to change the value of\n    /// @param _amountETH The new desired ETH value\n    function setPendingNFTValueETH(uint256 _nftIndex, uint256 _amountETH)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        pendingNFTValueETH[_nftIndex] = _amountETH;\n    }\n\n    /// @notice Allows a user to lock up JPEG to make the change in value of an NFT effective.\n    /// Can only be called after {setPendingNFTValueETH}, which requires a governance vote.\n    /// @dev The amount of JPEG that needs to be locked is calculated by applying `valueIncreaseLockRate`\n    /// to the new credit limit of the NFT\n    /// @param _nftIndex The index of the NFT\n    function finalizePendingNFTValueETH(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        uint256 pendingValue = pendingNFTValueETH[_nftIndex];\n        require(pendingValue > 0, \"no_pending_value\");\n        uint256 toLockJpeg = (((pendingValue *\n            _ethPriceUSD() *\n            settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator) *\n            settings.valueIncreaseLockRate.numerator) /\n            settings.valueIncreaseLockRate.denominator /\n            _jpegPriceUSD();\n\n        //lock JPEG using JPEGLock\n        jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg);\n\n        nftTypes[_nftIndex] = CUSTOM_NFT_HASH;\n        nftValueETH[_nftIndex] = pendingValue;\n        //clear pending value\n        pendingNFTValueETH[_nftIndex] = 0;\n    }\n\n    /// @dev Validates the credit limit rate and the liquidation limit rate.\n    /// The credit limit rate must be less than the liquidation rate\n    /// @param _creditLimitRate The credit limit rate to validate\n    /// @param _liquidationLimitRate The liquidation limit rate\n    function _validateCreditLimitAndLiquidationRate(\n        Rate memory _creditLimitRate,\n        Rate memory _liquidationLimitRate\n    ) internal pure {\n        require(\n            _liquidationLimitRate.numerator * _creditLimitRate.denominator >\n                _creditLimitRate.numerator * _liquidationLimitRate.denominator,\n            \"credit_rate_exceeds_or_equals_liquidation_rate\"\n        );\n    }\n\n    /// @dev Validates a rate. The denominator must be greater than zero and greater than or equal to the numerator.\n    /// @param rate The rate to validate\n    function _validateRate(Rate memory rate) internal pure {\n        require(\n            rate.denominator > 0 && rate.denominator >= rate.numerator,\n            \"invalid_rate\"\n        );\n    }\n\n    /// @dev Returns the value in ETH of the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT to return the value of\n    /// @return The value of the NFT, 18 decimals\n    function _getNFTValueETH(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        bytes32 nftType = nftTypes[_nftIndex];\n\n        if (nftType == bytes32(0) && !daoFloorOverride) {\n            return\n                _normalizeAggregatorAnswer(\n                    useFallbackOracle ? fallbackOracle : floorOracle\n                );\n        } else if (nftType == CUSTOM_NFT_HASH) return nftValueETH[_nftIndex];\n\n        return nftTypeValueETH[nftType];\n    }\n\n    /// @dev Returns the value in USD of the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT to return the value of\n    /// @return The value of the NFT in USD, 18 decimals\n    function _getNFTValueUSD(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 nft_value = _getNFTValueETH(_nftIndex);\n        return (nft_value * _ethPriceUSD()) / 1 ether;\n    }\n\n    /// @dev Returns the current ETH price in USD\n    /// @return The current ETH price, 18 decimals\n    function _ethPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(ethAggregator);\n    }\n\n    /// @dev Returns the current JPEG price in USD\n    /// @return The current JPEG price, 18 decimals\n    function _jpegPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(jpegAggregator);\n    }\n\n    /// @dev Fetches and converts to 18 decimals precision the latest answer of a Chainlink aggregator\n    /// @param aggregator The aggregator to fetch the answer from\n    /// @return The latest aggregator answer, normalized\n    function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator)\n        internal\n        view\n        returns (uint256)\n    {\n        int256 answer = aggregator.latestAnswer();\n        uint8 decimals = aggregator.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n        //converts the answer to have 18 decimals\n        return\n            decimals > 18\n                ? uint256(answer) / 10**(decimals - 18)\n                : uint256(answer) * 10**(18 - decimals);\n    }\n\n    struct NFTInfo {\n        uint256 index;\n        bytes32 nftType;\n        address owner;\n        uint256 nftValueETH;\n        uint256 nftValueUSD;\n    }\n\n    /// @notice Returns data relative to the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT index\n    /// @return nftInfo The data relative to the NFT\n    function getNFTInfo(uint256 _nftIndex)\n        external\n        view\n        returns (NFTInfo memory nftInfo)\n    {\n        nftInfo = NFTInfo(\n            _nftIndex,\n            nftTypes[_nftIndex],\n            nftContract.ownerOf(_nftIndex),\n            _getNFTValueETH(_nftIndex),\n            _getNFTValueUSD(_nftIndex)\n        );\n    }\n\n    /// @dev Returns the credit limit of an NFT\n    /// @param _nftIndex The NFT to return credit limit of\n    /// @return The NFT credit limit\n    function _getCreditLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator;\n    }\n\n    /// @dev Returns the minimum amount of debt necessary to liquidate an NFT\n    /// @param _nftIndex The index of the NFT\n    /// @return The minimum amount of debt to liquidate the NFT\n    function _getLiquidationLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.liquidationLimitRate.numerator) /\n            settings.liquidationLimitRate.denominator;\n    }\n\n    /// @dev Calculates current outstanding debt of an NFT\n    /// @param _nftIndex The NFT to calculate the outstanding debt of\n    /// @return The outstanding debt value\n    function _getDebtAmount(uint256 _nftIndex) internal view returns (uint256) {\n        uint256 calculatedDebt = _calculateDebt(\n            totalDebtAmount,\n            positions[_nftIndex].debtPortion,\n            totalDebtPortion\n        );\n\n        uint256 principal = positions[_nftIndex].debtPrincipal;\n\n        //_calculateDebt is prone to rounding errors that may cause\n        //the calculated debt amount to be 1 or 2 units less than\n        //the debt principal when the accrue() function isn't called\n        //in between the first borrow and the _calculateDebt call.\n        return principal > calculatedDebt ? principal : calculatedDebt;\n    }\n\n    /// @dev Calculates the total debt of a position given the global debt, the user's portion of the debt and the total user portions\n    /// @param total The global outstanding debt\n    /// @param userPortion The user's portion of debt\n    /// @param totalPortion The total user portions of debt\n    /// @return The outstanding debt of the position\n    function _calculateDebt(\n        uint256 total,\n        uint256 userPortion,\n        uint256 totalPortion\n    ) internal pure returns (uint256) {\n        return totalPortion == 0 ? 0 : (total * userPortion) / totalPortion;\n    }\n\n    /// @dev Opens a position\n    /// Emits a {PositionOpened} event\n    /// @param _owner The owner of the position to open\n    /// @param _nftIndex The NFT used as collateral for the position\n    function _openPosition(address _owner, uint256 _nftIndex) internal {\n        nftContract.transferFrom(_owner, address(this), _nftIndex);\n\n        positions[_nftIndex] = Position({\n            borrowType: BorrowType.NOT_CONFIRMED,\n            debtPrincipal: 0,\n            debtPortion: 0,\n            debtAmountForRepurchase: 0,\n            liquidatedAt: 0,\n            liquidator: address(0)\n        });\n        positionOwner[_nftIndex] = _owner;\n        positionIndexes.add(_nftIndex);\n\n        emit PositionOpened(_owner, _nftIndex);\n    }\n\n    /// @dev Calculates the additional global interest since last time the contract's state was updated by calling {accrue}\n    /// @return The additional interest value\n    function _calculateAdditionalInterest() internal view returns (uint256) {\n        // Number of seconds since {accrue} was called\n        uint256 elapsedTime = block.timestamp - totalDebtAccruedAt;\n        if (elapsedTime == 0) {\n            return 0;\n        }\n\n        if (totalDebtAmount == 0) {\n            return 0;\n        }\n\n        // Accrue interest\n        uint256 interestPerYear = (totalDebtAmount *\n            settings.debtInterestApr.numerator) /\n            settings.debtInterestApr.denominator;\n        uint256 interestPerSec = interestPerYear / 365 days;\n\n        return elapsedTime * interestPerSec;\n    }\n\n    /// @notice Returns the number of open positions\n    /// @return The number of open positions\n    function totalPositions() external view returns (uint256) {\n        return positionIndexes.length();\n    }\n\n    /// @notice Returns all open position NFT indexes\n    /// @return The open position NFT indexes\n    function openPositionsIndexes() external view returns (uint256[] memory) {\n        return positionIndexes.values();\n    }\n\n    struct PositionPreview {\n        address owner;\n        uint256 nftIndex;\n        bytes32 nftType;\n        uint256 nftValueUSD;\n        VaultSettings vaultSettings;\n        uint256 creditLimit;\n        uint256 debtPrincipal;\n        uint256 debtInterest;\n        BorrowType borrowType;\n        bool liquidatable;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    /// @notice Returns data relative to a postition, existing or not\n    /// @param _nftIndex The index of the NFT used as collateral for the position\n    /// @return preview See assignment below\n    function showPosition(uint256 _nftIndex)\n        external\n        view\n        validNFTIndex(_nftIndex)\n        returns (PositionPreview memory preview)\n    {\n        address posOwner = positionOwner[_nftIndex];\n\n        uint256 debtPrincipal = positions[_nftIndex].debtPrincipal;\n        uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0\n            ? positions[_nftIndex].debtAmountForRepurchase //calculate updated debt\n            : _calculateDebt(\n                totalDebtAmount + _calculateAdditionalInterest(),\n                positions[_nftIndex].debtPortion,\n                totalDebtPortion\n            );\n\n        //_calculateDebt is prone to rounding errors that may cause\n        //the calculated debt amount to be 1 or 2 units less than\n        //the debt principal if no time has elapsed in between the first borrow\n        //and the _calculateDebt call.\n        if (debtPrincipal > debtAmount) debtAmount = debtPrincipal;\n\n        preview = PositionPreview({\n            owner: posOwner, //the owner of the position, `address(0)` if the position doesn't exists\n            nftIndex: _nftIndex, //the NFT used as collateral for the position\n            nftType: nftTypes[_nftIndex], //the type of the NFT\n            nftValueUSD: _getNFTValueUSD(_nftIndex), //the value in USD of the NFT\n            vaultSettings: settings, //the current vault's settings\n            creditLimit: _getCreditLimit(_nftIndex), //the NFT's credit limit\n            debtPrincipal: debtPrincipal, //the debt principal for the position, `0` if the position doesn't exists\n            debtInterest: debtAmount - debtPrincipal, //the interest of the position\n            borrowType: positions[_nftIndex].borrowType, //the insurance type of the position, `NOT_CONFIRMED` if it doesn't exist\n            liquidatable: positions[_nftIndex].liquidatedAt == 0 &&\n                debtAmount >= _getLiquidationLimit(_nftIndex), //if the position can be liquidated\n            liquidatedAt: positions[_nftIndex].liquidatedAt, //if the position has been liquidated and it had insurance, the timestamp at which the liquidation happened\n            liquidator: positions[_nftIndex].liquidator //if the position has been liquidated and it had insurance, the address of the liquidator\n        });\n    }\n\n    /// @notice Allows users to open positions and borrow using an NFT\n    /// @dev emits a {Borrowed} event\n    /// @param _nftIndex The index of the NFT to be used as collateral\n    /// @param _amount The amount of PUSD to be borrowed. Note that the user will receive less than the amount requested,\n    /// the borrow fee and insurance automatically get removed from the amount borrowed\n    /// @param _useInsurance Whereter to open an insured position. In case the position has already been opened previously,\n    /// this parameter needs to match the previous insurance mode. To change insurance mode, a user needs to close and reopen the position\n    function borrow(\n        uint256 _nftIndex,\n        uint256 _amount,\n        bool _useInsurance\n    ) external validNFTIndex(_nftIndex) nonReentrant {\n        accrue();\n\n        require(\n            msg.sender == positionOwner[_nftIndex] ||\n                address(0) == positionOwner[_nftIndex],\n            \"unauthorized\"\n        );\n        require(_amount > 0, \"invalid_amount\");\n        require(\n            totalDebtAmount + _amount <= settings.borrowAmountCap,\n            \"debt_cap\"\n        );\n\n        if (positionOwner[_nftIndex] == address(0)) {\n            _openPosition(msg.sender, _nftIndex);\n        }\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n        require(\n            position.borrowType == BorrowType.NOT_CONFIRMED ||\n                (position.borrowType == BorrowType.USE_INSURANCE &&\n                    _useInsurance) ||\n                (position.borrowType == BorrowType.NON_INSURANCE &&\n                    !_useInsurance),\n            \"invalid_insurance_mode\"\n        );\n\n        uint256 creditLimit = _getCreditLimit(_nftIndex);\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(debtAmount + _amount <= creditLimit, \"insufficient_credit\");\n\n        //calculate the borrow fee\n        uint256 organizationFee = (_amount *\n            settings.organizationFeeRate.numerator) /\n            settings.organizationFeeRate.denominator;\n\n        uint256 feeAmount = organizationFee;\n        //if the position is insured, calculate the insurance fee\n        if (position.borrowType == BorrowType.USE_INSURANCE || _useInsurance) {\n            feeAmount +=\n                (_amount * settings.insurancePurchaseRate.numerator) /\n                settings.insurancePurchaseRate.denominator;\n        }\n        totalFeeCollected += feeAmount;\n        //subtract the fee from the amount borrowed\n        stablecoin.mint(msg.sender, _amount - feeAmount);\n\n        if (position.borrowType == BorrowType.NOT_CONFIRMED) {\n            position.borrowType = _useInsurance\n                ? BorrowType.USE_INSURANCE\n                : BorrowType.NON_INSURANCE;\n        }\n\n        // update debt portion\n        if (totalDebtPortion == 0) {\n            totalDebtPortion = _amount;\n            position.debtPortion = _amount;\n        } else {\n            uint256 plusPortion = (totalDebtPortion * _amount) /\n                totalDebtAmount;\n            totalDebtPortion += plusPortion;\n            position.debtPortion += plusPortion;\n        }\n        position.debtPrincipal += _amount;\n        totalDebtAmount += _amount;\n\n        emit Borrowed(msg.sender, _nftIndex, _amount);\n    }\n\n    /// @notice Allows users to repay a portion/all of their debt. Note that since interest increases every second,\n    /// a user wanting to repay all of their debt should repay for an amount greater than their current debt to account for the\n    /// additional interest while the repay transaction is pending, the contract will only take what's necessary to repay all the debt\n    /// @dev Emits a {Repaid} event\n    /// @param _nftIndex The NFT used as collateral for the position\n    /// @param _amount The amount of debt to repay. If greater than the position's outstanding debt, only the amount necessary to repay all the debt will be taken\n    function repay(uint256 _nftIndex, uint256 _amount)\n        external\n        validNFTIndex(_nftIndex)\n        nonReentrant\n    {\n        accrue();\n\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(_amount > 0, \"invalid_amount\");\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(debtAmount > 0, \"position_not_borrowed\");\n\n        uint256 debtPrincipal = position.debtPrincipal;\n        uint256 debtInterest = debtAmount - debtPrincipal;\n\n        _amount = _amount > debtAmount ? debtAmount : _amount;\n\n        // burn all payment, the interest is sent to the DAO using the {collect} function\n        stablecoin.burnFrom(msg.sender, _amount);\n\n        uint256 paidPrincipal = _amount > debtInterest\n            ? _amount - debtInterest\n            : 0;\n\n        uint256 minusPortion = paidPrincipal == debtPrincipal\n            ? position.debtPortion\n            : (totalDebtPortion * _amount) / totalDebtAmount;\n\n        totalDebtPortion -= minusPortion;\n        position.debtPortion -= minusPortion;\n        position.debtPrincipal -= paidPrincipal;\n        totalDebtAmount -= _amount;\n\n        emit Repaid(msg.sender, _nftIndex, _amount);\n    }\n\n    /// @notice Allows a user to close a position and get their collateral back, if the position's outstanding debt is 0\n    /// @dev Emits a {PositionClosed} event\n    /// @param _nftIndex The index of the NFT used as collateral\n    function closePosition(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        accrue();\n\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(_getDebtAmount(_nftIndex) == 0, \"position_not_repaid\");\n\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        // transfer nft back to owner if nft was deposited\n        if (nftContract.ownerOf(_nftIndex) == address(this)) {\n            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n        }\n\n        emit PositionClosed(msg.sender, _nftIndex);\n    }\n\n    /// @notice Allows members of the `LIQUIDATOR_ROLE` to liquidate a position. Positions can only be liquidated\n    /// once their debt amount exceeds the minimum liquidation debt to collateral value rate.\n    /// In order to liquidate a position, the liquidator needs to repay the user's outstanding debt.\n    /// If the position is not insured, it's closed immediately and the collateral is sent to the liquidator.\n    /// If the position is insured, the position remains open (interest doesn't increase) and the owner of the position has a certain amount of time\n    /// (`insuranceRepurchaseTimeLimit`) to fully repay the liquidator and pay an additional liquidation fee (`insuranceLiquidationPenaltyRate`), if this\n    /// is done in time the user gets back their collateral and their position is automatically closed. If the user doesn't repurchase their collateral\n    /// before the time limit passes, the liquidator can claim the liquidated NFT and the position is closed\n    /// @dev Emits a {Liquidated} event\n    /// @param _nftIndex The NFT to liquidate\n    function liquidate(uint256 _nftIndex)\n        external\n        onlyRole(LIQUIDATOR_ROLE)\n        validNFTIndex(_nftIndex)\n        nonReentrant\n    {\n        accrue();\n\n        address posOwner = positionOwner[_nftIndex];\n        require(posOwner != address(0), \"position_not_exist\");\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(\n            debtAmount >= _getLiquidationLimit(_nftIndex),\n            \"position_not_liquidatable\"\n        );\n\n        // burn all payment\n        stablecoin.burnFrom(msg.sender, debtAmount);\n\n        // update debt portion\n        totalDebtPortion -= position.debtPortion;\n        totalDebtAmount -= debtAmount;\n        position.debtPortion = 0;\n\n        bool insured = position.borrowType == BorrowType.USE_INSURANCE;\n        if (insured) {\n            position.debtAmountForRepurchase = debtAmount;\n            position.liquidatedAt = block.timestamp;\n            position.liquidator = msg.sender;\n        } else {\n            // transfer nft to liquidator\n            positionOwner[_nftIndex] = address(0);\n            delete positions[_nftIndex];\n            positionIndexes.remove(_nftIndex);\n            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n        }\n\n        emit Liquidated(msg.sender, posOwner, _nftIndex, insured);\n    }\n\n    /// @notice Allows liquidated users who purchased insurance to repurchase their collateral within the time limit\n    /// defined with the `insuranceRepurchaseTimeLimit`. The user needs to pay the liquidator the total amount of debt\n    /// the position had at the time of liquidation, plus an insurance liquidation fee defined with `insuranceLiquidationPenaltyRate`\n    /// @dev Emits a {Repurchased} event\n    /// @param _nftIndex The NFT to repurchase\n    function repurchase(uint256 _nftIndex) external validNFTIndex(_nftIndex) {\n        Position memory position = positions[_nftIndex];\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(position.liquidatedAt > 0, \"not_liquidated\");\n        require(\n            position.borrowType == BorrowType.USE_INSURANCE,\n            \"non_insurance\"\n        );\n        require(\n            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit >=\n                block.timestamp,\n            \"insurance_expired\"\n        );\n\n        uint256 debtAmount = position.debtAmountForRepurchase;\n        uint256 penalty = (debtAmount *\n            settings.insuranceLiquidationPenaltyRate.numerator) /\n            settings.insuranceLiquidationPenaltyRate.denominator;\n\n        // transfer payment to liquidator\n        stablecoin.transferFrom(\n            msg.sender,\n            position.liquidator,\n            debtAmount + penalty\n        );\n\n        // transfer nft to user\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n\n        emit Repurchased(msg.sender, _nftIndex);\n    }\n\n    /// @notice Allows the liquidator who liquidated the insured position with NFT at index `_nftIndex` to claim the position's collateral\n    /// after the time period defined with `insuranceRepurchaseTimeLimit` has expired and the position owner has not repurchased the collateral.\n    /// @dev Emits an {InsuranceExpired} event\n    /// @param _nftIndex The NFT to claim\n    function claimExpiredInsuranceNFT(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        Position memory position = positions[_nftIndex];\n        address owner = positionOwner[_nftIndex];\n        require(address(0) != owner, \"no_position\");\n        require(position.liquidatedAt > 0, \"not_liquidated\");\n        require(\n            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit <\n                block.timestamp,\n            \"insurance_not_expired\"\n        );\n        require(position.liquidator == msg.sender, \"unauthorized\");\n\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n\n        emit InsuranceExpired(owner, _nftIndex);\n    }\n\n    /// @notice Allows the DAO to collect interest and fees before they are repaid\n    function collect() external nonReentrant onlyRole(DAO_ROLE) {\n        accrue();\n        stablecoin.mint(msg.sender, totalFeeCollected);\n        totalFeeCollected = 0;\n    }\n\n    uint256[50] private __gap;\n}\n\n\n",
        "CodeNames": [
            "JPEGLock.sol",
            "NFTVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTVault.sol, JPEGLock.sol",
                "Type": "data overwrite",
                "Description": "Existing user\u2019s locked JPEG could be overwritten by new user, causing permanent loss of JPEG funds.",
                "Repair": "Release the tokens of the existing schedule or revert in finalizePendingNFTValueETH() if there is an existing lock schedule"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../interfaces/ISwapRouter.sol\";\nimport \"../../../interfaces/IUniswapV2Router.sol\";\nimport \"../../../interfaces/ICurve.sol\";\nimport \"../../../interfaces/IBooster.sol\";\nimport \"../../../interfaces/IBaseRewardPool.sol\";\n\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IFungibleAssetVaultForDAO.sol\";\n\n/// @title JPEG'd PUSD Convex autocompounding strategy\n/// @notice This strategy autocompounds Convex rewards from the PUSD/USDC/USDT/MIM Curve pool.\n/// @dev The strategy deposits either USDC or PUSD in the Curve pool depending on which one has lower liquidity.\n/// The strategy sells reward tokens for USDC. If the pool has less PUSD than USDC, this contract uses the\n/// USDC {FungibleAssetVaultForDAO} to mint PUSD using USDC as collateral\ncontract StrategyPUSDConvex is AccessControl {\n    using SafeERC20 for IERC20;\n\n    event Harvested(uint256 wantEarned);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    /// @param booster Convex Booster's address\n    /// @param baseRewardPool Convex BaseRewardPool's address\n    /// @param pid The Convex pool id for PUSD/USDC/USDT/MIM LP tokens\n    struct ConvexConfig {\n        IBooster booster;\n        IBaseRewardPool baseRewardPool;\n        uint256 pid;\n    }\n\n    /// @param curve Curve's PUSD/USDC/USDT/MIM pool address\n    /// @param usdcIndex The USDC token index in curve's pool\n    /// @param pusdIndex The PUSD token index in curve's pool\n    struct CurveConfig {\n        ICurve curve;\n        uint256 usdcIndex;\n        uint256 pusdIndex;\n    }\n\n    /// @param uniswapV2 The UniswapV2 (or Sushiswap) router address\n    /// @param uniswapV3 The UniswapV3 router address\n    struct DexConfig {\n        IUniswapV2Router uniswapV2;\n        ISwapRouter uniswapV3;\n    }\n\n    /// @param rewardTokens The Convex reward tokens\n    /// @param controller The strategy controller\n    /// @param usdcVault The JPEG'd USDC {FungibleAssetVaultForDAO} address\n    struct StrategyConfig {\n        IERC20[] rewardTokens;\n        IController controller;\n        IFungibleAssetVaultForDAO usdcVault;\n    }\n\n    bytes32 public constant STRATEGIST_ROLE = keccak256(\"STRATEGIST_ROLE\");\n\n    /// @notice The PUSD/USDC/USDT/MIM Curve LP token\n    IERC20 public immutable want;\n    IERC20 public immutable jpeg;\n    IERC20 public immutable pusd;\n    IERC20 public immutable weth;\n    IERC20 public immutable usdc;\n\n    DexConfig public dexConfig;\n    CurveConfig public curveConfig;\n    ConvexConfig public convexConfig;\n    StrategyConfig public strategyConfig;\n\n    /// @notice The performance fee to be sent to the DAO/strategists\n    Rate public performanceFee;\n\n    /// @notice lifetime strategy earnings denominated in `want` token\n    uint256 public earned;\n\n    /// @param _want The PUSD/USDC/USDT/MIM Curve LP token\n    /// @param _jpeg The JPEG token address\n    /// @param _pusd The PUSD token address\n    /// @param _weth The WETH token address\n    /// @param _usdc The USDC token address\n    /// @param _dexConfig See {DexConfig} struct\n    /// @param _curveConfig See {CurveConfig} struct\n    /// @param _convexConfig See {ConvexConfig} struct\n    /// @param _strategyConfig See {StrategyConfig} struct\n    /// @param _performanceFee The rate of USDC to be sent to the DAO/strategists\n    constructor(\n        address _want,\n        address _jpeg,\n        address _pusd,\n        address _weth,\n        address _usdc,\n        DexConfig memory _dexConfig,\n        CurveConfig memory _curveConfig,\n        ConvexConfig memory _convexConfig,\n        StrategyConfig memory _strategyConfig,\n        Rate memory _performanceFee\n    ) {\n        require(_want != address(0), \"INVALID_WANT\");\n        require(_jpeg != address(0), \"INVALID_JPEG\");\n        require(_pusd != address(0), \"INVALID_PUSD\");\n        require(_weth != address(0), \"INVALID_WETH\");\n        require(_usdc != address(0), \"INVALID_USDC\");\n        require(\n            address(_dexConfig.uniswapV2) != address(0),\n            \"INVALID_UNISWAP_V2\"\n        );\n        require(\n            address(_dexConfig.uniswapV3) != address(0),\n            \"INVALID_UNISWAP_V3\"\n        );\n        require(address(_curveConfig.curve) != address(0), \"INVALID_CURVE\");\n        require(\n            _curveConfig.pusdIndex != _curveConfig.usdcIndex,\n            \"INVALID_CURVE_INDEXES\"\n        );\n        require(_curveConfig.pusdIndex < 4, \"INVALID_PUSD_CURVE_INDEX\");\n        require(_curveConfig.usdcIndex < 4, \"INVALID_USDC_CURVE_INDEX\");\n        require(\n            address(_convexConfig.booster) != address(0),\n            \"INVALID_CONVEX_BOOSTER\"\n        );\n        require(\n            address(_convexConfig.baseRewardPool) != address(0),\n            \"INVALID_CONVEX_BASE_REWARD_POOL\"\n        );\n        require(\n            address(_strategyConfig.controller) != address(0),\n            \"INVALID_CONTROLLER\"\n        );\n        require(\n            address(_strategyConfig.usdcVault) != address(0),\n            \"INVALID_USDC_VAULT\"\n        );\n\n        for (uint256 i = 0; i < _strategyConfig.rewardTokens.length; i++) {\n            require(\n                address(_strategyConfig.rewardTokens[i]) != address(0),\n                \"INVALID_REWARD_TOKEN\"\n            );\n        }\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        setPerformanceFee(_performanceFee);\n\n        want = IERC20(_want);\n        jpeg = IERC20(_jpeg);\n        pusd = IERC20(_pusd);\n        weth = IERC20(_weth);\n        usdc = IERC20(_usdc);\n\n        dexConfig = _dexConfig;\n        curveConfig = _curveConfig;\n        convexConfig = _convexConfig;\n        strategyConfig = _strategyConfig;\n    }\n\n    modifier onlyController() {\n        require(\n            msg.sender == address(strategyConfig.controller),\n            \"NOT_CONTROLLER\"\n        );\n        _;\n    }\n\n    /// @notice Allows the DAO to set the performance fee\n    /// @param _performanceFee The new performance fee\n    function setPerformanceFee(Rate memory _performanceFee)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(\n            _performanceFee.denominator > 0 &&\n                _performanceFee.denominator >= _performanceFee.numerator,\n            \"INVALID_RATE\"\n        );\n        performanceFee = _performanceFee;\n    }\n\n    /// @notice Allows the DAO to set the strategy controller\n    /// @param _controller The new strategy controller\n    function setController(address _controller)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        strategyConfig.controller = IController(_controller);\n    }\n\n    /// @notice Allows the DAO to set the USDC vault\n    /// @param _vault The new USDC vault\n    function setUSDCVault(address _vault)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_vault != address(0), \"INVALID_USDC_VAULT\");\n        strategyConfig.usdcVault = IFungibleAssetVaultForDAO(_vault);\n    }\n\n    /// @return The strategy's name\n    function getName() external pure returns (string memory) {\n        return \"StrategyPUSDConvex\";\n    }\n\n    /// @return The amount of `want` tokens held by this contract\n    function balanceOfWant() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    /// @return The amount of `want` tokens deposited in the Convex pool by this contract\n    function balanceOfPool() public view returns (uint256) {\n        return convexConfig.baseRewardPool.balanceOf(address(this));\n    }\n\n    /// @return The amount of JPEG currently held by this contract and the amount of JPEG\n    /// rewards available from Convex\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned();\n                //we found jpeg, no need to continue the loop\n                break;\n            }\n        }\n\n        return availableBalance;\n    }\n\n    /// @return The total amount of `want` tokens this contract manages (held + deposited)\n    function balanceOf() external view returns (uint256) {\n        return balanceOfWant() + balanceOfPool();\n    }\n\n    /// @notice Allows anyone to deposit the total amount of `want` tokens in this contract into Convex\n    function deposit() public {\n        uint256 balance = want.balanceOf(address(this));\n        ConvexConfig memory convex = convexConfig;\n        want.safeIncreaseAllowance(address(convex.booster), balance);\n        convex.booster.depositAll(convex.pid, true);\n    }\n\n    /// @notice Controller only function that allows to withdraw non-strategy tokens (e.g tokens sent accidentally)\n    function withdraw(IERC20 _asset)\n        external\n        onlyController\n        returns (uint256 balance)\n    {\n        require(want != _asset, \"want\");\n        require(pusd != _asset, \"pusd\");\n        require(usdc != _asset, \"usdc\");\n        require(weth != _asset, \"weth\");\n        require(jpeg != _asset, \"jpeg\");\n        balance = _asset.balanceOf(address(this));\n        _asset.safeTransfer(address(strategyConfig.controller), balance);\n    }\n\n    /// @notice Allows the controller to withdraw `want` tokens. Normally used with a vault withdrawal\n    /// @param _amount The amount of `want` tokens to withdraw\n    function withdraw(uint256 _amount) external onlyController {\n        address vault = strategyConfig.controller.vaults(address(want));\n        require(vault != address(0), \"ZERO_VAULT\"); // additional protection so we don't burn the funds\n\n        uint256 balance = want.balanceOf(address(this));\n        //if the contract doesn't have enough want, withdraw from Convex\n        if (balance < _amount)\n            convexConfig.baseRewardPool.withdrawAndUnwrap(\n                _amount - balance,\n                false\n            );\n\n        want.safeTransfer(vault, _amount);\n    }\n\n    /// @notice Allows the controller to withdraw all `want` tokens. Normally used when migrating strategies\n    /// @return balance The total amount of funds that have been withdrawn\n    function withdrawAll() external onlyController returns (uint256 balance) {\n        address vault = strategyConfig.controller.vaults(address(want));\n        require(vault != address(0), \"ZERO_VAULT\"); // additional protection so we don't burn the funds\n\n        convexConfig.baseRewardPool.withdrawAllAndUnwrap(false);\n\n        balance = want.balanceOf(address(this));\n        want.safeTransfer(vault, balance);\n    }\n\n    /// @notice Allows the controller to claim JPEG rewards from Convex\n    /// and withdraw JPEG to the `_to` address\n    /// @param _to The address to send JPEG to\n    function withdrawJPEG(address _to) external onlyController {\n        // claim from convex rewards pool\n        convexConfig.baseRewardPool.getReward(address(this), true);\n        jpeg.safeTransfer(_to, jpeg.balanceOf(address(this)));\n    }\n\n    /// @notice Allows members of the `STRATEGIST_ROLE` to compound Convex rewards into Curve\n    /// @param minOutCurve The minimum amount of `want` tokens to receive\n    function harvest(uint256 minOutCurve) external onlyRole(STRATEGIST_ROLE) {\n        convexConfig.baseRewardPool.getReward(address(this), true);\n\n        //Prevent `Stack too deep` errors\n        {\n            DexConfig memory dex = dexConfig;\n            IERC20[] memory rewardTokens = strategyConfig.rewardTokens;\n            IERC20 _weth = weth;\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\n                uint256 balance = rewardTokens[i].balanceOf(address(this));\n\n                if (balance > 0)\n                    //minOut is not needed here, we already have it on the Curve deposit\n                    _swapUniswapV2(\n                        dex.uniswapV2,\n                        rewardTokens[i],\n                        _weth,\n                        balance,\n                        0\n                    );\n            }\n\n            uint256 wethBalance = _weth.balanceOf(address(this));\n            require(wethBalance > 0, \"NOOP\");\n\n            //handle sending jpeg here\n\n            _weth.safeIncreaseAllowance(address(dex.uniswapV3), wethBalance);\n\n            //minOut is not needed here, we already have it on the Curve deposit\n            ISwapRouter.ExactInputParams memory params = ISwapRouter\n                .ExactInputParams(\n                    abi.encodePacked(weth, uint24(500), usdc),\n                    address(this),\n                    block.timestamp,\n                    wethBalance,\n                    0\n                );\n\n            dex.uniswapV3.exactInput(params);\n        }\n\n        StrategyConfig memory strategy = strategyConfig;\n        CurveConfig memory curve = curveConfig;\n\n        uint256 usdcBalance = usdc.balanceOf(address(this));\n\n        //take the performance fee\n        uint256 fee = (usdcBalance * performanceFee.numerator) /\n            performanceFee.denominator;\n        usdc.safeTransfer(strategy.controller.feeAddress(), fee);\n        usdcBalance -= fee;\n\n        uint256 pusdCurveBalance = curve.curve.balances(curve.pusdIndex);\n        //USDC has 6 decimals while PUSD has 18. We need to convert the USDC\n        //balance to 18 decimals to compare it with the PUSD balance\n        uint256 usdcCurveBalance = curve.curve.balances(curve.usdcIndex) *\n            10**12;\n\n        //The curve pool has 4 tokens, we are doing a single asset deposit with either USDC or PUSD\n        uint256[4] memory liquidityAmounts = [uint256(0), 0, 0, 0];\n        if (usdcCurveBalance > pusdCurveBalance) {\n            //if there's more USDC than PUSD in the pool, use USDC as collateral to mint PUSD\n            //and deposit it into the Curve pool\n            usdc.safeIncreaseAllowance(\n                address(strategy.usdcVault),\n                usdcBalance\n            );\n            strategy.usdcVault.deposit(usdcBalance);\n\n            //check the vault's credit limit, it should be 1:1 for USDC\n            uint256 toBorrow = strategy.usdcVault.getCreditLimit(usdcBalance);\n\n            strategy.usdcVault.borrow(toBorrow);\n            liquidityAmounts[curve.pusdIndex] = toBorrow;\n\n            pusd.safeIncreaseAllowance(address(curve.curve), toBorrow);\n        } else {\n            //if there's more PUSD than USDC in the pool, deposit USDC\n            liquidityAmounts[curve.usdcIndex] = usdcBalance;\n            usdc.safeIncreaseAllowance(address(curve.curve), usdcBalance);\n        }\n\n        curve.curve.add_liquidity(liquidityAmounts, minOutCurve);\n\n        uint256 wantBalance = balanceOfWant();\n\n        deposit();\n\n        earned += wantBalance;\n        emit Harvested(wantBalance);\n    }\n\n    /// @dev Swaps `tokenIn` for `tokenOut` on UniswapV2 (or Sushiswap)\n    /// @param router The UniswapV2 (or Sushiswap) router\n    /// @param tokenIn The input token for the swap\n    /// @param tokenOut The output token for the swap\n    /// @param amountIn The amount of `tokenIn` to swap\n    /// @param minOut The minimum amount of `tokenOut` to receive for the TX not to revert\n    function _swapUniswapV2(\n        IUniswapV2Router router,\n        IERC20 tokenIn,\n        IERC20 tokenOut,\n        uint256 amountIn,\n        uint256 minOut\n    ) internal {\n        tokenIn.safeIncreaseAllowance(address(router), amountIn);\n\n        address[] memory path = new address[](2);\n        path[0] = address(tokenIn);\n        path[1] = address(tokenOut);\n\n        router.swapExactTokensForTokens(\n            amountIn,\n            minOut,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IStrategy.sol\";\n\n/// @title JPEG'd strategies controller\n/// @notice Allows members of the `STRATEGIST_ROLE` to manage all the strategies in the JPEG'd ecosystem\ncontract Controller is AccessControl {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant STRATEGIST_ROLE = keccak256(\"STRATEGIST_ROLE\");\n\n    IERC20 public immutable jpeg;\n    address public feeAddress;\n\n    mapping(IERC20 => address) public vaults;\n    mapping(IERC20 => IStrategy) public strategies;\n    mapping(IERC20 => mapping(IStrategy => bool)) public approvedStrategies;\n\n    /// @param _feeAddress The address to send fees to\n    constructor(address _jpeg, address _feeAddress) {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        setFeeAddress(_feeAddress);\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @notice Allows the DAO to set the fee receiver address\n    /// @param _feeAddress The new fee receiver address\n    function setFeeAddress(address _feeAddress)\n        public\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeAddress != address(0), \"INVALID_FEE_ADDRESS\");\n        feeAddress = _feeAddress;\n    }\n\n    /// @notice Allows the strategist to set the vault for a token\n    /// @param _token The token to set the vault for\n    /// @param _vault The vault address\n    function setVault(IERC20 _token, address _vault)\n        external\n        onlyRole(STRATEGIST_ROLE)\n    {\n        require(vaults[_token] == address(0), \"ALREADY_HAS_VAULT\");\n        require(_vault != address(0), \"INVALID_VAULT\");\n        vaults[_token] = _vault;\n    }\n\n    /// @notice Allows the DAO to approve a strategy for a token\n    /// @param _token The strategy's target token\n    /// @param _strategy The strategy for the token\n    function approveStrategy(IERC20 _token, IStrategy _strategy)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(address(_token) != address(0), \"INVALID_TOKEN\");\n        require(address(_strategy) != address(0), \"INVALID_STRATEGY\");\n\n        approvedStrategies[_token][_strategy] = true;\n    }\n\n    /// @notice Allows the DAO to revoke a strategy for a token\n    /// @param _token The strategy's target token\n    /// @param _strategy The strategy to revoke\n    function revokeStrategy(IERC20 _token, IStrategy _strategy)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(address(_token) != address(0), \"INVALID_TOKEN\");\n        require(address(_strategy) != address(0), \"INVALID_STRATEGY\");\n\n        approvedStrategies[_token][_strategy] = false;\n    }\n\n    /// @notice Allows the members of the `STRATEGIST_ROLE` to change between approved strategies for `_token`\n    /// @param _token The token to change strategy for\n    /// @param _strategy The strategy to change to\n    function setStrategy(IERC20 _token, IStrategy _strategy)\n        external\n        onlyRole(STRATEGIST_ROLE)\n    {\n        require(\n            approvedStrategies[_token][_strategy] == true,\n            \"STRATEGY_NOT_APPROVED\"\n        );\n\n        IStrategy _current = strategies[_token];\n        if (address(_current) != address(0)) {\n            //withdraw all funds from the current strategy\n            _current.withdrawAll();\n            _current.withdraw(address(jpeg));\n        }\n        strategies[_token] = _strategy;\n    }\n\n    /// @notice Allows anyone to deposit tokens from this contract to the token's strategy. Usually called by a vault after having sent tokens to this contract.\n    /// @param _token The token to deposit\n    /// @param _amount The amount of tokens to deposit\n    function earn(IERC20 _token, uint256 _amount) external {\n        IStrategy strategy = strategies[_token];\n        _token.safeTransfer(address(strategy), _amount);\n        strategy.deposit();\n    }\n\n    /// @return The amount of tokens held by `_token`'s strategy\n    /// @param _token The token to check\n    function balanceOf(IERC20 _token) external view returns (uint256) {\n        return strategies[_token].balanceOf();\n    }\n\n    /// @return The amount of JPEG available to be withdrawn from `_token`'s strategy\n    /// @param _token The token to check\n    function balanceOfJPEG(IERC20 _token) external view returns (uint256) {\n        return strategies[_token].balanceOfJPEG();\n    }\n\n    /// @notice Allows members of the `STRATEGIST_ROLE` to withdraw all strategy tokens from a strategy (e.g. In case of a bug in the strategy)\n    /// The tokens will be sent to the token's vault\n    /// @param _token The token to withdraw\n    function withdrawAll(IERC20 _token) external onlyRole(STRATEGIST_ROLE) {\n        strategies[_token].withdrawAll();\n    }\n\n    /// @notice Allows members of the `STRATEGIST_ROLE` to withdraw tokens stuck in this constract\n    /// @param _token The token to withdraw\n    /// @param _amount The amount of tokens to withdraw\n    function inCaseTokensGetStuck(IERC20 _token, uint256 _amount)\n        external\n        onlyRole(STRATEGIST_ROLE)\n    {\n        _token.safeTransfer(msg.sender, _amount);\n    }\n\n    /// @notice Allows members of the `STRATEGIST_ROLE` to withdraw non strategy tokens from a strategy\n    /// @param _strategy The strategy to withdraw from\n    /// @param _token The token to withdraw\n    function inCaseStrategyTokensGetStuck(IStrategy _strategy, address _token)\n        external\n        onlyRole(STRATEGIST_ROLE)\n    {\n        _strategy.withdraw(_token);\n    }\n\n    /// @notice Allows a vault to withdraw strategy tokens from a strategy (usually done during withdrawals from vaults)\n    /// @param _token The token to withdraw\n    /// @param _amount The amount of tokens to withdraw\n    function withdraw(IERC20 _token, uint256 _amount) public {\n        require(msg.sender == vaults[_token], \"NOT_VAULT\");\n        strategies[_token].withdraw(_amount);\n    }\n\n    /// @notice Allows the vault for token `_token` to withdraw JPEG from\n    /// `_token`'s strategy\n    /// @param _token The strategy's token\n    /// @param _to The address to send JPEG to\n    function withdrawJPEG(\n        IERC20 _token,\n        address _to\n    ) external {\n        require(msg.sender == vaults[_token], \"NOT_VAULT\");\n        strategies[_token].withdrawJPEG(_to);\n    }\n}\n\n\n",
        "CodeNames": [
            "StrategyPUSDConvex.sol",
            "Controller.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Controller.sol and StrategyPUSDConvex.sol",
                "Type": "Failure to handle edge case",
                "Description": "The controller calls the withdraw() method to withdraw JPEGs from the contract, but the strategy might blacklist the JPEG asset, which is what the PUSDConvex strategy has done. The migration would therefore revert.",
                "Repair": "Replace _current.withdraw(address(jpeg)); with _current.withdrawJPEG(vaults[_token])"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title JPEG'd LP Farming\n/// @notice Users can stake their JPEG'd ecosystem LP tokens to get JPEG rewards\n/// @dev This contract doesn't mint JPEG tokens, instead the owner (the JPEG'd DAO) allocates x amount of JPEG to be distributed as a reward for liquidity providers.\n/// To ensure that enough tokens are allocated, an epoch system is implemented.\n/// The owner is required to allocate enough tokens (`_rewardPerBlock * (_endBlock - _startBlock)`) when creating a new epoch.\n/// When there no epoch is ongoing, the contract stops emitting rewards\ncontract LPFarming is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event Claim(address indexed user, uint256 indexed pid, uint256 amount);\n    event ClaimAll(address indexed user, uint256 amount);\n\n    /// @dev Data relative to a user's staking position\n    /// @param amount The amount of LP tokens the user has provided\n    /// @param lastAccRewardPerShare The `accRewardPerShare` pool value at the time of the user's last claim\n    struct UserInfo {\n        uint256 amount;\n        uint256 lastAccRewardPerShare;\n    }\n\n    /// @dev Data relative to an LP pool\n    /// @param lpToken The LP token accepted by the pool\n    /// @param allocPoint Allocation points assigned to the pool. Determines the share of `rewardPerBlock` allocated to this pool\n    /// @param lastRewardBlock Last block number in which reward distribution occurred\n    /// @param accRewardPerShare Accumulated rewards per share, times 1e36. The amount of rewards the pool has accumulated per unit of LP token deposited\n    struct PoolInfo {\n        IERC20 lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardBlock;\n        uint256 accRewardPerShare;\n    }\n\n    /// @dev Data relative to an epoch\n    /// @param startBlock The epoch's starting block\n    /// @param endBlock The epoch's starting block\n    /// @param rewardPerBlock The amount of JPEG rewards distributed per block during this epoch\n    struct EpochInfo {\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 rewardPerBlock;\n    }\n\n    /// @notice The reward token, JPEG\n    IERC20 public immutable jpeg;\n\n    /// @notice The current epoch\n    /// @dev We don't need to store data about previous epochs, to simplify logic we only store data about the current epoch\n    EpochInfo public epoch;\n    /// @notice All the LP pools, active and inactive\n    PoolInfo[] public poolInfo;\n    /// @notice User staking positions, divided by PID\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    /// @notice Sum of the allocation points for all the pools\n    /// @dev Used to calculate the share of `rewardPerBlock` for each pool.\n    uint256 public totalAllocPoint;\n\n    /// @dev User's (total) withdrawable rewards\n    mapping(address => uint256) private userRewards;\n    /// @notice Contracts that are allowed to interact with the LP farm\n    /// @dev See the {noContract} modifier for more info\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _jpeg The reward token\n    constructor(address _jpeg) {\n        jpeg = IERC20(_jpeg);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the LP farm.\n    /// Prevents non-whitelisted 3rd party contracts (e.g. autocompounders) from diluting liquidity providers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts aren't allowed to farm\"\n        );\n        _;\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to start a new epoch. Can only be called when there's no ongoing epoch\n    /// @param _startBlock The new epoch's start block. Has to be greater than the previous epoch's `endBlock`\n    /// @param _endBlock The new epoch's end block. Has to be greater than `_startBlock`\n    /// @param _rewardPerBlock The new epoch's amount of rewards to distribute per block. Must be greater than 0\n    function newEpoch(\n        uint256 _startBlock,\n        uint256 _endBlock,\n        uint256 _rewardPerBlock\n    ) external onlyOwner {\n        require(_startBlock >= block.number, \"Invalid start block\");\n        require(_endBlock > _startBlock, \"Invalid end block\");\n        require(_rewardPerBlock > 0, \"Invalid reward per block\");\n\n        //update all pools to ensure that they have all been updated up to the last epoch's `endBlock`\n        _massUpdatePools();\n\n        uint256 remainingRewards = epoch.rewardPerBlock *\n            (epoch.endBlock - _blockNumber());\n        uint256 newRewards = _rewardPerBlock * (_endBlock - _startBlock);\n\n        epoch.startBlock = _startBlock;\n        epoch.endBlock = _endBlock;\n        epoch.rewardPerBlock = _rewardPerBlock;\n\n        if (remainingRewards > newRewards) {\n            jpeg.safeTransfer(msg.sender, remainingRewards - newRewards);\n        } else if (remainingRewards < newRewards) {\n            jpeg.safeTransferFrom(\n                msg.sender,\n                address(this),\n                newRewards - remainingRewards\n            );\n        }\n    }\n\n    /// @notice Allows the owner to add a new pool\n    /// @param _allocPoint Allocation points to assign to the new pool\n    /// @param _lpToken The LP token accepted by the new pool\n    function add(uint256 _allocPoint, IERC20 _lpToken) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 lastRewardBlock = _blockNumber();\n        totalAllocPoint = totalAllocPoint + _allocPoint;\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accRewardPerShare: 0\n            })\n        );\n    }\n\n    /// @notice Allows the owner to change a pool's allocation points\n    /// @param _pid The pool id of the pool to modify\n    /// @param _allocPoint The new allocation points\n    function set(uint256 _pid, uint256 _allocPoint) external onlyOwner {\n        _massUpdatePools();\n\n        uint256 prevAllocPoint = poolInfo[_pid].allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n        if (prevAllocPoint != _allocPoint) {\n            totalAllocPoint = totalAllocPoint - prevAllocPoint + _allocPoint;\n        }\n    }\n\n    /// @notice Returns the number of pools available\n    /// @return The length of the `poolInfo` array\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    /// @notice Frontend function used to calculate the amount of rewards `_user` can claim from the pool with id `_pid`\n    /// @param _pid The pool id\n    /// @param _user The address of the user\n    /// @return The amount of rewards claimable from `_pid` by user `_user`\n    function pendingReward(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        //if blockNumber is greater than the pool's `lastRewardBlock` the pool's `accRewardPerShare` is outdated,\n        //we need to calculate the up to date amount to return an accurate reward value\n        if (blockNumber > lastRewardBlock && lpSupply != 0) {\n            uint256 reward = ((blockNumber - lastRewardBlock) *\n                epoch.rewardPerBlock *\n                1e36 *\n                pool.allocPoint) / totalAllocPoint;\n            accRewardPerShare += reward / lpSupply;\n        }\n        return\n            //rewards that the user had already accumulated but not claimed\n            userRewards[_user] +\n            //subtracting the user's `lastAccRewardPerShare` from the pool's `accRewardPerShare` results in the amount of rewards per share\n            //the pool has accumulated since the user's last claim, multiplying it by the user's shares results in the amount of new rewards claimable\n            //by the user\n            (user.amount * (accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n    }\n\n    /// @notice Allows users to deposit `_amount` of LP tokens in the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Deposit} event\n    /// @param _pid The id of the pool to deposit into\n    /// @param _amount The amount of LP tokens to deposit\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        pool.lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n        user.amount = user.amount + _amount;\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    /// @notice Allows users to withdraw `_amount` of LP tokens from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Withdraw} event\n    /// @param _pid The id of the pool to withdraw from\n    /// @param _amount The amount of LP tokens to withdraw\n    function withdraw(uint256 _pid, uint256 _amount)\n        external\n        noContract(msg.sender)\n    {\n        require(_amount > 0, \"invalid_amount\");\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"insufficient_amount\");\n\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        user.amount -= _amount;\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    /// @dev Normalizes the current `block.number`. See {_normalizeBlockNumber} for more info\n    /// @return Normalized `block.number`\n    function _blockNumber() internal view returns (uint256) {\n        return _normalizeBlockNumber(block.number);\n    }\n\n    /// @dev Normalizes `blockNumber` to fit within the bounds of an epoch.\n    /// This is done to ensure that no rewards are distributed for staking outside of an epoch without modifying the reward logic.\n    /// For example:\n    /// `blockNumber` is 1100, the epoch's `endBlock` is 1000. In this case the function would return 1000. If this value were to be used\n    /// in the {_updatePool} function, where the pool's `lastRewardBlock` is 990, only the rewards from block 990 to block 1000 would be distributed\n    /// @return Normalized `blockNumber`\n    function _normalizeBlockNumber(uint256 blockNumber)\n        internal\n        view\n        returns (uint256)\n    {\n        if (blockNumber < epoch.startBlock) return epoch.startBlock;\n\n        if (blockNumber > epoch.endBlock) return epoch.endBlock;\n\n        return blockNumber;\n    }\n\n    /// @dev Calls {_updatePool} for every pool\n    function _massUpdatePools() internal {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            _updatePool(pid);\n        }\n    }\n\n    /// @dev Updates the state of the pool at index `_pid`\n    /// @param _pid The pool to update\n    function _updatePool(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (pool.allocPoint == 0) {\n            return;\n        }\n\n        uint256 blockNumber = _blockNumber();\n        //normalizing the pool's `lastRewardBlock` ensures that no rewards are distributed by staking outside of an epoch\n        uint256 lastRewardBlock = _normalizeBlockNumber(pool.lastRewardBlock);\n        if (blockNumber <= lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = blockNumber;\n            return;\n        }\n        uint256 reward = ((blockNumber - lastRewardBlock) *\n            epoch.rewardPerBlock *\n            1e36 *\n            pool.allocPoint) / totalAllocPoint;\n        pool.accRewardPerShare = pool.accRewardPerShare + reward / lpSupply;\n        pool.lastRewardBlock = blockNumber;\n    }\n\n    /// @dev Updates `msg.sender`'s claimable rewards by adding pending rewards from `_pid`\n    /// @param _pid The pool to withdraw rewards from\n    function _withdrawReward(uint256 _pid) internal returns (uint256) {\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 pending = (user.amount *\n            (poolInfo[_pid].accRewardPerShare - user.lastAccRewardPerShare)) /\n            1e36;\n        if (pending > 0) {\n            userRewards[msg.sender] += pending;\n        }\n\n        user.lastAccRewardPerShare = poolInfo[_pid].accRewardPerShare;\n\n        return pending;\n    }\n\n    /// @notice Allows users to claim rewards from the pool with id `_pid`. Non whitelisted contracts can't call this function\n    /// @dev Emits a {Claim} event\n    /// @param _pid The pool to claim rewards from\n    function claim(uint256 _pid) external nonReentrant noContract(msg.sender) {\n        _updatePool(_pid);\n        _withdrawReward(_pid);\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit Claim(msg.sender, _pid, rewards);\n    }\n\n    /// @notice Allows users to claim rewards from all pools. Non whitelisted contracts can't call this function\n    /// @dev Emits a {ClaimAll} event\n    function claimAll() external nonReentrant noContract(msg.sender) {\n        for (uint256 i = 0; i < poolInfo.length; i++) {\n            _updatePool(i);\n            _withdrawReward(i);\n        }\n\n        uint256 rewards = userRewards[msg.sender];\n        require(rewards > 0, \"no_reward\");\n\n        jpeg.safeTransfer(msg.sender, rewards);\n        userRewards[msg.sender] = 0;\n\n        emit ClaimAll(msg.sender, rewards);\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n",
        "CodeNames": [
            "LPFarming.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LPFarming.sol",
                "Type": "Lack of functionality",
                "Description": "A part of reward tokens will be locked in the farming pool if no user deposits lpToken at the epoch.startBlock. Since there is no function for the admin (or users) to withdraw the remaining, the reward will be stucked in the pool forever.",
                "Repair": "Add a new function for the admin (or user) to claim all rewards which remained in the pool when epoch.endTime has passed"
            },
            {
                "Location": "LPFarming.sol#L141-L154, LPFarming.sol#L288-L311",
                "Type": "Incorrect reward calculation",
                "Description": "When _lpToken is jpeg, reward calculation is incorrect.",
                "Repair": "Add a check that _lpToken is not jpeg in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token."
            },
            {
                "Location": "LPFarming.sol#L190",
                "Type": "Locked rewards",
                "Description": "Rewards will be locked if user transfer directly to pool without using deposit function.",
                "Repair": "Declare a new variable totalLPSupply to the struct PoolInfo, and use it instead of pool.lpToken.balanceOf(address(this))."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../escrow/NFTEscrow.sol\";\nimport \"../interfaces/ICryptoPunks.sol\";\n\n /// @title CryptoPunks NFTVault helper contract\n /// @notice Allows compatibility between CryptoPunks and {NFTVault}\n /// @dev CryptoPunks IERC721 compatibility.\n /// Meant to only be used by {NFTVault}.\n /// This contract is NOT an ERC721 wrapper for punks and is not meant to implement the ERC721 interface fully, \n /// its only purpose is to serve as a proxy between {NFTVault} and CryptoPunks.\n /// The owner is {NFTVault}\ncontract CryptoPunksHelper is NFTEscrow, OwnableUpgradeable {\n\n    /// @param punksAddress Address of the CryptoPunks contract\n    function initialize(address punksAddress) external initializer {\n        __NFTEscrow_init(punksAddress);\n        __Ownable_init();\n    }\n\n    /// @notice Returns the owner of the punk at index `_idx`\n    /// @dev If the owner of the punk is this contract we return the address of the {NFTVault} for compatibility\n    /// @param _idx The punk index\n    /// @return The owner of the punk if != `address(this)`, otherwise the the owner of this contract\n    function ownerOf(uint256 _idx) external view returns (address) {\n        address account = ICryptoPunks(nftAddress).punkIndexToAddress(_idx);\n\n        return account == address(this) ? owner() : account;\n    }\n\n    /// @notice Function called by {NFTVault} to transfer punks. Can only be called by the owner\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _idx The index of the punk to transfer\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _idx\n    ) external onlyOwner {\n        _transferFrom(_from, _to, _idx);\n    }\n\n    /// @dev We aren't calling {onERC721Received} on the _to address because punks don't implement\n    /// the {ERC721} interface, but we are including this function for compatibility with the {NFTVault} contract.\n    /// Calling the {onERC721Received} function on the receiver contract could cause problems as we aren't sending an ERC721.\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _idx The index of the punk to transfer\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _idx\n    ) external onlyOwner {\n        _transferFrom(_from, _to, _idx);\n    }\n\n    /// @dev Implementation of {transferFrom} and {safeTransferFrom}. We are using {NFTEscrow} for atomic transfers.\n    /// See {NFTEscrow} for more info\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _idx The index of the punk to transfer\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _idx\n    ) internal {\n        ICryptoPunks punks = ICryptoPunks(nftAddress);\n\n        address account = punks.punkIndexToAddress(_idx);\n\n        //if the owner is this address we don't need to go through {NFTEscrow}\n        if (account != address(this)) {\n            _executeTransfer(_from, _idx);\n        }\n\n        require(\n            punks.punkIndexToAddress(_idx) == address(this), //this should never be false\n            \"CryptoPunksHelper: not_deposited\"\n        );\n\n        //If _to is the owner ({NFTVault}), we aren't sending the punk\n        //since we'd have no way to get it back\n        if (_to != owner()) punks.transferPunk(_to, _idx);\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /// @dev The {transferPunk} function is used as the escrow's payload.\n    /// @param _idx The index of the punk that's going to be transferred using {NFTEscrow}\n    function _encodeFlashEscrowPayload(uint256 _idx)\n        internal\n        view\n        override\n        returns (bytes memory)\n    {\n        return\n            abi.encodeWithSignature(\n                \"transferPunk(address,uint256)\",\n                address(this),\n                _idx\n            );\n    }\n}\n\n\n",
        "CodeNames": [
            "CryptoPunksHelper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CryptoPunksHelper.sol",
                "Type": "Lack of validation",
                "Description": "In the NFT helper contract, there is no validation on that the receiver address must not be address zero. Therefore, it allows owner or an attacker who gain access to the owner address to burn NFTs forever through the functions by transferring the NFTs to address zero.",
                "Repair": "Restrict the receiver address to not be address zero"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../interfaces/IAggregatorV3Interface.sol\";\nimport \"../interfaces/IStableCoin.sol\";\nimport \"../interfaces/IERC20Decimals.sol\";\n\n/// @title Fungible asset vault (for DAO and ecosystem contracts)\n/// @notice Allows the DAO and other whitelisted addresses to mint PUSD using fungible assets as collateral\n/// @dev The contract only supports one asset, meaning that multiple instances\n/// of this contract are going to be deployed if support for multiple assets is needed.\n/// The credit limit rate of the supported asset is set at deploy time.\n/// This contract doesn't support liquidations. In case of undercollateralization,\n/// the DAO will promptly deposit more collateral.\n/// The vault implements {AccessControlUpgradeable} and only allows whitelisted wallets\n/// to deposit/borrow/withdraw/repay. The contract doesn't keep track of the individual\n/// debt/deposited collateral of each whitelisted address, it instead uses global debt and deposited collateral.\n/// This is intentional and it's done to allow the DAO to repay debt of ecosystem contracts ({StrategyPUSDConvex}, for example)\ncontract FungibleAssetVaultForDAO is\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IStableCoin;\n\n    event Deposit(address indexed user, uint256 depositAmount);\n    event Borrow(address indexed user, uint256 borrowAmount);\n    event Repay(address indexed user, uint256 repayAmount);\n    event Withdraw(address indexed user, uint256 withdrawAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n\n    /// @dev This contract can handle unwrapped ETH if `address(0)` is passed as the `_collateralAsset`\n    /// parameter in the {initialize} function\n    address internal constant ETH = address(0);\n\n    address public collateralAsset;\n    IStableCoin public stablecoin;\n    /// @dev We store the value of a single unit of the collateral asset `10 ** decimals`\n    /// instead of fetching it everytime to save gas\n    uint256 private _collateralUnit;\n\n    IAggregatorV3Interface public oracle;\n\n    Rate public creditLimitRate;\n\n    /// @notice Amount of deposited collateral\n    uint256 public collateralAmount;\n    /// @notice Outstanding debt\n    uint256 public debtAmount;\n\n    /// @param _collateralAsset The address of the collateral asset - `address(0)` for ETH\n    /// @param _stablecoin PUSD address\n    /// @param _oracle Chainlink price feed for `_collateralAsset`/USD\n    /// @param _creditLimitRate Max outstanding debt to collateral ratio\n    function initialize(\n        address _collateralAsset,\n        IStableCoin _stablecoin,\n        IAggregatorV3Interface _oracle,\n        Rate memory _creditLimitRate\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\n        setCreditLimitRate(_creditLimitRate);\n\n        collateralAsset = _collateralAsset;\n        stablecoin = _stablecoin;\n        if (_collateralAsset == ETH) {\n            _collateralUnit = 1 ether;\n        } else {\n            _collateralUnit = 10**IERC20Decimals(_collateralAsset).decimals();\n        }\n\n        oracle = _oracle;\n    }\n\n    /// @notice Allows members of the `DEFAULT_ADMIN_ROLE` to change the max outstanding debt to collateral ratio\n    /// @param _creditLimitRate The new ratio\n    function setCreditLimitRate(Rate memory _creditLimitRate) public onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(\n            _creditLimitRate.denominator > 0 &&\n                //denominator can be equal to the numerator in some cases (stablecoins used as collateral)\n                _creditLimitRate.denominator >= _creditLimitRate.numerator,\n            \"invalid_rate\"\n        );\n        creditLimitRate = _creditLimitRate;\n    }\n\n    /// @dev Returns the USD price of one unit of collateral asset, using 18 decimals precision\n    /// @return The USD price\n    function _collateralPriceUsd() internal view returns (uint256) {\n        int256 answer = oracle.latestAnswer();\n        uint8 decimals = oracle.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n\n        //check chainlink's precision and convert it to 18 decimals\n        return\n            decimals > 18\n                ? uint256(answer) / 10**(decimals - 18)\n                : uint256(answer) * 10**(18 - decimals);\n    }\n\n    /// @dev Returns the USD value of `amount` units of collateral, using 18 decimals precision\n    /// @param amount The amount of collateral to calculate the value of\n    /// @return The USD value\n    function _getCollateralValue(uint256 amount)\n        internal\n        view\n        returns (uint256)\n    {\n        return (amount * _collateralPriceUsd()) / _collateralUnit;\n    }\n\n    /// @notice Returns the max debt for `amount` of collateral\n    /// @param amount The amount of collateral to calculate max debt for\n    /// @return Max debt value for `amount`\n    function getCreditLimit(uint256 amount) public view returns (uint256) {\n        uint256 collateralValue = _getCollateralValue(amount);\n        return\n            (collateralValue * creditLimitRate.numerator) /\n            creditLimitRate.denominator;\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to deposit `amount` of collateral\n    /// @dev Emits a {Deposit} event\n    /// @param amount The amount of collateral to deposit\n    function deposit(uint256 amount) external payable onlyRole(WHITELISTED_ROLE) {\n        require(amount > 0, \"invalid_amount\");\n\n        if (collateralAsset == ETH) {\n            require(msg.value == amount, \"invalid_msg_value\");\n        } else {\n            require(msg.value == 0, \"non_zero_eth_value\");\n            IERC20Upgradeable(collateralAsset).safeTransferFrom(\n                msg.sender,\n                address(this),\n                amount\n            );\n        }\n\n        collateralAmount += amount;\n\n        emit Deposit(msg.sender, amount);\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to borrow `amount` of PUSD against the deposited collateral\n    /// @dev Emits a {Borrow} event\n    /// @param amount The amount of PUSD to borrow\n    function borrow(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n        require(amount > 0, \"invalid_amount\");\n\n        uint256 creditLimit = getCreditLimit(collateralAmount);\n        uint256 newDebtAmount = debtAmount + amount;\n        require(newDebtAmount <= creditLimit, \"insufficient_credit\");\n\n        debtAmount = newDebtAmount;\n        stablecoin.mint(msg.sender, amount);\n\n        emit Borrow(msg.sender, amount);\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to repay `amount` of debt using PUSD\n    /// @dev Emits a {Repay} event\n    /// @param amount The amount of debt to repay\n    function repay(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n        require(amount > 0, \"invalid_amount\");\n\n        amount = amount > debtAmount ? debtAmount : amount;\n\n        debtAmount -= amount;\n        stablecoin.burnFrom(msg.sender, amount);\n\n        emit Repay(msg.sender, amount);\n    }\n\n    /// @notice Allows members of the `WHITELISTED_ROLE` to withdraw `amount` of deposited collateral\n    /// @dev Emits a {Withdraw} event\n    /// @param amount The amount of collateral to withdraw\n    function withdraw(uint256 amount) external onlyRole(WHITELISTED_ROLE) nonReentrant {\n        require(amount > 0 && amount <= collateralAmount, \"invalid_amount\");\n\n        uint256 creditLimit = getCreditLimit(collateralAmount - amount);\n        require(creditLimit >= debtAmount, \"insufficient_credit\");\n\n        collateralAmount -= amount;\n\n        if (collateralAsset == ETH) payable(msg.sender).transfer(amount);\n        else\n            IERC20Upgradeable(collateralAsset).safeTransfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    uint256[50] private __gap;\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/IAggregatorV3Interface.sol\";\nimport \"../interfaces/IStableCoin.sol\";\nimport \"../interfaces/IJPEGLock.sol\";\n\n/// @title NFT lending vault\n/// @notice This contracts allows users to borrow PUSD using NFTs as collateral.\n/// The floor price of the NFT collection is fetched using a chainlink oracle, while some other more valuable traits\n/// can have an higher price set by the DAO. Users can also increase the price (and thus the borrow limit) of their\n/// NFT by submitting a governance proposal. If the proposal is approved the user can lock a percentage of the new price\n/// worth of JPEG to make it effective\ncontract NFTVault is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    event PositionOpened(address indexed owner, uint256 indexed index);\n    event Borrowed(\n        address indexed owner,\n        uint256 indexed index,\n        uint256 amount\n    );\n    event Repaid(address indexed owner, uint256 indexed index, uint256 amount);\n    event PositionClosed(address indexed owner, uint256 indexed index);\n    event Liquidated(\n        address indexed liquidator,\n        address indexed owner,\n        uint256 indexed index,\n        bool insured\n    );\n    event Repurchased(address indexed owner, uint256 indexed index);\n    event InsuranceExpired(address indexed owner, uint256 indexed index);\n\n    enum BorrowType {\n        NOT_CONFIRMED,\n        NON_INSURANCE,\n        USE_INSURANCE\n    }\n\n    struct Position {\n        BorrowType borrowType;\n        uint256 debtPrincipal;\n        uint256 debtPortion;\n        uint256 debtAmountForRepurchase;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    struct VaultSettings {\n        Rate debtInterestApr;\n        Rate creditLimitRate;\n        Rate liquidationLimitRate;\n        Rate valueIncreaseLockRate;\n        Rate organizationFeeRate;\n        Rate insurancePurchaseRate;\n        Rate insuranceLiquidationPenaltyRate;\n        uint256 insuraceRepurchaseTimeLimit;\n        uint256 borrowAmountCap;\n    }\n\n    bytes32 public constant DAO_ROLE = keccak256(\"DAO_ROLE\");\n    bytes32 public constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\n\n    bytes32 public constant CUSTOM_NFT_HASH = keccak256(\"CUSTOM\");\n\n    IStableCoin public stablecoin;\n    /// @notice Chainlink ETH/USD price feed\n    IAggregatorV3Interface public ethAggregator;\n    /// @notice Chainlink JPEG/USD price feed\n    IAggregatorV3Interface public jpegAggregator;\n    /// @notice Chainlink NFT floor oracle\n    IAggregatorV3Interface public floorOracle;\n    /// @notice Chainlink NFT fallback floor oracle\n    IAggregatorV3Interface public fallbackOracle;\n    /// @notice JPEGLocker, used by this contract to lock JPEG and increase the value of an NFT\n    IJPEGLock public jpegLocker;\n    IERC721Upgradeable public nftContract;\n\n    /// @notice If true, the floor price won't be fetched using the Chainlink oracle but\n    /// a value set by the DAO will be used instead\n    bool public daoFloorOverride;\n    // @notice If true, the floor price will be fetched using the fallback oracle\n    bool public useFallbackOracle;\n    /// @notice Total outstanding debt\n    uint256 public totalDebtAmount;\n    /// @dev Last time debt was accrued. See {accrue} for more info\n    uint256 public totalDebtAccruedAt;\n    uint256 public totalFeeCollected;\n    uint256 internal totalDebtPortion;\n\n    VaultSettings public settings;\n\n    /// @dev Keeps track of all the NFTs used as collateral for positions\n    EnumerableSetUpgradeable.UintSet private positionIndexes;\n\n    mapping(uint256 => Position) private positions;\n    mapping(uint256 => address) public positionOwner;\n    mapping(bytes32 => uint256) public nftTypeValueETH;\n    mapping(uint256 => uint256) public nftValueETH;\n    //bytes32(0) is floor\n    mapping(uint256 => bytes32) public nftTypes;\n    mapping(uint256 => uint256) public pendingNFTValueETH;\n\n    /// @dev Checks if the provided NFT index is valid\n    /// @param nftIndex The index to check\n    modifier validNFTIndex(uint256 nftIndex) {\n        //The standard OZ ERC721 implementation of ownerOf reverts on a non existing nft isntead of returning address(0)\n        require(nftContract.ownerOf(nftIndex) != address(0), \"invalid_nft\");\n        _;\n    }\n\n    struct NFTCategoryInitializer {\n        bytes32 hash;\n        uint256 valueETH;\n        uint256[] nfts;\n    }\n\n    /// @param _stablecoin PUSD address\n    /// @param _nftContract The NFT contrat address. It could also be the address of an helper contract\n    /// if the target NFT isn't an ERC721 (CryptoPunks as an example)\n    /// @param _ethAggregator Chainlink ETH/USD price feed address\n    /// @param _jpegAggregator Chainlink JPEG/USD price feed address\n    /// @param _floorOracle Chainlink floor oracle address\n    /// @param _fallbackOracle Chainlink fallback floor oracle address\n    /// @param _typeInitializers Used to initialize NFT categories with their value and NFT indexes.\n    /// Floor NFT shouldn't be initialized this way\n    /// @param _jpegLocker JPEGLock address\n    /// @param _settings Initial settings used by the contract\n    function initialize(\n        IStableCoin _stablecoin,\n        IERC721Upgradeable _nftContract,\n        IAggregatorV3Interface _ethAggregator,\n        IAggregatorV3Interface _jpegAggregator,\n        IAggregatorV3Interface _floorOracle,\n        IAggregatorV3Interface _fallbackOracle,\n        NFTCategoryInitializer[] memory _typeInitializers,\n        IJPEGLock _jpegLocker,\n        VaultSettings memory _settings\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DAO_ROLE, msg.sender);\n        _setRoleAdmin(LIQUIDATOR_ROLE, DAO_ROLE);\n        _setRoleAdmin(DAO_ROLE, DAO_ROLE);\n\n        _validateRate(_settings.debtInterestApr);\n        _validateRate(_settings.creditLimitRate);\n        _validateRate(_settings.liquidationLimitRate);\n        _validateRate(_settings.valueIncreaseLockRate);\n        _validateRate(_settings.organizationFeeRate);\n        _validateRate(_settings.insurancePurchaseRate);\n        _validateRate(_settings.insuranceLiquidationPenaltyRate);\n\n        _validateCreditLimitAndLiquidationRate(\n            _settings.creditLimitRate,\n            _settings.liquidationLimitRate\n        );\n\n        stablecoin = _stablecoin;\n        jpegLocker = _jpegLocker;\n        ethAggregator = _ethAggregator;\n        jpegAggregator = _jpegAggregator;\n        floorOracle = _floorOracle;\n        fallbackOracle = _fallbackOracle;\n        nftContract = _nftContract;\n\n        settings = _settings;\n\n        //initializing the categories\n        for (uint256 i = 0; i < _typeInitializers.length; i++) {\n            NFTCategoryInitializer memory initializer = _typeInitializers[i];\n            nftTypeValueETH[initializer.hash] = initializer.valueETH;\n            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n                nftTypes[initializer.nfts[j]] = initializer.hash;\n            }\n        }\n    }\n\n    /// @dev The {accrue} function updates the contract's state by calculating\n    /// the additional interest accrued since the last state update\n    function accrue() public {\n        uint256 additionalInterest = _calculateAdditionalInterest();\n\n        totalDebtAccruedAt = block.timestamp;\n\n        totalDebtAmount += additionalInterest;\n        totalFeeCollected += additionalInterest;\n    }\n\n    /// @notice Allows the DAO to change the total debt cap\n    /// @param _borrowAmountCap New total debt cap\n    function setBorrowAmountCap(uint256 _borrowAmountCap)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        settings.borrowAmountCap = _borrowAmountCap;\n    }\n\n    /// @notice Allows the DAO to change the interest APR on borrows\n    /// @param _debtInterestApr The new interest rate\n    function setDebtInterestApr(Rate memory _debtInterestApr)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_debtInterestApr);\n        settings.debtInterestApr = _debtInterestApr;\n    }\n\n    /// @notice Allows the DAO to change the amount of JPEG needed to increase the value of an NFT relative to the desired value\n    /// @param _valueIncreaseLockRate The new rate\n    function setValueIncreaseLockRate(Rate memory _valueIncreaseLockRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_valueIncreaseLockRate);\n        settings.valueIncreaseLockRate = _valueIncreaseLockRate;\n    }\n\n    /// @notice Allows the DAO to change the max debt to collateral rate for a position\n    /// @param _creditLimitRate The new rate\n    function setCreditLimitRate(Rate memory _creditLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_creditLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            _creditLimitRate,\n            settings.liquidationLimitRate\n        );\n\n        settings.creditLimitRate = _creditLimitRate;\n    }\n\n    /// @notice Allows the DAO to change the minimum debt to collateral rate for a position to be market as liquidatable\n    /// @param _liquidationLimitRate The new rate\n    function setLiquidationLimitRate(Rate memory _liquidationLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_liquidationLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            settings.creditLimitRate,\n            _liquidationLimitRate\n        );\n\n        settings.liquidationLimitRate = _liquidationLimitRate;\n    }\n\n    /// @notice Allows the DAO to toggle the fallback oracle\n    /// @param _useFallback Whether to use the fallback oracle\n    function toggleFallbackOracle(bool _useFallback)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        useFallbackOracle = _useFallback;\n    }\n\n    /// @notice Allows the DAO to change the amount of time JPEG tokens need to be locked to change the value of an NFT\n    /// @param _newLockTime The amount new lock time amount\n    function setJPEGLockTime(uint256 _newLockTime) external onlyRole(DAO_ROLE) {\n        jpegLocker.setLockTime(_newLockTime);\n    }\n\n    /// @notice Allows the DAO to bypass the floor oracle and override the NFT floor value\n    /// @param _newFloor The new floor\n    function overrideFloor(uint256 _newFloor) external onlyRole(DAO_ROLE) {\n        require(_newFloor > 0, \"Invalid floor\");\n        nftTypeValueETH[bytes32(0)] = _newFloor;\n        daoFloorOverride = true;\n    }\n\n    /// @notice Allows the DAO to stop overriding floor\n    function disableFloorOverride() external onlyRole(DAO_ROLE) {\n        daoFloorOverride = false;\n    }\n\n    /// @notice Allows the DAO to change the static borrow fee\n    /// @param _organizationFeeRate The new fee rate\n    function setOrganizationFeeRate(Rate memory _organizationFeeRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_organizationFeeRate);\n        settings.organizationFeeRate = _organizationFeeRate;\n    }\n\n    /// @notice Allows the DAO to change the cost of insurance\n    /// @param _insurancePurchaseRate The new insurance fee rate\n    function setInsurancePurchaseRate(Rate memory _insurancePurchaseRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_insurancePurchaseRate);\n        settings.insurancePurchaseRate = _insurancePurchaseRate;\n    }\n\n    /// @notice Allows the DAO to change the repurchase penalty rate in case of liquidation of an insured NFT\n    /// @param _insuranceLiquidationPenaltyRate The new rate\n    function setInsuranceLiquidationPenaltyRate(\n        Rate memory _insuranceLiquidationPenaltyRate\n    ) external onlyRole(DAO_ROLE) {\n        _validateRate(_insuranceLiquidationPenaltyRate);\n        settings\n            .insuranceLiquidationPenaltyRate = _insuranceLiquidationPenaltyRate;\n    }\n\n    /// @notice Allows the DAO to add an NFT to a specific price category\n    /// @param _nftIndex The index to add to the category\n    /// @param _type The category hash\n    function setNFTType(uint256 _nftIndex, bytes32 _type)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        require(\n            _type == bytes32(0) || nftTypeValueETH[_type] > 0,\n            \"invalid_nftType\"\n        );\n        nftTypes[_nftIndex] = _type;\n    }\n\n    /// @notice Allows the DAO to change the value of an NFT category\n    /// @param _type The category hash\n    /// @param _amountETH The new value, in ETH\n    function setNFTTypeValueETH(bytes32 _type, uint256 _amountETH)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        nftTypeValueETH[_type] = _amountETH;\n    }\n\n    /// @notice Allows the DAO to set the value in ETH of the NFT at index `_nftIndex`.\n    /// A JPEG deposit by a user is required afterwards. See {finalizePendingNFTValueETH} for more details\n    /// @param _nftIndex The index of the NFT to change the value of\n    /// @param _amountETH The new desired ETH value\n    function setPendingNFTValueETH(uint256 _nftIndex, uint256 _amountETH)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        pendingNFTValueETH[_nftIndex] = _amountETH;\n    }\n\n    /// @notice Allows a user to lock up JPEG to make the change in value of an NFT effective.\n    /// Can only be called after {setPendingNFTValueETH}, which requires a governance vote.\n    /// @dev The amount of JPEG that needs to be locked is calculated by applying `valueIncreaseLockRate`\n    /// to the new credit limit of the NFT\n    /// @param _nftIndex The index of the NFT\n    function finalizePendingNFTValueETH(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        uint256 pendingValue = pendingNFTValueETH[_nftIndex];\n        require(pendingValue > 0, \"no_pending_value\");\n        uint256 toLockJpeg = (((pendingValue *\n            _ethPriceUSD() *\n            settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator) *\n            settings.valueIncreaseLockRate.numerator) /\n            settings.valueIncreaseLockRate.denominator /\n            _jpegPriceUSD();\n\n        //lock JPEG using JPEGLock\n        jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg);\n\n        nftTypes[_nftIndex] = CUSTOM_NFT_HASH;\n        nftValueETH[_nftIndex] = pendingValue;\n        //clear pending value\n        pendingNFTValueETH[_nftIndex] = 0;\n    }\n\n    /// @dev Validates the credit limit rate and the liquidation limit rate.\n    /// The credit limit rate must be less than the liquidation rate\n    /// @param _creditLimitRate The credit limit rate to validate\n    /// @param _liquidationLimitRate The liquidation limit rate\n    function _validateCreditLimitAndLiquidationRate(\n        Rate memory _creditLimitRate,\n        Rate memory _liquidationLimitRate\n    ) internal pure {\n        require(\n            _liquidationLimitRate.numerator * _creditLimitRate.denominator >\n                _creditLimitRate.numerator * _liquidationLimitRate.denominator,\n            \"credit_rate_exceeds_or_equals_liquidation_rate\"\n        );\n    }\n\n    /// @dev Validates a rate. The denominator must be greater than zero and greater than or equal to the numerator.\n    /// @param rate The rate to validate\n    function _validateRate(Rate memory rate) internal pure {\n        require(\n            rate.denominator > 0 && rate.denominator >= rate.numerator,\n            \"invalid_rate\"\n        );\n    }\n\n    /// @dev Returns the value in ETH of the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT to return the value of\n    /// @return The value of the NFT, 18 decimals\n    function _getNFTValueETH(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        bytes32 nftType = nftTypes[_nftIndex];\n\n        if (nftType == bytes32(0) && !daoFloorOverride) {\n            return\n                _normalizeAggregatorAnswer(\n                    useFallbackOracle ? fallbackOracle : floorOracle\n                );\n        } else if (nftType == CUSTOM_NFT_HASH) return nftValueETH[_nftIndex];\n\n        return nftTypeValueETH[nftType];\n    }\n\n    /// @dev Returns the value in USD of the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT to return the value of\n    /// @return The value of the NFT in USD, 18 decimals\n    function _getNFTValueUSD(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 nft_value = _getNFTValueETH(_nftIndex);\n        return (nft_value * _ethPriceUSD()) / 1 ether;\n    }\n\n    /// @dev Returns the current ETH price in USD\n    /// @return The current ETH price, 18 decimals\n    function _ethPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(ethAggregator);\n    }\n\n    /// @dev Returns the current JPEG price in USD\n    /// @return The current JPEG price, 18 decimals\n    function _jpegPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(jpegAggregator);\n    }\n\n    /// @dev Fetches and converts to 18 decimals precision the latest answer of a Chainlink aggregator\n    /// @param aggregator The aggregator to fetch the answer from\n    /// @return The latest aggregator answer, normalized\n    function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator)\n        internal\n        view\n        returns (uint256)\n    {\n        int256 answer = aggregator.latestAnswer();\n        uint8 decimals = aggregator.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n        //converts the answer to have 18 decimals\n        return\n            decimals > 18\n                ? uint256(answer) / 10**(decimals - 18)\n                : uint256(answer) * 10**(18 - decimals);\n    }\n\n    struct NFTInfo {\n        uint256 index;\n        bytes32 nftType;\n        address owner;\n        uint256 nftValueETH;\n        uint256 nftValueUSD;\n    }\n\n    /// @notice Returns data relative to the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT index\n    /// @return nftInfo The data relative to the NFT\n    function getNFTInfo(uint256 _nftIndex)\n        external\n        view\n        returns (NFTInfo memory nftInfo)\n    {\n        nftInfo = NFTInfo(\n            _nftIndex,\n            nftTypes[_nftIndex],\n            nftContract.ownerOf(_nftIndex),\n            _getNFTValueETH(_nftIndex),\n            _getNFTValueUSD(_nftIndex)\n        );\n    }\n\n    /// @dev Returns the credit limit of an NFT\n    /// @param _nftIndex The NFT to return credit limit of\n    /// @return The NFT credit limit\n    function _getCreditLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator;\n    }\n\n    /// @dev Returns the minimum amount of debt necessary to liquidate an NFT\n    /// @param _nftIndex The index of the NFT\n    /// @return The minimum amount of debt to liquidate the NFT\n    function _getLiquidationLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.liquidationLimitRate.numerator) /\n            settings.liquidationLimitRate.denominator;\n    }\n\n    /// @dev Calculates current outstanding debt of an NFT\n    /// @param _nftIndex The NFT to calculate the outstanding debt of\n    /// @return The outstanding debt value\n    function _getDebtAmount(uint256 _nftIndex) internal view returns (uint256) {\n        uint256 calculatedDebt = _calculateDebt(\n            totalDebtAmount,\n            positions[_nftIndex].debtPortion,\n            totalDebtPortion\n        );\n\n        uint256 principal = positions[_nftIndex].debtPrincipal;\n\n        //_calculateDebt is prone to rounding errors that may cause\n        //the calculated debt amount to be 1 or 2 units less than\n        //the debt principal when the accrue() function isn't called\n        //in between the first borrow and the _calculateDebt call.\n        return principal > calculatedDebt ? principal : calculatedDebt;\n    }\n\n    /// @dev Calculates the total debt of a position given the global debt, the user's portion of the debt and the total user portions\n    /// @param total The global outstanding debt\n    /// @param userPortion The user's portion of debt\n    /// @param totalPortion The total user portions of debt\n    /// @return The outstanding debt of the position\n    function _calculateDebt(\n        uint256 total,\n        uint256 userPortion,\n        uint256 totalPortion\n    ) internal pure returns (uint256) {\n        return totalPortion == 0 ? 0 : (total * userPortion) / totalPortion;\n    }\n\n    /// @dev Opens a position\n    /// Emits a {PositionOpened} event\n    /// @param _owner The owner of the position to open\n    /// @param _nftIndex The NFT used as collateral for the position\n    function _openPosition(address _owner, uint256 _nftIndex) internal {\n        nftContract.transferFrom(_owner, address(this), _nftIndex);\n\n        positions[_nftIndex] = Position({\n            borrowType: BorrowType.NOT_CONFIRMED,\n            debtPrincipal: 0,\n            debtPortion: 0,\n            debtAmountForRepurchase: 0,\n            liquidatedAt: 0,\n            liquidator: address(0)\n        });\n        positionOwner[_nftIndex] = _owner;\n        positionIndexes.add(_nftIndex);\n\n        emit PositionOpened(_owner, _nftIndex);\n    }\n\n    /// @dev Calculates the additional global interest since last time the contract's state was updated by calling {accrue}\n    /// @return The additional interest value\n    function _calculateAdditionalInterest() internal view returns (uint256) {\n        // Number of seconds since {accrue} was called\n        uint256 elapsedTime = block.timestamp - totalDebtAccruedAt;\n        if (elapsedTime == 0) {\n            return 0;\n        }\n\n        if (totalDebtAmount == 0) {\n            return 0;\n        }\n\n        // Accrue interest\n        uint256 interestPerYear = (totalDebtAmount *\n            settings.debtInterestApr.numerator) /\n            settings.debtInterestApr.denominator;\n        uint256 interestPerSec = interestPerYear / 365 days;\n\n        return elapsedTime * interestPerSec;\n    }\n\n    /// @notice Returns the number of open positions\n    /// @return The number of open positions\n    function totalPositions() external view returns (uint256) {\n        return positionIndexes.length();\n    }\n\n    /// @notice Returns all open position NFT indexes\n    /// @return The open position NFT indexes\n    function openPositionsIndexes() external view returns (uint256[] memory) {\n        return positionIndexes.values();\n    }\n\n    struct PositionPreview {\n        address owner;\n        uint256 nftIndex;\n        bytes32 nftType;\n        uint256 nftValueUSD;\n        VaultSettings vaultSettings;\n        uint256 creditLimit;\n        uint256 debtPrincipal;\n        uint256 debtInterest;\n        BorrowType borrowType;\n        bool liquidatable;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    /// @notice Returns data relative to a postition, existing or not\n    /// @param _nftIndex The index of the NFT used as collateral for the position\n    /// @return preview See assignment below\n    function showPosition(uint256 _nftIndex)\n        external\n        view\n        validNFTIndex(_nftIndex)\n        returns (PositionPreview memory preview)\n    {\n        address posOwner = positionOwner[_nftIndex];\n\n        uint256 debtPrincipal = positions[_nftIndex].debtPrincipal;\n        uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0\n            ? positions[_nftIndex].debtAmountForRepurchase //calculate updated debt\n            : _calculateDebt(\n                totalDebtAmount + _calculateAdditionalInterest(),\n                positions[_nftIndex].debtPortion,\n                totalDebtPortion\n            );\n\n        //_calculateDebt is prone to rounding errors that may cause\n        //the calculated debt amount to be 1 or 2 units less than\n        //the debt principal if no time has elapsed in between the first borrow\n        //and the _calculateDebt call.\n        if (debtPrincipal > debtAmount) debtAmount = debtPrincipal;\n\n        preview = PositionPreview({\n            owner: posOwner, //the owner of the position, `address(0)` if the position doesn't exists\n            nftIndex: _nftIndex, //the NFT used as collateral for the position\n            nftType: nftTypes[_nftIndex], //the type of the NFT\n            nftValueUSD: _getNFTValueUSD(_nftIndex), //the value in USD of the NFT\n            vaultSettings: settings, //the current vault's settings\n            creditLimit: _getCreditLimit(_nftIndex), //the NFT's credit limit\n            debtPrincipal: debtPrincipal, //the debt principal for the position, `0` if the position doesn't exists\n            debtInterest: debtAmount - debtPrincipal, //the interest of the position\n            borrowType: positions[_nftIndex].borrowType, //the insurance type of the position, `NOT_CONFIRMED` if it doesn't exist\n            liquidatable: positions[_nftIndex].liquidatedAt == 0 &&\n                debtAmount >= _getLiquidationLimit(_nftIndex), //if the position can be liquidated\n            liquidatedAt: positions[_nftIndex].liquidatedAt, //if the position has been liquidated and it had insurance, the timestamp at which the liquidation happened\n            liquidator: positions[_nftIndex].liquidator //if the position has been liquidated and it had insurance, the address of the liquidator\n        });\n    }\n\n    /// @notice Allows users to open positions and borrow using an NFT\n    /// @dev emits a {Borrowed} event\n    /// @param _nftIndex The index of the NFT to be used as collateral\n    /// @param _amount The amount of PUSD to be borrowed. Note that the user will receive less than the amount requested,\n    /// the borrow fee and insurance automatically get removed from the amount borrowed\n    /// @param _useInsurance Whereter to open an insured position. In case the position has already been opened previously,\n    /// this parameter needs to match the previous insurance mode. To change insurance mode, a user needs to close and reopen the position\n    function borrow(\n        uint256 _nftIndex,\n        uint256 _amount,\n        bool _useInsurance\n    ) external validNFTIndex(_nftIndex) nonReentrant {\n        accrue();\n\n        require(\n            msg.sender == positionOwner[_nftIndex] ||\n                address(0) == positionOwner[_nftIndex],\n            \"unauthorized\"\n        );\n        require(_amount > 0, \"invalid_amount\");\n        require(\n            totalDebtAmount + _amount <= settings.borrowAmountCap,\n            \"debt_cap\"\n        );\n\n        if (positionOwner[_nftIndex] == address(0)) {\n            _openPosition(msg.sender, _nftIndex);\n        }\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n        require(\n            position.borrowType == BorrowType.NOT_CONFIRMED ||\n                (position.borrowType == BorrowType.USE_INSURANCE &&\n                    _useInsurance) ||\n                (position.borrowType == BorrowType.NON_INSURANCE &&\n                    !_useInsurance),\n            \"invalid_insurance_mode\"\n        );\n\n        uint256 creditLimit = _getCreditLimit(_nftIndex);\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(debtAmount + _amount <= creditLimit, \"insufficient_credit\");\n\n        //calculate the borrow fee\n        uint256 organizationFee = (_amount *\n            settings.organizationFeeRate.numerator) /\n            settings.organizationFeeRate.denominator;\n\n        uint256 feeAmount = organizationFee;\n        //if the position is insured, calculate the insurance fee\n        if (position.borrowType == BorrowType.USE_INSURANCE || _useInsurance) {\n            feeAmount +=\n                (_amount * settings.insurancePurchaseRate.numerator) /\n                settings.insurancePurchaseRate.denominator;\n        }\n        totalFeeCollected += feeAmount;\n        //subtract the fee from the amount borrowed\n        stablecoin.mint(msg.sender, _amount - feeAmount);\n\n        if (position.borrowType == BorrowType.NOT_CONFIRMED) {\n            position.borrowType = _useInsurance\n                ? BorrowType.USE_INSURANCE\n                : BorrowType.NON_INSURANCE;\n        }\n\n        // update debt portion\n        if (totalDebtPortion == 0) {\n            totalDebtPortion = _amount;\n            position.debtPortion = _amount;\n        } else {\n            uint256 plusPortion = (totalDebtPortion * _amount) /\n                totalDebtAmount;\n            totalDebtPortion += plusPortion;\n            position.debtPortion += plusPortion;\n        }\n        position.debtPrincipal += _amount;\n        totalDebtAmount += _amount;\n\n        emit Borrowed(msg.sender, _nftIndex, _amount);\n    }\n\n    /// @notice Allows users to repay a portion/all of their debt. Note that since interest increases every second,\n    /// a user wanting to repay all of their debt should repay for an amount greater than their current debt to account for the\n    /// additional interest while the repay transaction is pending, the contract will only take what's necessary to repay all the debt\n    /// @dev Emits a {Repaid} event\n    /// @param _nftIndex The NFT used as collateral for the position\n    /// @param _amount The amount of debt to repay. If greater than the position's outstanding debt, only the amount necessary to repay all the debt will be taken\n    function repay(uint256 _nftIndex, uint256 _amount)\n        external\n        validNFTIndex(_nftIndex)\n        nonReentrant\n    {\n        accrue();\n\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(_amount > 0, \"invalid_amount\");\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(debtAmount > 0, \"position_not_borrowed\");\n\n        uint256 debtPrincipal = position.debtPrincipal;\n        uint256 debtInterest = debtAmount - debtPrincipal;\n\n        _amount = _amount > debtAmount ? debtAmount : _amount;\n\n        // burn all payment, the interest is sent to the DAO using the {collect} function\n        stablecoin.burnFrom(msg.sender, _amount);\n\n        uint256 paidPrincipal = _amount > debtInterest\n            ? _amount - debtInterest\n            : 0;\n\n        uint256 minusPortion = paidPrincipal == debtPrincipal\n            ? position.debtPortion\n            : (totalDebtPortion * _amount) / totalDebtAmount;\n\n        totalDebtPortion -= minusPortion;\n        position.debtPortion -= minusPortion;\n        position.debtPrincipal -= paidPrincipal;\n        totalDebtAmount -= _amount;\n\n        emit Repaid(msg.sender, _nftIndex, _amount);\n    }\n\n    /// @notice Allows a user to close a position and get their collateral back, if the position's outstanding debt is 0\n    /// @dev Emits a {PositionClosed} event\n    /// @param _nftIndex The index of the NFT used as collateral\n    function closePosition(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        accrue();\n\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(_getDebtAmount(_nftIndex) == 0, \"position_not_repaid\");\n\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        // transfer nft back to owner if nft was deposited\n        if (nftContract.ownerOf(_nftIndex) == address(this)) {\n            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n        }\n\n        emit PositionClosed(msg.sender, _nftIndex);\n    }\n\n    /// @notice Allows members of the `LIQUIDATOR_ROLE` to liquidate a position. Positions can only be liquidated\n    /// once their debt amount exceeds the minimum liquidation debt to collateral value rate.\n    /// In order to liquidate a position, the liquidator needs to repay the user's outstanding debt.\n    /// If the position is not insured, it's closed immediately and the collateral is sent to the liquidator.\n    /// If the position is insured, the position remains open (interest doesn't increase) and the owner of the position has a certain amount of time\n    /// (`insuranceRepurchaseTimeLimit`) to fully repay the liquidator and pay an additional liquidation fee (`insuranceLiquidationPenaltyRate`), if this\n    /// is done in time the user gets back their collateral and their position is automatically closed. If the user doesn't repurchase their collateral\n    /// before the time limit passes, the liquidator can claim the liquidated NFT and the position is closed\n    /// @dev Emits a {Liquidated} event\n    /// @param _nftIndex The NFT to liquidate\n    function liquidate(uint256 _nftIndex)\n        external\n        onlyRole(LIQUIDATOR_ROLE)\n        validNFTIndex(_nftIndex)\n        nonReentrant\n    {\n        accrue();\n\n        address posOwner = positionOwner[_nftIndex];\n        require(posOwner != address(0), \"position_not_exist\");\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(\n            debtAmount >= _getLiquidationLimit(_nftIndex),\n            \"position_not_liquidatable\"\n        );\n\n        // burn all payment\n        stablecoin.burnFrom(msg.sender, debtAmount);\n\n        // update debt portion\n        totalDebtPortion -= position.debtPortion;\n        totalDebtAmount -= debtAmount;\n        position.debtPortion = 0;\n\n        bool insured = position.borrowType == BorrowType.USE_INSURANCE;\n        if (insured) {\n            position.debtAmountForRepurchase = debtAmount;\n            position.liquidatedAt = block.timestamp;\n            position.liquidator = msg.sender;\n        } else {\n            // transfer nft to liquidator\n            positionOwner[_nftIndex] = address(0);\n            delete positions[_nftIndex];\n            positionIndexes.remove(_nftIndex);\n            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n        }\n\n        emit Liquidated(msg.sender, posOwner, _nftIndex, insured);\n    }\n\n    /// @notice Allows liquidated users who purchased insurance to repurchase their collateral within the time limit\n    /// defined with the `insuranceRepurchaseTimeLimit`. The user needs to pay the liquidator the total amount of debt\n    /// the position had at the time of liquidation, plus an insurance liquidation fee defined with `insuranceLiquidationPenaltyRate`\n    /// @dev Emits a {Repurchased} event\n    /// @param _nftIndex The NFT to repurchase\n    function repurchase(uint256 _nftIndex) external validNFTIndex(_nftIndex) {\n        Position memory position = positions[_nftIndex];\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(position.liquidatedAt > 0, \"not_liquidated\");\n        require(\n            position.borrowType == BorrowType.USE_INSURANCE,\n            \"non_insurance\"\n        );\n        require(\n            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit >=\n                block.timestamp,\n            \"insurance_expired\"\n        );\n\n        uint256 debtAmount = position.debtAmountForRepurchase;\n        uint256 penalty = (debtAmount *\n            settings.insuranceLiquidationPenaltyRate.numerator) /\n            settings.insuranceLiquidationPenaltyRate.denominator;\n\n        // transfer payment to liquidator\n        stablecoin.transferFrom(\n            msg.sender,\n            position.liquidator,\n            debtAmount + penalty\n        );\n\n        // transfer nft to user\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n\n        emit Repurchased(msg.sender, _nftIndex);\n    }\n\n    /// @notice Allows the liquidator who liquidated the insured position with NFT at index `_nftIndex` to claim the position's collateral\n    /// after the time period defined with `insuranceRepurchaseTimeLimit` has expired and the position owner has not repurchased the collateral.\n    /// @dev Emits an {InsuranceExpired} event\n    /// @param _nftIndex The NFT to claim\n    function claimExpiredInsuranceNFT(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        Position memory position = positions[_nftIndex];\n        address owner = positionOwner[_nftIndex];\n        require(address(0) != owner, \"no_position\");\n        require(position.liquidatedAt > 0, \"not_liquidated\");\n        require(\n            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit <\n                block.timestamp,\n            \"insurance_not_expired\"\n        );\n        require(position.liquidator == msg.sender, \"unauthorized\");\n\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n\n        emit InsuranceExpired(owner, _nftIndex);\n    }\n\n    /// @notice Allows the DAO to collect interest and fees before they are repaid\n    function collect() external nonReentrant onlyRole(DAO_ROLE) {\n        accrue();\n        stablecoin.mint(msg.sender, totalFeeCollected);\n        totalFeeCollected = 0;\n    }\n\n    uint256[50] private __gap;\n}\n\n\n",
        "CodeNames": [
            "FungibleAssetVaultForDAO.sol",
            "NFTVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FungibleAssetVaultForDAO.sol#L105, NFTVault.sol#L459",
                "Type": "Deprecated API usage",
                "Description": "Chainlink pricer is using a deprecated API.",
                "Repair": "Use the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/IAggregatorV3Interface.sol\";\nimport \"../interfaces/IStableCoin.sol\";\nimport \"../interfaces/IJPEGLock.sol\";\n\n/// @title NFT lending vault\n/// @notice This contracts allows users to borrow PUSD using NFTs as collateral.\n/// The floor price of the NFT collection is fetched using a chainlink oracle, while some other more valuable traits\n/// can have an higher price set by the DAO. Users can also increase the price (and thus the borrow limit) of their\n/// NFT by submitting a governance proposal. If the proposal is approved the user can lock a percentage of the new price\n/// worth of JPEG to make it effective\ncontract NFTVault is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    event PositionOpened(address indexed owner, uint256 indexed index);\n    event Borrowed(\n        address indexed owner,\n        uint256 indexed index,\n        uint256 amount\n    );\n    event Repaid(address indexed owner, uint256 indexed index, uint256 amount);\n    event PositionClosed(address indexed owner, uint256 indexed index);\n    event Liquidated(\n        address indexed liquidator,\n        address indexed owner,\n        uint256 indexed index,\n        bool insured\n    );\n    event Repurchased(address indexed owner, uint256 indexed index);\n    event InsuranceExpired(address indexed owner, uint256 indexed index);\n\n    enum BorrowType {\n        NOT_CONFIRMED,\n        NON_INSURANCE,\n        USE_INSURANCE\n    }\n\n    struct Position {\n        BorrowType borrowType;\n        uint256 debtPrincipal;\n        uint256 debtPortion;\n        uint256 debtAmountForRepurchase;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    struct VaultSettings {\n        Rate debtInterestApr;\n        Rate creditLimitRate;\n        Rate liquidationLimitRate;\n        Rate valueIncreaseLockRate;\n        Rate organizationFeeRate;\n        Rate insurancePurchaseRate;\n        Rate insuranceLiquidationPenaltyRate;\n        uint256 insuraceRepurchaseTimeLimit;\n        uint256 borrowAmountCap;\n    }\n\n    bytes32 public constant DAO_ROLE = keccak256(\"DAO_ROLE\");\n    bytes32 public constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\n\n    bytes32 public constant CUSTOM_NFT_HASH = keccak256(\"CUSTOM\");\n\n    IStableCoin public stablecoin;\n    /// @notice Chainlink ETH/USD price feed\n    IAggregatorV3Interface public ethAggregator;\n    /// @notice Chainlink JPEG/USD price feed\n    IAggregatorV3Interface public jpegAggregator;\n    /// @notice Chainlink NFT floor oracle\n    IAggregatorV3Interface public floorOracle;\n    /// @notice Chainlink NFT fallback floor oracle\n    IAggregatorV3Interface public fallbackOracle;\n    /// @notice JPEGLocker, used by this contract to lock JPEG and increase the value of an NFT\n    IJPEGLock public jpegLocker;\n    IERC721Upgradeable public nftContract;\n\n    /// @notice If true, the floor price won't be fetched using the Chainlink oracle but\n    /// a value set by the DAO will be used instead\n    bool public daoFloorOverride;\n    // @notice If true, the floor price will be fetched using the fallback oracle\n    bool public useFallbackOracle;\n    /// @notice Total outstanding debt\n    uint256 public totalDebtAmount;\n    /// @dev Last time debt was accrued. See {accrue} for more info\n    uint256 public totalDebtAccruedAt;\n    uint256 public totalFeeCollected;\n    uint256 internal totalDebtPortion;\n\n    VaultSettings public settings;\n\n    /// @dev Keeps track of all the NFTs used as collateral for positions\n    EnumerableSetUpgradeable.UintSet private positionIndexes;\n\n    mapping(uint256 => Position) private positions;\n    mapping(uint256 => address) public positionOwner;\n    mapping(bytes32 => uint256) public nftTypeValueETH;\n    mapping(uint256 => uint256) public nftValueETH;\n    //bytes32(0) is floor\n    mapping(uint256 => bytes32) public nftTypes;\n    mapping(uint256 => uint256) public pendingNFTValueETH;\n\n    /// @dev Checks if the provided NFT index is valid\n    /// @param nftIndex The index to check\n    modifier validNFTIndex(uint256 nftIndex) {\n        //The standard OZ ERC721 implementation of ownerOf reverts on a non existing nft isntead of returning address(0)\n        require(nftContract.ownerOf(nftIndex) != address(0), \"invalid_nft\");\n        _;\n    }\n\n    struct NFTCategoryInitializer {\n        bytes32 hash;\n        uint256 valueETH;\n        uint256[] nfts;\n    }\n\n    /// @param _stablecoin PUSD address\n    /// @param _nftContract The NFT contrat address. It could also be the address of an helper contract\n    /// if the target NFT isn't an ERC721 (CryptoPunks as an example)\n    /// @param _ethAggregator Chainlink ETH/USD price feed address\n    /// @param _jpegAggregator Chainlink JPEG/USD price feed address\n    /// @param _floorOracle Chainlink floor oracle address\n    /// @param _fallbackOracle Chainlink fallback floor oracle address\n    /// @param _typeInitializers Used to initialize NFT categories with their value and NFT indexes.\n    /// Floor NFT shouldn't be initialized this way\n    /// @param _jpegLocker JPEGLock address\n    /// @param _settings Initial settings used by the contract\n    function initialize(\n        IStableCoin _stablecoin,\n        IERC721Upgradeable _nftContract,\n        IAggregatorV3Interface _ethAggregator,\n        IAggregatorV3Interface _jpegAggregator,\n        IAggregatorV3Interface _floorOracle,\n        IAggregatorV3Interface _fallbackOracle,\n        NFTCategoryInitializer[] memory _typeInitializers,\n        IJPEGLock _jpegLocker,\n        VaultSettings memory _settings\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DAO_ROLE, msg.sender);\n        _setRoleAdmin(LIQUIDATOR_ROLE, DAO_ROLE);\n        _setRoleAdmin(DAO_ROLE, DAO_ROLE);\n\n        _validateRate(_settings.debtInterestApr);\n        _validateRate(_settings.creditLimitRate);\n        _validateRate(_settings.liquidationLimitRate);\n        _validateRate(_settings.valueIncreaseLockRate);\n        _validateRate(_settings.organizationFeeRate);\n        _validateRate(_settings.insurancePurchaseRate);\n        _validateRate(_settings.insuranceLiquidationPenaltyRate);\n\n        _validateCreditLimitAndLiquidationRate(\n            _settings.creditLimitRate,\n            _settings.liquidationLimitRate\n        );\n\n        stablecoin = _stablecoin;\n        jpegLocker = _jpegLocker;\n        ethAggregator = _ethAggregator;\n        jpegAggregator = _jpegAggregator;\n        floorOracle = _floorOracle;\n        fallbackOracle = _fallbackOracle;\n        nftContract = _nftContract;\n\n        settings = _settings;\n\n        //initializing the categories\n        for (uint256 i = 0; i < _typeInitializers.length; i++) {\n            NFTCategoryInitializer memory initializer = _typeInitializers[i];\n            nftTypeValueETH[initializer.hash] = initializer.valueETH;\n            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n                nftTypes[initializer.nfts[j]] = initializer.hash;\n            }\n        }\n    }\n\n    /// @dev The {accrue} function updates the contract's state by calculating\n    /// the additional interest accrued since the last state update\n    function accrue() public {\n        uint256 additionalInterest = _calculateAdditionalInterest();\n\n        totalDebtAccruedAt = block.timestamp;\n\n        totalDebtAmount += additionalInterest;\n        totalFeeCollected += additionalInterest;\n    }\n\n    /// @notice Allows the DAO to change the total debt cap\n    /// @param _borrowAmountCap New total debt cap\n    function setBorrowAmountCap(uint256 _borrowAmountCap)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        settings.borrowAmountCap = _borrowAmountCap;\n    }\n\n    /// @notice Allows the DAO to change the interest APR on borrows\n    /// @param _debtInterestApr The new interest rate\n    function setDebtInterestApr(Rate memory _debtInterestApr)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_debtInterestApr);\n        settings.debtInterestApr = _debtInterestApr;\n    }\n\n    /// @notice Allows the DAO to change the amount of JPEG needed to increase the value of an NFT relative to the desired value\n    /// @param _valueIncreaseLockRate The new rate\n    function setValueIncreaseLockRate(Rate memory _valueIncreaseLockRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_valueIncreaseLockRate);\n        settings.valueIncreaseLockRate = _valueIncreaseLockRate;\n    }\n\n    /// @notice Allows the DAO to change the max debt to collateral rate for a position\n    /// @param _creditLimitRate The new rate\n    function setCreditLimitRate(Rate memory _creditLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_creditLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            _creditLimitRate,\n            settings.liquidationLimitRate\n        );\n\n        settings.creditLimitRate = _creditLimitRate;\n    }\n\n    /// @notice Allows the DAO to change the minimum debt to collateral rate for a position to be market as liquidatable\n    /// @param _liquidationLimitRate The new rate\n    function setLiquidationLimitRate(Rate memory _liquidationLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_liquidationLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            settings.creditLimitRate,\n            _liquidationLimitRate\n        );\n\n        settings.liquidationLimitRate = _liquidationLimitRate;\n    }\n\n    /// @notice Allows the DAO to toggle the fallback oracle\n    /// @param _useFallback Whether to use the fallback oracle\n    function toggleFallbackOracle(bool _useFallback)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        useFallbackOracle = _useFallback;\n    }\n\n    /// @notice Allows the DAO to change the amount of time JPEG tokens need to be locked to change the value of an NFT\n    /// @param _newLockTime The amount new lock time amount\n    function setJPEGLockTime(uint256 _newLockTime) external onlyRole(DAO_ROLE) {\n        jpegLocker.setLockTime(_newLockTime);\n    }\n\n    /// @notice Allows the DAO to bypass the floor oracle and override the NFT floor value\n    /// @param _newFloor The new floor\n    function overrideFloor(uint256 _newFloor) external onlyRole(DAO_ROLE) {\n        require(_newFloor > 0, \"Invalid floor\");\n        nftTypeValueETH[bytes32(0)] = _newFloor;\n        daoFloorOverride = true;\n    }\n\n    /// @notice Allows the DAO to stop overriding floor\n    function disableFloorOverride() external onlyRole(DAO_ROLE) {\n        daoFloorOverride = false;\n    }\n\n    /// @notice Allows the DAO to change the static borrow fee\n    /// @param _organizationFeeRate The new fee rate\n    function setOrganizationFeeRate(Rate memory _organizationFeeRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_organizationFeeRate);\n        settings.organizationFeeRate = _organizationFeeRate;\n    }\n\n    /// @notice Allows the DAO to change the cost of insurance\n    /// @param _insurancePurchaseRate The new insurance fee rate\n    function setInsurancePurchaseRate(Rate memory _insurancePurchaseRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_insurancePurchaseRate);\n        settings.insurancePurchaseRate = _insurancePurchaseRate;\n    }\n\n    /// @notice Allows the DAO to change the repurchase penalty rate in case of liquidation of an insured NFT\n    /// @param _insuranceLiquidationPenaltyRate The new rate\n    function setInsuranceLiquidationPenaltyRate(\n        Rate memory _insuranceLiquidationPenaltyRate\n    ) external onlyRole(DAO_ROLE) {\n        _validateRate(_insuranceLiquidationPenaltyRate);\n        settings\n            .insuranceLiquidationPenaltyRate = _insuranceLiquidationPenaltyRate;\n    }\n\n    /// @notice Allows the DAO to add an NFT to a specific price category\n    /// @param _nftIndex The index to add to the category\n    /// @param _type The category hash\n    function setNFTType(uint256 _nftIndex, bytes32 _type)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        require(\n            _type == bytes32(0) || nftTypeValueETH[_type] > 0,\n            \"invalid_nftType\"\n        );\n        nftTypes[_nftIndex] = _type;\n    }\n\n    /// @notice Allows the DAO to change the value of an NFT category\n    /// @param _type The category hash\n    /// @param _amountETH The new value, in ETH\n    function setNFTTypeValueETH(bytes32 _type, uint256 _amountETH)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        nftTypeValueETH[_type] = _amountETH;\n    }\n\n    /// @notice Allows the DAO to set the value in ETH of the NFT at index `_nftIndex`.\n    /// A JPEG deposit by a user is required afterwards. See {finalizePendingNFTValueETH} for more details\n    /// @param _nftIndex The index of the NFT to change the value of\n    /// @param _amountETH The new desired ETH value\n    function setPendingNFTValueETH(uint256 _nftIndex, uint256 _amountETH)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        pendingNFTValueETH[_nftIndex] = _amountETH;\n    }\n\n    /// @notice Allows a user to lock up JPEG to make the change in value of an NFT effective.\n    /// Can only be called after {setPendingNFTValueETH}, which requires a governance vote.\n    /// @dev The amount of JPEG that needs to be locked is calculated by applying `valueIncreaseLockRate`\n    /// to the new credit limit of the NFT\n    /// @param _nftIndex The index of the NFT\n    function finalizePendingNFTValueETH(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        uint256 pendingValue = pendingNFTValueETH[_nftIndex];\n        require(pendingValue > 0, \"no_pending_value\");\n        uint256 toLockJpeg = (((pendingValue *\n            _ethPriceUSD() *\n            settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator) *\n            settings.valueIncreaseLockRate.numerator) /\n            settings.valueIncreaseLockRate.denominator /\n            _jpegPriceUSD();\n\n        //lock JPEG using JPEGLock\n        jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg);\n\n        nftTypes[_nftIndex] = CUSTOM_NFT_HASH;\n        nftValueETH[_nftIndex] = pendingValue;\n        //clear pending value\n        pendingNFTValueETH[_nftIndex] = 0;\n    }\n\n    /// @dev Validates the credit limit rate and the liquidation limit rate.\n    /// The credit limit rate must be less than the liquidation rate\n    /// @param _creditLimitRate The credit limit rate to validate\n    /// @param _liquidationLimitRate The liquidation limit rate\n    function _validateCreditLimitAndLiquidationRate(\n        Rate memory _creditLimitRate,\n        Rate memory _liquidationLimitRate\n    ) internal pure {\n        require(\n            _liquidationLimitRate.numerator * _creditLimitRate.denominator >\n                _creditLimitRate.numerator * _liquidationLimitRate.denominator,\n            \"credit_rate_exceeds_or_equals_liquidation_rate\"\n        );\n    }\n\n    /// @dev Validates a rate. The denominator must be greater than zero and greater than or equal to the numerator.\n    /// @param rate The rate to validate\n    function _validateRate(Rate memory rate) internal pure {\n        require(\n            rate.denominator > 0 && rate.denominator >= rate.numerator,\n            \"invalid_rate\"\n        );\n    }\n\n    /// @dev Returns the value in ETH of the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT to return the value of\n    /// @return The value of the NFT, 18 decimals\n    function _getNFTValueETH(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        bytes32 nftType = nftTypes[_nftIndex];\n\n        if (nftType == bytes32(0) && !daoFloorOverride) {\n            return\n                _normalizeAggregatorAnswer(\n                    useFallbackOracle ? fallbackOracle : floorOracle\n                );\n        } else if (nftType == CUSTOM_NFT_HASH) return nftValueETH[_nftIndex];\n\n        return nftTypeValueETH[nftType];\n    }\n\n    /// @dev Returns the value in USD of the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT to return the value of\n    /// @return The value of the NFT in USD, 18 decimals\n    function _getNFTValueUSD(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 nft_value = _getNFTValueETH(_nftIndex);\n        return (nft_value * _ethPriceUSD()) / 1 ether;\n    }\n\n    /// @dev Returns the current ETH price in USD\n    /// @return The current ETH price, 18 decimals\n    function _ethPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(ethAggregator);\n    }\n\n    /// @dev Returns the current JPEG price in USD\n    /// @return The current JPEG price, 18 decimals\n    function _jpegPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(jpegAggregator);\n    }\n\n    /// @dev Fetches and converts to 18 decimals precision the latest answer of a Chainlink aggregator\n    /// @param aggregator The aggregator to fetch the answer from\n    /// @return The latest aggregator answer, normalized\n    function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator)\n        internal\n        view\n        returns (uint256)\n    {\n        int256 answer = aggregator.latestAnswer();\n        uint8 decimals = aggregator.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n        //converts the answer to have 18 decimals\n        return\n            decimals > 18\n                ? uint256(answer) / 10**(decimals - 18)\n                : uint256(answer) * 10**(18 - decimals);\n    }\n\n    struct NFTInfo {\n        uint256 index;\n        bytes32 nftType;\n        address owner;\n        uint256 nftValueETH;\n        uint256 nftValueUSD;\n    }\n\n    /// @notice Returns data relative to the NFT at index `_nftIndex`\n    /// @param _nftIndex The NFT index\n    /// @return nftInfo The data relative to the NFT\n    function getNFTInfo(uint256 _nftIndex)\n        external\n        view\n        returns (NFTInfo memory nftInfo)\n    {\n        nftInfo = NFTInfo(\n            _nftIndex,\n            nftTypes[_nftIndex],\n            nftContract.ownerOf(_nftIndex),\n            _getNFTValueETH(_nftIndex),\n            _getNFTValueUSD(_nftIndex)\n        );\n    }\n\n    /// @dev Returns the credit limit of an NFT\n    /// @param _nftIndex The NFT to return credit limit of\n    /// @return The NFT credit limit\n    function _getCreditLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator;\n    }\n\n    /// @dev Returns the minimum amount of debt necessary to liquidate an NFT\n    /// @param _nftIndex The index of the NFT\n    /// @return The minimum amount of debt to liquidate the NFT\n    function _getLiquidationLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.liquidationLimitRate.numerator) /\n            settings.liquidationLimitRate.denominator;\n    }\n\n    /// @dev Calculates current outstanding debt of an NFT\n    /// @param _nftIndex The NFT to calculate the outstanding debt of\n    /// @return The outstanding debt value\n    function _getDebtAmount(uint256 _nftIndex) internal view returns (uint256) {\n        uint256 calculatedDebt = _calculateDebt(\n            totalDebtAmount,\n            positions[_nftIndex].debtPortion,\n            totalDebtPortion\n        );\n\n        uint256 principal = positions[_nftIndex].debtPrincipal;\n\n        //_calculateDebt is prone to rounding errors that may cause\n        //the calculated debt amount to be 1 or 2 units less than\n        //the debt principal when the accrue() function isn't called\n        //in between the first borrow and the _calculateDebt call.\n        return principal > calculatedDebt ? principal : calculatedDebt;\n    }\n\n    /// @dev Calculates the total debt of a position given the global debt, the user's portion of the debt and the total user portions\n    /// @param total The global outstanding debt\n    /// @param userPortion The user's portion of debt\n    /// @param totalPortion The total user portions of debt\n    /// @return The outstanding debt of the position\n    function _calculateDebt(\n        uint256 total,\n        uint256 userPortion,\n        uint256 totalPortion\n    ) internal pure returns (uint256) {\n        return totalPortion == 0 ? 0 : (total * userPortion) / totalPortion;\n    }\n\n    /// @dev Opens a position\n    /// Emits a {PositionOpened} event\n    /// @param _owner The owner of the position to open\n    /// @param _nftIndex The NFT used as collateral for the position\n    function _openPosition(address _owner, uint256 _nftIndex) internal {\n        nftContract.transferFrom(_owner, address(this), _nftIndex);\n\n        positions[_nftIndex] = Position({\n            borrowType: BorrowType.NOT_CONFIRMED,\n            debtPrincipal: 0,\n            debtPortion: 0,\n            debtAmountForRepurchase: 0,\n            liquidatedAt: 0,\n            liquidator: address(0)\n        });\n        positionOwner[_nftIndex] = _owner;\n        positionIndexes.add(_nftIndex);\n\n        emit PositionOpened(_owner, _nftIndex);\n    }\n\n    /// @dev Calculates the additional global interest since last time the contract's state was updated by calling {accrue}\n    /// @return The additional interest value\n    function _calculateAdditionalInterest() internal view returns (uint256) {\n        // Number of seconds since {accrue} was called\n        uint256 elapsedTime = block.timestamp - totalDebtAccruedAt;\n        if (elapsedTime == 0) {\n            return 0;\n        }\n\n        if (totalDebtAmount == 0) {\n            return 0;\n        }\n\n        // Accrue interest\n        uint256 interestPerYear = (totalDebtAmount *\n            settings.debtInterestApr.numerator) /\n            settings.debtInterestApr.denominator;\n        uint256 interestPerSec = interestPerYear / 365 days;\n\n        return elapsedTime * interestPerSec;\n    }\n\n    /// @notice Returns the number of open positions\n    /// @return The number of open positions\n    function totalPositions() external view returns (uint256) {\n        return positionIndexes.length();\n    }\n\n    /// @notice Returns all open position NFT indexes\n    /// @return The open position NFT indexes\n    function openPositionsIndexes() external view returns (uint256[] memory) {\n        return positionIndexes.values();\n    }\n\n    struct PositionPreview {\n        address owner;\n        uint256 nftIndex;\n        bytes32 nftType;\n        uint256 nftValueUSD;\n        VaultSettings vaultSettings;\n        uint256 creditLimit;\n        uint256 debtPrincipal;\n        uint256 debtInterest;\n        BorrowType borrowType;\n        bool liquidatable;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    /// @notice Returns data relative to a postition, existing or not\n    /// @param _nftIndex The index of the NFT used as collateral for the position\n    /// @return preview See assignment below\n    function showPosition(uint256 _nftIndex)\n        external\n        view\n        validNFTIndex(_nftIndex)\n        returns (PositionPreview memory preview)\n    {\n        address posOwner = positionOwner[_nftIndex];\n\n        uint256 debtPrincipal = positions[_nftIndex].debtPrincipal;\n        uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0\n            ? positions[_nftIndex].debtAmountForRepurchase //calculate updated debt\n            : _calculateDebt(\n                totalDebtAmount + _calculateAdditionalInterest(),\n                positions[_nftIndex].debtPortion,\n                totalDebtPortion\n            );\n\n        //_calculateDebt is prone to rounding errors that may cause\n        //the calculated debt amount to be 1 or 2 units less than\n        //the debt principal if no time has elapsed in between the first borrow\n        //and the _calculateDebt call.\n        if (debtPrincipal > debtAmount) debtAmount = debtPrincipal;\n\n        preview = PositionPreview({\n            owner: posOwner, //the owner of the position, `address(0)` if the position doesn't exists\n            nftIndex: _nftIndex, //the NFT used as collateral for the position\n            nftType: nftTypes[_nftIndex], //the type of the NFT\n            nftValueUSD: _getNFTValueUSD(_nftIndex), //the value in USD of the NFT\n            vaultSettings: settings, //the current vault's settings\n            creditLimit: _getCreditLimit(_nftIndex), //the NFT's credit limit\n            debtPrincipal: debtPrincipal, //the debt principal for the position, `0` if the position doesn't exists\n            debtInterest: debtAmount - debtPrincipal, //the interest of the position\n            borrowType: positions[_nftIndex].borrowType, //the insurance type of the position, `NOT_CONFIRMED` if it doesn't exist\n            liquidatable: positions[_nftIndex].liquidatedAt == 0 &&\n                debtAmount >= _getLiquidationLimit(_nftIndex), //if the position can be liquidated\n            liquidatedAt: positions[_nftIndex].liquidatedAt, //if the position has been liquidated and it had insurance, the timestamp at which the liquidation happened\n            liquidator: positions[_nftIndex].liquidator //if the position has been liquidated and it had insurance, the address of the liquidator\n        });\n    }\n\n    /// @notice Allows users to open positions and borrow using an NFT\n    /// @dev emits a {Borrowed} event\n    /// @param _nftIndex The index of the NFT to be used as collateral\n    /// @param _amount The amount of PUSD to be borrowed. Note that the user will receive less than the amount requested,\n    /// the borrow fee and insurance automatically get removed from the amount borrowed\n    /// @param _useInsurance Whereter to open an insured position. In case the position has already been opened previously,\n    /// this parameter needs to match the previous insurance mode. To change insurance mode, a user needs to close and reopen the position\n    function borrow(\n        uint256 _nftIndex,\n        uint256 _amount,\n        bool _useInsurance\n    ) external validNFTIndex(_nftIndex) nonReentrant {\n        accrue();\n\n        require(\n            msg.sender == positionOwner[_nftIndex] ||\n                address(0) == positionOwner[_nftIndex],\n            \"unauthorized\"\n        );\n        require(_amount > 0, \"invalid_amount\");\n        require(\n            totalDebtAmount + _amount <= settings.borrowAmountCap,\n            \"debt_cap\"\n        );\n\n        if (positionOwner[_nftIndex] == address(0)) {\n            _openPosition(msg.sender, _nftIndex);\n        }\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n        require(\n            position.borrowType == BorrowType.NOT_CONFIRMED ||\n                (position.borrowType == BorrowType.USE_INSURANCE &&\n                    _useInsurance) ||\n                (position.borrowType == BorrowType.NON_INSURANCE &&\n                    !_useInsurance),\n            \"invalid_insurance_mode\"\n        );\n\n        uint256 creditLimit = _getCreditLimit(_nftIndex);\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(debtAmount + _amount <= creditLimit, \"insufficient_credit\");\n\n        //calculate the borrow fee\n        uint256 organizationFee = (_amount *\n            settings.organizationFeeRate.numerator) /\n            settings.organizationFeeRate.denominator;\n\n        uint256 feeAmount = organizationFee;\n        //if the position is insured, calculate the insurance fee\n        if (position.borrowType == BorrowType.USE_INSURANCE || _useInsurance) {\n            feeAmount +=\n                (_amount * settings.insurancePurchaseRate.numerator) /\n                settings.insurancePurchaseRate.denominator;\n        }\n        totalFeeCollected += feeAmount;\n        //subtract the fee from the amount borrowed\n        stablecoin.mint(msg.sender, _amount - feeAmount);\n\n        if (position.borrowType == BorrowType.NOT_CONFIRMED) {\n            position.borrowType = _useInsurance\n                ? BorrowType.USE_INSURANCE\n                : BorrowType.NON_INSURANCE;\n        }\n\n        // update debt portion\n        if (totalDebtPortion == 0) {\n            totalDebtPortion = _amount;\n            position.debtPortion = _amount;\n        } else {\n            uint256 plusPortion = (totalDebtPortion * _amount) /\n                totalDebtAmount;\n            totalDebtPortion += plusPortion;\n            position.debtPortion += plusPortion;\n        }\n        position.debtPrincipal += _amount;\n        totalDebtAmount += _amount;\n\n        emit Borrowed(msg.sender, _nftIndex, _amount);\n    }\n\n    /// @notice Allows users to repay a portion/all of their debt. Note that since interest increases every second,\n    /// a user wanting to repay all of their debt should repay for an amount greater than their current debt to account for the\n    /// additional interest while the repay transaction is pending, the contract will only take what's necessary to repay all the debt\n    /// @dev Emits a {Repaid} event\n    /// @param _nftIndex The NFT used as collateral for the position\n    /// @param _amount The amount of debt to repay. If greater than the position's outstanding debt, only the amount necessary to repay all the debt will be taken\n    function repay(uint256 _nftIndex, uint256 _amount)\n        external\n        validNFTIndex(_nftIndex)\n        nonReentrant\n    {\n        accrue();\n\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(_amount > 0, \"invalid_amount\");\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(debtAmount > 0, \"position_not_borrowed\");\n\n        uint256 debtPrincipal = position.debtPrincipal;\n        uint256 debtInterest = debtAmount - debtPrincipal;\n\n        _amount = _amount > debtAmount ? debtAmount : _amount;\n\n        // burn all payment, the interest is sent to the DAO using the {collect} function\n        stablecoin.burnFrom(msg.sender, _amount);\n\n        uint256 paidPrincipal = _amount > debtInterest\n            ? _amount - debtInterest\n            : 0;\n\n        uint256 minusPortion = paidPrincipal == debtPrincipal\n            ? position.debtPortion\n            : (totalDebtPortion * _amount) / totalDebtAmount;\n\n        totalDebtPortion -= minusPortion;\n        position.debtPortion -= minusPortion;\n        position.debtPrincipal -= paidPrincipal;\n        totalDebtAmount -= _amount;\n\n        emit Repaid(msg.sender, _nftIndex, _amount);\n    }\n\n    /// @notice Allows a user to close a position and get their collateral back, if the position's outstanding debt is 0\n    /// @dev Emits a {PositionClosed} event\n    /// @param _nftIndex The index of the NFT used as collateral\n    function closePosition(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        accrue();\n\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(_getDebtAmount(_nftIndex) == 0, \"position_not_repaid\");\n\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        // transfer nft back to owner if nft was deposited\n        if (nftContract.ownerOf(_nftIndex) == address(this)) {\n            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n        }\n\n        emit PositionClosed(msg.sender, _nftIndex);\n    }\n\n    /// @notice Allows members of the `LIQUIDATOR_ROLE` to liquidate a position. Positions can only be liquidated\n    /// once their debt amount exceeds the minimum liquidation debt to collateral value rate.\n    /// In order to liquidate a position, the liquidator needs to repay the user's outstanding debt.\n    /// If the position is not insured, it's closed immediately and the collateral is sent to the liquidator.\n    /// If the position is insured, the position remains open (interest doesn't increase) and the owner of the position has a certain amount of time\n    /// (`insuranceRepurchaseTimeLimit`) to fully repay the liquidator and pay an additional liquidation fee (`insuranceLiquidationPenaltyRate`), if this\n    /// is done in time the user gets back their collateral and their position is automatically closed. If the user doesn't repurchase their collateral\n    /// before the time limit passes, the liquidator can claim the liquidated NFT and the position is closed\n    /// @dev Emits a {Liquidated} event\n    /// @param _nftIndex The NFT to liquidate\n    function liquidate(uint256 _nftIndex)\n        external\n        onlyRole(LIQUIDATOR_ROLE)\n        validNFTIndex(_nftIndex)\n        nonReentrant\n    {\n        accrue();\n\n        address posOwner = positionOwner[_nftIndex];\n        require(posOwner != address(0), \"position_not_exist\");\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(\n            debtAmount >= _getLiquidationLimit(_nftIndex),\n            \"position_not_liquidatable\"\n        );\n\n        // burn all payment\n        stablecoin.burnFrom(msg.sender, debtAmount);\n\n        // update debt portion\n        totalDebtPortion -= position.debtPortion;\n        totalDebtAmount -= debtAmount;\n        position.debtPortion = 0;\n\n        bool insured = position.borrowType == BorrowType.USE_INSURANCE;\n        if (insured) {\n            position.debtAmountForRepurchase = debtAmount;\n            position.liquidatedAt = block.timestamp;\n            position.liquidator = msg.sender;\n        } else {\n            // transfer nft to liquidator\n            positionOwner[_nftIndex] = address(0);\n            delete positions[_nftIndex];\n            positionIndexes.remove(_nftIndex);\n            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n        }\n\n        emit Liquidated(msg.sender, posOwner, _nftIndex, insured);\n    }\n\n    /// @notice Allows liquidated users who purchased insurance to repurchase their collateral within the time limit\n    /// defined with the `insuranceRepurchaseTimeLimit`. The user needs to pay the liquidator the total amount of debt\n    /// the position had at the time of liquidation, plus an insurance liquidation fee defined with `insuranceLiquidationPenaltyRate`\n    /// @dev Emits a {Repurchased} event\n    /// @param _nftIndex The NFT to repurchase\n    function repurchase(uint256 _nftIndex) external validNFTIndex(_nftIndex) {\n        Position memory position = positions[_nftIndex];\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(position.liquidatedAt > 0, \"not_liquidated\");\n        require(\n            position.borrowType == BorrowType.USE_INSURANCE,\n            \"non_insurance\"\n        );\n        require(\n            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit >=\n                block.timestamp,\n            \"insurance_expired\"\n        );\n\n        uint256 debtAmount = position.debtAmountForRepurchase;\n        uint256 penalty = (debtAmount *\n            settings.insuranceLiquidationPenaltyRate.numerator) /\n            settings.insuranceLiquidationPenaltyRate.denominator;\n\n        // transfer payment to liquidator\n        stablecoin.transferFrom(\n            msg.sender,\n            position.liquidator,\n            debtAmount + penalty\n        );\n\n        // transfer nft to user\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n\n        emit Repurchased(msg.sender, _nftIndex);\n    }\n\n    /// @notice Allows the liquidator who liquidated the insured position with NFT at index `_nftIndex` to claim the position's collateral\n    /// after the time period defined with `insuranceRepurchaseTimeLimit` has expired and the position owner has not repurchased the collateral.\n    /// @dev Emits an {InsuranceExpired} event\n    /// @param _nftIndex The NFT to claim\n    function claimExpiredInsuranceNFT(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        Position memory position = positions[_nftIndex];\n        address owner = positionOwner[_nftIndex];\n        require(address(0) != owner, \"no_position\");\n        require(position.liquidatedAt > 0, \"not_liquidated\");\n        require(\n            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit <\n                block.timestamp,\n            \"insurance_not_expired\"\n        );\n        require(position.liquidator == msg.sender, \"unauthorized\");\n\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n\n        emit InsuranceExpired(owner, _nftIndex);\n    }\n\n    /// @notice Allows the DAO to collect interest and fees before they are repaid\n    function collect() external nonReentrant onlyRole(DAO_ROLE) {\n        accrue();\n        stablecoin.mint(msg.sender, totalFeeCollected);\n        totalFeeCollected = 0;\n    }\n\n    uint256[50] private __gap;\n}\n\n\n",
        "CodeNames": [
            "NFTVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NFTVault.sol#L590-L595",
                "Type": "Interest calculation error",
                "Description": "Division before Multiplication May Result In No Interest Being Accrued.",
                "Repair": "Perform the multiplication by elapsedTime before the division by the denominator or 365 days."
            },
            {
                "Location": "NFTVault.sol#L844-L851",
                "Type": "Accruing interest on bad debts",
                "Description": "Bad debts should not continue to accrue interest.",
                "Repair": "Add a stored value to record the amount of bad debt, and add a public function that allows anyone to mark a bad debt to get some reward. and change accrue function."
            },
            {
                "Location": "setDebtInterestApr function in NFTVault.sol",
                "Type": "setDebtInterestApr should accrue debt first",
                "Description": "The new debt interest rate is applied retroactively to the unaccrued period on next accrue() call. It should never be applied retroactively to a previous time window as this is unfair & wrong. Borrowers can incur more debt than they should.",
                "Repair": "Call accrue() first in setDebtInterestApr before setting the new settings.debtInterestApr"
            }
        ]
    }
]