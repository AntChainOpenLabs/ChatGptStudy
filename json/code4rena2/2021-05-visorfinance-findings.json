[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "timeLockERC20() function",
                "Type": "Unhandled return value",
                "Description": "ERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return \u2018false\u2019 on failure instead of reverting. It is safer to wrap such calls into require() statements or use safe wrapper functions implementing return value/data checks to handle these failures.",
                "Repair": "Replace use of solidityIERC20(token).transferFrom(msg.sender, address(this), amount) with solidityTransferHelper.safeTransferFrom(token, msg.sender, address(this), amount)"
            },
            {
                "Location": "_removeNft() function",
                "Type": "Unbounded loop",
                "Description": "The function _removeNft uses an unbounded loop, which iterates the array nfts until a specific one is found. If the NFT to be removed is at the very end of the nfts array, this function could consume a large amount of gas.",
                "Repair": "Use a mapping (e.g., mapping(address=Nft[]) nfts) to store the received NFTs into separate arrays according to nftContract instead of putting them into the same one. Or, add a method specifically for the owner to remove NFTs from the nfts array directly."
            },
            {
                "Location": "timeLockERC721() and transferERC721() functions",
                "Type": "Timelock",
                "Description": "If a particular NFT token was timelocked for a certain duration by the owner using timeLockERC721() with a delegate as the recipient and then transferred out of the vault by the delegate via transferERC721() but without unlocking it explicitly using timeUnlockERC721(), and if that same NFT is ever put back into the vault later but this time without a timelock, the vault logic still thinks it is a timelocked NFT with the older/stale recipient from earlier because of the missing deletion. So now the owner who makes the transferERC721() call will not match the older/stale recipient address and will fail the check on L510 (unless they control that stale recipient address from the earlier timelock).",
                "Repair": "Add delete timelockERC721s timelockERC721Keys[nftContract][i]]; after L510."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/Initializable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {TransferHelper} from \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\n\nimport {EIP712} from \"./EIP712.sol\";\nimport {ERC1271} from \"./ERC1271.sol\";\nimport {OwnableERC721} from \"./OwnableERC721.sol\";\nimport {IRageQuit} from \"../hypervisor/Hypervisor.sol\";\n\nimport {IUniversalVault} from \"../interfaces/IUniversalVault.sol\";\nimport {IVisorService} from \"../interfaces/IVisorService.sol\";\n\n/// @title Visor\n/// @notice Vault for isolated storage of staking tokens\n/// @dev Warning: not compatible with rebasing tokens\ncontract Visor is\n    IUniversalVault,\n    EIP712(\"UniversalVault\", \"1.0.0\"),\n    ERC1271,\n    OwnableERC721,\n    Initializable,\n    IERC721Receiver\n{\n    using SafeMath for uint256;\n    using Address for address;\n    using Address for address payable;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /* constant */\n\n    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks\n    // the gas requirement cannot be determined at runtime by querying the delegate\n    // as it could potentially be manipulated by a malicious delegate who could force\n    // the calls to revert.\n    // The gas limit could alternatively be set upon vault initialization or creation\n    // of a lock, but the gas consumption trade-offs are not favorable.\n    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant RAGEQUIT_GAS = 500000;\n    bytes32 public constant LOCK_TYPEHASH =\n        keccak256(\"Lock(address delegate,address token,uint256 amount,uint256 nonce)\");\n    bytes32 public constant UNLOCK_TYPEHASH =\n        keccak256(\"Unlock(address delegate,address token,uint256 amount,uint256 nonce)\");\n\n    string public constant VERSION = \"VISOR-2.0.3\";\n\n    /* storage */\n\n    uint256 private _nonce;\n    mapping(bytes32 => LockData) private _locks;\n    EnumerableSet.Bytes32Set private _lockSet;\n    string public uri;\n\n    struct Nft {\n      uint256 tokenId; \n      address nftContract;\n    }\n\n    Nft[] public nfts;\n    mapping(bytes32=>bool) public nftApprovals;\n    mapping(bytes32=>uint256) public erc20Approvals;\n\n    struct TimelockERC20 {\n      address recipient;\n      address token;\n      uint256 amount;\n      uint256 expires;\n    }\n\n    mapping(bytes32=>TimelockERC20) public timelockERC20s; \n    mapping(address=>bytes32[]) public timelockERC20Keys;\n    mapping(address=>uint256) public timelockERC20Balances;\n\n    struct TimelockERC721 {\n      address recipient;\n      address nftContract;\n      uint256 tokenId;\n      uint256 expires;\n    }\n\n    mapping(bytes32=>TimelockERC721) public timelockERC721s; \n    mapping(address=>bytes32[]) public timelockERC721Keys;\n\n    event AddNftToken(address nftContract, uint256 tokenId);\n    event RemoveNftToken(address nftContract, uint256 tokenId);\n    event TimeLockERC20(address recipient, address token, uint256 amount, uint256 expires);\n    event TimeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires);\n    event TimeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);\n    event TimeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires);\n\n    /* initialization function */\n\n    function initializeLock() external initializer {}\n\n    function initialize() external override initializer {\n      OwnableERC721._setNFT(msg.sender);\n    }\n\n    /* ether receive */\n\n    receive() external payable {}\n\n    /* internal  */\n\n    function _addNft(address nftContract, uint256 tokenId) internal {\n\n      nfts.push(\n        Nft({\n          tokenId: tokenId,\n          nftContract: nftContract\n        })\n      );\n      emit AddNftToken(nftContract, tokenId);\n    }\n\n    function _removeNft(address nftContract, uint256 tokenId) internal {\n      uint256 len = nfts.length;\n      for (uint256 i = 0; i < len; i++) {\n        Nft memory nftInfo = nfts[i];\n        if (nftContract == nftInfo.nftContract && tokenId == nftInfo.tokenId) {\n          if(i != len - 1) {\n            nfts[i] = nfts[len - 1];\n          }\n          nfts.pop();\n          emit RemoveNftToken(nftContract, tokenId);\n          break;\n        }\n      }\n    }\n\n    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {\n        return OwnableERC721.owner();\n    }\n\n    /* pure functions */\n\n    function calculateLockID(address delegate, address token)\n        public\n        pure\n        override\n        returns (bytes32 lockID)\n    {\n        return keccak256(abi.encodePacked(delegate, token));\n    }\n\n    /* getter functions */\n\n    function getPermissionHash(\n        bytes32 eip712TypeHash,\n        address delegate,\n        address token,\n        uint256 amount,\n        uint256 nonce\n    ) public view override returns (bytes32 permissionHash) {\n        return\n            EIP712._hashTypedDataV4(\n                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))\n            );\n    }\n\n    function getNonce() external view override returns (uint256 nonce) {\n        return _nonce;\n    }\n\n    function owner()\n        public\n        view\n        override(IUniversalVault, OwnableERC721)\n        returns (address ownerAddress)\n    {\n        return OwnableERC721.owner();\n    }\n\n    function getLockSetCount() external view override returns (uint256 count) {\n        return _lockSet.length();\n    }\n\n    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {\n        return _locks[_lockSet.at(index)];\n    }\n\n    function getBalanceDelegated(address token, address delegate)\n        external\n        view\n        override\n        returns (uint256 balance)\n    {\n        return _locks[calculateLockID(delegate, token)].balance;\n    }\n\n    function getBalanceLocked(address token) public view override returns (uint256 balance) {\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            if (_lockData.token == token && _lockData.balance > balance)\n                balance = _lockData.balance;\n        }\n        return balance;\n    }\n\n    function checkBalances() external view override returns (bool validity) {\n        // iterate over all token locks and validate sufficient balance\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            // fetch storage lock reference\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            // if insufficient balance and no\u220ft shutdown, return false\n            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;\n        }\n        // if sufficient balance or shutdown, return true\n        return true;\n    }\n\n    // @notice Get ERC721 from nfts[] by index\n    /// @param i nfts index of nfts[] \n    function getNftById(uint256 i) external view returns (address nftContract, uint256 tokenId) {\n        require(i < nfts.length, \"ID overflow\");\n        Nft memory ni = nfts[i];\n        nftContract = ni.nftContract;\n        tokenId = ni.tokenId;\n    }\n\n    // @notice Get index of ERC721 in nfts[]\n    /// @param nftContract Address of ERC721 \n    /// @param tokenId tokenId for NFT in nftContract \n    function getNftIdByTokenIdAndAddr(address nftContract, uint256 tokenId) external view returns(uint256) {\n        uint256 len = nfts.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (nftContract == nfts[i].nftContract && tokenId == nfts[i].tokenId) {\n                return i;\n            }\n        }\n        require(false, \"Token not found\");\n    }\n\n    // @notice Get number of timelocks for given ERC20 token \n    function getTimeLockCount(address token) public view returns(uint256) {\n      return timelockERC20Keys[token].length;\n    }\n\n    // @notice Get number of timelocks for NFTs of a given ERC721 contract \n    function getTimeLockERC721Count(address nftContract) public view returns(uint256) {\n      return timelockERC721Keys[nftContract].length;\n    }\n\n    /* user functions */\n\n    /// @notice Lock ERC20 tokens in the vault\n    /// access control: called by delegate with signed permission from owner\n    /// state machine: anytime\n    /// state scope:\n    /// - insert or update _locks\n    /// - increase _nonce\n    /// token transfer: none\n    /// @param token Address of token being locked\n    /// @param amount Amount of tokens being locked\n    /// @param permission Permission signature payload\n    function lock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    )\n        external\n        override\n        onlyValidSignature(\n            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),\n            permission\n        )\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(msg.sender, token);\n\n        // add lock to storage\n        if (_lockSet.contains(lockID)) {\n            // if lock already exists, increase amount\n            _locks[lockID].balance = _locks[lockID].balance.add(amount);\n        } else {\n            // if does not exist, create new lock\n            // add lock to set\n            assert(_lockSet.add(lockID));\n            // add lock data to storage\n            _locks[lockID] = LockData(msg.sender, token, amount);\n        }\n\n        // validate sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,\n            \"UniversalVault: insufficient balance\"\n        );\n\n        // increase nonce\n        _nonce += 1;\n\n        // emit event\n        emit Locked(msg.sender, token, amount);\n    }\n\n    /// @notice Unlock ERC20 tokens in the vault\n    /// access control: called by delegate with signed permission from owner\n    /// state machine: after valid lock from delegate\n    /// state scope:\n    /// - remove or update _locks\n    /// - increase _nonce\n    /// token transfer: none\n    /// @param token Address of token being unlocked\n    /// @param amount Amount of tokens being unlocked\n    /// @param permission Permission signature payload\n    function unlock(\n        address token,\n        uint256 amount,\n        bytes calldata permission\n    )\n        external\n        override\n        onlyValidSignature(\n            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),\n            permission\n        )\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(msg.sender, token);\n\n        // validate existing lock\n        require(_lockSet.contains(lockID), \"UniversalVault: missing lock\");\n\n        // update lock data\n        if (_locks[lockID].balance > amount) {\n            // substract amount from lock balance\n            _locks[lockID].balance = _locks[lockID].balance.sub(amount);\n        } else {\n            // delete lock data\n            delete _locks[lockID];\n            assert(_lockSet.remove(lockID));\n        }\n\n        // increase nonce\n        _nonce += 1;\n\n        // emit event\n        emit Unlocked(msg.sender, token, amount);\n    }\n\n    /// @notice Forcibly cancel delegate lock\n    /// @dev This function will attempt to notify the delegate of the rage quit using\n    ///      a fixed amount of gas.\n    /// access control: only owner\n    /// state machine: after valid lock from delegate\n    /// state scope:\n    /// - remove item from _locks\n    /// token transfer: none\n    /// @param delegate Address of delegate\n    /// @param token Address of token being unlocked\n    function rageQuit(address delegate, address token)\n        external\n        override\n        onlyOwner\n        returns (bool notified, string memory error)\n    {\n        // get lock id\n        bytes32 lockID = calculateLockID(delegate, token);\n\n        // validate existing lock\n        require(_lockSet.contains(lockID), \"UniversalVault: missing lock\");\n\n        // attempt to notify delegate\n        if (delegate.isContract()) {\n            // check for sufficient gas\n            require(gasleft() >= RAGEQUIT_GAS, \"UniversalVault: insufficient gas\");\n\n            // attempt rageQuit notification\n            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {\n                notified = true;\n            } catch Error(string memory res) {\n                notified = false;\n                error = res;\n            } catch (bytes memory) {\n                notified = false;\n            }\n        }\n\n        // update lock storage\n        assert(_lockSet.remove(lockID));\n        delete _locks[lockID];\n\n        // emit event\n        emit RageQuit(delegate, token, notified, error);\n    }\n\n    function setURI(string memory _uri) public onlyOwner {\n      uri = _uri;\n    }\n\n    /// @notice Transfer ERC20 tokens out of vault\n    /// access control: only owner\n    /// state machine: when balance >= max(lock) + amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param token Address of token being transferred\n    /// @param to Address of the to\n    /// @param amount Amount of tokens to transfer\n    function transferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external override onlyOwner {\n        // check for sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\n            \"UniversalVault: insufficient balance\"\n        );\n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    // @notice Approve delegate account to transfer ERC20 tokens out of vault\n    /// @param token Address of token being transferred\n    /// @param delegate Address being approved\n    /// @param amount Amount of tokens approved to transfer\n    function approveTransferERC20(address token, address delegate, uint256 amount) external onlyOwner {\n      erc20Approvals[keccak256(abi.encodePacked(delegate, token))] = amount;\n    }\n\n    /// @notice Transfer ERC20 tokens out of vault with an approved account\n    /// access control: only approved accounts in erc20Approvals \n    /// state machine: when balance >= max(lock) + amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param token Address of token being transferred\n    /// @param to Address of the to\n    /// @param amount Amount of tokens to transfer\n    function delegatedTransferERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        if(msg.sender != _getOwner()) {\n\n        require( \n            erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,\n            \"Account not approved to transfer amount\"); \n        } \n\n        // check for sufficient balance\n        require(\n            IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\n            \"UniversalVault: insufficient balance\"\n        );\n        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);\n        \n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    /// @notice Transfer ETH out of vault\n    /// access control: only owner\n    /// state machine: when balance >= amount\n    /// state scope: none\n    /// token transfer: transfer any token\n    /// @param to Address of the to\n    /// @param amount Amount of ETH to transfer\n    function transferETH(address to, uint256 amount) external payable override onlyOwner {\n      // perform transfer\n      TransferHelper.safeTransferETH(to, amount);\n    }\n\n    // @notice Approve delegate account to transfer ERC721 token out of vault\n    /// @param delegate Account address being approved to transfer nft  \n    /// @param nftContract address of nft minter \n    /// @param tokenId token id of the nft instance \n    function approveTransferERC721(\n      address delegate, \n      address nftContract, \n      uint256 tokenId\n    ) external onlyOwner {\n      nftApprovals[keccak256(abi.encodePacked(delegate, nftContract, tokenId))] = true;\n    }\n\n    /// @notice Transfer ERC721 out of vault\n    /// access control: only owner or approved\n    /// ERC721 transfer: transfer any ERC721 token\n    /// @param to recipient address \n    /// @param nftContract address of nft minter \n    /// @param tokenId token id of the nft instance \n    function transferERC721(\n        address to,\n        address nftContract,\n        uint256 tokenId\n    ) external {\n        if(msg.sender != _getOwner()) {\n          require( nftApprovals[keccak256(abi.encodePacked(msg.sender, nftContract, tokenId))], \"NFT not approved for transfer\"); \n        } \n\n        for(uint256 i=0; i<timelockERC721Keys[nftContract].length; i++) {\n          if(tokenId == timelockERC721s[timelockERC721Keys[nftContract][i]].tokenId) {\n              require(\n                timelockERC721s[timelockERC721Keys[nftContract][i]].expires <= block.timestamp, \n                \"NFT locked and not expired\"\n              );\n              require( timelockERC721s[timelockERC721Keys[nftContract][i]].recipient == msg.sender, \"NFT locked and must be withdrawn by timelock recipient\");\n          }\n        }\n\n        _removeNft(nftContract, tokenId);\n        IERC721(nftContract).safeTransferFrom(address(this), to, tokenId);\n    }\n\n    // @notice Adjust nfts[] on ERC721 token recieved \n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata) external override returns (bytes4) {\n      _addNft(msg.sender, tokenId);\n      return IERC721Receiver.onERC721Received.selector;\n    }\n\n    // @notice Lock ERC721 in vault until expires, redeemable by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param nftContract address of nft minter \n    /// @param tokenId Token id of the nft instance \n    /// @param expires Timestamp when recipient is allowed to withdraw \n    function timeLockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public onlyOwner {\n\n      require(\n        expires > block.timestamp, \n        \"Expires must be in future\"\n      );\n \n      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); \n\n      require(\n        timelockERC721s[key].expires == 0,\n        \"TimelockERC721 already exists\"\n      );\n     \n      timelockERC721s[key] = TimelockERC721({\n          recipient: recipient,\n          nftContract: nftContract,\n          tokenId: tokenId,\n          expires: expires\n      });\n\n      timelockERC721Keys[nftContract].push(key);\n\n      IERC721(nftContract).safeTransferFrom(msg.sender, address(this), tokenId);\n      emit TimeLockERC20(recipient, nftContract, tokenId, expires);\n    }\n\n    // @notice Withdraw ERC721 in vault post expires by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param nftContract address of nft minter \n    /// @param tokenId Token id of the nft instance \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeUnlockERC721(address recipient, address nftContract, uint256 tokenId, uint256 expires) public {\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, nftContract, tokenId, expires)); \n      require(\n        timelockERC721s[key].expires <= block.timestamp,\n        \"Not expired yet\"\n      );\n\n      require(msg.sender == timelockERC721s[key].recipient, \"Not recipient\");\n\n      _removeNft(nftContract, tokenId);\n      delete timelockERC721s[key];\n\n      IERC721(nftContract).safeTransferFrom(address(this), recipient, tokenId);\n      emit TimeUnlockERC721(recipient, nftContract, tokenId, expires);\n    }\n\n    // @notice Lock ERC720 amount in vault until expires, redeemable by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param token Address of token to lock \n    /// @param amount Amount of token to lock \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeLockERC20(address recipient, address token, uint256 amount, uint256 expires) public onlyOwner {\n\n      require(\n        IERC20(token).allowance(msg.sender, address(this)) >= amount, \n        \"Amount not approved\"\n      );\n\n      require(\n        expires > block.timestamp, \n        \"Expires must be in future\"\n      );\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); \n\n      require(\n        timelockERC20s[key].expires == 0,\n        \"TimelockERC20 already exists\"\n      );\n    \n      timelockERC20s[key] = TimelockERC20({\n          recipient: recipient,\n          token: token,\n          amount: amount,\n          expires: expires\n      });\n      timelockERC20Keys[token].push(key);\n      timelockERC20Balances[token] = timelockERC20Balances[token].add(amount);\n      IERC20(token).transferFrom(msg.sender, address(this), amount);\n      emit TimeLockERC20(recipient, token, amount, expires);\n    }\n\n    // @notice Withdraw ERC20 from vault post expires by recipient\n    /// @param recipient Address with right to withdraw after expires \n    /// @param token Address of token to lock \n    /// @param amount Amount of token to lock \n    /// @param expires Timestamp when recipient is allowed to withdraw\n    function timeUnlockERC20(address recipient, address token, uint256 amount, uint256 expires) public {\n\n      require(\n        IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),\n        \"Insufficient balance\"\n      );\n\n      bytes32 key = keccak256(abi.encodePacked(recipient, token, amount, expires)); \n      require(\n        timelockERC20s[key].expires <= block.timestamp,\n        \"Not expired yet\"\n      );\n\n      require(msg.sender == timelockERC20s[key].recipient, \"Not recipient\");\n      \n      delete timelockERC20s[key];\n\n      timelockERC20Balances[token] = timelockERC20Balances[token].sub(amount);\n      TransferHelper.safeTransfer(token, recipient, amount);\n      emit TimeUnlockERC20(recipient, token, amount, expires);\n    }\n\n}\n\n\n",
        "CodeNames": [
            "Visor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "line 504 of Visor.sol",
                "Type": "timelockERC721Keys could exceed the block size limit",
                "Description": "looping through the timelockERC721Keys could exceed the block size limit",
                "Repair": "transfer by index instead of token ID"
            },
            {
                "Location": "approveTransferERC721() and transferERC721 functions in Visor.sol",
                "Type": "NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens",
                "Description": "NFT transfer approvals that are set to true in approveTransferERC721() are never set to false and there is no way to remove such an nft approval.",
                "Repair": "adding a boolean parameter to approveTransferERC721() and set the nftApprovals to that parameter which can be true for giving approval and false for removing/revoking approval"
            },
            {
                "Location": "transferERC721 function in Visor.sol",
                "Type": "transferERC721 doesn't clean timelockERC721s",
                "Description": "timeUnlockERC721 cleans timelockERC721s (delete timelockERC721s[key];), while transferERC721 doesn't clean timelockERC721s",
                "Repair": "checking if the timelockERC721s mapping should also be cleaned from transferERC721, if so adapt the code accordingly"
            },
            {
                "Location": "Visor.transferERC721 function in Visor.sol",
                "Type": "Approval for NFT transfers is not removed after transfer",
                "Description": "The Visor.transferERC721 does not reset the approval for the NFT.",
                "Repair": "resetting the approval on transfer"
            }
        ]
    }
]