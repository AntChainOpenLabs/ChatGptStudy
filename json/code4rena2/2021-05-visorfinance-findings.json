[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "timeLockERC20() function",
                "Type": "Unhandled return value",
                "Description": "ERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return \u2018false\u2019 on failure instead of reverting. It is safer to wrap such calls into require() statements or use safe wrapper functions implementing return value/data checks to handle these failures.",
                "Repair": "Replace use of solidityIERC20(token).transferFrom(msg.sender, address(this), amount) with solidityTransferHelper.safeTransferFrom(token, msg.sender, address(this), amount)"
            },
            {
                "Location": "_removeNft() function",
                "Type": "Unbounded loop",
                "Description": "The function _removeNft uses an unbounded loop, which iterates the array nfts until a specific one is found. If the NFT to be removed is at the very end of the nfts array, this function could consume a large amount of gas.",
                "Repair": "Use a mapping (e.g., mapping(address=Nft[]) nfts) to store the received NFTs into separate arrays according to nftContract instead of putting them into the same one. Or, add a method specifically for the owner to remove NFTs from the nfts array directly."
            },
            {
                "Location": "timeLockERC721() and transferERC721() functions",
                "Type": "Permanent lock",
                "Description": "If a particular NFT token was timelocked for a certain duration by the owner using timeLockERC721() with a delegate as the recipient and then transferred out of the vault by the delegate via transferERC721() but without unlocking it explicitly using timeUnlockERC721(), and if that same NFT is ever put back into the vault later but this time without a timelock, the vault logic still thinks it is a timelocked NFT with the older/stale recipient from earlier because of the missing deletion. So now the owner who makes the transferERC721() call will not match the older/stale recipient address and will fail the check on L510 (unless they control that stale recipient address from the earlier timelock). The impact is that, without access/control to the earlier timelock recipient, this NFT token is now locked in the vault forever.",
                "Repair": "Add delete timelockERC721s timelockERC721Keys[nftContract][i]]; after L510."
            },
            {
                "Location": "timelockERC721Keys loop",
                "Type": "Block size limit",
                "Description": "Looping through the timelockERC721Keys could exceed the block size limit.",
                "Repair": "Transfer by index instead of token ID"
            },
            {
                "Location": "approveTransferERC721() and transferERC721() functions",
                "Type": "NFT transfer approval not removed",
                "Description": "NFT transfer approvals are not removed and cannot be revoked thus leading to loss of NFT tokens.",
                "Repair": "Add a boolean parameter to approveTransferERC721() and set the nftApprovals to that parameter which can be true for giving approval and false for removing/revoking approval. Call approveTransferERC721() with the boolean false to remove approval before making a transfer in transferERC721() on L515 if msg.sender != _getOwner()."
            },
            {
                "Location": "transferERC721() function",
                "Type": "timelockERC721s not cleaned",
                "Description": "transferERC721 doesn't clean timelockERC721s.",
                "Repair": "Check if the timelockERC721s mapping should also be cleaned from transferERC721 and adapt the code accordingly."
            },
            {
                "Location": "transferERC721() function",
                "Type": "Approval for NFT transfers not removed after transfer",
                "Description": "Approval for NFT transfers is not removed after transfer.",
                "Repair": "Reset the approval on transfer."
            }
        ]
    }
]