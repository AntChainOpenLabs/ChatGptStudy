[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ECCMath} from \"./util/ECCMath.sol\";\nimport {ISizeSealed} from \"./interfaces/ISizeSealed.sol\";\nimport {CommonTokenMath} from \"./util/CommonTokenMath.sol\";\n\n/// @title Size Sealed Auction\n/// @author Size Market\ncontract SizeSealed is ISizeSealed {\n    ///////////////////////////////\n    ///          STATE          ///\n    ///////////////////////////////\n\n    uint256 public currentAuctionId;\n\n    mapping(uint256 => Auction) public idToAuction;\n\n    ///////////////////////////////////////////////////\n    ///                  MODIFIERS                  ///\n    ///////////////////////////////////////////////////\n\n    modifier atState(Auction storage a, States _state) {\n        if (block.timestamp < a.timings.startTimestamp) {\n            if (_state != States.Created) revert InvalidState();\n        } else if (block.timestamp < a.timings.endTimestamp) {\n            if (_state != States.AcceptingBids) revert InvalidState();\n        } else if (a.data.lowestQuote != type(uint128).max) {\n            if (_state != States.Finalized) revert InvalidState();\n        } else if (block.timestamp <= a.timings.endTimestamp + 24 hours) {\n            if (_state != States.RevealPeriod) revert InvalidState();\n        } else if (block.timestamp > a.timings.endTimestamp + 24 hours) {\n            if (_state != States.Voided) revert InvalidState();\n        } else {\n            revert();\n        }\n        _;\n    }\n\n    ///////////////////////////////////////////////////////////////////////\n    ///                          AUCTION LOGIC                          ///\n    ///////////////////////////////////////////////////////////////////////\n\n    /// @notice Creates a new sealed auction\n    /// @dev Transfers the `baseToken` from `msg.sender` to the contract\n    /// @return `auctionId` unique to that auction\n    /// @param auctionParams Parameters used during the auction\n    /// @param timings The timestamps at which the auction starts/ends\n    /// @param encryptedSellerPrivKey Encrypted seller's ephemeral private key\n    function createAuction(\n        AuctionParameters calldata auctionParams,\n        Timings calldata timings,\n        bytes calldata encryptedSellerPrivKey\n    ) external returns (uint256) {\n        if (timings.endTimestamp <= block.timestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.startTimestamp >= timings.endTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.endTimestamp > timings.vestingStartTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.vestingStartTimestamp > timings.vestingEndTimestamp) {\n            revert InvalidTimestamp();\n        }\n        if (timings.cliffPercent > 1e18) {\n            revert InvalidCliffPercent();\n        }\n        // Revert if the min bid is more than the total reserve of the auction\n        if (\n            FixedPointMathLib.mulDivDown(\n                auctionParams.minimumBidQuote, type(uint128).max, auctionParams.totalBaseAmount\n            ) > auctionParams.reserveQuotePerBase\n        ) {\n            revert InvalidReserve();\n        }\n\n        uint256 auctionId = ++currentAuctionId;\n\n        Auction storage a = idToAuction[auctionId];\n        a.timings = timings;\n\n        a.data.seller = msg.sender;\n        a.data.lowestQuote = type(uint128).max;\n\n        a.params = auctionParams;\n\n        // Passes https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol#L9\n        // Transfer base tokens to auction contract and check for tax tokens\n        uint256 balanceBeforeTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n\n        SafeTransferLib.safeTransferFrom(\n            ERC20(auctionParams.baseToken), msg.sender, address(this), auctionParams.totalBaseAmount\n        );\n\n        uint256 balanceAfterTransfer = ERC20(auctionParams.baseToken).balanceOf(address(this));\n        if (balanceAfterTransfer - balanceBeforeTransfer != auctionParams.totalBaseAmount) {\n            revert UnexpectedBalanceChange();\n        }\n\n        emit AuctionCreated(auctionId, msg.sender, auctionParams, timings, encryptedSellerPrivKey);\n\n        return auctionId;\n    }\n\n    /// @notice Bid on a runnning auction\n    /// @dev Transfers `quoteAmount` of `quoteToken` from bidder to contract\n    /// @return Index of the bid\n    /// @param auctionId Id of the auction to bid on\n    /// @param quoteAmount Amount of `quoteTokens` bidding on a committed amount of `baseTokens`\n    /// @param commitment Hash commitment of the `baseAmount`\n    /// @param pubKey Public key used to encrypt `baseAmount`\n    /// @param encryptedMessage `baseAmount` encrypted to the seller's public key\n    /// @param encryptedPrivateKey Encrypted private key for on-chain storage\n    /// @param proof Merkle proof that checks seller against `merkleRoot` if there is a whitelist\n    function bid(\n        uint256 auctionId,\n        uint128 quoteAmount,\n        bytes32 commitment,\n        ECCMath.Point calldata pubKey,\n        bytes32 encryptedMessage,\n        bytes calldata encryptedPrivateKey,\n        bytes32[] calldata proof\n    ) external atState(idToAuction[auctionId], States.AcceptingBids) returns (uint256) {\n        Auction storage a = idToAuction[auctionId];\n        if (a.params.merkleRoot != bytes32(0)) {\n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n            if (!MerkleProofLib.verify(proof, a.params.merkleRoot, leaf)) {\n                revert InvalidProof();\n            }\n        }\n\n        // Seller cannot bid on their own auction\n        if (msg.sender == a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n\n        if (quoteAmount == 0 || quoteAmount == type(uint128).max || quoteAmount < a.params.minimumBidQuote) {\n            revert InvalidBidAmount();\n        }\n\n        EncryptedBid memory ebid;\n        ebid.sender = msg.sender;\n        ebid.quoteAmount = quoteAmount;\n        ebid.commitment = commitment;\n        ebid.pubKey = pubKey;\n        ebid.encryptedMessage = encryptedMessage;\n\n        uint256 bidIndex = a.bids.length;\n        // Max of 1000 bids on an auction to prevent DOS\n        if (bidIndex >= 1000) {\n            revert InvalidState();\n        }\n\n        a.bids.push(ebid);\n\n        SafeTransferLib.safeTransferFrom(ERC20(a.params.quoteToken), msg.sender, address(this), quoteAmount);\n\n        emit Bid(\n            msg.sender, auctionId, bidIndex, quoteAmount, commitment, pubKey, encryptedMessage, encryptedPrivateKey\n        );\n\n        return bidIndex;\n    }\n\n    /// @notice Reveals the private key of the seller\n    /// @dev All valid bids are decrypted after this\n    ///      finalizeData should be empty if seller does not wish to finalize in this tx\n    /// @param privateKey Private key corresponding to the auctions public key\n    /// @param finalizeData Calldata that will be sent to finalize()\n    function reveal(uint256 auctionId, uint256 privateKey, bytes calldata finalizeData)\n        external\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        if (a.data.seller != msg.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        ECCMath.Point memory pubKey = ECCMath.publicKey(privateKey);\n        if (pubKey.x != a.params.pubKey.x || pubKey.y != a.params.pubKey.y || (pubKey.x == 1 && pubKey.y == 1)) {\n            revert InvalidPrivateKey();\n        }\n\n        a.data.privKey = privateKey;\n\n        emit RevealedKey(auctionId, privateKey);\n\n        if (finalizeData.length != 0) {\n            (uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote) =\n                abi.decode(finalizeData, (uint256[], uint128, uint128));\n            finalize(auctionId, bidIndices, clearingBase, clearingQuote);\n        }\n    }\n\n    // Used to get around stack too deep errors -- even with viaIr\n    struct FinalizeData {\n        uint256 reserveQuotePerBase;\n        uint128 totalBaseAmount;\n        uint128 filledBase;\n        uint256 previousQuotePerBase;\n        uint256 previousIndex;\n    }\n\n    /// @notice Finalises an auction by revealing all bids\n    /// @dev Calculates the minimum `quotePerBase` and marks successful bids\n    /// @param auctionId `auctionId` of the auction to bid on\n    /// @param bidIndices Bids sorted by price descending\n    /// @param clearingBase Denominator in the clearing price calculation\n    /// @param clearingQuote Numerator in the clearing price calculation\n    function finalize(uint256 auctionId, uint256[] memory bidIndices, uint128 clearingBase, uint128 clearingQuote)\n        public\n        atState(idToAuction[auctionId], States.RevealPeriod)\n    {\n        Auction storage a = idToAuction[auctionId];\n        uint256 sellerPriv = a.data.privKey;\n        if (sellerPriv == 0) {\n            revert InvalidPrivateKey();\n        }\n\n        if (bidIndices.length != a.bids.length) {\n            revert InvalidCalldata();\n        }\n\n        FinalizeData memory data;\n        data.reserveQuotePerBase = a.params.reserveQuotePerBase;\n        data.totalBaseAmount = a.params.totalBaseAmount;\n        data.previousQuotePerBase = type(uint256).max;\n\n        // Last filled bid is the clearing price\n        a.data.lowestBase = clearingBase;\n        a.data.lowestQuote = clearingQuote;\n\n        // Bitmap of all the bid indices that have been processed\n        uint256[] memory seenBidMap = new uint256[]((bidIndices.length/256)+1);\n\n        // Fill orders from highest price to lowest price\n        for (uint256 i; i < bidIndices.length; i++) {\n            uint256 bidIndex = bidIndices[i];\n            EncryptedBid storage b = a.bids[bidIndex];\n\n            // Verify this bid index hasn't been seen before\n            uint256 bitmapIndex = bidIndex / 256;\n            uint256 bitMap = seenBidMap[bitmapIndex];\n            uint256 indexBit = 1 << (bidIndex % 256);\n            if (bitMap & indexBit == 1) revert InvalidState();\n            seenBidMap[bitmapIndex] = bitMap | indexBit;\n\n            // G^k1^k2 == G^k2^k1\n            ECCMath.Point memory sharedPoint = ECCMath.ecMul(b.pubKey, sellerPriv);\n            // If the bidder public key isn't on the bn128 curve\n            if (sharedPoint.x == 1 && sharedPoint.y == 1) continue;\n\n            bytes32 decryptedMessage = ECCMath.decryptMessage(sharedPoint, b.encryptedMessage);\n            // If the bidder didn't faithfully submit commitment or pubkey\n            // Or the bid was cancelled\n            if (computeCommitment(decryptedMessage) != b.commitment) continue;\n\n            // First 128 bits are the base amount, last are random salt\n            uint128 baseAmount = uint128(uint256(decryptedMessage >> 128));\n\n            // Require that bids are passed in descending price\n            uint256 quotePerBase = FixedPointMathLib.mulDivDown(b.quoteAmount, type(uint128).max, baseAmount);\n            if (quotePerBase >= data.previousQuotePerBase) {\n                // If last bid was the same price, make sure we filled the earliest bid first\n                if (quotePerBase == data.previousQuotePerBase) {\n                    if (data.previousIndex > bidIndex) revert InvalidSorting();\n                } else {\n                    revert InvalidSorting();\n                }\n            }\n\n            // Only fill if above reserve price\n            if (quotePerBase < data.reserveQuotePerBase) continue;\n\n            // Auction has been fully filled\n            if (data.filledBase == data.totalBaseAmount) continue;\n\n            data.previousQuotePerBase = quotePerBase;\n            data.previousIndex = bidIndex;\n\n            // Fill the remaining unfilled base amount\n            if (data.filledBase + baseAmount > data.totalBaseAmount) {\n                baseAmount = data.totalBaseAmount - data.filledBase;\n            }\n\n            b.filledBaseAmount = baseAmount;\n            data.filledBase += baseAmount;\n        }\n\n        if (data.previousQuotePerBase != FixedPointMathLib.mulDivDown(clearingQuote, type(uint128).max, clearingBase)) {\n            revert InvalidCalldata();\n        }\n\n        // seenBidMap[0:len-1] should be full\n        for (uint256 i; i < seenBidMap.length - 1; i++) {\n            if (seenBidMap[i] != type(uint256).max) {\n                revert InvalidState();\n            }\n        }\n\n        // seenBidMap[-1] should only have the last N bits set\n        if (seenBidMap[seenBidMap.length - 1] != (1 << (bidIndices.length % 256)) - 1) {\n            revert InvalidState();\n        }\n\n        if (data.filledBase > data.totalBaseAmount) {\n            revert InvalidState();\n        }\n\n        // Transfer the left over baseToken\n        if (data.totalBaseAmount != data.filledBase) {\n            uint128 unsoldBase = data.totalBaseAmount - data.filledBase;\n            a.params.totalBaseAmount = data.filledBase;\n            SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), a.data.seller, unsoldBase);\n        }\n\n        // Calculate quote amount based on clearing price\n        uint256 filledQuote = FixedPointMathLib.mulDivDown(clearingQuote, data.filledBase, clearingBase);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), a.data.seller, filledQuote);\n\n        emit AuctionFinalized(auctionId, bidIndices, data.filledBase, filledQuote);\n    }\n\n    /// @notice Called after finalize for unsuccessful bidders to return funds\n    /// @dev Returns all `quoteToken` to the original bidder\n    /// @param auctionId `auctionId` of the auction to bid on\n    /// @param bidIndex Index of the failed bid to be refunded\n    function refund(uint256 auctionId, uint256 bidIndex) external atState(idToAuction[auctionId], States.Finalized) {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        if (b.filledBaseAmount != 0) {\n            revert InvalidState();\n        }\n\n        b.sender = address(0);\n\n        emit BidRefund(auctionId, bidIndex);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount);\n    }\n\n    /// @notice Called after finalize for successful bidders\n    /// @dev Returns won `baseToken` & any unfilled `quoteToken` to the bidder\n    /// @param auctionId `auctionId` of the auction bid on\n    /// @param bidIndex Index of the successful bid\n    function withdraw(uint256 auctionId, uint256 bidIndex) external atState(idToAuction[auctionId], States.Finalized) {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        uint128 baseAmount = b.filledBaseAmount;\n        if (baseAmount == 0) {\n            revert InvalidState();\n        }\n\n        uint128 baseTokensAvailable = tokensAvailableForWithdrawal(auctionId, baseAmount);\n        baseTokensAvailable = baseTokensAvailable - b.baseWithdrawn;\n\n        b.baseWithdrawn += baseTokensAvailable;\n\n        // Refund unfilled quoteAmount on first withdraw\n        if (b.quoteAmount != 0) {\n            uint256 quoteBought = FixedPointMathLib.mulDivDown(baseAmount, a.data.lowestQuote, a.data.lowestBase);\n            uint256 refundedQuote = b.quoteAmount - quoteBought;\n            b.quoteAmount = 0;\n\n            SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, refundedQuote);\n        }\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, baseTokensAvailable);\n\n        emit Withdrawal(auctionId, bidIndex, baseTokensAvailable, baseAmount - b.baseWithdrawn);\n    }\n\n    /// @dev Transfers `baseToken` back to seller and will enable withdraws for bidders\n    /// @param auctionId `auctionId` of the auction to be cancelled\n    function cancelAuction(uint256 auctionId) external {\n        Auction storage a = idToAuction[auctionId];\n        if (msg.sender != a.data.seller) {\n            revert UnauthorizedCaller();\n        }\n        // Only allow cancellations before finalization\n        // Equivalent to atState(idToAuction[auctionId], ~STATE_FINALIZED)\n        if (a.data.lowestQuote != type(uint128).max) {\n            revert InvalidState();\n        }\n\n        // Allowing bidders to cancel bids (withdraw quote)\n        // Auction considered forever States.AcceptingBids but nobody can finalize\n        a.data.seller = address(0);\n        a.timings.endTimestamp = type(uint32).max;\n\n        emit AuctionCancelled(auctionId);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.baseToken), msg.sender, a.params.totalBaseAmount);\n    }\n\n    /// @dev Transfers `quoteToken` back to bidder and prevents bid from being finalised\n    /// @param auctionId `auctionId` of the auction to be cancelled\n    /// @param bidIndex Index of the bid to be cancelled\n    function cancelBid(uint256 auctionId, uint256 bidIndex)\n        external\n    {\n        Auction storage a = idToAuction[auctionId];\n        EncryptedBid storage b = a.bids[bidIndex];\n        if (msg.sender != b.sender) {\n            revert UnauthorizedCaller();\n        }\n\n        // Only allow bid cancellations while not finalized or in the reveal period\n        if (block.timestamp >= a.timings.endTimestamp) {\n            if (a.data.lowestQuote != type(uint128).max || block.timestamp <= a.timings.endTimestamp + 24 hours) {\n                revert InvalidState();\n            }\n        }\n\n        // Prevent any futher access to this EncryptedBid\n        b.sender = address(0);\n\n        // Prevent seller from finalizing a cancelled bid\n        b.commitment = 0;\n\n        emit BidCancelled(auctionId, bidIndex);\n\n        SafeTransferLib.safeTransfer(ERC20(a.params.quoteToken), msg.sender, b.quoteAmount);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    ///                            UTIL FUNCTIONS                            ///\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Calculates available unlocked tokens for an auction\n    /// @dev Uses vesting parameters to account for cliff & linearity\n    /// @return tokensAvailable Amount of unlocked `baseToken` at the current time\n    /// @param auctionId `auctionId` of the auction bid on\n    /// @param baseAmount Amount of total vested `baseToken`\n    function tokensAvailableForWithdrawal(uint256 auctionId, uint128 baseAmount)\n        public\n        view\n        returns (uint128 tokensAvailable)\n    {\n        Auction storage a = idToAuction[auctionId];\n        return CommonTokenMath.tokensAvailableAtTime(\n            a.timings.vestingStartTimestamp,\n            a.timings.vestingEndTimestamp,\n            uint32(block.timestamp),\n            a.timings.cliffPercent,\n            baseAmount\n        );\n    }\n\n    function computeCommitment(bytes32 message) public pure returns (bytes32) {\n        return keccak256(abi.encode(message));\n    }\n\n    function computeMessage(uint128 baseAmount, bytes16 salt) external pure returns (bytes32) {\n        return bytes32(abi.encodePacked(baseAmount, salt));\n    }\n\n    function getTimings(uint256 auctionId) external view returns (Timings memory timings) {\n        timings = idToAuction[auctionId].timings;\n    }\n\n    function getAuctionData(uint256 auctionId) external view returns (AuctionData memory data) {\n        data = idToAuction[auctionId].data;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {Merkle} from \"murky/Merkle.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ECCMath} from \"../util/ECCMath.sol\";\nimport {SizeSealed} from \"../SizeSealed.sol\";\nimport {MockBuyer} from \"./mocks/MockBuyer.sol\";\nimport {MockERC20} from \"./mocks/MockERC20.sol\";\nimport {MockSeller} from \"./mocks/MockSeller.sol\";\nimport {ISizeSealed} from \"../interfaces/ISizeSealed.sol\";\n\ncontract SizeSealedTest is Test, ISizeSealed {\n\n    SizeSealed auction;\n\n    MockSeller seller;\n    MockERC20 quoteToken;\n    MockERC20 baseToken;\n\n    MockBuyer bidder1;\n    MockBuyer bidder2;\n    MockBuyer bidder3;\n\n    // Auction parameters (cliff unlock)\n    uint32 startTime;\n    uint32 endTime;\n    uint32 unlockTime;\n    uint32 unlockEnd;\n    uint128 cliffPercent;\n\n    uint128 baseToSell;\n\n    uint256 reserveQuotePerBase = 0.5e6 * uint256(type(uint128).max) / 1e18;\n    uint128 minimumBidQuote = 1e6;\n\n    function setUp() public {\n        // Create quote and bid tokens\n        quoteToken = new MockERC20(\"USD Coin\", \"USDC\", 6);\n        baseToken = new MockERC20(\"ChainLink Token\", \"LINK\", 18);\n\n        // Init auction contract\n        auction = new SizeSealed();\n\n        // Create seller\n        seller = new MockSeller(address(auction), quoteToken, baseToken);\n\n        // Create bidders\n        bidder1 = new MockBuyer(address(auction), quoteToken, baseToken);\n        bidder2 = new MockBuyer(address(auction), quoteToken, baseToken);\n        bidder3 = new MockBuyer(address(auction), quoteToken, baseToken);\n\n        startTime = uint32(block.timestamp);\n        endTime = uint32(block.timestamp) + 60;\n        unlockTime = uint32(block.timestamp) + 100;\n        unlockEnd = uint32(block.timestamp) + 1000;\n        cliffPercent = 0;\n\n        baseToSell = 10 ether;\n\n        vm.label(address(bidder1), \"Bidder 1\");\n        vm.label(address(bidder2), \"Bidder 2\");\n        vm.label(address(bidder3), \"Bidder 3\");\n        vm.label(address(quoteToken), \"Quote Token\");\n        vm.label(address(baseToken), \"Base Token\");\n    }\n\n    // Test against vitalik's ecmul bn_128 impl\n    // https://github.com/ethereum/py_pairing/blob/master/tests/test_bn128.py\n    function testECMUL() public {\n        ECCMath.Point memory pubKey = ECCMath.publicKey(1);\n        assertEq(pubKey.x, 1);\n        assertEq(pubKey.y, 2);\n\n        // Not on curve\n        pubKey = ECCMath.publicKey(0);\n        assertEq(pubKey.x, 1);\n        assertEq(pubKey.y, 1);\n\n        pubKey = ECCMath.publicKey(10);\n        assertEq(pubKey.x, 4444740815889402603535294170722302758225367627362056425101568584910268024244);\n        assertEq(pubKey.y, 10537263096529483164618820017164668921386457028564663708352735080900270541420);\n\n        pubKey = ECCMath.publicKey(100);\n        assertEq(pubKey.x, 8464813805670834410435113564993955236359239915934467825032129101731355555480);\n        assertEq(pubKey.y, 15805858227829959406383193382434604346463310251314385567227770510519895659279);\n\n        pubKey = ECCMath.publicKey(1000);\n        assertEq(pubKey.x, 1877430218621023249938287835150142829605985124239973405386905603937246406682);\n        assertEq(pubKey.y, 5158670745399576371417749445914270010222487318683077220882364692777539249273);\n    }\n\n    function testCreateAuction() public {\n        seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n    }\n\n    function testCancelAuction() public {\n        (uint256 beforeQuote, uint256 beforeBase) = seller.balances();\n        seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        seller.cancelAuction();\n        (uint256 afterQuote, uint256 afterBase) = seller.balances();\n        assertEq(beforeBase, afterBase, \"base before cancel != base after cancel\");\n        assertEq(beforeQuote, afterQuote, \"quote before cancel != quote after cancel\");\n    }\n\n    function testCancelAuctionDuringRevealPeriod() public {\n        seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        vm.warp(endTime);\n        seller.cancelAuction();\n    }\n\n    function testCreateAuctionTimings() public {\n        // End in the past\n        vm.expectRevert(ISizeSealed.InvalidTimestamp.selector);\n        seller.createAuction(\n            baseToSell,\n            reserveQuotePerBase,\n            minimumBidQuote,\n            startTime,\n            uint32(block.timestamp - 1),\n            unlockTime,\n            unlockEnd,\n            cliffPercent\n        );\n\n        // End before start\n        vm.expectRevert(ISizeSealed.InvalidTimestamp.selector);\n        seller.createAuction(\n            baseToSell,\n            reserveQuotePerBase,\n            minimumBidQuote,\n            startTime + 2,\n            startTime + 2,\n            unlockTime,\n            unlockEnd,\n            cliffPercent\n        );\n\n        // Vesting starts before end\n        vm.expectRevert(ISizeSealed.InvalidTimestamp.selector);\n        seller.createAuction(\n            baseToSell,\n            reserveQuotePerBase,\n            minimumBidQuote,\n            startTime,\n            unlockTime + 1,\n            unlockTime,\n            unlockEnd,\n            cliffPercent\n        );\n\n        // Vesting ends before vesting starts\n        vm.expectRevert(ISizeSealed.InvalidTimestamp.selector);\n        seller.createAuction(\n            baseToSell,\n            reserveQuotePerBase,\n            minimumBidQuote,\n            startTime,\n            endTime,\n            unlockTime,\n            unlockTime - 1,\n            cliffPercent\n        );\n    }\n\n    function testCreateAuctionReserve() public {\n        // Min bid is more than reserve\n        uint256 reserve = 10e6 * uint256(type(uint128).max) / baseToSell;\n        uint128 minBid = 10e6 + 1;\n        vm.expectRevert(ISizeSealed.InvalidReserve.selector);\n        seller.createAuction(baseToSell, reserve, minBid, startTime, endTime, unlockTime, unlockEnd, cliffPercent);\n    }\n\n    function testCancelAuctionAfterFinalization() public {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        bidder1.bidOnAuctionWithSalt(1 ether, 10 ether, \"hello\");\n\n        uint256[] memory bidIndices = new uint[](1);\n        bidIndices[0] = 0;\n\n        vm.warp(endTime);\n        seller.finalize(bidIndices, 1 ether, 10 ether);\n        // Cancel should fail\n        vm.expectRevert(ISizeSealed.InvalidState.selector);\n        seller.cancelAuction();\n    }\n\n    function testAuctionFinalizeBeforeReveal() public {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        bidder1.bidOnAuctionWithSalt(1 ether, 10 ether, \"hello\");\n\n        uint256[] memory bidIndices = new uint[](1);\n        bidIndices[0] = 0;\n\n        vm.warp(endTime);\n        vm.prank(address(seller));\n        vm.expectRevert(ISizeSealed.InvalidPrivateKey.selector);\n        auction.finalize(aid, bidIndices, 1 ether, 10 ether);\n    }\n\n    /*\n    Test with a single bidder\n    Base amoount = 1 ether, quote amount = 10 ether\n    Price = 10 q per b\n    */\n    function testSingleBid() public {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        (uint256 beforeQuote, uint256 beforeBase) = bidder1.balances();\n        bidder1.bidOnAuction(1 ether, 10e6);\n        (uint256 afterQuote, uint256 afterBase) = bidder1.balances();\n        assertEq(beforeQuote, afterQuote + 10e6);\n        assertEq(beforeBase, afterBase);\n    }\n\n    function testMultipleBids() public {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        bidder2.setAuctionId(aid);\n        (uint256 beforeQuote, uint256 beforeBase) = bidder1.balances();\n        (uint256 beforeQuote2, uint256 beforeBase2) = bidder2.balances();\n        bidder1.bidOnAuction(1 ether, 10e6);\n        bidder2.bidOnAuction(1 ether, 8e6);\n        (uint256 afterQuote, uint256 afterBase) = bidder1.balances();\n        (uint256 afterQuote2, uint256 afterBase2) = bidder2.balances();\n        assertEq(beforeQuote, afterQuote + 10e6);\n        assertEq(beforeBase, afterBase);\n\n        assertEq(beforeQuote2, afterQuote2 + 8e6);\n        assertEq(beforeBase2, afterBase2);\n    }\n\n    function testFailSingleBidBeforeAuctionStart() public {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        vm.warp(startTime - 1);\n        bidder1.bidOnAuction(1 ether, 10e6);\n    }\n\n    function testBidBelowMin() public {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        vm.expectRevert(ISizeSealed.InvalidBidAmount.selector);\n        bidder1.bidOnAuction(1 ether, 0.8e6);\n    }\n\n    function cancelSetup() internal {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        bidder1.bidOnAuctionWithSalt(1 ether, 10e6, \"hello\");\n    }\n\n    function testCancelBidAfterFinalize() public {\n        cancelSetup();\n        uint256[] memory bidIndices = new uint[](1);\n        bidIndices[0] = 0;\n        vm.warp(endTime);\n        seller.finalize(bidIndices, 1 ether, 10e6);\n        \n        vm.expectRevert(ISizeSealed.InvalidState.selector);\n        bidder1.cancel();\n        \n        vm.warp(endTime + 25 hours);\n        vm.expectRevert(ISizeSealed.InvalidState.selector);\n        bidder1.cancel();\n    }\n\n    function testCancelBidDuringRevealBeforeFinalize() public {\n        cancelSetup();\n        vm.warp(endTime + 1);\n        vm.expectRevert(ISizeSealed.InvalidState.selector);\n        bidder1.cancel();\n    }\n\n    function testCancelBidDuringVoidedNoFinalize() public {\n        cancelSetup();\n        vm.warp(endTime + 25 hours);\n        bidder1.cancel();\n    }\n\n    function testCancelSingleBid() public {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        (uint256 beforeQuote, uint256 beforeBase) = bidder1.balances();\n        bidder1.bidOnAuction(1 ether, 10e6);\n        (uint256 afterQuote, uint256 afterBase) = bidder1.balances();\n        assertEq(beforeQuote, afterQuote + 10e6);\n        // Test cancel while auction is still running\n        bidder1.cancel();\n        (uint256 cancelQuote, uint256 cancelBase) = bidder1.balances();\n        assertEq(cancelQuote, beforeQuote);\n        assertEq(beforeBase, afterBase);\n        assertEq(beforeBase, cancelBase);\n    }\n\n    function testAuctionFinaliseEarly() public {\n        seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        uint256[] memory bidIndices = new uint[](2);\n        vm.expectRevert(ISizeSealed.InvalidState.selector);\n        seller.finalize(bidIndices, 0, 0);\n    }\n\n    function testAuctionFinalizePriceSort() public {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        bidder2.setAuctionId(aid);\n        bidder1.bidOnAuctionWithSalt(1 ether, 11e6, \"hello\");\n        bidder2.bidOnAuctionWithSalt(1 ether, 10e6, \"hello2\");\n\n        uint256[] memory bidIndices = new uint[](2);\n        bidIndices[0] = 1;\n        bidIndices[1] = 0;\n\n        vm.warp(endTime);\n        vm.expectRevert(ISizeSealed.InvalidSorting.selector);\n        seller.finalize(bidIndices, 1 ether, 10e6);\n    }\n\n    function testAuctionFinalizeTimeSort() public {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        bidder2.setAuctionId(aid);\n        bidder1.bidOnAuctionWithSalt(1 ether, 10e6, \"hello\");\n        bidder2.bidOnAuctionWithSalt(1 ether, 10e6, \"hello2\");\n\n        uint256[] memory bidIndices = new uint[](2);\n        bidIndices[0] = 1;\n        bidIndices[1] = 0;\n\n        vm.warp(endTime);\n        vm.expectRevert(ISizeSealed.InvalidSorting.selector);\n        seller.finalize(bidIndices, 1 ether, 10e6);\n    }\n\n    function testFinalizeAfterVoided() public {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        bidder2.setAuctionId(aid);\n        bidder1.bidOnAuctionWithSalt(1 ether, 10e6, \"hello\");\n        bidder2.bidOnAuctionWithSalt(1 ether, 11e6, \"hello2\");\n\n        uint256[] memory bidIndices = new uint[](2);\n        bidIndices[0] = 1;\n        bidIndices[1] = 0;\n\n        vm.warp(endTime + 24 hours + 1);\n        vm.expectRevert(ISizeSealed.InvalidState.selector);\n        seller.finalize(bidIndices, 1 ether, 10e6);\n    }\n\n    function testAuctionFinalizePartial() public {\n        (uint256 sellerQuoteBeforeFinalize, uint256 sellerBaseBeforeFinalize) = seller.balances();\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        bidder2.setAuctionId(aid);\n        (uint256 b1QuoteBeforeFinalize,) = bidder1.balances();\n        (uint256 b2QuoteBeforeFinalize,) = bidder2.balances();\n        bidder1.bidOnAuctionWithSalt(9 ether, 4.5e6, \"hello\");\n        bidder2.bidOnAuctionWithSalt(2 ether, 2e6, \"hello2\");\n        uint256[] memory bidIndices = new uint[](2);\n        bidIndices[0] = 1;\n        bidIndices[1] = 0;\n        vm.warp(endTime + 1);\n\n        seller.finalize(bidIndices, 9 ether, 4.5e6);\n\n        (uint256 sellerQuoteAfterFinalize, uint256 sellerBaseAfterFinalize) = seller.balances();\n        (uint256 b1QuoteAfterFinalize, uint256 b1BaseAfterFinalize) = bidder1.balances();\n        (uint256 b2QuoteAfterFinalize, uint256 b2BaseAfterFinalize) = bidder2.balances();\n\n        assertEq(sellerQuoteBeforeFinalize, sellerQuoteAfterFinalize - 5e6, \"quote gain for seller\");\n        assertEq(sellerBaseBeforeFinalize - 10 ether, sellerBaseAfterFinalize, \"base sold for seller\");\n\n        assertEq(b1QuoteBeforeFinalize - 4.5e6, b1QuoteAfterFinalize, \"quote gain for buyer\");\n        assertEq(b2QuoteBeforeFinalize - 2e6, b2QuoteAfterFinalize, \"quote gain for buyer\");\n\n        vm.warp(unlockEnd + 1);\n        bidder1.withdraw();\n        bidder2.withdraw();\n\n        (uint256 b1QuoteAfterWithdraw, uint256 b1BaseAfterWithdraw) = bidder1.balances();\n        (uint256 b2QuoteAfterWithdraw, uint256 b2BaseAfterWithdraw) = bidder2.balances();\n\n        assertEq(b1QuoteAfterFinalize + 0.5e6, b1QuoteAfterWithdraw, \"B1 Incorrect Refund\");\n        assertEq(b1BaseAfterFinalize + 8 ether, b1BaseAfterWithdraw, \"B1 Incorrect Base Withdraw\");\n        assertEq(b2QuoteAfterFinalize + 1e6, b2QuoteAfterWithdraw, \"B2 Incorrect Refund\");\n        assertEq(b2BaseAfterFinalize + 2 ether, b2BaseAfterWithdraw, \"B2 Incorrect Base Withdraw\");\n    }\n\n    function testAuctionOneBidFinalise() public {\n        (uint256 sellerBeforeQuote, uint256 sellerBeforeBase) = seller.balances();\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        (uint256 buyerBeforeQuote,) = bidder1.balances();\n        bidder1.bidOnAuctionWithSalt(1 ether, 5e6, \"hello\");\n        uint256[] memory bidIndices = new uint[](1);\n        bidIndices[0] = 0;\n        vm.warp(endTime + 1);\n        seller.finalize(bidIndices, 1 ether, 5e6);\n        (uint256 sellerAfterQuote, uint256 sellerAfterBase) = seller.balances();\n        (uint256 buyerAfterQuote,) = bidder1.balances();\n        assertEq(sellerBeforeQuote, sellerAfterQuote - 5e6, \"quote gain for seller\");\n        assertEq(sellerBeforeBase - 1 ether, sellerAfterBase, \"base sold for seller\");\n\n        assertEq(buyerBeforeQuote - 5e6, buyerAfterQuote, \"quote gain for buyer\");\n        AuctionData memory data = auction.getAuctionData(aid);\n        emit log_named_uint(\"lowestBase\", data.lowestBase);\n        emit log_named_uint(\"lowestQuote\", data.lowestQuote);\n    }\n\n    function testAuctionRevealWrongKey() external {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        bidder1.bidOnAuctionWithSalt(1 ether, 5e6, \"hello\");\n\n        uint256[] memory bidIndices = new uint[](1);\n        bidIndices[0] = 0;\n        vm.warp(endTime + 1);\n\n        vm.prank(address(seller));\n        vm.expectRevert(ISizeSealed.InvalidPrivateKey.selector);\n        auction.reveal(aid, 1, abi.encode(bidIndices, 1 ether, 5e6));\n    }\n\n    function testAuctionMultipleBidsFinalise() public {\n        (uint256 sellerBeforeQuote, uint256 sellerBeforeBase) = seller.balances();\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        bidder2.setAuctionId(aid);\n        (uint256 buyerBeforeQuote,) = bidder1.balances();\n        (uint256 buyerBeforeQuote2,) = bidder2.balances();\n        bidder1.bidOnAuctionWithSalt(1 ether, 5e6, \"hello\");\n        bidder2.bidOnAuctionWithSalt(1 ether, 6e6, \"hello2\");\n        uint256[] memory bidIndices = new uint[](2);\n        bidIndices[0] = 1;\n        bidIndices[1] = 0;\n        vm.warp(endTime + 1);\n        seller.finalize(bidIndices, 1 ether, 5e6);\n        (uint256 sellerAfterQuote, uint256 sellerAfterBase) = seller.balances();\n        (uint256 buyerAfterQuote,) = bidder1.balances();\n        (uint256 buyerAfterQuote2,) = bidder2.balances();\n        assertEq(sellerBeforeQuote, sellerAfterQuote - 5e6 - 5e6, \"quote gain for seller\");\n        assertEq(sellerBeforeBase - 1 ether - 1 ether, sellerAfterBase, \"base sold for seller\");\n\n        assertEq(buyerBeforeQuote - 5e6, buyerAfterQuote, \"quote gain for buyer\");\n        assertEq(buyerBeforeQuote2 - 6e6, buyerAfterQuote2, \"quote gain for buyer\");\n        AuctionData memory data = auction.getAuctionData(aid);\n        emit log_named_uint(\"lowestBase\", data.lowestBase);\n        emit log_named_uint(\"lowestQuote\", data.lowestQuote);\n    }\n\n    function testAuctionRefundLostBidder() public {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        bidder1.setAuctionId(aid);\n        bidder2.setAuctionId(aid);\n        bidder1.bidOnAuctionWithSalt(5 ether, 2e6, \"hello\");\n        bidder2.bidOnAuctionWithSalt(1 ether, 2e6, \"hello\");\n        uint256[] memory bidIndices = new uint[](2);\n        bidIndices[0] = 1;\n        bidIndices[1] = 0;\n        vm.warp(endTime + 1);\n        (uint256 sellerBeforeQuote, uint256 sellerBeforeBase) = seller.balances();\n        seller.finalize(bidIndices, 1 ether, 2e6);\n        (uint256 sellerAfterQuote, uint256 sellerAfterBase) = seller.balances();\n        assertEq(sellerBeforeQuote + 2e6, sellerAfterQuote, \"quote gain for seller\");\n        assertEq(sellerBeforeBase + 9 ether, sellerAfterBase, \"base refund for seller\");\n\n        // Winning bid can't refund\n        vm.expectRevert(ISizeSealed.InvalidState.selector);\n        bidder2.refund();\n        (uint256 buyerBeforeQuote,) = bidder1.balances();\n        bidder1.refund();\n        (uint256 buyerAfterQuote,) = bidder1.balances();\n        assertEq(buyerBeforeQuote + 2e6, buyerAfterQuote, \"quote refund for buyer\");\n    }\n\n    function testTokensAvailableForWithdrawal() public {\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        vm.warp(unlockTime - 1);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 100e36), 0);\n        vm.warp(unlockTime);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 100e36), 0);\n\n        vm.warp((unlockTime + unlockEnd) / 2);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 100e36), 50e36);\n\n        vm.warp(unlockEnd);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 100e36), 100e36);\n        vm.warp(unlockEnd + 1);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 100e36), 100e36);\n    }\n\n    function test50CliffAndLinearWithdrawal() public {\n        cliffPercent = 0.5e18;\n        uint256 aid = seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, cliffPercent\n        );\n        vm.warp(unlockTime - 1);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 1e36), 0);\n        vm.warp(unlockTime);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 100e36), 0);\n\n        vm.warp(unlockTime + 1);\n        uint256 singleSecondVesting = 50e36 / (unlockEnd - unlockTime);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 100e36), 50e36 + singleSecondVesting);\n\n        vm.warp((unlockTime + unlockEnd) / 2);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 100e36), 75e36);\n\n        vm.warp(unlockEnd);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 100e36), 100e36);\n        vm.warp(unlockEnd + 1);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 100e36), 100e36);\n    }\n\n    function test100CliffWithdrawal() public {\n        uint32 unlockCliffStart = uint32(block.timestamp + 100);\n        uint32 unlockCliffEnd = unlockCliffStart;\n        uint256 aid = seller.createAuction(\n            baseToSell,\n            reserveQuotePerBase,\n            minimumBidQuote,\n            startTime,\n            endTime,\n            unlockCliffStart,\n            unlockCliffEnd,\n            0.98e18\n        );\n        vm.warp(unlockCliffStart);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 100), 0);\n        vm.warp(unlockCliffStart + 1);\n        assertEq(auction.tokensAvailableForWithdrawal(aid, 100), 100);\n    }\n\n    function testSingleWhitelistBid() public {\n        Merkle m = new Merkle();\n        bytes32[] memory data = new bytes32[](2);\n        data[0] = keccak256(abi.encodePacked(address(bidder1)));\n        data[1] = keccak256(abi.encodePacked(address(bidder2)));\n\n        // Use murky library to generate merkleRoot & proof for bidder1\n        bytes32 root = m.getRoot(data);\n        bytes32[] memory proof1 = m.getProof(data, 0);\n        bytes32[] memory proof2 = m.getProof(data, 1);\n\n        uint256 aid = seller.createAuctionWhitelist(\n            baseToSell,\n            reserveQuotePerBase,\n            minimumBidQuote,\n            startTime,\n            endTime,\n            unlockTime,\n            unlockEnd,\n            cliffPercent,\n            root\n        );\n        bidder1.setAuctionId(aid);\n        bidder1.bidOnWhitelistAuctionWithSalt(1 ether, 2e6, \"hello\", proof1);\n        bidder2.setAuctionId(aid);\n        bidder2.bidOnWhitelistAuctionWithSalt(1 ether, 3e6, \"hello2\", proof2);\n        bidder3.setAuctionId(aid);\n        vm.expectRevert(ISizeSealed.InvalidProof.selector);\n        bidder3.bidOnWhitelistAuctionWithSalt(1 ether, 3e6, \"hello3\", proof2);\n    }\n\n    function testInvalidTimestamps() public {\n        // Test 101% cliff\n        vm.expectRevert(ISizeSealed.InvalidCliffPercent.selector);\n        seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockTime, unlockEnd, 1.01e18\n        );\n\n        // Test vestingTimings swapped with auctionTimings\n        vm.expectRevert(ISizeSealed.InvalidTimestamp.selector);\n        seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, unlockTime, unlockEnd, startTime, endTime, 0.5e18\n        );\n\n        // Test unlock period larger than auction period\n        vm.expectRevert(ISizeSealed.InvalidTimestamp.selector);\n        uint32 future = uint32(block.timestamp + 1000000);\n        seller.createAuction(baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, 0, future, 0.5e18);\n\n        // Test startAuction and endAuction being swapped\n        vm.expectRevert(ISizeSealed.InvalidTimestamp.selector);\n        seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, endTime, startTime, unlockTime, unlockEnd, cliffPercent\n        );\n\n        // Test startVest swapped with vestingEnd\n        vm.expectRevert(ISizeSealed.InvalidTimestamp.selector);\n        seller.createAuction(\n            baseToSell, reserveQuotePerBase, minimumBidQuote, startTime, endTime, unlockEnd, unlockTime, cliffPercent\n        );\n    }\n\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\n        uint256 tempUint;\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), 0))\n        }\n        return tempUint;\n    }\n}\n\n\n",
        "CodeNames": [
            "SizeSealed.sol",
            "SizeSealed.t.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Transferring base tokens and quote tokens in the SizeSealed contract",
                "Type": "Incompatibility with fee-on-transfer/inflationary/deflationary/rebasing tokens",
                "Description": "The contract cannot handle fee-on-transfer base tokens and incorrectly handles unusual ERC20 tokens in general, resulting in fund loss and denial-of-service.",
                "Repair": "Consider using two parameters for transferring base tokens, adding a check for quoteAmount to be correctly transferred, or check the actual amount transferred in the contract instead of using the function parameter"
            },
            {
                "Location": "Transferring quote tokens in the SizeSealed contract using Solmate's SafeTransferLib",
                "Type": "Failure to check token contract's existence",
                "Description": "The contract does not check for token contract's existence, which opens up possibility for a honeypot attack.",
                "Repair": "Consider using OpenZeppelin's SafeERC20 instead, which has checks that an address does indeed have a contract"
            },
            {
                "Location": "finalize() function in SizeSealed.sol contract",
                "Type": "state confusion",
                "Description": "Attacker can steal any funds in the contract by state confusion (no preconditions).",
                "Repair": "Do not trust the value of lowestQuote when determining the finalize state, use a dedicated state variable for it."
            },
            {
                "Location": "finalize function in the SizeSealed smart contract",
                "Type": "Denial of Service",
                "Description": "A malicious user may encrypt the message with baseAmount == 0, then the auction is impossible to finalize. Any user can make a griffering attack to invalidate the auction.",
                "Repair": "Add a special check to the finalize function to prevent errors in cases when baseAmount is equal to zero"
            },
            {
                "Location": "withdraw function in the SizeSealed smart contract",
                "Type": "Insufficient Balance",
                "Description": "Bidders might fail to withdraw their unused funds after the auction was finalized because the contract doesn't have enough balance. The last bidder will fail to withdraw his funds because the contract doesn't have enough balance of quote token.",
                "Repair": "Add a new field filledQuote to the FinalizeData struct and update it during auction finalization. Each bidder can pay the filledQuote of quote token and receive the filledBase of base token without calculating again using the clearing price. The seller can receive the sum of filledQuote of all bidders to avoid the rounding issue."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "createAuction function",
                "Type": "Re-entrancy",
                "Description": "The createAuction function lacks the check of re-entrancy. An attacker can use an ERC777 token with tax as the base token to create auctions. By registering ERC777TokensSender interface implementer in the ERC1820Registry contract, the attacker can re-enter the createAuction function and create more than one auction with less token. And the sum of the totalBaseAmount of these auctions will be greater than the token amount received by the SizeSealed contract. Finally, the attacker can take more money from the contract global pool which means stealing tokens from the other auctions and treasury.",
                "Repair": "Implement a check for re-entrancy in the createAuction function"
            },
            {
                "Location": "bid() function",
                "Type": "Seller's ability to decrypt bids before reveal",
                "Description": "Seller's ability to decrypt bids before reveal could result in a much higher clearing price than anticipated and make buyers distrust the system.",
                "Repair": "Introduce a 2 step reveal where the bidders also encrypt their bid with their own private key and only reveal their key after the seller has revealed theirs. This could be mitigated by bidders losing (part of) their quote tokens when not revealing their bids."
            },
            {
                "Location": "finalize loop",
                "Type": "DOS auctions using invalid bid parameters",
                "Description": "Attacker may DOS auctions using invalid bid parameters.",
                "Repair": "Implement a slashing mechanism. If the bid cannot be executed due to user's fault, some % their submitted quote tokens will go to the protocol and auction creator."
            },
            {
                "Location": "seller.finalize() function",
                "Type": "Sorting Logic Vulnerability",
                "Description": "The sorting logic used in the finalize function is not strict enough, which can result in the seller receiving fewer quote tokens than desired. This can be demonstrated by a test case. The suggested repair method is to modify the comparison method to be strict by multiplying quote and base amounts.",
                "Repair": "Modify the comparison method to be strict by multiplying quote and base amounts"
            }
        ]
    }
]