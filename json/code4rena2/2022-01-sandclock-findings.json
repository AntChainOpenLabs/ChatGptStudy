[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "functions claimYield, _withdraw, and _unsponsor",
                "Type": "Check for empty address",
                "Description": "Prevent accidental burns by validating that _to is not an empty 0x0 address.",
                "Repair": "Implement the proposed validation: require _to != address(0)"
            },
            {
                "Location": "Strategy contracts",
                "Type": "Incompatibility with rebasing/deflationary/inflationary tokens",
                "Description": "The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.",
                "Repair": "Add support in contracts for such tokens before accepting user-supplied tokens"
            },
            {
                "Location": "Strategy, Vault, and Factory contracts",
                "Type": "Single malicious trusted account takeover",
                "Description": "If any single account has its private keys compromised or decides to become malicious on their own, they can remove all other trusted accounts from the isTrusted mapping.",
                "Repair": "Utilize Rari Capital's updated Auth.sol contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"./curve/ICurve.sol\";\nimport \"./BaseStrategy.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * Strategy that handles non-UST tokens, by first converting them to UST via\n * Curve (https://curve.fi/), and only then depositing into EthAnchor\n */\ncontract NonUSTStrategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n\n    // address of the Curve pool to use\n    ICurve public curvePool;\n\n    // index of the underlying token in the pool\n    int128 public underlyingI;\n\n    // index of the UST token in the pool\n    int128 public ustI;\n\n    constructor(\n        address _vault,\n        address _treasury,\n        address _ethAnchorRouter,\n        address _exchangeRateFeeder,\n        IERC20 _ustToken,\n        IERC20 _aUstToken,\n        uint16 _perfFeePct,\n        address _owner,\n        address _curvePool,\n        int128 _underlyingI,\n        int128 _ustI\n    )\n        BaseStrategy(\n            _vault,\n            _treasury,\n            _ethAnchorRouter,\n            _exchangeRateFeeder,\n            _ustToken,\n            _aUstToken,\n            _perfFeePct,\n            _owner\n        )\n    {\n        require(underlying != _ustToken, \"invalid underlying\");\n        require(_curvePool != address(0), \"0x addr\");\n        curvePool = ICurve(_curvePool);\n        underlyingI = _underlyingI;\n        ustI = _ustI;\n\n        ustToken.safeApprove(_curvePool, type(uint256).max);\n        underlying.safeApprove(_curvePool, type(uint256).max);\n    }\n\n    /**\n     * Swaps the underlying currency for UST, and initiates a deposit of all\n     * the converted UST into EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the deposit process, but does not finish it.\n     */\n    function doHardWork() external override(BaseStrategy) restricted {\n        _swapUnderlyingToUst();\n        _initDepositStable();\n    }\n\n    /**\n     * Calls Curve to convert the existing underlying balance into UST\n     */\n    function _swapUnderlyingToUst() internal {\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        if (underlyingBalance > 0) {\n            // slither-disable-next-line unused-return\n            curvePool.exchange_underlying(\n                underlyingI,\n                ustI,\n                underlyingBalance,\n                0\n            );\n        }\n    }\n\n    /**\n     * Calls Curve to convert the existing UST back into the underlying token\n     */\n    function _swapUstToUnderlying() internal {\n        uint256 ustBalance = _getUstBalance();\n        if (ustBalance > 0) {\n            // slither-disable-next-line unused-return\n            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);\n        }\n    }\n\n    /**\n     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.\n     * Once UST is retrieved, convert it back to underlying via Curve\n     *\n     * @notice Must be called some time after `initRedeemStable()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending redeem operation\n     */\n    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {\n        super.finishRedeemStable(idx);\n        _swapUstToUnderlying();\n    }\n\n    /**\n     * Amount, expressed in the underlying currency, currently in the strategy\n     *\n     * @notice both held and invested amounts are included here, using the\n     * latest known exchange rates to the underlying currency\n     *\n     * @return The total amount of underlying\n     */\n    function investedAssets()\n        external\n        view\n        override(BaseStrategy)\n        returns (uint256)\n    {\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(\n            address(aUstToken),\n            true\n        ) * aUstBalance) / 1e18) + pendingDeposits;\n        return\n            underlyingBalance +\n            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);\n    }\n}\n\n\n",
        "CodeNames": [
            "NonUSTStrategy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "NonUSTStrategy contract",
                "Type": "Flash loan attack",
                "Description": "The NonUSTStrategy is vulnerable to attacks by flash loans on curve pools.",
                "Repair": "Use an oracle"
            },
            {
                "Location": "NonUSTStrategy.sol",
                "Type": "Improper handling of swap fees",
                "Description": "NonUSTStrategy.sol improperly handles swap fees, allowing an attacker to steal funds from other users.",
                "Repair": "Change the way new shares are issued: 1. Swap from Vault asset (eg. FRAX) to UST in deposit(); 2. Using the UST amount out / total underlying UST for the amount of new shares issued to the depositor. In essence, the depositor should be paying for the swap fee and slippage."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Trust} from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\nimport {IVault} from \"./vault/IVault.sol\";\nimport {IVaultSponsoring} from \"./vault/IVaultSponsoring.sol\";\nimport {PercentMath} from \"./lib/PercentMath.sol\";\nimport {Depositors} from \"./vault/Depositors.sol\";\nimport {Claimers} from \"./vault/Claimers.sol\";\nimport {IIntegration} from \"./integrations/IIntegration.sol\";\nimport {IStrategy} from \"./strategy/IStrategy.sol\";\nimport {ERC165Query} from \"./lib/ERC165Query.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * A vault where other accounts can deposit an underlying token\n * currency and set distribution params for their principal and yield\n *\n * @dev Yield generation strategies not yet implemented\n */\n\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n\n    //\n    // Constants\n    //\n\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n\n    //\n    // State\n    //\n\n    /// Underlying ERC20 token accepted by the vault\n    /// See {IVault}\n    IERC20 public override(IVault) underlying;\n\n    /// See {IVault}\n    IStrategy public strategy;\n\n    /// See {IVault}\n    uint256 public investPerc;\n\n    /// See {IVault}\n    uint256 public immutable override(IVault) minLockPeriod;\n\n    /// See {IVaultSponsoring}\n    uint256 public override(IVaultSponsoring) totalSponsored;\n\n    /// Depositors, represented as an NFT per deposit\n    Depositors public depositors;\n\n    /// Yield allocation\n    Claimers public claimers;\n\n    /// Unique IDs to correlate donations that belong to the same foundation\n    Counters.Counter private _depositGroupIds;\n\n    /**\n     * @param _underlying Underlying ERC20 token to use.\n     */\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n\n    //\n    // IVault\n    //\n\n    /// See {IVault}\n    function setStrategy(address _strategy)\n        external\n        override(IVault)\n        requiresTrust\n    {\n        require(_strategy != address(0), \"Vault: strategy 0x\");\n        require(\n            IStrategy(_strategy).vault() == address(this),\n            \"Vault: invalid vault\"\n        );\n        require(\n            address(strategy) == address(0) || strategy.investedAssets() == 0,\n            \"Vault: strategy has invested funds\"\n        );\n\n        strategy = IStrategy(_strategy);\n    }\n\n    /// See {IVault}\n    function totalUnderlying() public view override(IVault) returns (uint256) {\n        if (address(strategy) != address(0)) {\n            return\n                underlying.balanceOf(address(this)) + strategy.investedAssets();\n        } else {\n            return underlying.balanceOf(address(this));\n        }\n    }\n\n    /// See {IVault}\n    function totalShares() public view override(IVault) returns (uint256) {\n        return claimers.totalShares();\n    }\n\n    /// See {IVault}\n    function yieldFor(address _to)\n        public\n        view\n        override(IVault)\n        returns (uint256)\n    {\n        uint256 tokenId = claimers.addressToTokenID(_to);\n        uint256 claimerPrincipal = claimers.principalOf(tokenId);\n        uint256 claimerShares = claimers.sharesOf(tokenId);\n        uint256 currentClaimerPrincipal = _computeAmount(\n            claimerShares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        if (currentClaimerPrincipal <= claimerPrincipal) {\n            return 0;\n        }\n\n        return currentClaimerPrincipal - claimerPrincipal;\n    }\n\n    /// See {IVault}\n    function deposit(DepositParams calldata _params) external {\n        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n        _transferAndCheckUnderlying(_msgSender(), _params.amount);\n    }\n\n    /// See {IVault}\n    function claimYield(address _to) external override(IVault) {\n        uint256 yield = yieldFor(_msgSender());\n\n        if (yield == 0) return;\n\n        uint256 shares = _computeShares(\n            yield,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n        uint256 sharesAmount = _computeAmount(\n            shares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);\n\n        underlying.safeTransfer(_to, sharesAmount);\n    }\n\n    /// See {IVault}\n    function withdraw(address _to, uint256[] memory _ids)\n        external\n        override(IVault)\n    {\n        _withdraw(_to, _ids, false);\n    }\n\n    /// See {IVault}\n    function forceWithdraw(address _to, uint256[] memory _ids) external {\n        _withdraw(_to, _ids, true);\n    }\n\n    /// See {IVault}\n    function setInvestPerc(uint16 _investPerc) external requiresTrust {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n\n        emit InvestPercentageUpdated(_investPerc);\n\n        investPerc = _investPerc;\n    }\n\n    /// See {IVault}\n    function investableAmount() public view returns (uint256) {\n        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);\n\n        uint256 alreadyInvested = strategy.investedAssets();\n\n        if (alreadyInvested >= maxInvestableAssets) {\n            return 0;\n        } else {\n            return maxInvestableAssets - alreadyInvested;\n        }\n    }\n\n    /// See {IVault}\n    function updateInvested() external requiresTrust {\n        require(address(strategy) != address(0), \"Vault: strategy is not set\");\n\n        uint256 _investable = investableAmount();\n\n        if (_investable > 0) {\n            underlying.safeTransfer(address(strategy), _investable);\n\n            emit Invested(_investable);\n        }\n\n        strategy.doHardWork();\n    }\n\n    //\n    // IVaultSponsoring\n\n    /// See {IVaultSponsoring}\n    function sponsor(uint256 _amount, uint256 _lockedUntil)\n        external\n        override(IVaultSponsoring)\n    {\n        if (_lockedUntil == 0)\n            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n        else\n            require(\n                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            _amount,\n            0,\n            _lockedUntil\n        );\n\n        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n        totalSponsored += _amount;\n        _transferAndCheckUnderlying(_msgSender(), _amount);\n    }\n\n    /// See {IVaultSponsoring}\n    function unsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, false);\n    }\n\n    /// See {IVaultSponsoring}\n    function forceUnsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, true);\n    }\n\n    //\n    // Public API\n    //\n\n    /**\n     * Computes the total amount of principal + yield currently controlled by the\n     * vault and the strategy. The principal + yield is the total amount\n     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.\n     *\n     * @return Total amount of principal and yield help by the vault (not including sponsored amount).\n     */\n    function totalUnderlyingMinusSponsored() public view returns (uint256) {\n        // TODO no invested amount yet\n        return totalUnderlying() - totalSponsored;\n    }\n\n    //\n    // ERC165\n    //\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IVault).interfaceId ||\n            interfaceId == type(IVaultSponsoring).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    //\n    // Internal API\n    //\n\n    /**\n     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _withdraw(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();\n        uint256 amount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            amount += _withdrawDeposit(\n                _ids[i],\n                localTotalShares,\n                localTotalPrincipal,\n                _to,\n                _force\n            );\n        }\n\n        underlying.safeTransfer(_to, amount);\n    }\n\n    /**\n     * Withdraws the sponsored amount for the deposits with the ids provided\n     * in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _unsponsor(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 sponsorAmount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            uint256 tokenId = _ids[i];\n\n            require(\n                depositors.ownerOf(tokenId) == _msgSender(),\n                \"Vault: you are not the owner of a sponsor\"\n            );\n\n            (\n                uint256 depositAmount,\n                uint256 claimerId,\n                uint256 lockedUntil\n            ) = depositors.deposits(tokenId);\n            require(lockedUntil <= block.timestamp, \"Vault: amount is locked\");\n\n            require(claimerId == 0, \"Vault: token id is not a sponsor\");\n\n            depositors.burn(tokenId);\n\n            emit Unsponsored(tokenId);\n\n            sponsorAmount += depositAmount;\n        }\n\n        uint256 sponsorToTransfer = sponsorAmount;\n\n        if (_force && sponsorAmount > totalUnderlying()) {\n            sponsorToTransfer = totalUnderlying();\n        } else if (!_force) {\n            require(\n                sponsorToTransfer <= totalUnderlying(),\n                \"Vault: not enough funds to unsponsor\"\n            );\n        }\n\n        totalSponsored -= sponsorAmount;\n\n        underlying.safeTransfer(_to, sponsorToTransfer);\n    }\n\n    /**\n     * Creates a deposit with the given amount of underlying and claim\n     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.\n     * @notice This function assumes underlying will be transfered elsewhere in\n     * the transaction.\n     *\n     * @notice Underlying must be transfered *after* this function, in order to\n     * correctly calculate shares.\n     *\n     * @notice claims must add up to 100%.\n     *\n     * @param _amount Amount of underlying to consider @param claims claim\n     * @param _lockedUntil When the depositor can unsponsor the amount.\n     * @param claims Claim params\n     * params.\n     */\n    function _createDeposit(\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams[] calldata claims\n    ) internal {\n        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;\n        else\n            require(\n                _lockedUntil >= block.timestamp + minLockPeriod,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();\n        uint256 pct = 0;\n\n        for (uint256 i = 0; i < claims.length; ++i) {\n            ClaimParams memory data = claims[i];\n            _createClaim(\n                _depositGroupIds.current(),\n                _amount,\n                _lockedUntil,\n                data,\n                localTotalShares,\n                localTotalUnderlying\n            );\n            pct += data.pct;\n        }\n\n        _depositGroupIds.increment();\n\n        require(pct.is100Perc(), \"Vault: claims don't add up to 100%\");\n    }\n\n    function _createClaim(\n        uint256 _depositGroupId,\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams memory _claim,\n        uint256 _localTotalShares,\n        uint256 _localTotalPrincipal\n    ) internal {\n        uint256 amount = _amount.percOf(_claim.pct);\n\n        uint256 newShares = _computeShares(\n            amount,\n            _localTotalShares,\n            _localTotalPrincipal\n        );\n\n        uint256 claimerId = claimers.mint(\n            _claim.beneficiary,\n            amount,\n            newShares\n        );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            amount,\n            claimerId,\n            _lockedUntil\n        );\n\n        if (_isIntegration(_claim.beneficiary)) {\n            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(\n                tokenId,\n                newShares,\n                _claim.data\n            );\n\n            require(\n                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector\n            );\n        }\n\n        emit DepositMinted(\n            tokenId,\n            _depositGroupId,\n            amount,\n            newShares,\n            _msgSender(),\n            _claim.beneficiary,\n            claimerId,\n            _lockedUntil\n        );\n    }\n\n    /**\n     * Burns a deposit NFT and reduces the principal and shares of the claimer.\n     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.\n     *\n     * @notice This function doesn't transfer any funds, it only updates the state.\n     *\n     * @notice Only the owner of the deposit may call this function.\n     *\n     * @param _tokenId The deposit ID to withdraw from.\n     * @param _totalShares The total shares to consider for the withdraw.\n     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.\n     *\n     * @return the amount to withdraw.\n     */\n    function _withdrawDeposit(\n        uint256 _tokenId,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored,\n        address _to,\n        bool _force\n    ) internal returns (uint256) {\n        require(\n            depositors.ownerOf(_tokenId) == _msgSender(),\n            \"Vault: you are not the owner of a deposit\"\n        );\n\n        (\n            uint256 depositAmount,\n            uint256 claimerId,\n            uint256 lockedUntil\n        ) = depositors.deposits(_tokenId);\n        require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n        require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n        uint256 claimerShares = claimers.sharesOf(claimerId);\n\n        uint256 depositShares = _computeShares(\n            depositAmount,\n            _totalShares,\n            _totalUnderlyingMinusSponsored\n        );\n\n        if (_force && depositShares > claimerShares) {\n            depositShares = claimerShares;\n        } else if (!_force) {\n            require(\n                claimerShares >= depositShares,\n                \"Vault: cannot withdraw more than the available amount\"\n            );\n        }\n\n        claimers.onWithdraw(claimerId, depositAmount, depositShares);\n        depositors.burn(_tokenId);\n\n        address claimer = claimers.ownerOf(claimerId);\n\n        if (_isIntegration(claimer)) {\n            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\n\n            require(ret == IIntegration(claimer).onDepositBurned.selector);\n        }\n\n        emit DepositBurned(_tokenId, depositShares, _to);\n\n        return\n            _computeAmount(\n                depositShares,\n                _totalShares,\n                _totalUnderlyingMinusSponsored\n            );\n    }\n\n    function _transferAndCheckUnderlying(address _from, uint256 _amount)\n        internal\n    {\n        uint256 balanceBefore = totalUnderlying();\n        underlying.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = totalUnderlying();\n\n        require(\n            balanceAfter == balanceBefore + _amount,\n            \"Vault: amount received does not match params\"\n        );\n    }\n\n    function _blockTimestamp() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    /**\n     * Computes amount of shares that will be received for a given deposit amount\n     *\n     * @param _amount Amount of deposit to consider.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount of shares the deposit will receive.\n     */\n    function _computeShares(\n        uint256 _amount,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_amount == 0) return 0;\n        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;\n\n        require(\n            _totalUnderlyingMinusSponsored > 0,\n            \"Vault: cannot compute shares when there's no principal\"\n        );\n\n        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;\n    }\n\n    /**\n     * Computes the amount of underlying from a given number of shares\n     *\n     * @param _shares Number of shares.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount that corresponds to the number of shares.\n     */\n    function _computeAmount(\n        uint256 _shares,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {\n            return 0;\n        } else {\n            // TODO exclude sponsored assets\n            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);\n        }\n    }\n\n    /**\n     * Checks if the given address is a contract implementing IIntegration\n     *\n     * @param addr Address to check\n     * @return true if contract is an IIntegraiont\n     */\n    function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Vault.sol contract",
                "Type": "No use of safeMint()",
                "Description": "Calling mint this way does not ensure that the receiver of the NFT is able to accept them.",
                "Repair": "Use _safeMint() instead of mint()"
            },
            {
                "Location": "Vault.sol contract",
                "Type": "Vault can't receive deposits",
                "Description": "If the underlying token of a vault charges a fee for every transfer, any deposit to the protocol will fail.",
                "Repair": "Simply not use ERC20 tokens with fees"
            },
            {
                "Location": "sponsor() function in Vault.sol",
                "Type": "Reentrancy Attack",
                "Description": "The sponsor() function does not have a reentrancy guard allowing an attacker to reenter the function because the depositors.mint() function has as callback to the msg.sender.",
                "Repair": "Add a reentrancy guard modifier to the sponsor() function"
            },
            {
                "Location": "withdrawers can get more value returned than expected with reentrant call in Vault.sol",
                "Type": "Reentrancy Attack",
                "Description": "The impact of this is that users can get significantly more UST withdrawn than they would be allotted if they had done non-reentrant withdraw calls.",
                "Repair": "Add reentrancy guard modifiers to the deposit(), withdraw() and all other important protocol functions"
            },
            {
                "Location": "setStrategy() function in Vault.sol",
                "Type": "Griefing Attack",
                "Description": "A vault wouldn't let the strategy be changed unless the strategy holds no funds.",
                "Repair": "Keep an internal aUST balance of the strategy and use it to check if the strategy holds no aUST funds or add capability for the strategy to send the aUST to the vault"
            },
            {
                "Location": "deposit(), withdraw(), claimYield() and unsponsor() functions in Vault.sol",
                "Type": "Insufficient Balance Check",
                "Description": "totalUnderlying() includes the invested assets, they are not in the contract balance.",
                "Repair": "Withdraw from the strategy when the system doesn't have enough balance to make the transfer"
            },
            {
                "Location": "deposit() function in Vault.sol",
                "Type": "Reentrancy Attack",
                "Description": "The deposit() function is left wide open to reentrancy attacks.",
                "Repair": "Add reentrancy guard modifiers to the deposit(), withdraw() and all other important protocol functions"
            },
            {
                "Location": "Vault.sol",
                "Type": "Flash loan attack",
                "Description": "Vault.sol is susceptible to flash loan attacks due to a zero _minLockPeriod and the manipulability of the spot price of the pool.",
                "Repair": "Ensure that _minLockPeriod is non-zero in the constructor. Also, consider an alternative price feed."
            },
            {
                "Location": "forceUnsponsor() function in Vault.sol",
                "Type": "Manipulation of totalShares",
                "Description": "forceUnsponsor() function in Vault.sol may open a window for attackers to manipulate the _totalShares and freeze users' funds at a certain deposit amount.",
                "Repair": "Consider adding a minimum balance reserve (eg. 1e18 Wei) that cannot be withdrawn by anyone in any case. It can be transferred in alongside with the deployment by the deployer."
            },
            {
                "Location": "Vault.sol",
                "Type": "Smart Contract Logic",
                "Description": "Late users will take more losses than expected when the underlying contract (EthAnchor) suffers investment losses.",
                "Repair": "Add a new storage variable called totalLoss to maintain a stable value of share / adjustedUnderlying."
            },
            {
                "Location": "Vault.sol",
                "Type": "Smart Contract Logic",
                "Description": "totalUnderlyingMinusSponsored() function may revert on underflow and malfunction the contract.",
                "Repair": "Check whether the sponsor amount is greater than the total underlying amount before calculating totalUnderlyingMinusSponsored() to prevent underflow."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Trust} from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\nimport \"../lib/PercentMath.sol\";\nimport \"../vault/IVault.sol\";\nimport \"./IStrategy.sol\";\nimport \"./anchor/IEthAnchorRouter.sol\";\nimport \"./anchor/IExchangeRateFeeder.sol\";\n\n// import \"./Controllable.sol\";\n\n/**\n * Base strategy that handles UST tokens and invests them via the EthAnchor\n * protocol (https://docs.anchorprotocol.com/ethanchor/ethanchor)\n */\nabstract contract BaseStrategy is IStrategy, Trust {\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n\n    event PerfFeeClaimed(uint256 amount);\n    event PerfFeePctUpdated(uint256 pct);\n\n    struct Operation {\n        address operator;\n        uint256 amount;\n    }\n\n    IERC20 public override(IStrategy) underlying;\n    // Vault address\n    address public override(IStrategy) vault;\n\n    // address of the treasury\n    address public treasury;\n\n    // address for the UST token\n    IERC20 public ustToken;\n\n    // address for the aUST token (wrapped Anchor UST, received to accrue interest for an Anchor deposit)\n    IERC20 public aUstToken;\n\n    // performance fee taken by the treasury on profits\n    uint16 public perfFeePct;\n\n    // external contract to interact with EthAnchor\n    IEthAnchorRouter public ethAnchorRouter;\n\n    // external exchange rate provider\n    IExchangeRateFeeder public exchangeRateFeeder;\n\n    // amount currently pending in deposits to EthAnchor\n    uint256 public pendingDeposits;\n\n    // amount currently pending redeemption from EthAnchor\n    uint256 public pendingRedeems;\n\n    // deposit operations history\n    Operation[] public depositOperations;\n\n    // redeem operations history\n    Operation[] public redeemOperations;\n\n    // amount of UST converted (used to calculate yield)\n    uint256 public convertedUst;\n\n    // restructs a function to be called only by the vault or governance\n    modifier restricted() {\n        require(msg.sender == vault || isTrusted[msg.sender], \"restricted\");\n\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == vault, \"only vault\");\n\n        _;\n    }\n\n    constructor(\n        address _vault,\n        address _treasury,\n        address _ethAnchorRouter,\n        address _exchangeRateFeeder,\n        IERC20 _ustToken,\n        IERC20 _aUstToken,\n        uint16 _perfFeePct,\n        address _owner\n    ) Trust(_owner) {\n        require(_ethAnchorRouter != address(0), \"0x addr\");\n        require(_exchangeRateFeeder != address(0), \"0x addr\");\n        require(address(_ustToken) != address(0), \"0x addr\");\n        require(address(_aUstToken) != address(0), \"0x addr\");\n        require(PercentMath.validPerc(_perfFeePct), \"invalid pct\");\n\n        treasury = _treasury;\n        vault = _vault;\n        underlying = IVault(_vault).underlying();\n        ethAnchorRouter = IEthAnchorRouter(_ethAnchorRouter);\n        exchangeRateFeeder = IExchangeRateFeeder(_exchangeRateFeeder);\n        ustToken = _ustToken;\n        aUstToken = _aUstToken;\n        perfFeePct = _perfFeePct;\n\n        // pre-approve EthAnchor router to transact all UST and aUST\n        ustToken.safeApprove(_ethAnchorRouter, type(uint256).max);\n        aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max);\n    }\n\n    /**\n     * Initiates a deposit of all the currently held UST into EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the deposit process, but does not finish it.\n     */\n    function doHardWork() external virtual override(IStrategy) restricted {\n        _initDepositStable();\n    }\n\n    function _initDepositStable() internal {\n        uint256 ustBalance = _getUstBalance();\n        require(ustBalance > 0, \"balance 0\");\n        pendingDeposits += ustBalance;\n        address _operator = ethAnchorRouter.initDepositStable(ustBalance);\n        depositOperations.push(\n            Operation({operator: _operator, amount: ustBalance})\n        );\n    }\n\n    /**\n     * Calls EthAnchor with a pending deposit ID, and attempts to finish it.\n     *\n     * @notice Must be called some time after `doHardWork()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending deposit operation\n     */\n    function finishDepositStable(uint256 idx) external {\n        require(depositOperations.length > idx, \"not running\");\n        Operation storage operation = depositOperations[idx];\n        ethAnchorRouter.finishDepositStable(operation.operator);\n\n        pendingDeposits -= operation.amount;\n        convertedUst += operation.amount;\n\n        operation.operator = depositOperations[depositOperations.length - 1]\n            .operator;\n        operation.amount = depositOperations[depositOperations.length - 1]\n            .amount;\n        depositOperations.pop();\n    }\n\n    /**\n     * Initiates a withdrawal of UST from EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the redeem process, but does not finish it.\n     *\n     * @param amount Amount of aUST to redeem\n     */\n    function initRedeemStable(uint256 amount) public restricted {\n        uint256 aUstBalance = _getAUstBalance();\n        require(amount > 0, \"amount 0\");\n        require(aUstBalance >= amount, \"insufficient\");\n        pendingRedeems += amount;\n        address _operator = ethAnchorRouter.initRedeemStable(amount);\n        redeemOperations.push(Operation({operator: _operator, amount: amount}));\n    }\n\n    /**\n     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.\n     *\n     * @notice Must be called some time after `initRedeemStable()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending redeem operation\n     */\n    function finishRedeemStable(uint256 idx) public virtual {\n        require(redeemOperations.length > idx, \"not running\");\n        Operation storage operation = redeemOperations[idx];\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n        uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;\n        uint256 ustBalanceBefore = _getUstBalance();\n\n        ethAnchorRouter.finishRedeemStable(operation.operator);\n\n        uint256 redeemedAmount = _getUstBalance() - ustBalanceBefore;\n        uint256 perfFee = redeemedAmount > originalUst\n            ? (redeemedAmount - originalUst).percOf(perfFeePct)\n            : 0;\n        if (perfFee > 0) {\n            ustToken.safeTransfer(treasury, perfFee);\n            emit PerfFeeClaimed(perfFee);\n        }\n        convertedUst -= originalUst;\n        pendingRedeems -= operation.amount;\n\n        operation.operator = redeemOperations[redeemOperations.length - 1]\n            .operator;\n        operation.amount = redeemOperations[redeemOperations.length - 1].amount;\n        redeemOperations.pop();\n    }\n\n    /**\n     * Withdraws the entire amount back to the vault\n     *\n     * @notice since some of the amount may be deposited into EthAnchor, this\n     * call may not withdraw all the funds right away. It will start a redeem\n     * process on EthAnchor, but this function must be called again a second\n     * time once that is finished.\n     */\n    function withdrawAllToVault() external override(IStrategy) restricted {\n        uint256 aUstBalance = _getAUstBalance();\n        if (aUstBalance > 0) {\n            initRedeemStable(aUstBalance);\n        }\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        if (underlyingBalance > 0) {\n            underlying.safeTransfer(vault, underlyingBalance);\n        }\n    }\n\n    /**\n     * Withdraws a specified amount back to the vault\n     *\n     * @notice Unlike `withdrawToVault`, this function only considers the\n     * amount currently not invested, but only what is currently held by the\n     * strategy\n     *\n     * @param amount Amount to withdraw\n     */\n    function withdrawToVault(uint256 amount)\n        external\n        override(IStrategy)\n        restricted\n    {\n        underlying.safeTransfer(vault, amount);\n    }\n\n    /**\n     * Updates the performance fee\n     *\n     * @notice Can only be called by governance\n     *\n     * @param _perfFeePct The new performance fee %\n     */\n    function setPerfFeePct(uint16 _perfFeePct) external restricted {\n        require(PercentMath.validPerc(_perfFeePct), \"invalid pct\");\n        perfFeePct = _perfFeePct;\n        emit PerfFeePctUpdated(_perfFeePct);\n    }\n\n    /**\n     * Amount, expressed in the underlying currency, currently in the strategy\n     *\n     * @notice both held and invested amounts are included here, using the\n     * latest known exchange rates to the underlying currency\n     *\n     * @return The total amount of underlying\n     */\n    function investedAssets()\n        external\n        view\n        virtual\n        override(IStrategy)\n        returns (uint256)\n    {\n        uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n        return\n            underlyingBalance +\n            ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *\n                aUstBalance) / 1e18);\n    }\n\n    // Amount of underlying tokens in the strategy\n    function _getUnderlyingBalance() internal view returns (uint256) {\n        return underlying.balanceOf(address(this));\n    }\n\n    // Amount of UST tokens in the strategy\n    function _getUstBalance() internal view returns (uint256) {\n        return ustToken.balanceOf(address(this));\n    }\n\n    // Amount of aUST tokens in the strategy\n    function _getAUstBalance() internal view returns (uint256) {\n        return aUstToken.balanceOf(address(this));\n    }\n\n    // Amount of pending deposit operations\n    function depositOperationLength() external view returns (uint256) {\n        return depositOperations.length;\n    }\n\n    // Amount of pending redeem operations\n    function redeemOperationLength() external view returns (uint256) {\n        return redeemOperations.length;\n    }\n}\n\n\n",
        "CodeNames": [
            "BaseStrategy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "initRedeemStable() function in BaseStrategy.sol",
                "Type": "Centralization Risk",
                "Description": "The current implementation requires trusted key holders to send transactions to initialize withdrawals from EthAnchor before the users can withdraw funds from the contract.",
                "Repair": "Allow depositors to call uninvest for UST vaults and add trusted multisig for nonUST vaults that pay per curve swap"
            },
            {
                "Location": "BaseStrategy.sol",
                "Type": "Lack of setter for exchangeRateFeeder",
                "Description": "BaseStrategy.sol does not have a setter to change exchangeRateFeeder after deployment, which can lead to inaccurate/unupdated values from exchangeRateFeeder when calculating the vault's total invested assets.",
                "Repair": "Add a setter for exchangeRateFeeder."
            },
            {
                "Location": "BaseStrategy.sol",
                "Type": "Smart Contract Logic",
                "Description": "Add a timelock to setPerfFeePct function to give more trust to users.",
                "Repair": "Put setter functions of key/critical variables behind a timelock."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport \"./curve/ICurve.sol\";\nimport \"./BaseStrategy.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * Strategy that handles non-UST tokens, by first converting them to UST via\n * Curve (https://curve.fi/), and only then depositing into EthAnchor\n */\ncontract NonUSTStrategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n\n    // address of the Curve pool to use\n    ICurve public curvePool;\n\n    // index of the underlying token in the pool\n    int128 public underlyingI;\n\n    // index of the UST token in the pool\n    int128 public ustI;\n\n    constructor(\n        address _vault,\n        address _treasury,\n        address _ethAnchorRouter,\n        address _exchangeRateFeeder,\n        IERC20 _ustToken,\n        IERC20 _aUstToken,\n        uint16 _perfFeePct,\n        address _owner,\n        address _curvePool,\n        int128 _underlyingI,\n        int128 _ustI\n    )\n        BaseStrategy(\n            _vault,\n            _treasury,\n            _ethAnchorRouter,\n            _exchangeRateFeeder,\n            _ustToken,\n            _aUstToken,\n            _perfFeePct,\n            _owner\n        )\n    {\n        require(underlying != _ustToken, \"invalid underlying\");\n        require(_curvePool != address(0), \"0x addr\");\n        curvePool = ICurve(_curvePool);\n        underlyingI = _underlyingI;\n        ustI = _ustI;\n\n        ustToken.safeApprove(_curvePool, type(uint256).max);\n        underlying.safeApprove(_curvePool, type(uint256).max);\n    }\n\n    /**\n     * Swaps the underlying currency for UST, and initiates a deposit of all\n     * the converted UST into EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the deposit process, but does not finish it.\n     */\n    function doHardWork() external override(BaseStrategy) restricted {\n        _swapUnderlyingToUst();\n        _initDepositStable();\n    }\n\n    /**\n     * Calls Curve to convert the existing underlying balance into UST\n     */\n    function _swapUnderlyingToUst() internal {\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        if (underlyingBalance > 0) {\n            // slither-disable-next-line unused-return\n            curvePool.exchange_underlying(\n                underlyingI,\n                ustI,\n                underlyingBalance,\n                0\n            );\n        }\n    }\n\n    /**\n     * Calls Curve to convert the existing UST back into the underlying token\n     */\n    function _swapUstToUnderlying() internal {\n        uint256 ustBalance = _getUstBalance();\n        if (ustBalance > 0) {\n            // slither-disable-next-line unused-return\n            curvePool.exchange_underlying(ustI, underlyingI, ustBalance, 0);\n        }\n    }\n\n    /**\n     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.\n     * Once UST is retrieved, convert it back to underlying via Curve\n     *\n     * @notice Must be called some time after `initRedeemStable()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending redeem operation\n     */\n    function finishRedeemStable(uint256 idx) public override(BaseStrategy) {\n        super.finishRedeemStable(idx);\n        _swapUstToUnderlying();\n    }\n\n    /**\n     * Amount, expressed in the underlying currency, currently in the strategy\n     *\n     * @notice both held and invested amounts are included here, using the\n     * latest known exchange rates to the underlying currency\n     *\n     * @return The total amount of underlying\n     */\n    function investedAssets()\n        external\n        view\n        override(BaseStrategy)\n        returns (uint256)\n    {\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n        uint256 ustAssets = ((exchangeRateFeeder.exchangeRateOf(\n            address(aUstToken),\n            true\n        ) * aUstBalance) / 1e18) + pendingDeposits;\n        return\n            underlyingBalance +\n            curvePool.get_dy_underlying(ustI, underlyingI, ustAssets);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Trust} from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\nimport \"../lib/PercentMath.sol\";\nimport \"../vault/IVault.sol\";\nimport \"./IStrategy.sol\";\nimport \"./anchor/IEthAnchorRouter.sol\";\nimport \"./anchor/IExchangeRateFeeder.sol\";\n\n// import \"./Controllable.sol\";\n\n/**\n * Base strategy that handles UST tokens and invests them via the EthAnchor\n * protocol (https://docs.anchorprotocol.com/ethanchor/ethanchor)\n */\nabstract contract BaseStrategy is IStrategy, Trust {\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n\n    event PerfFeeClaimed(uint256 amount);\n    event PerfFeePctUpdated(uint256 pct);\n\n    struct Operation {\n        address operator;\n        uint256 amount;\n    }\n\n    IERC20 public override(IStrategy) underlying;\n    // Vault address\n    address public override(IStrategy) vault;\n\n    // address of the treasury\n    address public treasury;\n\n    // address for the UST token\n    IERC20 public ustToken;\n\n    // address for the aUST token (wrapped Anchor UST, received to accrue interest for an Anchor deposit)\n    IERC20 public aUstToken;\n\n    // performance fee taken by the treasury on profits\n    uint16 public perfFeePct;\n\n    // external contract to interact with EthAnchor\n    IEthAnchorRouter public ethAnchorRouter;\n\n    // external exchange rate provider\n    IExchangeRateFeeder public exchangeRateFeeder;\n\n    // amount currently pending in deposits to EthAnchor\n    uint256 public pendingDeposits;\n\n    // amount currently pending redeemption from EthAnchor\n    uint256 public pendingRedeems;\n\n    // deposit operations history\n    Operation[] public depositOperations;\n\n    // redeem operations history\n    Operation[] public redeemOperations;\n\n    // amount of UST converted (used to calculate yield)\n    uint256 public convertedUst;\n\n    // restructs a function to be called only by the vault or governance\n    modifier restricted() {\n        require(msg.sender == vault || isTrusted[msg.sender], \"restricted\");\n\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == vault, \"only vault\");\n\n        _;\n    }\n\n    constructor(\n        address _vault,\n        address _treasury,\n        address _ethAnchorRouter,\n        address _exchangeRateFeeder,\n        IERC20 _ustToken,\n        IERC20 _aUstToken,\n        uint16 _perfFeePct,\n        address _owner\n    ) Trust(_owner) {\n        require(_ethAnchorRouter != address(0), \"0x addr\");\n        require(_exchangeRateFeeder != address(0), \"0x addr\");\n        require(address(_ustToken) != address(0), \"0x addr\");\n        require(address(_aUstToken) != address(0), \"0x addr\");\n        require(PercentMath.validPerc(_perfFeePct), \"invalid pct\");\n\n        treasury = _treasury;\n        vault = _vault;\n        underlying = IVault(_vault).underlying();\n        ethAnchorRouter = IEthAnchorRouter(_ethAnchorRouter);\n        exchangeRateFeeder = IExchangeRateFeeder(_exchangeRateFeeder);\n        ustToken = _ustToken;\n        aUstToken = _aUstToken;\n        perfFeePct = _perfFeePct;\n\n        // pre-approve EthAnchor router to transact all UST and aUST\n        ustToken.safeApprove(_ethAnchorRouter, type(uint256).max);\n        aUstToken.safeApprove(_ethAnchorRouter, type(uint256).max);\n    }\n\n    /**\n     * Initiates a deposit of all the currently held UST into EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the deposit process, but does not finish it.\n     */\n    function doHardWork() external virtual override(IStrategy) restricted {\n        _initDepositStable();\n    }\n\n    function _initDepositStable() internal {\n        uint256 ustBalance = _getUstBalance();\n        require(ustBalance > 0, \"balance 0\");\n        pendingDeposits += ustBalance;\n        address _operator = ethAnchorRouter.initDepositStable(ustBalance);\n        depositOperations.push(\n            Operation({operator: _operator, amount: ustBalance})\n        );\n    }\n\n    /**\n     * Calls EthAnchor with a pending deposit ID, and attempts to finish it.\n     *\n     * @notice Must be called some time after `doHardWork()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending deposit operation\n     */\n    function finishDepositStable(uint256 idx) external {\n        require(depositOperations.length > idx, \"not running\");\n        Operation storage operation = depositOperations[idx];\n        ethAnchorRouter.finishDepositStable(operation.operator);\n\n        pendingDeposits -= operation.amount;\n        convertedUst += operation.amount;\n\n        operation.operator = depositOperations[depositOperations.length - 1]\n            .operator;\n        operation.amount = depositOperations[depositOperations.length - 1]\n            .amount;\n        depositOperations.pop();\n    }\n\n    /**\n     * Initiates a withdrawal of UST from EthAnchor\n     *\n     * @notice since EthAnchor uses an asynchronous model, this function\n     * only starts the redeem process, but does not finish it.\n     *\n     * @param amount Amount of aUST to redeem\n     */\n    function initRedeemStable(uint256 amount) public restricted {\n        uint256 aUstBalance = _getAUstBalance();\n        require(amount > 0, \"amount 0\");\n        require(aUstBalance >= amount, \"insufficient\");\n        pendingRedeems += amount;\n        address _operator = ethAnchorRouter.initRedeemStable(amount);\n        redeemOperations.push(Operation({operator: _operator, amount: amount}));\n    }\n\n    /**\n     * Calls EthAnchor with a pending redeem ID, and attempts to finish it.\n     *\n     * @notice Must be called some time after `initRedeemStable()`. Will only work if\n     * the EthAnchor bridge has finished processing the deposit.\n     *\n     * @param idx Id of the pending redeem operation\n     */\n    function finishRedeemStable(uint256 idx) public virtual {\n        require(redeemOperations.length > idx, \"not running\");\n        Operation storage operation = redeemOperations[idx];\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n        uint256 originalUst = (convertedUst * operation.amount) / aUstBalance;\n        uint256 ustBalanceBefore = _getUstBalance();\n\n        ethAnchorRouter.finishRedeemStable(operation.operator);\n\n        uint256 redeemedAmount = _getUstBalance() - ustBalanceBefore;\n        uint256 perfFee = redeemedAmount > originalUst\n            ? (redeemedAmount - originalUst).percOf(perfFeePct)\n            : 0;\n        if (perfFee > 0) {\n            ustToken.safeTransfer(treasury, perfFee);\n            emit PerfFeeClaimed(perfFee);\n        }\n        convertedUst -= originalUst;\n        pendingRedeems -= operation.amount;\n\n        operation.operator = redeemOperations[redeemOperations.length - 1]\n            .operator;\n        operation.amount = redeemOperations[redeemOperations.length - 1].amount;\n        redeemOperations.pop();\n    }\n\n    /**\n     * Withdraws the entire amount back to the vault\n     *\n     * @notice since some of the amount may be deposited into EthAnchor, this\n     * call may not withdraw all the funds right away. It will start a redeem\n     * process on EthAnchor, but this function must be called again a second\n     * time once that is finished.\n     */\n    function withdrawAllToVault() external override(IStrategy) restricted {\n        uint256 aUstBalance = _getAUstBalance();\n        if (aUstBalance > 0) {\n            initRedeemStable(aUstBalance);\n        }\n        uint256 underlyingBalance = _getUnderlyingBalance();\n        if (underlyingBalance > 0) {\n            underlying.safeTransfer(vault, underlyingBalance);\n        }\n    }\n\n    /**\n     * Withdraws a specified amount back to the vault\n     *\n     * @notice Unlike `withdrawToVault`, this function only considers the\n     * amount currently not invested, but only what is currently held by the\n     * strategy\n     *\n     * @param amount Amount to withdraw\n     */\n    function withdrawToVault(uint256 amount)\n        external\n        override(IStrategy)\n        restricted\n    {\n        underlying.safeTransfer(vault, amount);\n    }\n\n    /**\n     * Updates the performance fee\n     *\n     * @notice Can only be called by governance\n     *\n     * @param _perfFeePct The new performance fee %\n     */\n    function setPerfFeePct(uint16 _perfFeePct) external restricted {\n        require(PercentMath.validPerc(_perfFeePct), \"invalid pct\");\n        perfFeePct = _perfFeePct;\n        emit PerfFeePctUpdated(_perfFeePct);\n    }\n\n    /**\n     * Amount, expressed in the underlying currency, currently in the strategy\n     *\n     * @notice both held and invested amounts are included here, using the\n     * latest known exchange rates to the underlying currency\n     *\n     * @return The total amount of underlying\n     */\n    function investedAssets()\n        external\n        view\n        virtual\n        override(IStrategy)\n        returns (uint256)\n    {\n        uint256 underlyingBalance = _getUnderlyingBalance() + pendingDeposits;\n        uint256 aUstBalance = _getAUstBalance() + pendingRedeems;\n\n        return\n            underlyingBalance +\n            ((exchangeRateFeeder.exchangeRateOf(address(aUstToken), true) *\n                aUstBalance) / 1e18);\n    }\n\n    // Amount of underlying tokens in the strategy\n    function _getUnderlyingBalance() internal view returns (uint256) {\n        return underlying.balanceOf(address(this));\n    }\n\n    // Amount of UST tokens in the strategy\n    function _getUstBalance() internal view returns (uint256) {\n        return ustToken.balanceOf(address(this));\n    }\n\n    // Amount of aUST tokens in the strategy\n    function _getAUstBalance() internal view returns (uint256) {\n        return aUstToken.balanceOf(address(this));\n    }\n\n    // Amount of pending deposit operations\n    function depositOperationLength() external view returns (uint256) {\n        return depositOperations.length;\n    }\n\n    // Amount of pending redeem operations\n    function redeemOperationLength() external view returns (uint256) {\n        return redeemOperations.length;\n    }\n}\n\n\n",
        "CodeNames": [
            "NonUSTStrategy.sol",
            "BaseStrategy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BaseStrategy.sol, NonUSTStrategy.sol",
                "Type": "Smart Contract Logic",
                "Description": "investedAssets() function does not take into consideration the performance fee charged on strategy withdrawals.",
                "Repair": "Calculate the expected performance fee to be charged if all the strategy's assets are withdrawn from the Anchor protocol when calculating the investedAssets() amount."
            }
        ]
    }
]