[
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\n//TODO: add revert reasons or v8 custom errors back in\ncontract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    //TODO: recommend using block timestamp instead of block numbers here\n    uint256 public constant TIMELOCK_DURATION = 1 days; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    uint256 public maxSupply;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n    PendingMaxSupply public pendingMaxSupply;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    bool public override initialized;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        maxSupply = proposal.maxSupply;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n\n        initialized = true;\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory, uint256) {\n        return (pendingWeights.tokens, pendingWeights.weights, pendingWeights.minIbRatio);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length > 0);\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        uint256 startSupply = totalSupply();\n        require(startSupply + amount <= maxSupply);\n\n        handleFees(startSupply);\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        require(totalSupply() <= maxSupply);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n        _burn(msg.sender, amount);\n\n        uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);\n        ibRatio = newIbRatio;\n\n        emit NewIBRatio(newIbRatio);\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees(uint256 startSupply) private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else if (startSupply == 0) {\n            return;\n        } else {\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {\n            require(block.timestamp >= pendingPublisher.timestamp + TIMELOCK_DURATION);\n            publisher = newPublisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.timestamp = block.timestamp;\n\n            emit NewPublisherSubmitted(newPublisher);\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {\n            require(block.timestamp >= pendingLicenseFee.timestamp + TIMELOCK_DURATION);\n            licenseFee = newLicenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.timestamp = block.timestamp;\n\n            emit NewLicenseFeeSubmitted(newLicenseFee);\n        }\n    }\n\n    //changes maxSupply\n    // timelocked\n    function setNewMaxSupply(uint256 newMaxSupply) onlyPublisher public override {\n        require(newMaxSupply > totalSupply());\n\n        if (pendingMaxSupply.maxSupply != 0 && pendingMaxSupply.maxSupply == newMaxSupply) {\n            require(block.timestamp >= pendingMaxSupply.timestamp + TIMELOCK_DURATION);\n            maxSupply = newMaxSupply;\n\n            pendingMaxSupply.maxSupply = 0;\n\n            emit ChangedMaxSupply(newMaxSupply);\n        } else {\n            pendingMaxSupply.maxSupply = newMaxSupply;\n            pendingMaxSupply.timestamp = block.timestamp;\n\n            emit NewMaxSupplySubmitted(newMaxSupply);\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.timestamp >= pendingWeights.timestamp + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.timestamp = block.timestamp;\n                pendingWeights.minIbRatio = _minIbRatio;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.timestamp = block.timestamp;\n            pendingWeights.minIbRatio = _minIbRatio;\n\n            emit NewIndexSubmitted();\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(msg.sender);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).safeApprove(spender, 0);\n            IERC20(tokens[i]).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            require(tokenAmount > 0);\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}\n\n",
        "CodeNames": [
            "Basket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Basket contract's initialize() method",
                "Type": "Reentrancy",
                "Description": "A malicious publisher can create a basket proposal that mixes real ERC20 tokens with a malicious ERC20 token containing a reentrancy callback in its approve() method.",
                "Repair": "Use the initializer modifier available in ERC20Upgradeable to prevent reentrancy attacks"
            },
            {
                "Location": "Basket contract's auction mechanism",
                "Type": "Forced bond burn",
                "Description": "The publisher can lock all user funds in the Basket in order to force a user to have their bond burned.",
                "Repair": "Add more oversight and accountability between users and publishers to mitigate attacks of this type"
            },
            {
                "Location": "Basket contract's fee calculation function",
                "Type": "Fee calculation error",
                "Description": "Fee calculation is slightly off due to the use of a simple interest formula, leading to slightly less fee collected when fees are collected more frequently.",
                "Repair": "Fix the fee calculation formula to prevent any precision loss or value leakage"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LicenseFee variable",
                "Type": "Missing cap",
                "Description": "There is no cap on LicenseFee, which can potentially lead to over/underflow in various functions.",
                "Repair": "Introduce a maxLicenseFee to prevent incorrect values from making it all the way through"
            },
            {
                "Location": "Factory's auctionMultiplier and auctionDecrement variables",
                "Type": "Change in profitability",
                "Description": "When factory changes auctionMultiplier or auctionDecrement, profitability of bonded auctions change and factory owners can decide to get all tokens from baskets where they are bonded for the auction.",
                "Repair": "Save auctionDecrement and auctionMultiplier to global variables in Auction.sol when startAuction is called"
            },
            {
                "Location": "Basket:handleFees",
                "Type": "Wrong fee calculation",
                "Description": "The fee calculation on L141 is wrong. It should only get divided by BASE and not (BASE feePct)",
                "Repair": "Only divide by BASE"
            },
            {
                "Location": "handleFees function",
                "Type": "Wrong fee calculation after totalSupply was 0",
                "Description": "handleFees does not update lastFee if startSupply == 0",
                "Repair": "Set lastFee = block.timestamp if startSupply == 0"
            },
            {
                "Location": "auctionBurn function",
                "Type": "Basket.sol#auctionBurn calculates ibRatio wrong",
                "Description": "ibRatio is calculated higher than it should be",
                "Repair": "Calculate newIbRatio as follows: uint256 newIbRatio = ibRatio * (supply + amount) / supply"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 1 days;\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondTimestamp;\n    uint256 public override bondBlock;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    bool public override initialized;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondTimestamp = block.timestamp;\n        bondBlock = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public nonReentrant override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY > block.timestamp);\n        require(msg.sender == auctionBonder);\n        require(inputTokens.length == inputWeights.length);\n        require(outputTokens.length == outputWeights.length);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        //TODO: name a and b or further split up\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();\n        require(newRatio >= minIbRatio);\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        basketAsERC20.safeTransfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY <= block.timestamp);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty storage bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).safeTransfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }\n\npragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\n//TODO: add revert reasons or v8 custom errors back in\ncontract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    //TODO: recommend using block timestamp instead of block numbers here\n    uint256 public constant TIMELOCK_DURATION = 1 days; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    uint256 public maxSupply;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n    PendingMaxSupply public pendingMaxSupply;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    bool public override initialized;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        maxSupply = proposal.maxSupply;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n\n        initialized = true;\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory, uint256) {\n        return (pendingWeights.tokens, pendingWeights.weights, pendingWeights.minIbRatio);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length > 0);\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        uint256 startSupply = totalSupply();\n        require(startSupply + amount <= maxSupply);\n\n        handleFees(startSupply);\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        require(totalSupply() <= maxSupply);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n        _burn(msg.sender, amount);\n\n        uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);\n        ibRatio = newIbRatio;\n\n        emit NewIBRatio(newIbRatio);\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees(uint256 startSupply) private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else if (startSupply == 0) {\n            return;\n        } else {\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {\n            require(block.timestamp >= pendingPublisher.timestamp + TIMELOCK_DURATION);\n            publisher = newPublisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.timestamp = block.timestamp;\n\n            emit NewPublisherSubmitted(newPublisher);\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {\n            require(block.timestamp >= pendingLicenseFee.timestamp + TIMELOCK_DURATION);\n            licenseFee = newLicenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.timestamp = block.timestamp;\n\n            emit NewLicenseFeeSubmitted(newLicenseFee);\n        }\n    }\n\n    //changes maxSupply\n    // timelocked\n    function setNewMaxSupply(uint256 newMaxSupply) onlyPublisher public override {\n        require(newMaxSupply > totalSupply());\n\n        if (pendingMaxSupply.maxSupply != 0 && pendingMaxSupply.maxSupply == newMaxSupply) {\n            require(block.timestamp >= pendingMaxSupply.timestamp + TIMELOCK_DURATION);\n            maxSupply = newMaxSupply;\n\n            pendingMaxSupply.maxSupply = 0;\n\n            emit ChangedMaxSupply(newMaxSupply);\n        } else {\n            pendingMaxSupply.maxSupply = newMaxSupply;\n            pendingMaxSupply.timestamp = block.timestamp;\n\n            emit NewMaxSupplySubmitted(newMaxSupply);\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.timestamp >= pendingWeights.timestamp + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.timestamp = block.timestamp;\n                pendingWeights.minIbRatio = _minIbRatio;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.timestamp = block.timestamp;\n            pendingWeights.minIbRatio = _minIbRatio;\n\n            emit NewIndexSubmitted();\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(msg.sender);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).safeApprove(spender, 0);\n            IERC20(tokens[i]).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            require(tokenAmount > 0);\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}\n\n",
        "CodeNames": [
            "Auction.sol",
            "Basket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Basket.sol, Auction.sol",
                "Type": "Smart Contract Vulnerability",
                "Description": "M-06: Basket can be fully drained if the auction is settled within a specific block, M-07: Bonder may not be able to settle a bonded auction, leading to loss of funds, M-08: Lost fees due to precision loss in fees calculation, M-11: Fees are overcharged",
                "Repair": "Move the minIbRatio check to bondForRebalance() in Auction.sol, and track the fees paid out to the factory owner and publisher and exclude them from fee calculations in Basket.sol"
            }
        ]
    }
]