[
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO pool template contract\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\n\ncontract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Unlocked(uint256 indexed id, uint256 amount);\n    event Insured(\n        uint256 indexed id,\n        uint256 amount,\n        bytes32 target,\n        uint256 startTime,\n        uint256 endTime,\n        address insured,\n        uint256 premium\n    );\n    event Redeemed(\n        uint256 indexed id,\n        address insured,\n        bytes32 target,\n        uint256 amount,\n        uint256 payout\n    );\n    event CoverApplied(\n        uint256 pending,\n        uint256 payoutNumerator,\n        uint256 payoutDenominator,\n        uint256 incidentTimestamp,\n        bytes32 merkleRoot,\n        string rawdata,\n        string memo\n    );\n    event TransferInsurance(uint256 indexed id, address from, address to);\n    event CreditIncrease(address indexed depositor, uint256 credit);\n    event CreditDecrease(address indexed withdrawer, uint256 credit);\n    event MarketStatusChanged(MarketStatus statusValue);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public override paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n\n    /// @notice Market variables\n    uint256 public attributionDebt; //pool's attribution for indices\n    uint256 public override lockedAmount; //Liquidity locked when utilized\n    uint256 public override totalCredit; //Liquidity from index\n    uint256 public rewardPerCredit; //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.\n    uint256 public pendingEnd; //pending time when paying out\n\n    /// @notice Market variables for margin account\n    struct IndexInfo {\n        uint256 credit; //How many credit (equal to liquidity) the index has allocated\n        uint256 rewardDebt; // Reward debt. *See explanation below.\n        bool exist; //true if the index has allocated credit\n    }\n\n    mapping(address => IndexInfo) public indicies;\n    address[] public indexList;\n\n    //\n    // * We do some fancy math for premium calculation of indicies.\n    // Basically, any point in time, the amount of premium entitled to an index but is pending to be distributed is:\n    //\n    //   pending reward = (index.credit * rewardPerCredit) - index.rewardDebt\n    //\n    // When the pool receives premium, it updates rewardPerCredit\n    //\n    // Whenever an index deposits, withdraws credit to a pool, Here's what happens:\n    //   1. The index receives the pending reward sent to the index vault.\n    //   2. The index's rewardDebt get updated.\n    //\n    // This mechanism is widely used (e.g. SushiSwap: MasterChef.sol)\n    //\n\n    ///@notice Market status transition management\n    enum MarketStatus {\n        Trading,\n        Payingout\n    }\n    MarketStatus public marketStatus;\n\n    ///@notice user's withdrawal status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    ///@notice insurance status management\n    struct Insurance {\n        uint256 id; //each insuance has their own id\n        uint256 startTime; //timestamp of starttime\n        uint256 endTime; //timestamp of endtime\n        uint256 amount; //insured amount\n        bytes32 target; //target id in bytes32\n        address insured; //the address holds the right to get insured\n        bool status; //true if insurance is not expired or redeemed\n    }\n    mapping(uint256 => Insurance) public insurances;\n    uint256 public allInsuranceCount;\n\n    ///@notice incident status management\n    struct Incident {\n        uint256 payoutNumerator;\n        uint256 payoutDenominator;\n        uint256 incidentTimestamp;\n        bytes32 merkleRoot;\n    }\n    Incident public incident;\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = target governance token address\n     * references[1] = underlying token address\n     * references[2] = registry\n     * references[3] = parameter\n     * references[4] = initialDepositor\n     * conditions[0] = minimim deposit amount defined by the factory\n     * conditions[1] = initial deposit amount defined by the creator\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0) &&\n                _references[3] != address(0) &&\n                _references[4] != address(0) &&\n                _conditions[0] <= _conditions[1],\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n        initialized = true;\n\n        string memory _name = string(\n            abi.encodePacked(\n                \"InsureDAO-\",\n                IERC20Metadata(_references[1]).name(),\n                \"-PoolInsurance\"\n            )\n        );\n        string memory _symbol = string(\n            abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n        );\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        registry = IRegistry(_references[2]);\n        parameters = IParameters(_references[3]);\n        vault = IVault(parameters.getVault(_references[1]));\n\n        metadata = _metaData;\n\n        marketStatus = MarketStatus.Trading;\n\n        if (_conditions[1] > 0) {\n            _depositFrom(_conditions[1], _references[4]);\n        }\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies tokens to the pool and receives iTokens\n     * @param _amount amount of tokens to deposit\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, msg.sender, address(this));\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice Internal deposit function that allows third party to deposit\n     * @param _amount amount of tokens to deposit\n     * @param _from deposit beneficiary's address\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function _depositFrom(uint256 _amount, address _from)\n        internal\n        returns (uint256 _mintAmount)\n    {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, _from, address(this));\n\n        emit Deposit(_from, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(_from, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iTokens to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iTokens and receives collateral from the pool\n     * @param _amount amount of iTokens to burn\n     * @return _retVal the amount underlying tokens returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        uint256 _supply = totalSupply();\n        require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");\n\n        uint256 _liquidity = originalLiquidity();\n        _retVal = (_amount * _liquidity) / _supply;\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: WITHDRAWAL_PENDING\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n        require(\n            _retVal <= availableBalance(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Unlocks an array of insurances\n     * @param _ids array of ids to unlock\n     */\n    function unlockBatch(uint256[] calldata _ids) external {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            unlock(_ids[i]);\n        }\n    }\n\n    /**\n     * @notice Unlock funds locked in the expired insurance\n     * @param _id id of the insurance policy to unlock liquidity\n     */\n    function unlock(uint256 _id) public {\n        require(\n            insurances[_id].status == true &&\n                marketStatus == MarketStatus.Trading &&\n                insurances[_id].endTime + parameters.getGrace(msg.sender) <\n                block.timestamp,\n            \"ERROR: UNLOCK_BAD_COINDITIONS\"\n        );\n        insurances[_id].status == false;\n\n        lockedAmount = lockedAmount - insurances[_id].amount;\n\n        emit Unlocked(_id, insurances[_id].amount);\n    }\n\n    /**\n     * Index interactions\n     */\n\n    /**\n     * @notice Allocate credit from an index. Allocated credits are deemed as equivalent liquidity as real token deposits.\n     * @param _credit credit (liquidity amount) to be added to this pool\n     * @return _pending pending preium for the caller index\n     */\n\n    function allocateCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS\"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        if (_index.exist == false) {\n            _index.exist = true;\n            indexList.push(msg.sender);\n        } else if (_index.credit > 0) {\n            _pending = _sub(\n                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n                _index.rewardDebt\n            );\n            if (_pending > 0) {\n                vault.transferAttribution(_pending, msg.sender);\n                attributionDebt -= _pending;\n            }\n        }\n        if (_credit > 0) {\n            totalCredit += _credit;\n            _index.credit += _credit;\n            emit CreditIncrease(msg.sender, _credit);\n        }\n        _index.rewardDebt =\n            (_index.credit * _rewardPerCredit) /\n            MAGIC_SCALE_1E6;\n    }\n\n    /**\n     * @notice An index withdraw credit and earn accrued premium\n     * @param _credit credit (liquidity amount) to be withdrawn from this pool\n     * @return _pending pending preium for the caller index\n     */\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        require(\n            IRegistry(registry).isListed(msg.sender) &&\n                _index.credit >= _credit &&\n                _credit <= availableBalance(),\n            \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n        );\n\n        //calculate acrrued premium\n        _pending = _sub(\n            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n            _index.rewardDebt\n        );\n\n        //Withdraw liquidity\n        if (_credit > 0) {\n            totalCredit -= _credit;\n            _index.credit -= _credit;\n            emit CreditDecrease(msg.sender, _credit);\n        }\n\n        //withdraw acrrued premium\n        if (_pending > 0) {\n            vault.transferAttribution(_pending, msg.sender);\n            attributionDebt -= _pending;\n            _index.rewardDebt =\n                (_index.credit * _rewardPerCredit) /\n                MAGIC_SCALE_1E6;\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Get insured for the specified amount for specified span\n     * @param _amount target amount to get covered\n     * @param _maxCost maximum cost to pay for the premium. revert if the premium is higher\n     * @param _span length to get covered(e.g. 7 days)\n     * @param _target target id\n     * @return id of the insurance policy\n     */\n    function insure(\n        uint256 _amount,\n        uint256 _maxCost,\n        uint256 _span,\n        bytes32 _target\n    ) external returns (uint256) {\n        //Distribute premium and fee\n        uint256 _endTime = _span + block.timestamp;\n        uint256 _premium = getPremium(_amount, _span);\n        uint256 _fee = parameters.getFeeRate(msg.sender);\n\n        require(\n            _amount <= availableBalance(),\n            \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"\n        );\n        require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");\n        require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");\n        require(\n            parameters.getMinDate(msg.sender) <= _span,\n            \"ERROR: INSURE_SPAN_BELOW_MIN\"\n        );\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: INSURE_MARKET_PENDING\"\n        );\n        require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");\n\n        //current liquidity\n        uint256 _liquidity = totalLiquidity();\n        uint256 _totalCredit = totalCredit;\n\n        //accrue premium/fee\n        uint256[2] memory _newAttribution = vault.addValueBatch(\n            _premium,\n            msg.sender,\n            [address(this), parameters.getOwner()],\n            [MAGIC_SCALE_1E6 - _fee, _fee]\n        );\n\n        //Lock covered amount\n        uint256 _id = allInsuranceCount;\n        lockedAmount += _amount;\n        Insurance memory _insurance = Insurance(\n            _id,\n            block.timestamp,\n            _endTime,\n            _amount,\n            _target,\n            msg.sender,\n            true\n        );\n        insurances[_id] = _insurance;\n        allInsuranceCount += 1;\n\n        //Calculate liquidity for index\n        if (_totalCredit > 0) {\n            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /\n                _liquidity;\n            attributionDebt += _attributionForIndex;\n            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /\n                _totalCredit);\n        }\n\n        emit Insured(\n            _id,\n            _amount,\n            _target,\n            block.timestamp,\n            _endTime,\n            msg.sender,\n            _premium\n        );\n\n        return _id;\n    }\n\n    /**\n     * @notice Redeem an insurance policy\n     * @param _id the id of the insurance policy\n     * @param _merkleProof merkle proof (similar to \"verify\" function of MerkleProof.sol of OpenZeppelin\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol\n     */\n    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {\n        Insurance storage _insurance = insurances[_id];\n        require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");\n\n        uint256 _payoutNumerator = incident.payoutNumerator;\n        uint256 _payoutDenominator = incident.payoutDenominator;\n        uint256 _incidentTimestamp = incident.incidentTimestamp;\n        bytes32 _targets = incident.merkleRoot;\n\n        require(\n            marketStatus == MarketStatus.Payingout,\n            \"ERROR: NO_APPLICABLE_INCIDENT\"\n        );\n        require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                _insurance.startTime <= _incidentTimestamp &&\n                _insurance.endTime >= _incidentTimestamp,\n            \"ERROR: INSURANCE_NOT_APPLICABLE\"\n        );\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                _targets,\n                keccak256(\n                    abi.encodePacked(_insurance.target, _insurance.insured)\n                )\n            ) ||\n                MerkleProof.verify(\n                    _merkleProof,\n                    _targets,\n                    keccak256(abi.encodePacked(_insurance.target, address(0)))\n                ),\n            \"ERROR: INSURANCE_EXEMPTED\"\n        );\n        _insurance.status = false;\n        lockedAmount -= _insurance.amount;\n\n        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /\n            _payoutDenominator;\n\n        vault.borrowValue(_payoutAmount, msg.sender);\n\n        emit Redeemed(\n            _id,\n            msg.sender,\n            _insurance.target,\n            _insurance.amount,\n            _payoutAmount\n        );\n    }\n\n    /**\n     * @notice Transfers an active insurance\n     * @param _id id of the insurance policy\n     * @param _to receipient of of the policy\n     */\n    function transferInsurance(uint256 _id, address _to) external {\n        Insurance storage insurance = insurances[_id];\n\n        require(\n            _to != address(0) &&\n                insurance.insured == msg.sender &&\n                insurance.endTime >= block.timestamp &&\n                insurance.status == true,\n            \"ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS\"\n        );\n\n        insurance.insured = _to;\n        emit TransferInsurance(_id, msg.sender, _to);\n    }\n\n    /**\n     * @notice Get how much premium for the specified amount and span\n     * @param _amount amount to get insured\n     * @param _span span to get covered\n     */\n    function getPremium(uint256 _amount, uint256 _span)\n        public\n        view\n        returns (uint256 premium)\n    {\n        return\n            parameters.getPremium(\n                _amount,\n                _span,\n                totalLiquidity(),\n                lockedAmount,\n                address(this)\n            );\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Decision to make a payout\n     * @param _pending length of time to allow policyholders to redeem their policy\n     * @param _payoutNumerator Numerator of the payout *See below\n     * @param _payoutDenominator Denominator of the payout *See below\n     * @param _incidentTimestamp Unixtimestamp of the incident\n     * @param _merkleRoot Merkle root of the payout id list\n     * @param _rawdata raw data before the data set is coverted to merkle tree (to be emi\uff54ted within event)\n     * @param _memo additional memo for the payout report (to be emmited within event)\n     * payout ratio is determined by numerator/denominator (e.g. 50/100 = 50% payout\n     */\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external override onlyOwner {\n        require(paused == false, \"ERROR: UNABLE_TO_APPLY\");\n        incident.payoutNumerator = _payoutNumerator;\n        incident.payoutDenominator = _payoutDenominator;\n        incident.incidentTimestamp = _incidentTimestamp;\n        incident.merkleRoot = _merkleRoot;\n        marketStatus = MarketStatus.Payingout;\n        pendingEnd = block.timestamp + _pending;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            if (indicies[indexList[i]].credit > 0) {\n                IIndexTemplate(indexList[i]).lock();\n            }\n        }\n        emit CoverApplied(\n            _pending,\n            _payoutNumerator,\n            _payoutDenominator,\n            _incidentTimestamp,\n            _merkleRoot,\n            _rawdata,\n            _memo\n        );\n        emit MarketStatusChanged(marketStatus);\n    }\n\n    /**\n     * @notice Anyone can resume the market after a pending period ends\n     */\n    function resume() external {\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                pendingEnd < block.timestamp,\n            \"ERROR: UNABLE_TO_RESUME\"\n        );\n\n        uint256 _debt = vault.debts(address(this));\n        uint256 _totalCredit = totalCredit;\n        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n        uint256 _actualDeduction;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            address _index = indexList[i];\n            uint256 _credit = indicies[_index].credit;\n            if (_credit > 0) {\n                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                    _totalCredit;\n                uint256 _redeemAmount = _divCeil(\n                    _deductionFromIndex,\n                    _shareOfIndex\n                );\n                _actualDeduction += IIndexTemplate(_index).compensate(\n                    _redeemAmount\n                );\n            }\n        }\n\n        uint256 _deductionFromPool = _debt -\n            _deductionFromIndex /\n            MAGIC_SCALE_1E6;\n        uint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n\n        if (_deductionFromPool > 0) {\n            vault.offsetDebt(_deductionFromPool, address(this));\n        }\n\n        vault.transferDebt(_shortage);\n\n        marketStatus = MarketStatus.Trading;\n        emit MarketStatusChanged(MarketStatus.Trading);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice Get the exchange rate of LP tokens against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying tokens balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying tokens for the specified address\n     */\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * originalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get the accrued value for an index\n     * @param _index the address of index\n     * @return The pending premium for the specified index\n     */\n    function pendingPremium(address _index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _credit = indicies[_index].credit;\n        if (_credit == 0) {\n            return 0;\n        } else {\n            return\n                _sub(\n                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,\n                    indicies[_index].rewardDebt\n                );\n        }\n    }\n\n    /**\n     * @notice Get token number for the specified underlying value\n     * @param _value amount of iToken\n     * @return _amount The balance of underlying tokens for the specified amount\n     */\n    function worth(uint256 _value) public view returns (uint256 _amount) {\n        uint256 _supply = totalSupply();\n        uint256 _originalLiquidity = originalLiquidity();\n        if (_supply > 0 && _originalLiquidity > 0) {\n            _amount = (_value * _supply) / _originalLiquidity;\n        } else if (_supply > 0 && _originalLiquidity == 0) {\n            _amount = _value * _supply;\n        } else {\n            _amount = _value;\n        }\n    }\n\n    /**\n     * @notice Get allocated credit\n     * @param _index address of an index\n     * @return The balance of credit allocated by the specified index\n     */\n    function allocatedCredit(address _index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return indicies[_index].credit;\n    }\n\n    /**\n     * @notice Returns the amount of underlying tokens available for withdrawals\n     * @return _balance available liquidity of this pool\n     */\n    function availableBalance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        if (totalLiquidity() > 0) {\n            return totalLiquidity() - lockedAmount;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns the utilization rate for this pool. Scaled by 1e6 (100% = 1e6)\n     * @return _rate utilization rate\n     */\n    function utilizationRate() public view override returns (uint256 _rate) {\n        if (lockedAmount > 0) {\n            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Pool's Liquidity + Liquidity from Index (how much can the pool sell cover)\n     * @return _balance total liquidity of this pool\n     */\n    function totalLiquidity() public view override returns (uint256 _balance) {\n        return originalLiquidity() + totalCredit;\n    }\n\n    /**\n     * @notice Pool's Liquidity\n     * @return _balance total liquidity of this pool\n     */\n    function originalLiquidity() public view returns (uint256 _balance) {\n        return\n            vault.underlyingValue(address(this)) -\n            vault.attributionValue(attributionDebt);\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of tokens to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for safe division\n     */\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n\n    /**\n     * @notice Internal function for overflow free subtraction\n     */\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return 0;\n        } else {\n            return a - b;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "PoolTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PoolTemplate contract, redeem method",
                "Type": "Signature replay",
                "Description": "The only data related to the _insurance are target and insured, so as the incident has no relation with the Insurance, apparently nothing prevents a user to call insure with high amounts, after receive the incident, the only thing that prevents this from being reused is that the owner creates the incident with an _incidentTimestamp from the past.",
                "Repair": "Add a check in applyCover that _incidentTimestamp is less than the current date and the span argument is greater than 0 in the insure method"
            },
            {
                "Location": "PoolTemplate contract, unlock function",
                "Type": "Multiple unlock calls allowed",
                "Description": "The function unlock() in PoolTemplate has a typo where it compares insurances[_id].status to false rather than setting it to false.",
                "Repair": "Change insurances[_id].status == false; to insurances[_id].status = false;"
            },
            {
                "Location": "PoolTemplate.initialize()",
                "Type": "Theft of initial pool deposit",
                "Description": "An attacker can frontrun the Factory.createMarket transaction with their own market creation and create a market with different parameters but still passing in _conditions[1]=amount and _references[4]=victim. A market with parameters that the initial depositor did not want can be created with their tokens and these tokens are essentially lost.",
                "Repair": "Set the initial depositor to Factory.createMarket's msg.sender instead of being able to pick a whitelisted one as _references[4]"
            },
            {
                "Location": "PoolTemplate.applyCover()",
                "Type": "Infinite Insurance Period Extension",
                "Description": "The owner could potentially extend the insurance period indefinitely in the applyCover function without ever allowing the market to resume.",
                "Repair": "Require that the market be in a Trading state to allow another applyCover call."
            },
            {
                "Location": "PoolTemplate.sol",
                "Type": "Smart Contract Vulnerability",
                "Description": "The first depositor to a pool can drain all users if there is no liquidity in the pool, and the attacker can steal all money from liquidity providers.",
                "Repair": "Add a check to ensure that ownership control is not compromised before allowing transferAttribution() to be called"
            },
            {
                "Location": "PoolTemplate.sol",
                "Type": "Smart Contract Vulnerability",
                "Description": "System Debt Is Not Handled When Insurance Pools Become Insolvent.",
                "Repair": "Devise a mechanism to ensure system debt is properly handled, such as minting INSURE tokens or implementing a better mechanism to payback"
            },
            {
                "Location": "PoolTemplate.sol#resume()",
                "Type": "Wrong implementation of resume()",
                "Description": "Wrong implementation of resume() will compensate overmuch redeem amount from index pools.",
                "Repair": "Change the implementation of resume() as suggested in the report"
            },
            {
                "Location": "PoolTemplate.sol#L703",
                "Type": "Unbounded iteration",
                "Description": "Unbounded iteration over all indexes could result in denial of service for the desired functionality and break core functionality.",
                "Repair": "Keep the array size small or upgrade the severity level"
            },
            {
                "Location": "PoolTemplate.sol#L279",
                "Type": "Withdrawal without obligation to withdraw",
                "Description": "There are no obligations to withdraw after the lockup period, and the capital will keep earning premium during lockup.",
                "Repair": "Extend the lockup period at least by a factor of 2 or force underwriter to withdraw after lockup period"
            },
            {
                "Location": "PoolTemplate.sol#withdrawCredit()",
                "Type": "Admin can withdraw credit after applyCover()",
                "Description": "Admin of the index pool can withdraw credit after applyCover() to avoid taking loss for the compensation paid for a certain pool.",
                "Repair": "Lock the credit control when the pool is in payout status"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO vault contract\n * @notice\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IVault.sol\";\n\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IRegistry.sol\";\n\ncontract Vault is IVault {\n    using SafeERC20 for IERC20;\n\n    /**\n     * Storage\n     */\n\n    address public override token;\n    IController public controller;\n    IRegistry public registry;\n    IOwnership public ownership;\n\n    mapping(address => uint256) public override debts;\n    mapping(address => uint256) public attributions;\n    uint256 public totalAttributions;\n\n    address public keeper; //keeper can operate utilize(), if address zero, anyone can operate.\n    uint256 public balance; //balance of underlying token\n    uint256 public totalDebt; //total debt balance. 1debt:1token\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n\n\n    event ControllerSet(address controller);\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    modifier onlyMarket() {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR_ONLY_MARKET\"\n        );\n        _;\n    }\n\n    constructor(\n        address _token,\n        address _registry,\n        address _controller,\n        address _ownership\n    ) {\n        require(_token != address(0));\n        require(_registry != address(0));\n        require(_ownership != address(0));\n        //controller can be zero\n\n        token = _token;\n        registry = IRegistry(_registry);\n        controller = IController(_controller);\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * Vault Functions\n     */\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiaries beneficiary's address array\n     * @param _shares funds share within beneficiaries (100% = 1e6)\n     * @return _allocations attribution amount generated from the transaction\n     */\n    function addValueBatch(\n        uint256 _amount,\n        address _from,\n        address[2] memory _beneficiaries,\n        uint256[2] memory _shares\n    ) external override onlyMarket returns (uint256[2] memory _allocations) {\n        \n        require(_shares[0] + _shares[1] == 1000000, \"ERROR_INCORRECT_SHARE\");\n\n        uint256 _attributions;\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n\n        balance += _amount;\n        totalAttributions += _attributions;\n        for (uint128 i = 0; i < 2; i++) {\n            uint256 _allocation = (_shares[i] * _attributions) / MAGIC_SCALE_1E6;\n            attributions[_beneficiaries[i]] += _allocation;\n            _allocations[i] = _allocation;\n        }\n    }\n\n    /**\n     * @notice A market contract can deposit collateral and get attribution point in return\n     * @param  _amount amount of tokens to deposit\n     * @param _from sender's address\n     * @param _beneficiary beneficiary's address\n     * @return _attributions attribution amount generated from the transaction\n     */\n\n    function addValue(\n        uint256 _amount,\n        address _from,\n        address _beneficiary\n    ) external override onlyMarket returns (uint256 _attributions) {\n\n        if (totalAttributions == 0) {\n            _attributions = _amount;\n        } else {\n            uint256 _pool = valueAll();\n            _attributions = (_amount * totalAttributions) / _pool;\n        }\n        IERC20(token).safeTransferFrom(_from, address(this), _amount);\n        balance += _amount;\n        totalAttributions += _attributions;\n        attributions[_beneficiary] += _attributions;\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw underlying value\n     * @param _amount amount of tokens to withdraw\n     * @param _to address to get underlying tokens\n     * @return _attributions amount of attributions burnet\n     */\n    function withdrawValue(uint256 _amount, address _to)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_WITHDRAW-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (totalAttributions * _amount) / valueAll();\n\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n\n        if (available() < _amount) {\n            //when USDC in this contract isn't enough\n            uint256 _shortage = _amount - available();\n            _unutilize(_shortage);\n\n            assert(available() >= _amount);\n        }\n\n        balance -= _amount;\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer underlying value\n     * @param _amount sender of value\n     * @param _destination reciepient of value\n     */\n\n    function transferValue(uint256 _amount, address _destination)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_TRANSFER-VALUE_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        attributions[_destination] += _attributions;\n    }\n\n    /**\n     * @notice a registered contract can borrow balance from the vault\n     * @param _amount borrow amount\n     * @param _to borrower's address\n     */\n    function borrowValue(uint256 _amount, address _to) external onlyMarket override {\n        debts[msg.sender] += _amount;\n        totalDebt += _amount;\n\n        IERC20(token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can offset an address's debt\n     * @param _amount debt amount to offset\n     * @param _target borrower's address\n     */\n\n    function offsetDebt(uint256 _amount, address _target)\n        external\n        override\n        returns (uint256 _attributions)\n    {\n        require(\n            attributions[msg.sender] > 0 &&\n                underlyingValue(msg.sender) >= _amount,\n            \"ERROR_REPAY_DEBT_BADCONDITOONS\"\n        );\n        _attributions = (_amount * totalAttributions) / valueAll();\n        attributions[msg.sender] -= _attributions;\n        totalAttributions -= _attributions;\n        balance -= _amount;\n        debts[_target] -= _amount;\n        totalDebt -= _amount;\n    }\n\n    /**\n     * @notice a registerd market can transfer their debt to system debt\n     * @param _amount debt amount to transfer\n     * @dev will be called when CDS could not afford when resume the market.\n     */\n    function transferDebt(uint256 _amount) external onlyMarket override {\n\n        if(_amount != 0){\n            debts[msg.sender] -= _amount;\n            debts[address(0)] += _amount;\n        }\n    }\n\n    /**\n     * @notice anyone can repay the system debt by sending tokens to this contract\n     * @param _amount debt amount to repay\n     * @param _target borrower's address\n     */\n    function repayDebt(uint256 _amount, address _target) external override {\n        uint256 _debt = debts[_target];\n        if (_debt >= _amount) {\n            debts[_target] -= _amount;\n            totalDebt -= _amount;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n        } else {\n            debts[_target] = 0;\n            totalDebt -= _debt;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);\n        }\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw value denominated in attribution\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAttribution(uint256 _attribution, address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(_attribution, _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function withdrawAllAttribution(address _to)\n        external\n        override\n        returns (uint256 _retVal)\n    {\n        _retVal = _withdrawAttribution(attributions[msg.sender], _to);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can withdraw all value\n     * @param _attribution amount of attribution to burn\n     * @param _to beneficiary's address\n     * @return _retVal number of tokens withdrawn from the transaction\n     */\n    function _withdrawAttribution(uint256 _attribution, address _to)\n        internal\n        returns (uint256 _retVal)\n    {\n        require(\n            attributions[msg.sender] >= _attribution,\n            \"ERROR_WITHDRAW-ATTRIBUTION_BADCONDITOONS\"\n        );\n        _retVal = (_attribution * valueAll()) / totalAttributions;\n\n        attributions[msg.sender] -= _attribution;\n        totalAttributions -= _attribution;\n\n        if (available() < _retVal) {\n            uint256 _shortage = _retVal - available();\n            _unutilize(_shortage);\n        }\n\n        balance -= _retVal;\n        IERC20(token).safeTransfer(_to, _retVal);\n    }\n\n    /**\n     * @notice an address that has balance in the vault can transfer value denominated in attribution\n     * @param _amount amount of attribution to transfer\n     * @param _destination reciepient of attribution\n     */\n    function transferAttribution(uint256 _amount, address _destination)\n        external\n        override\n    {\n        require(_destination != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        require(\n            _amount != 0 && attributions[msg.sender] >= _amount,\n            \"ERROR_TRANSFER-ATTRIBUTION_BADCONDITOONS\"\n        );\n\n        attributions[msg.sender] -= _amount;\n        attributions[_destination] += _amount;\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @return _amount amount of tokens utilized\n     */\n    function utilize() external override returns (uint256 _amount) {\n        if (keeper != address(0)) {\n            require(msg.sender == keeper, \"ERROR_NOT_KEEPER\");\n        }\n        _amount = available(); //balance\n        if (_amount > 0) {\n            IERC20(token).safeTransfer(address(controller), _amount);\n            balance -= _amount;\n            controller.earn(address(token), _amount);\n        }\n    }\n\n    /**\n     * @notice get attribution number for the specified address\n     * @param _target target address\n     * @return amount of attritbution\n     */\n\n    function attributionOf(address _target)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return attributions[_target];\n    }\n\n    /**\n     * @notice get all attribution number for this contract\n     * @return amount of all attribution\n     */\n    function attributionAll() external view returns (uint256) {\n        return totalAttributions;\n    }\n\n    /**\n     * @notice Convert attribution number into underlying assset value\n     * @param _attribution amount of attribution\n     * @return token value of input attribution\n     */\n    function attributionValue(uint256 _attribution)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (totalAttributions > 0 && _attribution > 0) {\n            return (_attribution * valueAll()) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of the specified address\n     * @param _target target address\n     * @return token value of target address\n     */\n    function underlyingValue(address _target)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (attributions[_target] > 0) {\n            return (valueAll() * attributions[_target]) / totalAttributions;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice return underlying value of this contract\n     * @return all token value of the vault\n     */\n    function valueAll() public view returns (uint256) {\n        if (address(controller) != address(0)) {\n            return balance + controller.valueAll();\n        } else {\n            return balance;\n        }\n    }\n\n    /**\n     * @notice internal function to unutilize the funds and keep utilization rate\n     * @param _amount amount to withdraw from controller\n     */\n    function _unutilize(uint256 _amount) internal {\n        require(address(controller) != address(0), \"ERROR_CONTROLLER_NOT_SET\");\n\n        controller.withdraw(address(this), _amount);\n        balance += _amount;\n    }\n\n    /**\n     * @notice return how much funds in this contract is available to be utilized\n     * @return available balance to utilize\n     */\n    function available() public view returns (uint256) {\n        return balance - totalDebt;\n    }\n\n    /**\n     * @notice return how much price for each attribution\n     * @return value of one share of attribution\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return (valueAll() * MAGIC_SCALE_1E6) / totalAttributions;\n    }\n\n    /**\n     * onlyOwner\n     */\n\n    /**\n     * @notice withdraw redundant token stored in this contract\n     * @param _token token address\n     * @param _to beneficiary's address\n     */\n    function withdrawRedundant(address _token, address _to)\n        external\n        override\n        onlyOwner\n    {\n        if (\n            _token == address(token) &&\n            balance < IERC20(token).balanceOf(address(this))\n        ) {\n            uint256 _redundant = IERC20(token).balanceOf(address(this)) -\n                balance;\n            IERC20(token).safeTransfer(_to, _redundant);\n        } else if (IERC20(_token).balanceOf(address(this)) > 0) {\n            IERC20(_token).safeTransfer(\n                _to,\n                IERC20(_token).balanceOf(address(this))\n            );\n        }\n    }\n\n    /**\n     * @notice admin function to set controller address\n     * @param _controller address of the controller\n     */\n    function setController(address _controller) public override onlyOwner {\n        require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");\n\n        if (address(controller) != address(0)) {\n            controller.migrate(address(_controller));\n            controller = IController(_controller);\n        } else {\n            controller = IController(_controller);\n        }\n\n        emit ControllerSet(_controller);\n    }\n\n    /**\n     * @notice the controller can utilize all available stored funds\n     * @param _keeper keeper address\n     */\n    function setKeeper(address _keeper) external override onlyOwner {\n        if (keeper != _keeper) {\n            keeper = _keeper;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Vault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Vault contract, borrowValue function",
                "Type": "Compromised admin can drain funds",
                "Description": "The current design/implementation allows a market address (registered on the registry) to call Vault#borrowValue() and transfer tokens to an arbitrary address.",
                "Repair": "Consider adding constrains (eg. timelock) to Registry#supportMarket(). Consider adding constrains (upper bound for each pool, and index pool for example) to Vault#borrowValue()"
            },
            {
                "Location": "Vault contract, utilize function",
                "Type": "Tokens can be burned with no access control",
                "Description": "The Vault.sol contract has two address state variables, the keeper variable and the controller variable, which are both permitted to be the zero address.",
                "Repair": "Add the following line to the very beginning of the utilize() function: require(address(controller) != address(0))"
            },
            {
                "Location": "Vault.withdrawRedundant()",
                "Type": "Backdoor in withdrawRedundant",
                "Description": "There's a backdoor in the withdrawRedundant that allows admins to steal all user deposits.",
                "Repair": "Change the logic of withdrawRedundant to handle precision loss while converting between the amount of shares and the amount of underlying tokens back and forth properly"
            },
            {
                "Location": "Vault.setController(), Vault.utilize()",
                "Type": "Unauthorized Fund Transfer",
                "Description": "A malicious controller contract can transfer funds from the Vault to the attacker.",
                "Repair": "Disallow Vault.setController() to set a new address if a controller is existing, or put a timelock to this function at least."
            },
            {
                "Location": "Vault.addValue()",
                "Type": "Unsupported Tokens",
                "Description": "ERC20 tokens that charge fee for every transfer() / transferFrom() are not supported.",
                "Repair": "Compare before and after balance to get the actual transferred amount."
            },
            {
                "Location": "Vault.sol",
                "Type": "Smart Contract Vulnerability",
                "Description": "repayDebt in Vault.sol could DOS functionality for markets.",
                "Repair": "Make repayDebt() accept an amount up to and including the value of the debt for the given borrower"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Vault#addValue()",
                "Type": "Wrong design/implementation of permission control",
                "Description": "Allows malicious/compromised Registry or Factory admin to steal funds from users' wallet balances",
                "Repair": "Change the design/implementation to make sure that the allowances approved by the users can only be used by themselves"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.7;\n/**\n * @author InsureDAO\n * @title InsureDAO market template contract\n * SPDX-License-Identifier: GPL-3.0\n */\n import \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/ICDSTemplate.sol\";\n\n/**\n * An index pool can index a certain number of pools with leverage.\n *\n * Index A\n * \u3000\u251c Pool A\n * \u3000\u251c Pool B\n * \u3000\u251c Pool C\n * \u3000...\n *\n */\n\ncontract IndexTemplate is InsureDAOERC20, IIndexTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Compensated(address indexed index, uint256 amount);\n    event Paused(bool paused);\n    event Resumed();\n    event Locked();\n    event MetadataChanged(string metadata);\n    event LeverageSet(uint256 target);\n    event AllocationSet(\n        uint256 indexed _index,\n        address indexed pool,\n        uint256 allocPoint\n    );\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public paused;\n    bool public locked;\n    uint256 public pendingEnd;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IVault public vault;\n    IRegistry public registry;\n\n    /// @notice Market variables for margin account\n    uint256 public totalAllocatedCredit; //total allocated credit(liquidity)\n    mapping(address => uint256) public allocPoints; //allocation point for each pool\n    uint256 public totalAllocPoint; //total allocation point\n    address[] public poolList; //list of all pools\n    uint256 public targetLev; //1x = MAGIC_SCALE_1E6\n    //The allocated credits are deemed as liquidity in each underlying pool\n    //Credit amount(liquidity) will be determined by the following math\n    //credit for a pool = total liquidity of this pool * leverage rate * allocation point for a pool / total allocation point\n\n    ///@notice user status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    struct PoolStatus {\n        uint256 current;\n        uint256 available;\n        uint256 allocation;\n        address addr;\n    }\n\n    ///@notice magic numbers\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    /**\n     * @notice Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = underlying token address\n     * references[1] = registry\n     * references[2] = parameter\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0),\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n\n        initialized = true;\n\n        string memory _name = \"InsureDAO-Index\";\n        string memory _symbol = \"iIndex\";\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        parameters = IParameters(_references[2]);\n        vault = IVault(parameters.getVault(_references[0]));\n        registry = IRegistry(_references[1]);\n\n        metadata = _metaData;\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies collateral to the pool and receives iTokens\n     * @param _amount amount of token to deposit\n     * @return _mintAmount the amount of iToken minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(locked == false && paused == false, \"ERROR: DEPOSIT_DISABLED\");\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        uint256 _supply = totalSupply();\n        uint256 _totalLiquidity = totalLiquidity();\n        vault.addValue(_amount, msg.sender, address(this));\n\n        if (_supply > 0 && _totalLiquidity > 0) {\n            _mintAmount = (_amount * _supply) / _totalLiquidity;\n        } else if (_supply > 0 && _totalLiquidity == 0) {\n            //when\n            _mintAmount = _amount * _supply;\n        } else {\n            _mintAmount = _amount;\n        }\n        emit Deposit(msg.sender, _amount, _mintAmount);\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n        uint256 _liquidityAfter = _totalLiquidity + _amount;\n        uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n            _liquidityAfter;\n        //execut adjustAlloc only when the leverage became below target - lower-slack\n        if (targetLev - parameters.getLowerSlack(address(this)) > _leverage) {\n            _adjustAlloc(_liquidityAfter);\n        }\n    }\n\n    /**\n     * @notice A liquidity provider requests withdrawal of collateral\n     * @param _amount amount of iToken to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iToken and receives collateral from the pool\n     * @param _amount amount of iToken to burn\n     * @return _retVal the amount underlying token returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        //Calculate underlying value\n\n        uint256 _liquidty = totalLiquidity();\n        uint256 _lockup = parameters.getLockup(msg.sender);\n        uint256 _requestTime = withdrawalReq[msg.sender].timestamp;\n        _retVal = (_liquidty * _amount) / totalSupply();\n        require(locked == false, \"ERROR: WITHDRAWAL_PENDING\");\n        require(\n            _requestTime + _lockup < block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n\n        require(\n            _retVal <= withdrawable(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Check current leverage rate and get updated target total credit allocation\n        uint256 _liquidityAfter = _liquidty - _retVal;\n\n        if (_liquidityAfter > 0) {\n            uint256 _leverage = (totalAllocatedCredit * MAGIC_SCALE_1E6) /\n                _liquidityAfter;\n            //execute adjustAlloc only when the leverage became above target + upper-slack\n            if (\n                targetLev + parameters.getUpperSlack(address(this)) < _leverage\n            ) {\n                _adjustAlloc(_liquidityAfter);\n            }\n        } else {\n            _adjustAlloc(0);\n        }\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Get how much can a user withdraw from this index\n     * Withdrawable amount = Index liquidity - necessary amount to support credit liquidity\n     * Necessary amoount Locked * totalAllocPoint / allocpoint of the lowest available liquidity market\n     * Otherwise, the allocation to a specific pool may take up the overall allocation, and may break the risk sharing.\n     * @return _retVal withdrawable amount\n     */\n    function withdrawable() public view returns (uint256 _retVal) {\n        uint256 _totalLiquidity = totalLiquidity();\n        if(_totalLiquidity > 0){\n            uint256 _length = poolList.length;\n            uint256 _lowestAvailableRate = MAGIC_SCALE_1E6;\n            uint256 _targetAllocPoint;\n            uint256 _targetLockedCreditScore;\n            //Check which pool has the lowest available rate and keep stats\n            for (uint256 i = 0; i < _length; i++) {\n                address _poolAddress = poolList[i];\n                uint256 _allocPoint = allocPoints[_poolAddress];\n                if (_allocPoint > 0) {\n                    uint256 _allocated = IPoolTemplate(_poolAddress)\n                        .allocatedCredit(address(this));\n                    uint256 _availableBalance = IPoolTemplate(_poolAddress)\n                        .availableBalance();\n                    //check if some portion of credit is locked\n                    if (_allocated > _availableBalance) {\n                        uint256 _availableRate = (_availableBalance *\n                            MAGIC_SCALE_1E6) / _allocated;\n                        uint256 _lockedCredit = _allocated - _availableBalance;\n                        if (i == 0 || _availableRate < _lowestAvailableRate) {\n                            _lowestAvailableRate = _availableRate;\n                            _targetLockedCreditScore = _lockedCredit;\n                            _targetAllocPoint = _allocPoint;\n                        }\n                    }\n                }\n            }\n            //Calculate the return value\n            if (_lowestAvailableRate == MAGIC_SCALE_1E6) {\n                _retVal = _totalLiquidity;\n            } else {\n                uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;\n                _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev;\n                if(_necessaryAmount < _totalLiquidity){\n                    _retVal = _totalLiquidity - _necessaryAmount;\n                }else{\n                    _retVal = 0;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Adjust allocation of credit based on the target leverage rate\n     */\n    function adjustAlloc() public {\n        _adjustAlloc(totalLiquidity());\n    }\n\n    /**\n     * @notice Internal function to adjust allocation\n     * @param _liquidity available liquidity of the index\n     * Allocation adjustment of credit is done by the following steps\n     * 1)Check total allocatable balance of the index\n     * 2)Calculate ideal allocation for each pool\n     * 3)Check Current allocated balance for each pool\n     * 4)Adjust (withdraw/deposit) allocation for each Pool*\n     *\n     * Liquidity in pool may be locked and cannot withdraw. In that case, the index try to withdraw all available liquidity first,\n     * then recalculated available balance and iterate 1)~4) for the remaining.\n     *\n     * The index may allocate credit beyond the share settings to maintain the leverage rate not to surpass the leverage setting.\n     *\n     * Along with adjustment the index clears accrued premiums in underlying pools to this pool during allocation.\n     */\n    function _adjustAlloc(uint256 _liquidity) internal {\n        //Check current leverage rate and get target total credit allocation\n        uint256 _targetCredit = (targetLev * _liquidity) / MAGIC_SCALE_1E6;\n        uint256 _allocatable = _targetCredit;\n        uint256 _allocatablePoints = totalAllocPoint;\n        uint256 _length = poolList.length;\n        PoolStatus[] memory _poolList = new PoolStatus[](_length);\n\n        //Check each pool and if current credit allocation > target && it is impossible to adjust, then withdraw all availablle credit\n        for (uint256 i = 0; i < _length; i++) {\n            address _pool = poolList[i];\n            if (_pool != address(0)) {\n                uint256 _allocation = allocPoints[_pool];\n                //Target credit allocation for a pool\n                uint256 _target = (_targetCredit * _allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = IPoolTemplate(_pool).allocatedCredit(\n                    address(this)\n                );\n                //get how much liquidty is available to withdraw\n                uint256 _available = IPoolTemplate(_pool).availableBalance();\n                //if needed to withdraw credit but unable, then withdraw all available.\n                //Otherwise, skip.\n                if (\n                    (_current > _target && _current - _target > _available) ||\n                    IPoolTemplate(_pool).paused() == true\n                ) {\n                    IPoolTemplate(_pool).withdrawCredit(_available);\n                    totalAllocatedCredit -= _available;\n                    _poolList[i].addr = address(0);\n                    _allocatable -= _current - _available;\n                    _allocatablePoints -= _allocation;\n                } else {\n                    _poolList[i].addr = _pool;\n                    _poolList[i].current = _current;\n                    _poolList[i].available = _available;\n                    _poolList[i].allocation = _allocation;\n                }\n            }\n        }\n        //Check pools that was not falling under the previous criteria, then adjust to meet the target credit allocation.\n        for (uint256 i = 0; i < _length; i++) {\n            if (_poolList[i].addr != address(0)) {\n                //Target credit allocation for a pool\n                uint256 _target = (_allocatable * _poolList[i].allocation) /\n                    _allocatablePoints;\n                //get how much has been allocated for a pool\n                uint256 _current = _poolList[i].current;\n                //get how much liquidty is available to withdraw\n                uint256 _available = _poolList[i].available;\n                //Withdraw or Deposit credit\n                if (_current > _target && _available != 0) {\n                    //if allocated credit is higher than the target, try to decrease\n                    uint256 _decrease = _current - _target;\n                    IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);\n                    totalAllocatedCredit -= _decrease;\n                }\n                if (_current < _target) {\n                    //Sometimes we need to allocate more\n                    uint256 _allocate = _target - _current;\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);\n                    totalAllocatedCredit += _allocate;\n                }\n                if (_current == _target) {\n                    IPoolTemplate(_poolList[i].addr).allocateCredit(0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Make a payout if an accident occured in a underlying pool\n     * @param _amount amount of liquidity to compensate for the called pool\n     * We compensate underlying pools by the following steps\n     * 1) Compensate underlying pools from the liquidity of this pool\n     * 2) If this pool is unable to cover a compensation, can get compensated from the CDS pool\n     */\n    function compensate(uint256 _amount)\n        external\n        override\n        returns (uint256 _compensated)\n    {\n        require(\n            allocPoints[msg.sender] > 0,\n            \"ERROR_COMPENSATE_UNAUTHORIZED_CALLER\"\n        );\n        uint256 _value = vault.underlyingValue(address(this));\n        if (_value >= _amount) {\n            //When the deposited value without earned premium is enough to cover\n            vault.offsetDebt(_amount, msg.sender);\n            //vault.transferValue(_amount, msg.sender);\n            _compensated = _amount;\n        } else {\n            //Withdraw credit to cashout the earnings\n            uint256 _shortage;\n            if (totalLiquidity() < _amount) {\n                //Insolvency case\n                _shortage = _amount - _value;\n                uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))\n                    .compensate(_shortage);\n                _compensated = _value + _cds;\n            }\n            vault.offsetDebt(_compensated, msg.sender);\n        }\n        adjustAlloc();\n        emit Compensated(msg.sender, _compensated);\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Resume market\n     */\n    function resume() external override {\n        uint256 _poolLength = poolList.length;\n\n        for (uint256 i = 0; i < _poolLength; i++) {\n            require(\n                IPoolTemplate(poolList[i]).paused() == false,\n                \"ERROR: POOL_IS_PAUSED\"\n            );\n        }\n\n        locked = false;\n        emit Resumed();\n    }\n\n    /**\n     * @notice lock market withdrawal\n     */\n    function lock() external override {\n        require(allocPoints[msg.sender] > 0);\n\n        locked = true;\n        emit Locked();\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice get the current leverage rate 1e6x\n     * @return _rate leverage rate\n     */\n    function leverage() public view returns (uint256 _rate) {\n        //check current leverage rate\n        if (totalLiquidity() > 0) {\n            return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice total Liquidity of the pool (how much can the pool sell cover)\n     * @return _balance total liquidity of the pool\n     */\n    function totalLiquidity() public view returns (uint256 _balance) {\n        return vault.underlyingValue(address(this)) + _accruedPremiums();\n    }\n\n    /**\n     * @notice Get the exchange rate of LP token against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying token balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying token for the specified address\n     */\n    function valueOfUnderlying(address _owner) public view returns (uint256) {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * totalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get all underlying pools\n     * @return pool array\n     */\n    function getAllPools() external view returns (address[] memory) {\n        return poolList;\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * @notice Change target leverate rate for this index x 1e6\n     * @param _target new leverage rate\n     */\n    function setLeverage(uint256 _target) external override onlyOwner {\n        targetLev = _target;\n        adjustAlloc();\n        emit LeverageSet(_target);\n    }\n\n    /**\n     * @notice Change allocation point for each pool\n     * @param _index target id of the underlying pool\n     * @param _pool address of pool\n     * @param _allocPoint new allocation point\n     */\n    function set(\n        uint256 _index,\n        address _pool,\n        uint256 _allocPoint\n    ) public override onlyOwner {\n        require(registry.isListed(_pool), \"ERROR:UNREGISTERED_POOL\");\n        require(\n            _index <= parameters.getMaxList(address(this)),\n            \"ERROR: EXCEEEDED_MAX_INDEX\"\n        );\n        uint256 _length = poolList.length;\n\n        //create a new pool or replace existing\n        if (_length <= _index) {\n            require(_length == _index, \"ERROR: BAD_INDEX\");\n            poolList.push(_pool);\n        } else {\n            address _poolAddress = poolList[_index];\n            if (_poolAddress != address(0) && _poolAddress != _pool) {\n                uint256 _current = IPoolTemplate(_poolAddress).allocatedCredit(\n                    address(this)\n                );\n                IPoolTemplate(_poolAddress).withdrawCredit(_current);\n            }\n            poolList[_index] = _pool;\n        }\n        if (totalAllocPoint > 0) {\n            totalAllocPoint =\n                totalAllocPoint -\n                allocPoints[_pool] +\n                _allocPoint;\n        } else {\n            totalAllocPoint = _allocPoint;\n        }\n        allocPoints[_pool] = _allocPoint;\n        adjustAlloc();\n        emit AllocationSet(_index, _pool, _allocPoint);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of token to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Get the total equivalent value of credit to token\n     * @return _totalValue accrued but yet claimed premium within underlying pools\n     */\n    function _accruedPremiums() internal view returns (uint256 _totalValue) {\n        for (uint256 i = 0; i < poolList.length; i++) {\n            if (allocPoints[poolList[i]] > 0) {\n                _totalValue =\n                    _totalValue +\n                    IPoolTemplate(poolList[i]).pendingPremium(address(this));\n            }\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "IndexTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "IndexTemplate.sol#compensate()",
                "Type": "Precision loss while converting between the amount of shares and the amount of underlying tokens back and forth",
                "Description": "While CDSTemplate.sol#compensate() takes a parameter for the amount of underlying tokens, it uses vault.transferValue() to transfer corresponding _attributions (shares) instead of underlying tokens. Due to precision loss, the _attributions transferred in the terms of underlying tokens will most certainly be less than the shortage.",
                "Repair": "Change the code to handle precision loss properly"
            },
            {
                "Location": "IndexTemplate.sol",
                "Type": "Smart Contract Vulnerability",
                "Description": "Index compensate is 0 when totalLiquidity() is enough to cover the whole amount.",
                "Repair": "Set the value of _compensated to 0 when _amount is equal to _value and <= totalLiquidity(), and try to redeem the premium to cover the whole amount"
            },
            {
                "Location": "IndexTemplate.sol",
                "Type": "Smart Contract Vulnerability",
                "Description": "Wrong implementation allows lp of the index pool to resume a locked PayingOut pool and escape the responsibility for the compensation.",
                "Repair": "Change the condition in resume() to check if the market status is Trading instead of checking if the pool is paused"
            }
        ]
    },
    {
        "Code": "/**\n * @title Factory\n * @author @InsureDAO\n * @notice This contract is the functory contract that manages functions related to market creation activities.\n * SPDX-License-Identifier: GPL-3.0\n */\n\npragma solidity 0.8.7;\n\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Factory is IFactory {\n    event MarketCreated(\n        address indexed market,\n        address indexed template,\n        string _metaData,\n        uint256[] conditions,\n        address[] references\n    );\n    event TemplateApproval(\n        IUniversalMarket indexed template,\n        bool approval,\n        bool isOpen,\n        bool duplicate\n    );\n    event ReferenceApproval(\n        IUniversalMarket indexed template,\n        uint256 indexed slot,\n        address target,\n        bool approval\n    );\n    event ConditionApproval(\n        IUniversalMarket indexed template,\n        uint256 indexed slot,\n        uint256 target\n    );\n\n    address[] public markets;\n\n    struct Template {\n        bool isOpen; //true if the market allows anyone to create a market\n        bool approval; //true if the template exists\n        bool allowDuplicate; //true if the market with same ID is allowed\n    }\n    mapping(address => Template) public templates;\n    //mapping of authorized market template address\n\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        public reflist;\n    //Authorized reference(address) list for market market template\n    //Each template has different set of references\n    //true if that address is authorized within the template\n    // Example reference list for pool template v1\n    // references[0] = target governance token address\n    // references[1] = underlying token address\n    // references[2] = registry\n    // references[3] = parameter\n\n    mapping(address => mapping(uint256 => uint256)) public conditionlist;\n    //Authorized condition(uint256) list for market temaplate\n    //Each template has different set of conditions\n    //true if that address is authorized within the template\n    // Example condition list for pool template v1\n    // conditions[0] = minimim deposit amount\n\n    address public registry;\n    IOwnership public ownership;\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor(address _registry, address _ownership) {\n        registry = _registry;\n        ownership = IOwnership(_ownership);\n    }\n\n    /**\n     * @notice A function to approve or disapprove templates.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _approval true if a market is allowed to create based on the template\n     * @param _isOpen true if anyone can create a market based on the template\n     * @param _duplicate true if a market with duplicate target id is allowed\n     */\n    function approveTemplate(\n        IUniversalMarket _template,\n        bool _approval,\n        bool _isOpen,\n        bool _duplicate\n    ) external override onlyOwner {\n        require(address(_template) != address(0));\n        templates[address(_template)].approval = _approval;\n        templates[address(_template)].isOpen = _isOpen;\n        templates[address(_template)].allowDuplicate = _duplicate;\n        emit TemplateApproval(_template, _approval, _isOpen, _duplicate);\n    }\n\n    /**\n     * @notice A function to preset reference.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _slot the index within reference array\n     * @param _target the reference  address\n     * @param _approval true if the reference is approved\n     */\n    function approveReference(\n        IUniversalMarket _template,\n        uint256 _slot,\n        address _target,\n        bool _approval\n    ) external override onlyOwner {\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        reflist[address(_template)][_slot][_target] = _approval;\n        emit ReferenceApproval(_template, _slot, _target, _approval);\n    }\n\n    /**\n     * @notice A function to preset reference.\n     * Only owner of the contract can operate.\n     * @param _template template address, which must be registered\n     * @param _slot the index within condition array\n     * @param _target the condition uint\n     */\n    function setCondition(\n        IUniversalMarket _template,\n        uint256 _slot,\n        uint256 _target\n    ) external override onlyOwner {\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        conditionlist[address(_template)][_slot] = _target;\n        emit ConditionApproval(_template, _slot, _target);\n    }\n\n    /**\n     * @notice A function to create markets.\n     * This function is market model agnostic.\n     * @param _template template address, which must be registered\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     * @return created market address\n     */\n    function createMarket(\n        IUniversalMarket _template,\n        string memory _metaData,\n        uint256[] memory _conditions,\n        address[] memory _references\n    ) public override returns (address) {\n        //check eligibility\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        if (templates[address(_template)].isOpen == false) {\n            require(\n                ownership.owner() == msg.sender,\n                \"ERROR: UNAUTHORIZED_SENDER\"\n            );\n        }\n        if (_references.length > 0) {\n            for (uint256 i = 0; i < _references.length; i++) {\n                require(\n                    reflist[address(_template)][i][_references[i]] == true ||\n                        reflist[address(_template)][i][address(0)] == true,\n                    \"ERROR: UNAUTHORIZED_REFERENCE\"\n                );\n            }\n        }\n\n        if (_conditions.length > 0) {\n            for (uint256 i = 0; i < _conditions.length; i++) {\n                if (conditionlist[address(_template)][i] > 0) {\n                    _conditions[i] = conditionlist[address(_template)][i];\n                }\n            }\n        }\n\n        if (\n            IRegistry(registry).confirmExistence(\n                address(_template),\n                _references[0]\n            ) == false\n        ) {\n            IRegistry(registry).setExistence(\n                address(_template),\n                _references[0]\n            );\n        } else {\n            if (templates[address(_template)].allowDuplicate == false) {\n                revert(\"ERROR: DUPLICATE_MARKET\");\n            }\n        }\n\n        //create market\n        IUniversalMarket market = IUniversalMarket(\n            _createClone(address(_template))\n        );\n\n        IRegistry(registry).supportMarket(address(market));\n        \n        markets.push(address(market));\n\n\n        //initialize\n        market.initialize(_metaData, _conditions, _references);\n\n        emit MarketCreated(\n            address(market),\n            address(_template),\n            _metaData,\n            _conditions,\n            _references\n        );\n\n        return address(market);\n    }\n\n    /**\n     * @notice Template Code for the create clone method:\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\n     */\n    function _createClone(address target) internal returns (address result) {\n        // convert address to bytes20 for assembly use\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            // allocate clone memory\n            let clone := mload(0x40)\n            // store initial portion of the delegation contract code in bytes form\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            // store the provided address\n            mstore(add(clone, 0x14), targetBytes)\n            // store the remaining delegation contract code\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            // create the actual delegate contract reference and return its address\n            result := create(0, clone, 0x37)\n        }\n    }\n}\n\n\npragma solidity 0.8.7;\n\n/**\n * @author InsureDAO\n * @title InsureDAO pool template contract\n * SPDX-License-Identifier: GPL-3.0\n */\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./InsureDAOERC20.sol\";\nimport \"./interfaces/IPoolTemplate.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\n\nimport \"./interfaces/IParameters.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IIndexTemplate.sol\";\n\ncontract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {\n    /**\n     * EVENTS\n     */\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Unlocked(uint256 indexed id, uint256 amount);\n    event Insured(\n        uint256 indexed id,\n        uint256 amount,\n        bytes32 target,\n        uint256 startTime,\n        uint256 endTime,\n        address insured,\n        uint256 premium\n    );\n    event Redeemed(\n        uint256 indexed id,\n        address insured,\n        bytes32 target,\n        uint256 amount,\n        uint256 payout\n    );\n    event CoverApplied(\n        uint256 pending,\n        uint256 payoutNumerator,\n        uint256 payoutDenominator,\n        uint256 incidentTimestamp,\n        bytes32 merkleRoot,\n        string rawdata,\n        string memo\n    );\n    event TransferInsurance(uint256 indexed id, address from, address to);\n    event CreditIncrease(address indexed depositor, uint256 credit);\n    event CreditDecrease(address indexed withdrawer, uint256 credit);\n    event MarketStatusChanged(MarketStatus statusValue);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    /**\n     * Storage\n     */\n    /// @notice Market setting\n    bool public initialized;\n    bool public override paused;\n    string public metadata;\n\n    /// @notice External contract call addresses\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n\n    /// @notice Market variables\n    uint256 public attributionDebt; //pool's attribution for indices\n    uint256 public override lockedAmount; //Liquidity locked when utilized\n    uint256 public override totalCredit; //Liquidity from index\n    uint256 public rewardPerCredit; //Times MAGIC_SCALE_1E6. To avoid reward decimal truncation *See explanation below.\n    uint256 public pendingEnd; //pending time when paying out\n\n    /// @notice Market variables for margin account\n    struct IndexInfo {\n        uint256 credit; //How many credit (equal to liquidity) the index has allocated\n        uint256 rewardDebt; // Reward debt. *See explanation below.\n        bool exist; //true if the index has allocated credit\n    }\n\n    mapping(address => IndexInfo) public indicies;\n    address[] public indexList;\n\n    //\n    // * We do some fancy math for premium calculation of indicies.\n    // Basically, any point in time, the amount of premium entitled to an index but is pending to be distributed is:\n    //\n    //   pending reward = (index.credit * rewardPerCredit) - index.rewardDebt\n    //\n    // When the pool receives premium, it updates rewardPerCredit\n    //\n    // Whenever an index deposits, withdraws credit to a pool, Here's what happens:\n    //   1. The index receives the pending reward sent to the index vault.\n    //   2. The index's rewardDebt get updated.\n    //\n    // This mechanism is widely used (e.g. SushiSwap: MasterChef.sol)\n    //\n\n    ///@notice Market status transition management\n    enum MarketStatus {\n        Trading,\n        Payingout\n    }\n    MarketStatus public marketStatus;\n\n    ///@notice user's withdrawal status management\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    ///@notice insurance status management\n    struct Insurance {\n        uint256 id; //each insuance has their own id\n        uint256 startTime; //timestamp of starttime\n        uint256 endTime; //timestamp of endtime\n        uint256 amount; //insured amount\n        bytes32 target; //target id in bytes32\n        address insured; //the address holds the right to get insured\n        bool status; //true if insurance is not expired or redeemed\n    }\n    mapping(uint256 => Insurance) public insurances;\n    uint256 public allInsuranceCount;\n\n    ///@notice incident status management\n    struct Incident {\n        uint256 payoutNumerator;\n        uint256 payoutDenominator;\n        uint256 incidentTimestamp;\n        bytes32 merkleRoot;\n    }\n    Incident public incident;\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n\n    /**\n     * Initialize interaction\n     */\n\n    /**\n     * @notice Initialize market\n     * This function registers market conditions.\n     * references[0] = target governance token address\n     * references[1] = underlying token address\n     * references[2] = registry\n     * references[3] = parameter\n     * references[4] = initialDepositor\n     * conditions[0] = minimim deposit amount defined by the factory\n     * conditions[1] = initial deposit amount defined by the creator\n     * @param _metaData arbitrary string to store market information\n     * @param _conditions array of conditions\n     * @param _references array of references\n     */\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0) &&\n                _references[3] != address(0) &&\n                _references[4] != address(0) &&\n                _conditions[0] <= _conditions[1],\n            \"ERROR: INITIALIZATION_BAD_CONDITIONS\"\n        );\n        initialized = true;\n\n        string memory _name = string(\n            abi.encodePacked(\n                \"InsureDAO-\",\n                IERC20Metadata(_references[1]).name(),\n                \"-PoolInsurance\"\n            )\n        );\n        string memory _symbol = string(\n            abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())\n        );\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        registry = IRegistry(_references[2]);\n        parameters = IParameters(_references[3]);\n        vault = IVault(parameters.getVault(_references[1]));\n\n        metadata = _metaData;\n\n        marketStatus = MarketStatus.Trading;\n\n        if (_conditions[1] > 0) {\n            _depositFrom(_conditions[1], _references[4]);\n        }\n    }\n\n    /**\n     * Pool interactions\n     */\n\n    /**\n     * @notice A liquidity provider supplies tokens to the pool and receives iTokens\n     * @param _amount amount of tokens to deposit\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, msg.sender, address(this));\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n\n    /**\n     * @notice Internal deposit function that allows third party to deposit\n     * @param _amount amount of tokens to deposit\n     * @param _from deposit beneficiary's address\n     * @return _mintAmount the amount of iTokens minted from the transaction\n     */\n    function _depositFrom(uint256 _amount, address _from)\n        internal\n        returns (uint256 _mintAmount)\n    {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            \"ERROR: DEPOSIT_DISABLED\"\n        );\n        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, _from, address(this));\n\n        emit Deposit(_from, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(_from, _mintAmount);\n    }\n\n    /**\n     * @notice A liquidity provider request withdrawal of collateral\n     * @param _amount amount of iTokens to burn\n     */\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");\n        require(_amount > 0, \"ERROR: REQUEST_ZERO\");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice A liquidity provider burns iTokens and receives collateral from the pool\n     * @param _amount amount of iTokens to burn\n     * @return _retVal the amount underlying tokens returned\n     */\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        uint256 _supply = totalSupply();\n        require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");\n\n        uint256 _liquidity = originalLiquidity();\n        _retVal = (_amount * _liquidity) / _supply;\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: WITHDRAWAL_PENDING\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_QUEUE\"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"\n        );\n        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");\n        require(\n            _retVal <= availableBalance(),\n            \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"\n        );\n        //reduce requested amount\n        withdrawalReq[msg.sender].amount -= _amount;\n\n        //Burn iToken\n        _burn(msg.sender, _amount);\n\n        //Withdraw liquidity\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n\n    /**\n     * @notice Unlocks an array of insurances\n     * @param _ids array of ids to unlock\n     */\n    function unlockBatch(uint256[] calldata _ids) external {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            unlock(_ids[i]);\n        }\n    }\n\n    /**\n     * @notice Unlock funds locked in the expired insurance\n     * @param _id id of the insurance policy to unlock liquidity\n     */\n    function unlock(uint256 _id) public {\n        require(\n            insurances[_id].status == true &&\n                marketStatus == MarketStatus.Trading &&\n                insurances[_id].endTime + parameters.getGrace(msg.sender) <\n                block.timestamp,\n            \"ERROR: UNLOCK_BAD_COINDITIONS\"\n        );\n        insurances[_id].status == false;\n\n        lockedAmount = lockedAmount - insurances[_id].amount;\n\n        emit Unlocked(_id, insurances[_id].amount);\n    }\n\n    /**\n     * Index interactions\n     */\n\n    /**\n     * @notice Allocate credit from an index. Allocated credits are deemed as equivalent liquidity as real token deposits.\n     * @param _credit credit (liquidity amount) to be added to this pool\n     * @return _pending pending preium for the caller index\n     */\n\n    function allocateCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            \"ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS\"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        if (_index.exist == false) {\n            _index.exist = true;\n            indexList.push(msg.sender);\n        } else if (_index.credit > 0) {\n            _pending = _sub(\n                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n                _index.rewardDebt\n            );\n            if (_pending > 0) {\n                vault.transferAttribution(_pending, msg.sender);\n                attributionDebt -= _pending;\n            }\n        }\n        if (_credit > 0) {\n            totalCredit += _credit;\n            _index.credit += _credit;\n            emit CreditIncrease(msg.sender, _credit);\n        }\n        _index.rewardDebt =\n            (_index.credit * _rewardPerCredit) /\n            MAGIC_SCALE_1E6;\n    }\n\n    /**\n     * @notice An index withdraw credit and earn accrued premium\n     * @param _credit credit (liquidity amount) to be withdrawn from this pool\n     * @return _pending pending preium for the caller index\n     */\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        require(\n            IRegistry(registry).isListed(msg.sender) &&\n                _index.credit >= _credit &&\n                _credit <= availableBalance(),\n            \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"\n        );\n\n        //calculate acrrued premium\n        _pending = _sub(\n            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n            _index.rewardDebt\n        );\n\n        //Withdraw liquidity\n        if (_credit > 0) {\n            totalCredit -= _credit;\n            _index.credit -= _credit;\n            emit CreditDecrease(msg.sender, _credit);\n        }\n\n        //withdraw acrrued premium\n        if (_pending > 0) {\n            vault.transferAttribution(_pending, msg.sender);\n            attributionDebt -= _pending;\n            _index.rewardDebt =\n                (_index.credit * _rewardPerCredit) /\n                MAGIC_SCALE_1E6;\n        }\n    }\n\n    /**\n     * Insurance interactions\n     */\n\n    /**\n     * @notice Get insured for the specified amount for specified span\n     * @param _amount target amount to get covered\n     * @param _maxCost maximum cost to pay for the premium. revert if the premium is higher\n     * @param _span length to get covered(e.g. 7 days)\n     * @param _target target id\n     * @return id of the insurance policy\n     */\n    function insure(\n        uint256 _amount,\n        uint256 _maxCost,\n        uint256 _span,\n        bytes32 _target\n    ) external returns (uint256) {\n        //Distribute premium and fee\n        uint256 _endTime = _span + block.timestamp;\n        uint256 _premium = getPremium(_amount, _span);\n        uint256 _fee = parameters.getFeeRate(msg.sender);\n\n        require(\n            _amount <= availableBalance(),\n            \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"\n        );\n        require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");\n        require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");\n        require(\n            parameters.getMinDate(msg.sender) <= _span,\n            \"ERROR: INSURE_SPAN_BELOW_MIN\"\n        );\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            \"ERROR: INSURE_MARKET_PENDING\"\n        );\n        require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");\n\n        //current liquidity\n        uint256 _liquidity = totalLiquidity();\n        uint256 _totalCredit = totalCredit;\n\n        //accrue premium/fee\n        uint256[2] memory _newAttribution = vault.addValueBatch(\n            _premium,\n            msg.sender,\n            [address(this), parameters.getOwner()],\n            [MAGIC_SCALE_1E6 - _fee, _fee]\n        );\n\n        //Lock covered amount\n        uint256 _id = allInsuranceCount;\n        lockedAmount += _amount;\n        Insurance memory _insurance = Insurance(\n            _id,\n            block.timestamp,\n            _endTime,\n            _amount,\n            _target,\n            msg.sender,\n            true\n        );\n        insurances[_id] = _insurance;\n        allInsuranceCount += 1;\n\n        //Calculate liquidity for index\n        if (_totalCredit > 0) {\n            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /\n                _liquidity;\n            attributionDebt += _attributionForIndex;\n            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /\n                _totalCredit);\n        }\n\n        emit Insured(\n            _id,\n            _amount,\n            _target,\n            block.timestamp,\n            _endTime,\n            msg.sender,\n            _premium\n        );\n\n        return _id;\n    }\n\n    /**\n     * @notice Redeem an insurance policy\n     * @param _id the id of the insurance policy\n     * @param _merkleProof merkle proof (similar to \"verify\" function of MerkleProof.sol of OpenZeppelin\n     * Ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol\n     */\n    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {\n        Insurance storage _insurance = insurances[_id];\n        require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");\n\n        uint256 _payoutNumerator = incident.payoutNumerator;\n        uint256 _payoutDenominator = incident.payoutDenominator;\n        uint256 _incidentTimestamp = incident.incidentTimestamp;\n        bytes32 _targets = incident.merkleRoot;\n\n        require(\n            marketStatus == MarketStatus.Payingout,\n            \"ERROR: NO_APPLICABLE_INCIDENT\"\n        );\n        require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                _insurance.startTime <= _incidentTimestamp &&\n                _insurance.endTime >= _incidentTimestamp,\n            \"ERROR: INSURANCE_NOT_APPLICABLE\"\n        );\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                _targets,\n                keccak256(\n                    abi.encodePacked(_insurance.target, _insurance.insured)\n                )\n            ) ||\n                MerkleProof.verify(\n                    _merkleProof,\n                    _targets,\n                    keccak256(abi.encodePacked(_insurance.target, address(0)))\n                ),\n            \"ERROR: INSURANCE_EXEMPTED\"\n        );\n        _insurance.status = false;\n        lockedAmount -= _insurance.amount;\n\n        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /\n            _payoutDenominator;\n\n        vault.borrowValue(_payoutAmount, msg.sender);\n\n        emit Redeemed(\n            _id,\n            msg.sender,\n            _insurance.target,\n            _insurance.amount,\n            _payoutAmount\n        );\n    }\n\n    /**\n     * @notice Transfers an active insurance\n     * @param _id id of the insurance policy\n     * @param _to receipient of of the policy\n     */\n    function transferInsurance(uint256 _id, address _to) external {\n        Insurance storage insurance = insurances[_id];\n\n        require(\n            _to != address(0) &&\n                insurance.insured == msg.sender &&\n                insurance.endTime >= block.timestamp &&\n                insurance.status == true,\n            \"ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS\"\n        );\n\n        insurance.insured = _to;\n        emit TransferInsurance(_id, msg.sender, _to);\n    }\n\n    /**\n     * @notice Get how much premium for the specified amount and span\n     * @param _amount amount to get insured\n     * @param _span span to get covered\n     */\n    function getPremium(uint256 _amount, uint256 _span)\n        public\n        view\n        returns (uint256 premium)\n    {\n        return\n            parameters.getPremium(\n                _amount,\n                _span,\n                totalLiquidity(),\n                lockedAmount,\n                address(this)\n            );\n    }\n\n    /**\n     * Reporting interactions\n     */\n\n    /**\n     * @notice Decision to make a payout\n     * @param _pending length of time to allow policyholders to redeem their policy\n     * @param _payoutNumerator Numerator of the payout *See below\n     * @param _payoutDenominator Denominator of the payout *See below\n     * @param _incidentTimestamp Unixtimestamp of the incident\n     * @param _merkleRoot Merkle root of the payout id list\n     * @param _rawdata raw data before the data set is coverted to merkle tree (to be emi\uff54ted within event)\n     * @param _memo additional memo for the payout report (to be emmited within event)\n     * payout ratio is determined by numerator/denominator (e.g. 50/100 = 50% payout\n     */\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external override onlyOwner {\n        require(paused == false, \"ERROR: UNABLE_TO_APPLY\");\n        incident.payoutNumerator = _payoutNumerator;\n        incident.payoutDenominator = _payoutDenominator;\n        incident.incidentTimestamp = _incidentTimestamp;\n        incident.merkleRoot = _merkleRoot;\n        marketStatus = MarketStatus.Payingout;\n        pendingEnd = block.timestamp + _pending;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            if (indicies[indexList[i]].credit > 0) {\n                IIndexTemplate(indexList[i]).lock();\n            }\n        }\n        emit CoverApplied(\n            _pending,\n            _payoutNumerator,\n            _payoutDenominator,\n            _incidentTimestamp,\n            _merkleRoot,\n            _rawdata,\n            _memo\n        );\n        emit MarketStatusChanged(marketStatus);\n    }\n\n    /**\n     * @notice Anyone can resume the market after a pending period ends\n     */\n    function resume() external {\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                pendingEnd < block.timestamp,\n            \"ERROR: UNABLE_TO_RESUME\"\n        );\n\n        uint256 _debt = vault.debts(address(this));\n        uint256 _totalCredit = totalCredit;\n        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n        uint256 _actualDeduction;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            address _index = indexList[i];\n            uint256 _credit = indicies[_index].credit;\n            if (_credit > 0) {\n                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                    _totalCredit;\n                uint256 _redeemAmount = _divCeil(\n                    _deductionFromIndex,\n                    _shareOfIndex\n                );\n                _actualDeduction += IIndexTemplate(_index).compensate(\n                    _redeemAmount\n                );\n            }\n        }\n\n        uint256 _deductionFromPool = _debt -\n            _deductionFromIndex /\n            MAGIC_SCALE_1E6;\n        uint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n\n        if (_deductionFromPool > 0) {\n            vault.offsetDebt(_deductionFromPool, address(this));\n        }\n\n        vault.transferDebt(_shortage);\n\n        marketStatus = MarketStatus.Trading;\n        emit MarketStatusChanged(MarketStatus.Trading);\n    }\n\n    /**\n     * Utilities\n     */\n\n    /**\n     * @notice Get the exchange rate of LP tokens against underlying asset(scaled by MAGIC_SCALE_1E6)\n     * @return The value against the underlying tokens balance.\n     */\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @param _owner the target address to look up value\n     * @return The balance of underlying tokens for the specified address\n     */\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * originalLiquidity()) / totalSupply();\n        }\n    }\n\n    /**\n     * @notice Get the accrued value for an index\n     * @param _index the address of index\n     * @return The pending premium for the specified index\n     */\n    function pendingPremium(address _index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _credit = indicies[_index].credit;\n        if (_credit == 0) {\n            return 0;\n        } else {\n            return\n                _sub(\n                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,\n                    indicies[_index].rewardDebt\n                );\n        }\n    }\n\n    /**\n     * @notice Get token number for the specified underlying value\n     * @param _value amount of iToken\n     * @return _amount The balance of underlying tokens for the specified amount\n     */\n    function worth(uint256 _value) public view returns (uint256 _amount) {\n        uint256 _supply = totalSupply();\n        uint256 _originalLiquidity = originalLiquidity();\n        if (_supply > 0 && _originalLiquidity > 0) {\n            _amount = (_value * _supply) / _originalLiquidity;\n        } else if (_supply > 0 && _originalLiquidity == 0) {\n            _amount = _value * _supply;\n        } else {\n            _amount = _value;\n        }\n    }\n\n    /**\n     * @notice Get allocated credit\n     * @param _index address of an index\n     * @return The balance of credit allocated by the specified index\n     */\n    function allocatedCredit(address _index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return indicies[_index].credit;\n    }\n\n    /**\n     * @notice Returns the amount of underlying tokens available for withdrawals\n     * @return _balance available liquidity of this pool\n     */\n    function availableBalance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        if (totalLiquidity() > 0) {\n            return totalLiquidity() - lockedAmount;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Returns the utilization rate for this pool. Scaled by 1e6 (100% = 1e6)\n     * @return _rate utilization rate\n     */\n    function utilizationRate() public view override returns (uint256 _rate) {\n        if (lockedAmount > 0) {\n            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Pool's Liquidity + Liquidity from Index (how much can the pool sell cover)\n     * @return _balance total liquidity of this pool\n     */\n    function totalLiquidity() public view override returns (uint256 _balance) {\n        return originalLiquidity() + totalCredit;\n    }\n\n    /**\n     * @notice Pool's Liquidity\n     * @return _balance total liquidity of this pool\n     */\n    function originalLiquidity() public view returns (uint256 _balance) {\n        return\n            vault.underlyingValue(address(this)) -\n            vault.attributionValue(attributionDebt);\n    }\n\n    /**\n     * Admin functions\n     */\n\n    /**\n     * @notice Used for changing settlementFeeRecipient\n     * @param _state true to set paused and vice versa\n     */\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n\n    /**\n     * @notice Change metadata string\n     * @param _metadata new metadata string\n     */\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n\n    /**\n     * Internal functions\n     */\n\n    /**\n     * @notice Internal function to offset withdraw request and latest balance\n     * @param from the account who send\n     * @param to a\n     * @param amount the amount of tokens to offset\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n\n    /**\n     * @notice Internal function for safe division\n     */\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n\n    /**\n     * @notice Internal function for overflow free subtraction\n     */\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return 0;\n        } else {\n            return a - b;\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "Factory.sol",
            "PoolTemplate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Factory.createMarket(), PoolTemplate.initialize()",
                "Type": "Malicious Market Creation",
                "Description": "A malicious market creator can abuse PoolTemplate.initialize() as it makes a vault deposit from an account that they control.",
                "Repair": "Parse a _creator address to PoolTemplate.sol which will act as the depositor and be set to msg.sender in Factory.createMarket()"
            }
        ]
    }
]