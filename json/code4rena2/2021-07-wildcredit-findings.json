[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) 2021 0xdev0 - All rights reserved\n// https://twitter.com/0xdev0\n\npragma solidity ^0.8.0;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/ILPTokenMaster.sol';\nimport './interfaces/ILendingPair.sol';\nimport './interfaces/IController.sol';\nimport './interfaces/IRewardDistribution.sol';\nimport './interfaces/IInterestRateModel.sol';\n\nimport './external/Math.sol';\nimport './external/Ownable.sol';\nimport './external/Address.sol';\nimport './external/Clones.sol';\nimport './external/ERC20.sol';\n\nimport './TransferHelper.sol';\n\ncontract LendingPair is TransferHelper {\n\n  // Prevents division by zero and other undesirable behaviour\n  uint public constant MIN_RESERVE = 1000;\n\n  using Address for address;\n  using Clones for address;\n\n  mapping (address => mapping (address => uint)) public debtOf;\n  mapping (address => mapping (address => uint)) public accountInterestSnapshot;\n  mapping (address => uint) public cumulativeInterestRate; // 100e18 = 100%\n  mapping (address => uint) public totalDebt;\n  mapping (address => IERC20) public lpToken;\n\n  IController public controller;\n  address public tokenA;\n  address public tokenB;\n  uint public lastBlockAccrued;\n\n  event Liquidation(\n    address indexed account,\n    address indexed repayToken,\n    address indexed supplyToken,\n    uint repayAmount,\n    uint supplyAmount\n  );\n\n  event Deposit(address indexed account, address indexed token, uint amount);\n  event Withdraw(address indexed token, uint amount);\n  event Borrow(address indexed token, uint amount);\n  event Repay(address indexed account, address indexed token, uint amount);\n\n  receive() external payable {}\n\n  function initialize(\n    address _lpTokenMaster,\n    address _controller,\n    IERC20 _tokenA,\n    IERC20 _tokenB\n  ) external {\n    require(address(tokenA) == address(0), \"LendingPair: already initialized\");\n    require(address(_tokenA) != address(0) && address(_tokenB) != address(0), \"LendingPair: cannot be ZERO address\");\n\n    controller = IController(_controller);\n    tokenA = address(_tokenA);\n    tokenB = address(_tokenB);\n    lastBlockAccrued = block.number;\n\n    lpToken[tokenA] = _createLpToken(_lpTokenMaster);\n    lpToken[tokenB] = _createLpToken(_lpTokenMaster);\n  }\n\n  function depositRepay(address _account, address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    _depositRepay(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function depositRepayETH(address _account) external payable {\n    accrueAccount(_account);\n\n    _depositRepay(_account, address(WETH), msg.value);\n    _depositWeth();\n  }\n\n  function deposit(address _account, address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    _deposit(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function withdrawBorrow(address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    _withdrawBorrow(_token, _amount);\n    _safeTransfer(IERC20(_token), msg.sender, _amount);\n  }\n\n  function withdrawBorrowETH(uint _amount) external {\n    accrueAccount(msg.sender);\n\n    _withdrawBorrow(address(WETH), _amount);\n    _wethWithdrawTo(msg.sender, _amount);\n    _checkMinReserve(address(WETH));\n  }\n\n  function withdraw(address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    _withdraw(_token, _amount);\n    _safeTransfer(IERC20(_token), msg.sender, _amount);\n  }\n\n  function withdrawAll(address _token) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    uint amount = lpToken[address(_token)].balanceOf(msg.sender);\n    _withdraw(_token, amount);\n    _safeTransfer(IERC20(_token), msg.sender, amount);\n  }\n\n  function withdrawAllETH() external {\n    accrueAccount(msg.sender);\n\n    uint amount = lpToken[address(WETH)].balanceOf(msg.sender);\n    _withdraw(address(WETH), amount);\n    _wethWithdrawTo(msg.sender, amount);\n  }\n\n  function borrow(address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(msg.sender);\n\n    _borrow(_token, _amount);\n    _safeTransfer(IERC20(_token), msg.sender, _amount);\n  }\n\n  function repayAll(address _account, address _token) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    uint amount = debtOf[_token][_account];\n    _repay(_account, _token, amount);\n    _safeTransferFrom(_token, msg.sender, amount);\n  }\n\n  function repayAllETH(address _account) external payable {\n    accrueAccount(_account);\n\n    uint amount = debtOf[address(WETH)][_account];\n    require(msg.value >= amount, \"LendingPair: insufficient ETH deposit\");\n\n    _depositWeth();\n    _repay(_account, address(WETH), amount);\n    uint refundAmount = msg.value > amount ? (msg.value - amount) : 0;\n\n    if (refundAmount > 0) {\n      _wethWithdrawTo(msg.sender, refundAmount);\n    }\n  }\n\n  function repay(address _account, address _token, uint _amount) external {\n    _validateToken(_token);\n    accrueAccount(_account);\n\n    _repay(_account, _token, _amount);\n    _safeTransferFrom(_token, msg.sender, _amount);\n  }\n\n  function accrue() public {\n    if (lastBlockAccrued < block.number) {\n      _accrueInterest(tokenA);\n      _accrueInterest(tokenB);\n      lastBlockAccrued = block.number;\n    }\n  }\n\n  function accrueAccount(address _account) public {\n    _distributeReward(_account);\n    accrue();\n    _accrueAccountInterest(_account);\n\n    if (_account != feeRecipient()) {\n      _accrueAccountInterest(feeRecipient());\n    }\n  }\n\n  function accountHealth(address _account) public view returns(uint) {\n\n    if (debtOf[tokenA][_account] == 0 && debtOf[tokenB][_account] == 0) {\n      return controller.LIQ_MIN_HEALTH();\n    }\n\n    uint totalAccountSupply  = _supplyCredit(_account, tokenA, tokenA)  + _supplyCredit(_account, tokenB, tokenA);\n    uint totalAccountBorrrow = _borrowBalance(_account, tokenA, tokenA) + _borrowBalance(_account, tokenB, tokenA);\n\n    return totalAccountSupply * 1e18 / totalAccountBorrrow;\n  }\n\n  // Get borow balance converted to the units of _returnToken\n  function borrowBalance(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_borrowedToken);\n    _validateToken(_returnToken);\n\n    return _borrowBalance(_account, _borrowedToken, _returnToken);\n  }\n\n  function supplyBalance(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) external view returns(uint) {\n\n    _validateToken(_suppliedToken);\n    _validateToken(_returnToken);\n\n    return _supplyBalance(_account, _suppliedToken, _returnToken);\n  }\n\n  function supplyRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return controller.interestRateModel().supplyRatePerBlock(ILendingPair(address(this)), _token);\n  }\n\n  function borrowRatePerBlock(address _token) external view returns(uint) {\n    _validateToken(_token);\n    return _borrowRatePerBlock(_token);\n  }\n\n  // Sell collateral to reduce debt and increase accountHealth\n  // Set _repayAmount to uint(-1) to repay all debt, inc. pending interest\n  function liquidateAccount(\n    address _account,\n    address _repayToken,\n    uint    _repayAmount,\n    uint    _minSupplyOutput\n  ) external {\n\n    // Input validation and adjustments\n\n    _validateToken(_repayToken);\n    address supplyToken = _repayToken == tokenA ? tokenB : tokenA;\n\n    // Check account is underwater after interest\n\n    _accrueAccountInterest(_account);\n    _accrueAccountInterest(feeRecipient());\n    uint health = accountHealth(_account);\n    require(health < controller.LIQ_MIN_HEALTH(), \"LendingPair: account health > LIQ_MIN_HEALTH\");\n\n    // Calculate balance adjustments\n\n    _repayAmount = Math.min(_repayAmount, debtOf[_repayToken][_account]);\n\n    uint supplyDebt   = _convertTokenValues(_repayToken, supplyToken, _repayAmount);\n    uint callerFee    = supplyDebt * controller.liqFeeCaller(_repayToken) / 100e18;\n    uint systemFee    = supplyDebt * controller.liqFeeSystem(_repayToken) / 100e18;\n    uint supplyBurn   = supplyDebt + callerFee + systemFee;\n    uint supplyOutput = supplyDebt + callerFee;\n\n    require(supplyOutput >= _minSupplyOutput, \"LendingPair: supplyOutput >= _minSupplyOutput\");\n\n    // Adjust balances\n\n    _burnSupply(supplyToken, _account, supplyBurn);\n    _mintSupply(supplyToken, feeRecipient(), systemFee);\n    _burnDebt(_repayToken, _account, _repayAmount);\n\n    // Settle token transfers\n\n    _safeTransferFrom(_repayToken, msg.sender, _repayAmount);\n    _safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput);\n\n    emit Liquidation(_account, _repayToken, supplyToken, _repayAmount, supplyOutput);\n  }\n\n  function pendingSupplyInterest(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    uint newInterest = _newInterest(lpToken[_token].balanceOf(_account), _token, _account);\n    return newInterest * _lpRate(_token) / 100e18;\n  }\n\n  function pendingBorrowInterest(address _token, address _account) external view returns(uint) {\n    _validateToken(_token);\n    return _pendingBorrowInterest(_token, _account);\n  }\n\n  function feeRecipient() public view returns(address) {\n    return controller.feeRecipient();\n  }\n\n  function checkAccountHealth(address _account) public view  {\n    uint health = accountHealth(_account);\n    require(health >= controller.LIQ_MIN_HEALTH(), \"LendingPair: insufficient accountHealth\");\n  }\n\n  function convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) external view returns(uint) {\n\n    _validateToken(_fromToken);\n    _validateToken(_toToken);\n\n    return _convertTokenValues(_fromToken, _toToken, _inputAmount);\n  }\n\n  function _depositRepay(address _account, address _token, uint _amount) internal {\n\n    uint debt = debtOf[_token][_account];\n    uint repayAmount = debt > _amount ? _amount : debt;\n\n    if (repayAmount > 0) {\n      _repay(_account, _token, repayAmount);\n    }\n\n    uint depositAmount = _amount - repayAmount;\n\n    if (depositAmount > 0) {\n      _deposit(_account, _token, depositAmount);\n    }\n  }\n\n  function _withdrawBorrow(address _token, uint _amount) internal {\n\n    uint supplyAmount = lpToken[_token].balanceOf(msg.sender);\n    uint withdrawAmount = supplyAmount > _amount ? _amount : supplyAmount;\n\n    if (withdrawAmount > 0) {\n      _withdraw(_token, withdrawAmount);\n    }\n\n    uint borrowAmount = _amount - withdrawAmount;\n\n    if (borrowAmount > 0) {\n      _borrow(_token, borrowAmount);\n    }\n  }\n\n  function _distributeReward(address _account) internal {\n    IRewardDistribution rewardDistribution = controller.rewardDistribution();\n\n    if (address(rewardDistribution) != address(0)) {\n      rewardDistribution.distributeReward(_account, tokenA);\n      rewardDistribution.distributeReward(_account, tokenB);\n    }\n  }\n\n  function _mintSupply(address _token, address _account, uint _amount) internal {\n    if (_amount > 0) {\n      lpToken[_token].mint(_account, _amount);\n    }\n  }\n\n  function _burnSupply(address _token, address _account, uint _amount) internal {\n    if (_amount > 0) {\n      lpToken[_token].burn(_account, _amount);\n    }\n  }\n\n  function _mintDebt(address _token, address _account, uint _amount) internal {\n    debtOf[_token][_account] += _amount;\n    totalDebt[_token] += _amount;\n  }\n\n  function _burnDebt(address _token, address _account, uint _amount) internal {\n    debtOf[_token][_account] -= _amount;\n    totalDebt[_token] -= _amount;\n  }\n\n  function _accrueAccountInterest(address _account) internal {\n    uint lpBalanceA = lpToken[tokenA].balanceOf(_account);\n    uint lpBalanceB = lpToken[tokenB].balanceOf(_account);\n\n    _accrueAccountSupply(tokenA, lpBalanceA, _account);\n    _accrueAccountSupply(tokenB, lpBalanceB, _account);\n    _accrueAccountDebt(tokenA, _account);\n    _accrueAccountDebt(tokenB, _account);\n\n    accountInterestSnapshot[tokenA][_account] = cumulativeInterestRate[tokenA];\n    accountInterestSnapshot[tokenB][_account] = cumulativeInterestRate[tokenB];\n  }\n\n  function _accrueAccountSupply(address _token, uint _amount, address _account) internal {\n    if (_amount > 0) {\n      uint supplyInterest   = _newInterest(_amount, _token, _account);\n      uint newSupplyAccount = supplyInterest * _lpRate(_token) / 100e18;\n      uint newSupplySystem  = supplyInterest * _systemRate(_token) / 100e18;\n\n      _mintSupply(_token, _account, newSupplyAccount);\n      _mintSupply(_token, feeRecipient(), newSupplySystem);\n    }\n  }\n\n  function _accrueAccountDebt(address _token, address _account) internal {\n    if (debtOf[_token][_account] > 0) {\n      uint newDebt = _pendingBorrowInterest(_token, _account);\n      _mintDebt(_token, _account, newDebt);\n    }\n  }\n\n  function _withdraw(address _token, uint _amount) internal {\n\n    lpToken[address(_token)].burn(msg.sender, _amount);\n\n    checkAccountHealth(msg.sender);\n\n    emit Withdraw(_token, _amount);\n  }\n\n  function _borrow(address _token, uint _amount) internal {\n\n    require(lpToken[address(_token)].balanceOf(msg.sender) == 0, \"LendingPair: cannot borrow supplied token\");\n\n    _mintDebt(_token, msg.sender, _amount);\n\n    _checkBorrowLimits(_token, msg.sender);\n    checkAccountHealth(msg.sender);\n\n    emit Borrow(_token, _amount);\n  }\n\n  function _repay(address _account, address _token, uint _amount) internal {\n    _burnDebt(_token, _account, _amount);\n    emit Repay(_account, _token, _amount);\n  }\n\n  function _deposit(address _account, address _token, uint _amount) internal {\n\n    _checkOracleSupport(tokenA);\n    _checkOracleSupport(tokenB);\n\n    require(debtOf[_token][_account] == 0, \"LendingPair: cannot deposit borrowed token\");\n\n    _mintSupply(_token, _account, _amount);\n    _checkDepositLimit(_token);\n\n    emit Deposit(_account, _token, _amount);\n  }\n\n  function _accrueInterest(address _token) internal {\n    uint blocksElapsed = block.number - lastBlockAccrued;\n    uint newInterest = _borrowRatePerBlock(_token) * blocksElapsed;\n    cumulativeInterestRate[_token] += newInterest;\n  }\n\n  function _createLpToken(address _lpTokenMaster) internal returns(IERC20) {\n    ILPTokenMaster newLPToken = ILPTokenMaster(_lpTokenMaster.clone());\n    newLPToken.initialize();\n    return IERC20(newLPToken);\n  }\n\n  function _safeTransfer(IERC20 _token, address _recipient, uint _amount) internal {\n    if (_amount > 0) {\n      bool success = _token.transfer(_recipient, _amount);\n      require(success, \"LendingPair: transfer failed\");\n      _checkMinReserve(address(_token));\n    }\n  }\n\n  function _wethWithdrawTo(address _to, uint _amount) internal override {\n    if (_amount > 0) {\n      TransferHelper._wethWithdrawTo(_to, _amount);\n      _checkMinReserve(address(WETH));\n    }\n  }\n\n  function _borrowRatePerBlock(address _token) internal view returns(uint) {\n    return controller.interestRateModel().borrowRatePerBlock(ILendingPair(address(this)), _token);\n  }\n\n  function _pendingBorrowInterest(address _token, address _account) internal view returns(uint) {\n    return _newInterest(debtOf[_token][_account], _token, _account);\n  }\n\n  function _borrowBalance(\n    address _account,\n    address _borrowedToken,\n    address _returnToken\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(_borrowedToken, _returnToken, debtOf[_borrowedToken][_account]);\n  }\n\n  // Get supply balance converted to the units of _returnToken\n  function _supplyBalance(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) internal view returns(uint) {\n\n    return _convertTokenValues(_suppliedToken, _returnToken, lpToken[_suppliedToken].balanceOf(_account));\n  }\n\n  function _supplyCredit(\n    address _account,\n    address _suppliedToken,\n    address _returnToken\n  ) internal view returns(uint) {\n\n    return _supplyBalance(_account, _suppliedToken, _returnToken) * controller.colFactor(_suppliedToken) / 100e18;\n  }\n\n  function _convertTokenValues(\n    address _fromToken,\n    address _toToken,\n    uint    _inputAmount\n  ) internal view returns(uint) {\n\n    uint priceFrom = controller.tokenPrice(_fromToken) * 1e18 / 10 ** IERC20(_fromToken).decimals();\n    uint priceTo   = controller.tokenPrice(_toToken)   * 1e18 / 10 ** IERC20(_toToken).decimals();\n\n    return _inputAmount * priceFrom / priceTo;\n  }\n\n  function _validateToken(address _token) internal view {\n    require(_token == tokenA || _token == tokenB, \"LendingPair: invalid token\");\n  }\n\n  function _checkOracleSupport(address _token) internal view {\n    require(controller.tokenSupported(_token), \"LendingPair: token not supported\");\n  }\n\n  function _checkMinReserve(address _token) internal view {\n    require(IERC20(_token).balanceOf(address(this)) >= MIN_RESERVE, \"LendingPair: below MIN_RESERVE\");\n  }\n\n  function _checkDepositLimit(address _token) internal view {\n    require(controller.depositsEnabled(), \"LendingPair: deposits disabled\");\n\n    uint depositLimit = controller.depositLimit(address(this), _token);\n\n    if (depositLimit > 0) {\n      require((lpToken[_token].totalSupply()) <= depositLimit, \"LendingPair: deposit limit reached\");\n    }\n  }\n\n  function _checkBorrowLimits(address _token, address _account) internal view {\n    require(controller.borrowingEnabled(), \"LendingPair: borrowing disabled\");\n\n    uint accountBorrowUSD = debtOf[_token][_account] * controller.tokenPrice(_token) / 1e18;\n    require(accountBorrowUSD >= controller.minBorrowUSD(), \"LendingPair: borrow amount below minimum\");\n\n    uint borrowLimit = controller.borrowLimit(address(this), _token);\n\n    if (borrowLimit > 0) {\n      require(totalDebt[_token] <= borrowLimit, \"LendingPair: borrow limit reached\");\n    }\n  }\n\n  function _systemRate(address _token) internal view returns(uint) {\n    return controller.interestRateModel().systemRate(ILendingPair(address(this)), _token);\n  }\n\n  function _lpRate(address _token) internal view returns(uint) {\n    return 100e18 - _systemRate(_token);\n  }\n\n  function _newInterest(uint _balance, address _token, address _account) internal view returns(uint) {\n    return _balance * (cumulativeInterestRate[_token] - accountInterestSnapshot[_token][_account]) / 100e18;\n  }\n}\n\n\n",
        "CodeNames": [
            "LendingPair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LendingPair.liquidateAccount function",
                "Type": "LendingPair.liquidateAccount fails if tokens are lent out",
                "Description": "No liquidations can be performed if all tokens are lent out, leading to insolvency risk and potential loss of user funds.",
                "Repair": "Mint LP supply tokens to msg.sender instead of trying to pay out underlying supply tokens"
            },
            {
                "Location": "LendingPair.accrueAccount function",
                "Type": "Reward computation is wrong",
                "Description": "Wrong rewards will be minted to users, not representing their real fair share due to incorrect percentage calculations.",
                "Repair": "Increase total debt and total supply on each accrual by the total new interest, not just by the specific user's interest"
            },
            {
                "Location": "LendingPair.accrueAccount function",
                "Type": "Total LP supply & total debt accrual is wrong",
                "Description": "Total debt and total supply only increase when debt/supply is minted to the user, leading to incorrect borrow rates and utilization ratios.",
                "Repair": "Increase total debt and total supply on each accrual by the total new interest, not just by the specific user's interest"
            },
            {
                "Location": "LendingPair.liquidateAccount function",
                "Type": "LendingPair.liquidateAccount does not accrue and update cumulativeInterestRate",
                "Description": "Liquidatee's state will not be up-to-date, potentially allowing for skipping of interest payments and stealing of unpaid interest from the protocol.",
                "Repair": "Call accrueAccount instead of _accrueAccountInterest"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IUniswapV3Pool.sol';\nimport './interfaces/IUniswapV3Factory.sol';\nimport './interfaces/ILinkOracle.sol';\nimport './interfaces/IUniswapPriceConverter.sol';\nimport './external/Ownable.sol';\n\ncontract UniswapV3Oracle is Ownable {\n\n  IUniswapV3Factory public constant uniFactory    = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n  ILinkOracle       public constant wethOracle    = ILinkOracle(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n  address           public constant WETH          = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n  uint24            public constant WETH_POOL_FEE = 3000;\n\n  struct Pool {\n    address pairToken;\n    uint24  poolFee;\n  }\n\n  uint32 public twapPeriod;\n  uint   public minObservations;\n\n  IUniswapPriceConverter public uniPriceConverter;\n\n  mapping(address => Pool) public pools;\n\n  event PoolAdded(address indexed token);\n  event PoolRemoved(address indexed token);\n\n  constructor(\n    IUniswapPriceConverter _uniPriceConverter,\n    uint32       _twapPeriod,\n    uint         _minObservations\n  ) {\n    uniPriceConverter = _uniPriceConverter;\n    twapPeriod        = _twapPeriod;\n    minObservations   = _minObservations;\n  }\n\n  function addPool(\n    address _token,\n    address _pairToken,\n    uint24  _poolFee\n  ) external onlyOwner {\n\n    _validatePool(_token, _pairToken, _poolFee);\n\n    pools[_token] = Pool({\n      pairToken: _pairToken,\n      poolFee: _poolFee\n    });\n\n    emit PoolAdded(_token);\n  }\n\n  function removePool(address _token) external onlyOwner {\n    pools[_token] = Pool(address(0), 0);\n    emit PoolRemoved(_token);\n  }\n\n  function setUniPriceConverter(IUniswapPriceConverter _value) external onlyOwner {\n    uniPriceConverter = _value;\n  }\n\n  function setTwapPeriod(uint32 _value) external onlyOwner {\n    twapPeriod = _value;\n  }\n\n  function setMinObservations(uint _value) external onlyOwner {\n    minObservations = _value;\n  }\n\n  function tokenPrice(address _token) external view returns(uint) {\n    require(pools[_token].pairToken != address(0), \"UniswapV3Oracle: token not supported\");\n    _validatePool(_token, pools[_token].pairToken, pools[_token].poolFee);\n\n    uint ethValue = uniPriceConverter.assetToAssetThruRoute(\n      _token,\n      10 ** IERC20(_token).decimals(),\n      WETH,\n      twapPeriod,\n      pools[_token].pairToken,\n      [pools[_token].poolFee, WETH_POOL_FEE]\n    );\n\n    return ethValue * ethPrice() / 1e18;\n  }\n\n  function ethPrice() public view returns(uint) {\n    return wethOracle.latestAnswer() * 1e10;\n  }\n\n  function isPoolValid(address _token, address _pairToken, uint24 _poolFee) public view returns(bool) {\n    address poolAddress = uniFactory.getPool(_token, _pairToken, _poolFee);\n    if (poolAddress == address(0)) { return false; }\n\n    (, , , , uint observationSlots , ,) = IUniswapV3Pool(poolAddress).slot0();\n    return observationSlots >= minObservations;\n  }\n\n  function tokenSupported(address _token) external view returns(bool) {\n    return pools[_token].pairToken != address(0);\n  }\n\n  function _validatePool(address _token, address _pairToken, uint24 _poolFee) internal view {\n    require(isPoolValid(_token, _pairToken, _poolFee), \"UniswapV3Oracle: invalid pool\");\n  }\n}\n\n\n",
        "CodeNames": [
            "UniswapV3Oracle.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "UniswapV3Oracle.sol contract",
                "Type": "Chainlink - Use latestRoundData instead of latestAnswer to run more validations",
                "Description": "Using latestAnswer method does not allow for checking if data is fresh, potentially leading to stale prices and incorrect calculations.",
                "Repair": "Use latestRoundData method instead of latestAnswer method and run extra validations to ensure data is fresh"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) 2021 0xdev0 - All rights reserved\n// https://twitter.com/0xdev0\n\npragma solidity ^0.8.0;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IWETH.sol';\n\ncontract TransferHelper {\n\n  // Mainnet\n  IWETH internal constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  // Kovan\n  // IWETH internal constant WETH = IWETH(0xd0A1E359811322d97991E03f863a0C30C2cF029C);\n\n  function _safeTransferFrom(address _token, address _sender, uint _amount) internal virtual {\n    bool success = IERC20(_token).transferFrom(_sender, address(this), _amount);\n    require(success, \"TransferHelper: transfer failed\");\n    require(_amount > 0, \"TransferHelper: amount must be > 0\");\n  }\n\n  function _wethWithdrawTo(address _to, uint _amount) internal virtual {\n    require(_amount > 0, \"TransferHelper: amount must be > 0\");\n    WETH.withdraw(_amount);\n    (bool success, ) = _to.call { value: _amount }(new bytes(0));\n    require(success, 'TransferHelper: ETH transfer failed');\n  }\n\n  function _depositWeth() internal {\n    require(msg.value > 0, \"TransferHelper: amount must be > 0\");\n    WETH.deposit { value: msg.value }();\n  }\n}\n\n\n",
        "CodeNames": [
            "TransferHelper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TransferHelper.sol contract",
                "Type": "safeTransferFrom in TransferHelper is not safeTransferFrom",
                "Description": "Non-standard ERC20 tokens will raise errors when calling _safeTransferFrom, potentially leading to deposit issues.",
                "Repair": "Use SafeERC20 library in TransferHelper and any other contract that uses IERC20"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "_wethWithdrawTo function in withdrawBorrowETH function",
                "Type": "_wethWithdrawTo is vulnerable re-entrancy",
                "Description": "_wethWithdrawTo function uses a low level call that is vulnerable to re-entrancy attacks, potentially allowing for bypassing of reserve checks.",
                "Repair": "Consider using re-entrancy guard on all main action functions to prevent re-entrancy attacks"
            }
        ]
    }
]