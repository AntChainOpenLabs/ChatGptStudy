[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Merkle-tree-related contracts",
                "Type": "Smart Contract Vulnerability",
                "Description": "Merkle-tree-related contracts vulnerable to cross-chain-replay attacks",
                "Repair": "Add EIP-712 protections and add a mechanism to allow tokens to be transferred to a different address using EIP-2612 permit()"
            },
            {
                "Location": "Pool owners can prevent withdrawals of specific receipts",
                "Type": "Smart Contract Vulnerability",
                "Description": "Pool owners can prevent withdrawals of specific receipts without impacting any other functionality",
                "Repair": "Return a boolean of whether all withdrawals were successful, and allow withdraw() to be called multiple times, keeping track of what has been transferred and what hasn't"
            },
            {
                "Location": "Verification should be leafed based and not address based",
                "Type": "Smart Contract Vulnerability",
                "Description": "Contracts should clarify what is the intended behavior for Merkle trees with multiple leafs with the same address.",
                "Repair": "Clarify the behavior in the comments at least, and make clear to merkle tree builders"
            },
            {
                "Location": "amount requires to be updated to contract balance increase",
                "Type": "Smart Contract Vulnerability",
                "Description": "Every time transferFrom or transfer function in ERC20 standard is called there is a possibility that underlying smart contract did not transfer the exact amount entered.",
                "Repair": "Update actual amount to the contract balance increase"
            },
            {
                "Location": "safeTransferFrom function in ERC20 contracts",
                "Type": "smart contract vulnerability",
                "Description": "Using transfer function in ERC20 contracts can lead to funds getting stuck in the contract without possibility to retrieve them, especially for tokens like USDT that return nothing. Using safeTransferFrom of SafeERC20.sol is recommended instead.",
                "Repair": "Use safeTransferFrom of SafeERC20.sol instead of transfer"
            },
            {
                "Location": "Deposit and Merkle-tree-related contracts",
                "Type": "Rebasing tokens go to the pool owner, or remain locked in the various contracts",
                "Description": "Deposited tokens will grow in value, but the value in excess of the pre-calculated getMaximumRewards()/deposited amounts go solely to the owner/creator, or will remain locked in the contract.",
                "Repair": "Provide a function for the pool owner to withdraw excess deposited tokens and repay any associated taxes. In the case of the Merkle trees though, pro rata share amounts need to be calculated and tracked and updated with every withdrawal, which will require drastic changes to the code, making it much more expensive."
            },
            {
                "Location": "withdrawExcessRewards() function",
                "Type": "DoS",
                "Description": "An attacker may cause a DoS attack on withdrawExcessRewards() by creating an excessive number of receipts with minimal value.",
                "Repair": "Add a minimum deposit amount for each pool that can be configured by the pool owner. Alternatively, allow the owner to call withdrawExcessRewards() given some other criteria such as a fixed period of time (e.g. 1 month) has passed since the end of the auction and 90% of the deposits have been withdrawn."
            },
            {
                "Location": "withdrawTaxes() function",
                "Type": "Prevention of tax payment",
                "Description": "Pool owners can prevent taxes from being paid without impacting any other functionality.",
                "Repair": "Force taxes to be paid during withdraw()."
            },
            {
                "Location": "addPool() function",
                "Type": "Prevention of tax payment",
                "Description": "It is possible for the owner of a pool to prevent any taxes being withdrawn by the globalBeneficiary.",
                "Repair": "The withdrawTaxes() function can take both poolId and rewardIndex as parameters to allow the tax beneficiary to only withdraw from certain reward tokens in the pool. Alternatively, implement a try-catch condition around the withdrawal of reward tokens. In the catch statement, re-instate the taxes[poolId][i] = tax if the transfer fails. Alternatively, just skip the reward tokens if the transfer fails though this would be undesirable if a token is paused for some reason."
            },
            {
                "Location": "setGlobalTax() function",
                "Type": "Centralisation Risk",
                "Description": "Owner may abuse the tax rate to claim 99.9% of pools. The globalBeneficiary can modify the tax rate and front-run transactions to create pools with the 99.9% tax rate.",
                "Repair": "Set upper bounds for the tax rate, consider setting it to 5%"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.12;\n\nimport \"../interfaces/IERC20.sol\";\n\n/// @title A factory pattern for basic staking, put tokens in, get more tokens (potentially multiple types) out\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Anyone can create a pool, and fees are taken out of rewards\n/// @dev Maximum possible pool obligations are computed at pool-creation-time and taken from creator at that time\n/// @dev Any unclaimed rewards are claimable after the pool has ended, pool funds are accounted for separately\ncontract PermissionlessBasicPoolFactory {\n\n    // this represents a single deposit into a staking pool, used to withdraw as well\n    struct Receipt {\n        uint id;   // primary key\n        uint amountDepositedWei;  // amount of tokens originally deposited\n        uint timeDeposited;  // the time the deposit was made\n        uint timeWithdrawn;  // the time the deposit was withdrawn, or 0 if not withdrawn yet\n        address owner;  // the owner of the deposit\n    }\n\n    // this represents a single staking pool with >= 1 reward tokens\n    struct Pool {\n        uint id; // primary key\n        uint[] rewardsWeiPerSecondPerToken; // array of reward rates, this number gets multiplied by time and tokens (not wei) to determine rewards\n        uint[] rewardsWeiClaimed;  // bookkeeping of how many rewards have been paid out for each token\n        uint[] rewardFunding;  // bookkeeping of how many rewards have been supplied for each token\n        uint maximumDepositWei;  // the size of the pool, maximum sum of all deposits\n        uint totalDepositsWei;  // current sum of all deposits\n        uint numReceipts;  // number of receipts issued\n        uint startTime;  // the time that the pool begins\n        uint endTime;    // time that the pool ends\n        uint taxPerCapita;  // portion of rewards that go to the contract creator\n        address depositToken;  // token that user deposits (stakes)\n        address excessBeneficiary;  // address that is able to reclaim unused rewards\n        address[] rewardTokens;  // array of token contract addresses that stakers will receive as rewards\n        mapping (uint => Receipt) receipts;  // mapping of receipt ids to receipt structs\n    }\n\n    // simple struct for UI to display relevant data\n    struct Metadata {\n        bytes32 name;\n        bytes32 ipfsHash;\n    }\n\n    // the number of staking pools ever created\n    uint public numPools;\n\n    // the beneficiary of taxes\n    address public globalBeneficiary;\n\n    // this is the settable tax imposed on new pools, fixed at pool creation time\n    uint public globalTaxPerCapita;\n\n    // pools[poolId] = poolStruct\n    mapping (uint => Pool) public pools;\n    // metadatas[poolId] = metadataStruct\n    mapping (uint => Metadata) public metadatas;\n    // taxes[poolId] = taxesCollected[rewardIndex]\n    mapping (uint => uint[]) public taxes;\n\n    // every time a deposit happens\n    event DepositOccurred(uint indexed poolId, uint indexed receiptId, address indexed owner);\n    // every time a withdrawal happens\n    event WithdrawalOccurred(uint indexed poolId, uint indexed receiptId, address indexed owner);\n    // every time excess rewards are withdrawn\n    event ExcessRewardsWithdrawn(uint indexed poolId);\n    // every time a pool is added\n    event PoolAdded(uint indexed poolId, bytes32 indexed name, address indexed depositToken);\n\n    /// @notice Whoever deploys the contract decides who receives how much fees\n    /// @param _globalBeneficiary the address that receives the fees and can also set the fees\n    /// @param _globalTaxPerCapita the amount of the rewards that goes to the globalBeneficiary * 1000 (perCapita)\n    constructor(address _globalBeneficiary, uint _globalTaxPerCapita) {\n        globalBeneficiary = _globalBeneficiary;\n        globalTaxPerCapita = _globalTaxPerCapita;\n    }\n\n    /// @notice Create a pool and fund it\n    /// @dev Anyone may call this function, but they must fund it, having called approve on all contracts beforehand\n    /// @dev Any malicious token contracts included here will make the pool malicious, but not effect other pools\n    /// @param startTime time at which pool starts, if in past, it is set to block.timestamp \"now\"\n    /// @param maxDeposit the maximum amount of tokens that can be deposited in this pool\n    /// @param rewardsWeiPerSecondPerToken the amount of tokens given out per second per token (not wei) deposited\n    /// @param programLengthDays the amount of days the pool will be open, this with the start time determines the end time\n    /// @param depositTokenAddress the token that users will put into the pool to receive rewards\n    /// @param excessBeneficiary the recipient of any unclaimed funds in the pool\n    /// @param rewardTokenAddresses the list of token contracts that will be given out as rewards for staking\n    /// @param ipfsHash a hash of any metadata about the pool, may be incorporated into interfaces\n    /// @param name name of pool, to be used by interfaces\n    function addPool (\n        uint startTime,\n        uint maxDeposit,\n        uint[] memory rewardsWeiPerSecondPerToken,\n        uint programLengthDays,\n        address depositTokenAddress,\n        address excessBeneficiary,\n        address[] memory rewardTokenAddresses,\n        bytes32 ipfsHash,\n        bytes32 name\n    ) external {\n        Pool storage pool = pools[++numPools];\n        pool.id = numPools;\n        pool.rewardsWeiPerSecondPerToken = rewardsWeiPerSecondPerToken;\n        pool.startTime = startTime > block.timestamp ? startTime : block.timestamp;\n        pool.endTime = pool.startTime + (programLengthDays * 1 days);\n        pool.depositToken = depositTokenAddress;\n        pool.excessBeneficiary = excessBeneficiary;\n        pool.taxPerCapita = globalTaxPerCapita;\n\n        require(rewardsWeiPerSecondPerToken.length == rewardTokenAddresses.length, 'Rewards and reward token arrays must be same length');\n\n        // fill out the arrays with zeros\n        for (uint i = 0; i < rewardTokenAddresses.length; i++) {\n            pool.rewardTokens.push(rewardTokenAddresses[i]);\n            pool.rewardsWeiClaimed.push(0);\n            pool.rewardFunding.push(0);\n            taxes[numPools].push(0);\n        }\n        pool.maximumDepositWei = maxDeposit;\n\n        // this must be after pool initialization above\n        fundPool(pool.id);\n\n        {\n            Metadata storage metadata = metadatas[numPools];\n            metadata.ipfsHash = ipfsHash;\n            metadata.name = name;\n        }\n        emit PoolAdded(pool.id, name, depositTokenAddress);\n    }\n\n    /// @notice Add funds to a pool\n    /// @dev This function is internal because pools cannot be underfunded, liabilities are known at pool-creation-time\n    /// @param poolId index of pool that is being funded\n    function fundPool(uint poolId) internal {\n        Pool storage pool = pools[poolId];\n        bool success = true;\n        uint amount;\n        for (uint i = 0; i < pool.rewardFunding.length; i++) {\n            amount = getMaximumRewards(poolId, i);\n            // transfer the tokens from pool-creator to this contract\n            success = success && IERC20(pool.rewardTokens[i]).transferFrom(msg.sender, address(this), amount);\n            // bookkeeping to make sure pools don't share tokens\n            pool.rewardFunding[i] += amount;\n        }\n        require(success, 'Token deposits failed');\n    }\n\n    /// @notice Compute the rewards that would be received if the receipt was cashed out now\n    /// @dev This function does not inspect whether the receipt has already been cashed out\n    /// @param poolId which pool are we talking about?\n    /// @param receiptId the id of the receipt that we are querying\n    /// @return rewardsLocal array of rewards, one entry for each reward token\n    function getRewards(uint poolId, uint receiptId) public view returns (uint[] memory) {\n        Pool storage pool = pools[poolId];\n        Receipt memory receipt = pool.receipts[receiptId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        require(receipt.id == receiptId, 'Uninitialized receipt');\n        uint nowish = block.timestamp;\n        if (nowish > pool.endTime) {\n            nowish = pool.endTime;\n        }\n\n        uint secondsDiff = nowish - receipt.timeDeposited;\n        uint[] memory rewardsLocal = new uint[](pool.rewardsWeiPerSecondPerToken.length);\n        for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {\n            rewardsLocal[i] = (secondsDiff * pool.rewardsWeiPerSecondPerToken[i] * receipt.amountDepositedWei) / 1e18;\n        }\n\n        return rewardsLocal;\n    }\n\n    /// @notice Add funds to a pool\n    /// @dev Anyone may call this function, it simply puts tokens in the pool and returns a receipt\n    /// @dev If deposit amount causes pool to overflow, amount is decreased so pool is full\n    /// @param poolId which pool are we talking about?\n    /// @param amount amount of tokens to deposit\n    function deposit(uint poolId, uint amount) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        require(block.timestamp > pool.startTime, 'Cannot deposit before pool start');\n        require(block.timestamp < pool.endTime, 'Cannot deposit after pool ends');\n        require(pool.totalDepositsWei < pool.maximumDepositWei, 'Maximum deposit already reached');\n        if (pool.totalDepositsWei + amount > pool.maximumDepositWei) {\n            amount = pool.maximumDepositWei - pool.totalDepositsWei;\n        }\n        pool.totalDepositsWei += amount;\n        pool.numReceipts++;\n\n        Receipt storage receipt = pool.receipts[pool.numReceipts];\n        receipt.id = pool.numReceipts;\n        receipt.amountDepositedWei = amount;\n        receipt.timeDeposited = block.timestamp;\n        receipt.owner = msg.sender;\n\n        bool success = IERC20(pool.depositToken).transferFrom(msg.sender, address(this), amount);\n        require(success, 'Token transfer failed');\n\n        emit DepositOccurred(poolId, pool.numReceipts, msg.sender);\n    }\n\n    /// @notice Withdraw funds from pool\n    /// @dev Only receipt owner may call this function\n    /// @dev If any of the reward tokens are malicious, this function may break\n    /// @param poolId which pool are we talking about?\n    /// @param receiptId which receipt is being cashed in\n    function withdraw(uint poolId, uint receiptId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        Receipt storage receipt = pool.receipts[receiptId];\n        require(receipt.id == receiptId, 'Can only withdraw real receipts');\n        require(receipt.owner == msg.sender || block.timestamp > pool.endTime, 'Can only withdraw your own deposit');\n        require(receipt.timeWithdrawn == 0, 'Can only withdraw once per receipt');\n\n        // close re-entry gate\n        receipt.timeWithdrawn = block.timestamp;\n\n        uint[] memory rewards = getRewards(poolId, receiptId);\n        pool.totalDepositsWei -= receipt.amountDepositedWei;\n        bool success = true;\n\n        for (uint i = 0; i < rewards.length; i++) {\n            pool.rewardsWeiClaimed[i] += rewards[i];\n            pool.rewardFunding[i] -= rewards[i];\n            uint tax = (pool.taxPerCapita * rewards[i]) / 1000;\n            uint transferAmount = rewards[i] - tax;\n            taxes[poolId][i] += tax;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, transferAmount);\n        }\n\n        success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);\n        require(success, 'Token transfer failed');\n\n        emit WithdrawalOccurred(poolId, receiptId, receipt.owner);\n    }\n\n    /// @notice Withdraw any unused rewards from the pool, after it has ended\n    /// @dev Anyone can call this, as the excess beneficiary is set at pool-creation-time\n    /// @param poolId which pool are we talking about?\n    function withdrawExcessRewards(uint poolId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n        require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');\n        require(block.timestamp > pool.endTime, 'Contract must reach maturity');\n\n        bool success = true;\n        for (uint i = 0; i < pool.rewardTokens.length; i++) {\n            uint rewards = pool.rewardFunding[i];\n            pool.rewardFunding[i] = 0;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(pool.excessBeneficiary, rewards);\n        }\n        require(success, 'Token transfer failed');\n        emit ExcessRewardsWithdrawn(poolId);\n    }\n\n    /// @notice Withdraw taxes from pool\n    /// @dev Anyone may call this, it just moves the taxes from this contract to the globalBeneficiary\n    /// @param poolId which pool are we talking about?\n    function withdrawTaxes(uint poolId) external {\n        Pool storage pool = pools[poolId];\n        require(pool.id == poolId, 'Uninitialized pool');\n\n        bool success = true;\n        for (uint i = 0; i < pool.rewardTokens.length; i++) {\n            uint tax = taxes[poolId][i];\n            taxes[poolId][i] = 0;\n            success = success && IERC20(pool.rewardTokens[i]).transfer(globalBeneficiary, tax);\n        }\n        require(success, 'Token transfer failed');\n    }\n\n    /// @notice Compute maximum rewards that could be given out by a given pool\n    /// @dev This is primarily used by fundPool to compute how many tokens to take from the pool-creator\n    /// @param poolId which pool are we talking about?\n    /// @param rewardIndex index into the rewards array, to avoid passing arrays around\n    /// @return maximumRewardAmount the theoretical maximum that will be paid from this reward token, if pool fills instantly\n    function getMaximumRewards(uint poolId, uint rewardIndex) public view returns (uint) {\n        Pool storage pool = pools[poolId];\n        // rewardsPerSecondPerToken * tokens * seconds\n        return pool.rewardsWeiPerSecondPerToken[rewardIndex] * pool.maximumDepositWei * (pool.endTime - pool.startTime) / 1e18;\n    }\n\n    /// @notice Get reward data about a pool\n    /// @dev This gets all the reward-relevant fields from the struct\n    /// @param poolId which pool are we talking about?\n    /// @return rewardsWeiPerSecondPerToken reward slope array\n    /// @return rewardsWeiClaimed rewards already claimed array\n    /// @return rewardTokens array of reward token contract addresses\n    /// @return rewardFunding array of amounts of reward tokens already dispensed\n    function getRewardData(uint poolId) external view returns (uint[] memory, uint[] memory, address[] memory, uint[] memory) {\n        Pool storage pool = pools[poolId];\n        return (pool.rewardsWeiPerSecondPerToken, pool.rewardsWeiClaimed, pool.rewardTokens, pool.rewardFunding);\n    }\n\n    /// @notice Get data about a specific receipt\n    /// @dev This gets all the fields from a receipt\n    /// @param poolId which pool are we talking about?\n    /// @param receiptId which receipt are we talking about?\n    /// @return amountDepositedWei original deposit amount\n    /// @return timeDeposited the time of original deposit\n    /// @return timeWithdrawn time when receipt was cashed in, if ever\n    /// @return owner the beneficiary of the receipt, who deposited the tokens originally?\n    function getReceipt(uint poolId, uint receiptId) external view returns (uint, uint, uint, address) {\n        Pool storage pool = pools[poolId];\n        Receipt storage receipt = pool.receipts[receiptId];\n        return (receipt.amountDepositedWei, receipt.timeDeposited, receipt.timeWithdrawn, receipt.owner);\n    }\n\n    /// @notice Change the fee factor\n    /// @dev This can only be called by the global beneficiary\n    /// @param newTaxPerCapita the new fee\n    function setGlobalTax(uint newTaxPerCapita) external {\n        require(msg.sender == globalBeneficiary, 'Only globalBeneficiary can set tax');\n        require(newTaxPerCapita < 1000, 'Tax too high');\n        globalTaxPerCapita = newTaxPerCapita;\n    }\n}\n\n\n",
        "CodeNames": [
            "PermissionlessBasicPoolFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "getRewards() function in PermissionlessBasicPoolFactory contract",
                "Type": "smart contract vulnerability",
                "Description": "The getRewards() function in PermissionlessBasicPoolFactory contract calculates the wrong reward amount for receiptId==0, which can be exploited by sending receiptId as 0.",
                "Repair": "Add a check to ensure receiptId is not 0 or check for uninitialized receipts with owner field as non-zero"
            },
            {
                "Location": "withdraw function in PermissionlessBasicPoolFactory contract",
                "Type": "smart contract vulnerability",
                "Description": "Malicious token reward could disable withdrawals in the PermissionlessBasicPoolFactory contract, and an emergencyWithdraw function is needed to ignore failed reward token transfers.",
                "Repair": "Add an emergencyWithdraw function that ignores failed reward token transfers"
            },
            {
                "Location": "PermissionlessBasicPoolFactory.sol contract",
                "Type": "DoS: Blacklisted user may prevent  withdrawExcessRewards()",
                "Description": "If one user becomes blacklisted or otherwise cannot be transferred funds in any of the rewards tokens or the deposit token then they will not be able to call withdraw() for that token.",
                "Repair": "Consider allowing withdrawExcessRewards() to be called after a set period of time after the pool end if most users have withdrawn or some similar criteria."
            },
            {
                "Location": "PermissionlessBasicPoolFactory.sol",
                "Type": "Unchecked transfer",
                "Description": "When the transfer is made in the withdraw() function, it is not validated if the transfer was done correctly. This could be a conflict since not being able to perform it would return a false and that case would not be handled, the most common is to revert.",
                "Repair": "Wrap the transfer with a require"
            },
            {
                "Location": "PermissionlessBasicPoolFactory.sol",
                "Type": "User fund freeze",
                "Description": "Reward tokens that do not allow for zero amount transfers can prevent user pool exit. If withdraw was called at the moment when some reward amount is zero, the withdraw() will revert. As withdraw() the only way for a user to exit pool, her funds will be frozen within.",
                "Repair": "Control for zero amounts in reward transfer cycle"
            },
            {
                "Location": "PermissionlessBasicPoolFactory contract",
                "Type": "Incorrect reward calculation",
                "Description": "Contract PermissionlessBasicPoolFactory calculates rewards by using hardcoded value of decimals 18 (1e18) for ERC20 tokens. This leads to wrong rewards calculations and effectively loss of funds for all pools that will be using ERC20 tokens with different decimals than 18.",
                "Repair": "Add support for different numbers of decimals than 18 by dynamically checking decimals() for the tokens that are part of the rewards calculations. Alternatively, if such support is not needed, new require statements should be added to addPool that will be checking that the number of decimals for all ERC20 tokens is 18."
            },
            {
                "Location": "withdraw() function in PermissionlessBasicPoolFactory contract",
                "Type": "Unbounded loop",
                "Description": "The withdraw() function has an unbounded loop with external calls, which may cause the function to revert due to exceeding the block size gas limit.",
                "Repair": "Allow the specification of an offset and length to the withdraw() function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A factory pattern for merkle-vesting, that is, a time release schedule for tokens, using merkle proofs to scale\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Any fees must be included in the data of the merkle tree.\n/// @dev The contract cannot introspect into the contents of the merkle tree, except when provided a merkle proof\ncontract MerkleVesting {\n    using MerkleLib for bytes32;\n\n    // the number of vesting schedules in this contract\n    uint public numTrees = 0;\n    \n    // this represents a single vesting schedule for a specific address\n    struct Tranche {\n        uint totalCoins;  // total number of coins released to an address after vesting is completed\n        uint currentCoins; // how many coins are left unclaimed by this address, vested or unvested\n        uint startTime; // when the vesting schedule is set to start, possibly in the past\n        uint endTime;  // when the vesting schedule will have released all coins\n        uint coinsPerSecond; // an intermediate value cached to reduce gas costs, how many coins released every second\n        uint lastWithdrawalTime; // the last time a withdrawal occurred, used to compute unvested coins\n        uint lockPeriodEndTime; // the first time at which coins may be withdrawn\n    }\n\n    // this represents a set of vesting schedules all in the same token\n    struct MerkleTree {\n        bytes32 rootHash;  // merkleroot of tree whose leaves are (address,uint,uint,uint,uint) representing vesting schedules\n        bytes32 ipfsHash; // ipfs hash of entire dataset, used to reconstruct merkle proofs if our servers go down\n        address tokenAddress; // token that the vesting schedules will be denominated in\n        uint tokenBalance; // current amount of tokens deposited to this tree, used to make sure trees don't share tokens\n    }\n\n    // initialized[recipient][treeIndex] = wasItInitialized?\n    mapping (address => mapping (uint => bool)) public initialized;\n\n    // array-like sequential map for all the vesting schedules\n    mapping (uint => MerkleTree) public merkleTrees;\n\n    // tranches[recipient][treeIndex] = initializedVestingSchedule\n    mapping (address => mapping (uint => Tranche)) public tranches;\n\n    // every time there's a withdrawal\n    event WithdrawalOccurred(uint indexed treeIndex, address indexed destination, uint numTokens, uint tokensLeft);\n\n    // every time a tree is added\n    event MerkleRootAdded(uint indexed treeIndex, address indexed tokenAddress, bytes32 newRoot, bytes32 ipfsHash);\n\n    // every time a tree is topped up\n    event TokensDeposited(uint indexed treeIndex, address indexed tokenAddress, uint amount);\n\n    /// @notice Add a new merkle tree to the contract, creating a new merkle-vesting-schedule\n    /// @dev Anyone may call this function, therefore we must make sure trees cannot affect each other\n    /// @dev Root hash should be built from (destination, totalCoins, startTime, endTime, lockPeriodEndTime)\n    /// @param newRoot root hash of merkle tree representing vesting schedules\n    /// @param ipfsHash the ipfs hash of the entire dataset, used for redundance so that creator can ensure merkleproof are always computable\n    /// @param tokenAddress the address of the token contract that is being distributed\n    /// @param tokenBalance the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function addMerkleRoot(bytes32 newRoot, bytes32 ipfsHash, address tokenAddress, uint tokenBalance) public {\n        // prefix operator ++ increments then evaluates\n        merkleTrees[++numTrees] = MerkleTree(\n            newRoot,\n            ipfsHash,\n            tokenAddress,\n            0    // no funds have been allocated to the tree yet\n        );\n        // fund the tree now\n        depositTokens(numTrees, tokenBalance);\n        emit MerkleRootAdded(numTrees, tokenAddress, newRoot, ipfsHash);\n    }\n\n    /// @notice Add funds to an existing merkle-vesting-schedule\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\n    /// @dev If the tree is over-funded, excess funds are lost. No clear way to get around this without zk-proofs\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param value the amount of tokens user wishes to use to fund the airdrop, note trees can be underfunded\n    function depositTokens(uint treeIndex, uint value) public {\n        // storage since we are editing\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\n\n        // bookkeeping to make sure trees don't share tokens\n        merkleTree.tokenBalance += value;\n\n        // transfer tokens, if this is a malicious token, then this whole tree is malicious\n        // but it does not effect the other trees\n        require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, value);\n    }\n\n    /// @notice Called once per recipient of a vesting schedule to initialize the vesting schedule\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\n    /// @dev If the tree is over-funded, excess funds are lost. No clear way to get around this without zk-proofs of global tree stats\n    /// @dev The contract has no knowledge of the vesting schedules until this function is called\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param destination address that will receive tokens\n    /// @param totalCoins amount of tokens to be released after vesting completes\n    /// @param startTime time that vesting schedule starts, can be past or future\n    /// @param endTime time vesting schedule completes, can be past or future\n    /// @param lockPeriodEndTime time that coins become unlocked, can be after endTime\n    /// @param proof array of hashes linking leaf hash of (destination, totalCoins, startTime, endTime, lockPeriodEndTime) to root\n    function initialize(uint treeIndex, address destination, uint totalCoins, uint startTime, uint endTime, uint lockPeriodEndTime, bytes32[] memory proof) external {\n        // must not initialize multiple times\n        require(!initialized[destination][treeIndex], \"Already initialized\");\n        // leaf hash is digest of vesting schedule parameters and destination\n        // NOTE: use abi.encode, not abi.encodePacked to avoid possible (but unlikely) collision\n        bytes32 leaf = keccak256(abi.encode(destination, totalCoins, startTime, endTime, lockPeriodEndTime));\n        // memory because we read only\n        MerkleTree memory tree = merkleTrees[treeIndex];\n        // call to MerkleLib to check if the submitted data is correct\n        require(tree.rootHash.verifyProof(leaf, proof), \"The proof could not be verified.\");\n        // set initialized, preventing double initialization\n        initialized[destination][treeIndex] = true;\n        // precompute how many coins are released per second\n        uint coinsPerSecond = totalCoins / (endTime - startTime);\n        // create the tranche struct and assign it\n        tranches[destination][treeIndex] = Tranche(\n            totalCoins,  // total coins to be released\n            totalCoins,  // currentCoins starts as totalCoins\n            startTime,\n            endTime,\n            coinsPerSecond,\n            startTime,    // lastWithdrawal starts as startTime\n            lockPeriodEndTime\n        );\n        // if we've passed the lock time go ahead and perform a withdrawal now\n        if (lockPeriodEndTime < block.timestamp) {\n            withdraw(treeIndex, destination);\n        }\n    }\n\n    /// @notice Claim funds as a recipient in the merkle-drop\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\n    /// @param treeIndex index into array-like map of merkleTrees, which tree should we apply the proof to?\n    /// @param destination recipient of tokens\n    function withdraw(uint treeIndex, address destination) public {\n        // cannot withdraw from an uninitialized vesting schedule\n        require(initialized[destination][treeIndex], \"You must initialize your account first.\");\n        // storage because we will modify it\n        Tranche storage tranche = tranches[destination][treeIndex];\n        // no withdrawals before lock time ends\n        require(block.timestamp > tranche.lockPeriodEndTime, 'Must wait until after lock period');\n        // revert if there's nothing left\n        require(tranche.currentCoins >  0, 'No coins left to withdraw');\n\n        // declaration for branched assignment\n        uint currentWithdrawal = 0;\n\n        // if after vesting period ends, give them the remaining coins\n        if (block.timestamp >= tranche.endTime) {\n            currentWithdrawal = tranche.currentCoins;\n        } else {\n            // compute allowed withdrawal\n            currentWithdrawal = (block.timestamp - tranche.lastWithdrawalTime) * tranche.coinsPerSecond;\n        }\n\n        // decrease allocation of coins\n        tranche.currentCoins -= currentWithdrawal;\n        // this makes sure coins don't get double withdrawn\n        tranche.lastWithdrawalTime = block.timestamp;\n\n        // update the tree balance so trees can't take each other's tokens\n        MerkleTree storage tree = merkleTrees[treeIndex];\n        tree.tokenBalance -= currentWithdrawal;\n\n        // Transfer the tokens, if the token contract is malicious, this will make the whole tree malicious\n        // but this does not allow re-entrance due to struct updates and it does not effect other trees.\n        // It is also consistent with the ethereum general security model:\n        // other contracts do what they want, it's our job to protect our contract\n        IERC20(tree.tokenAddress).transfer(destination, currentWithdrawal);\n        emit WithdrawalOccurred(treeIndex, destination, currentWithdrawal, tranche.currentCoins);\n    }\n\n}\n\n",
        "CodeNames": [
            "MerkleVesting.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "withdraw function in MerkleVesting contract",
                "Type": "smart contract vulnerability",
                "Description": "The MerkleVesting withdrawal function does not verify that tokens were transferred successfully, which can lead to users losing their allocation and funds if the ERC20 transfer is temporarily failing.",
                "Repair": "Add a check that verifies that the transfer has succeeded"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A factory pattern for merkledrops, that is, airdrops using merkleproofs to compute eligibility\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Any fees must be included in the data of the merkle tree.\n/// @dev The contract cannot introspect into the contents of the merkle tree, except when provided a merkle proof,\n/// @dev therefore the total liabilities of the merkle tree are untrusted and tree balances must be managed separately\ncontract MerkleDropFactory {\n    using MerkleLib for bytes32;\n\n    // the number of airdrops in this contract\n    uint public numTrees = 0;\n\n    // this represents a single airdrop\n    struct MerkleTree {\n        bytes32 merkleRoot;  // merkleroot of tree whose leaves are (address,uint) pairs representing amount owed to user\n        bytes32 ipfsHash; // ipfs hash of entire dataset, as backup in case our servers turn off...\n        address tokenAddress; // address of token that is being airdropped\n        uint tokenBalance; // amount of tokens allocated for this tree\n        uint spentTokens; // amount of tokens dispensed from this tree\n    }\n\n    // withdrawn[recipient][treeIndex] = hasUserWithdrawnAirdrop\n    mapping (address => mapping (uint => bool)) public withdrawn;\n\n    // array-like map for all ze merkle trees (airdrops)\n    mapping (uint => MerkleTree) public merkleTrees;\n\n    // every time there's a withdraw\n    event WithdrawalOccurred(uint indexed treeIndex, address indexed destination, uint value);\n\n    // every time a tree is added\n    event MerkleTreeAdded(uint indexed treeIndex, address indexed tokenAddress, bytes32 newRoot, bytes32 ipfsHash);\n\n    // every time a tree is topped up\n    event TokensDeposited(uint indexed treeIndex, address indexed tokenAddress, uint amount);\n\n    /// @notice Add a new merkle tree to the contract, creating a new merkle-drop\n    /// @dev Anyone may call this function, therefore we must make sure trees cannot affect each other\n    /// @param newRoot root hash of merkle tree representing liabilities == (destination, value) pairs\n    /// @param ipfsHash the ipfs hash of the entire dataset, used for redundance so that creator can ensure merkleproof are always computable\n    /// @param tokenAddress the address of the token contract that is being distributed\n    /// @param tokenBalance the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function addMerkleTree(bytes32 newRoot, bytes32 ipfsHash, address tokenAddress, uint tokenBalance) public {\n        // prefix operator ++ increments then evaluates\n        merkleTrees[++numTrees] = MerkleTree(\n            newRoot,\n            ipfsHash,\n            tokenAddress,\n            0,  // ain't no tokens in here yet\n            0   // ain't nobody claimed no tokens yet either\n        );\n        // you don't get to add a tree without funding it\n        depositTokens(numTrees, tokenBalance);\n        // I guess we should tell people (interfaces) what happened\n        emit MerkleTreeAdded(numTrees, tokenAddress, newRoot, ipfsHash);\n    }\n\n    /// @notice Add funds to an existing merkle-drop\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param value the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function depositTokens(uint treeIndex, uint value) public {\n        // storage since we are editing\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\n\n        // bookkeeping to make sure trees don't share tokens\n        merkleTree.tokenBalance += value;\n\n        // transfer tokens, if this is a malicious token, then this whole tree is malicious\n        // but it does not effect the other trees\n        require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, value);\n    }\n\n    /// @notice Claim funds as a recipient in the merkle-drop\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\n    /// @param treeIndex index into array-like map of merkleTrees, which tree should we apply the proof to?\n    /// @param destination recipient of tokens\n    /// @param value amount of tokens that will be sent to destination\n    /// @param proof array of hashes bridging from leaf (hash of destination | value) to merkle root\n    function withdraw(uint treeIndex, address destination, uint value, bytes32[] memory proof) public {\n        // no withdrawing from uninitialized merkle trees\n        require(treeIndex <= numTrees, \"Provided merkle index doesn't exist\");\n        // no withdrawing same airdrop twice\n        require(!withdrawn[destination][treeIndex], \"You have already withdrawn your entitled token.\");\n        // compute merkle leaf, this is first element of proof\n        bytes32 leaf = keccak256(abi.encode(destination, value));\n        // storage because we edit\n        MerkleTree storage tree = merkleTrees[treeIndex];\n        // this calls to MerkleLib, will return false if recursive hashes do not end in merkle root\n        require(tree.merkleRoot.verifyProof(leaf, proof), \"The proof could not be verified.\");\n        // close re-entrance gate, prevent double claims\n        withdrawn[destination][treeIndex] = true;\n        // update struct\n        tree.tokenBalance -= value;\n        tree.spentTokens += value;\n        // transfer the tokens\n        // NOTE: if the token contract is malicious this call could re-enter this function\n        // which will fail because withdrawn will be set to true\n        require(IERC20(tree.tokenAddress).transfer(destination, value), \"ERC20 transfer failed\");\n        emit WithdrawalOccurred(treeIndex, destination, value);\n    }\n\n}\n\n// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\n/// @title A library for merkle trees\n/// @author metapriest\n/// @notice This library is used to check merkle proofs very efficiently.\n/// @dev Each additional proof element adds ~1000 gas\nlibrary MerkleLib {\n\n    /// @notice Check the merkle proof to determine whether leaf data was included in dataset represented by merkle root\n    /// @dev Leaf is pre-hashed to allow calling contract to implement whatever hashing scheme they want\n    /// @param root root hash of merkle tree that is the destination of the hash chain\n    /// @param leaf the pre-hashed leaf data, the starting point of the proof\n    /// @param proof the array of hashes forming a hash chain from leaf to root\n    /// @return true if proof is correct, else false\n    function verifyProof(bytes32 root, bytes32 leaf, bytes32[] memory proof) public pure returns (bool) {\n        bytes32 currentHash = leaf;\n\n        // the proof is all siblings of the ancestors of the leaf (including the sibling of the leaf itself)\n        // each iteration of this loop steps one layer higher in the merkle tree\n        for (uint i = 0; i < proof.length; i += 1) {\n            currentHash = parentHash(currentHash, proof[i]);\n        }\n\n        // does the result match the expected root? if so this leaf was committed to when the root was posted\n        // else we must assume the data was not included\n        return currentHash == root;\n    }\n\n    /// @notice Compute the hash of the parent node in the merkle tree\n    /// @dev The arguments are sorted to remove ambiguity about tree definition\n    /// @param a hash of left child node\n    /// @param b hash of right child node\n    /// @return hash of sorted arguments\n    function parentHash(bytes32 a, bytes32 b) public pure returns (bytes32) {\n        if (a < b) {\n            return keccak256(abi.encode(a, b));\n        } else {\n            return keccak256(abi.encode(b, a));\n        }\n    }\n\n}\n\n\n",
        "CodeNames": [
            "MerkleDropFactory.sol",
            "MerkleLib.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MerkleLib.sol and MerkleDropFactory.sol contracts",
                "Type": "Merkle leaves are the same length as the parents that are hashed",
                "Description": "The size of a leaf is the same size of the parent data that is hashed, both are 64 bytes. As a result it is possible to have a hash collision between a leaf and any node in the tree.",
                "Repair": "Consider using leaf = keccak(abi.encodePacked(destination, value)) in withdraw() as this will reduce the size of the leaf data being hashed to 52 bytes. Since keccak256 prevents length extension attacks a different length of data to be hashed can be assumed to give different hashes and prevent a collision between a leaf and other nodes in the tree."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A factory pattern for user-chosen vesting-schedules, that is, a time release schedule for tokens, using merkle proofs to scale\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Any fees must be included in the data of the merkle tree.\n/// @dev The contract cannot introspect into the contents of the merkle tree, except when provided a merkle proof.\n/// @dev User chosen vesting schedules means the contract has parameters that define a line segment that\n/// @dev describes a range of vesting-schedule parameters within which the user can negotiate tradeoffs\n/// @dev More tokens => longer vesting time && slower drip, when used correctly, but the contract does not enforce\n/// @dev coherence of vesting schedules, so someone could make a range of vesting schedules in which\n/// @dev more tokens => longer vesting time && faster drip, but this is a user error, also we wouldn't catch it until\n/// @dev after the tree has been initialized and funded, so we just let them do it.\n/// @dev The choice of which parameters to initialize at tree-creation-time versus at schedule-initialization-time is\n/// @dev somewhat arbitrary, but we choose to have min/max end times at tree scope and min/max total payments at first-withdrawal-time\ncontract MerkleResistor {\n    using MerkleLib for bytes32;\n\n    // tree (vesting schedule) counter\n    uint public numTrees = 0;\n\n    // this represents a user chosen vesting schedule, post initiation\n    struct Tranche {\n        uint totalCoins; // total coins released after vesting complete\n        uint currentCoins; // unclaimed coins remaining in the contract, waiting to be vested\n        uint startTime; // start time of the vesting schedule\n        uint endTime;   // end time of the vesting schedule\n        uint coinsPerSecond;  // how many coins are emitted per second, this value is cached to avoid recomputing it\n        uint lastWithdrawalTime; // keep track of last time user claimed coins to compute coins owed for this withdrawal\n    }\n\n    // this represents an arbitrarily large set of token recipients with partially-initialized vesting schedules\n    struct MerkleTree {\n        bytes32 merkleRoot; // merkle root of tree whose leaves are ranges of vesting schedules for each recipient\n        bytes32 ipfsHash; // ipfs hash of the entire data set represented by the merkle root, in case our servers go down\n        uint minEndTime; // minimum length (offset, not absolute) of vesting schedule in seconds\n        uint maxEndTime; // maximum length (offset, not absolute) of vesting schedule in seconds\n        uint pctUpFront; // percent of vested coins that will be available and withdrawn upon initialization\n        address tokenAddress; // address of token to be distributed\n        uint tokenBalance; // amount of tokens allocated to this tree (this prevents trees from sharing tokens)\n    }\n\n    // initialized[recipient][treeIndex] = hasUserChosenVestingSchedule\n    // could have reused tranches (see below) for this but loading a bool is cheaper than loading an entire struct\n    // NOTE: if a user appears in the same tree multiple times, the first leaf initialized will prevent the others from initializing\n    mapping (address => mapping (uint => bool)) public initialized;\n\n    // basically an array of vesting schedules, but without annoying solidity array syntax\n    mapping (uint => MerkleTree) public merkleTrees;\n\n    // tranches[recipient][treeIndex] = chosenVestingSchedule\n    mapping (address => mapping (uint => Tranche)) public tranches;\n\n    // precision factory used to handle floating point arithmetic\n    uint constant public PRECISION = 1000000;\n\n    // every time a withdrawal occurs\n    event WithdrawalOccurred(uint indexed treeIndex, address indexed destination, uint numTokens, uint tokensLeft);\n\n    // every time a tree is added\n    event MerkleTreeAdded(uint indexed treeIndex, address indexed tokenAddress, bytes32 newRoot, bytes32 ipfsHash);\n\n    // every time a tree is topped up\n    event TokensDeposited(uint indexed treeIndex, address indexed tokenAddress, uint amount);\n\n    /// @notice Add a new merkle tree to the contract, creating a new merkle-vesting-schedule-range\n    /// @dev Anyone may call this function, therefore we must make sure trees cannot affect each other\n    /// @dev Root hash should be built from (destination, minTotalPayments, maxTotalPayments)\n    /// @param newRoot root hash of merkle tree representing vesting schedule ranges\n    /// @param ipfsHash the ipfs hash of the entire dataset, used for redundance so that creator can ensure merkleproof are always computable\n    /// @param minEndTime a continuous range of possible end times are specified, this is the minimum\n    /// @param maxEndTime a continuous range of possible end times are specified, this is the maximum\n    /// @param pctUpFront the percent of tokens user will get at initialization time (note this implies no lock time)\n    /// @param tokenAddress the address of the token contract that is being distributed\n    /// @param tokenBalance the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function addMerkleTree(bytes32 newRoot, bytes32 ipfsHash, uint minEndTime, uint maxEndTime, uint pctUpFront, address tokenAddress, uint tokenBalance) public {\n        // check basic coherence of request\n        require(pctUpFront < 100, 'pctUpFront >= 100');\n        require(minEndTime < maxEndTime, 'minEndTime must be less than maxEndTime');\n\n        // prefix operator ++ increments then evaluates\n        merkleTrees[++numTrees] = MerkleTree(\n            newRoot,\n            ipfsHash,\n            minEndTime,\n            maxEndTime,\n            pctUpFront,\n            tokenAddress,\n            0    // tokenBalance is 0 at first because no tokens have been deposited\n        );\n\n        // pull tokens from user to fund the tree\n        // if tree is insufficiently funded, then some users may not be able to be paid out, this is the responsibility\n        // of the tree creator, if trees are not funded, then the UI will not display the tree\n        depositTokens(numTrees, tokenBalance);\n        emit MerkleTreeAdded(numTrees, tokenAddress, newRoot, ipfsHash);\n    }\n\n    /// @notice Add funds to an existing merkle-tree\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param value the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function depositTokens(uint treeIndex, uint value) public {\n        // storage because we edit\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\n\n        // bookkeeping to make sure trees do not share tokens\n        merkleTree.tokenBalance += value;\n\n        // do the transfer from the caller\n        // NOTE: it is possible for user to overfund the tree and there is no mechanism to reclaim excess tokens\n        // this is because there is no way for the contract to know when a tree has had all leaves claimed.\n        // There is also no way for the contract to know the minimum or maximum liabilities represented by the leaves\n        // in short, there is no on-chain inspection of any of the leaf data except at initialization time\n        // NOTE: a malicious token contract could cause merkleTree.tokenBalance to be out of sync with the token contract\n        // this is an unavoidable possibility, and it could render the tree unusable, while leaving other trees unharmed\n        require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, value);\n    }\n\n    /// @notice Called once per recipient of a vesting schedule to initialize the vesting schedule and fix the parameters\n    /// @dev Only the recipient can initialize their own schedule here, because a meaningful choice is made\n    /// @dev If the tree is over-funded, excess funds are lost. No clear way to get around this without zk-proofs of global tree stats\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param destination address that will receive tokens\n    /// @param vestingTime the actual length of the vesting schedule, chosen by the user\n    /// @param minTotalPayments the minimum amount of tokens they will receive, if they choose minEndTime as vestingTime\n    /// @param maxTotalPayments the maximum amount of tokens they will receive, if they choose maxEndTime as vestingTime\n    /// @param proof array of hashes linking leaf hash of (destination, minTotalPayments, maxTotalPayments) to root\n    function initialize(uint treeIndex, address destination, uint vestingTime, uint minTotalPayments, uint maxTotalPayments, bytes32[] memory proof) external {\n        // user selects own vesting schedule, not others\n        require(msg.sender == destination, 'Can only initialize your own tranche');\n        // can only initialize once\n        require(!initialized[destination][treeIndex], \"Already initialized\");\n        // compute merkle leaf, this is first element of proof\n        bytes32 leaf = keccak256(abi.encode(destination, minTotalPayments, maxTotalPayments));\n        // memory because we do not edit\n        MerkleTree memory tree = merkleTrees[treeIndex];\n        // this calls into MerkleLib, super cheap ~1000 gas per proof element\n        require(tree.merkleRoot.verifyProof(leaf, proof), \"The proof could not be verified.\");\n        // mark tree as initialized, preventing re-entrance or multiple initializations\n        initialized[destination][treeIndex] = true;\n\n        (bool valid, uint totalCoins, uint coinsPerSecond, uint startTime) = verifyVestingSchedule(treeIndex, vestingTime, minTotalPayments, maxTotalPayments);\n        require(valid, 'Invalid vesting schedule');\n\n        // fill out the struct for the address' vesting schedule\n        // don't have to mark as storage here, it's implied (why isn't it always implied when written to? solc-devs?)\n        tranches[destination][treeIndex] = Tranche(\n            totalCoins,    // this is just a cached number for UI, not used\n            totalCoins,    // starts out full\n            startTime,     // start time will usually be in the past, if pctUpFront > 0\n            block.timestamp + vestingTime,  // vesting starts from initialization time\n            coinsPerSecond,  // cached value to avoid recomputation\n            startTime      // this is lastWithdrawalTime, set to startTime to indicate no withdrawals have occurred yet\n        );\n        withdraw(treeIndex, destination);\n    }\n\n    /// @notice Move unlocked funds to the destination\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\n    /// @param treeIndex index into array-like map of merkleTrees, which tree should we apply the proof to?\n    /// @param destination recipient of tokens\n    function withdraw(uint treeIndex, address destination) public {\n        // initialize first, no operations on empty structs, I don't care if the values are \"probably zero\"\n        require(initialized[destination][treeIndex], \"You must initialize your account first.\");\n        // storage, since we are editing\n        Tranche storage tranche = tranches[destination][treeIndex];\n        // if it's empty, don't bother\n        require(tranche.currentCoins >  0, 'No coins left to withdraw');\n        uint currentWithdrawal = 0;\n\n        // if after vesting period ends, give them the remaining coins, also avoids dust from rounding errors\n        if (block.timestamp >= tranche.endTime) {\n            currentWithdrawal = tranche.currentCoins;\n        } else {\n            // compute allowed withdrawal\n            // secondsElapsedSinceLastWithdrawal * coinsPerSecond == coinsAccumulatedSinceLastWithdrawal\n            currentWithdrawal = (block.timestamp - tranche.lastWithdrawalTime) * tranche.coinsPerSecond;\n        }\n        // muto? servo\n        MerkleTree storage tree = merkleTrees[treeIndex];\n\n        // update struct, modern solidity will catch underflow and prevent currentWithdrawal from exceeding currentCoins\n        // but it's computed internally anyway, not user generated\n        tranche.currentCoins -= currentWithdrawal;\n        // move the time counter up so users can't double-withdraw allocated coins\n        // this also works as a re-entrance gate, so currentWithdrawal would be 0 upon re-entrance\n        tranche.lastWithdrawalTime = block.timestamp;\n        // handle the bookkeeping so trees don't share tokens, do it before transferring to create one more re-entrance gate\n        tree.tokenBalance -= currentWithdrawal;\n\n        // transfer the tokens, brah\n        // NOTE: if this is a malicious token, what could happen?\n        // 1/ token doesn't transfer given amount to recipient, this is bad for user, but does not effect other trees\n        // 2/ token fails for some reason, again bad for user, but this does not effect other trees\n        // 3/ token re-enters this function (or other, but this is the only one that transfers tokens out)\n        // in which case, lastWithdrawalTime == block.timestamp, so currentWithdrawal == 0\n        require(IERC20(tree.tokenAddress).transfer(destination, currentWithdrawal), 'Token transfer failed');\n        emit WithdrawalOccurred(treeIndex, destination, currentWithdrawal, tranche.currentCoins);\n    }\n\n    /// @notice Determine if the proposed vesting schedule is legit\n    /// @dev Anyone may call this to check, but it also returns values used in the initialization of vesting schedules\n    /// @param treeIndex index into array-like map of merkleTrees, which tree are we talking about?\n    /// @param vestingTime user chosen length of vesting schedule\n    /// @param minTotalPayments pre-committed (in the root hash) minimum of possible totalCoins\n    /// @param maxTotalPayments pre-committed (in the root hash) maximum of possible totalCoins\n    /// @return valid is the proposed vesting-schedule valid\n    /// @return totalCoins amount of coins allocated in the vesting schedule\n    /// @return coinsPerSecond amount of coins released every second, in the proposed vesting schedule\n    /// @return startTime start time of vesting schedule implied by supplied parameters, will always be <= block.timestamp\n    function verifyVestingSchedule(uint treeIndex, uint vestingTime, uint minTotalPayments, uint maxTotalPayments) public view returns (bool, uint, uint, uint) {\n        // vesting schedules for non-existing trees are invalid, I don't care how much you like uninitialized structs\n        if (treeIndex > numTrees) {\n            return (false, 0, 0, 0);\n        }\n\n        // memory not storage, since we do not edit the tree, and it's a view function anyways\n        MerkleTree memory tree = merkleTrees[treeIndex];\n\n        // vesting time must sit within the closed interval of [minEndTime, maxEndTime]\n        if (vestingTime > tree.maxEndTime || vestingTime < tree.minEndTime) {\n            return (false, 0, 0, 0);\n        }\n\n        uint totalCoins;\n        if (vestingTime == tree.maxEndTime) {\n            // this is to prevent dust accumulation from rounding errors\n            // maxEndTime results in max payments, no further computation necessary\n            totalCoins = maxTotalPayments;\n        } else {\n            // remember grade school algebra? slope = \u0394y / \u0394x\n            // this is the slope of eligible vesting schedules. In general, 0 < m < 1,\n            // (longer vesting schedules should result in less coins per second, hence \"resistor\")\n            // so we multiply by a precision factor to reduce rounding errors\n            // y axis = total coins released after vesting completed\n            // x axis = length of vesting schedule\n            // this is the line of valid end-points for the chosen vesting schedule line, see below\n            // NOTE: this reverts if minTotalPayments > maxTotalPayments, which is a good thing\n            uint paymentSlope = (maxTotalPayments - minTotalPayments) * PRECISION / (tree.maxEndTime - tree.minEndTime);\n\n            // y = mx + b = paymentSlope * (x - x0) + y0\n            // divide by precision factor here since we have completed the rounding error sensitive operations\n            totalCoins = (paymentSlope * (vestingTime - tree.minEndTime) / PRECISION) + minTotalPayments;\n        }\n\n        // this is a different slope, the slope of their chosen vesting schedule\n        // y axis = cumulative coins emitted\n        // x axis = time elapsed\n        // NOTE: vestingTime starts from block.timestamp, so doesn't include coins already available from pctUpFront\n        // totalCoins / vestingTime is wrong, we have to multiple by the proportion of the coins that are indexed\n        // by vestingTime, which is (100 - pctUpFront) / 100\n        uint coinsPerSecond = (totalCoins * (uint(100) - tree.pctUpFront)) / (vestingTime * 100);\n\n        // vestingTime is relative to initialization point\n        // endTime = block.timestamp + vestingTime\n        // vestingLength = totalCoins / coinsPerSecond\n        uint startTime = block.timestamp + vestingTime - (totalCoins / coinsPerSecond);\n\n        return (true, totalCoins, coinsPerSecond, startTime);\n    }\n\n}\n\n\n",
        "CodeNames": [
            "MerkleResistor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MerkleResistor.sol",
                "Type": "Division by zero",
                "Description": "It is possible for coinsPerSecond to be zero. In these cases, the startTime calculation will revert from division by zero, preventing initialization, and by extension, withdrawals of vested tokens.",
                "Repair": "Scale up coinsPerSecond by PRECISION, then scale down when executing withdrawals"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IPriceGate.sol\";\n\n/// @title A factory pattern for a price gate whose price increases exponentially on purchase and decays linearly thereafter\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract has no management key, anyone can add a gate\n/// @dev Note passing thru the gate forwards all gas, so beneficiary can be a contract, possibly malicious\ncontract SpeedBumpPriceGate is IPriceGate {\n\n    // this represents a single gate\n    struct Gate {\n        uint priceIncreaseFactor;\n        uint priceIncreaseDenominator;\n        uint lastPrice;\n        uint decayFactor;\n        uint priceFloor;\n        uint lastPurchaseBlock;\n        address beneficiary;\n    }\n\n    // array-like mapping of gate structs\n    mapping (uint => Gate) public gates;\n    // count the gates as they come in!\n    uint public numGates;\n\n    /// @notice Add a price gate to the list of available price gates\n    /// @dev Anyone can call this, but it must be connected to MerkleIdentity via priceGateIndex to be used\n    /// @dev The price increase factor is split into numerator and denominator to enable fractions (wow! I love fractions!)\n    /// @param priceFloor the starting price and the lowest price that can be reached via decay\n    /// @param priceDecay the per-block rate at which the price reduces until it hits the price floor\n    /// @param priceIncrease the numerator of the factor by which the price multiplies when a purchase occurs\n    /// @param priceIncreaseDenominator the denominator of the price increase factor\n    /// @param beneficiary who receives the proceeds from a purchase\n    function addGate(uint priceFloor, uint priceDecay, uint priceIncrease, uint priceIncreaseDenominator, address beneficiary) external {\n        // prefix operator increments then evaluates\n        Gate storage gate = gates[++numGates];\n        gate.priceFloor = priceFloor;\n        gate.decayFactor = priceDecay;\n        gate.priceIncreaseFactor = priceIncrease;\n        gate.priceIncreaseDenominator = priceIncreaseDenominator;\n        gate.beneficiary = beneficiary;\n    }\n\n    /// @notice Get the cost of passing thru this gate\n    /// @param index which gate are we talking about?\n    /// @return _ethCost the amount of ether required to pass thru this gate\n    function getCost(uint index) override public view returns (uint _ethCost) {\n        Gate memory gate = gates[index];\n        // compute the linear decay\n        uint decay = gate.decayFactor * (block.number - gate.lastPurchaseBlock);\n        // gate.lastPrice - decay < gate.priceFloor (left side could underflow)\n        if (gate.lastPrice < decay + gate.priceFloor) {\n            return gate.priceFloor;\n        } else {\n            return gate.lastPrice - decay;\n        }\n    }\n\n    /// @notice Pass thru this gate, should be called by MerkleIndex\n    /// @dev This can be called by anyone, devs can call it to test it on mainnet\n    /// @param index which gate are we passing thru?\n    function passThruGate(uint index, address) override external payable {\n        uint price = getCost(index);\n        require(msg.value >= price, 'Please send more ETH');\n\n        // bump up the price\n        Gate storage gate = gates[index];\n        // multiply by the price increase factor\n        gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;\n        // move up the reference\n        gate.lastPurchaseBlock = block.number;\n\n        // pass thru the ether\n        if (msg.value > 0) {\n            // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here\n            (bool sent, bytes memory data) = gate.beneficiary.call{value: msg.value}(\"\");\n            require(sent, 'ETH transfer failed');\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "SpeedBumpPriceGate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "SpeedBumpPriceGate contract's passThruGate function",
                "Type": "Excess ether not returned",
                "Description": "The passThruGate function did not return the excess ether, which would cause asset loss to the user.",
                "Repair": "Add a check to return excess ether to the user"
            },
            {
                "Location": "SpeedBumpPriceGate contract's addGate() function",
                "Type": "Lack of input validation",
                "Description": "If priceIncreaseDenominator is set to 0 when addGate(), in passThruGate() the tx will revert at L72 because of div by 0.",
                "Repair": "Add a check to require priceIncreaseDenominator > 0"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IVoterID.sol\";\nimport \"../interfaces/IPriceGate.sol\";\nimport \"../interfaces/IEligibility.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A generalized NFT minting system using merkle trees to pre-commit to metadata posted to ipfs\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissioned, it requires a treeAdder key to add trees\n/// @dev Merkle trees are used at this layer to prove the correctness of metadata added to newly minted NFTs\n/// @dev A single NFT contract may have many merkle trees with the same or different roots added here\n/// @dev Each tree added has a price gate (specifies price schedule) and an eligibility gate (specifies eligibility criteria)\n/// @dev Double minting of the same NFT is prevented by the NFT contract (VoterID)\ncontract MerkleIdentity {\n    using MerkleLib for bytes32;\n\n    // this represents a mint of a single NFT contract with a fixed price gate and eligibility gate\n    struct MerkleTree {\n        bytes32 metadataMerkleRoot;  // root of merkle tree whose leaves are uri strings to be assigned to minted NFTs\n        bytes32 ipfsHash; // ipfs hash of complete uri dataset, as redundancy so that merkle proof remain computable\n        address nftAddress; // address of NFT contract to be minted\n        address priceGateAddress;  // address price gate contract\n        address eligibilityAddress;  // address of eligibility gate contract\n        uint eligibilityIndex; // enables re-use of eligibility contracts\n        uint priceIndex; // enables re-use of price gate contracts\n    }\n\n    // array-like mapping of index to MerkleTree structs\n    mapping (uint => MerkleTree) public merkleTrees;\n    // count the trees\n    uint public numTrees;\n\n    // management key used to set ipfs hashes and treeAdder addresses\n    address public management;\n    // treeAdder is address that can add trees, separated from management to prevent switching it to a broken contract\n    address public treeAdder;\n\n    // every time a merkle tree is added\n    event MerkleTreeAdded(uint indexed index, address indexed nftAddress);\n\n    // simple call gate\n    modifier managementOnly() {\n        require (msg.sender == management, 'Only management may call this');\n        _;\n    }\n\n    /// @notice Whoever deploys the contract sets the two privileged keys\n    /// @param _mgmt key that will initially be both management and treeAdder\n    constructor(address _mgmt) {\n        management = _mgmt;\n        treeAdder = _mgmt;\n    }\n\n    /// @notice Change the management key\n    /// @dev Only the current management key can change this\n    /// @param newMgmt the new management key\n    function setManagement(address newMgmt) external managementOnly {\n        management = newMgmt;\n    }\n\n    /// @notice Change the treeAdder key\n    /// @dev Only the current management key can call this\n    /// @param newAdder new addres that will be able to add trees, old address will not be able to\n    function setTreeAdder(address newAdder) external managementOnly {\n        treeAdder = newAdder;\n    }\n\n    /// @notice Set the ipfs hash of a specific tree\n    /// @dev Only the current management key can call this\n    /// @param merkleIndex which merkle tree are we talking about?\n    /// @param hash the new ipfs hash summarizing this dataset, written as bytes32 omitting the first 2 bytes \"Qm\"\n    function setIpfsHash(uint merkleIndex, bytes32 hash) external managementOnly {\n        MerkleTree storage tree = merkleTrees[merkleIndex];\n        tree.ipfsHash = hash;\n    }\n\n    /// @notice Create a new merkle tree, opening a mint to an existing contract\n    /// @dev Only treeAdder can call this\n    /// @param metadataMerkleRoot merkle root of the complete metadata set represented as mintable by this tree\n    /// @param ipfsHash ipfs hash of complete dataset (note that you can post hash here without posting to network aka \"submarining\"\n    /// @param nftAddress address of NFT contract to be minted (must conform to IVoterID interface)\n    /// @param priceGateAddress address of price gate contract (must conform to IPriceGate interface)\n    /// @param eligibilityAddress address of eligibility gate contract (must conform to IEligibility interface)\n    /// @param eligibilityIndex index passed to eligibility gate, which in general will have many gates, to select which parameters\n    /// @param priceIndex index passed to price gate to select which parameters to use\n    function addMerkleTree(\n        bytes32 metadataMerkleRoot,\n        bytes32 ipfsHash,\n        address nftAddress,\n        address priceGateAddress,\n        address eligibilityAddress,\n        uint eligibilityIndex,\n        uint priceIndex) external {\n        require(msg.sender == treeAdder, 'Only treeAdder can add trees');\n        MerkleTree storage tree = merkleTrees[++numTrees];\n        tree.metadataMerkleRoot = metadataMerkleRoot;\n        tree.ipfsHash = ipfsHash;\n        tree.nftAddress = nftAddress;\n        tree.priceGateAddress = priceGateAddress;\n        tree.eligibilityAddress = eligibilityAddress;\n        tree.eligibilityIndex = eligibilityIndex;\n        tree.priceIndex = priceIndex;\n        emit MerkleTreeAdded(numTrees, nftAddress);\n    }\n\n    /// @notice Mint a new NFT\n    /// @dev Anyone may call this, but they must pass thru the two gates\n    /// @param merkleIndex which merkle tree are we withdrawing the NFT from?\n    /// @param tokenId the id number of the NFT to be minted, this data is bound to the uri in each leaf of the metadata merkle tree\n    /// @param uri the metadata uri that will be associated with the minted NFT\n    /// @param addressProof merkle proof proving the presence of msg.sender's address in an eligibility merkle tree\n    /// @param metadataProof sequence of hashes from leaf hash (tokenID, uri) to merkle root, proving data validity\n    function withdraw(uint merkleIndex, uint tokenId, string memory uri, bytes32[] memory addressProof, bytes32[] memory metadataProof) external payable {\n        MerkleTree storage tree = merkleTrees[merkleIndex];\n        IVoterID id = IVoterID(tree.nftAddress);\n\n        // mint an identity first, this keeps the token-collision gas cost down\n        id.createIdentityFor(msg.sender, tokenId, uri);\n\n        // check that the merkle index is real\n        require(merkleIndex <= numTrees, 'merkleIndex out of range');\n\n        // verify that the metadata is real\n        require(verifyMetadata(tree.metadataMerkleRoot, tokenId, uri, metadataProof), \"The metadata proof could not be verified\");\n\n        // check eligibility of address\n        IEligibility(tree.eligibilityAddress).passThruGate(tree.eligibilityIndex, msg.sender, addressProof);\n\n        // check that the price is right\n        IPriceGate(tree.priceGateAddress).passThruGate{value: msg.value}(tree.priceIndex, msg.sender);\n\n    }\n\n    /// @notice Get the current price for minting an NFT from a particular tree\n    /// @dev This does not take tokenId as an argument, if you want different tokenIds to have different prices, use different trees\n    /// @return ethCost the cost in wei of minting an NFT (could represent token cost if price gate takes tokens)\n    function getPrice(uint merkleIndex) public view returns (uint) {\n        MerkleTree memory tree = merkleTrees[merkleIndex];\n        uint ethCost = IPriceGate(tree.priceGateAddress).getCost(tree.priceIndex);\n        return ethCost;\n    }\n\n    /// @notice Is the given address eligibile to mint from the given tree\n    /// @dev If the eligibility gate does not use merkle trees, the proof can be left empty or used for anything else\n    /// @param merkleIndex which tree are we talking about?\n    /// @param recipient the address about which we are querying eligibility\n    /// @param proof merkle proof linking recipient to eligibility merkle root\n    /// @return eligibility true if recipient is currently eligible\n    function isEligible(uint merkleIndex, address recipient, bytes32[] memory proof) public view returns (bool) {\n        MerkleTree memory tree = merkleTrees[merkleIndex];\n        return IEligibility(tree.eligibilityAddress).isEligible(tree.eligibilityIndex, recipient, proof);\n    }\n\n    /// @notice Is the provided metadata included in tree?\n    /// @dev This is public for interfaces, called internally by withdraw function\n    /// @param root merkle root (proof destination)\n    /// @param tokenId index of NFT being queried\n    /// @param uri intended uri of NFT being minted\n    /// @param proof sequence of hashes linking leaf data to merkle root\n    function verifyMetadata(bytes32 root, uint tokenId, string memory uri, bytes32[] memory proof) public pure returns (bool) {\n        bytes32 leaf = keccak256(abi.encode(tokenId, uri));\n        return root.verifyProof(leaf, proof);\n    }\n\n}\n\n",
        "CodeNames": [
            "MerkleIdentity.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MerkleIdentity contract's merkleIndex check",
                "Type": "Out of range check",
                "Description": "The merkleIndex check did not fail for index 0, which should have failed.",
                "Repair": "Change the check to require merkleIndex <= numTrees && merkleIndex > 0"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./MerkleLib.sol\";\n\n/// @title A factory pattern for merkledrops, that is, airdrops using merkleproofs to compute eligibility\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract is permissionless and public facing. Any fees must be included in the data of the merkle tree.\n/// @dev The contract cannot introspect into the contents of the merkle tree, except when provided a merkle proof,\n/// @dev therefore the total liabilities of the merkle tree are untrusted and tree balances must be managed separately\ncontract MerkleDropFactory {\n    using MerkleLib for bytes32;\n\n    // the number of airdrops in this contract\n    uint public numTrees = 0;\n\n    // this represents a single airdrop\n    struct MerkleTree {\n        bytes32 merkleRoot;  // merkleroot of tree whose leaves are (address,uint) pairs representing amount owed to user\n        bytes32 ipfsHash; // ipfs hash of entire dataset, as backup in case our servers turn off...\n        address tokenAddress; // address of token that is being airdropped\n        uint tokenBalance; // amount of tokens allocated for this tree\n        uint spentTokens; // amount of tokens dispensed from this tree\n    }\n\n    // withdrawn[recipient][treeIndex] = hasUserWithdrawnAirdrop\n    mapping (address => mapping (uint => bool)) public withdrawn;\n\n    // array-like map for all ze merkle trees (airdrops)\n    mapping (uint => MerkleTree) public merkleTrees;\n\n    // every time there's a withdraw\n    event WithdrawalOccurred(uint indexed treeIndex, address indexed destination, uint value);\n\n    // every time a tree is added\n    event MerkleTreeAdded(uint indexed treeIndex, address indexed tokenAddress, bytes32 newRoot, bytes32 ipfsHash);\n\n    // every time a tree is topped up\n    event TokensDeposited(uint indexed treeIndex, address indexed tokenAddress, uint amount);\n\n    /// @notice Add a new merkle tree to the contract, creating a new merkle-drop\n    /// @dev Anyone may call this function, therefore we must make sure trees cannot affect each other\n    /// @param newRoot root hash of merkle tree representing liabilities == (destination, value) pairs\n    /// @param ipfsHash the ipfs hash of the entire dataset, used for redundance so that creator can ensure merkleproof are always computable\n    /// @param tokenAddress the address of the token contract that is being distributed\n    /// @param tokenBalance the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function addMerkleTree(bytes32 newRoot, bytes32 ipfsHash, address tokenAddress, uint tokenBalance) public {\n        // prefix operator ++ increments then evaluates\n        merkleTrees[++numTrees] = MerkleTree(\n            newRoot,\n            ipfsHash,\n            tokenAddress,\n            0,  // ain't no tokens in here yet\n            0   // ain't nobody claimed no tokens yet either\n        );\n        // you don't get to add a tree without funding it\n        depositTokens(numTrees, tokenBalance);\n        // I guess we should tell people (interfaces) what happened\n        emit MerkleTreeAdded(numTrees, tokenAddress, newRoot, ipfsHash);\n    }\n\n    /// @notice Add funds to an existing merkle-drop\n    /// @dev Anyone may call this function, the only risk here is that the token contract is malicious, rendering the tree malicious\n    /// @param treeIndex index into array-like map of merkleTrees\n    /// @param value the amount of tokens user wishes to use to fund the airdrop, note trees can be under/overfunded\n    function depositTokens(uint treeIndex, uint value) public {\n        // storage since we are editing\n        MerkleTree storage merkleTree = merkleTrees[treeIndex];\n\n        // bookkeeping to make sure trees don't share tokens\n        merkleTree.tokenBalance += value;\n\n        // transfer tokens, if this is a malicious token, then this whole tree is malicious\n        // but it does not effect the other trees\n        require(IERC20(merkleTree.tokenAddress).transferFrom(msg.sender, address(this), value), \"ERC20 transfer failed\");\n        emit TokensDeposited(treeIndex, merkleTree.tokenAddress, value);\n    }\n\n    /// @notice Claim funds as a recipient in the merkle-drop\n    /// @dev Anyone may call this function for anyone else, funds go to destination regardless, it's just a question of\n    /// @dev who provides the proof and pays the gas, msg.sender is not used in this function\n    /// @param treeIndex index into array-like map of merkleTrees, which tree should we apply the proof to?\n    /// @param destination recipient of tokens\n    /// @param value amount of tokens that will be sent to destination\n    /// @param proof array of hashes bridging from leaf (hash of destination | value) to merkle root\n    function withdraw(uint treeIndex, address destination, uint value, bytes32[] memory proof) public {\n        // no withdrawing from uninitialized merkle trees\n        require(treeIndex <= numTrees, \"Provided merkle index doesn't exist\");\n        // no withdrawing same airdrop twice\n        require(!withdrawn[destination][treeIndex], \"You have already withdrawn your entitled token.\");\n        // compute merkle leaf, this is first element of proof\n        bytes32 leaf = keccak256(abi.encode(destination, value));\n        // storage because we edit\n        MerkleTree storage tree = merkleTrees[treeIndex];\n        // this calls to MerkleLib, will return false if recursive hashes do not end in merkle root\n        require(tree.merkleRoot.verifyProof(leaf, proof), \"The proof could not be verified.\");\n        // close re-entrance gate, prevent double claims\n        withdrawn[destination][treeIndex] = true;\n        // update struct\n        tree.tokenBalance -= value;\n        tree.spentTokens += value;\n        // transfer the tokens\n        // NOTE: if the token contract is malicious this call could re-enter this function\n        // which will fail because withdrawn will be set to true\n        require(IERC20(tree.tokenAddress).transfer(destination, value), \"ERC20 transfer failed\");\n        emit WithdrawalOccurred(treeIndex, destination, value);\n    }\n\n}\n\n",
        "CodeNames": [
            "MerkleDropFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MerkleDropFactory contract's depositTokens() function",
                "Type": "Missing input validation",
                "Description": "The depositTokens() function does not first check to ensure that the treeIndex exists.",
                "Repair": "Add a check to ensure 0 < treeIndex <= numTrees"
            }
        ]
    }
]