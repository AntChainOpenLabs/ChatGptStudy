[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "anchor_beth_reward/src/user.rs#L187-L212",
                "Type": "bEth Rewards Depletion",
                "Description": "An attacker may arbitrarily increase their bEth balance either by flashloan of purchase of wormhole eth, then converting it bEth via anchor_beth_converter. The attacker may then have a significant portion of the total balance. This use can then call the contract which pushes rewards to anchor_beth_reward this will increase the reward_balance of the contract. Since the attacker controls a large portion of the bEth balance they will receive a higher portion of the rewards. They may then convert the bEth back to wormhole eth and close their position.",
                "Repair": "Option 1: Only allow the global_index to be updated once per block and cap the amount of rewards that may be paid per block. Option 2: Induce a wait time before the user may begin earning rewards."
            },
            {
                "Location": "anchor_airdrop_registry/src/contract.rs#L109",
                "Type": "Missing Access Control",
                "Description": "FabricateMIRClaim and FabricateANCClaim should only be issued by the Hub contract (the central hub for all minted bLuna managed by Lido). However, execute_fabricate_anchor_claim and execute_fabricate_mir_claim do not restrict the caller, allowing anyone to submit these msgs.",
                "Repair": "Add at least simple access control checks in the contract to ensure that these functions can only be called by the Hub and not by others."
            },
            {
                "Location": "overseer/src/contract.rs#L19",
                "Type": "Out-of-Date Data",
                "Description": "When the anc_purchase_factor is updated by the owner, the execute_epoch_operations is not called. This will cause to out-of-date data.",
                "Repair": "Consider calling execute_epoch_operations function after config update."
            },
            {
                "Location": "collector/src/contract.rs#L130-L137",
                "Type": "Sandwich Attack",
                "Description": "The collector contract allows anyone to sweep, swapping an asset token to ANC through astro port. Note that belief_price is not set and config.max_spread might not be set as well or misconfigured. This allows an attacker to create a contract to perform a sandwich attack to make a profit on this trade.",
                "Repair": "Consider setting a ANC/asset belief_price from an oracle."
            },
            {
                "Location": "anchor_basset_hub/src/config.rs",
                "Type": "Updating hub's token contract address may lead to incorrect undelegation amount",
                "Description": "Updating the hub\u2019s token contract address may cause wrong amounts of tokens to be calculated during processing of undelegations, since the amount of unbonded bLuna tokens is stored for batched unbonding as requested_with_fee.",
                "Repair": "Remove the ability to update token_contract config value, or assert that requested_with_fee is zero before allowing an update of the token_contract address"
            },
            {
                "Location": "anchor_basset_reward/src/user.rs",
                "Type": "Pending yields can be stolen",
                "Description": "If the pending yield on an underlying strategy can be harvested and cause a surge of rewards to all existing investors, especially if the harvest can be triggered permissionlessly, then the attacker can amplify the attack using a flash loan.",
                "Repair": "Update state.global_index before changing the user's balance, transfer rewards and update global_index in one transaction"
            },
            {
                "Location": "claim_rewards function in the money-market-contracts/contracts/market",
                "Type": "Claim rewards may revert",
                "Description": "Users won't be able to claim their rewards anymore once the amount of the rewards excess the spend_limit config on distributor_contract.",
                "Repair": "Remove the spend_limit or allow users to specify an amount when claim_rewards."
            },
            {
                "Location": "feed_prices function in the money-market-contracts/oracle",
                "Type": "Delayed transaction may disrupt price feeds",
                "Description": "The price feeds can be disrupted when the network is congested, or the endpoint is down for a while, or the feeder bot handled the message queue inappropriately, as a result, the transactions with stale prices get accepted as fresh prices.",
                "Repair": "Reject stale price and reject future timestamp, graceFuturePeriod can be set to 3, which means < 3s is allowed."
            },
            {
                "Location": "pick_validator function",
                "Type": "Predictable randomness",
                "Description": "The randomness in the pick_validator function can be predicted, allowing a validator to steal rewards and increase their own.",
                "Repair": "Keep track of all bonds with a bond_id and create a map of bond_id - validator. If a validator's stake decreased due to slashing, take the remaining unstake amount proportionally from all other validators."
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"ethereum/BytesLib.sol\";\n\ninterface WormholeCoreBridge {\n    function publishMessage(\n        uint32 nonce,\n        bytes memory payload,\n        uint8 consistencyLevel\n    ) external payable returns (uint64 sequence);\n\n    struct Signature {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        uint8 guardianIndex;\n    }\n\n    struct VM {\n        uint8 version;\n        uint32 timestamp;\n        uint32 nonce;\n        uint16 emitterChainId;\n        bytes32 emitterAddress;\n        uint64 sequence;\n        uint8 consistencyLevel;\n        bytes payload;\n        uint32 guardianSetIndex;\n        Signature[] signatures;\n        bytes32 hash;\n    }\n\n    function parseAndVerifyVM(bytes calldata encodedVM)\n        external\n        view\n        returns (\n            VM memory vm,\n            bool valid,\n            string memory reason\n        );\n}\n\ninterface WormholeTokenBridge {\n    function transferTokens(\n        address token,\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        uint256 arbiterFee,\n        uint32 nonce\n    ) external payable returns (uint64 sequence);\n\n    struct Transfer {\n        // PayloadID uint8 = 1\n        uint8 payloadID;\n        // Amount being transferred (big-endian uint256)\n        uint256 amount;\n        // Address of the token. Left-zero-padded if shorter than 32 bytes\n        bytes32 tokenAddress;\n        // Chain ID of the token\n        uint16 tokenChain;\n        // Address of the recipient. Left-zero-padded if shorter than 32 bytes\n        bytes32 to;\n        // Chain ID of the recipient\n        uint16 toChain;\n        // Amount of tokens (big-endian uint256) that the user is willing to pay as relayer fee. Must be <= Amount.\n        uint256 fee;\n    }\n\n    function parseTransfer(bytes memory encoded)\n        external\n        pure\n        returns (Transfer memory transfer);\n\n    function isTransferCompleted(bytes32 hash) external view returns (bool);\n\n    function completeTransfer(bytes memory encodedVm) external;\n\n    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress)\n        external\n        view\n        returns (address);\n\n    function chainId() external view returns (uint16);\n}\n\ncontract CrossAnchorBridge is\n    Initializable,\n    UUPSUpgradeable,\n    OwnableUpgradeable\n{\n    uint16 private constant TERRA_CHAIN_ID = 3;\n\n    uint8 private constant FLAG_INCOMING_TRANSFER = 0x80; // 1000 0000\n    uint8 private constant FLAG_OUTGOING_TRANSFER = 0x40; // 0100 0000\n    uint8 private constant FLAG_BOTH_TRANSFERS = 0xC0; // 1100 0000\n    uint8 private constant FLAG_NO_ASSC_TRANSFER = 0x00; // 0000 0000\n\n    uint8 private constant OP_CODE_DEPOSIT_STABLE = 0 | FLAG_BOTH_TRANSFERS;\n    uint8 private constant OP_CODE_REDEEM_STABLE = 1 | FLAG_BOTH_TRANSFERS;\n\n    uint8 private constant OP_CODE_REPAY_STABLE = 0 | FLAG_INCOMING_TRANSFER;\n    uint8 private constant OP_CODE_LOCK_COLLATERAL = 1 | FLAG_INCOMING_TRANSFER;\n\n    uint8 private constant OP_CODE_UNLOCK_COLLATERAL =\n        0 | FLAG_OUTGOING_TRANSFER;\n    uint8 private constant OP_CODE_BORROW_STABLE = 1 | FLAG_OUTGOING_TRANSFER;\n    uint8 private constant OP_CODE_CLAIM_REWARDS = 2 | FLAG_OUTGOING_TRANSFER;\n\n    uint32 private constant INSTRUCTION_NONCE = 1324532;\n    uint32 private constant TOKEN_TRANSFER_NONCE = 15971121;\n\n    uint8 private CONSISTENCY_LEVEL;\n    address private WORMHOLE_CORE_BRIDGE;\n    address private WORMHOLE_TOKEN_BRIDGE;\n    bytes32 private TERRA_ANCHOR_BRIDGE_ADDRESS;\n\n    // Wormhole-wrapped Terra stablecoin tokens that are whitelisted in Terra Anchor Market. Example: UST.\n    mapping(address => bool) public whitelistedStableTokens;\n    // Wormhole-wrapped Terra Anchor yield-generating tokens that can be redeemed for Terra stablecoins. Example: aUST.\n    mapping(address => bool) public whitelistedAnchorStableTokens;\n    // Wormhole-wrapped Terra cw20 tokens that can be used as collateral in Anchor. Examples: bLUNA, bETH.\n    mapping(address => bool) public whitelistedCollateralTokens;\n\n    // Stores hashes of completed incoming token transfer.\n    mapping(bytes32 => bool) public completedTokenTransfers;\n\n    function initialize(\n        uint8 _consistencyLevel,\n        address _wust,\n        address _aust,\n        address[] memory _collateralTokens,\n        address _wormholeCoreBridge,\n        address _wormholeTokenBridge,\n        bytes32 _terraAnchorBridgeAddress\n    ) public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        CONSISTENCY_LEVEL = _consistencyLevel;\n        whitelistedStableTokens[_wust] = true;\n        whitelistedAnchorStableTokens[_aust] = true;\n        for (uint8 i = 0; i < _collateralTokens.length; i++) {\n            whitelistedCollateralTokens[_collateralTokens[i]] = true;\n        }\n        WORMHOLE_CORE_BRIDGE = _wormholeCoreBridge;\n        WORMHOLE_TOKEN_BRIDGE = _wormholeTokenBridge;\n        TERRA_ANCHOR_BRIDGE_ADDRESS = _terraAnchorBridgeAddress;\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    function encodeAddress(address addr)\n        internal\n        pure\n        returns (bytes32 encodedAddress)\n    {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function handleStableToken(\n        address token,\n        uint256 amount,\n        uint8 opCode\n    ) internal {\n        // Check that `token` is a whitelisted stablecoin token.\n        // require(whitelistedStableTokens[token]);\n        handleToken(token, amount, opCode);\n    }\n\n    function handleToken(\n        address token,\n        uint256 amount,\n        uint8 opCode\n    ) internal {\n        // Transfer ERC-20 token from message sender to this contract.\n        SafeERC20.safeTransferFrom(\n            IERC20(token),\n            msg.sender,\n            address(this),\n            amount\n        );\n        // Allow wormhole to spend USTw from this contract.\n        SafeERC20.safeApprove(IERC20(token), WORMHOLE_TOKEN_BRIDGE, amount);\n        // Initiate token transfer.\n        uint64 tokenTransferSequence = WormholeTokenBridge(\n            WORMHOLE_TOKEN_BRIDGE\n        ).transferTokens(\n                token,\n                amount,\n                TERRA_CHAIN_ID,\n                TERRA_ANCHOR_BRIDGE_ADDRESS,\n                0,\n                TOKEN_TRANSFER_NONCE\n            );\n        // Send instruction message to Terra manager.\n        WormholeCoreBridge(WORMHOLE_CORE_BRIDGE).publishMessage(\n            INSTRUCTION_NONCE,\n            abi.encodePacked(\n                opCode,\n                encodeAddress(msg.sender),\n                tokenTransferSequence\n            ),\n            CONSISTENCY_LEVEL\n        );\n    }\n\n    function depositStable(address token, uint256 amount) external {\n        handleStableToken(token, amount, OP_CODE_DEPOSIT_STABLE);\n    }\n\n    function repayStable(address token, uint256 amount) external {\n        handleStableToken(token, amount, OP_CODE_REPAY_STABLE);\n    }\n\n    function unlockCollateral(\n        bytes32 collateralTokenTerraAddress,\n        uint128 amount\n    ) external {\n        WormholeCoreBridge(WORMHOLE_CORE_BRIDGE).publishMessage(\n            INSTRUCTION_NONCE,\n            abi.encodePacked(\n                OP_CODE_UNLOCK_COLLATERAL,\n                encodeAddress(msg.sender),\n                collateralTokenTerraAddress,\n                amount\n            ),\n            CONSISTENCY_LEVEL\n        );\n    }\n\n    function borrowStable(uint256 amount) external {\n        WormholeCoreBridge(WORMHOLE_CORE_BRIDGE).publishMessage(\n            INSTRUCTION_NONCE,\n            abi.encodePacked(\n                OP_CODE_BORROW_STABLE,\n                encodeAddress(msg.sender),\n                amount\n            ),\n            CONSISTENCY_LEVEL\n        );\n    }\n\n    function redeemStable(address token, uint256 amount) external {\n        // require(whitelistedAnchorStableTokens[token]);\n        handleToken(token, amount, OP_CODE_REDEEM_STABLE);\n    }\n\n    function lockCollateral(address token, uint256 amount) external {\n        // require(whitelistedCollateralTokens[token]);\n        handleToken(token, amount, OP_CODE_LOCK_COLLATERAL);\n    }\n\n    struct IncomingTokenTransferInfo {\n        uint16 chainId;\n        bytes32 tokenRecipientAddress;\n        uint64 tokenTransferSequence;\n        uint64 instructionSequence;\n    }\n\n    using BytesLib for bytes;\n\n    function parseIncomingTokenTransferInfo(bytes memory encoded)\n        public\n        pure\n        returns (IncomingTokenTransferInfo memory incomingTokenTransferInfo)\n    {\n        uint256 index = 0;\n\n        incomingTokenTransferInfo.chainId = encoded.toUint16(index);\n        index += 2;\n\n        incomingTokenTransferInfo.tokenRecipientAddress = encoded.toBytes32(\n            index\n        );\n        index += 32;\n\n        incomingTokenTransferInfo.tokenTransferSequence = encoded.toUint64(\n            index\n        );\n        index += 8;\n\n        incomingTokenTransferInfo.instructionSequence = encoded.toUint64(index);\n        index += 8;\n\n        require(\n            encoded.length == index,\n            \"invalid IncomingTokenTransferInfo encoded length\"\n        );\n    }\n\n    // operations are bundled into two messages:\n    // - a token transfer message from the token bridge\n    // - a generic message providing context to the token transfer\n    function processTokenTransferInstruction(\n        bytes memory encodedIncomingTokenTransferInfo,\n        bytes memory encodedTokenTransfer\n    ) external {\n        WormholeTokenBridge wormholeTokenBridge = WormholeTokenBridge(\n            WORMHOLE_TOKEN_BRIDGE\n        );\n        WormholeCoreBridge wormholeCoreBridge = WormholeCoreBridge(\n            WORMHOLE_CORE_BRIDGE\n        );\n\n        (\n            WormholeCoreBridge.VM memory incomingTokenTransferInfoVM,\n            bool validIncomingTokenTransferInfo,\n            string memory reasonIncomingTokenTransferInfo\n        ) = wormholeCoreBridge.parseAndVerifyVM(\n                encodedIncomingTokenTransferInfo\n            );\n        require(\n            validIncomingTokenTransferInfo,\n            reasonIncomingTokenTransferInfo\n        );\n        require(\n            incomingTokenTransferInfoVM.emitterChainId == TERRA_CHAIN_ID,\n            \"message does not come from terra\"\n        );\n        require(\n            incomingTokenTransferInfoVM.emitterAddress ==\n                TERRA_ANCHOR_BRIDGE_ADDRESS,\n            \"message does not come from terra anchor bridge\"\n        );\n        require(\n            !completedTokenTransfers[incomingTokenTransferInfoVM.hash],\n            \"transfer info already processed\"\n        );\n\n        // block replay attacks\n        completedTokenTransfers[incomingTokenTransferInfoVM.hash] = true;\n        IncomingTokenTransferInfo\n            memory incomingTokenTransferInfo = parseIncomingTokenTransferInfo(\n                incomingTokenTransferInfoVM.payload\n            );\n\n        (\n            WormholeCoreBridge.VM memory tokenTransferVM,\n            bool valid,\n            string memory reason\n        ) = wormholeCoreBridge.parseAndVerifyVM(encodedTokenTransfer);\n        require(valid, reason);\n        require(\n            tokenTransferVM.emitterChainId == TERRA_CHAIN_ID,\n            \"chain id mismatch\"\n        );\n        // No need to check emitter address; this is checked by completeTransfer.\n        // ensure that the provided transfer vaa is the one referenced by the transfer info\n        require(\n            tokenTransferVM.sequence ==\n                incomingTokenTransferInfo.tokenTransferSequence,\n            \"sequence mismatch\"\n        );\n\n        WormholeTokenBridge.Transfer memory transfer = wormholeTokenBridge\n            .parseTransfer(tokenTransferVM.payload);\n        // No need to check that recipient chain matches this chain; this is checked by completeTransfer.\n        require(\n            transfer.to == encodeAddress(address(this)),\n            \"transfer is not to this address\"\n        );\n        require(\n            transfer.toChain == incomingTokenTransferInfo.chainId,\n            \"transfer is to the wrong chain\"\n        );\n\n        if (!wormholeTokenBridge.isTransferCompleted(tokenTransferVM.hash)) {\n            wormholeTokenBridge.completeTransfer(encodedTokenTransfer);\n        }\n\n        address tokenAddress;\n\n        if (transfer.tokenChain == wormholeTokenBridge.chainId()) {\n            tokenAddress = address(uint160(uint256(transfer.tokenAddress)));\n        } else {\n            tokenAddress = wormholeTokenBridge.wrappedAsset(\n                transfer.tokenChain,\n                transfer.tokenAddress\n            );\n        }\n        // forward the tokens to the appropriate recipient\n        SafeERC20.safeTransfer(\n            IERC20(tokenAddress),\n            address(\n                uint160(\n                    uint256(incomingTokenTransferInfo.tokenRecipientAddress)\n                )\n            ),\n            transfer.amount\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "CrossAnchorBridge.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CrossAnchorBridge.sol#L167-L175, CrossAnchorBridge.sol#L250-L253, CrossAnchorBridge.sol#L255-L258",
                "Type": "Frozen Funds",
                "Description": "In the current implementation of CrossAnchorBridge, all require that 'Check that token is a whitelisted token' is commented out. As a result, users may send transcations with the non-whitelisted tokens and as they can not be processd properly on the Terra side, the funds can be frozen on the brige contract or on the Terra side.",
                "Repair": "Uncomment the whitelist codes."
            }
        ]
    },
    {
        "Code": "use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_bignumber::Uint256;\nuse cw20::Cw20ReceiveMsg;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct InstantiateMsg {\n    /// owner address\n    pub owner: String,\n    /// bAsset token address\n    pub collateral_token: String,\n    /// overseer contract address\n    pub overseer_contract: String,\n    /// market contract address\n    pub market_contract: String,\n    /// bAsset rewrad contract\n    pub reward_contract: String,\n    /// liquidation contract address\n    pub liquidation_contract: String,\n    /// Expected reward denom. If bAsset reward is not same with\n    /// it, we try to convert the reward to the `stable_denom`.\n    pub stable_denom: String,\n    pub basset_info: BAssetInfo,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    /// CW20 token receiver\n    Receive(Cw20ReceiveMsg),\n\n    ////////////////////\n    /// Overseer operations\n    ////////////////////\n\n    /// Update config\n    UpdateConfig {\n        owner: Option<String>,\n        liquidation_contract: Option<String>,\n    },\n    /// Make specified amount of tokens unspendable\n    LockCollateral { borrower: String, amount: Uint256 },\n    /// Make specified amount of collateral tokens spendable\n    UnlockCollateral { borrower: String, amount: Uint256 },\n    /// Claim bAsset rewards and distribute claimed rewards\n    /// to market and overseer contracts\n    DistributeRewards {},\n\n    /// Liquidate collateral and send liquidated collateral to `to` address\n    LiquidateCollateral {\n        liquidator: String,\n        borrower: String,\n        amount: Uint256,\n    },\n\n    ////////////////////\n    /// User operations\n    ////////////////////\n\n    /// Withdraw spendable collateral token.\n    /// If the amount is not given,\n    /// return all spendable collateral\n    WithdrawCollateral { amount: Option<Uint256> },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum Cw20HookMsg {\n    /// Deposit collateral token\n    DepositCollateral {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    Config {},\n    Borrower {\n        address: String,\n    },\n    Borrowers {\n        start_after: Option<String>,\n        limit: Option<u32>,\n    },\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct ConfigResponse {\n    pub owner: String,\n    pub collateral_token: String,\n    pub overseer_contract: String,\n    pub market_contract: String,\n    pub reward_contract: String,\n    pub liquidation_contract: String,\n    pub stable_denom: String,\n    pub basset_info: BAssetInfo,\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct BorrowerResponse {\n    pub borrower: String,\n    pub balance: Uint256,\n    pub spendable: Uint256,\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct BorrowersResponse {\n    pub borrowers: Vec<BorrowerResponse>,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct BAssetInfo {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n}\n\n\n",
        "CodeNames": [
            "custody.rs"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "swap_to_stable_denom function in the custody contracts",
                "Type": "Potential lock of rewards",
                "Description": "If the last swap consistently fails in some period for any reason, the total rewards will be locked in the contract during that period.",
                "Repair": "Handle the reply on either success or failure, i.e., using ReplyOn::Always, to avoid the failure of the swap to cause tokens to be locked."
            }
        ]
    },
    {
        "Code": "use cosmwasm_std::{Binary, Decimal, Uint128};\nuse cw20::Cw20ReceiveMsg;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\nuse crate::common::OrderBy;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InstantiateMsg {\n    pub quorum: Decimal,\n    pub threshold: Decimal,\n    pub voting_period: u64,\n    pub timelock_period: u64,\n    pub proposal_deposit: Uint128,\n    pub snapshot_period: u64,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    Receive(Cw20ReceiveMsg),\n    ExecutePollMsgs {\n        poll_id: u64,\n    },\n    RegisterContracts {\n        anchor_token: String,\n    },\n    UpdateConfig {\n        owner: Option<String>,\n        quorum: Option<Decimal>,\n        threshold: Option<Decimal>,\n        voting_period: Option<u64>,\n        timelock_period: Option<u64>,\n        proposal_deposit: Option<Uint128>,\n        snapshot_period: Option<u64>,\n    },\n    CastVote {\n        poll_id: u64,\n        vote: VoteOption,\n        amount: Uint128,\n    },\n    WithdrawVotingTokens {\n        amount: Option<Uint128>,\n    },\n    EndPoll {\n        poll_id: u64,\n    },\n    ExecutePoll {\n        poll_id: u64,\n    },\n    SnapshotPoll {\n        poll_id: u64,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum Cw20HookMsg {\n    /// StakeVotingTokens a user can stake their mirror token to receive rewards\n    /// or do vote on polls\n    StakeVotingTokens {},\n    /// CreatePoll need to receive deposit from a proposer\n    CreatePoll {\n        title: String,\n        description: String,\n        link: Option<String>,\n        execute_msgs: Option<Vec<PollExecuteMsg>>,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct PollExecuteMsg {\n    pub order: u64,\n    pub contract: String,\n    pub msg: Binary,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    Config {},\n    State {},\n    Staker {\n        address: String,\n    },\n    Poll {\n        poll_id: u64,\n    },\n    Polls {\n        filter: Option<PollStatus>,\n        start_after: Option<u64>,\n        limit: Option<u32>,\n        order_by: Option<OrderBy>,\n    },\n    Voters {\n        poll_id: u64,\n        start_after: Option<String>,\n        limit: Option<u32>,\n        order_by: Option<OrderBy>,\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct ConfigResponse {\n    pub owner: String,\n    pub anchor_token: String,\n    pub quorum: Decimal,\n    pub threshold: Decimal,\n    pub voting_period: u64,\n    pub timelock_period: u64,\n    pub proposal_deposit: Uint128,\n    pub snapshot_period: u64,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct StateResponse {\n    pub poll_count: u64,\n    pub total_share: Uint128,\n    pub total_deposit: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)]\npub struct PollResponse {\n    pub id: u64,\n    pub creator: String,\n    pub status: PollStatus,\n    pub end_height: u64,\n    pub title: String,\n    pub description: String,\n    pub link: Option<String>,\n    pub deposit_amount: Uint128,\n    pub execute_data: Option<Vec<PollExecuteMsg>>,\n    pub yes_votes: Uint128, // balance\n    pub no_votes: Uint128,  // balance\n    pub staked_amount: Option<Uint128>,\n    pub total_balance_at_end_poll: Option<Uint128>,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)]\npub struct PollsResponse {\n    pub polls: Vec<PollResponse>,\n}\n\n#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)]\npub struct PollCountResponse {\n    pub poll_count: u64,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)]\npub struct StakerResponse {\n    pub balance: Uint128,\n    pub share: Uint128,\n    pub locked_balance: Vec<(u64, VoterInfo)>,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)]\npub struct VotersResponseItem {\n    pub voter: String,\n    pub vote: VoteOption,\n    pub balance: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)]\npub struct VotersResponse {\n    pub voters: Vec<VotersResponseItem>,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct VoterInfo {\n    pub vote: VoteOption,\n    pub balance: Uint128,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum PollStatus {\n    InProgress,\n    Passed,\n    Rejected,\n    Executed,\n    Expired, // Depricated\n    Failed,\n}\n\nimpl fmt::Display for PollStatus {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum VoteOption {\n    Yes,\n    No,\n}\n\nimpl fmt::Display for VoteOption {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        if *self == VoteOption::Yes {\n            write!(f, \"yes\")\n        } else {\n            write!(f, \"no\")\n        }\n    }\n}\n\n\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    attr, to_binary, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response, StdError,\n    StdResult, SubMsg, Uint128, WasmMsg,\n};\n\nuse crate::state::{\n    read_airdrop_info, read_all_airdrop_infos, read_config, remove_airdrop_info,\n    store_airdrop_info, store_config, update_airdrop_info, Config, CONFIG,\n};\nuse basset::airdrop::{\n    ANCAirdropHandleMsg, AirdropInfo, AirdropInfoElem, AirdropInfoResponse, ConfigResponse,\n    ExecuteMsg, InstantiateMsg, MIRAirdropHandleMsg, PairHandleMsg, QueryMsg,\n};\nuse basset::hub::ExecuteMsg as HubHandleMsg;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    let sndr_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n\n    let config = Config {\n        owner: sndr_raw,\n        hub_contract: msg.hub_contract,\n        reward_contract: msg.reward_contract,\n        airdrop_tokens: vec![],\n    };\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -> StdResult<Response> {\n    match msg {\n        ExecuteMsg::FabricateMIRClaim {\n            stage,\n            amount,\n            proof,\n        } => execute_fabricate_mir_claim(deps, env, info, stage, amount, proof),\n        ExecuteMsg::FabricateANCClaim {\n            stage,\n            amount,\n            proof,\n        } => execute_fabricate_anchor_claim(deps, env, info, stage, amount, proof),\n        ExecuteMsg::UpdateConfig {\n            owner,\n            hub_contract,\n            reward_contract,\n        } => execute_update_config(deps, env, info, owner, hub_contract, reward_contract),\n        ExecuteMsg::AddAirdropInfo {\n            airdrop_token,\n            airdrop_info,\n        } => execute_add_airdrop(deps, env, info, airdrop_token, airdrop_info),\n        ExecuteMsg::RemoveAirdropInfo { airdrop_token } => {\n            execute_remove_airdrop(deps, env, info, airdrop_token)\n        }\n        ExecuteMsg::UpdateAirdropInfo {\n            airdrop_token,\n            airdrop_info,\n        } => execute_update_airdrop(deps, env, info, airdrop_token, airdrop_info),\n    }\n}\n\nfn execute_fabricate_mir_claim(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    stage: u8,\n    amount: Uint128,\n    proof: Vec<String>,\n) -> StdResult<Response> {\n    let config = read_config(deps.storage)?;\n\n    let mut messages: Vec<SubMsg> = vec![];\n\n    let airdrop_info = read_airdrop_info(deps.storage, \"MIR\".to_string()).unwrap();\n    messages.push(SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.hub_contract,\n        msg: to_binary(&HubHandleMsg::ClaimAirdrop {\n            airdrop_token_contract: airdrop_info.airdrop_token_contract,\n            airdrop_contract: airdrop_info.airdrop_contract,\n            airdrop_swap_contract: airdrop_info.airdrop_swap_contract,\n            claim_msg: to_binary(&MIRAirdropHandleMsg::Claim {\n                stage,\n                amount,\n                proof,\n            })?,\n            swap_msg: to_binary(&PairHandleMsg::Swap {\n                belief_price: airdrop_info.swap_belief_price,\n                max_spread: airdrop_info.swap_max_spread,\n                to: Some(config.reward_contract),\n            })?,\n        })?,\n        funds: vec![],\n    })));\n\n    Ok(Response::new()\n        .add_submessages(messages)\n        .add_attributes(vec![attr(\"action\", \"fabricate_mir_claim\")]))\n}\n\nfn execute_fabricate_anchor_claim(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    stage: u8,\n    amount: Uint128,\n    proof: Vec<String>,\n) -> StdResult<Response> {\n    let config = read_config(deps.storage)?;\n\n    let mut messages: Vec<SubMsg> = vec![];\n\n    let airdrop_info = read_airdrop_info(deps.storage, \"ANC\".to_string())?;\n    messages.push(SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.hub_contract,\n        msg: to_binary(&HubHandleMsg::ClaimAirdrop {\n            airdrop_token_contract: airdrop_info.airdrop_token_contract,\n            airdrop_contract: airdrop_info.airdrop_contract,\n            airdrop_swap_contract: airdrop_info.airdrop_swap_contract,\n            claim_msg: to_binary(&ANCAirdropHandleMsg::Claim {\n                stage,\n                amount,\n                proof,\n            })?,\n            swap_msg: to_binary(&PairHandleMsg::Swap {\n                belief_price: airdrop_info.swap_belief_price,\n                max_spread: airdrop_info.swap_max_spread,\n                to: Some(config.reward_contract),\n            })?,\n        })?,\n        funds: vec![],\n    })));\n\n    Ok(Response::new()\n        .add_submessages(messages)\n        .add_attributes(vec![attr(\"action\", \"fabricate_anc_claim\")]))\n}\npub fn execute_update_config(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    owner: Option<String>,\n    hub_contract: Option<String>,\n    reward_contract: Option<String>,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let mut config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if let Some(o) = owner {\n        let owner_raw = deps.api.addr_canonicalize(&o)?;\n        config.owner = owner_raw\n    }\n    if let Some(hub) = hub_contract {\n        config.hub_contract = hub;\n    }\n    if let Some(reward_addr) = reward_contract {\n        config.reward_contract = reward_addr;\n    }\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![attr(\"action\", \"update_config\")]))\n}\n\npub fn execute_add_airdrop(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    airdrop_token: String,\n    airdrop_info: AirdropInfo,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let exists = read_airdrop_info(deps.storage, airdrop_token.clone());\n    if exists.is_ok() {\n        return Err(StdError::generic_err(format!(\n            \"There is a token info with this {}\",\n            airdrop_token\n        )));\n    }\n\n    CONFIG.update(deps.storage, |mut conf| -> StdResult<Config> {\n        conf.airdrop_tokens.push(airdrop_token.clone());\n        Ok(conf)\n    })?;\n\n    store_airdrop_info(deps.storage, airdrop_token.clone(), airdrop_info)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"add_airdrop_info\"),\n        attr(\"airdrop_token\", airdrop_token),\n    ]))\n}\n\npub fn execute_update_airdrop(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    airdrop_token: String,\n    airdrop_info: AirdropInfo,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let exists = read_airdrop_info(deps.storage, airdrop_token.clone());\n    if exists.is_err() {\n        return Err(StdError::generic_err(format!(\n            \"There is no token info with this {}\",\n            airdrop_token\n        )));\n    }\n\n    update_airdrop_info(deps.storage, airdrop_token.clone(), airdrop_info)?;\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"update_airdrop_info\"),\n        attr(\"airdrop_token\", airdrop_token),\n    ]))\n}\n\npub fn execute_remove_airdrop(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    airdrop_token: String,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let exists = read_airdrop_info(deps.storage, airdrop_token.clone());\n    if exists.is_err() {\n        return Err(StdError::generic_err(format!(\n            \"There is no token info with this {}\",\n            airdrop_token\n        )));\n    }\n\n    CONFIG.update(deps.storage, |mut conf| -> StdResult<Config> {\n        conf.airdrop_tokens.retain(|item| item != &airdrop_token);\n        Ok(conf)\n    })?;\n\n    remove_airdrop_info(deps.storage, airdrop_token.clone())?;\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"remove_airdrop_info\"),\n        attr(\"airdrop_token\", airdrop_token),\n    ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::Config {} => to_binary(&query_config(deps)?),\n        QueryMsg::AirdropInfo {\n            airdrop_token,\n            start_after,\n            limit,\n        } => to_binary(&query_airdrop_infos(\n            deps,\n            airdrop_token,\n            start_after,\n            limit,\n        )?),\n    }\n}\n\nfn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n    let config = read_config(deps.storage)?;\n    let owner_addr = deps.api.addr_humanize(&config.owner)?;\n\n    Ok(ConfigResponse {\n        owner: owner_addr.to_string(),\n        hub_contract: config.hub_contract,\n        reward_contract: config.reward_contract,\n        airdrop_tokens: config.airdrop_tokens,\n    })\n}\n\nfn query_airdrop_infos(\n    deps: Deps,\n    airdrop_token: Option<String>,\n    start_after: Option<String>,\n    limit: Option<u32>,\n) -> StdResult<AirdropInfoResponse> {\n    if let Some(air_token) = airdrop_token {\n        let info = read_airdrop_info(deps.storage, air_token.clone()).unwrap();\n\n        Ok(AirdropInfoResponse {\n            airdrop_info: vec![AirdropInfoElem {\n                airdrop_token: air_token,\n                info,\n            }],\n        })\n    } else {\n        let infos = read_all_airdrop_infos(deps.storage, start_after, limit)?;\n        Ok(AirdropInfoResponse {\n            airdrop_info: infos,\n        })\n    }\n}\n\n\n",
        "CodeNames": [
            "gov.rs",
            "contract.rs"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "receive_cw20 function in the gov contract",
                "Type": "Governance Voting Dis-proportionally Favours Users",
                "Description": "Users who stake their Anchor tokens after a poll has had its snapshot taken are incentivized to maximize their voting power.",
                "Repair": "Implement a check-pointing mechanism such that when a user casts a vote, the user's staked balance is checked at the block height upon which the snapshot was taken instead of checking its most up-to-date staked balance."
            }
        ]
    },
    {
        "Code": "use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::Uint128;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InstantiateMsg {\n    pub gov_contract: String, // anchor gov contract\n    pub anchor_token: String, // anchor token address\n    pub spend_limit: Uint128, // spend limit per each `spend` request\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    UpdateConfig { spend_limit: Option<Uint128> },\n    Spend { recipient: String, amount: Uint128 },\n}\n\n/// We currently take no arguments for migrations\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct MigrateMsg {}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    Config {},\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct ConfigResponse {\n    pub gov_contract: String,\n    pub anchor_token: String,\n    pub spend_limit: Uint128,\n}\n\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::Uint128;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InstantiateMsg {\n    pub gov_contract: String,   // anchor gov contract\n    pub anchor_token: String,   // anchor token address\n    pub whitelist: Vec<String>, // whitelisted contract addresses to spend distributor\n    pub spend_limit: Uint128,   // spend limit per each `spend` request\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    UpdateConfig { spend_limit: Option<Uint128> },\n    Spend { recipient: String, amount: Uint128 },\n    AddDistributor { distributor: String },\n    RemoveDistributor { distributor: String },\n}\n\n/// We currently take no arguments for migrations\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct MigrateMsg {}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    Config {},\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct ConfigResponse {\n    pub gov_contract: String,\n    pub anchor_token: String,\n    pub whitelist: Vec<String>,\n    pub spend_limit: Uint128,\n}\n\n\n",
        "CodeNames": [
            "community.rs",
            "distributor.rs"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "distributor and community contracts",
                "Type": "Spend limit bypass",
                "Description": "The owner can bypass the spend limit by sending multiple transactions each of the spend limit amount without decreasing the spend limit.",
                "Repair": "Decrease the spend limit after successful spend"
            }
        ]
    },
    {
        "Code": "#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    attr, to_binary, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response, StdError,\n    StdResult, SubMsg, Uint128, WasmMsg,\n};\n\nuse crate::state::{\n    read_airdrop_info, read_all_airdrop_infos, read_config, remove_airdrop_info,\n    store_airdrop_info, store_config, update_airdrop_info, Config, CONFIG,\n};\nuse basset::airdrop::{\n    ANCAirdropHandleMsg, AirdropInfo, AirdropInfoElem, AirdropInfoResponse, ConfigResponse,\n    ExecuteMsg, InstantiateMsg, MIRAirdropHandleMsg, PairHandleMsg, QueryMsg,\n};\nuse basset::hub::ExecuteMsg as HubHandleMsg;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    let sndr_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n\n    let config = Config {\n        owner: sndr_raw,\n        hub_contract: msg.hub_contract,\n        reward_contract: msg.reward_contract,\n        airdrop_tokens: vec![],\n    };\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -> StdResult<Response> {\n    match msg {\n        ExecuteMsg::FabricateMIRClaim {\n            stage,\n            amount,\n            proof,\n        } => execute_fabricate_mir_claim(deps, env, info, stage, amount, proof),\n        ExecuteMsg::FabricateANCClaim {\n            stage,\n            amount,\n            proof,\n        } => execute_fabricate_anchor_claim(deps, env, info, stage, amount, proof),\n        ExecuteMsg::UpdateConfig {\n            owner,\n            hub_contract,\n            reward_contract,\n        } => execute_update_config(deps, env, info, owner, hub_contract, reward_contract),\n        ExecuteMsg::AddAirdropInfo {\n            airdrop_token,\n            airdrop_info,\n        } => execute_add_airdrop(deps, env, info, airdrop_token, airdrop_info),\n        ExecuteMsg::RemoveAirdropInfo { airdrop_token } => {\n            execute_remove_airdrop(deps, env, info, airdrop_token)\n        }\n        ExecuteMsg::UpdateAirdropInfo {\n            airdrop_token,\n            airdrop_info,\n        } => execute_update_airdrop(deps, env, info, airdrop_token, airdrop_info),\n    }\n}\n\nfn execute_fabricate_mir_claim(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    stage: u8,\n    amount: Uint128,\n    proof: Vec<String>,\n) -> StdResult<Response> {\n    let config = read_config(deps.storage)?;\n\n    let mut messages: Vec<SubMsg> = vec![];\n\n    let airdrop_info = read_airdrop_info(deps.storage, \"MIR\".to_string()).unwrap();\n    messages.push(SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.hub_contract,\n        msg: to_binary(&HubHandleMsg::ClaimAirdrop {\n            airdrop_token_contract: airdrop_info.airdrop_token_contract,\n            airdrop_contract: airdrop_info.airdrop_contract,\n            airdrop_swap_contract: airdrop_info.airdrop_swap_contract,\n            claim_msg: to_binary(&MIRAirdropHandleMsg::Claim {\n                stage,\n                amount,\n                proof,\n            })?,\n            swap_msg: to_binary(&PairHandleMsg::Swap {\n                belief_price: airdrop_info.swap_belief_price,\n                max_spread: airdrop_info.swap_max_spread,\n                to: Some(config.reward_contract),\n            })?,\n        })?,\n        funds: vec![],\n    })));\n\n    Ok(Response::new()\n        .add_submessages(messages)\n        .add_attributes(vec![attr(\"action\", \"fabricate_mir_claim\")]))\n}\n\nfn execute_fabricate_anchor_claim(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    stage: u8,\n    amount: Uint128,\n    proof: Vec<String>,\n) -> StdResult<Response> {\n    let config = read_config(deps.storage)?;\n\n    let mut messages: Vec<SubMsg> = vec![];\n\n    let airdrop_info = read_airdrop_info(deps.storage, \"ANC\".to_string())?;\n    messages.push(SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: config.hub_contract,\n        msg: to_binary(&HubHandleMsg::ClaimAirdrop {\n            airdrop_token_contract: airdrop_info.airdrop_token_contract,\n            airdrop_contract: airdrop_info.airdrop_contract,\n            airdrop_swap_contract: airdrop_info.airdrop_swap_contract,\n            claim_msg: to_binary(&ANCAirdropHandleMsg::Claim {\n                stage,\n                amount,\n                proof,\n            })?,\n            swap_msg: to_binary(&PairHandleMsg::Swap {\n                belief_price: airdrop_info.swap_belief_price,\n                max_spread: airdrop_info.swap_max_spread,\n                to: Some(config.reward_contract),\n            })?,\n        })?,\n        funds: vec![],\n    })));\n\n    Ok(Response::new()\n        .add_submessages(messages)\n        .add_attributes(vec![attr(\"action\", \"fabricate_anc_claim\")]))\n}\npub fn execute_update_config(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    owner: Option<String>,\n    hub_contract: Option<String>,\n    reward_contract: Option<String>,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let mut config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if let Some(o) = owner {\n        let owner_raw = deps.api.addr_canonicalize(&o)?;\n        config.owner = owner_raw\n    }\n    if let Some(hub) = hub_contract {\n        config.hub_contract = hub;\n    }\n    if let Some(reward_addr) = reward_contract {\n        config.reward_contract = reward_addr;\n    }\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![attr(\"action\", \"update_config\")]))\n}\n\npub fn execute_add_airdrop(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    airdrop_token: String,\n    airdrop_info: AirdropInfo,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let exists = read_airdrop_info(deps.storage, airdrop_token.clone());\n    if exists.is_ok() {\n        return Err(StdError::generic_err(format!(\n            \"There is a token info with this {}\",\n            airdrop_token\n        )));\n    }\n\n    CONFIG.update(deps.storage, |mut conf| -> StdResult<Config> {\n        conf.airdrop_tokens.push(airdrop_token.clone());\n        Ok(conf)\n    })?;\n\n    store_airdrop_info(deps.storage, airdrop_token.clone(), airdrop_info)?;\n\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"add_airdrop_info\"),\n        attr(\"airdrop_token\", airdrop_token),\n    ]))\n}\n\npub fn execute_update_airdrop(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    airdrop_token: String,\n    airdrop_info: AirdropInfo,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let exists = read_airdrop_info(deps.storage, airdrop_token.clone());\n    if exists.is_err() {\n        return Err(StdError::generic_err(format!(\n            \"There is no token info with this {}\",\n            airdrop_token\n        )));\n    }\n\n    update_airdrop_info(deps.storage, airdrop_token.clone(), airdrop_info)?;\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"update_airdrop_info\"),\n        attr(\"airdrop_token\", airdrop_token),\n    ]))\n}\n\npub fn execute_remove_airdrop(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    airdrop_token: String,\n) -> StdResult<Response> {\n    // only owner can send this message.\n    let config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(&info.sender.to_string())?;\n    if sender_raw != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let exists = read_airdrop_info(deps.storage, airdrop_token.clone());\n    if exists.is_err() {\n        return Err(StdError::generic_err(format!(\n            \"There is no token info with this {}\",\n            airdrop_token\n        )));\n    }\n\n    CONFIG.update(deps.storage, |mut conf| -> StdResult<Config> {\n        conf.airdrop_tokens.retain(|item| item != &airdrop_token);\n        Ok(conf)\n    })?;\n\n    remove_airdrop_info(deps.storage, airdrop_token.clone())?;\n    Ok(Response::new().add_attributes(vec![\n        attr(\"action\", \"remove_airdrop_info\"),\n        attr(\"airdrop_token\", airdrop_token),\n    ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::Config {} => to_binary(&query_config(deps)?),\n        QueryMsg::AirdropInfo {\n            airdrop_token,\n            start_after,\n            limit,\n        } => to_binary(&query_airdrop_infos(\n            deps,\n            airdrop_token,\n            start_after,\n            limit,\n        )?),\n    }\n}\n\nfn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n    let config = read_config(deps.storage)?;\n    let owner_addr = deps.api.addr_humanize(&config.owner)?;\n\n    Ok(ConfigResponse {\n        owner: owner_addr.to_string(),\n        hub_contract: config.hub_contract,\n        reward_contract: config.reward_contract,\n        airdrop_tokens: config.airdrop_tokens,\n    })\n}\n\nfn query_airdrop_infos(\n    deps: Deps,\n    airdrop_token: Option<String>,\n    start_after: Option<String>,\n    limit: Option<u32>,\n) -> StdResult<AirdropInfoResponse> {\n    if let Some(air_token) = airdrop_token {\n        let info = read_airdrop_info(deps.storage, air_token.clone()).unwrap();\n\n        Ok(AirdropInfoResponse {\n            airdrop_info: vec![AirdropInfoElem {\n                airdrop_token: air_token,\n                info,\n            }],\n        })\n    } else {\n        let infos = read_all_airdrop_infos(deps.storage, start_after, limit)?;\n        Ok(AirdropInfoResponse {\n            airdrop_info: infos,\n        })\n    }\n}\n\n\nuse crate::error::ContractError;\nuse crate::state::{\n    bank_read, bank_store, config_read, config_store, poll_read, poll_voter_store, state_read,\n    state_store, Config, Poll, State, TokenManager,\n};\n\nuse anchor_token::gov::{PollStatus, StakerResponse};\nuse astroport::querier::query_token_balance;\nuse cosmwasm_std::{\n    to_binary, Addr, CanonicalAddr, CosmosMsg, Deps, DepsMut, MessageInfo, Response, StdResult,\n    Storage, Uint128, WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\npub fn stake_voting_tokens(\n    deps: DepsMut,\n    sender: Addr,\n    amount: Uint128,\n) -> Result<Response, ContractError> {\n    if amount.is_zero() {\n        return Err(ContractError::InsufficientFunds {});\n    }\n\n    let sender_address_raw = deps.api.addr_canonicalize(sender.as_str())?;\n    let key = &sender_address_raw.as_slice();\n\n    let mut token_manager = bank_read(deps.storage).may_load(key)?.unwrap_or_default();\n    let config: Config = config_store(deps.storage).load()?;\n    let mut state: State = state_store(deps.storage).load()?;\n\n    // balance already increased, so subtract deposit amount\n    let total_balance = query_token_balance(\n        &deps.querier,\n        deps.api.addr_humanize(&config.anchor_token)?,\n        deps.api.addr_humanize(&state.contract_addr)?,\n    )?\n    .checked_sub(state.total_deposit + amount)?;\n\n    let share = if total_balance.is_zero() || state.total_share.is_zero() {\n        amount\n    } else {\n        amount.multiply_ratio(state.total_share, total_balance)\n    };\n\n    token_manager.share += share;\n    state.total_share += share;\n\n    state_store(deps.storage).save(&state)?;\n    bank_store(deps.storage).save(key, &token_manager)?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"action\", \"staking\"),\n        (\"sender\", sender.as_str()),\n        (\"share\", share.to_string().as_str()),\n        (\"amount\", amount.to_string().as_str()),\n    ]))\n}\n\n// Withdraw amount if not staked. By default all funds will be withdrawn.\npub fn withdraw_voting_tokens(\n    deps: DepsMut,\n    info: MessageInfo,\n    amount: Option<Uint128>,\n) -> Result<Response, ContractError> {\n    let sender_address_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n    let key = sender_address_raw.as_slice();\n\n    if let Some(mut token_manager) = bank_read(deps.storage).may_load(key)? {\n        let config: Config = config_store(deps.storage).load()?;\n        let mut state: State = state_store(deps.storage).load()?;\n\n        // Load total share & total balance except proposal deposit amount\n        let total_share = state.total_share.u128();\n        let total_balance = query_token_balance(\n            &deps.querier,\n            deps.api.addr_humanize(&config.anchor_token)?,\n            deps.api.addr_humanize(&state.contract_addr)?,\n        )?\n        .checked_sub(state.total_deposit)?\n        .u128();\n\n        let locked_balance =\n            compute_locked_balance(deps.storage, &mut token_manager, &sender_address_raw);\n        let locked_share = locked_balance * total_share / total_balance;\n        let user_share = token_manager.share.u128();\n\n        let withdraw_share = amount\n            .map(|v| std::cmp::max(v.multiply_ratio(total_share, total_balance).u128(), 1u128))\n            .unwrap_or_else(|| user_share - locked_share);\n        let withdraw_amount = amount\n            .map(|v| v.u128())\n            .unwrap_or_else(|| withdraw_share * total_balance / total_share);\n\n        if locked_share + withdraw_share > user_share {\n            Err(ContractError::InvalidWithdrawAmount {})\n        } else {\n            let share = user_share - withdraw_share;\n            token_manager.share = Uint128::from(share);\n\n            bank_store(deps.storage).save(key, &token_manager)?;\n\n            state.total_share = Uint128::from(total_share - withdraw_share);\n            state_store(deps.storage).save(&state)?;\n\n            send_tokens(\n                deps,\n                &config.anchor_token,\n                &sender_address_raw,\n                withdraw_amount,\n                \"withdraw\",\n            )\n        }\n    } else {\n        Err(ContractError::NothingStaked {})\n    }\n}\n\n// removes not in-progress poll voter info & unlock tokens\n// and returns the largest locked amount in participated polls.\nfn compute_locked_balance(\n    storage: &mut dyn Storage,\n    token_manager: &mut TokenManager,\n    voter: &CanonicalAddr,\n) -> u128 {\n    token_manager.locked_balance.retain(|(poll_id, _)| {\n        let poll: Poll = poll_read(storage).load(&poll_id.to_be_bytes()).unwrap();\n\n        if poll.status != PollStatus::InProgress {\n            // remove voter info from the poll\n            poll_voter_store(storage, *poll_id).remove(voter.as_slice());\n        }\n\n        poll.status == PollStatus::InProgress\n    });\n\n    token_manager\n        .locked_balance\n        .iter()\n        .map(|(_, v)| v.balance.u128())\n        .max()\n        .unwrap_or_default()\n}\n\nfn send_tokens(\n    deps: DepsMut,\n    asset_token: &CanonicalAddr,\n    recipient: &CanonicalAddr,\n    amount: u128,\n    action: &str,\n) -> Result<Response, ContractError> {\n    let contract_human = deps.api.addr_humanize(asset_token)?.to_string();\n    let recipient_human = deps.api.addr_humanize(recipient)?.to_string();\n\n    Ok(Response::new()\n        .add_messages(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: contract_human,\n            msg: to_binary(&Cw20ExecuteMsg::Transfer {\n                recipient: recipient_human.clone(),\n                amount: Uint128::from(amount),\n            })?,\n            funds: vec![],\n        })])\n        .add_attributes(vec![\n            (\"action\", action),\n            (\"recipient\", recipient_human.as_str()),\n            (\"amount\", amount.to_string().as_str()),\n        ]))\n}\n\npub fn query_staker(deps: Deps, address: String) -> StdResult<StakerResponse> {\n    let addr_raw = deps.api.addr_canonicalize(&address).unwrap();\n    let config: Config = config_read(deps.storage).load()?;\n    let state: State = state_read(deps.storage).load()?;\n    let mut token_manager = bank_read(deps.storage)\n        .may_load(addr_raw.as_slice())?\n        .unwrap_or_default();\n\n    // filter out not in-progress polls\n    token_manager.locked_balance.retain(|(poll_id, _)| {\n        let poll: Poll = poll_read(deps.storage)\n            .load(&poll_id.to_be_bytes())\n            .unwrap();\n\n        poll.status == PollStatus::InProgress\n    });\n\n    let total_balance = query_token_balance(\n        &deps.querier,\n        deps.api.addr_humanize(&config.anchor_token)?,\n        deps.api.addr_humanize(&state.contract_addr)?,\n    )?\n    .checked_sub(state.total_deposit)?;\n\n    Ok(StakerResponse {\n        balance: if !state.total_share.is_zero() {\n            token_manager\n                .share\n                .multiply_ratio(total_balance, state.total_share)\n        } else {\n            Uint128::zero()\n        },\n        share: token_manager.share,\n        locked_balance: token_manager.locked_balance,\n    })\n}\n\n\n",
        "CodeNames": [
            "contract.rs",
            "staking.rs"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "staking contract",
                "Type": "Token theft",
                "Description": "The shares calculation rounds down when withdrawing from the staking contract, allowing token theft.",
                "Repair": "Always round up in withdraw_share or always recompute the withdraw_amount with the new withdraw_share even if the amount parameter was set, or use a share parameter instead of the amount parameter and use it as withdraw_share"
            }
        ]
    },
    {
        "Code": "use anchor_token::distributor::ExecuteMsg as FaucetExecuteMsg;\nuse cosmwasm_bignumber::{Decimal256, Uint256};\nuse cosmwasm_std::{\n    attr, to_binary, Addr, BankMsg, Coin, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response,\n    StdResult, WasmMsg,\n};\nuse moneymarket::interest_model::BorrowRateResponse;\nuse moneymarket::market::{BorrowerInfoResponse, BorrowerInfosResponse};\nuse moneymarket::overseer::BorrowLimitResponse;\nuse moneymarket::querier::{deduct_tax, query_balance, query_supply};\n\nuse crate::deposit::compute_exchange_rate_raw;\nuse crate::error::ContractError;\nuse crate::querier::{query_borrow_limit, query_borrow_rate, query_target_deposit_rate};\nuse crate::state::{\n    read_borrower_info, read_borrower_infos, read_config, read_state, store_borrower_info,\n    store_state, BorrowerInfo, Config, State,\n};\n\npub fn borrow_stable(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrow_amount: Uint256,\n    to: Option<Addr>,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n\n    let mut state: State = read_state(deps.storage)?;\n\n    let borrower = info.sender;\n    let borrower_raw = deps.api.addr_canonicalize(borrower.as_str())?;\n    let mut liability: BorrowerInfo = read_borrower_info(deps.storage, &borrower_raw);\n\n    // Compute interest\n    compute_interest(deps.as_ref(), &config, &mut state, env.block.height, None)?;\n    compute_borrower_interest(&state, &mut liability);\n\n    // Compute ANC reward\n    compute_reward(&mut state, env.block.height);\n    compute_borrower_reward(&state, &mut liability);\n\n    let overseer = deps.api.addr_humanize(&config.overseer_contract)?;\n    let borrow_limit_res: BorrowLimitResponse = query_borrow_limit(\n        deps.as_ref(),\n        overseer,\n        borrower.clone(),\n        Some(env.block.time.seconds()),\n    )?;\n\n    if borrow_limit_res.borrow_limit < borrow_amount + liability.loan_amount {\n        return Err(ContractError::BorrowExceedsLimit(\n            borrow_limit_res.borrow_limit.into(),\n        ));\n    }\n\n    let current_balance = query_balance(\n        deps.as_ref(),\n        env.contract.address,\n        config.stable_denom.to_string(),\n    )?;\n\n    // Assert borrow amount\n    assert_max_borrow_factor(&config, &state, current_balance, borrow_amount)?;\n\n    liability.loan_amount += borrow_amount;\n    state.total_liabilities += Decimal256::from_uint256(borrow_amount);\n    store_state(deps.storage, &state)?;\n    store_borrower_info(deps.storage, &borrower_raw, &liability)?;\n\n    Ok(Response::new()\n        .add_message(CosmosMsg::Bank(BankMsg::Send {\n            to_address: to.unwrap_or_else(|| borrower.clone()).to_string(),\n            amount: vec![deduct_tax(\n                deps.as_ref(),\n                Coin {\n                    denom: config.stable_denom,\n                    amount: borrow_amount.into(),\n                },\n            )?],\n        }))\n        .add_attributes(vec![\n            attr(\"action\", \"borrow_stable\"),\n            attr(\"borrower\", borrower),\n            attr(\"borrow_amount\", borrow_amount),\n        ]))\n}\n\npub fn repay_stable_from_liquidation(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrower: Addr,\n    prev_balance: Uint256,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    if config.overseer_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let cur_balance: Uint256 = query_balance(\n        deps.as_ref(),\n        env.contract.address.clone(),\n        config.stable_denom.to_string(),\n    )?;\n\n    // override env\n    let mut info = info;\n\n    info.sender = borrower;\n    info.funds = vec![Coin {\n        denom: config.stable_denom,\n        amount: (cur_balance - prev_balance).into(),\n    }];\n\n    repay_stable(deps, env, info)\n}\n\npub fn repay_stable(deps: DepsMut, env: Env, info: MessageInfo) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n\n    // Check stable denom deposit\n    let amount: Uint256 = info\n        .funds\n        .iter()\n        .find(|c| c.denom == config.stable_denom)\n        .map(|c| Uint256::from(c.amount))\n        .unwrap_or_else(Uint256::zero);\n\n    // Cannot deposit zero amount\n    if amount.is_zero() {\n        return Err(ContractError::ZeroRepay(config.stable_denom));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n\n    let borrower = info.sender;\n    let borrower_raw = deps.api.addr_canonicalize(borrower.as_str())?;\n    let mut liability: BorrowerInfo = read_borrower_info(deps.storage, &borrower_raw);\n\n    // Compute interest\n    compute_interest(\n        deps.as_ref(),\n        &config,\n        &mut state,\n        env.block.height,\n        Some(amount),\n    )?;\n    compute_borrower_interest(&state, &mut liability);\n\n    // Compute ANC reward\n    compute_reward(&mut state, env.block.height);\n    compute_borrower_reward(&state, &mut liability);\n\n    let repay_amount: Uint256;\n    let mut messages: Vec<CosmosMsg> = vec![];\n    if liability.loan_amount < amount {\n        repay_amount = liability.loan_amount;\n        liability.loan_amount = Uint256::zero();\n\n        // Payback left repay amount to sender\n        messages.push(CosmosMsg::Bank(BankMsg::Send {\n            to_address: borrower.to_string(),\n            amount: vec![deduct_tax(\n                deps.as_ref(),\n                Coin {\n                    denom: config.stable_denom,\n                    amount: (amount - repay_amount).into(),\n                },\n            )?],\n        }));\n    } else {\n        repay_amount = amount;\n        liability.loan_amount = liability.loan_amount - repay_amount;\n    }\n\n    state.total_liabilities = state.total_liabilities - Decimal256::from_uint256(repay_amount);\n\n    store_borrower_info(deps.storage, &borrower_raw, &liability)?;\n    store_state(deps.storage, &state)?;\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"repay_stable\"),\n        attr(\"borrower\", borrower),\n        attr(\"repay_amount\", repay_amount),\n    ]))\n}\n\npub fn claim_rewards(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    to: Option<Addr>,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    let mut state: State = read_state(deps.storage)?;\n\n    let borrower = info.sender;\n    let borrower_raw = deps.api.addr_canonicalize(borrower.as_str())?;\n    let mut liability: BorrowerInfo = read_borrower_info(deps.storage, &borrower_raw);\n\n    // Compute interest\n    compute_interest(deps.as_ref(), &config, &mut state, env.block.height, None)?;\n    compute_borrower_interest(&state, &mut liability);\n\n    // Compute ANC reward\n    compute_reward(&mut state, env.block.height);\n    compute_borrower_reward(&state, &mut liability);\n\n    let claim_amount = liability.pending_rewards * Uint256::one();\n    liability.pending_rewards = liability.pending_rewards - Decimal256::from_uint256(claim_amount);\n\n    store_state(deps.storage, &state)?;\n    store_borrower_info(deps.storage, &borrower_raw, &liability)?;\n\n    let messages: Vec<CosmosMsg> = if !claim_amount.is_zero() {\n        vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: deps\n                .api\n                .addr_humanize(&config.distributor_contract)?\n                .to_string(),\n            funds: vec![],\n            msg: to_binary(&FaucetExecuteMsg::Spend {\n                recipient: if let Some(to) = to {\n                    to.to_string()\n                } else {\n                    borrower.to_string()\n                },\n                amount: claim_amount.into(),\n            })?,\n        })]\n    } else {\n        vec![]\n    };\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"claim_rewards\"),\n        attr(\"claim_amount\", claim_amount),\n    ]))\n}\n\n/// Compute interest and update state\n/// total liabilities and total reserves\npub fn compute_interest(\n    deps: Deps,\n    config: &Config,\n    state: &mut State,\n    block_height: u64,\n    deposit_amount: Option<Uint256>,\n) -> StdResult<()> {\n    if state.last_interest_updated >= block_height {\n        return Ok(());\n    }\n\n    let aterra_supply = query_supply(deps, deps.api.addr_humanize(&config.aterra_contract)?)?;\n    let balance: Uint256 = query_balance(\n        deps,\n        deps.api.addr_humanize(&config.contract_addr)?,\n        config.stable_denom.to_string(),\n    )? - deposit_amount.unwrap_or_else(Uint256::zero);\n\n    let borrow_rate_res: BorrowRateResponse = query_borrow_rate(\n        deps,\n        deps.api.addr_humanize(&config.interest_model)?,\n        balance,\n        state.total_liabilities,\n        state.total_reserves,\n    )?;\n\n    let target_deposit_rate: Decimal256 =\n        query_target_deposit_rate(deps, deps.api.addr_humanize(&config.overseer_contract)?)?;\n\n    compute_interest_raw(\n        state,\n        block_height,\n        balance,\n        aterra_supply,\n        borrow_rate_res.rate,\n        target_deposit_rate,\n    );\n\n    Ok(())\n}\n\n// CONTRACT: to use this function as state update purpose,\n// executor must update following three state after execution\n// * state.prev_aterra_supply\n// * state.prev_exchange_rate\n// * state.last_interest_updated\npub fn compute_interest_raw(\n    state: &mut State,\n    block_height: u64,\n    balance: Uint256,\n    aterra_supply: Uint256,\n    borrow_rate: Decimal256,\n    target_deposit_rate: Decimal256,\n) {\n    if state.last_interest_updated >= block_height {\n        return;\n    }\n\n    let passed_blocks = Decimal256::from_uint256(block_height - state.last_interest_updated);\n\n    let interest_factor = passed_blocks * borrow_rate;\n    let interest_accrued = state.total_liabilities * interest_factor;\n\n    state.global_interest_index =\n        state.global_interest_index * (Decimal256::one() + interest_factor);\n    state.total_liabilities += interest_accrued;\n\n    let mut exchange_rate = compute_exchange_rate_raw(state, aterra_supply, balance);\n    let effective_deposit_rate = exchange_rate / state.prev_exchange_rate;\n    let deposit_rate = (effective_deposit_rate - Decimal256::one()) / passed_blocks;\n\n    if deposit_rate > target_deposit_rate {\n        // excess_deposit_rate(_per_block)\n        let excess_deposit_rate = deposit_rate - target_deposit_rate;\n        let prev_deposits =\n            Decimal256::from_uint256(state.prev_aterra_supply * state.prev_exchange_rate);\n\n        // excess_yield = prev_deposits * excess_deposit_rate(_per_block) * blocks\n        let excess_yield = prev_deposits * passed_blocks * excess_deposit_rate;\n\n        state.total_reserves += excess_yield;\n        exchange_rate = compute_exchange_rate_raw(state, aterra_supply, balance);\n    }\n\n    state.prev_aterra_supply = aterra_supply;\n    state.prev_exchange_rate = exchange_rate;\n    state.last_interest_updated = block_height;\n}\n\n/// Compute new interest and apply to liability\npub(crate) fn compute_borrower_interest(state: &State, liability: &mut BorrowerInfo) {\n    liability.loan_amount =\n        liability.loan_amount * state.global_interest_index / liability.interest_index;\n    liability.interest_index = state.global_interest_index;\n}\n\n/// Compute distributed reward and update global index\npub fn compute_reward(state: &mut State, block_height: u64) {\n    if state.last_reward_updated >= block_height {\n        return;\n    }\n\n    let passed_blocks = Decimal256::from_uint256(block_height - state.last_reward_updated);\n    let reward_accrued = passed_blocks * state.anc_emission_rate;\n    let borrow_amount = state.total_liabilities / state.global_interest_index;\n\n    if !reward_accrued.is_zero() && !borrow_amount.is_zero() {\n        state.global_reward_index += reward_accrued / borrow_amount;\n    }\n\n    state.last_reward_updated = block_height;\n}\n\n/// Compute reward amount a borrower received\npub(crate) fn compute_borrower_reward(state: &State, liability: &mut BorrowerInfo) {\n    liability.pending_rewards += Decimal256::from_uint256(liability.loan_amount)\n        / state.global_interest_index\n        * (state.global_reward_index - liability.reward_index);\n    liability.reward_index = state.global_reward_index;\n}\n\npub fn query_borrower_info(\n    deps: Deps,\n    env: Env,\n    borrower: Addr,\n    block_height: Option<u64>,\n) -> StdResult<BorrowerInfoResponse> {\n    let mut borrower_info: BorrowerInfo = read_borrower_info(\n        deps.storage,\n        &deps.api.addr_canonicalize(borrower.as_str())?,\n    );\n\n    let block_height = if let Some(block_height) = block_height {\n        block_height\n    } else {\n        env.block.height\n    };\n\n    let config: Config = read_config(deps.storage)?;\n    let mut state: State = read_state(deps.storage)?;\n\n    compute_interest(deps, &config, &mut state, block_height, None)?;\n    compute_borrower_interest(&state, &mut borrower_info);\n\n    compute_reward(&mut state, block_height);\n    compute_borrower_reward(&state, &mut borrower_info);\n\n    Ok(BorrowerInfoResponse {\n        borrower: borrower.to_string(),\n        interest_index: borrower_info.interest_index,\n        reward_index: borrower_info.reward_index,\n        loan_amount: borrower_info.loan_amount,\n        pending_rewards: borrower_info.pending_rewards,\n    })\n}\n\npub fn query_borrower_infos(\n    deps: Deps,\n    start_after: Option<Addr>,\n    limit: Option<u32>,\n) -> StdResult<BorrowerInfosResponse> {\n    let start_after = if let Some(start_after) = start_after {\n        Some(deps.api.addr_canonicalize(start_after.as_str())?)\n    } else {\n        None\n    };\n\n    let borrower_infos: Vec<BorrowerInfoResponse> = read_borrower_infos(deps, start_after, limit)?;\n    Ok(BorrowerInfosResponse { borrower_infos })\n}\n\nfn assert_max_borrow_factor(\n    config: &Config,\n    state: &State,\n    current_balance: Uint256,\n    borrow_amount: Uint256,\n) -> Result<(), ContractError> {\n    let current_balance = Decimal256::from_uint256(current_balance);\n    let borrow_amount = Decimal256::from_uint256(borrow_amount);\n\n    // Assert max borrow factor\n    if state.total_liabilities + borrow_amount\n        > (current_balance + state.total_liabilities - state.total_reserves)\n            * config.max_borrow_factor\n    {\n        return Err(ContractError::MaxBorrowFactorReached(\n            config.stable_denom.clone(),\n        ));\n    }\n\n    // Assert available balance\n    if borrow_amount + state.total_reserves > current_balance {\n        return Err(ContractError::NoStableAvailable(\n            config.stable_denom.clone(),\n        ));\n    }\n\n    Ok(())\n}\n\n\n",
        "CodeNames": [
            "borrow.rs"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "borrow rate calculation",
                "Type": "Inexact interest calculation",
                "Description": "The simple interest formula used to compute the accrued debt in the borrow rate calculation can lead to a lower borrow rate in low-activity markets, leading to suppliers losing out on interest.",
                "Repair": "Ensure that the markets are accrued regularly, or switch to a compound interest formula"
            }
        ]
    }
]