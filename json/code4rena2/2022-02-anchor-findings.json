[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "anchor_beth_reward/src/user.rs#L187-L212",
                "Type": "Arbitrary Balance Increase",
                "Description": "An attacker may arbitrarily increase their bEth balance either by flashloan or purchase of wormhole eth, then converting it to bEth via anchor_beth_converter. The attacker may then have a significant portion of the total balance, and since the attacker controls a large portion of the bEth balance, they will receive a higher portion of the rewards. The logic for update_global_index() does not account for sudden balance increases.",
                "Repair": "Option 1: Only allow the global_index to be updated once per block and cap the amount of rewards that may be paid per block. Option 2: Induce a wait time before the user may begin earning rewards, requiring a second transaction from the user to begin collecting their reward."
            },
            {
                "Location": "overseer/src/contract.rs#L192",
                "Type": "Out-of-Date Data",
                "Description": "When the anc_purchase_factor is updated by the owner, execute_epoch_operations is not called, causing out-of-date data and possible wrong bAsset rewards/borrow limits calculation.",
                "Repair": "Call execute_epoch_operations function after config update to ensure that reward calculation is done with up-to-date data."
            },
            {
                "Location": "collector/src/contract.rs#L130-L137",
                "Type": "Sandwich Attack",
                "Description": "The collector contract allows anyone to sweep, swapping an asset token to ANC through astro port. However, belief_price is not set and config.max_spread might not be set or misconfigured, allowing an attacker to create a contract to perform a sandwich attack to make a profit on this trade.",
                "Repair": "Consider setting an ANC/asset belief_price from an oracle to prevent an attacker from creating a contract to perform a sandwich attack."
            },
            {
                "Location": "anchor_airdrop_registry/src/contract.rs#L109, anchor_airdrop_registry/src/contract.rs#L71",
                "Type": "Missing Access Control",
                "Description": "FabricateMIRClaim and FabricateANCClaim should only be issued by the Hub contract, but execute_fabricate_anchor_claim and execute_fabricate_mir_claim do not restrict the caller, allowing anyone to submit these messages.",
                "Repair": "Add at least simple access control checks in the contract to ensure that FabricateMIRClaim and FabricateANCClaim can only be called by the Hub and not by others."
            },
            {
                "Location": "anchor_basset_reward pending yields can be stolen",
                "Type": "smart contract vulnerability",
                "Description": "If the pending yield on an underlying strategy can be harvested and cause a surge of rewards to all existing investors, especially if the harvest can be triggered permissionlessly.",
                "Repair": "update state.global_index before changing the user's balance and/or transfer rewards and update global_index in one transaction"
            },
            {
                "Location": "Governance Voting Dis-proportionally Favours Users Who Stake And Vote After A Poll Has Been Created And Had Its Snapshot Taken",
                "Type": "smart contract vulnerability",
                "Description": "Poll voters are actually incentivised to stake tokens after a poll has had its snapshot taken in order to maximise their voting power.",
                "Repair": "Implement a check-pointing mechanism such that when a user casts a vote, the user's staked balance is checked at the block height upon which the snapshot was taken instead of checking its most up-to-date staked balance"
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"ethereum/BytesLib.sol\";\n\ninterface WormholeCoreBridge {\n    function publishMessage(\n        uint32 nonce,\n        bytes memory payload,\n        uint8 consistencyLevel\n    ) external payable returns (uint64 sequence);\n\n    struct Signature {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        uint8 guardianIndex;\n    }\n\n    struct VM {\n        uint8 version;\n        uint32 timestamp;\n        uint32 nonce;\n        uint16 emitterChainId;\n        bytes32 emitterAddress;\n        uint64 sequence;\n        uint8 consistencyLevel;\n        bytes payload;\n        uint32 guardianSetIndex;\n        Signature[] signatures;\n        bytes32 hash;\n    }\n\n    function parseAndVerifyVM(bytes calldata encodedVM)\n        external\n        view\n        returns (\n            VM memory vm,\n            bool valid,\n            string memory reason\n        );\n}\n\ninterface WormholeTokenBridge {\n    function transferTokens(\n        address token,\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        uint256 arbiterFee,\n        uint32 nonce\n    ) external payable returns (uint64 sequence);\n\n    struct Transfer {\n        // PayloadID uint8 = 1\n        uint8 payloadID;\n        // Amount being transferred (big-endian uint256)\n        uint256 amount;\n        // Address of the token. Left-zero-padded if shorter than 32 bytes\n        bytes32 tokenAddress;\n        // Chain ID of the token\n        uint16 tokenChain;\n        // Address of the recipient. Left-zero-padded if shorter than 32 bytes\n        bytes32 to;\n        // Chain ID of the recipient\n        uint16 toChain;\n        // Amount of tokens (big-endian uint256) that the user is willing to pay as relayer fee. Must be <= Amount.\n        uint256 fee;\n    }\n\n    function parseTransfer(bytes memory encoded)\n        external\n        pure\n        returns (Transfer memory transfer);\n\n    function isTransferCompleted(bytes32 hash) external view returns (bool);\n\n    function completeTransfer(bytes memory encodedVm) external;\n\n    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress)\n        external\n        view\n        returns (address);\n\n    function chainId() external view returns (uint16);\n}\n\ncontract CrossAnchorBridge is\n    Initializable,\n    UUPSUpgradeable,\n    OwnableUpgradeable\n{\n    uint16 private constant TERRA_CHAIN_ID = 3;\n\n    uint8 private constant FLAG_INCOMING_TRANSFER = 0x80; // 1000 0000\n    uint8 private constant FLAG_OUTGOING_TRANSFER = 0x40; // 0100 0000\n    uint8 private constant FLAG_BOTH_TRANSFERS = 0xC0; // 1100 0000\n    uint8 private constant FLAG_NO_ASSC_TRANSFER = 0x00; // 0000 0000\n\n    uint8 private constant OP_CODE_DEPOSIT_STABLE = 0 | FLAG_BOTH_TRANSFERS;\n    uint8 private constant OP_CODE_REDEEM_STABLE = 1 | FLAG_BOTH_TRANSFERS;\n\n    uint8 private constant OP_CODE_REPAY_STABLE = 0 | FLAG_INCOMING_TRANSFER;\n    uint8 private constant OP_CODE_LOCK_COLLATERAL = 1 | FLAG_INCOMING_TRANSFER;\n\n    uint8 private constant OP_CODE_UNLOCK_COLLATERAL =\n        0 | FLAG_OUTGOING_TRANSFER;\n    uint8 private constant OP_CODE_BORROW_STABLE = 1 | FLAG_OUTGOING_TRANSFER;\n    uint8 private constant OP_CODE_CLAIM_REWARDS = 2 | FLAG_OUTGOING_TRANSFER;\n\n    uint32 private constant INSTRUCTION_NONCE = 1324532;\n    uint32 private constant TOKEN_TRANSFER_NONCE = 15971121;\n\n    uint8 private CONSISTENCY_LEVEL;\n    address private WORMHOLE_CORE_BRIDGE;\n    address private WORMHOLE_TOKEN_BRIDGE;\n    bytes32 private TERRA_ANCHOR_BRIDGE_ADDRESS;\n\n    // Wormhole-wrapped Terra stablecoin tokens that are whitelisted in Terra Anchor Market. Example: UST.\n    mapping(address => bool) public whitelistedStableTokens;\n    // Wormhole-wrapped Terra Anchor yield-generating tokens that can be redeemed for Terra stablecoins. Example: aUST.\n    mapping(address => bool) public whitelistedAnchorStableTokens;\n    // Wormhole-wrapped Terra cw20 tokens that can be used as collateral in Anchor. Examples: bLUNA, bETH.\n    mapping(address => bool) public whitelistedCollateralTokens;\n\n    // Stores hashes of completed incoming token transfer.\n    mapping(bytes32 => bool) public completedTokenTransfers;\n\n    function initialize(\n        uint8 _consistencyLevel,\n        address _wust,\n        address _aust,\n        address[] memory _collateralTokens,\n        address _wormholeCoreBridge,\n        address _wormholeTokenBridge,\n        bytes32 _terraAnchorBridgeAddress\n    ) public initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n        CONSISTENCY_LEVEL = _consistencyLevel;\n        whitelistedStableTokens[_wust] = true;\n        whitelistedAnchorStableTokens[_aust] = true;\n        for (uint8 i = 0; i < _collateralTokens.length; i++) {\n            whitelistedCollateralTokens[_collateralTokens[i]] = true;\n        }\n        WORMHOLE_CORE_BRIDGE = _wormholeCoreBridge;\n        WORMHOLE_TOKEN_BRIDGE = _wormholeTokenBridge;\n        TERRA_ANCHOR_BRIDGE_ADDRESS = _terraAnchorBridgeAddress;\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    function encodeAddress(address addr)\n        internal\n        pure\n        returns (bytes32 encodedAddress)\n    {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function handleStableToken(\n        address token,\n        uint256 amount,\n        uint8 opCode\n    ) internal {\n        // Check that `token` is a whitelisted stablecoin token.\n        // require(whitelistedStableTokens[token]);\n        handleToken(token, amount, opCode);\n    }\n\n    function handleToken(\n        address token,\n        uint256 amount,\n        uint8 opCode\n    ) internal {\n        // Transfer ERC-20 token from message sender to this contract.\n        SafeERC20.safeTransferFrom(\n            IERC20(token),\n            msg.sender,\n            address(this),\n            amount\n        );\n        // Allow wormhole to spend USTw from this contract.\n        SafeERC20.safeApprove(IERC20(token), WORMHOLE_TOKEN_BRIDGE, amount);\n        // Initiate token transfer.\n        uint64 tokenTransferSequence = WormholeTokenBridge(\n            WORMHOLE_TOKEN_BRIDGE\n        ).transferTokens(\n                token,\n                amount,\n                TERRA_CHAIN_ID,\n                TERRA_ANCHOR_BRIDGE_ADDRESS,\n                0,\n                TOKEN_TRANSFER_NONCE\n            );\n        // Send instruction message to Terra manager.\n        WormholeCoreBridge(WORMHOLE_CORE_BRIDGE).publishMessage(\n            INSTRUCTION_NONCE,\n            abi.encodePacked(\n                opCode,\n                encodeAddress(msg.sender),\n                tokenTransferSequence\n            ),\n            CONSISTENCY_LEVEL\n        );\n    }\n\n    function depositStable(address token, uint256 amount) external {\n        handleStableToken(token, amount, OP_CODE_DEPOSIT_STABLE);\n    }\n\n    function repayStable(address token, uint256 amount) external {\n        handleStableToken(token, amount, OP_CODE_REPAY_STABLE);\n    }\n\n    function unlockCollateral(\n        bytes32 collateralTokenTerraAddress,\n        uint128 amount\n    ) external {\n        WormholeCoreBridge(WORMHOLE_CORE_BRIDGE).publishMessage(\n            INSTRUCTION_NONCE,\n            abi.encodePacked(\n                OP_CODE_UNLOCK_COLLATERAL,\n                encodeAddress(msg.sender),\n                collateralTokenTerraAddress,\n                amount\n            ),\n            CONSISTENCY_LEVEL\n        );\n    }\n\n    function borrowStable(uint256 amount) external {\n        WormholeCoreBridge(WORMHOLE_CORE_BRIDGE).publishMessage(\n            INSTRUCTION_NONCE,\n            abi.encodePacked(\n                OP_CODE_BORROW_STABLE,\n                encodeAddress(msg.sender),\n                amount\n            ),\n            CONSISTENCY_LEVEL\n        );\n    }\n\n    function redeemStable(address token, uint256 amount) external {\n        // require(whitelistedAnchorStableTokens[token]);\n        handleToken(token, amount, OP_CODE_REDEEM_STABLE);\n    }\n\n    function lockCollateral(address token, uint256 amount) external {\n        // require(whitelistedCollateralTokens[token]);\n        handleToken(token, amount, OP_CODE_LOCK_COLLATERAL);\n    }\n\n    struct IncomingTokenTransferInfo {\n        uint16 chainId;\n        bytes32 tokenRecipientAddress;\n        uint64 tokenTransferSequence;\n        uint64 instructionSequence;\n    }\n\n    using BytesLib for bytes;\n\n    function parseIncomingTokenTransferInfo(bytes memory encoded)\n        public\n        pure\n        returns (IncomingTokenTransferInfo memory incomingTokenTransferInfo)\n    {\n        uint256 index = 0;\n\n        incomingTokenTransferInfo.chainId = encoded.toUint16(index);\n        index += 2;\n\n        incomingTokenTransferInfo.tokenRecipientAddress = encoded.toBytes32(\n            index\n        );\n        index += 32;\n\n        incomingTokenTransferInfo.tokenTransferSequence = encoded.toUint64(\n            index\n        );\n        index += 8;\n\n        incomingTokenTransferInfo.instructionSequence = encoded.toUint64(index);\n        index += 8;\n\n        require(\n            encoded.length == index,\n            \"invalid IncomingTokenTransferInfo encoded length\"\n        );\n    }\n\n    // operations are bundled into two messages:\n    // - a token transfer message from the token bridge\n    // - a generic message providing context to the token transfer\n    function processTokenTransferInstruction(\n        bytes memory encodedIncomingTokenTransferInfo,\n        bytes memory encodedTokenTransfer\n    ) external {\n        WormholeTokenBridge wormholeTokenBridge = WormholeTokenBridge(\n            WORMHOLE_TOKEN_BRIDGE\n        );\n        WormholeCoreBridge wormholeCoreBridge = WormholeCoreBridge(\n            WORMHOLE_CORE_BRIDGE\n        );\n\n        (\n            WormholeCoreBridge.VM memory incomingTokenTransferInfoVM,\n            bool validIncomingTokenTransferInfo,\n            string memory reasonIncomingTokenTransferInfo\n        ) = wormholeCoreBridge.parseAndVerifyVM(\n                encodedIncomingTokenTransferInfo\n            );\n        require(\n            validIncomingTokenTransferInfo,\n            reasonIncomingTokenTransferInfo\n        );\n        require(\n            incomingTokenTransferInfoVM.emitterChainId == TERRA_CHAIN_ID,\n            \"message does not come from terra\"\n        );\n        require(\n            incomingTokenTransferInfoVM.emitterAddress ==\n                TERRA_ANCHOR_BRIDGE_ADDRESS,\n            \"message does not come from terra anchor bridge\"\n        );\n        require(\n            !completedTokenTransfers[incomingTokenTransferInfoVM.hash],\n            \"transfer info already processed\"\n        );\n\n        // block replay attacks\n        completedTokenTransfers[incomingTokenTransferInfoVM.hash] = true;\n        IncomingTokenTransferInfo\n            memory incomingTokenTransferInfo = parseIncomingTokenTransferInfo(\n                incomingTokenTransferInfoVM.payload\n            );\n\n        (\n            WormholeCoreBridge.VM memory tokenTransferVM,\n            bool valid,\n            string memory reason\n        ) = wormholeCoreBridge.parseAndVerifyVM(encodedTokenTransfer);\n        require(valid, reason);\n        require(\n            tokenTransferVM.emitterChainId == TERRA_CHAIN_ID,\n            \"chain id mismatch\"\n        );\n        // No need to check emitter address; this is checked by completeTransfer.\n        // ensure that the provided transfer vaa is the one referenced by the transfer info\n        require(\n            tokenTransferVM.sequence ==\n                incomingTokenTransferInfo.tokenTransferSequence,\n            \"sequence mismatch\"\n        );\n\n        WormholeTokenBridge.Transfer memory transfer = wormholeTokenBridge\n            .parseTransfer(tokenTransferVM.payload);\n        // No need to check that recipient chain matches this chain; this is checked by completeTransfer.\n        require(\n            transfer.to == encodeAddress(address(this)),\n            \"transfer is not to this address\"\n        );\n        require(\n            transfer.toChain == incomingTokenTransferInfo.chainId,\n            \"transfer is to the wrong chain\"\n        );\n\n        if (!wormholeTokenBridge.isTransferCompleted(tokenTransferVM.hash)) {\n            wormholeTokenBridge.completeTransfer(encodedTokenTransfer);\n        }\n\n        address tokenAddress;\n\n        if (transfer.tokenChain == wormholeTokenBridge.chainId()) {\n            tokenAddress = address(uint160(uint256(transfer.tokenAddress)));\n        } else {\n            tokenAddress = wormholeTokenBridge.wrappedAsset(\n                transfer.tokenChain,\n                transfer.tokenAddress\n            );\n        }\n        // forward the tokens to the appropriate recipient\n        SafeERC20.safeTransfer(\n            IERC20(tokenAddress),\n            address(\n                uint160(\n                    uint256(incomingTokenTransferInfo.tokenRecipientAddress)\n                )\n            ),\n            transfer.amount\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "CrossAnchorBridge.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CrossAnchorBridge.sol#L167-L175, CrossAnchorBridge.sol#L250-L253, CrossAnchorBridge.sol#L255-L258",
                "Type": "Missing Whitelist Check",
                "Description": "In the current implementation of CrossAnchorBridge, all require that 'Check that token is a whitelisted token' is commented out, allowing users to send transactions with non-whitelisted tokens that cannot be processed properly on the Terra side, potentially leading to frozen funds.",
                "Repair": "Uncomment the whitelist codes to ensure that only whitelisted tokens can be processed properly on the Terra side."
            }
        ]
    },
    {
        "Code": "use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_bignumber::Uint256;\nuse cw20::Cw20ReceiveMsg;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct InstantiateMsg {\n    /// owner address\n    pub owner: String,\n    /// bAsset token address\n    pub collateral_token: String,\n    /// overseer contract address\n    pub overseer_contract: String,\n    /// market contract address\n    pub market_contract: String,\n    /// bAsset rewrad contract\n    pub reward_contract: String,\n    /// liquidation contract address\n    pub liquidation_contract: String,\n    /// Expected reward denom. If bAsset reward is not same with\n    /// it, we try to convert the reward to the `stable_denom`.\n    pub stable_denom: String,\n    pub basset_info: BAssetInfo,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    /// CW20 token receiver\n    Receive(Cw20ReceiveMsg),\n\n    ////////////////////\n    /// Overseer operations\n    ////////////////////\n\n    /// Update config\n    UpdateConfig {\n        owner: Option<String>,\n        liquidation_contract: Option<String>,\n    },\n    /// Make specified amount of tokens unspendable\n    LockCollateral { borrower: String, amount: Uint256 },\n    /// Make specified amount of collateral tokens spendable\n    UnlockCollateral { borrower: String, amount: Uint256 },\n    /// Claim bAsset rewards and distribute claimed rewards\n    /// to market and overseer contracts\n    DistributeRewards {},\n\n    /// Liquidate collateral and send liquidated collateral to `to` address\n    LiquidateCollateral {\n        liquidator: String,\n        borrower: String,\n        amount: Uint256,\n    },\n\n    ////////////////////\n    /// User operations\n    ////////////////////\n\n    /// Withdraw spendable collateral token.\n    /// If the amount is not given,\n    /// return all spendable collateral\n    WithdrawCollateral { amount: Option<Uint256> },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum Cw20HookMsg {\n    /// Deposit collateral token\n    DepositCollateral {},\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    Config {},\n    Borrower {\n        address: String,\n    },\n    Borrowers {\n        start_after: Option<String>,\n        limit: Option<u32>,\n    },\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct ConfigResponse {\n    pub owner: String,\n    pub collateral_token: String,\n    pub overseer_contract: String,\n    pub market_contract: String,\n    pub reward_contract: String,\n    pub liquidation_contract: String,\n    pub stable_denom: String,\n    pub basset_info: BAssetInfo,\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct BorrowerResponse {\n    pub borrower: String,\n    pub balance: Uint256,\n    pub spendable: Uint256,\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct BorrowersResponse {\n    pub borrowers: Vec<BorrowerResponse>,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct BAssetInfo {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n}\n\n\n",
        "CodeNames": [
            "custody.rs"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Potential lock of rewards in the custody contracts",
                "Type": "smart contract vulnerability",
                "Description": "The rewards are locked in the contract until someone triggers swap_to_stable_denom again, and the last swap succeeds.",
                "Repair": "Handle the reply on either success or failure, i.e., using ReplyOn::Always, to avoid the failure of the swap to cause tokens to be locked"
            }
        ]
    },
    {
        "Code": "use crate::state::{read_config, store_config};\n\nuse cosmwasm_std::{attr, Addr, DepsMut, MessageInfo, Response, StdError, StdResult};\nuse terra_cosmwasm::TerraMsgWrapper;\n\npub fn execute_post_initialize(\n    deps: DepsMut,\n    info: MessageInfo,\n    token_contract: Addr,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let mut config = read_config(deps.storage)?;\n    let owner_addr = deps.api.addr_humanize(&config.owner)?;\n\n    if info.sender != owner_addr {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    config.token_contract = Some(deps.api.addr_canonicalize(token_contract.as_str())?);\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![attr(\"action\", \"post_initialize\")]))\n}\n\npub fn execute_update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    owner: Addr,\n) -> StdResult<Response<TerraMsgWrapper>> {\n    let mut config = read_config(deps.storage)?;\n    let owner_addr = deps.api.addr_humanize(&config.owner)?;\n\n    if info.sender != owner_addr {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    config.owner = deps.api.addr_canonicalize(owner.as_str())?;\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![attr(\"action\", \"update_config\")]))\n}\n\n\n",
        "CodeNames": [
            "owner.rs"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Spend limit on owner can be bypassed",
                "Type": "smart contract vulnerability",
                "Description": "The owner is only allowed to spend amount uptil config.spend_limit. However it was observed that this config.spend_limit is never decreased even if owner has spend an amount.",
                "Repair": "Decrease the config.spend_limit by the amount spend after successful spend"
            }
        ]
    },
    {
        "Code": "use crate::error::ContractError;\nuse crate::state::{\n    bank_read, bank_store, config_read, config_store, poll_read, poll_voter_store, state_read,\n    state_store, Config, Poll, State, TokenManager,\n};\n\nuse anchor_token::gov::{PollStatus, StakerResponse};\nuse astroport::querier::query_token_balance;\nuse cosmwasm_std::{\n    to_binary, Addr, CanonicalAddr, CosmosMsg, Deps, DepsMut, MessageInfo, Response, StdResult,\n    Storage, Uint128, WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\npub fn stake_voting_tokens(\n    deps: DepsMut,\n    sender: Addr,\n    amount: Uint128,\n) -> Result<Response, ContractError> {\n    if amount.is_zero() {\n        return Err(ContractError::InsufficientFunds {});\n    }\n\n    let sender_address_raw = deps.api.addr_canonicalize(sender.as_str())?;\n    let key = &sender_address_raw.as_slice();\n\n    let mut token_manager = bank_read(deps.storage).may_load(key)?.unwrap_or_default();\n    let config: Config = config_store(deps.storage).load()?;\n    let mut state: State = state_store(deps.storage).load()?;\n\n    // balance already increased, so subtract deposit amount\n    let total_balance = query_token_balance(\n        &deps.querier,\n        deps.api.addr_humanize(&config.anchor_token)?,\n        deps.api.addr_humanize(&state.contract_addr)?,\n    )?\n    .checked_sub(state.total_deposit + amount)?;\n\n    let share = if total_balance.is_zero() || state.total_share.is_zero() {\n        amount\n    } else {\n        amount.multiply_ratio(state.total_share, total_balance)\n    };\n\n    token_manager.share += share;\n    state.total_share += share;\n\n    state_store(deps.storage).save(&state)?;\n    bank_store(deps.storage).save(key, &token_manager)?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"action\", \"staking\"),\n        (\"sender\", sender.as_str()),\n        (\"share\", share.to_string().as_str()),\n        (\"amount\", amount.to_string().as_str()),\n    ]))\n}\n\n// Withdraw amount if not staked. By default all funds will be withdrawn.\npub fn withdraw_voting_tokens(\n    deps: DepsMut,\n    info: MessageInfo,\n    amount: Option<Uint128>,\n) -> Result<Response, ContractError> {\n    let sender_address_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n    let key = sender_address_raw.as_slice();\n\n    if let Some(mut token_manager) = bank_read(deps.storage).may_load(key)? {\n        let config: Config = config_store(deps.storage).load()?;\n        let mut state: State = state_store(deps.storage).load()?;\n\n        // Load total share & total balance except proposal deposit amount\n        let total_share = state.total_share.u128();\n        let total_balance = query_token_balance(\n            &deps.querier,\n            deps.api.addr_humanize(&config.anchor_token)?,\n            deps.api.addr_humanize(&state.contract_addr)?,\n        )?\n        .checked_sub(state.total_deposit)?\n        .u128();\n\n        let locked_balance =\n            compute_locked_balance(deps.storage, &mut token_manager, &sender_address_raw);\n        let locked_share = locked_balance * total_share / total_balance;\n        let user_share = token_manager.share.u128();\n\n        let withdraw_share = amount\n            .map(|v| std::cmp::max(v.multiply_ratio(total_share, total_balance).u128(), 1u128))\n            .unwrap_or_else(|| user_share - locked_share);\n        let withdraw_amount = amount\n            .map(|v| v.u128())\n            .unwrap_or_else(|| withdraw_share * total_balance / total_share);\n\n        if locked_share + withdraw_share > user_share {\n            Err(ContractError::InvalidWithdrawAmount {})\n        } else {\n            let share = user_share - withdraw_share;\n            token_manager.share = Uint128::from(share);\n\n            bank_store(deps.storage).save(key, &token_manager)?;\n\n            state.total_share = Uint128::from(total_share - withdraw_share);\n            state_store(deps.storage).save(&state)?;\n\n            send_tokens(\n                deps,\n                &config.anchor_token,\n                &sender_address_raw,\n                withdraw_amount,\n                \"withdraw\",\n            )\n        }\n    } else {\n        Err(ContractError::NothingStaked {})\n    }\n}\n\n// removes not in-progress poll voter info & unlock tokens\n// and returns the largest locked amount in participated polls.\nfn compute_locked_balance(\n    storage: &mut dyn Storage,\n    token_manager: &mut TokenManager,\n    voter: &CanonicalAddr,\n) -> u128 {\n    token_manager.locked_balance.retain(|(poll_id, _)| {\n        let poll: Poll = poll_read(storage).load(&poll_id.to_be_bytes()).unwrap();\n\n        if poll.status != PollStatus::InProgress {\n            // remove voter info from the poll\n            poll_voter_store(storage, *poll_id).remove(voter.as_slice());\n        }\n\n        poll.status == PollStatus::InProgress\n    });\n\n    token_manager\n        .locked_balance\n        .iter()\n        .map(|(_, v)| v.balance.u128())\n        .max()\n        .unwrap_or_default()\n}\n\nfn send_tokens(\n    deps: DepsMut,\n    asset_token: &CanonicalAddr,\n    recipient: &CanonicalAddr,\n    amount: u128,\n    action: &str,\n) -> Result<Response, ContractError> {\n    let contract_human = deps.api.addr_humanize(asset_token)?.to_string();\n    let recipient_human = deps.api.addr_humanize(recipient)?.to_string();\n\n    Ok(Response::new()\n        .add_messages(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: contract_human,\n            msg: to_binary(&Cw20ExecuteMsg::Transfer {\n                recipient: recipient_human.clone(),\n                amount: Uint128::from(amount),\n            })?,\n            funds: vec![],\n        })])\n        .add_attributes(vec![\n            (\"action\", action),\n            (\"recipient\", recipient_human.as_str()),\n            (\"amount\", amount.to_string().as_str()),\n        ]))\n}\n\npub fn query_staker(deps: Deps, address: String) -> StdResult<StakerResponse> {\n    let addr_raw = deps.api.addr_canonicalize(&address).unwrap();\n    let config: Config = config_read(deps.storage).load()?;\n    let state: State = state_read(deps.storage).load()?;\n    let mut token_manager = bank_read(deps.storage)\n        .may_load(addr_raw.as_slice())?\n        .unwrap_or_default();\n\n    // filter out not in-progress polls\n    token_manager.locked_balance.retain(|(poll_id, _)| {\n        let poll: Poll = poll_read(deps.storage)\n            .load(&poll_id.to_be_bytes())\n            .unwrap();\n\n        poll.status == PollStatus::InProgress\n    });\n\n    let total_balance = query_token_balance(\n        &deps.querier,\n        deps.api.addr_humanize(&config.anchor_token)?,\n        deps.api.addr_humanize(&state.contract_addr)?,\n    )?\n    .checked_sub(state.total_deposit)?;\n\n    Ok(StakerResponse {\n        balance: if !state.total_share.is_zero() {\n            token_manager\n                .share\n                .multiply_ratio(total_balance, state.total_share)\n        } else {\n            Uint128::zero()\n        },\n        share: token_manager.share,\n        locked_balance: token_manager.locked_balance,\n    })\n}\n\n\n",
        "CodeNames": [
            "staking.rs"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "staking.rs",
                "Type": "Stolen Tokens",
                "Description": "Staking tokens can be stolen when withdrawing from the staking contract due to rounding down of shares calculation.",
                "Repair": "1. Always round up in withdraw_share 2. Always recompute the withdraw_amount with the new withdraw_share even if the amount parameter was set. 3. Use a share parameter (instead of the amount parameter) and use it as withdraw_share. Rounding down on the resulting withdraw_amount is bad for the attacker as burning a share leads to fewer tokens."
            }
        ]
    },
    {
        "Code": "use anchor_token::distributor::ExecuteMsg as FaucetExecuteMsg;\nuse cosmwasm_bignumber::{Decimal256, Uint256};\nuse cosmwasm_std::{\n    attr, to_binary, Addr, BankMsg, Coin, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response,\n    StdResult, WasmMsg,\n};\nuse moneymarket::interest_model::BorrowRateResponse;\nuse moneymarket::market::{BorrowerInfoResponse, BorrowerInfosResponse};\nuse moneymarket::overseer::BorrowLimitResponse;\nuse moneymarket::querier::{deduct_tax, query_balance, query_supply};\n\nuse crate::deposit::compute_exchange_rate_raw;\nuse crate::error::ContractError;\nuse crate::querier::{query_borrow_limit, query_borrow_rate, query_target_deposit_rate};\nuse crate::state::{\n    read_borrower_info, read_borrower_infos, read_config, read_state, store_borrower_info,\n    store_state, BorrowerInfo, Config, State,\n};\n\npub fn borrow_stable(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrow_amount: Uint256,\n    to: Option<Addr>,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n\n    let mut state: State = read_state(deps.storage)?;\n\n    let borrower = info.sender;\n    let borrower_raw = deps.api.addr_canonicalize(borrower.as_str())?;\n    let mut liability: BorrowerInfo = read_borrower_info(deps.storage, &borrower_raw);\n\n    // Compute interest\n    compute_interest(deps.as_ref(), &config, &mut state, env.block.height, None)?;\n    compute_borrower_interest(&state, &mut liability);\n\n    // Compute ANC reward\n    compute_reward(&mut state, env.block.height);\n    compute_borrower_reward(&state, &mut liability);\n\n    let overseer = deps.api.addr_humanize(&config.overseer_contract)?;\n    let borrow_limit_res: BorrowLimitResponse = query_borrow_limit(\n        deps.as_ref(),\n        overseer,\n        borrower.clone(),\n        Some(env.block.time.seconds()),\n    )?;\n\n    if borrow_limit_res.borrow_limit < borrow_amount + liability.loan_amount {\n        return Err(ContractError::BorrowExceedsLimit(\n            borrow_limit_res.borrow_limit.into(),\n        ));\n    }\n\n    let current_balance = query_balance(\n        deps.as_ref(),\n        env.contract.address,\n        config.stable_denom.to_string(),\n    )?;\n\n    // Assert borrow amount\n    assert_max_borrow_factor(&config, &state, current_balance, borrow_amount)?;\n\n    liability.loan_amount += borrow_amount;\n    state.total_liabilities += Decimal256::from_uint256(borrow_amount);\n    store_state(deps.storage, &state)?;\n    store_borrower_info(deps.storage, &borrower_raw, &liability)?;\n\n    Ok(Response::new()\n        .add_message(CosmosMsg::Bank(BankMsg::Send {\n            to_address: to.unwrap_or_else(|| borrower.clone()).to_string(),\n            amount: vec![deduct_tax(\n                deps.as_ref(),\n                Coin {\n                    denom: config.stable_denom,\n                    amount: borrow_amount.into(),\n                },\n            )?],\n        }))\n        .add_attributes(vec![\n            attr(\"action\", \"borrow_stable\"),\n            attr(\"borrower\", borrower),\n            attr(\"borrow_amount\", borrow_amount),\n        ]))\n}\n\npub fn repay_stable_from_liquidation(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrower: Addr,\n    prev_balance: Uint256,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    if config.overseer_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let cur_balance: Uint256 = query_balance(\n        deps.as_ref(),\n        env.contract.address.clone(),\n        config.stable_denom.to_string(),\n    )?;\n\n    // override env\n    let mut info = info;\n\n    info.sender = borrower;\n    info.funds = vec![Coin {\n        denom: config.stable_denom,\n        amount: (cur_balance - prev_balance).into(),\n    }];\n\n    repay_stable(deps, env, info)\n}\n\npub fn repay_stable(deps: DepsMut, env: Env, info: MessageInfo) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n\n    // Check stable denom deposit\n    let amount: Uint256 = info\n        .funds\n        .iter()\n        .find(|c| c.denom == config.stable_denom)\n        .map(|c| Uint256::from(c.amount))\n        .unwrap_or_else(Uint256::zero);\n\n    // Cannot deposit zero amount\n    if amount.is_zero() {\n        return Err(ContractError::ZeroRepay(config.stable_denom));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n\n    let borrower = info.sender;\n    let borrower_raw = deps.api.addr_canonicalize(borrower.as_str())?;\n    let mut liability: BorrowerInfo = read_borrower_info(deps.storage, &borrower_raw);\n\n    // Compute interest\n    compute_interest(\n        deps.as_ref(),\n        &config,\n        &mut state,\n        env.block.height,\n        Some(amount),\n    )?;\n    compute_borrower_interest(&state, &mut liability);\n\n    // Compute ANC reward\n    compute_reward(&mut state, env.block.height);\n    compute_borrower_reward(&state, &mut liability);\n\n    let repay_amount: Uint256;\n    let mut messages: Vec<CosmosMsg> = vec![];\n    if liability.loan_amount < amount {\n        repay_amount = liability.loan_amount;\n        liability.loan_amount = Uint256::zero();\n\n        // Payback left repay amount to sender\n        messages.push(CosmosMsg::Bank(BankMsg::Send {\n            to_address: borrower.to_string(),\n            amount: vec![deduct_tax(\n                deps.as_ref(),\n                Coin {\n                    denom: config.stable_denom,\n                    amount: (amount - repay_amount).into(),\n                },\n            )?],\n        }));\n    } else {\n        repay_amount = amount;\n        liability.loan_amount = liability.loan_amount - repay_amount;\n    }\n\n    state.total_liabilities = state.total_liabilities - Decimal256::from_uint256(repay_amount);\n\n    store_borrower_info(deps.storage, &borrower_raw, &liability)?;\n    store_state(deps.storage, &state)?;\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"repay_stable\"),\n        attr(\"borrower\", borrower),\n        attr(\"repay_amount\", repay_amount),\n    ]))\n}\n\npub fn claim_rewards(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    to: Option<Addr>,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    let mut state: State = read_state(deps.storage)?;\n\n    let borrower = info.sender;\n    let borrower_raw = deps.api.addr_canonicalize(borrower.as_str())?;\n    let mut liability: BorrowerInfo = read_borrower_info(deps.storage, &borrower_raw);\n\n    // Compute interest\n    compute_interest(deps.as_ref(), &config, &mut state, env.block.height, None)?;\n    compute_borrower_interest(&state, &mut liability);\n\n    // Compute ANC reward\n    compute_reward(&mut state, env.block.height);\n    compute_borrower_reward(&state, &mut liability);\n\n    let claim_amount = liability.pending_rewards * Uint256::one();\n    liability.pending_rewards = liability.pending_rewards - Decimal256::from_uint256(claim_amount);\n\n    store_state(deps.storage, &state)?;\n    store_borrower_info(deps.storage, &borrower_raw, &liability)?;\n\n    let messages: Vec<CosmosMsg> = if !claim_amount.is_zero() {\n        vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: deps\n                .api\n                .addr_humanize(&config.distributor_contract)?\n                .to_string(),\n            funds: vec![],\n            msg: to_binary(&FaucetExecuteMsg::Spend {\n                recipient: if let Some(to) = to {\n                    to.to_string()\n                } else {\n                    borrower.to_string()\n                },\n                amount: claim_amount.into(),\n            })?,\n        })]\n    } else {\n        vec![]\n    };\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"claim_rewards\"),\n        attr(\"claim_amount\", claim_amount),\n    ]))\n}\n\n/// Compute interest and update state\n/// total liabilities and total reserves\npub fn compute_interest(\n    deps: Deps,\n    config: &Config,\n    state: &mut State,\n    block_height: u64,\n    deposit_amount: Option<Uint256>,\n) -> StdResult<()> {\n    if state.last_interest_updated >= block_height {\n        return Ok(());\n    }\n\n    let aterra_supply = query_supply(deps, deps.api.addr_humanize(&config.aterra_contract)?)?;\n    let balance: Uint256 = query_balance(\n        deps,\n        deps.api.addr_humanize(&config.contract_addr)?,\n        config.stable_denom.to_string(),\n    )? - deposit_amount.unwrap_or_else(Uint256::zero);\n\n    let borrow_rate_res: BorrowRateResponse = query_borrow_rate(\n        deps,\n        deps.api.addr_humanize(&config.interest_model)?,\n        balance,\n        state.total_liabilities,\n        state.total_reserves,\n    )?;\n\n    let target_deposit_rate: Decimal256 =\n        query_target_deposit_rate(deps, deps.api.addr_humanize(&config.overseer_contract)?)?;\n\n    compute_interest_raw(\n        state,\n        block_height,\n        balance,\n        aterra_supply,\n        borrow_rate_res.rate,\n        target_deposit_rate,\n    );\n\n    Ok(())\n}\n\n// CONTRACT: to use this function as state update purpose,\n// executor must update following three state after execution\n// * state.prev_aterra_supply\n// * state.prev_exchange_rate\n// * state.last_interest_updated\npub fn compute_interest_raw(\n    state: &mut State,\n    block_height: u64,\n    balance: Uint256,\n    aterra_supply: Uint256,\n    borrow_rate: Decimal256,\n    target_deposit_rate: Decimal256,\n) {\n    if state.last_interest_updated >= block_height {\n        return;\n    }\n\n    let passed_blocks = Decimal256::from_uint256(block_height - state.last_interest_updated);\n\n    let interest_factor = passed_blocks * borrow_rate;\n    let interest_accrued = state.total_liabilities * interest_factor;\n\n    state.global_interest_index =\n        state.global_interest_index * (Decimal256::one() + interest_factor);\n    state.total_liabilities += interest_accrued;\n\n    let mut exchange_rate = compute_exchange_rate_raw(state, aterra_supply, balance);\n    let effective_deposit_rate = exchange_rate / state.prev_exchange_rate;\n    let deposit_rate = (effective_deposit_rate - Decimal256::one()) / passed_blocks;\n\n    if deposit_rate > target_deposit_rate {\n        // excess_deposit_rate(_per_block)\n        let excess_deposit_rate = deposit_rate - target_deposit_rate;\n        let prev_deposits =\n            Decimal256::from_uint256(state.prev_aterra_supply * state.prev_exchange_rate);\n\n        // excess_yield = prev_deposits * excess_deposit_rate(_per_block) * blocks\n        let excess_yield = prev_deposits * passed_blocks * excess_deposit_rate;\n\n        state.total_reserves += excess_yield;\n        exchange_rate = compute_exchange_rate_raw(state, aterra_supply, balance);\n    }\n\n    state.prev_aterra_supply = aterra_supply;\n    state.prev_exchange_rate = exchange_rate;\n    state.last_interest_updated = block_height;\n}\n\n/// Compute new interest and apply to liability\npub(crate) fn compute_borrower_interest(state: &State, liability: &mut BorrowerInfo) {\n    liability.loan_amount =\n        liability.loan_amount * state.global_interest_index / liability.interest_index;\n    liability.interest_index = state.global_interest_index;\n}\n\n/// Compute distributed reward and update global index\npub fn compute_reward(state: &mut State, block_height: u64) {\n    if state.last_reward_updated >= block_height {\n        return;\n    }\n\n    let passed_blocks = Decimal256::from_uint256(block_height - state.last_reward_updated);\n    let reward_accrued = passed_blocks * state.anc_emission_rate;\n    let borrow_amount = state.total_liabilities / state.global_interest_index;\n\n    if !reward_accrued.is_zero() && !borrow_amount.is_zero() {\n        state.global_reward_index += reward_accrued / borrow_amount;\n    }\n\n    state.last_reward_updated = block_height;\n}\n\n/// Compute reward amount a borrower received\npub(crate) fn compute_borrower_reward(state: &State, liability: &mut BorrowerInfo) {\n    liability.pending_rewards += Decimal256::from_uint256(liability.loan_amount)\n        / state.global_interest_index\n        * (state.global_reward_index - liability.reward_index);\n    liability.reward_index = state.global_reward_index;\n}\n\npub fn query_borrower_info(\n    deps: Deps,\n    env: Env,\n    borrower: Addr,\n    block_height: Option<u64>,\n) -> StdResult<BorrowerInfoResponse> {\n    let mut borrower_info: BorrowerInfo = read_borrower_info(\n        deps.storage,\n        &deps.api.addr_canonicalize(borrower.as_str())?,\n    );\n\n    let block_height = if let Some(block_height) = block_height {\n        block_height\n    } else {\n        env.block.height\n    };\n\n    let config: Config = read_config(deps.storage)?;\n    let mut state: State = read_state(deps.storage)?;\n\n    compute_interest(deps, &config, &mut state, block_height, None)?;\n    compute_borrower_interest(&state, &mut borrower_info);\n\n    compute_reward(&mut state, block_height);\n    compute_borrower_reward(&state, &mut borrower_info);\n\n    Ok(BorrowerInfoResponse {\n        borrower: borrower.to_string(),\n        interest_index: borrower_info.interest_index,\n        reward_index: borrower_info.reward_index,\n        loan_amount: borrower_info.loan_amount,\n        pending_rewards: borrower_info.pending_rewards,\n    })\n}\n\npub fn query_borrower_infos(\n    deps: Deps,\n    start_after: Option<Addr>,\n    limit: Option<u32>,\n) -> StdResult<BorrowerInfosResponse> {\n    let start_after = if let Some(start_after) = start_after {\n        Some(deps.api.addr_canonicalize(start_after.as_str())?)\n    } else {\n        None\n    };\n\n    let borrower_infos: Vec<BorrowerInfoResponse> = read_borrower_infos(deps, start_after, limit)?;\n    Ok(BorrowerInfosResponse { borrower_infos })\n}\n\nfn assert_max_borrow_factor(\n    config: &Config,\n    state: &State,\n    current_balance: Uint256,\n    borrow_amount: Uint256,\n) -> Result<(), ContractError> {\n    let current_balance = Decimal256::from_uint256(current_balance);\n    let borrow_amount = Decimal256::from_uint256(borrow_amount);\n\n    // Assert max borrow factor\n    if state.total_liabilities + borrow_amount\n        > (current_balance + state.total_liabilities - state.total_reserves)\n            * config.max_borrow_factor\n    {\n        return Err(ContractError::MaxBorrowFactorReached(\n            config.stable_denom.clone(),\n        ));\n    }\n\n    // Assert available balance\n    if borrow_amount + state.total_reserves > current_balance {\n        return Err(ContractError::NoStableAvailable(\n            config.stable_denom.clone(),\n        ));\n    }\n\n    Ok(())\n}\n\n\n",
        "CodeNames": [
            "borrow.rs"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "borrow.rs",
                "Type": "Spend Limit Revert",
                "Description": "The claim_rewards function may revert due to the spend_limit set on the distributor contract.",
                "Repair": "Consider removing the spend_limit or allowing users to specify an amount when claim_rewards."
            },
            {
                "Location": "compute_interest_raw function in borrow.rs file",
                "Type": "Loss of Yield",
                "Description": "The borrow rate uses a simple interest formula to compute the accrued debt, instead of a compounding formula. This means the actual borrow rate and interest for suppliers depend on how often updates are made. This difference should be negligible in highly active markets, but it could lead to a lower borrow rate in low-activity markets, leading to suppliers losing out on interest.",
                "Repair": "Accrue markets regularly or switch to a compound interest formula"
            }
        ]
    },
    {
        "Code": "use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_bignumber::Decimal256;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InstantiateMsg {\n    pub owner: String,\n    pub base_asset: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ExecuteMsg {\n    UpdateConfig {\n        owner: Option<String>,\n    },\n    RegisterFeeder {\n        asset: String,\n        feeder: String,\n    },\n    FeedPrice {\n        prices: Vec<(String, Decimal256)>, // (asset, price)\n    },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryMsg {\n    Config {},\n    Feeder {\n        asset: String,\n    },\n    Price {\n        base: String,\n        quote: String,\n    },\n    Prices {\n        start_after: Option<String>,\n        limit: Option<u32>,\n    },\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct ConfigResponse {\n    pub owner: String,\n    pub base_asset: String,\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct FeederResponse {\n    pub asset: String,\n    pub feeder: String,\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct PriceResponse {\n    pub rate: Decimal256,\n    pub last_updated_base: u64,\n    pub last_updated_quote: u64,\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct PricesResponseElem {\n    pub asset: String,\n    pub price: Decimal256,\n    pub last_updated_time: u64,\n}\n\n// We define a custom struct for each query response\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct PricesResponse {\n    pub prices: Vec<PricesResponseElem>,\n}\n\n\n",
        "CodeNames": [
            "oracle.rs"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "oracle.rs",
                "Type": "Disrupted Price Feeds",
                "Description": "The feed_prices function in the oracle contract can accept stale prices, which can disrupt price feeds and result in wrongful liquidation of user positions.",
                "Repair": "Change the implementation of feed_prices to check whether the price is stale or not. Consider implementing a mean shorting function that pulls multiple price feeds so that if one is stale it gets rejected."
            }
        ]
    },
    {
        "Code": "use crate::contract::{query_total_issued, slashing};\nuse crate::math::decimal_division;\nuse crate::state::{is_valid_validator, CONFIG, CURRENT_BATCH, PARAMETERS, STATE};\nuse basset::hub::State;\nuse cosmwasm_std::{\n    attr, to_binary, CosmosMsg, DepsMut, Env, MessageInfo, Response, StakingMsg, StdError,\n    StdResult, Uint128, WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\npub fn execute_bond(\n    mut deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    validator: String,\n) -> StdResult<Response> {\n    // validator must be whitelisted\n    let is_valid = is_valid_validator(deps.storage, validator.clone())?;\n    if !is_valid {\n        return Err(StdError::generic_err(\n            \"The chosen validator is currently not supported\",\n        ));\n    }\n\n    let params = PARAMETERS.load(deps.storage)?;\n    let coin_denom = params.underlying_coin_denom;\n    let threshold = params.er_threshold;\n    let recovery_fee = params.peg_recovery_fee;\n\n    // current batch requested fee is need for accurate exchange rate computation.\n    let current_batch = CURRENT_BATCH.load(deps.storage)?;\n    let requested_with_fee = current_batch.requested_with_fee;\n\n    // coin must have be sent along with transaction and it should be in underlying coin denom\n    if info.funds.len() > 1usize {\n        return Err(StdError::generic_err(\n            \"More than one coin is sent; only one asset is supported\",\n        ));\n    }\n\n    let payment = info\n        .funds\n        .iter()\n        .find(|x| x.denom == coin_denom && x.amount > Uint128::zero())\n        .ok_or_else(|| {\n            StdError::generic_err(format!(\"No {} assets are provided to bond\", coin_denom))\n        })?;\n\n    // check slashing\n    slashing(&mut deps, env)?;\n\n    let state = STATE.load(deps.storage)?;\n    let sender = info.sender;\n\n    // get the total supply\n    let mut total_supply = query_total_issued(deps.as_ref()).unwrap_or_default();\n\n    // peg recovery fee should be considered\n    let mint_amount = decimal_division(payment.amount, state.exchange_rate);\n    let mut mint_amount_with_fee = mint_amount;\n    if state.exchange_rate < threshold {\n        let max_peg_fee = mint_amount * recovery_fee;\n        let required_peg_fee = ((total_supply + mint_amount + current_batch.requested_with_fee)\n            .checked_sub(state.total_bond_amount + payment.amount))?;\n        let peg_fee = Uint128::min(max_peg_fee, required_peg_fee);\n        mint_amount_with_fee = (mint_amount.checked_sub(peg_fee))?;\n    }\n\n    // total supply should be updated for exchange rate calculation.\n    total_supply += mint_amount_with_fee;\n\n    // exchange rate should be updated for future\n    STATE.update(deps.storage, |mut prev_state| -> StdResult<State> {\n        prev_state.total_bond_amount += payment.amount;\n        prev_state.update_exchange_rate(total_supply, requested_with_fee);\n        Ok(prev_state)\n    })?;\n\n    let mut messages: Vec<CosmosMsg> = vec![\n        // send the delegate message\n        CosmosMsg::Staking(StakingMsg::Delegate {\n            validator,\n            amount: payment.clone(),\n        }),\n    ];\n\n    // issue the basset token for sender\n    let mint_msg = Cw20ExecuteMsg::Mint {\n        recipient: sender.to_string(),\n        amount: mint_amount_with_fee,\n    };\n\n    let config = CONFIG.load(deps.storage)?;\n    let token_address = deps\n        .api\n        .addr_humanize(\n            &config\n                .token_contract\n                .expect(\"the token contract must have been registered\"),\n        )?\n        .to_string();\n\n    messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: token_address,\n        msg: to_binary(&mint_msg)?,\n        funds: vec![],\n    }));\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"mint\"),\n        attr(\"from\", sender),\n        attr(\"bonded\", payment.amount),\n        attr(\"minted\", mint_amount_with_fee),\n    ]))\n}\n\n\n",
        "CodeNames": [
            "bond.rs"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "bond.rs",
                "Type": "Predictable Randomness",
                "Description": "The pick_validator function used for unbonding can be predicted, allowing a validator to steal rewards and increase their own.",
                "Repair": "Keep track of all bonds with a bond_id and create a map of bond_id - validator. If a validator's stake decreased due to slashing, take the remaining unstake amount proportionally from all other validators."
            }
        ]
    }
]