[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {CERC20} from \"./interfaces/CERC20.sol\";\nimport {Comptroller} from \"./interfaces/Comptroller.sol\";\n\nimport {TurboMaster} from \"./TurboMaster.sol\";\n\n/// @title Turbo Safe\n/// @author Transmissions11\n/// @notice Fuse liquidity accelerator.\ncontract TurboSafe is Auth, ERC4626, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The Master contract that created the Safe.\n    /// @dev Fees are paid directly to the Master, where they can be swept.\n    TurboMaster public immutable master;\n\n    /// @notice The Fei token on the network.\n    ERC20 public immutable fei;\n\n    /// @notice The Turbo Fuse Pool contract that collateral is held in and Fei is borrowed from.\n    Comptroller public immutable pool;\n\n    /// @notice The Fei cToken in the Turbo Fuse Pool that Fei is borrowed from.\n    CERC20 public immutable feiTurboCToken;\n\n    /// @notice The cToken that accepts the asset in the Turbo Fuse Pool.\n    CERC20 public immutable assetTurboCToken;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates a new Safe that accepts a specific asset.\n    /// @param _owner The owner of the Safe.\n    /// @param _authority The Authority of the Safe.\n    /// @param _asset The ERC20 compliant token the Safe should accept.\n    constructor(\n        address _owner,\n        Authority _authority,\n        ERC20 _asset\n    )\n        Auth(_owner, _authority)\n        ERC4626(\n            _asset,\n            // ex: Dai Stablecoin Turbo Safe\n            string(abi.encodePacked(_asset.name(), \" Turbo Safe\")),\n            // ex: tsDAI\n            string(abi.encodePacked(\"ts\", _asset.symbol()))\n        )\n    {\n        master = TurboMaster(msg.sender);\n\n        fei = master.fei();\n\n        // An asset of Fei makes no sense.\n        require(asset != fei, \"INVALID_ASSET\");\n\n        pool = master.pool();\n\n        feiTurboCToken = pool.cTokensByUnderlying(fei);\n\n        assetTurboCToken = pool.cTokensByUnderlying(asset);\n\n        // If the provided asset is not supported by the Turbo Fuse Pool, revert.\n        require(address(assetTurboCToken) != address(0), \"UNSUPPORTED_ASSET\");\n\n        // Construct an array of market(s) to enable as collateral.\n        CERC20[] memory marketsToEnter = new CERC20[](1);\n        marketsToEnter[0] = assetTurboCToken;\n\n        // Enter the market(s) and ensure to properly revert if there is an error.\n        require(pool.enterMarkets(marketsToEnter)[0] == 0, \"ENTER_MARKETS_FAILED\");\n\n        // Preemptively approve the asset to the Turbo Fuse Pool's corresponding cToken.\n        asset.safeApprove(address(assetTurboCToken), type(uint256).max);\n\n        // Preemptively approve Fei to the Turbo Fuse Pool's Fei cToken.\n        fei.safeApprove(address(feiTurboCToken), type(uint256).max);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SAFE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The current total amount of Fei the Safe is using to boost Vaults.\n    uint256 public totalFeiBoosted;\n\n    /// @notice Maps Vaults to the total amount of Fei they've being boosted with.\n    /// @dev Used to determine the fees to be paid back to the Master.\n    mapping(ERC4626 => uint256) public getTotalFeiBoostedForVault;\n\n    /*///////////////////////////////////////////////////////////////\n                               MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks the caller is authorized using either the Master's Authority or the Safe's local Authority.\n    modifier requiresLocalOrMasterAuth() {\n        // Check if the caller is the owner first:\n        if (msg.sender != owner) {\n            Authority masterAuth = master.authority(); // Saves a warm SLOAD, about 100 gas.\n\n            // If the Master's Authority does not exist or does not accept upfront:\n            if (address(masterAuth) == address(0) || !masterAuth.canCall(msg.sender, address(this), msg.sig)) {\n                Authority auth = authority; // Memoizing saves us a warm SLOAD, around 100 gas.\n\n                // The only authorization option left is via the local Authority, otherwise revert.\n                require(\n                    address(auth) != address(0) && auth.canCall(msg.sender, address(this), msg.sig),\n                    \"UNAUTHORIZED\"\n                );\n            }\n        }\n\n        _;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC4626 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Called after any type of deposit occurs.\n    /// @param assetAmount The amount of assets being deposited.\n    /// @dev Using requiresAuth here prevents unauthorized users from depositing.\n    function afterDeposit(uint256 assetAmount, uint256) internal override nonReentrant requiresAuth {\n        // Collateralize the assets in the Turbo Fuse Pool.\n        require(assetTurboCToken.mint(assetAmount) == 0, \"MINT_FAILED\");\n    }\n\n    /// @notice Called before any type of withdrawal occurs.\n    /// @param assetAmount The amount of assets being withdrawn.\n    /// @dev Using requiresAuth here prevents unauthorized users from withdrawing.\n    function beforeWithdraw(uint256 assetAmount, uint256) internal override nonReentrant requiresAuth {\n        // Withdraw the assets from the Turbo Fuse Pool.\n        require(assetTurboCToken.redeemUnderlying(assetAmount) == 0, \"REDEEM_FAILED\");\n    }\n\n    /// @notice Returns the total amount of assets held in the Safe.\n    /// @return The total amount of assets held in the Safe.\n    function totalAssets() public view override returns (uint256) {\n        return assetTurboCToken.balanceOf(address(this)).mulWadDown(assetTurboCToken.exchangeRateStored());\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           BOOST/LESS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a Vault is boosted by the Safe.\n    /// @param user The user who boosted the Vault.\n    /// @param vault The Vault that was boosted.\n    /// @param feiAmount The amount of Fei that was boosted to the Vault.\n    event VaultBoosted(address indexed user, ERC4626 indexed vault, uint256 feiAmount);\n\n    /// @notice Borrow Fei from the Turbo Fuse Pool and deposit it into an authorized Vault.\n    /// @param vault The Vault to deposit the borrowed Fei into.\n    /// @param feiAmount The amount of Fei to borrow and supply into the Vault.\n    /// @dev Automatically accrues any fees earned by the Safe in the Vault to the Master.\n    function boost(ERC4626 vault, uint256 feiAmount) external nonReentrant requiresAuth {\n        // Ensure the Vault accepts Fei asset.\n        require(vault.asset() == fei, \"NOT_FEI\");\n\n        // Call the Master where it will do extra validation\n        // and update it's total count of funds used for boosting.\n        master.onSafeBoost(asset, vault, feiAmount);\n\n        // Increase the boost total proportionately.\n        totalFeiBoosted += feiAmount;\n\n        unchecked {\n            // Update the total Fei deposited into the Vault proportionately.\n            // Cannot overflow because the total cannot be less than a single Vault.\n            getTotalFeiBoostedForVault[vault] += feiAmount;\n        }\n\n        emit VaultBoosted(msg.sender, vault, feiAmount);\n\n        // Borrow the Fei amount from the Fei cToken in the Turbo Fuse Pool.\n        require(feiTurboCToken.borrow(feiAmount) == 0, \"BORROW_FAILED\");\n\n        // Approve the borrowed Fei to the specified Vault.\n        fei.safeApprove(address(vault), feiAmount);\n\n        // Deposit the Fei into the specified Vault.\n        vault.deposit(feiAmount, address(this));\n    }\n\n    /// @notice Emitted when a Vault is withdrawn from by the Safe.\n    /// @param user The user who lessed the Vault.\n    /// @param vault The Vault that was withdrawn from.\n    /// @param feiAmount The amount of Fei that was withdrawn from the Vault.\n    event VaultLessened(address indexed user, ERC4626 indexed vault, uint256 feiAmount);\n\n    /// @notice Withdraw Fei from a deposited Vault and use it to repay debt in the Turbo Fuse Pool.\n    /// @param vault The Vault to withdraw the Fei from.\n    /// @param feiAmount The amount of Fei to withdraw from the Vault and repay in the Turbo Fuse Pool.\n    /// @dev Automatically accrues any fees earned by the Safe in the Vault to the Master.\n    function less(ERC4626 vault, uint256 feiAmount) external nonReentrant requiresLocalOrMasterAuth {\n        // Update the total Fei deposited into the Vault proportionately.\n        getTotalFeiBoostedForVault[vault] -= feiAmount;\n\n        unchecked {\n            // Decrease the boost total proportionately.\n            // Cannot underflow because the total cannot be less than a single Vault.\n            totalFeiBoosted -= feiAmount;\n        }\n\n        emit VaultLessened(msg.sender, vault, feiAmount);\n\n        // Withdraw the specified amount of Fei from the Vault.\n        vault.withdraw(feiAmount, address(this), address(this));\n\n        // Get out current amount of Fei debt in the Turbo Fuse Pool.\n        uint256 feiDebt = feiTurboCToken.borrowBalanceCurrent(address(this));\n\n        // If our debt balance decreased, repay the minimum.\n        // The surplus Fei will accrue as fees and can be sweeped.\n        if (feiAmount > feiDebt) feiAmount = feiDebt;\n\n        // Repay Fei debt in the Turbo Fuse Pool, unless we would repay nothing.\n        if (feiAmount != 0) require(feiTurboCToken.repayBorrow(feiAmount) == 0, \"REPAY_FAILED\");\n\n        // Call the Master to allow it to update its accounting.\n        master.onSafeLess(asset, vault, feiAmount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              SLURP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a Vault is slurped from by the Safe.\n    /// @param user The user who slurped the Vault.\n    /// @param vault The Vault that was slurped.\n    /// @param protocolFeeAmount The amount of Fei accrued as fees to the Master.\n    /// @param safeInterestAmount The amount of Fei accrued as interest to the Safe.\n    event VaultSlurped(\n        address indexed user,\n        ERC4626 indexed vault,\n        uint256 protocolFeeAmount,\n        uint256 safeInterestAmount\n    );\n\n    /// @notice Accrue any interest earned by the Safe in the Vault.\n    /// @param vault The Vault to accrue interest from, if any.\n    /// @dev Sends a portion of the interest to the Master, as determined by the Clerk.\n    function slurp(ERC4626 vault) external nonReentrant requiresLocalOrMasterAuth {\n        // Ensure the Safe has Fei currently boosting the Vault.\n        require(getTotalFeiBoostedForVault[vault] != 0, \"NO_FEI_BOOSTED\");\n\n        // Compute the amount of Fei interest the Safe generated by boosting the Vault.\n        uint256 interestEarned = vault.assetsOf(address(this)) - getTotalFeiBoostedForVault[vault];\n\n        // Compute what percentage of the interest earned will go back to the Safe.\n        uint256 protocolFeePercent = master.clerk().getFeePercentageForSafe(this, asset);\n\n        // Compute the amount of Fei the protocol will retain as fees.\n        uint256 protocolFeeAmount = interestEarned.mulWadDown(protocolFeePercent);\n\n        // Compute the amount of Fei the Safe will retain as interest.\n        uint256 safeInterestAmount = interestEarned - protocolFeeAmount;\n\n        // Increase the boost total proportionately.\n        totalFeiBoosted += safeInterestAmount;\n\n        unchecked {\n            // Update the total Fei held in the Vault proportionately.\n            // Cannot overflow because the total cannot be less than a single Vault.\n            getTotalFeiBoostedForVault[vault] += safeInterestAmount;\n        }\n\n        emit VaultSlurped(msg.sender, vault, protocolFeeAmount, safeInterestAmount);\n\n        // If we have unaccrued fees, withdraw them from the Vault and transfer them to the Master.\n        if (protocolFeeAmount != 0) vault.withdraw(protocolFeeAmount, address(master), address(this));\n\n        // Call the Master to allow it to update its accounting.\n        master.onSafeSlurp(asset, vault, safeInterestAmount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              SWEEP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted a token is sweeped from the Safe.\n    /// @param user The user who sweeped the token from the Safe.\n    /// @param to The recipient of the sweeped tokens.\n    /// @param amount The amount of the token that was sweeped.\n    event TokenSweeped(address indexed user, address indexed to, ERC20 indexed token, uint256 amount);\n\n    /// @notice Claim tokens sitting idly in the Safe.\n    /// @param to The recipient of the sweeped tokens.\n    /// @param token The token to sweep and send.\n    /// @param amount The amount of the token to sweep.\n    function sweep(\n        address to,\n        ERC20 token,\n        uint256 amount\n    ) external nonReentrant requiresAuth {\n        // Ensure the caller is not trying to steal Vault shares or collateral cTokens.\n        require(getTotalFeiBoostedForVault[ERC4626(address(token))] == 0 && token != assetTurboCToken, \"INVALID_TOKEN\");\n\n        emit TokenSweeped(msg.sender, to, token, amount);\n\n        // Transfer the sweeped tokens to the recipient.\n        token.safeTransfer(to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               GIB LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a Safe is gibbed.\n    /// @param user The user who gibbed the Safe.\n    /// @param to The recipient of the impounded collateral.\n    /// @param assetAmount The amount of underling tokens impounded.\n    event SafeGibbed(address indexed user, address indexed to, uint256 assetAmount);\n\n    /// @notice Impound a specific amount of a Safe's collateral.\n    /// @param to The address to send the impounded collateral to.\n    /// @param assetAmount The amount of the asset to impound.\n    /// @dev Can only be called by the Gibber, not by the Safe owner.\n    /// @dev Debt must be repaid in advance, or the redemption will fail.\n    function gib(address to, uint256 assetAmount) external nonReentrant requiresLocalOrMasterAuth {\n        emit SafeGibbed(msg.sender, to, assetAmount);\n\n        // Withdraw the specified amount of assets from the Turbo Fuse Pool.\n        require(assetTurboCToken.redeemUnderlying(assetAmount) == 0, \"REDEEM_FAILED\");\n\n        // Transfer the assets to the authorized caller.\n        asset.safeTransfer(to, assetAmount);\n    }\n}\n\n\n",
        "CodeNames": [
            "TurboSafe.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TurboSafe.sol#L335",
                "Type": "Unauthorized fund transfer",
                "Description": "Gibber can take any amount from safes.",
                "Repair": "Limit gib to certain collateral ratio"
            },
            {
                "Location": "TurboSafe.sol#L225-L236",
                "Type": "Incorrect implementation",
                "Description": "Wrong implementation of TurboSafe.sol#less() may cause boosted record value in TurboMaster bigger than actual lead to BoostCapForVault and BoostCapForCollateral to be permanently occupied.",
                "Repair": "Update the total Fei deposited into the Vault proportionately"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ERC4626.deposit/mint function",
                "Type": "Incompatibility with fee-on-transfer tokens",
                "Description": "ERC4626 does not work with fee-on-transfer tokens.",
                "Repair": "Use the mixin with ERC20 Standard Tokens"
            },
            {
                "Location": "TurboRouter: deposit(), mint(), createSafeAndDeposit(), and createSafeAndDepositAndBoost() functions",
                "Type": "Functionality Failure",
                "Description": "The deposit and mint functions of the ERC4626RouterBase contract will call the deposit and mint functions of the TurboSafe contract. The TurboSafe contract inherits from the ERC4626 contract, that is, the deposit and mint functions of the ERC4626 contract will be called. The deposit and mint functions of the ERC4626 contract will call the safeTransferFrom function. Since the caller is the TurboRouter contract, msg.sender will be the TurboRouter contract. And because the user calls the deposit, mint, createSafeAndDeposit, and createSafeAndDepositAndBoost functions of the TurboRouter contract without transferring tokens to the TurboRouter contract and approving the TurboSafe contract to use the tokens, the call will fail.",
                "Repair": "Add code for the user to transfer tokens and approve the use of tokens in the TurboSafe contract in the deposit, mint, createSafeAndDeposit, and createSafeAndDepositAndBoost functions of the TurboRouter contract"
            },
            {
                "Location": "ERC4626 mint function",
                "Type": "Incorrect parameter usage",
                "Description": "The mint function mints 'amount' instead of 'shares', which can lead to issues when the asset < shares are not 1-to-1 as will be the case for most vaults over time.",
                "Repair": "Change the parameter used in the mint function from 'amount' to 'shares'"
            },
            {
                "Location": "ERC4626RouterBase.withdraw function",
                "Type": "Lack of max shares out check",
                "Description": "The user can lose their entire shares due to the wrong check in the withdraw function, which only checks that the burned shares are not less than a 'minSharesOut' amount.",
                "Repair": "Add a 'maxSharesIn' parameter to the withdraw function and check that the burned shares are not greater than this value"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {DSTestPlus} from \"solmate/test/utils/DSTestPlus.sol\";\nimport {MockERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport {MockERC4626} from \"solmate/test/utils/mocks/MockERC4626.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {MockCToken} from \"./mocks/MockCToken.sol\";\nimport {MockPriceFeed} from \"./mocks/MockPriceFeed.sol\";\nimport {MockFuseAdmin} from \"./mocks/MockFuseAdmin.sol\";\nimport {MockComptroller} from \"./mocks/MockComptroller.sol\";\n\nimport {TurboClerk} from \"../modules/TurboClerk.sol\";\nimport {TurboBooster} from \"../modules/TurboBooster.sol\";\n\nimport {TurboSafe} from \"../TurboSafe.sol\";\nimport {TurboMaster} from \"../TurboMaster.sol\";\n\ncontract TurboSafeTest is DSTestPlus {\n    using FixedPointMathLib for uint256;\n\n    TurboMaster master;\n\n    TurboClerk clerk;\n\n    TurboBooster booster;\n\n    MockFuseAdmin fuseAdmin;\n\n    MockComptroller comptroller;\n\n    MockERC20 fei;\n\n    MockERC20 asset;\n\n    MockCToken assetCToken;\n\n    MockCToken feiCToken;\n\n    MockERC4626 vault;\n\n    TurboSafe safe;\n\n    function setUp() public {\n        fei = new MockERC20(\"Fei USD\", \"FEI\", 18);\n\n        asset = new MockERC20(\"Mock Token\", \"MOCK\", 18);\n\n        fuseAdmin = new MockFuseAdmin();\n\n        booster = new TurboBooster(address(this), Authority(address(0)));\n\n        clerk = new TurboClerk(address(this), Authority(address(0)));\n\n        comptroller = new MockComptroller(address(fuseAdmin), new MockPriceFeed());\n\n        master = new TurboMaster(comptroller, fei, address(this), Authority(address(0)));\n\n        assetCToken = new MockCToken(asset);\n\n        comptroller.mapUnderlyingToCToken(asset, assetCToken);\n\n        feiCToken = new MockCToken(fei);\n\n        comptroller.mapUnderlyingToCToken(fei, feiCToken);\n\n        vault = new MockERC4626(fei, \"Mock Fei Vault\", \"mvFEI\");\n\n        master.setBooster(booster);\n\n        master.setClerk(clerk);\n\n        (safe, ) = master.createSafe(asset);\n\n        asset.mint(address(this), type(uint256).max);\n        asset.approve(address(safe), type(uint256).max);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                      DEPOSIT/WITHDRAWAL TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    function testDeposit(uint128 amount, address to) public {\n        if (amount == 0) amount = 1;\n\n        safe.deposit(amount, to);\n\n        assertEq(safe.balanceOf(to), amount);\n        assertEq(safe.assetsOf(to), amount);\n        assertEq(assetCToken.balanceOfUnderlying(address(safe)), amount);\n        assertEq(safe.totalAssets(), amount);\n    }\n\n    function testDepositRedeem(uint128 amount, address to) public {\n        if (amount == 0) amount = 1;\n\n        uint256 toBalance = asset.balanceOf(to);\n\n        safe.deposit(amount, address(this));\n        safe.redeem(amount, to, address(this));\n\n        assertEq(safe.totalAssets(), 0);\n        assertEq(safe.balanceOf(to), 0);\n        assertEq(asset.balanceOf(to), to == address(this) ? toBalance : toBalance + amount);\n        assertEq(assetCToken.balanceOfUnderlying(address(safe)), 0);\n    }\n\n    function testDepositWithdraw(uint128 amount, address to) public {\n        if (amount == 0) amount = 1;\n\n        uint256 toBalance = asset.balanceOf(to);\n\n        safe.deposit(amount, address(this));\n        safe.withdraw(amount, to, address(this));\n\n        assertEq(safe.totalAssets(), 0);\n        assertEq(safe.balanceOf(to), 0);\n        assertEq(asset.balanceOf(to), to == address(this) ? toBalance : toBalance + amount);\n        assertEq(assetCToken.balanceOfUnderlying(address(safe)), 0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             BOOST TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    function testFailBoostNotEnoughCollateral(\n        uint128 underlyingAmount,\n        uint128 feiMintAmount,\n        uint128 feiAmount,\n        address to\n    ) public {\n        feiAmount = uint128(bound(feiAmount, feiMintAmount + 1, type(uint128).max));\n\n        safe.deposit(underlyingAmount, to);\n\n        fei.mint(address(feiCToken), feiMintAmount);\n\n        booster.setBoostCapForVault(vault, feiAmount);\n        booster.setBoostCapForCollateral(asset, feiAmount);\n\n        safe.boost(vault, feiAmount);\n    }\n\n    function testFailBoostVaultCapTooLow(\n        uint128 underlyingAmount,\n        uint128 feiMintAmount,\n        uint128 feiAmount,\n        address to\n    ) public {\n        feiAmount = uint128(bound(feiAmount, 0, feiMintAmount));\n\n        safe.deposit(underlyingAmount, to);\n\n        fei.mint(address(feiCToken), feiMintAmount);\n\n        booster.setBoostCapForVault(vault, bound(feiAmount, 0, feiAmount - 1));\n        booster.setBoostCapForCollateral(asset, feiAmount);\n\n        safe.boost(vault, feiAmount);\n    }\n\n    function testFailBoostCollateralCapTooLow(\n        uint128 underlyingAmount,\n        uint128 feiMintAmount,\n        uint128 feiAmount,\n        address to\n    ) public {\n        feiAmount = uint128(bound(feiAmount, 0, feiMintAmount));\n\n        safe.deposit(underlyingAmount, to);\n\n        fei.mint(address(feiCToken), feiMintAmount);\n\n        booster.setBoostCapForVault(vault, feiAmount);\n        booster.setBoostCapForCollateral(asset, bound(feiAmount, 0, feiAmount - 1));\n\n        safe.boost(vault, feiAmount);\n    }\n\n    function testFailBoostFrozen(\n        uint128 underlyingAmount,\n        uint128 feiMintAmount,\n        uint128 feiAmount,\n        address to\n    ) public {\n        feiAmount = uint128(bound(feiAmount, 0, feiMintAmount));\n\n        safe.deposit(underlyingAmount, to);\n\n        fei.mint(address(feiCToken), feiMintAmount);\n\n        booster.setBoostCapForVault(vault, feiAmount);\n        booster.setBoostCapForCollateral(asset, feiAmount);\n\n        booster.setFreezeStatus(true);\n\n        safe.boost(vault, feiAmount);\n    }\n\n    function testFailInvalidVault(\n        uint128 underlyingAmount,\n        uint128 feiMintAmount,\n        uint128 feiAmount,\n        address to,\n        ERC4626 invalidVault\n    ) public {\n        feiAmount = uint128(bound(feiAmount, 0, feiMintAmount));\n\n        safe.deposit(underlyingAmount, to);\n\n        fei.mint(address(feiCToken), feiMintAmount);\n\n        booster.setBoostCapForVault(invalidVault, feiAmount);\n        booster.setBoostCapForCollateral(invalidVault, feiAmount);\n\n        safe.boost(invalidVault, feiAmount);\n    }\n\n    function testFailWrongAssetVault(\n        uint128 underlyingAmount,\n        uint128 feiMintAmount,\n        uint128 feiAmount,\n        address to\n    ) public {\n        feiAmount = uint128(bound(feiAmount, 0, feiMintAmount));\n\n        safe.deposit(underlyingAmount, to);\n\n        fei.mint(address(feiCToken), feiMintAmount);\n\n        MockERC4626 wrongAssetVault = new MockERC4626(asset, \"Wrong Asset Vault\", \"WAV\");\n\n        booster.setBoostCapForVault(wrongAssetVault, feiAmount);\n        booster.setBoostCapForCollateral(wrongAssetVault, feiAmount);\n\n        safe.boost(wrongAssetVault, feiAmount);\n    }\n\n    function testBoost(\n        uint128 underlyingAmount,\n        uint128 feiMintAmount,\n        uint128 feiAmount,\n        address to\n    ) public {\n        if (underlyingAmount == 0) underlyingAmount = 1;\n        if (feiMintAmount == 0) feiMintAmount = 1;\n\n        feiAmount = uint128(bound(feiAmount, 1, feiMintAmount));\n\n        safe.deposit(underlyingAmount, to);\n\n        fei.mint(address(feiCToken), feiMintAmount);\n\n        booster.setBoostCapForVault(vault, feiAmount);\n        booster.setBoostCapForCollateral(asset, feiAmount);\n\n        safe.boost(vault, feiAmount);\n\n        assertEq(safe.totalFeiBoosted(), feiAmount);\n        assertEq(safe.getTotalFeiBoostedForVault(vault), feiAmount);\n        assertEq(vault.assetsOf(address(safe)), feiAmount);\n        assertEq(vault.totalAssets(), feiAmount);\n        assertEq(feiCToken.borrowBalanceCurrent(address(safe)), feiAmount);\n\n        assertEq(master.totalBoosted(), feiAmount);\n        assertEq(master.getTotalBoostedForVault(vault), feiAmount);\n        assertEq(master.getTotalBoostedAgainstCollateral(asset), feiAmount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             LESS TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    function testBoostAndLess(\n        uint128 boostAmount,\n        uint128 lessAmount,\n        address to\n    ) public {\n        if (boostAmount == 0) boostAmount = 1;\n        if (lessAmount == 0) lessAmount = 1;\n\n        lessAmount = uint128(bound(lessAmount, 0, boostAmount));\n\n        safe.deposit(boostAmount, to);\n\n        fei.mint(address(feiCToken), boostAmount);\n\n        booster.setBoostCapForVault(vault, boostAmount);\n        booster.setBoostCapForCollateral(asset, boostAmount);\n\n        safe.boost(vault, boostAmount);\n\n        safe.less(vault, lessAmount);\n\n        uint256 delta = boostAmount - lessAmount;\n\n        assertEq(safe.totalFeiBoosted(), delta);\n        assertEq(safe.getTotalFeiBoostedForVault(vault), delta);\n        assertEq(vault.assetsOf(address(safe)), delta);\n        assertEq(vault.totalAssets(), delta);\n        assertEq(feiCToken.borrowBalanceCurrent(address(safe)), delta);\n\n        assertEq(master.totalBoosted(), delta);\n        assertEq(master.getTotalBoostedForVault(vault), delta);\n        assertEq(master.getTotalBoostedAgainstCollateral(asset), delta);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             SLURP TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    function testFailSlurpUntrustedVault(ERC4626 untrustedVault) public {\n        if (untrustedVault == vault) revert();\n\n        safe.slurp(untrustedVault);\n    }\n\n    function testSlurp(\n        uint64 boostAmount,\n        uint64 donationAmount,\n        uint256 feePercentage,\n        address to\n    ) public {\n        if (boostAmount == 0) boostAmount = 1;\n\n        feePercentage = bound(feePercentage, 0, 1e18);\n\n        safe.deposit(boostAmount, to);\n\n        fei.mint(address(feiCToken), boostAmount);\n\n        booster.setBoostCapForVault(vault, boostAmount);\n        booster.setBoostCapForCollateral(asset, boostAmount);\n\n        safe.boost(vault, boostAmount);\n\n        fei.mint(address(vault), donationAmount);\n\n        clerk.setDefaultFeePercentage(feePercentage);\n\n        safe.slurp(vault);\n\n        uint256 protocolFeeAmount = uint256(donationAmount).mulWadDown(feePercentage);\n\n        uint256 safeInterestAmount = donationAmount - protocolFeeAmount;\n\n        uint256 delta = boostAmount + safeInterestAmount;\n\n        assertEq(safe.totalFeiBoosted(), delta);\n        assertEq(safe.getTotalFeiBoostedForVault(vault), delta);\n        assertEq(vault.assetsOf(address(safe)), delta);\n        assertEq(vault.totalAssets(), delta);\n        assertEq(feiCToken.borrowBalanceCurrent(address(safe)), boostAmount);\n\n        assertEq(master.totalBoosted(), delta);\n        assertEq(master.getTotalBoostedForVault(vault), delta);\n        assertEq(master.getTotalBoostedAgainstCollateral(asset), delta);\n\n        assertEq(fei.balanceOf(address(master)), protocolFeeAmount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             SWEEP TESTS\n    //////////////////////////////////////////////////////////////*/\n\n    function testFailSweepVaultShares(address to, uint256 amount) public {\n        safe.sweep(to, vault, amount);\n    }\n\n    function testFailSweepAssetCToken(address to, uint256 amount) public {\n        safe.sweep(to, assetCToken, amount);\n    }\n\n    function testSweep(uint256 amount, address to) public {\n        fei.mint(address(safe), amount);\n\n        safe.sweep(to, fei, amount);\n\n        assertEq(fei.balanceOf(to), amount);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.10;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {CERC20} from \"./interfaces/CERC20.sol\";\nimport {Comptroller} from \"./interfaces/Comptroller.sol\";\n\nimport {TurboMaster} from \"./TurboMaster.sol\";\n\n/// @title Turbo Safe\n/// @author Transmissions11\n/// @notice Fuse liquidity accelerator.\ncontract TurboSafe is Auth, ERC4626, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The Master contract that created the Safe.\n    /// @dev Fees are paid directly to the Master, where they can be swept.\n    TurboMaster public immutable master;\n\n    /// @notice The Fei token on the network.\n    ERC20 public immutable fei;\n\n    /// @notice The Turbo Fuse Pool contract that collateral is held in and Fei is borrowed from.\n    Comptroller public immutable pool;\n\n    /// @notice The Fei cToken in the Turbo Fuse Pool that Fei is borrowed from.\n    CERC20 public immutable feiTurboCToken;\n\n    /// @notice The cToken that accepts the asset in the Turbo Fuse Pool.\n    CERC20 public immutable assetTurboCToken;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates a new Safe that accepts a specific asset.\n    /// @param _owner The owner of the Safe.\n    /// @param _authority The Authority of the Safe.\n    /// @param _asset The ERC20 compliant token the Safe should accept.\n    constructor(\n        address _owner,\n        Authority _authority,\n        ERC20 _asset\n    )\n        Auth(_owner, _authority)\n        ERC4626(\n            _asset,\n            // ex: Dai Stablecoin Turbo Safe\n            string(abi.encodePacked(_asset.name(), \" Turbo Safe\")),\n            // ex: tsDAI\n            string(abi.encodePacked(\"ts\", _asset.symbol()))\n        )\n    {\n        master = TurboMaster(msg.sender);\n\n        fei = master.fei();\n\n        // An asset of Fei makes no sense.\n        require(asset != fei, \"INVALID_ASSET\");\n\n        pool = master.pool();\n\n        feiTurboCToken = pool.cTokensByUnderlying(fei);\n\n        assetTurboCToken = pool.cTokensByUnderlying(asset);\n\n        // If the provided asset is not supported by the Turbo Fuse Pool, revert.\n        require(address(assetTurboCToken) != address(0), \"UNSUPPORTED_ASSET\");\n\n        // Construct an array of market(s) to enable as collateral.\n        CERC20[] memory marketsToEnter = new CERC20[](1);\n        marketsToEnter[0] = assetTurboCToken;\n\n        // Enter the market(s) and ensure to properly revert if there is an error.\n        require(pool.enterMarkets(marketsToEnter)[0] == 0, \"ENTER_MARKETS_FAILED\");\n\n        // Preemptively approve the asset to the Turbo Fuse Pool's corresponding cToken.\n        asset.safeApprove(address(assetTurboCToken), type(uint256).max);\n\n        // Preemptively approve Fei to the Turbo Fuse Pool's Fei cToken.\n        fei.safeApprove(address(feiTurboCToken), type(uint256).max);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SAFE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The current total amount of Fei the Safe is using to boost Vaults.\n    uint256 public totalFeiBoosted;\n\n    /// @notice Maps Vaults to the total amount of Fei they've being boosted with.\n    /// @dev Used to determine the fees to be paid back to the Master.\n    mapping(ERC4626 => uint256) public getTotalFeiBoostedForVault;\n\n    /*///////////////////////////////////////////////////////////////\n                               MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Checks the caller is authorized using either the Master's Authority or the Safe's local Authority.\n    modifier requiresLocalOrMasterAuth() {\n        // Check if the caller is the owner first:\n        if (msg.sender != owner) {\n            Authority masterAuth = master.authority(); // Saves a warm SLOAD, about 100 gas.\n\n            // If the Master's Authority does not exist or does not accept upfront:\n            if (address(masterAuth) == address(0) || !masterAuth.canCall(msg.sender, address(this), msg.sig)) {\n                Authority auth = authority; // Memoizing saves us a warm SLOAD, around 100 gas.\n\n                // The only authorization option left is via the local Authority, otherwise revert.\n                require(\n                    address(auth) != address(0) && auth.canCall(msg.sender, address(this), msg.sig),\n                    \"UNAUTHORIZED\"\n                );\n            }\n        }\n\n        _;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC4626 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Called after any type of deposit occurs.\n    /// @param assetAmount The amount of assets being deposited.\n    /// @dev Using requiresAuth here prevents unauthorized users from depositing.\n    function afterDeposit(uint256 assetAmount, uint256) internal override nonReentrant requiresAuth {\n        // Collateralize the assets in the Turbo Fuse Pool.\n        require(assetTurboCToken.mint(assetAmount) == 0, \"MINT_FAILED\");\n    }\n\n    /// @notice Called before any type of withdrawal occurs.\n    /// @param assetAmount The amount of assets being withdrawn.\n    /// @dev Using requiresAuth here prevents unauthorized users from withdrawing.\n    function beforeWithdraw(uint256 assetAmount, uint256) internal override nonReentrant requiresAuth {\n        // Withdraw the assets from the Turbo Fuse Pool.\n        require(assetTurboCToken.redeemUnderlying(assetAmount) == 0, \"REDEEM_FAILED\");\n    }\n\n    /// @notice Returns the total amount of assets held in the Safe.\n    /// @return The total amount of assets held in the Safe.\n    function totalAssets() public view override returns (uint256) {\n        return assetTurboCToken.balanceOf(address(this)).mulWadDown(assetTurboCToken.exchangeRateStored());\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           BOOST/LESS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a Vault is boosted by the Safe.\n    /// @param user The user who boosted the Vault.\n    /// @param vault The Vault that was boosted.\n    /// @param feiAmount The amount of Fei that was boosted to the Vault.\n    event VaultBoosted(address indexed user, ERC4626 indexed vault, uint256 feiAmount);\n\n    /// @notice Borrow Fei from the Turbo Fuse Pool and deposit it into an authorized Vault.\n    /// @param vault The Vault to deposit the borrowed Fei into.\n    /// @param feiAmount The amount of Fei to borrow and supply into the Vault.\n    /// @dev Automatically accrues any fees earned by the Safe in the Vault to the Master.\n    function boost(ERC4626 vault, uint256 feiAmount) external nonReentrant requiresAuth {\n        // Ensure the Vault accepts Fei asset.\n        require(vault.asset() == fei, \"NOT_FEI\");\n\n        // Call the Master where it will do extra validation\n        // and update it's total count of funds used for boosting.\n        master.onSafeBoost(asset, vault, feiAmount);\n\n        // Increase the boost total proportionately.\n        totalFeiBoosted += feiAmount;\n\n        unchecked {\n            // Update the total Fei deposited into the Vault proportionately.\n            // Cannot overflow because the total cannot be less than a single Vault.\n            getTotalFeiBoostedForVault[vault] += feiAmount;\n        }\n\n        emit VaultBoosted(msg.sender, vault, feiAmount);\n\n        // Borrow the Fei amount from the Fei cToken in the Turbo Fuse Pool.\n        require(feiTurboCToken.borrow(feiAmount) == 0, \"BORROW_FAILED\");\n\n        // Approve the borrowed Fei to the specified Vault.\n        fei.safeApprove(address(vault), feiAmount);\n\n        // Deposit the Fei into the specified Vault.\n        vault.deposit(feiAmount, address(this));\n    }\n\n    /// @notice Emitted when a Vault is withdrawn from by the Safe.\n    /// @param user The user who lessed the Vault.\n    /// @param vault The Vault that was withdrawn from.\n    /// @param feiAmount The amount of Fei that was withdrawn from the Vault.\n    event VaultLessened(address indexed user, ERC4626 indexed vault, uint256 feiAmount);\n\n    /// @notice Withdraw Fei from a deposited Vault and use it to repay debt in the Turbo Fuse Pool.\n    /// @param vault The Vault to withdraw the Fei from.\n    /// @param feiAmount The amount of Fei to withdraw from the Vault and repay in the Turbo Fuse Pool.\n    /// @dev Automatically accrues any fees earned by the Safe in the Vault to the Master.\n    function less(ERC4626 vault, uint256 feiAmount) external nonReentrant requiresLocalOrMasterAuth {\n        // Update the total Fei deposited into the Vault proportionately.\n        getTotalFeiBoostedForVault[vault] -= feiAmount;\n\n        unchecked {\n            // Decrease the boost total proportionately.\n            // Cannot underflow because the total cannot be less than a single Vault.\n            totalFeiBoosted -= feiAmount;\n        }\n\n        emit VaultLessened(msg.sender, vault, feiAmount);\n\n        // Withdraw the specified amount of Fei from the Vault.\n        vault.withdraw(feiAmount, address(this), address(this));\n\n        // Get out current amount of Fei debt in the Turbo Fuse Pool.\n        uint256 feiDebt = feiTurboCToken.borrowBalanceCurrent(address(this));\n\n        // If our debt balance decreased, repay the minimum.\n        // The surplus Fei will accrue as fees and can be sweeped.\n        if (feiAmount > feiDebt) feiAmount = feiDebt;\n\n        // Repay Fei debt in the Turbo Fuse Pool, unless we would repay nothing.\n        if (feiAmount != 0) require(feiTurboCToken.repayBorrow(feiAmount) == 0, \"REPAY_FAILED\");\n\n        // Call the Master to allow it to update its accounting.\n        master.onSafeLess(asset, vault, feiAmount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              SLURP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a Vault is slurped from by the Safe.\n    /// @param user The user who slurped the Vault.\n    /// @param vault The Vault that was slurped.\n    /// @param protocolFeeAmount The amount of Fei accrued as fees to the Master.\n    /// @param safeInterestAmount The amount of Fei accrued as interest to the Safe.\n    event VaultSlurped(\n        address indexed user,\n        ERC4626 indexed vault,\n        uint256 protocolFeeAmount,\n        uint256 safeInterestAmount\n    );\n\n    /// @notice Accrue any interest earned by the Safe in the Vault.\n    /// @param vault The Vault to accrue interest from, if any.\n    /// @dev Sends a portion of the interest to the Master, as determined by the Clerk.\n    function slurp(ERC4626 vault) external nonReentrant requiresLocalOrMasterAuth {\n        // Ensure the Safe has Fei currently boosting the Vault.\n        require(getTotalFeiBoostedForVault[vault] != 0, \"NO_FEI_BOOSTED\");\n\n        // Compute the amount of Fei interest the Safe generated by boosting the Vault.\n        uint256 interestEarned = vault.assetsOf(address(this)) - getTotalFeiBoostedForVault[vault];\n\n        // Compute what percentage of the interest earned will go back to the Safe.\n        uint256 protocolFeePercent = master.clerk().getFeePercentageForSafe(this, asset);\n\n        // Compute the amount of Fei the protocol will retain as fees.\n        uint256 protocolFeeAmount = interestEarned.mulWadDown(protocolFeePercent);\n\n        // Compute the amount of Fei the Safe will retain as interest.\n        uint256 safeInterestAmount = interestEarned - protocolFeeAmount;\n\n        // Increase the boost total proportionately.\n        totalFeiBoosted += safeInterestAmount;\n\n        unchecked {\n            // Update the total Fei held in the Vault proportionately.\n            // Cannot overflow because the total cannot be less than a single Vault.\n            getTotalFeiBoostedForVault[vault] += safeInterestAmount;\n        }\n\n        emit VaultSlurped(msg.sender, vault, protocolFeeAmount, safeInterestAmount);\n\n        // If we have unaccrued fees, withdraw them from the Vault and transfer them to the Master.\n        if (protocolFeeAmount != 0) vault.withdraw(protocolFeeAmount, address(master), address(this));\n\n        // Call the Master to allow it to update its accounting.\n        master.onSafeSlurp(asset, vault, safeInterestAmount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              SWEEP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted a token is sweeped from the Safe.\n    /// @param user The user who sweeped the token from the Safe.\n    /// @param to The recipient of the sweeped tokens.\n    /// @param amount The amount of the token that was sweeped.\n    event TokenSweeped(address indexed user, address indexed to, ERC20 indexed token, uint256 amount);\n\n    /// @notice Claim tokens sitting idly in the Safe.\n    /// @param to The recipient of the sweeped tokens.\n    /// @param token The token to sweep and send.\n    /// @param amount The amount of the token to sweep.\n    function sweep(\n        address to,\n        ERC20 token,\n        uint256 amount\n    ) external nonReentrant requiresAuth {\n        // Ensure the caller is not trying to steal Vault shares or collateral cTokens.\n        require(getTotalFeiBoostedForVault[ERC4626(address(token))] == 0 && token != assetTurboCToken, \"INVALID_TOKEN\");\n\n        emit TokenSweeped(msg.sender, to, token, amount);\n\n        // Transfer the sweeped tokens to the recipient.\n        token.safeTransfer(to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               GIB LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a Safe is gibbed.\n    /// @param user The user who gibbed the Safe.\n    /// @param to The recipient of the impounded collateral.\n    /// @param assetAmount The amount of underling tokens impounded.\n    event SafeGibbed(address indexed user, address indexed to, uint256 assetAmount);\n\n    /// @notice Impound a specific amount of a Safe's collateral.\n    /// @param to The address to send the impounded collateral to.\n    /// @param assetAmount The amount of the asset to impound.\n    /// @dev Can only be called by the Gibber, not by the Safe owner.\n    /// @dev Debt must be repaid in advance, or the redemption will fail.\n    function gib(address to, uint256 assetAmount) external nonReentrant requiresLocalOrMasterAuth {\n        emit SafeGibbed(msg.sender, to, assetAmount);\n\n        // Withdraw the specified amount of assets from the Turbo Fuse Pool.\n        require(assetTurboCToken.redeemUnderlying(assetAmount) == 0, \"REDEEM_FAILED\");\n\n        // Transfer the assets to the authorized caller.\n        asset.safeTransfer(to, assetAmount);\n    }\n}\n\n\n",
        "CodeNames": [
            "TurboSafe.t.sol",
            "TurboSafe.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TurboSafe.slurp function",
                "Type": "Frontrunning",
                "Description": "The TurboSafe.slurp function fetches the current fee from the clerk().This fee can be changed.The slurp transaction can be frontrun with a fee increase (specifically targeted for the vault or the asset) by the clerk and steal the vault yield that should go to the user.",
                "Repair": "Add a MAX_FEE hardcoded variable to ensure fees can never go above a certain threshold and publicly disclose the potential risk to protocol users"
            }
        ]
    }
]