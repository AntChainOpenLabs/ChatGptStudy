[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Compounding.sol';\n\ncontract VaultTracker {\n  /// @notice A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  struct Vault {\n    uint256 notional;\n    uint256 redeemable;\n    uint256 exchangeRate;\n  }\n\n  mapping(address => Vault) public vaults;\n\n  address public immutable admin;\n  address public immutable cTokenAddr;\n  address public immutable swivel;\n  uint256 public immutable maturity;\n  uint256 public maturityRate;\n  uint8 public immutable protocol;\n\n  /// @param m Maturity timestamp associated with this vault\n  /// @param c Compounding Token address associated with this vault\n  /// @param s Address of the deployed swivel contract\n  constructor(uint8 p, uint256 m, address c, address s) {\n    admin = msg.sender;\n    protocol = p;\n    maturity = m;\n    cTokenAddr = c;\n    swivel = s;\n\n    // instantiate swivel's vault (unblocking transferNotionalFee)\n    vaults[s] = Vault({\n      notional: 0,\n      redeemable: 0,\n      exchangeRate: Compounding.exchangeRate(p, c)\n    });\n  }\n\n  /// @notice Adds notional to a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional added\n  function addNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    Vault memory vlt = vaults[o];\n\n    if (vlt.notional > 0) {\n      uint256 yield;\n\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { // Calculate marginal interest\n        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n      }\n\n      uint256 interest = (yield * vlt.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      vlt.redeemable += interest;\n      vlt.notional += a;\n    } else {\n      vlt.notional = a;\n    }\n\n    vlt.exchangeRate = exchangeRate;\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Removes notional from a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional to remove\n  function removeNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n\n    Vault memory vlt = vaults[o];\n\n    if (a > vlt.notional) { revert Exception(31, a, vlt.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    vlt.redeemable += interest;\n    vlt.notional -= a;\n    vlt.exchangeRate = exchangeRate;\n\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Redeem's interest accrued by a given address\n  /// @param o Address that owns a vault\n  function redeemInterest(address o) external authorized(admin) returns (uint256) {\n\n    Vault memory vlt = vaults[o];\n\n    uint256 redeemable = vlt.redeemable;\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n\n    vlt.exchangeRate = exchangeRate;\n    vlt.redeemable = 0;\n\n    vaults[o] = vlt;\n\n    // return adds marginal interest to previously accrued redeemable interest\n    return (redeemable + interest);\n  }\n\n  /// @notice Matures the vault\n  /// @param c The current cToken exchange rate\n  function matureVault(uint256 c) external authorized(admin) returns (bool) {\n    maturityRate = c;\n    return true;\n  }\n\n  /// @notice Transfers notional from one address to another\n  /// @param f Owner of the amount\n  /// @param t Recipient of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFrom(address f, address t, uint256 a) external authorized(admin) returns (bool) {\n    if (f == t) { revert Exception(32, 0, 0, f, t); }\n\n    Vault memory from = vaults[f];\n    Vault memory to = vaults[t];\n\n    if (a > from.notional) { revert Exception(31, a, from.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { \n      // calculate marginal interest\n      yield = ((maturityRate * 1e26) / from.exchangeRate) - 1e26;\n    } else {\n      yield = ((exchangeRate * 1e26) / from.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * from.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    from.redeemable += interest;\n    from.notional -= a;\n    from.exchangeRate = exchangeRate;\n\n    vaults[f] = from;\n\n    // transfer notional to address \"t\", calculate interest if necessary\n    if (to.notional > 0) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n        yield = ((maturityRate * 1e26) / to.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / to.exchangeRate) - 1e26;\n      }\n\n      uint256 newVaultInterest = (yield * to.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      to.redeemable += newVaultInterest;\n      to.notional += a;\n    } else {\n      to.notional = a;\n    }\n\n    to.exchangeRate = exchangeRate;\n    vaults[t] = to;\n\n    return true;\n  }\n\n  /// @notice Transfers, in notional, a fee payment to the Swivel contract without recalculating marginal interest for the owner\n  /// @param f Owner of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFee(address f, uint256 a) external authorized(admin) returns(bool) {\n    Vault memory oVault = vaults[f];\n    Vault memory sVault = vaults[swivel];\n\n    // remove notional from its owner\n    oVault.notional -= a;\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate\n    uint256 yield;\n    if (sVault.exchangeRate != exchangeRate) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n          yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;\n      } else {\n          yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;\n      }\n      uint256 interest = (yield * sVault.notional) / 1e26;\n      // add interest and amount, reset cToken exchange rate\n      sVault.redeemable += interest;\n      sVault.exchangeRate = exchangeRate;\n    }\n    // add notional to swivel's vault\n    sVault.notional += a;\n    // store the adjusted vaults\n    vaults[swivel] = sVault;\n    vaults[f] = oVault;\n    return true;\n  }\n\n  /// @notice Returns both relevant balances for a given user's vault\n  /// @param o Address that owns a vault\n  function balancesOf(address o) external view returns (uint256, uint256) {\n    Vault memory vault = vaults[o];\n    return (vault.notional, vault.redeemable);\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n}\n\n\n",
        "CodeNames": [
            "VaultTracker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaultTracker.sol line 86",
                "Type": "Incorrect comparison operator",
                "Description": "The comparison should be 'a = vlt.notional' instead of a  vlt.notional. Otherwise dust amounts will always be left in vlt.notional when calling removeNotional() or transferNotionalFrom().",
                "Repair": "Change comparison operator from '>' to '>='"
            },
            {
                "Location": "VaultTracker.sol line 123-132",
                "Type": "Loss of funds",
                "Description": "Loss of all user funds. This exploit stems from a quirk in the way that exchange rate is tracked for matured positions.",
                "Repair": "Add 'require(block.timestamp < m)' in SplitUnderlying function and add 'vlt.notional = 0' after line 124 in redeemInterest function"
            },
            {
                "Location": "Functions within VaultTracker that calculate interest",
                "Type": "Miscalculated interest",
                "Description": "VaultTracker neglect previously accrued interest while attempting to calculate new interest. This causes nToken holders to receive less yield than they should.",
                "Repair": "For all interest calculations, use vlt.notional + vlt.redeemable instead of just vlt.notional as yield base."
            },
            {
                "Location": "VaultTracker.sol",
                "Type": "VaultTracker has the wrong admin",
                "Description": "VaultTracker takes msg.sender as the admin. However, the creator contract is not able (and not supposed to) interact with the VaultTracker unlike the marketplace contract.",
                "Repair": "Modify the constructor of the VaultTracker contract so that the creator contract can pass in msg.sender (MarketPlace\u2019s address) to be used as admin"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "function _removeNotional()",
                "Type": "Reentrancy",
                "Description": "The _removeNotional() function can be reentered by an attacker, allowing them to drain the protocol of funds.",
                "Repair": "Use the checks-effects-interactions pattern to ensure that all external calls are made after state changes have been made"
            },
            {
                "Location": "function redeemVaultInterest()",
                "Type": "Integer Underflow",
                "Description": "The redeemVaultInterest() function can underflow if the maturity rate is less than the exchange rate, causing users to lose their funds or interest.",
                "Repair": "Check that the maturity rate is greater than or equal to the exchange rate before performing any calculations that rely on this assumption"
            },
            {
                "Location": "function permit()",
                "Type": "Incorrect Check",
                "Description": "The permit() function allows anyone to approve themselves as a spender using the zero address, resulting in unlimited approval and the potential for draining the protocol.",
                "Repair": "Change the check to ensure that the recovered address is not equal to the zero address"
            },
            {
                "Location": "authRedeem function in Marketplace contract",
                "Type": "Missing modifier",
                "Description": "Due to missing modifier, User will be able to redeem zcTokens and withdraw underlying even in paused Market.",
                "Repair": "Add unpaused(p) modifier in authRedeem function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Protocols.sol'; // NOTE: if size restrictions become extreme we can use ints (implicit enum)\nimport './LibCompound.sol';\nimport './LibFuse.sol';\n\ninterface IErc4626 {\n  /// @dev Converts the given 'assets' (uint256) to 'shares', returning that amount\n  function convertToAssets(uint256) external view returns (uint256);\n}\n\ninterface ICompoundToken {\n  function exchangeRateCurrent() external view returns(uint256);\n}\n\ninterface IYearnVault {\n  function pricePerShare() external view returns (uint256);\n}\n\ninterface IAavePool {\n   /// @dev Returns the normalized income of the reserve given the address of the underlying asset of the reserve\n  function getReserveNormalizedIncome(address) external view returns (uint256);\n}\n\ninterface IAaveToken {\n  function POOL() external view returns (address);\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n\ninterface IEulerToken {\n  /// @notice Convert an eToken balance to an underlying amount, taking into account current exchange rate\n  function convertBalanceToUnderlying(uint256) external view returns(uint256);\n}\n\nlibrary Compounding {\n  /// @param p Protocol Enum value\n  /// @param c Compounding token address\n  function exchangeRate(uint8 p, address c) internal view returns (uint256) {\n    if (p == uint8(Protocols.Compound)) {\n      return LibCompound.viewExchangeRate(ICERC20(c));\n    } else if (p == uint8(Protocols.Rari)) { \n      return LibFuse.viewExchangeRate(ICERC20(c));\n    } else if (p == uint8(Protocols.Yearn)) {\n      return IYearnVault(c).pricePerShare();\n    } else if (p == uint8(Protocols.Aave)) {\n      IAaveToken aToken = IAaveToken(c);\n      return IAavePool(aToken.POOL()).getReserveNormalizedIncome(aToken.UNDERLYING_ASSET_ADDRESS());\n    } else if (p == uint8(Protocols.Euler)) {\n      // NOTE: the 1e26 const is a degree of precision to enforce on the return\n      return IEulerToken(c).convertBalanceToUnderlying(1e26);\n    } else {\n      // NOTE: the 1e26 const is a degree of precision to enforce on the return\n      return IErc4626(c).convertToAssets(1e26);\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "Compounding.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Yearn vault integration in Compounding.sol",
                "Type": "Broken functionality",
                "Description": "Yearn integration is broken, making it impossible to create a MarketPlace associated with a Yearn vault.",
                "Repair": "Access the underlying token of a Yearn vault through the token property instead of the non-existent underlying which will cause a revert and the inability to create marketplaces associated with the protocol."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Erc20.sol\";\nimport \"./Compounding.sol\";\nimport \"./IERC5095.sol\";  \nimport \"./IRedeemer.sol\";\n\n// Utilizing an external custody contract to allow for backwards compatability with some projects.\n// Assumes interest generated post maturity using an internal Compounding library.\ncontract ZcToken is Erc20, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public override immutable maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public override immutable underlying;\n    /// @dev uint8 associated with a given protocol in Swivel\n    uint8 public immutable protocol;\n    \n    /////////////OPTIONAL///////////////// (Allows the calculation and distribution of yield post maturity)\n    /// @dev address of a cToken\n    address public immutable cToken;\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    IRedeemer public immutable redeemer;\n\n    error Maturity(uint256 timestamp);  \n\n    error Approvals(uint256 approved, uint256 amount);\n\n    error Authorized(address owner);\n\n    constructor(uint8 _protocol, address _underlying, uint256 _maturity, address _cToken, address _redeemer, string memory _name, string memory _symbol, uint8 _decimals) \n    Erc20( _name, _symbol, _decimals) {\n        protocol = _protocol;\n        underlying = _underlying;\n        maturity = _maturity;\n        cToken = _cToken;\n        redeemer = IRedeemer(_redeemer);\n    }\n\n    /// @notice Post maturity converts an amount of principal tokens to an amount of underlying that would be returned. Returns 0 pre-maturity.\n    /// @param principalAmount The amount of principal tokens to convert\n    /// @return underlyingAmount The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity converts a desired amount of underlying tokens returned to principal tokens needed. Returns 0 pre-maturity.\n    /// @param underlyingAmount The amount of underlying tokens to convert\n    /// @return principalAmount The amount of principal tokens returned by the conversion\n    function convertToPrincipal(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount * IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));\n    }\n    /// @notice Post maturity calculates the amount of principal tokens that `owner` can redeem. Returns 0 pre-maturity.\n    /// @param owner The address of the owner for which redemption is calculated\n    /// @return maxPrincipalAmount The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address owner) external override view returns (uint256 maxPrincipalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (balanceOf[owner]);\n    }\n    /// @notice Post maturity simulates the effects of redeemption at the current block. Returns 0 pre-maturity.\n    /// @param principalAmount the amount of principal tokens redeemed in the simulation\n    /// @return underlyingAmount The maximum amount of underlying returned by `principalAmount` of PT redemption\n    function previewRedeem(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity calculates the amount of underlying tokens that `owner` can withdraw. Returns 0 pre-maturity.\n    /// @param  owner The address of the owner for which withdrawal is calculated\n    /// @return maxUnderlyingAmount The maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address owner) external override view returns (uint256 maxUnderlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (balanceOf[owner] * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity simulates the effects of withdrawal at the current block. Returns 0 pre-maturity.\n    /// @param underlyingAmount the amount of underlying tokens withdrawn in the simulation\n    /// @return principalAmount The amount of principal tokens required for the withdrawal of `underlyingAmount`\n    function previewWithdraw(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount * IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));\n    }\n    /// @notice At or after maturity, Burns principalAmount from `owner` and sends exactly `underlyingAmount` of underlying tokens to `receiver`.\n    /// @param underlyingAmount The amount of underlying tokens withdrawn\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return principalAmount The amount of principal tokens burnt by the withdrawal\n    function withdraw(uint256 underlyingAmount, address receiver, address holder) external override returns (uint256 principalAmount){\n        uint256 previewAmount = this.previewWithdraw(underlyingAmount);\n        // If maturity is not yet reached\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        // Transfer logic\n        // If holder is msg.sender, skip approval check\n        if (holder == msg.sender) {\n            redeemer.authRedeem(protocol, underlying, maturity, msg.sender, receiver, previewAmount);\n            return previewAmount;\n        }\n        else {\n            uint256 allowed = allowance[holder][msg.sender];\n            if (allowed >= previewAmount) {\n                revert Approvals(allowed, previewAmount);\n            }\n            allowance[holder][msg.sender] -= previewAmount;\n            redeemer.authRedeem(protocol, underlying, maturity, holder, receiver, previewAmount); \n            return previewAmount;\n        }\n    }\n    /// @notice At or after maturity, burns exactly `principalAmount` of Principal Tokens from `owner` and sends underlyingAmount of underlying tokens to `receiver`.\n    /// @param principalAmount The amount of principal tokens being redeemed\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return underlyingAmount The amount of underlying tokens distributed by the redemption\n    function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){\n        // If maturity is not yet reached\n        if (block.timestamp < maturity) { revert Maturity(maturity); }\n        // some 5095 tokens may have custody of underlying and can can just burn PTs and transfer underlying out, while others rely on external custody\n        if (holder == msg.sender) {\n            return redeemer.authRedeem(protocol, underlying, maturity, msg.sender, receiver, principalAmount);\n        }\n        else {\n            uint256 allowed = allowance[holder][msg.sender];\n            if (allowed >= principalAmount) { revert Approvals(allowed, principalAmount); }\n            allowance[holder][msg.sender] -= principalAmount;  \n            return redeemer.authRedeem(protocol, underlying, maturity, holder, receiver, principalAmount);\n        }\n    }\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    function burn(address f, uint256 a) external onlyAdmin(address(redeemer)) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    function mint(address t, uint256 a) external onlyAdmin(address(redeemer)) returns (bool) {\n        _mint(t, a);\n        return true;\n    }\n\n    modifier onlyAdmin(address a) {\n    if (msg.sender != a) { revert Authorized(a); }\n    _;\n  }\n}\n\n\n",
        "CodeNames": [
            "ZcToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ZcToken.sol",
                "Type": "Error in allowance logic",
                "Description": "There is an error in the allowance functionality to allow a non-owner to withdraw or redeem ZcTokens for the owner.",
                "Repair": "Change = to < in the if statement"
            },
            {
                "Location": "ZcToken.withdraw function",
                "Type": "Incorrect withdrawal behavior",
                "Description": "If maturityRate is still 0 after maturity deadline, then previewWithdraw calculated amount is 0 and thus withdraw function will send 0 underlying tokens to user, which might be very confusing to user.",
                "Repair": "Add getMaturityRate function to ZcToken and use it instead of maturityRate across the contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './Protocols.sol';\nimport './Hash.sol';\nimport './Sig.sol';\nimport './Safe.sol';\n\ncontract Swivel {\n  /// @dev A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n  /// @dev maps the key of an order to a boolean indicating if an order was cancelled\n  mapping (bytes32 => bool) public cancelled;\n  /// @dev maps the key of an order to an amount representing its taken volume\n  mapping (bytes32 => uint256) public filled;\n  /// @dev maps a token address to a point in time, a hold, after which a withdrawal can be made\n  mapping (address => uint256) public withdrawals;\n  /// @dev maps a token address to a point in time, a hold, after which an approval can be made\n  mapping (address => uint256) public approvals;\n\n  string constant public NAME = 'Swivel Finance';\n  string constant public VERSION = '3.0.0';\n  uint256 constant public HOLD = 3 days;\n  bytes32 public immutable domain;\n  address public immutable marketPlace;\n  address public admin;\n  \n  /// @dev address of a deployed Aave contract implementing IAave\n  address public aaveAddr; // TODO immutable?\n\n  uint16 constant public MIN_FEENOMINATOR = 33;\n  /// @dev holds the fee demoninators for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit]\n  uint16[4] public feenominators;\n  /// @dev A point in time, a hold, after which a change to Fees\n  uint256 public feeChange;\n\n  /// @notice Emitted on order cancellation\n  event Cancel (bytes32 indexed key, bytes32 hash);\n  /// @notice Emitted on any initiate*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Initiate(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on any exit*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Exit(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on token withdrawal scheduling\n  event ScheduleWithdrawal(address indexed token, uint256 hold);\n  /// @notice Emitted on token withdrawal blocking\n  event BlockWithdrawal(address indexed token);\n  /// @notice Emitted on a change to the feenominators array\n  event SetFee(uint256 indexed index, uint256 indexed feenominator);\n  /// @notice Emitted on a token approval scheduling\n  event ScheduleApproval(address indexed token, uint256 hold);\n  /// @notice Emitted on a token approval blocking\n  event BlockApproval(address indexed token);\n  /// @notice Emitted on a fee change scheduling\n  event ScheduleFeeChange(uint256 hold);\n  /// @notice Emitted on a fee change blocking\n  event BlockFeeChange();\n\n  /// @param m Deployed MarketPlace contract address\n  /// @param a Address of a deployed Aave contract implementing our interface\n  constructor(address m, address a) {\n    admin = msg.sender;\n    domain = Hash.domain(NAME, VERSION, block.chainid, address(this));\n    marketPlace = m;\n    aaveAddr = a;\n    feenominators = [200, 600, 400, 200];\n  }\n\n  // ********* INITIATING *************\n\n  /// @notice Allows a user to initiate a position\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Array of Components from valid ECDSA signatures\n  function initiate(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i < len;) {\n      Hash.Order memory order = o[i];\n      if (!order.exit) {\n        if (!order.vault) {\n          initiateVaultFillingZcTokenInitiate(o[i], a[i], c[i]);\n        } else {\n          initiateZcTokenFillingVaultInitiate(o[i], a[i], c[i]);\n        }\n      } else {\n        if (!order.vault) {\n          initiateZcTokenFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          initiateVaultFillingVaultExit(o[i], a[i], c[i]);\n        }\n      }\n      unchecked {i++;}\n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (premium) being filled by the taker's initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    // checks order signature, order cancellation and order expiry\n    bytes32 hash = validOrderHash(o, c);\n\n    // checks the side, and the amount compared to available\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n    \n    // TODO cheaper to assign amount here or keep the ADD?\n    filled[hash] += a;\n\n    // transfer underlying tokens\n    IErc20 uToken = IErc20(o.underlying);\n    Safe.transferFrom(uToken, msg.sender, o.maker, a);\n\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    Safe.transferFrom(uToken, o.maker, address(this), principalFilled);\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n\n    // perform the actual deposit type transaction, specific to a protocol\n    if (!deposit(o.protocol, o.underlying, cTokenAddr, principalFilled)) { revert Exception(6, 0, 0, address(0), address(0)); }\n\n    // alert marketplace\n    if (!mPlace.custodialInitiate(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, principalFilled)) { revert Exception(8, 0, 0, address(0), address(0)); }\n\n    // transfer fee in vault notional to swivel (from msg.sender)\n    uint256 fee = principalFilled / feenominators[2];\n    if (!mPlace.transferVaultNotionalFee(o.protocol, o.underlying, o.maturity, msg.sender, fee)) { revert Exception(10, 0, 0, address(0), address(0)); }\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    IErc20 uToken = IErc20(o.underlying);\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\n\n    // transfer principal + fee in underlying to swivel (from sender)\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), (a + fee));\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n\n    // perform the actual deposit type transaction, specific to a protocol\n    if(!deposit(o.protocol, o.underlying, cTokenAddr, a)) { revert Exception(6, 0, 0, address(0), address(0)); }\n\n    // alert marketplace \n    if (!mPlace.custodialInitiate(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, a)) { revert Exception(8, 0, 0, address(0), address(0)); }\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate zcToken? by filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's initiate \n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n\n    IErc20 uToken = IErc20(o.underlying);\n    // transfer underlying tokens, then take fee\n    Safe.transferFrom(uToken, msg.sender, o.maker, a - premiumFilled);\n\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // alert marketplace\n    if (!IMarketPlace(marketPlace).p2pZcTokenExchange(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, a)) { revert Exception(11, 0, 0, address(0), address(0)); }\n            \n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n\n    // TODO assign amount or keep ADD?\n    filled[hash] += a;\n\n    Safe.transferFrom(IErc20(o.underlying), msg.sender, o.maker, a);\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    // alert marketplace\n    if (!mPlace.p2pVaultExchange(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, principalFilled)) { revert Exception(12, 0, 0, address(0), address(0)); }\n\n    // transfer fee (in vault notional) to swivel\n    uint256 fee = principalFilled / feenominators[2];\n    if (!mPlace.transferVaultNotionalFee(o.protocol, o.underlying, o.maturity, msg.sender, fee)) { revert Exception(10, 0, 0, address(0), address(0)); }\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  // ********* EXITING ***************\n\n  /// @notice Allows a user to exit (sell) a currently held position to the marketplace.\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Components of a valid ECDSA signature\n  function exit(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i < len;) {\n      Hash.Order memory order = o[i];\n      // if the order being filled is not an exit\n      if (!order.exit) {\n        // if the order being filled is a vault initiate or a zcToken initiate\n          if (!order.vault) {\n            // if filling a zcToken initiate with an exit, one is exiting zcTokens\n            exitZcTokenFillingZcTokenInitiate(o[i], a[i], c[i]);\n          } else {\n            // if filling a vault initiate with an exit, one is exiting vault notional\n            exitVaultFillingVaultInitiate(o[i], a[i], c[i]);\n          }\n      } else {\n        // if the order being filled is a vault exit or a zcToken exit\n        if (!order.vault) {\n          // if filling a zcToken exit with an exit, one is exiting vault\n          exitVaultFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          // if filling a vault exit with an exit, one is exiting zcTokens\n          exitZcTokenFillingVaultExit(o[i], a[i], c[i]);\n        }   \n      }\n      unchecked {i++;}\n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitZcTokenFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;       \n\n    IErc20 uToken = IErc20(o.underlying);\n\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    // transfer underlying from initiating party to exiting party, minus the price the exit party pays for the exit (premium), and the fee.\n    Safe.transferFrom(uToken, o.maker, msg.sender, principalFilled - a);\n\n    // transfer fee in underlying to swivel\n    uint256 fee = principalFilled / feenominators[1];\n\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // alert marketplace\n    if (!IMarketPlace(marketPlace).p2pZcTokenExchange(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, principalFilled)) { revert Exception(11, 0, 0, address(0), address(0)); }\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n  \n  /// @notice Allows a user to exit their Vault by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n    \n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n        \n    IErc20 uToken = IErc20(o.underlying);\n\n    // transfer premium from maker to sender\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\n\n    uint256 fee = premiumFilled / feenominators[3];\n    // transfer fee in underlying to swivel from sender\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // transfer <a> notional from sender to maker\n    if (!IMarketPlace(marketPlace).p2pVaultExchange(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, a)) { revert Exception(12, 0, 0, address(0), address(0)); }\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to exit their Vault filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.exitFillingExit\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitVaultFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    // redeem underlying on Compound and burn cTokens\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n\n    if (!withdraw(o.protocol, o.underlying, cTokenAddr, a)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    IErc20 uToken = IErc20(o.underlying);\n    // transfer principal-premium  back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transfer(uToken, o.maker, a - premiumFilled);\n\n    // transfer premium-fee to floating exit party\n    uint256 fee = premiumFilled / feenominators[3];\n    Safe.transfer(uToken, msg.sender, premiumFilled - fee);\n\n    // burn zcTokens + nTokens from o.maker and msg.sender respectively\n    if (!mPlace.custodialExit(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, a)) { revert Exception(9, 0, 0, address(0), address(0)); }\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.exitFillingExit\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitZcTokenFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n    \n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    // redeem underlying on Compound and burn cTokens\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n    uint256 principalFilled = (a * o.principal) / o.premium;\n\n    if (!withdraw(o.protocol, o.underlying, cTokenAddr, principalFilled)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    IErc20 uToken = IErc20(o.underlying);\n    // transfer principal-premium-fee back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uint256 fee = principalFilled / feenominators[1];\n    Safe.transfer(uToken, msg.sender, principalFilled - a - fee);\n    Safe.transfer(uToken, o.maker, a);\n\n    // burn <principalFilled> zcTokens + nTokens from msg.sender and o.maker respectively\n    if (!mPlace.custodialExit(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, principalFilled)) { revert Exception(9, 0, 0, address(0), address(0)); }\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to cancel an order, preventing it from being filled in the future\n  /// @param o Order being cancelled\n  /// @param c Components of a valid ECDSA signature\n  function cancel(Hash.Order[] calldata o, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    for (uint256 i; i < len;) {\n      bytes32 hash = validOrderHash(o[i], c[i]);\n      if (msg.sender != o[i].maker) { revert Exception(15, 0, 0, msg.sender, o[i].maker); }\n\n      cancelled[hash] = true;\n\n      emit Cancel(o[i].key, hash);\n\n      unchecked {\n        i++;\n      }\n    }\n\n    return true;\n  }\n\n  // ********* ADMINISTRATIVE ***************\n\n  /// @param a Address of a new admin\n  function setAdmin(address a) external authorized(admin) returns (bool) {\n    admin = a;\n\n    return true;\n  }\n\n  /// @notice Allows the admin to schedule the withdrawal of tokens\n  /// @param e Address of (erc20) token to withdraw\n  function scheduleWithdrawal(address e) external authorized(admin) returns (bool) {\n    uint256 when = block.timestamp + HOLD;\n    withdrawals[e] = when;\n\n    emit ScheduleWithdrawal(e, when);\n\n    return true;\n  }\n\n  /// @notice Emergency function to block unplanned withdrawals\n  /// @param e Address of token withdrawal to block\n  function blockWithdrawal(address e) external authorized(admin) returns (bool) {\n      withdrawals[e] = 0;\n\n      emit BlockWithdrawal(e);\n\n      return true;\n  }\n\n  /// @notice Allows the admin to withdraw the given token, provided the holding period has been observed\n  /// @param e Address of token to withdraw\n  function withdraw(address e) external authorized(admin) returns (bool) {\n    uint256 when = withdrawals[e];\n\n    if (when == 0) { revert Exception(16, 0, 0, address(0), address(0)); }\n\n    if (block.timestamp < when) { revert Exception(17, block.timestamp, when, address(0), address(0)); }\n\n    withdrawals[e] = 0;\n\n    IErc20 token = IErc20(e);\n    Safe.transfer(token, admin, token.balanceOf(address(this)));\n\n    return true;\n  }\n\n  /// @notice Allows the admin to schedule the change of fees\n  function scheduleFeeChange() external authorized(admin) returns (bool) {\n    uint256 when = block.timestamp + HOLD;\n    feeChange = when;\n\n    emit ScheduleFeeChange(when);\n\n    return true;\n  }\n\n  /// @notice Emergency function to block unplanned withdrawals\n  function blockFeeChange() external authorized(admin) returns (bool) {\n      feeChange = 0;\n\n      emit BlockFeeChange();\n\n      return true;\n  }\n\n\n  /// @notice Allows the admin to set a new fee denominator\n  /// @param i The index of the new fee denominator\n  /// @param d The new fee denominator\n  function setFee(uint16[] memory i, uint16[] memory d) external authorized(admin) returns (bool) {\n    uint256 len = i.length;\n\n    if (len != d.length) { revert Exception(19, len, d.length, address(0), address(0)); }\n\n    if (feeChange == 0) { revert Exception(16, 0, 0, address(0), address(0)); }\n\n    if (block.timestamp < feeChange) { revert Exception(17, block.timestamp, feeChange, address(0), address(0)); }\n\n    for (uint256 x; x < len;) {\n      if (d[x] < MIN_FEENOMINATOR) { revert Exception(18, uint256(d[x]), 0, address(0), address(0)); }\n\n      feenominators[x] = d[x];\n      emit SetFee(i[x], d[x]);\n\n      unchecked {\n        x++;\n      }\n    }\n\n    feeChange = 0;\n\n    return true;\n  }\n\n  /// @notice Allows the admin to schedule the approval of tokens\n  /// @param e Address of (erc20) token to withdraw\n  function scheduleApproval(address e) external authorized(admin) returns (bool) {\n    uint256 when = block.timestamp + HOLD;\n    approvals[e] = when;\n\n    emit ScheduleApproval(e, when);\n\n    return true;\n  }\n\n  /// @notice Emergency function to block unplanned withdrawals\n  /// @param e Address of token approval to block\n  function blockApproval(address e) external authorized(admin) returns (bool) {\n      approvals[e] = 0;\n\n      emit BlockApproval(e);\n\n      return true;\n  }\n\n  /// @notice Allows the admin to bulk approve given compound addresses at the underlying token, saving marginal approvals\n  /// @param u array of underlying token addresses\n  /// @param c array of compound token addresses\n  function approveUnderlying(address[] calldata u, address[] calldata c) external authorized(admin) returns (bool) {\n    uint256 len = u.length;\n\n    if (len != c.length) { revert Exception(19, len, c.length, address(0), address(0)); }\n\n    uint256 max = 2**256 - 1;\n    uint256 when;\n\n    for (uint256 i; i < len;) {\n      when = approvals[u[i]];\n\n      if (when == 0) { revert Exception(16, 0, 0, address(0), address(0)); }\n\n      if (block.timestamp < when) { revert Exception(17, block.timestamp, when, address(0), address(0));\n      }\n\n      approvals[u[i]] = 0;\n      IErc20 uToken = IErc20(u[i]);\n      Safe.approve(uToken, c[i], max);\n      unchecked {\n        i++;\n      }\n    }\n\n    return true;\n  }\n  // ********* PROTOCOL UTILITY ***************\n\n  /// @notice Allows users to deposit underlying and in the process split it into/mint \n  /// zcTokens and vault notional. Calls mPlace.mintZcTokenAddingNotional\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with this market pair\n  /// @param m Maturity timestamp of this associated market\n  /// @param a Amount of underlying being deposited\n  function splitUnderlying(uint8 p, address u, uint256 m, uint256 a) external returns (bool) {\n    IErc20 uToken = IErc20(u);\n    Safe.transferFrom(uToken, msg.sender, address(this), a);\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    \n    // the underlying deposit is directed to the appropriate abstraction\n    if (!deposit(p, u, mPlace.cTokenAddress(p, u, m), a)) { revert Exception(6, 0, 0, address(0), address(0));\n    }\n\n    if (!mPlace.mintZcTokenAddingNotional(p, u, m, msg.sender, a)) { revert Exception(13, 0, 0, address(0), address(0));\n    }\n\n    return true;\n  }\n\n  /// @notice Allows users deposit/burn 1-1 amounts of both zcTokens and vault notional,\n  /// in the process \"combining\" the two, and redeeming underlying. Calls mPlace.burnZcTokenRemovingNotional.\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function combineTokens(uint8 p, address u, uint256 m, uint256 a) external returns (bool) {\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n\n    if (!mPlace.burnZcTokenRemovingNotional(p, u, m, msg.sender, a)) { revert Exception(14, 0, 0, address(0), address(0));\n    }\n\n    if (!withdraw(p, u, mPlace.cTokenAddress(p, u, m), a)) { revert Exception(7, 0, 0, address(0), address(0));\n    }\n\n    Safe.transfer(IErc20(u), msg.sender, a);\n\n    return true;\n  }\n\n  /// @notice Allows users to redeem zcTokens and withdraw underlying, boiling up from the zcToken instead of starting on Swivel\n  /// @notice p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with this market pair\n  /// @param c Compound token address associated with this market pair\n  /// @param t Address of the user receiving the underlying tokens\n  /// @param a Amount of underlying being redeemed\n  function authRedeemZcToken(uint8 p, address u, address c, address t, uint256 a) external authorized(marketPlace) returns(bool) {\n    // redeem underlying from compounding\n    if (!withdraw(p, u, c, a)) { revert Exception(7, 0, 0, address(0), address(0)); }\n    // transfer underlying back to msg.sender\n    Safe.transfer(IErc20(u), t, a);\n\n    return (true);\n  }\n\n  /// @notice Allows zcToken holders to redeem their tokens for underlying tokens after maturity has been reached (via MarketPlace).\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function redeemZcToken(uint8 p, address u, uint256 m, uint256 a) external returns (bool) {\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemZcToken(p, u, m, msg.sender, a);\n    // redeem underlying from compounding\n    if (!withdraw(p, u, mPlace.cTokenAddress(p, u, m), redeemed)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    // transfer underlying back to msg.sender\n    Safe.transfer(IErc20(u), msg.sender, redeemed);\n\n    return true;\n  }\n\n  /// @notice Allows Vault owners to redeem any currently accrued interest (via MarketPlace)\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function redeemVaultInterest(uint8 p, address u, uint256 m) external returns (bool) {\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemVaultInterest(p, u, m, msg.sender);\n    // redeem underlying from compounding\n    address cTokenAddr = mPlace.cTokenAddress(p, u, m);\n\n    if (!withdraw(p, u, cTokenAddr, redeemed)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    // transfer underlying back to msg.sender\n    Safe.transfer(IErc20(u), msg.sender, redeemed);\n\n    return true;\n  }\n\n  /// @notice Allows Swivel to redeem any currently accrued interest (via MarketPlace)\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function redeemSwivelVaultInterest(uint8 p, address u, uint256 m) external returns (bool) {\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemVaultInterest(p, u, m, address(this));\n    // redeem underlying from compounding\n    if (!withdraw(p, u, mPlace.cTokenAddress(p, u, m), redeemed)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    // NOTE: for swivel reddem there is no transfer out as there is in redeemVaultInterest\n\n    return true;\n  }\n\n  /// @notice Varifies the validity of an order and it's signature.\n  /// @param o An offline Swivel.Order\n  /// @param c Components of a valid ECDSA signature\n  /// @return the hashed order.\n  function validOrderHash(Hash.Order calldata o, Sig.Components calldata c) internal view returns (bytes32) {\n    bytes32 hash = Hash.order(o);\n\n    if (cancelled[hash]) { revert Exception(2, 0, 0, address(0), address(0)); }\n\n    if (o.expiry < block.timestamp) { revert Exception(3, o.expiry, block.timestamp, address(0), address(0)); }\n\n    address recovered = Sig.recover(Hash.message(domain, hash), c);\n\n    if (o.maker != recovered) { revert Exception(4, 0, 0, o.maker, recovered); }\n\n    return hash;\n  }\n\n  /// @notice Use the Protocol Enum to direct deposit type transactions to their specific library abstraction\n  /// @dev This functionality is an abstraction used by `IVFZI`, `IZFVI` and `splitUnderlying`\n  /// @param p Protocol Enum Value\n  /// @param u Address of an underlying token (used by Aave)\n  /// @param c Compounding token address\n  /// @param a Amount to deposit\n  function deposit(uint8 p, address u, address c, uint256 a) internal returns (bool) {\n    // TODO as stated elsewhere, we may choose to simply return true in all and not attempt to measure against any expected return\n    if (p == uint8(Protocols.Compound)) { // TODO is Rari a drop in here?\n      return ICompound(c).mint(a) == 0;\n    } else if (p == uint8(Protocols.Yearn)) {\n      // yearn vault api states that deposit returns shares as uint256\n      return IYearn(c).deposit(a) >= 0;\n    } else if (p == uint8(Protocols.Aave)) {\n      // Aave deposit is void. NOTE the change in pattern here where our interface is not wrapping a compounding token directly, but\n      // a specified protocol contract whose address we have set\n      // TODO explain the Aave deposit args\n      IAave(aaveAddr).deposit(u, a, address(this), 0);\n      return true;\n    } else if (p == uint8(Protocols.Euler)) {\n      // Euler deposit is void.\n      // TODO explain the 0 (primary account)\n      IEuler(c).deposit(0, a);\n      return true;\n    } else {\n      // we will allow protocol[0] to also function as a catchall for Erc4626\n      // NOTE: deposit, as per the spec, returns 'shares' but it is unknown if 0 would revert, thus we'll check for 0 or greater\n      return IErc4626(c).deposit(a, address(this)) >= 0;\n    }\n  }\n\n  /// @notice Use the Protocol Enum to direct withdraw type transactions to their specific library abstraction\n  /// @dev This functionality is an abstraction used by `EVFZE`, `EZFVE`, `combineTokens`, `redeemZcToken` and `redeemVaultInterest`.\n  /// Note that while there is an external method `withdraw` also on this contract the unique method signatures (and visibility)\n  /// exclude any possible clashing\n  /// @param p Protocol Enum Value\n  /// @param u Address of an underlying token (used by Aave)\n  /// @param c Compounding token address\n  /// @param a Amount to withdraw\n  function withdraw(uint8 p, address u, address c, uint256 a) internal returns (bool) {\n    // TODO as stated elsewhere, we may choose to simply return true in all and not attempt to measure against any expected return\n    if (p == uint8(Protocols.Compound)) { // TODO is Rari a drop in here?\n      return ICompound(c).redeemUnderlying(a) == 0;\n    } else if (p == uint8(Protocols.Yearn)) {\n      // yearn vault api states that withdraw returns uint256\n      return IYearn(c).withdraw(a) >= 0;\n    } else if (p == uint8(Protocols.Aave)) {\n      // Aave v2 docs state that withraw returns uint256\n      // TODO explain the withdraw args\n      return IAave(aaveAddr).withdraw(u, a, address(this)) >= 0;\n    } else if (p == uint8(Protocols.Euler)) {\n      // Euler withdraw is void\n      // TODO explain the 0\n      IEuler(c).withdraw(0, a);\n      return true;\n    } else {\n      // we will allow protocol[0] to also function as a catchall for Erc4626\n      return IErc4626(c).withdraw(a, address(this), address(this)) >= 0;\n    }\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n}\n\n\n",
        "CodeNames": [
            "Swivel.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Swivel.sol",
                "Type": "Mismatch in withdraw() between Yearn and other protocols can prevent Users from redeeming zcTokens and permanently lock funds",
                "Description": "Yearn withdraw amount parameter specifies how many shares are burnt instead of underlying assets retrieved.",
                "Repair": "Calculate the price per share and use that to retrieve the correct number of underlying assets"
            },
            {
                "Location": "Swivel.sol",
                "Type": "Swivel.setFee() is implemented wrongly",
                "Description": "Swivel.feenominators won't be set as expected.",
                "Repair": "Modify the line of code to feenominators[i[x]] = d[x]"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './Compounding.sol';\n\ncontract MarketPlace {\n  /// @dev A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  struct Market {\n    address cTokenAddr;\n    address zcToken;\n    address vaultTracker;\n    uint256 maturityRate;\n  }\n\n  mapping (uint8 => mapping (address => mapping (uint256 => Market))) public markets;\n  mapping (uint8 => bool) public paused;\n\n  address public admin;\n  address public swivel;\n  address public immutable creator;\n\n  event Create(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address cToken, address zcToken, address vaultTracker);\n  event Mature(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, uint256 maturityRate, uint256 matured);\n  event RedeemZcToken(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address sender, uint256 amount);\n  event RedeemVaultInterest(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address sender);\n  event CustodialInitiate(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);\n  event CustodialExit(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);\n  event P2pZcTokenExchange(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\n  event P2pVaultExchange(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\n  event TransferVaultNotional(uint8 indexed protocol, address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\n\n  constructor(address c) {\n    admin = msg.sender;\n    creator = c;\n  }\n\n  /// @param s Address of the deployed swivel contract\n  /// @notice We only allow this to be set once\n  function setSwivel(address s) external authorized(admin) returns (bool) {\n    if (swivel != address(0)) { revert Exception(20, 0, 0, swivel, address(0));  }\n\n    swivel = s;\n    return true;\n  }\n\n  /// @param a Address of a new admin\n  function setAdmin(address a) external authorized(admin) returns (bool) {\n    admin = a;\n    return true;\n  }\n\n  /// @notice Allows the owner to create new markets\n  /// @param p Protocol associated with the new market\n  /// @param m Maturity timestamp of the new market\n  /// @param c Compounding Token address associated with the new market\n  /// @param n Name of the new market zcToken\n  /// @param s Symbol of the new market zcToken\n  function createMarket(\n    uint8 p,\n    uint256 m,\n    address c,\n    string memory n,\n    string memory s\n  ) external authorized(admin) unpaused(p) returns (bool) {\n    if (swivel == address(0)) { revert Exception(21, 0, 0, address(0), address(0)); }\n\n    address underAddr = Compounding.underlying(p, c);\n\n    if (markets[p][underAddr][m].vaultTracker != address(0)) { revert Exception(22, 0, 0, address(0), address(0)); }\n\n    (address zct, address tracker) = ICreator(creator).create(p, underAddr, m, c, swivel, n, s, IErc20(underAddr).decimals()) ;\n\n    markets[p][underAddr][m] = Market(c, zct, tracker, 0);\n\n    emit Create(p, underAddr, m, c, zct, tracker);\n\n    return true;\n  }\n\n  /// @notice Can be called after maturity, allowing all of the zcTokens to earn floating interest on Compound until they release their funds\n  /// @param p Protocol Enum value associated with the market being matured\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function matureMarket(uint8 p, address u, uint256 m) public unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n\n    if (market.maturityRate != 0) { revert Exception(23, market.maturityRate, 0, address(0), address(0)); }\n\n    if (block.timestamp < m) { revert Exception(24, block.timestamp, m, address(0), address(0)); }\n\n    // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate\n    uint256 exchangeRate = Compounding.exchangeRate(p, market.cTokenAddr);\n    markets[p][u][m].maturityRate = exchangeRate;\n\n    // NOTE we don't check the return of this simple operation\n    IVaultTracker(market.vaultTracker).matureVault(exchangeRate);\n\n    emit Mature(p, u, m, exchangeRate, block.timestamp);\n\n    return true;\n  }\n\n  /// @notice Allows Swivel caller to deposit their underlying, in the process splitting it - minting both zcTokens and vault notional.\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the depositing user\n  /// @param a Amount of notional being added\n  function mintZcTokenAddingNotional(uint8 p, address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n\n    if (!IZcToken(market.zcToken).mint(t, a)) { revert Exception(28, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).addNotional(t, a)) { revert Exception(25, 0, 0, address(0), address(0)); }\n    \n    return true;\n  }\n\n  /// @notice Allows Swivel caller to deposit/burn both zcTokens + vault notional. This process is \"combining\" the two and redeeming underlying.\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the combining/redeeming user\n  /// @param a Amount of zcTokens being burned\n  function burnZcTokenRemovingNotional(uint8 p, address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused(p) returns(bool) {\n    Market memory market = markets[p][u][m];\n\n    if (!IZcToken(market.zcToken).burn(t, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).removeNotional(t, a)) { revert Exception(26, 0, 0, address(0), address(0)); }\n    \n    return true;\n  }\n\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Address of the user having their zcTokens burned\n  /// @param t Address of the user receiving underlying\n  /// @param a Amount of zcTokens being redeemed\n  /// @return underlyingAmount Amount of underlying being withdrawn (needed for 5095 return)\n  function authRedeem(uint8 p, address u, uint256 m, address f, address t, uint256 a) public authorized(markets[p][u][m].zcToken) returns (uint256 underlyingAmount) {\n    Market memory market = markets[p][u][m];\n    // if the market has not matured, mature it...\n    if (market.maturityRate == 0) {\n      if (!matureMarket(p, u, m)) { revert Exception(30, 0, 0, address(0), address(0)); }\n\n      if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n      ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, a);\n\n      return (a);\n    } else {\n\n      if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n      uint256 amount = calculateReturn(p, u, m, a);\n      ISwivel(swivel).authRedeem(p, u, market.cTokenAddr, t, amount);\n\n      return (amount);\n    }\n  }\n\n  /// @notice Allows (via swivel) zcToken holders to redeem their tokens for underlying tokens after maturity has been reached.\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the redeeming user\n  /// @param a Amount of zcTokens being redeemed\n  function redeemZcToken(uint8 p, address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused(p) returns (uint256) {\n    Market memory market = markets[p][u][m];\n\n    // if the market has not matured, mature it and redeem exactly the amount\n    if (market.maturityRate == 0) {\n      if (!matureMarket(p, u, m)) { revert Exception(30, 0, 0, address(0), address(0)); }\n    }\n\n    if (!IZcToken(market.zcToken).burn(t, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    emit RedeemZcToken(p, u, m, t, a);\n\n    if (market.maturityRate == 0) {\n      return a;\n    } else { \n      // if the market was already mature the return should include the amount + marginal floating interest generated on Compound since maturity\n      return calculateReturn(p, u, m, a);\n    }\n  }\n\n  /// @notice Allows Vault owners (via Swivel) to redeem any currently accrued interest\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Address of the redeeming user\n  function redeemVaultInterest(uint8 p, address u, uint256 m, address t) external authorized(swivel) unpaused(p) returns (uint256) {\n    // call to the floating market contract to release the position and calculate the interest generated\n    uint256 interest = IVaultTracker(markets[p][u][m].vaultTracker).redeemInterest(t);\n\n    emit RedeemVaultInterest(p, u, m, t);\n\n    return interest;\n  }\n\n  /// @notice Calculates the total amount of underlying returned including interest generated since the `matureMarket` function has been called\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function calculateReturn(uint8 p, address u, uint256 m, uint256 a) internal view returns (uint256) {\n    Market memory market = markets[p][u][m];\n\n    uint256 exchangeRate = Compounding.exchangeRate(p, market.cTokenAddr);\n\n    return (a * exchangeRate) / market.maturityRate;\n  }\n\n  /// @notice Return the compounding token address for a given market\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function cTokenAddress(uint8 p, address u, uint256 m) external view returns (address) {\n    Market memory market = markets[p][u][m];\n    return market.cTokenAddr;\n  }\n\n  /// @notice Return the exchangeRate for a given protocol's compounding token\n  /// @param p Protocol Enum value associated with this market\n  /// @param c Compounding token address associated with the market\n  function getExchangeRate(uint8 p, address c) external view returns (uint256) {\n      return Compounding.exchangeRate(p, c);\n  }\n\n  /// @notice Called by swivel IVFZI && IZFVI\n  /// @dev Call with protocol, underlying, maturity, mint-target, add-notional-target and an amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param z Recipient of the minted zcToken\n  /// @param n Recipient of the added notional\n  /// @param a Amount of zcToken minted and notional added\n  function custodialInitiate(uint8 p, address u, uint256 m, address z, address n, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n    if (!IZcToken(market.zcToken).mint(z, a)) { revert Exception(28, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).addNotional(n, a)) { revert Exception(25, 0, 0, address(0), address(0)); }\n\n    emit CustodialInitiate(p, u, m, z, n, a);\n    return true;\n  }\n\n  /// @notice Called by swivel EVFZE FF EZFVE\n  /// @dev Call with protocol, underlying, maturity, burn-target, remove-notional-target and an amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param z Owner of the zcToken to be burned\n  /// @param n Target to remove notional from\n  /// @param a Amount of zcToken burned and notional removed\n  function custodialExit(uint8 p, address u, uint256 m, address z, address n, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n    if (!IZcToken(market.zcToken).burn(z, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    if (!IVaultTracker(market.vaultTracker).removeNotional(n, a)) { revert Exception(26, 0, 0, address(0), address(0)); }\n\n    emit CustodialExit(p, u, m, z, n, a);\n    return true;\n  }\n\n  /// @notice Called by swivel IZFZE, EZFZI\n  /// @dev Call with underlying, maturity, transfer-from, transfer-to, amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Owner of the zcToken to be burned\n  /// @param t Target to be minted to\n  /// @param a Amount of zcToken transfer\n  function p2pZcTokenExchange(uint8 p, address u, uint256 m, address f, address t, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    Market memory market = markets[p][u][m];\n    if (!IZcToken(market.zcToken).burn(f, a)) { revert Exception(29, 0, 0, address(0), address(0)); }\n\n    if (!IZcToken(market.zcToken).mint(t, a)) { revert Exception(28, 0, 0, address(0), address(0)); }\n\n    emit P2pZcTokenExchange(p, u, m, f, t, a);\n    return true;\n  }\n\n  /// @notice Called by swivel IVFVE, EVFVI\n  /// @dev Call with protocol, underlying, maturity, remove-from, add-to, amount\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Owner of the notional to be transferred\n  /// @param t Target to be transferred to\n  /// @param a Amount of notional transfer\n  function p2pVaultExchange(uint8 p, address u, uint256 m, address f, address t, uint256 a) external authorized(swivel) unpaused(p) returns (bool) {\n    if (!IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFrom(f, t, a)) { revert Exception(27, 0, 0, address(0), address(0)); }\n\n    emit P2pVaultExchange(p, u, m, f, t, a);\n    return true;\n  }\n\n  /// @notice External method giving access to this functionality within a given vault\n  /// @dev Note that this method calculates yield and interest as well\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param t Target to be transferred to\n  /// @param a Amount of notional to be transferred\n  function transferVaultNotional(uint8 p, address u, uint256 m, address t, uint256 a) external unpaused(p) returns (bool) {\n    if (!IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFrom(msg.sender, t, a)) { revert Exception(27, 0, 0, address(0), address(0)); }\n\n    emit TransferVaultNotional(p, u, m, msg.sender, t, a);\n    return true;\n  }\n\n  /// @notice Transfers notional fee to the Swivel contract without recalculating marginal interest for from\n  /// @param p Protocol Enum value associated with this market\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param f Owner of the amount\n  /// @param a Amount to transfer\n  function transferVaultNotionalFee(uint8 p, address u, uint256 m, address f, uint256 a) external authorized(swivel) returns (bool) {\n    IVaultTracker(markets[p][u][m].vaultTracker).transferNotionalFee(f, a);\n    return true;\n  }\n\n  /// @notice Called by admin at any point to pause / unpause market transactions in a specified protocol\n  /// @param p Protocol Enum value of the protocol to be paused\n  /// @param b Boolean which indicates the (protocol) markets paused status\n  function pause(uint8 p, bool b) external authorized(admin) returns (bool) {\n    paused[p] = b;\n    return true;\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n\n  modifier unpaused(uint8 p) {\n    if(paused[p]) { revert Exception(1, 0, 0, address(0), address(0)); }\n    _;\n  }\n}\n\n\n",
        "CodeNames": [
            "MarketPlace.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MarketPlace.authRedeem function",
                "Type": "Interface definition error",
                "Description": "MarketPlace.authRedeem call interface ISwivel.authRedeem but Swivel contract does not have this method only method authRedeemZcToken().",
                "Repair": "Declare 'is ISwivel' in Swivel contract and change method name to authRedeem"
            }
        ]
    }
]