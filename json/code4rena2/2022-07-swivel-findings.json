[
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Compounding.sol';\n\ncontract VaultTracker {\n  /// @notice A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n\n  struct Vault {\n    uint256 notional;\n    uint256 redeemable;\n    uint256 exchangeRate;\n  }\n\n  mapping(address => Vault) public vaults;\n\n  address public immutable admin;\n  address public immutable cTokenAddr;\n  address public immutable swivel;\n  uint256 public immutable maturity;\n  uint256 public maturityRate;\n  uint8 public immutable protocol;\n\n  /// @param m Maturity timestamp associated with this vault\n  /// @param c Compounding Token address associated with this vault\n  /// @param s Address of the deployed swivel contract\n  constructor(uint8 p, uint256 m, address c, address s) {\n    admin = msg.sender;\n    protocol = p;\n    maturity = m;\n    cTokenAddr = c;\n    swivel = s;\n\n    // instantiate swivel's vault (unblocking transferNotionalFee)\n    vaults[s] = Vault({\n      notional: 0,\n      redeemable: 0,\n      exchangeRate: Compounding.exchangeRate(p, c)\n    });\n  }\n\n  /// @notice Adds notional to a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional added\n  function addNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    Vault memory vlt = vaults[o];\n\n    if (vlt.notional > 0) {\n      uint256 yield;\n\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { // Calculate marginal interest\n        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n      }\n\n      uint256 interest = (yield * vlt.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      vlt.redeemable += interest;\n      vlt.notional += a;\n    } else {\n      vlt.notional = a;\n    }\n\n    vlt.exchangeRate = exchangeRate;\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Removes notional from a given address\n  /// @param o Address that owns a vault\n  /// @param a Amount of notional to remove\n  function removeNotional(address o, uint256 a) external authorized(admin) returns (bool) {\n\n    Vault memory vlt = vaults[o];\n\n    if (a > vlt.notional) { revert Exception(31, a, vlt.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    vlt.redeemable += interest;\n    vlt.notional -= a;\n    vlt.exchangeRate = exchangeRate;\n\n    vaults[o] = vlt;\n\n    return true;\n  }\n\n  /// @notice Redeem's interest accrued by a given address\n  /// @param o Address that owns a vault\n  function redeemInterest(address o) external authorized(admin) returns (uint256) {\n\n    Vault memory vlt = vaults[o];\n\n    uint256 redeemable = vlt.redeemable;\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { // Calculate marginal interest\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\n    } else {\n      // calculate marginal interest\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * vlt.notional) / 1e26;\n\n    vlt.exchangeRate = exchangeRate;\n    vlt.redeemable = 0;\n\n    vaults[o] = vlt;\n\n    // return adds marginal interest to previously accrued redeemable interest\n    return (redeemable + interest);\n  }\n\n  /// @notice Matures the vault\n  /// @param c The current cToken exchange rate\n  function matureVault(uint256 c) external authorized(admin) returns (bool) {\n    maturityRate = c;\n    return true;\n  }\n\n  /// @notice Transfers notional from one address to another\n  /// @param f Owner of the amount\n  /// @param t Recipient of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFrom(address f, address t, uint256 a) external authorized(admin) returns (bool) {\n    if (f == t) { revert Exception(32, 0, 0, f, t); }\n\n    Vault memory from = vaults[f];\n    Vault memory to = vaults[t];\n\n    if (a > from.notional) { revert Exception(31, a, from.notional, address(0), address(0)); }\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n    uint256 yield;\n    if (maturityRate > 0) { \n      // calculate marginal interest\n      yield = ((maturityRate * 1e26) / from.exchangeRate) - 1e26;\n    } else {\n      yield = ((exchangeRate * 1e26) / from.exchangeRate) - 1e26;\n    }\n\n    uint256 interest = (yield * from.notional) / 1e26;\n    // remove amount from position, Add interest to position, reset cToken exchange rate\n    from.redeemable += interest;\n    from.notional -= a;\n    from.exchangeRate = exchangeRate;\n\n    vaults[f] = from;\n\n    // transfer notional to address \"t\", calculate interest if necessary\n    if (to.notional > 0) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n        yield = ((maturityRate * 1e26) / to.exchangeRate) - 1e26;\n      } else {\n        yield = ((exchangeRate * 1e26) / to.exchangeRate) - 1e26;\n      }\n\n      uint256 newVaultInterest = (yield * to.notional) / 1e26;\n      // add interest and amount to position, reset cToken exchange rate\n      to.redeemable += newVaultInterest;\n      to.notional += a;\n    } else {\n      to.notional = a;\n    }\n\n    to.exchangeRate = exchangeRate;\n    vaults[t] = to;\n\n    return true;\n  }\n\n  /// @notice Transfers, in notional, a fee payment to the Swivel contract without recalculating marginal interest for the owner\n  /// @param f Owner of the amount\n  /// @param a Amount to transfer\n  function transferNotionalFee(address f, uint256 a) external authorized(admin) returns(bool) {\n    Vault memory oVault = vaults[f];\n    Vault memory sVault = vaults[swivel];\n\n    // remove notional from its owner\n    oVault.notional -= a;\n\n    uint256 exchangeRate = Compounding.exchangeRate(protocol, cTokenAddr);\n\n    // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate\n    uint256 yield;\n    if (sVault.exchangeRate != exchangeRate) {\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\n      if (maturityRate > 0) { \n        // calculate marginal interest\n          yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;\n      } else {\n          yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;\n      }\n      uint256 interest = (yield * sVault.notional) / 1e26;\n      // add interest and amount, reset cToken exchange rate\n      sVault.redeemable += interest;\n      sVault.exchangeRate = exchangeRate;\n    }\n    // add notional to swivel's vault\n    sVault.notional += a;\n    // store the adjusted vaults\n    vaults[swivel] = sVault;\n    vaults[f] = oVault;\n    return true;\n  }\n\n  /// @notice Returns both relevant balances for a given user's vault\n  /// @param o Address that owns a vault\n  function balancesOf(address o) external view returns (uint256, uint256) {\n    Vault memory vault = vaults[o];\n    return (vault.notional, vault.redeemable);\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n}\n\n\n",
        "CodeNames": [
            "VaultTracker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "VaultTracker.sol",
                "Type": "Incorrect assumption",
                "Description": "The vulnerability stems from an incorrect assumption that the exchange rate of the underlying protocol never decreases, which can lead to loss of all user funds in the event of a loss of funds in the underlying protocol.",
                "Repair": "Add require(block.timestamp < m) in SplitUnderlying and add vlt.notional = 0 after L124 in redeemInterest"
            },
            {
                "Location": "VaultTracker.sol",
                "Type": "Reentrancy",
                "Description": "With most functions in VaultTracker.sol, users can call them only once after maturity has been reached. However, if vlt.exchangeRate is larger than maturityRate after maturity, it will revert from the second call with uint underflow error, which can lead to loss of funds or interests.",
                "Repair": "Save vlt.exchangeRate = maturityRate when maturityRate > 0 and exchangeRate > maturityRate"
            },
            {
                "Location": "Functions within VaultTracker that calculate interest",
                "Type": "Interest calculation issue",
                "Description": "VaultTracker neglect previously accrued interest while attempting to calculate new interest. This causes nToken holders to receive less yield than they should.",
                "Repair": "For all interest calculations, use vlt.notional + vlt.redeemable instead of just vlt.notional as yield base."
            },
            {
                "Location": "VaultTracker constructor",
                "Type": "Admin error",
                "Description": "The VaultTracker contract takes msg.sender as the admin, which is the address of the creator contract. However, the creator contract is not able (and not supposed to) interact with the VaultTracker unlike the marketplace contract.",
                "Repair": "Modify the constructor of the VaultTracker contract so that the creator contract can pass in msg.sender (MarketPlace\u2019s address) to be used as admin"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "permit() function in ERC20.sol",
                "Type": "Unlimited approval",
                "Description": "The incorrect check on returnedAddress in permit() function results in unlimited approval of zero address.",
                "Repair": "Change the custom error in permit() function to correctly handle the case when recoveredAddress is 0x0"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Protocols.sol'; // NOTE: if size restrictions become extreme we can use ints (implicit enum)\nimport './LibCompound.sol';\nimport './LibFuse.sol';\n\ninterface IErc4626 {\n  /// @dev Converts the given 'assets' (uint256) to 'shares', returning that amount\n  function convertToAssets(uint256) external view returns (uint256);\n}\n\ninterface ICompoundToken {\n  function exchangeRateCurrent() external view returns(uint256);\n}\n\ninterface IYearnVault {\n  function pricePerShare() external view returns (uint256);\n}\n\ninterface IAavePool {\n   /// @dev Returns the normalized income of the reserve given the address of the underlying asset of the reserve\n  function getReserveNormalizedIncome(address) external view returns (uint256);\n}\n\ninterface IAaveToken {\n  function POOL() external view returns (address);\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n\ninterface IEulerToken {\n  /// @notice Convert an eToken balance to an underlying amount, taking into account current exchange rate\n  function convertBalanceToUnderlying(uint256) external view returns(uint256);\n}\n\nlibrary Compounding {\n  /// @param p Protocol Enum value\n  /// @param c Compounding token address\n  function exchangeRate(uint8 p, address c) internal view returns (uint256) {\n    if (p == uint8(Protocols.Compound)) {\n      return LibCompound.viewExchangeRate(ICERC20(c));\n    } else if (p == uint8(Protocols.Rari)) { \n      return LibFuse.viewExchangeRate(ICERC20(c));\n    } else if (p == uint8(Protocols.Yearn)) {\n      return IYearnVault(c).pricePerShare();\n    } else if (p == uint8(Protocols.Aave)) {\n      IAaveToken aToken = IAaveToken(c);\n      return IAavePool(aToken.POOL()).getReserveNormalizedIncome(aToken.UNDERLYING_ASSET_ADDRESS());\n    } else if (p == uint8(Protocols.Euler)) {\n      // NOTE: the 1e26 const is a degree of precision to enforce on the return\n      return IEulerToken(c).convertBalanceToUnderlying(1e26);\n    } else {\n      // NOTE: the 1e26 const is a degree of precision to enforce on the return\n      return IErc4626(c).convertToAssets(1e26);\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "Compounding.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Yearn vault integration in Compounding.sol",
                "Type": "Integration issue",
                "Description": "Yearn integration is broken, making it impossible to create a MarketPlace associated with a Yearn vault.",
                "Repair": "Access the underlying token of a Yearn vault through the token property instead of the non-existent underlying which will cause a revert and the inability to create marketplaces associated with the protocol."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Erc20.sol\";\nimport \"./Compounding.sol\";\nimport \"./IERC5095.sol\";  \nimport \"./IRedeemer.sol\";\n\n// Utilizing an external custody contract to allow for backwards compatability with some projects.\n// Assumes interest generated post maturity using an internal Compounding library.\ncontract ZcToken is Erc20, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public override immutable maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public override immutable underlying;\n    /// @dev uint8 associated with a given protocol in Swivel\n    uint8 public immutable protocol;\n    \n    /////////////OPTIONAL///////////////// (Allows the calculation and distribution of yield post maturity)\n    /// @dev address of a cToken\n    address public immutable cToken;\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    IRedeemer public immutable redeemer;\n\n    error Maturity(uint256 timestamp);  \n\n    error Approvals(uint256 approved, uint256 amount);\n\n    error Authorized(address owner);\n\n    constructor(uint8 _protocol, address _underlying, uint256 _maturity, address _cToken, address _redeemer, string memory _name, string memory _symbol, uint8 _decimals) \n    Erc20( _name, _symbol, _decimals) {\n        protocol = _protocol;\n        underlying = _underlying;\n        maturity = _maturity;\n        cToken = _cToken;\n        redeemer = IRedeemer(_redeemer);\n    }\n\n    /// @notice Post maturity converts an amount of principal tokens to an amount of underlying that would be returned. Returns 0 pre-maturity.\n    /// @param principalAmount The amount of principal tokens to convert\n    /// @return underlyingAmount The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity converts a desired amount of underlying tokens returned to principal tokens needed. Returns 0 pre-maturity.\n    /// @param underlyingAmount The amount of underlying tokens to convert\n    /// @return principalAmount The amount of principal tokens returned by the conversion\n    function convertToPrincipal(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount * IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));\n    }\n    /// @notice Post maturity calculates the amount of principal tokens that `owner` can redeem. Returns 0 pre-maturity.\n    /// @param owner The address of the owner for which redemption is calculated\n    /// @return maxPrincipalAmount The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address owner) external override view returns (uint256 maxPrincipalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (balanceOf[owner]);\n    }\n    /// @notice Post maturity simulates the effects of redeemption at the current block. Returns 0 pre-maturity.\n    /// @param principalAmount the amount of principal tokens redeemed in the simulation\n    /// @return underlyingAmount The maximum amount of underlying returned by `principalAmount` of PT redemption\n    function previewRedeem(uint256 principalAmount) external override view returns (uint256 underlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (principalAmount * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity calculates the amount of underlying tokens that `owner` can withdraw. Returns 0 pre-maturity.\n    /// @param  owner The address of the owner for which withdrawal is calculated\n    /// @return maxUnderlyingAmount The maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address owner) external override view returns (uint256 maxUnderlyingAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (balanceOf[owner] * IRedeemer(redeemer).getExchangeRate(protocol, cToken) / IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate);\n    }\n    /// @notice Post maturity simulates the effects of withdrawal at the current block. Returns 0 pre-maturity.\n    /// @param underlyingAmount the amount of underlying tokens withdrawn in the simulation\n    /// @return principalAmount The amount of principal tokens required for the withdrawal of `underlyingAmount`\n    function previewWithdraw(uint256 underlyingAmount) external override view returns (uint256 principalAmount){\n        if (block.timestamp < maturity) {\n            return 0;\n        }\n        return (underlyingAmount * IRedeemer(redeemer).markets(protocol, underlying, maturity).maturityRate / IRedeemer(redeemer).getExchangeRate(protocol, cToken));\n    }\n    /// @notice At or after maturity, Burns principalAmount from `owner` and sends exactly `underlyingAmount` of underlying tokens to `receiver`.\n    /// @param underlyingAmount The amount of underlying tokens withdrawn\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return principalAmount The amount of principal tokens burnt by the withdrawal\n    function withdraw(uint256 underlyingAmount, address receiver, address holder) external override returns (uint256 principalAmount){\n        uint256 previewAmount = this.previewWithdraw(underlyingAmount);\n        // If maturity is not yet reached\n        if (block.timestamp < maturity) {\n            revert Maturity(maturity);\n        }\n        // Transfer logic\n        // If holder is msg.sender, skip approval check\n        if (holder == msg.sender) {\n            redeemer.authRedeem(protocol, underlying, maturity, msg.sender, receiver, previewAmount);\n            return previewAmount;\n        }\n        else {\n            uint256 allowed = allowance[holder][msg.sender];\n            if (allowed >= previewAmount) {\n                revert Approvals(allowed, previewAmount);\n            }\n            allowance[holder][msg.sender] -= previewAmount;\n            redeemer.authRedeem(protocol, underlying, maturity, holder, receiver, previewAmount); \n            return previewAmount;\n        }\n    }\n    /// @notice At or after maturity, burns exactly `principalAmount` of Principal Tokens from `owner` and sends underlyingAmount of underlying tokens to `receiver`.\n    /// @param principalAmount The amount of principal tokens being redeemed\n    /// @param receiver The receiver of the underlying tokens being withdrawn\n    /// @return underlyingAmount The amount of underlying tokens distributed by the redemption\n    function redeem(uint256 principalAmount, address receiver, address holder) external override returns (uint256 underlyingAmount){\n        // If maturity is not yet reached\n        if (block.timestamp < maturity) { revert Maturity(maturity); }\n        // some 5095 tokens may have custody of underlying and can can just burn PTs and transfer underlying out, while others rely on external custody\n        if (holder == msg.sender) {\n            return redeemer.authRedeem(protocol, underlying, maturity, msg.sender, receiver, principalAmount);\n        }\n        else {\n            uint256 allowed = allowance[holder][msg.sender];\n            if (allowed >= principalAmount) { revert Approvals(allowed, principalAmount); }\n            allowance[holder][msg.sender] -= principalAmount;  \n            return redeemer.authRedeem(protocol, underlying, maturity, holder, receiver, principalAmount);\n        }\n    }\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    function burn(address f, uint256 a) external onlyAdmin(address(redeemer)) returns (bool) {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    function mint(address t, uint256 a) external onlyAdmin(address(redeemer)) returns (bool) {\n        _mint(t, a);\n        return true;\n    }\n\n    modifier onlyAdmin(address a) {\n    if (msg.sender != a) { revert Authorized(a); }\n    _;\n  }\n}\n\n\n",
        "CodeNames": [
            "ZcToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "ZcToken.sol",
                "Type": "Error in allowance logic",
                "Description": "There is an error in the allowance functionality to allow a non-owner to withdraw or redeem ZcTokens for the owner.",
                "Repair": "Change '=' to '<' in the if statement"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\nimport './Interfaces.sol';\nimport './Protocols.sol';\nimport './Hash.sol';\nimport './Sig.sol';\nimport './Safe.sol';\n\ncontract Swivel {\n  /// @dev A single custom error capable of indicating a wide range of detected errors by providing\n  /// an error code value whose string representation is documented <here>, and any possible other values\n  /// that are pertinent to the error.\n  error Exception(uint8, uint256, uint256, address, address);\n  /// @dev maps the key of an order to a boolean indicating if an order was cancelled\n  mapping (bytes32 => bool) public cancelled;\n  /// @dev maps the key of an order to an amount representing its taken volume\n  mapping (bytes32 => uint256) public filled;\n  /// @dev maps a token address to a point in time, a hold, after which a withdrawal can be made\n  mapping (address => uint256) public withdrawals;\n  /// @dev maps a token address to a point in time, a hold, after which an approval can be made\n  mapping (address => uint256) public approvals;\n\n  string constant public NAME = 'Swivel Finance';\n  string constant public VERSION = '3.0.0';\n  uint256 constant public HOLD = 3 days;\n  bytes32 public immutable domain;\n  address public immutable marketPlace;\n  address public admin;\n  \n  /// @dev address of a deployed Aave contract implementing IAave\n  address public aaveAddr; // TODO immutable?\n\n  uint16 constant public MIN_FEENOMINATOR = 33;\n  /// @dev holds the fee demoninators for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit]\n  uint16[4] public feenominators;\n  /// @dev A point in time, a hold, after which a change to Fees\n  uint256 public feeChange;\n\n  /// @notice Emitted on order cancellation\n  event Cancel (bytes32 indexed key, bytes32 hash);\n  /// @notice Emitted on any initiate*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Initiate(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on any exit*\n  /// @dev filled is 'principalFilled' when (vault:false, exit:false) && (vault:true, exit:true)\n  /// @dev filled is 'premiumFilled' when (vault:true, exit:false) && (vault:false, exit:true)\n  event Exit(bytes32 indexed key, bytes32 hash, address indexed maker, bool vault, bool exit, address indexed sender, uint256 amount, uint256 filled);\n  /// @notice Emitted on token withdrawal scheduling\n  event ScheduleWithdrawal(address indexed token, uint256 hold);\n  /// @notice Emitted on token withdrawal blocking\n  event BlockWithdrawal(address indexed token);\n  /// @notice Emitted on a change to the feenominators array\n  event SetFee(uint256 indexed index, uint256 indexed feenominator);\n  /// @notice Emitted on a token approval scheduling\n  event ScheduleApproval(address indexed token, uint256 hold);\n  /// @notice Emitted on a token approval blocking\n  event BlockApproval(address indexed token);\n  /// @notice Emitted on a fee change scheduling\n  event ScheduleFeeChange(uint256 hold);\n  /// @notice Emitted on a fee change blocking\n  event BlockFeeChange();\n\n  /// @param m Deployed MarketPlace contract address\n  /// @param a Address of a deployed Aave contract implementing our interface\n  constructor(address m, address a) {\n    admin = msg.sender;\n    domain = Hash.domain(NAME, VERSION, block.chainid, address(this));\n    marketPlace = m;\n    aaveAddr = a;\n    feenominators = [200, 600, 400, 200];\n  }\n\n  // ********* INITIATING *************\n\n  /// @notice Allows a user to initiate a position\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Array of Components from valid ECDSA signatures\n  function initiate(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i < len;) {\n      Hash.Order memory order = o[i];\n      if (!order.exit) {\n        if (!order.vault) {\n          initiateVaultFillingZcTokenInitiate(o[i], a[i], c[i]);\n        } else {\n          initiateZcTokenFillingVaultInitiate(o[i], a[i], c[i]);\n        }\n      } else {\n        if (!order.vault) {\n          initiateZcTokenFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          initiateVaultFillingVaultExit(o[i], a[i], c[i]);\n        }\n      }\n      unchecked {i++;}\n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (premium) being filled by the taker's initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    // checks order signature, order cancellation and order expiry\n    bytes32 hash = validOrderHash(o, c);\n\n    // checks the side, and the amount compared to available\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n    \n    // TODO cheaper to assign amount here or keep the ADD?\n    filled[hash] += a;\n\n    // transfer underlying tokens\n    IErc20 uToken = IErc20(o.underlying);\n    Safe.transferFrom(uToken, msg.sender, o.maker, a);\n\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    Safe.transferFrom(uToken, o.maker, address(this), principalFilled);\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n\n    // perform the actual deposit type transaction, specific to a protocol\n    if (!deposit(o.protocol, o.underlying, cTokenAddr, principalFilled)) { revert Exception(6, 0, 0, address(0), address(0)); }\n\n    // alert marketplace\n    if (!mPlace.custodialInitiate(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, principalFilled)) { revert Exception(8, 0, 0, address(0), address(0)); }\n\n    // transfer fee in vault notional to swivel (from msg.sender)\n    uint256 fee = principalFilled / feenominators[2];\n    if (!mPlace.transferVaultNotionalFee(o.protocol, o.underlying, o.maturity, msg.sender, fee)) { revert Exception(10, 0, 0, address(0), address(0)); }\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's initiate\n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    IErc20 uToken = IErc20(o.underlying);\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\n\n    // transfer principal + fee in underlying to swivel (from sender)\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), (a + fee));\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n\n    // perform the actual deposit type transaction, specific to a protocol\n    if(!deposit(o.protocol, o.underlying, cTokenAddr, a)) { revert Exception(6, 0, 0, address(0), address(0)); }\n\n    // alert marketplace \n    if (!mPlace.custodialInitiate(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, a)) { revert Exception(8, 0, 0, address(0), address(0)); }\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate zcToken? by filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's initiate \n  /// @param c Components of a valid ECDSA signature\n  function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n\n    IErc20 uToken = IErc20(o.underlying);\n    // transfer underlying tokens, then take fee\n    Safe.transferFrom(uToken, msg.sender, o.maker, a - premiumFilled);\n\n    uint256 fee = premiumFilled / feenominators[0];\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // alert marketplace\n    if (!IMarketPlace(marketPlace).p2pZcTokenExchange(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, a)) { revert Exception(11, 0, 0, address(0), address(0)); }\n            \n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to initiate a Vault by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, principalFilled) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function initiateVaultFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n\n    // TODO assign amount or keep ADD?\n    filled[hash] += a;\n\n    Safe.transferFrom(IErc20(o.underlying), msg.sender, o.maker, a);\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    // alert marketplace\n    if (!mPlace.p2pVaultExchange(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, principalFilled)) { revert Exception(12, 0, 0, address(0), address(0)); }\n\n    // transfer fee (in vault notional) to swivel\n    uint256 fee = principalFilled / feenominators[2];\n    if (!mPlace.transferVaultNotionalFee(o.protocol, o.underlying, o.maturity, msg.sender, fee)) { revert Exception(10, 0, 0, address(0), address(0)); }\n\n    emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  // ********* EXITING ***************\n\n  /// @notice Allows a user to exit (sell) a currently held position to the marketplace.\n  /// @param o Array of offline Swivel.Orders\n  /// @param a Array of order volume (principal) amounts relative to passed orders\n  /// @param c Components of a valid ECDSA signature\n  function exit(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    // for each order filled, routes the order to the right interaction depending on its params\n    for (uint256 i; i < len;) {\n      Hash.Order memory order = o[i];\n      // if the order being filled is not an exit\n      if (!order.exit) {\n        // if the order being filled is a vault initiate or a zcToken initiate\n          if (!order.vault) {\n            // if filling a zcToken initiate with an exit, one is exiting zcTokens\n            exitZcTokenFillingZcTokenInitiate(o[i], a[i], c[i]);\n          } else {\n            // if filling a vault initiate with an exit, one is exiting vault notional\n            exitVaultFillingVaultInitiate(o[i], a[i], c[i]);\n          }\n      } else {\n        // if the order being filled is a vault exit or a zcToken exit\n        if (!order.vault) {\n          // if filling a zcToken exit with an exit, one is exiting vault\n          exitVaultFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          // if filling a vault exit with an exit, one is exiting zcTokens\n          exitZcTokenFillingVaultExit(o[i], a[i], c[i]);\n        }   \n      }\n      unchecked {i++;}\n    }\n\n    return true;\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline zcToken initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.p2pZcTokenExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitZcTokenFillingZcTokenInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;       \n\n    IErc20 uToken = IErc20(o.underlying);\n\n    uint256 principalFilled = (a * o.principal) / o.premium;\n    // transfer underlying from initiating party to exiting party, minus the price the exit party pays for the exit (premium), and the fee.\n    Safe.transferFrom(uToken, o.maker, msg.sender, principalFilled - a);\n\n    // transfer fee in underlying to swivel\n    uint256 fee = principalFilled / feenominators[1];\n\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // alert marketplace\n    if (!IMarketPlace(marketPlace).p2pZcTokenExchange(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, principalFilled)) { revert Exception(11, 0, 0, address(0), address(0)); }\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n  \n  /// @notice Allows a user to exit their Vault by filling an offline vault initiate order\n  /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.p2pVaultExchange\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n    \n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n        \n    IErc20 uToken = IErc20(o.underlying);\n\n    // transfer premium from maker to sender\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transferFrom(uToken, o.maker, msg.sender, premiumFilled);\n\n    uint256 fee = premiumFilled / feenominators[3];\n    // transfer fee in underlying to swivel from sender\n    Safe.transferFrom(uToken, msg.sender, address(this), fee);\n\n    // transfer <a> notional from sender to maker\n    if (!IMarketPlace(marketPlace).p2pVaultExchange(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, a)) { revert Exception(12, 0, 0, address(0), address(0)); }\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to exit their Vault filling an offline zcToken exit order\n  /// @dev This method should pass (underlying, maturity, maker, sender, a) to MarketPlace.exitFillingExit\n  /// @param o Order being filled\n  /// @param a Amount of volume (principal) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitVaultFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.principal) { revert Exception(5, amount, o.principal, address(0), address(0)); }\n\n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    // redeem underlying on Compound and burn cTokens\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n\n    if (!withdraw(o.protocol, o.underlying, cTokenAddr, a)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    IErc20 uToken = IErc20(o.underlying);\n    // transfer principal-premium  back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uint256 premiumFilled = (a * o.premium) / o.principal;\n    Safe.transfer(uToken, o.maker, a - premiumFilled);\n\n    // transfer premium-fee to floating exit party\n    uint256 fee = premiumFilled / feenominators[3];\n    Safe.transfer(uToken, msg.sender, premiumFilled - fee);\n\n    // burn zcTokens + nTokens from o.maker and msg.sender respectively\n    if (!mPlace.custodialExit(o.protocol, o.underlying, o.maturity, o.maker, msg.sender, a)) { revert Exception(9, 0, 0, address(0), address(0)); }\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  /// @notice Allows a user to exit their zcTokens by filling an offline vault exit order\n  /// @dev This method should pass (underlying, maturity, sender, maker, principalFilled) to MarketPlace.exitFillingExit\n  /// @param o Order being filled\n  /// @param a Amount of volume (interest) being filled by the taker's exit\n  /// @param c Components of a valid ECDSA signature\n  function exitZcTokenFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n    uint256 amount = a + filled[hash];\n\n    if (amount > o.premium) { revert Exception(5, amount, o.premium, address(0), address(0)); }\n    \n    // TODO assign amount or keep the ADD?\n    filled[hash] += a;\n\n    // redeem underlying on Compound and burn cTokens\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.protocol, o.underlying, o.maturity);\n    uint256 principalFilled = (a * o.principal) / o.premium;\n\n    if (!withdraw(o.protocol, o.underlying, cTokenAddr, principalFilled)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    IErc20 uToken = IErc20(o.underlying);\n    // transfer principal-premium-fee back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uint256 fee = principalFilled / feenominators[1];\n    Safe.transfer(uToken, msg.sender, principalFilled - a - fee);\n    Safe.transfer(uToken, o.maker, a);\n\n    // burn <principalFilled> zcTokens + nTokens from msg.sender and o.maker respectively\n    if (!mPlace.custodialExit(o.protocol, o.underlying, o.maturity, msg.sender, o.maker, principalFilled)) { revert Exception(9, 0, 0, address(0), address(0)); }\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n  /// @notice Allows a user to cancel an order, preventing it from being filled in the future\n  /// @param o Order being cancelled\n  /// @param c Components of a valid ECDSA signature\n  function cancel(Hash.Order[] calldata o, Sig.Components[] calldata c) external returns (bool) {\n    uint256 len = o.length;\n    for (uint256 i; i < len;) {\n      bytes32 hash = validOrderHash(o[i], c[i]);\n      if (msg.sender != o[i].maker) { revert Exception(15, 0, 0, msg.sender, o[i].maker); }\n\n      cancelled[hash] = true;\n\n      emit Cancel(o[i].key, hash);\n\n      unchecked {\n        i++;\n      }\n    }\n\n    return true;\n  }\n\n  // ********* ADMINISTRATIVE ***************\n\n  /// @param a Address of a new admin\n  function setAdmin(address a) external authorized(admin) returns (bool) {\n    admin = a;\n\n    return true;\n  }\n\n  /// @notice Allows the admin to schedule the withdrawal of tokens\n  /// @param e Address of (erc20) token to withdraw\n  function scheduleWithdrawal(address e) external authorized(admin) returns (bool) {\n    uint256 when = block.timestamp + HOLD;\n    withdrawals[e] = when;\n\n    emit ScheduleWithdrawal(e, when);\n\n    return true;\n  }\n\n  /// @notice Emergency function to block unplanned withdrawals\n  /// @param e Address of token withdrawal to block\n  function blockWithdrawal(address e) external authorized(admin) returns (bool) {\n      withdrawals[e] = 0;\n\n      emit BlockWithdrawal(e);\n\n      return true;\n  }\n\n  /// @notice Allows the admin to withdraw the given token, provided the holding period has been observed\n  /// @param e Address of token to withdraw\n  function withdraw(address e) external authorized(admin) returns (bool) {\n    uint256 when = withdrawals[e];\n\n    if (when == 0) { revert Exception(16, 0, 0, address(0), address(0)); }\n\n    if (block.timestamp < when) { revert Exception(17, block.timestamp, when, address(0), address(0)); }\n\n    withdrawals[e] = 0;\n\n    IErc20 token = IErc20(e);\n    Safe.transfer(token, admin, token.balanceOf(address(this)));\n\n    return true;\n  }\n\n  /// @notice Allows the admin to schedule the change of fees\n  function scheduleFeeChange() external authorized(admin) returns (bool) {\n    uint256 when = block.timestamp + HOLD;\n    feeChange = when;\n\n    emit ScheduleFeeChange(when);\n\n    return true;\n  }\n\n  /// @notice Emergency function to block unplanned withdrawals\n  function blockFeeChange() external authorized(admin) returns (bool) {\n      feeChange = 0;\n\n      emit BlockFeeChange();\n\n      return true;\n  }\n\n\n  /// @notice Allows the admin to set a new fee denominator\n  /// @param i The index of the new fee denominator\n  /// @param d The new fee denominator\n  function setFee(uint16[] memory i, uint16[] memory d) external authorized(admin) returns (bool) {\n    uint256 len = i.length;\n\n    if (len != d.length) { revert Exception(19, len, d.length, address(0), address(0)); }\n\n    if (feeChange == 0) { revert Exception(16, 0, 0, address(0), address(0)); }\n\n    if (block.timestamp < feeChange) { revert Exception(17, block.timestamp, feeChange, address(0), address(0)); }\n\n    for (uint256 x; x < len;) {\n      if (d[x] < MIN_FEENOMINATOR) { revert Exception(18, uint256(d[x]), 0, address(0), address(0)); }\n\n      feenominators[x] = d[x];\n      emit SetFee(i[x], d[x]);\n\n      unchecked {\n        x++;\n      }\n    }\n\n    feeChange = 0;\n\n    return true;\n  }\n\n  /// @notice Allows the admin to schedule the approval of tokens\n  /// @param e Address of (erc20) token to withdraw\n  function scheduleApproval(address e) external authorized(admin) returns (bool) {\n    uint256 when = block.timestamp + HOLD;\n    approvals[e] = when;\n\n    emit ScheduleApproval(e, when);\n\n    return true;\n  }\n\n  /// @notice Emergency function to block unplanned withdrawals\n  /// @param e Address of token approval to block\n  function blockApproval(address e) external authorized(admin) returns (bool) {\n      approvals[e] = 0;\n\n      emit BlockApproval(e);\n\n      return true;\n  }\n\n  /// @notice Allows the admin to bulk approve given compound addresses at the underlying token, saving marginal approvals\n  /// @param u array of underlying token addresses\n  /// @param c array of compound token addresses\n  function approveUnderlying(address[] calldata u, address[] calldata c) external authorized(admin) returns (bool) {\n    uint256 len = u.length;\n\n    if (len != c.length) { revert Exception(19, len, c.length, address(0), address(0)); }\n\n    uint256 max = 2**256 - 1;\n    uint256 when;\n\n    for (uint256 i; i < len;) {\n      when = approvals[u[i]];\n\n      if (when == 0) { revert Exception(16, 0, 0, address(0), address(0)); }\n\n      if (block.timestamp < when) { revert Exception(17, block.timestamp, when, address(0), address(0));\n      }\n\n      approvals[u[i]] = 0;\n      IErc20 uToken = IErc20(u[i]);\n      Safe.approve(uToken, c[i], max);\n      unchecked {\n        i++;\n      }\n    }\n\n    return true;\n  }\n  // ********* PROTOCOL UTILITY ***************\n\n  /// @notice Allows users to deposit underlying and in the process split it into/mint \n  /// zcTokens and vault notional. Calls mPlace.mintZcTokenAddingNotional\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with this market pair\n  /// @param m Maturity timestamp of this associated market\n  /// @param a Amount of underlying being deposited\n  function splitUnderlying(uint8 p, address u, uint256 m, uint256 a) external returns (bool) {\n    IErc20 uToken = IErc20(u);\n    Safe.transferFrom(uToken, msg.sender, address(this), a);\n\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    \n    // the underlying deposit is directed to the appropriate abstraction\n    if (!deposit(p, u, mPlace.cTokenAddress(p, u, m), a)) { revert Exception(6, 0, 0, address(0), address(0));\n    }\n\n    if (!mPlace.mintZcTokenAddingNotional(p, u, m, msg.sender, a)) { revert Exception(13, 0, 0, address(0), address(0));\n    }\n\n    return true;\n  }\n\n  /// @notice Allows users deposit/burn 1-1 amounts of both zcTokens and vault notional,\n  /// in the process \"combining\" the two, and redeeming underlying. Calls mPlace.burnZcTokenRemovingNotional.\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function combineTokens(uint8 p, address u, uint256 m, uint256 a) external returns (bool) {\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n\n    if (!mPlace.burnZcTokenRemovingNotional(p, u, m, msg.sender, a)) { revert Exception(14, 0, 0, address(0), address(0));\n    }\n\n    if (!withdraw(p, u, mPlace.cTokenAddress(p, u, m), a)) { revert Exception(7, 0, 0, address(0), address(0));\n    }\n\n    Safe.transfer(IErc20(u), msg.sender, a);\n\n    return true;\n  }\n\n  /// @notice Allows users to redeem zcTokens and withdraw underlying, boiling up from the zcToken instead of starting on Swivel\n  /// @notice p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with this market pair\n  /// @param c Compound token address associated with this market pair\n  /// @param t Address of the user receiving the underlying tokens\n  /// @param a Amount of underlying being redeemed\n  function authRedeemZcToken(uint8 p, address u, address c, address t, uint256 a) external authorized(marketPlace) returns(bool) {\n    // redeem underlying from compounding\n    if (!withdraw(p, u, c, a)) { revert Exception(7, 0, 0, address(0), address(0)); }\n    // transfer underlying back to msg.sender\n    Safe.transfer(IErc20(u), t, a);\n\n    return (true);\n  }\n\n  /// @notice Allows zcToken holders to redeem their tokens for underlying tokens after maturity has been reached (via MarketPlace).\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  /// @param a Amount of zcTokens being redeemed\n  function redeemZcToken(uint8 p, address u, uint256 m, uint256 a) external returns (bool) {\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemZcToken(p, u, m, msg.sender, a);\n    // redeem underlying from compounding\n    if (!withdraw(p, u, mPlace.cTokenAddress(p, u, m), redeemed)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    // transfer underlying back to msg.sender\n    Safe.transfer(IErc20(u), msg.sender, redeemed);\n\n    return true;\n  }\n\n  /// @notice Allows Vault owners to redeem any currently accrued interest (via MarketPlace)\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function redeemVaultInterest(uint8 p, address u, uint256 m) external returns (bool) {\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemVaultInterest(p, u, m, msg.sender);\n    // redeem underlying from compounding\n    address cTokenAddr = mPlace.cTokenAddress(p, u, m);\n\n    if (!withdraw(p, u, cTokenAddr, redeemed)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    // transfer underlying back to msg.sender\n    Safe.transfer(IErc20(u), msg.sender, redeemed);\n\n    return true;\n  }\n\n  /// @notice Allows Swivel to redeem any currently accrued interest (via MarketPlace)\n  /// @param p Protocol Enum value associated with this market pair\n  /// @param u Underlying token address associated with the market\n  /// @param m Maturity timestamp of the market\n  function redeemSwivelVaultInterest(uint8 p, address u, uint256 m) external returns (bool) {\n    IMarketPlace mPlace = IMarketPlace(marketPlace);\n    // call marketplace to determine the amount redeemed\n    uint256 redeemed = mPlace.redeemVaultInterest(p, u, m, address(this));\n    // redeem underlying from compounding\n    if (!withdraw(p, u, mPlace.cTokenAddress(p, u, m), redeemed)) { revert Exception(7, 0, 0, address(0), address(0)); }\n\n    // NOTE: for swivel reddem there is no transfer out as there is in redeemVaultInterest\n\n    return true;\n  }\n\n  /// @notice Varifies the validity of an order and it's signature.\n  /// @param o An offline Swivel.Order\n  /// @param c Components of a valid ECDSA signature\n  /// @return the hashed order.\n  function validOrderHash(Hash.Order calldata o, Sig.Components calldata c) internal view returns (bytes32) {\n    bytes32 hash = Hash.order(o);\n\n    if (cancelled[hash]) { revert Exception(2, 0, 0, address(0), address(0)); }\n\n    if (o.expiry < block.timestamp) { revert Exception(3, o.expiry, block.timestamp, address(0), address(0)); }\n\n    address recovered = Sig.recover(Hash.message(domain, hash), c);\n\n    if (o.maker != recovered) { revert Exception(4, 0, 0, o.maker, recovered); }\n\n    return hash;\n  }\n\n  /// @notice Use the Protocol Enum to direct deposit type transactions to their specific library abstraction\n  /// @dev This functionality is an abstraction used by `IVFZI`, `IZFVI` and `splitUnderlying`\n  /// @param p Protocol Enum Value\n  /// @param u Address of an underlying token (used by Aave)\n  /// @param c Compounding token address\n  /// @param a Amount to deposit\n  function deposit(uint8 p, address u, address c, uint256 a) internal returns (bool) {\n    // TODO as stated elsewhere, we may choose to simply return true in all and not attempt to measure against any expected return\n    if (p == uint8(Protocols.Compound)) { // TODO is Rari a drop in here?\n      return ICompound(c).mint(a) == 0;\n    } else if (p == uint8(Protocols.Yearn)) {\n      // yearn vault api states that deposit returns shares as uint256\n      return IYearn(c).deposit(a) >= 0;\n    } else if (p == uint8(Protocols.Aave)) {\n      // Aave deposit is void. NOTE the change in pattern here where our interface is not wrapping a compounding token directly, but\n      // a specified protocol contract whose address we have set\n      // TODO explain the Aave deposit args\n      IAave(aaveAddr).deposit(u, a, address(this), 0);\n      return true;\n    } else if (p == uint8(Protocols.Euler)) {\n      // Euler deposit is void.\n      // TODO explain the 0 (primary account)\n      IEuler(c).deposit(0, a);\n      return true;\n    } else {\n      // we will allow protocol[0] to also function as a catchall for Erc4626\n      // NOTE: deposit, as per the spec, returns 'shares' but it is unknown if 0 would revert, thus we'll check for 0 or greater\n      return IErc4626(c).deposit(a, address(this)) >= 0;\n    }\n  }\n\n  /// @notice Use the Protocol Enum to direct withdraw type transactions to their specific library abstraction\n  /// @dev This functionality is an abstraction used by `EVFZE`, `EZFVE`, `combineTokens`, `redeemZcToken` and `redeemVaultInterest`.\n  /// Note that while there is an external method `withdraw` also on this contract the unique method signatures (and visibility)\n  /// exclude any possible clashing\n  /// @param p Protocol Enum Value\n  /// @param u Address of an underlying token (used by Aave)\n  /// @param c Compounding token address\n  /// @param a Amount to withdraw\n  function withdraw(uint8 p, address u, address c, uint256 a) internal returns (bool) {\n    // TODO as stated elsewhere, we may choose to simply return true in all and not attempt to measure against any expected return\n    if (p == uint8(Protocols.Compound)) { // TODO is Rari a drop in here?\n      return ICompound(c).redeemUnderlying(a) == 0;\n    } else if (p == uint8(Protocols.Yearn)) {\n      // yearn vault api states that withdraw returns uint256\n      return IYearn(c).withdraw(a) >= 0;\n    } else if (p == uint8(Protocols.Aave)) {\n      // Aave v2 docs state that withraw returns uint256\n      // TODO explain the withdraw args\n      return IAave(aaveAddr).withdraw(u, a, address(this)) >= 0;\n    } else if (p == uint8(Protocols.Euler)) {\n      // Euler withdraw is void\n      // TODO explain the 0\n      IEuler(c).withdraw(0, a);\n      return true;\n    } else {\n      // we will allow protocol[0] to also function as a catchall for Erc4626\n      return IErc4626(c).withdraw(a, address(this), address(this)) >= 0;\n    }\n  }\n\n  modifier authorized(address a) {\n    if(msg.sender != a) { revert Exception(0, 0, 0, msg.sender, a); }\n    _;\n  }\n}\n\n\n",
        "CodeNames": [
            "Swivel.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Swivel.sol",
                "Type": "Mismatch in withdraw() between Yearn and other protocols can prevent Users from redeeming zcTokens and permanently lock funds",
                "Description": "The yearn withdraw 'amount' parameter specifies how many 'shares' are burnt instead of underlying assets retrieved.",
                "Repair": "Calculate the price per share and use that to retrieve the correct number of underlying assets"
            },
            {
                "Location": "Swivel.setFee()",
                "Type": "Incorrect implementation",
                "Description": "The setFee() function in Swivel contract is implemented wrongly, which results in feenominators not being set as expected.",
                "Repair": "Modify the function implementation to correctly set the feenominators array based on the index parameter"
            }
        ]
    }
]