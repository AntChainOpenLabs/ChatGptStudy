[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ImmutableState } from \"./ImmutableState.sol\";\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\n\nimport { IPair } from \"./interfaces/IPair.sol\";\nimport { IPairMintCallback } from \"./interfaces/callback/IPairMintCallback.sol\";\nimport { ISwapCallback } from \"./interfaces/callback/ISwapCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\n\nabstract contract Pair is ImmutableState, ReentrancyGuard, IPair {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(uint256 amount0In, uint256 amount1In, uint256 liquidity);\n\n  event Burn(uint256 amount0Out, uint256 amount1Out, uint256 liquidity, address indexed to);\n\n  event Swap(uint256 amount0Out, uint256 amount1Out, uint256 amount0In, uint256 amount1In, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InvariantError();\n\n  error InsufficientOutputError();\n\n  /*//////////////////////////////////////////////////////////////\n                                 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  uint120 public override reserve0;\n\n  /// @inheritdoc IPair\n  uint120 public override reserve1;\n\n  /// @inheritdoc IPair\n  uint256 public override totalLiquidity;\n\n  /*//////////////////////////////////////////////////////////////\n                              PAIR LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function mint(uint256 liquidity, bytes calldata data) internal {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    IPairMintCallback(msg.sender).pairMintCallback(liquidity, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In, _reserve1 + amount1In, _totalLiquidity + liquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In); // SSTORE\n    totalLiquidity = _totalLiquidity + liquidity; // SSTORE\n\n    emit Mint(amount0In, amount1In, liquidity);\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function burn(address to, uint256 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    amount0 = FullMath.mulDiv(_reserve0, liquidity, _totalLiquidity);\n    amount1 = FullMath.mulDiv(_reserve1, liquidity, _totalLiquidity);\n    if (amount0 == 0 && amount1 == 0) revert InsufficientOutputError();\n\n    if (amount0 > 0) SafeTransferLib.safeTransfer(token0, to, amount0);\n    if (amount1 > 0) SafeTransferLib.safeTransfer(token1, to, amount1);\n\n    // Extra check of the invariant\n    if (!invariant(_reserve0 - amount0, _reserve1 - amount1, _totalLiquidity - liquidity)) revert InvariantError();\n\n    reserve0 = _reserve0 - SafeCast.toUint120(amount0); // SSTORE\n    reserve1 = _reserve1 - SafeCast.toUint120(amount1); // SSTORE\n    totalLiquidity = _totalLiquidity - liquidity; // SSTORE\n\n    emit Burn(amount0, amount1, liquidity, to);\n  }\n\n  /// @inheritdoc IPair\n  function swap(address to, uint256 amount0Out, uint256 amount1Out, bytes calldata data) external override nonReentrant {\n    if (amount0Out == 0 && amount1Out == 0) revert InsufficientOutputError();\n\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n\n    if (amount0Out > 0) SafeTransferLib.safeTransfer(token0, to, amount0Out);\n    if (amount1Out > 0) SafeTransferLib.safeTransfer(token1, to, amount1Out);\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    ISwapCallback(msg.sender).swapCallback(amount0Out, amount1Out, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In - amount0Out, _reserve1 + amount1In - amount1Out, totalLiquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In) - SafeCast.toUint120(amount0Out); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In) - SafeCast.toUint120(amount1Out); // SSTORE\n\n    emit Swap(amount0Out, amount1Out, amount0In, amount1In, to);\n  }\n}\n\n\n",
        "CodeNames": [
            "Pair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Pair.invariant() function in Pair.sol",
                "Type": "Precision loss",
                "Description": "There is a precision loss in the invariant function which can lead to loss of funds. The significant rounding before conversion to D18 can result in the wrong invariant check result. An attacker can steal the funds without affecting the invariant. The fix is to multiply first before division to prevent precision loss.",
                "Repair": "Multiply first before division to prevent precision loss"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { Multicall } from \"./Multicall.sol\";\nimport { Payment } from \"./Payment.sol\";\nimport { SelfPermit } from \"./SelfPermit.sol\";\n\nimport { ILendgine } from \"../core/interfaces/ILendgine.sol\";\nimport { IPairMintCallback } from \"../core/interfaces/callback/IPairMintCallback.sol\";\n\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { LendgineAddress } from \"./libraries/LendgineAddress.sol\";\n\n/// @notice Manages liquidity provider positions\n/// @author Kyle Scott (kyle@numoen.com)\ncontract LiquidityManager is Multicall, Payment, SelfPermit, IPairMintCallback {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n  event AddLiquidity(\n    address indexed from,\n    address indexed lendgine,\n    uint256 liquidity,\n    uint256 size,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n\n  event RemoveLiquidity(\n    address indexed from,\n    address indexed lendgine,\n    uint256 liquidity,\n    uint256 size,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n\n  event Collect(address indexed from, address indexed lendgine, uint256 amount, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error LivelinessError();\n\n  error AmountError();\n\n  error ValidationError();\n\n  error PositionInvalidError();\n\n  error CollectError();\n\n  /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  address public immutable factory;\n\n  struct Position {\n    uint256 size;\n    uint256 rewardPerPositionPaid;\n    uint256 tokensOwed;\n  }\n\n  /// @notice Owner to lendgine to position\n  mapping(address => mapping(address => Position)) public positions;\n\n  /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n  constructor(address _factory, address _weth) Payment(_weth) {\n    factory = _factory;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           LIVELINESS MODIFIER\n    //////////////////////////////////////////////////////////////*/\n\n  modifier checkDeadline(uint256 deadline) {\n    if (deadline < block.timestamp) revert LivelinessError();\n    _;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                                CALLBACK\n    //////////////////////////////////////////////////////////////*/\n\n  struct PairMintCallbackData {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 amount0;\n    uint256 amount1;\n    address payer;\n  }\n\n  /// @notice callback that sends the underlying tokens for the specified amount of liquidity shares\n  function pairMintCallback(uint256, bytes calldata data) external {\n    PairMintCallbackData memory decoded = abi.decode(data, (PairMintCallbackData));\n\n    address lendgine = LendgineAddress.computeAddress(\n      factory, decoded.token0, decoded.token1, decoded.token0Exp, decoded.token1Exp, decoded.upperBound\n    );\n    if (lendgine != msg.sender) revert ValidationError();\n\n    if (decoded.amount0 > 0) pay(decoded.token0, decoded.payer, msg.sender, decoded.amount0);\n    if (decoded.amount1 > 0) pay(decoded.token1, decoded.payer, msg.sender, decoded.amount1);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        LIQUIDITY MANAGER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  struct AddLiquidityParams {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 liquidity;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    uint256 sizeMin;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Add liquidity to a liquidity position\n  function addLiquidity(AddLiquidityParams calldata params) external payable checkDeadline(params.deadline) {\n    address lendgine = LendgineAddress.computeAddress(\n      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n    );\n\n    uint256 r0 = ILendgine(lendgine).reserve0();\n    uint256 r1 = ILendgine(lendgine).reserve1();\n    uint256 totalLiquidity = ILendgine(lendgine).totalLiquidity();\n\n    uint256 amount0;\n    uint256 amount1;\n\n    if (totalLiquidity == 0) {\n      amount0 = params.amount0Min;\n      amount1 = params.amount1Min;\n    } else {\n      amount0 = FullMath.mulDivRoundingUp(params.liquidity, r0, totalLiquidity);\n      amount1 = FullMath.mulDivRoundingUp(params.liquidity, r1, totalLiquidity);\n    }\n\n    if (amount0 < params.amount0Min || amount1 < params.amount1Min) revert AmountError();\n\n    uint256 size = ILendgine(lendgine).deposit(\n      address(this),\n      params.liquidity,\n      abi.encode(\n        PairMintCallbackData({\n          token0: params.token0,\n          token1: params.token1,\n          token0Exp: params.token0Exp,\n          token1Exp: params.token1Exp,\n          upperBound: params.upperBound,\n          amount0: amount0,\n          amount1: amount1,\n          payer: msg.sender\n        })\n      )\n    );\n    if (size < params.sizeMin) revert AmountError();\n\n    Position memory position = positions[params.recipient][lendgine]; // SLOAD\n\n    (, uint256 rewardPerPositionPaid,) = ILendgine(lendgine).positions(address(this));\n    position.tokensOwed += FullMath.mulDiv(position.size, rewardPerPositionPaid - position.rewardPerPositionPaid, 1e18);\n    position.rewardPerPositionPaid = rewardPerPositionPaid;\n    position.size += size;\n\n    positions[params.recipient][lendgine] = position; // SSTORE\n\n    emit AddLiquidity(msg.sender, lendgine, params.liquidity, size, amount0, amount1, params.recipient);\n  }\n\n  struct RemoveLiquidityParams {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 size;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Removes from a liquidity position\n  function removeLiquidity(RemoveLiquidityParams calldata params) external payable checkDeadline(params.deadline) {\n    address lendgine = LendgineAddress.computeAddress(\n      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n    );\n\n    address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n\n    (uint256 amount0, uint256 amount1, uint256 liquidity) = ILendgine(lendgine).withdraw(recipient, params.size);\n    if (amount0 < params.amount0Min || amount1 < params.amount1Min) revert AmountError();\n\n    Position memory position = positions[msg.sender][lendgine]; // SLOAD\n\n    (, uint256 rewardPerPositionPaid,) = ILendgine(lendgine).positions(address(this));\n    position.tokensOwed += FullMath.mulDiv(position.size, rewardPerPositionPaid - position.rewardPerPositionPaid, 1e18);\n    position.rewardPerPositionPaid = rewardPerPositionPaid;\n    position.size -= params.size;\n\n    positions[msg.sender][lendgine] = position; // SSTORE\n\n    emit RemoveLiquidity(msg.sender, lendgine, liquidity, params.size, amount0, amount1, recipient);\n  }\n\n  struct CollectParams {\n    address lendgine;\n    address recipient;\n    uint256 amountRequested;\n  }\n\n  /// @notice Collects interest owed to the callers liqudity position\n  function collect(CollectParams calldata params) external payable returns (uint256 amount) {\n    ILendgine(params.lendgine).accruePositionInterest();\n\n    address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n\n    Position memory position = positions[msg.sender][params.lendgine]; // SLOAD\n\n    (, uint256 rewardPerPositionPaid,) = ILendgine(params.lendgine).positions(address(this));\n    position.tokensOwed += FullMath.mulDiv(position.size, rewardPerPositionPaid - position.rewardPerPositionPaid, 1e18);\n    position.rewardPerPositionPaid = rewardPerPositionPaid;\n\n    amount = params.amountRequested > position.tokensOwed ? position.tokensOwed : params.amountRequested;\n    position.tokensOwed -= amount;\n\n    positions[msg.sender][params.lendgine] = position; // SSTORE\n\n    uint256 collectAmount = ILendgine(params.lendgine).collect(recipient, amount);\n    if (collectAmount != amount) revert CollectError(); // extra check for safety\n\n    emit Collect(msg.sender, params.lendgine, amount, recipient);\n  }\n}\n\n\n",
        "CodeNames": [
            "LiquidityManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LiquidityManager.sol",
                "Type": "Loss of Funds",
                "Description": "The LPs are supposed to use the function LiquidityManager.addLiquidity(AddLiquidityParams calldata params) to add liquidity. If the LP chooses the values amount0, amount1, liquidity not accurately, the transaction reverts or a+b-c-d becomes greater than zero, resulting in loss of funds for the first liquidity depositor.",
                "Repair": "Add a functionality to calculate the liquidity for the first deposit on-chain. Pass in the amount of liquidity as part of the input."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { Multicall } from \"./Multicall.sol\";\nimport { Payment } from \"./Payment.sol\";\nimport { SelfPermit } from \"./SelfPermit.sol\";\nimport { SwapHelper } from \"./SwapHelper.sol\";\n\nimport { ILendgine } from \"../core/interfaces/ILendgine.sol\";\nimport { IMintCallback } from \"../core/interfaces/callback/IMintCallback.sol\";\nimport { IPairMintCallback } from \"../core/interfaces/callback/IPairMintCallback.sol\";\n\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { LendgineAddress } from \"./libraries/LendgineAddress.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\n\n/// @notice Contract for automatically entering and exiting option positions\n/// @author Kyle Scott (kyle@numoen.com)\ncontract LendgineRouter is Multicall, Payment, SelfPermit, SwapHelper, IMintCallback, IPairMintCallback {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(address indexed from, address indexed lendgine, uint256 collateral, uint256 shares, address indexed to);\n\n  event Burn(address indexed from, address indexed lendgine, uint256 collateral, uint256 shares, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error LivelinessError();\n\n  error ValidationError();\n\n  error AmountError();\n\n  /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  address public immutable factory;\n\n  /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n  constructor(\n    address _factory,\n    address _uniswapV2Factory,\n    address _uniswapV3Factory,\n    address _weth\n  )\n    SwapHelper(_uniswapV2Factory, _uniswapV3Factory)\n    Payment(_weth)\n  {\n    factory = _factory;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           LIVELINESS MODIFIER\n    //////////////////////////////////////////////////////////////*/\n\n  modifier checkDeadline(uint256 deadline) {\n    if (deadline < block.timestamp) revert LivelinessError();\n    _;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                               MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  struct MintCallbackData {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 collateralMax;\n    SwapType swapType;\n    bytes swapExtraData;\n    address payer;\n  }\n\n  /// @notice Transfer the necessary amount of token1 to mint an option position\n  function mintCallback(\n    uint256 collateralTotal,\n    uint256 amount0,\n    uint256 amount1,\n    uint256,\n    bytes calldata data\n  )\n    external\n    override\n  {\n    MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n\n    address lendgine = LendgineAddress.computeAddress(\n      factory, decoded.token0, decoded.token1, decoded.token0Exp, decoded.token1Exp, decoded.upperBound\n    );\n    if (lendgine != msg.sender) revert ValidationError();\n\n    // swap all token0 to token1\n    uint256 collateralSwap = swap(\n      decoded.swapType,\n      SwapParams({\n        tokenIn: decoded.token0,\n        tokenOut: decoded.token1,\n        amount: SafeCast.toInt256(amount0),\n        recipient: msg.sender\n      }),\n      decoded.swapExtraData\n    );\n\n    // send token1 back\n    SafeTransferLib.safeTransfer(decoded.token1, msg.sender, amount1);\n\n    // pull the rest of tokens from the user\n    uint256 collateralIn = collateralTotal - amount1 - collateralSwap;\n    if (collateralIn > decoded.collateralMax) revert AmountError();\n\n    pay(decoded.token1, decoded.payer, msg.sender, collateralIn);\n  }\n\n  struct MintParams {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 amountIn;\n    uint256 amountBorrow;\n    uint256 sharesMin;\n    SwapType swapType;\n    bytes swapExtraData;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Use token1 to completely mint an option position\n  function mint(MintParams calldata params) external payable checkDeadline(params.deadline) returns (uint256 shares) {\n    address lendgine = LendgineAddress.computeAddress(\n      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n    );\n\n    shares = ILendgine(lendgine).mint(\n      address(this),\n      params.amountIn + params.amountBorrow,\n      abi.encode(\n        MintCallbackData({\n          token0: params.token0,\n          token1: params.token1,\n          token0Exp: params.token0Exp,\n          token1Exp: params.token1Exp,\n          upperBound: params.upperBound,\n          collateralMax: params.amountIn,\n          swapType: params.swapType,\n          swapExtraData: params.swapExtraData,\n          payer: msg.sender\n        })\n      )\n    );\n    if (shares < params.sharesMin) revert AmountError();\n\n    SafeTransferLib.safeTransfer(lendgine, params.recipient, shares);\n\n    emit Mint(msg.sender, lendgine, params.amountIn, shares, params.recipient);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                               BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  struct PairMintCallbackData {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 collateralMin;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    SwapType swapType;\n    bytes swapExtraData;\n    address recipient;\n  }\n\n  /// @notice Provide the tokens for the liquidity that is owed\n  function pairMintCallback(uint256 liquidity, bytes calldata data) external override {\n    PairMintCallbackData memory decoded = abi.decode(data, (PairMintCallbackData));\n\n    address lendgine = LendgineAddress.computeAddress(\n      factory, decoded.token0, decoded.token1, decoded.token0Exp, decoded.token1Exp, decoded.upperBound\n    );\n    if (lendgine != msg.sender) revert ValidationError();\n\n    uint256 r0 = ILendgine(msg.sender).reserve0();\n    uint256 r1 = ILendgine(msg.sender).reserve1();\n    uint256 totalLiquidity = ILendgine(msg.sender).totalLiquidity();\n\n    uint256 amount0;\n    uint256 amount1;\n\n    if (totalLiquidity == 0) {\n      amount0 = decoded.amount0Min;\n      amount1 = decoded.amount1Min;\n    } else {\n      amount0 = FullMath.mulDivRoundingUp(liquidity, r0, totalLiquidity);\n      amount1 = FullMath.mulDivRoundingUp(liquidity, r1, totalLiquidity);\n    }\n\n    if (amount0 < decoded.amount0Min || amount1 < decoded.amount1Min) revert AmountError();\n\n    // swap for required token0\n    uint256 collateralSwapped = swap(\n      decoded.swapType,\n      SwapParams({\n        tokenIn: decoded.token1,\n        tokenOut: decoded.token0,\n        amount: -SafeCast.toInt256(amount0),\n        recipient: msg.sender\n      }),\n      decoded.swapExtraData\n    );\n\n    // pay token1\n    SafeTransferLib.safeTransfer(decoded.token1, msg.sender, amount1);\n\n    // determine remaining and send to recipient\n    uint256 collateralTotal = ILendgine(msg.sender).convertLiquidityToCollateral(liquidity);\n    uint256 collateralOut = collateralTotal - amount1 - collateralSwapped;\n    if (collateralOut < decoded.collateralMin) revert AmountError();\n\n    if (decoded.recipient != address(this)) {\n      SafeTransferLib.safeTransfer(decoded.token1, decoded.recipient, collateralOut);\n    }\n  }\n\n  struct BurnParams {\n    address token0;\n    address token1;\n    uint256 token0Exp;\n    uint256 token1Exp;\n    uint256 upperBound;\n    uint256 shares;\n    uint256 collateralMin;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    SwapType swapType;\n    bytes swapExtraData;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Take an option position and withdraw it fully into token1\n  function burn(BurnParams calldata params) external payable checkDeadline(params.deadline) returns (uint256 amount) {\n    address lendgine = LendgineAddress.computeAddress(\n      factory, params.token0, params.token1, params.token0Exp, params.token1Exp, params.upperBound\n    );\n\n    address recipient = params.recipient == address(0) ? address(this) : params.recipient;\n\n    SafeTransferLib.safeTransferFrom(lendgine, msg.sender, lendgine, params.shares);\n\n    amount = ILendgine(lendgine).burn(\n      address(this),\n      abi.encode(\n        PairMintCallbackData({\n          token0: params.token0,\n          token1: params.token1,\n          token0Exp: params.token0Exp,\n          token1Exp: params.token1Exp,\n          upperBound: params.upperBound,\n          collateralMin: params.collateralMin,\n          amount0Min: params.amount0Min,\n          amount1Min: params.amount1Min,\n          swapType: params.swapType,\n          swapExtraData: params.swapExtraData,\n          recipient: recipient\n        })\n      )\n    );\n\n    emit Burn(msg.sender, lendgine, amount, params.shares, recipient);\n  }\n}\n\n\n",
        "CodeNames": [
            "LendgineRouter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LendgineRouter.sol",
                "Type": "Partial fund loss",
                "Description": "Borrower can lose partial fund during minting of Power Token as excess ETH are not refunded automatically",
                "Repair": "Automatically refund excess ETH or use atomic multicall feature"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.8.0;\n\nimport { IUniswapV2Pair } from \"../interfaces/IUniswapV2Pair.sol\";\n\n/// @notice Library for helpful UniswapV2 functions\n/// @author Uniswap (https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol)\n/// @dev Updated for newer solidity by removing safe math\nlibrary UniswapV2Library {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(\n      uint160( // extra cast for newer solidity\n        uint256(\n          keccak256(\n            abi.encodePacked(\n              hex\"ff\",\n              factory,\n              keccak256(abi.encodePacked(token0, token1)),\n              hex\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\" // init code hash\n            )\n          )\n        )\n      )\n    );\n  }\n\n  // fetches and sorts the reserves for a pair\n  function getReserves(\n    address factory,\n    address tokenA,\n    address tokenB\n  )\n    internal\n    view\n    returns (uint256 reserveA, uint256 reserveB)\n  {\n    (address token0,) = sortTokens(tokenA, tokenB);\n    (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n  }\n\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  )\n    internal\n    pure\n    returns (uint256 amountOut)\n  {\n    require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n    require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n    uint256 amountInWithFee = amountIn * 997;\n    uint256 numerator = amountInWithFee * reserveOut;\n    uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n    amountOut = numerator / denominator;\n  }\n\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  )\n    internal\n    pure\n    returns (uint256 amountIn)\n  {\n    require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n    require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n    uint256 numerator = reserveIn * amountOut * 1000;\n    uint256 denominator = (reserveOut - amountOut) * 997;\n    amountIn = (numerator / denominator) + 1;\n  }\n}\n\n\n",
        "CodeNames": [
            "UniswapV2Library.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "UniswapV2Library.sol",
                "Type": "Wrong init code hash",
                "Description": "Init code hash used to calculate the address of UniswapV2 pair contract is not same as the latest UniswapV2 repository",
                "Repair": "Integrate the latest version of UniswapV2"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ERC20 } from \"./ERC20.sol\";\nimport { JumpRate } from \"./JumpRate.sol\";\nimport { Pair } from \"./Pair.sol\";\n\nimport { ILendgine } from \"./interfaces/ILendgine.sol\";\nimport { IMintCallback } from \"./interfaces/callback/IMintCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { Position } from \"./libraries/Position.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\n\ncontract Lendgine is ERC20, JumpRate, Pair, ILendgine {\n  using Position for mapping(address => Position.Info);\n  using Position for Position.Info;\n\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(address indexed sender, uint256 collateral, uint256 shares, uint256 liquidity, address indexed to);\n\n  event Burn(address indexed sender, uint256 collateral, uint256 shares, uint256 liquidity, address indexed to);\n\n  event Deposit(address indexed sender, uint256 size, uint256 liquidity, address indexed to);\n\n  event Withdraw(address indexed sender, uint256 size, uint256 liquidity, address indexed to);\n\n  event AccrueInterest(uint256 timeElapsed, uint256 collateral, uint256 liquidity);\n\n  event AccruePositionInterest(address indexed owner, uint256 rewardPerPosition);\n\n  event Collect(address indexed owner, address indexed to, uint256 amount);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InputError();\n\n  error CompleteUtilizationError();\n\n  error InsufficientInputError();\n\n  error InsufficientPositionError();\n\n  /*//////////////////////////////////////////////////////////////\n                          LENDGINE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc ILendgine\n  mapping(address => Position.Info) public override positions;\n\n  /// @inheritdoc ILendgine\n  uint256 public override totalPositionSize;\n\n  /// @inheritdoc ILendgine\n  uint256 public override totalLiquidityBorrowed;\n\n  /// @inheritdoc ILendgine\n  uint256 public override rewardPerPositionStored;\n\n  /// @inheritdoc ILendgine\n  uint256 public override lastUpdate;\n\n  /// @inheritdoc ILendgine\n  function mint(\n    address to,\n    uint256 collateral,\n    bytes calldata data\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 shares)\n  {\n    _accrueInterest();\n\n    uint256 liquidity = convertCollateralToLiquidity(collateral);\n    shares = convertLiquidityToShare(liquidity);\n\n    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n    if (liquidity > totalLiquidity) revert CompleteUtilizationError();\n    // next check is for the case when liquidity is borrowed but then was completely accrued\n    if (totalSupply > 0 && totalLiquidityBorrowed == 0) revert CompleteUtilizationError();\n\n    totalLiquidityBorrowed += liquidity;\n    (uint256 amount0, uint256 amount1) = burn(to, liquidity);\n    _mint(to, shares);\n\n    uint256 balanceBefore = Balance.balance(token1);\n    IMintCallback(msg.sender).mintCallback(collateral, amount0, amount1, liquidity, data);\n    uint256 balanceAfter = Balance.balance(token1);\n\n    if (balanceAfter < balanceBefore + collateral) revert InsufficientInputError();\n\n    emit Mint(msg.sender, collateral, shares, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function burn(address to, bytes calldata data) external override nonReentrant returns (uint256 collateral) {\n    _accrueInterest();\n\n    uint256 shares = balanceOf[address(this)];\n    uint256 liquidity = convertShareToLiquidity(shares);\n    collateral = convertLiquidityToCollateral(liquidity);\n\n    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n\n    totalLiquidityBorrowed -= liquidity;\n    _burn(address(this), shares);\n    SafeTransferLib.safeTransfer(token1, to, collateral); // optimistically transfer\n    mint(liquidity, data);\n\n    emit Burn(msg.sender, collateral, shares, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function deposit(\n    address to,\n    uint256 liquidity,\n    bytes calldata data\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 size)\n  {\n    _accrueInterest();\n\n    uint256 _totalPositionSize = totalPositionSize; // SLOAD\n    uint256 totalLiquiditySupplied = totalLiquidity + totalLiquidityBorrowed;\n\n    size = Position.convertLiquidityToPosition(liquidity, totalLiquiditySupplied, _totalPositionSize);\n\n    if (liquidity == 0 || size == 0) revert InputError();\n    // next check is for the case when liquidity is borrowed but then was completely accrued\n    if (totalLiquiditySupplied == 0 && totalPositionSize > 0) revert CompleteUtilizationError();\n\n    positions.update(to, SafeCast.toInt256(size), rewardPerPositionStored);\n    totalPositionSize = _totalPositionSize + size;\n    mint(liquidity, data);\n\n    emit Deposit(msg.sender, size, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function withdraw(\n    address to,\n    uint256 size\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 amount0, uint256 amount1, uint256 liquidity)\n  {\n    _accrueInterest();\n\n    uint256 _totalPositionSize = totalPositionSize; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n    uint256 totalLiquiditySupplied = _totalLiquidity + totalLiquidityBorrowed;\n\n    Position.Info memory positionInfo = positions[msg.sender]; // SLOAD\n    liquidity = Position.convertPositionToLiquidity(size, totalLiquiditySupplied, _totalPositionSize);\n\n    if (liquidity == 0 || size == 0) revert InputError();\n\n    if (size > positionInfo.size) revert InsufficientPositionError();\n    if (liquidity > _totalLiquidity) revert CompleteUtilizationError();\n\n    positions.update(msg.sender, -SafeCast.toInt256(size), rewardPerPositionStored);\n    totalPositionSize -= size;\n    (amount0, amount1) = burn(to, liquidity);\n\n    emit Withdraw(msg.sender, size, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function accrueInterest() external override nonReentrant {\n    _accrueInterest();\n  }\n\n  /// @inheritdoc ILendgine\n  function accruePositionInterest() external override nonReentrant {\n    _accrueInterest();\n    _accruePositionInterest(msg.sender);\n  }\n\n  /// @inheritdoc ILendgine\n  function collect(address to, uint256 collateralRequested) external override nonReentrant returns (uint256 collateral) {\n    Position.Info storage position = positions[msg.sender]; // SLOAD\n    uint256 tokensOwed = position.tokensOwed;\n\n    collateral = collateralRequested > tokensOwed ? tokensOwed : collateralRequested;\n\n    if (collateral > 0) {\n      position.tokensOwed = tokensOwed - collateral; // SSTORE\n      SafeTransferLib.safeTransfer(token1, to, collateral);\n    }\n\n    emit Collect(msg.sender, to, collateral);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc ILendgine\n  function convertLiquidityToShare(uint256 liquidity) public view override returns (uint256) {\n    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n    return _totalLiquidityBorrowed == 0 ? liquidity : FullMath.mulDiv(liquidity, totalSupply, _totalLiquidityBorrowed);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertShareToLiquidity(uint256 shares) public view override returns (uint256) {\n    return FullMath.mulDiv(totalLiquidityBorrowed, shares, totalSupply);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertCollateralToLiquidity(uint256 collateral) public view override returns (uint256) {\n    return FullMath.mulDiv(collateral * token1Scale, 1e18, 2 * upperBound);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertLiquidityToCollateral(uint256 liquidity) public view override returns (uint256) {\n    return FullMath.mulDiv(liquidity, 2 * upperBound, 1e18) / token1Scale;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         INTERNAL INTEREST LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Helper function for accruing lendgine interest\n  function _accrueInterest() private {\n    if (totalSupply == 0 || totalLiquidityBorrowed == 0) {\n      lastUpdate = block.timestamp;\n      return;\n    }\n\n    uint256 timeElapsed = block.timestamp - lastUpdate;\n    if (timeElapsed == 0) return;\n\n    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n    uint256 totalLiquiditySupplied = totalLiquidity + _totalLiquidityBorrowed; // SLOAD\n\n    uint256 borrowRate = getBorrowRate(_totalLiquidityBorrowed, totalLiquiditySupplied);\n\n    uint256 dilutionLPRequested = (FullMath.mulDiv(borrowRate, _totalLiquidityBorrowed, 1e18) * timeElapsed) / 365 days;\n    uint256 dilutionLP = dilutionLPRequested > _totalLiquidityBorrowed ? _totalLiquidityBorrowed : dilutionLPRequested;\n    uint256 dilutionSpeculative = convertLiquidityToCollateral(dilutionLP);\n\n    totalLiquidityBorrowed = _totalLiquidityBorrowed - dilutionLP;\n    rewardPerPositionStored += FullMath.mulDiv(dilutionSpeculative, 1e18, totalPositionSize);\n    lastUpdate = block.timestamp;\n\n    emit AccrueInterest(timeElapsed, dilutionSpeculative, dilutionLP);\n  }\n\n  /// @notice Helper function for accruing interest to a position\n  /// @dev Assume the global interest is up to date\n  /// @param owner The address that this position belongs to\n  function _accruePositionInterest(address owner) private {\n    uint256 _rewardPerPositionStored = rewardPerPositionStored; // SLOAD\n\n    positions.update(owner, 0, _rewardPerPositionStored);\n\n    emit AccruePositionInterest(owner, _rewardPerPositionStored);\n  }\n}\n\n\n",
        "CodeNames": [
            "Lendgine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Lendgine.sol",
                "Type": "Fee on transfer tokens",
                "Description": "Fee on transfer tokens will not behave as expected and can cause mint() to revert",
                "Repair": "Whitelist tokens or calculate balance before and after transfer"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ImmutableState } from \"./ImmutableState.sol\";\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\n\nimport { IPair } from \"./interfaces/IPair.sol\";\nimport { IPairMintCallback } from \"./interfaces/callback/IPairMintCallback.sol\";\nimport { ISwapCallback } from \"./interfaces/callback/ISwapCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\n\nabstract contract Pair is ImmutableState, ReentrancyGuard, IPair {\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(uint256 amount0In, uint256 amount1In, uint256 liquidity);\n\n  event Burn(uint256 amount0Out, uint256 amount1Out, uint256 liquidity, address indexed to);\n\n  event Swap(uint256 amount0Out, uint256 amount1Out, uint256 amount0In, uint256 amount1In, address indexed to);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InvariantError();\n\n  error InsufficientOutputError();\n\n  /*//////////////////////////////////////////////////////////////\n                                 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  uint120 public override reserve0;\n\n  /// @inheritdoc IPair\n  uint120 public override reserve1;\n\n  /// @inheritdoc IPair\n  uint256 public override totalLiquidity;\n\n  /*//////////////////////////////////////////////////////////////\n                              PAIR LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0, 1e18, liquidity) * token0Scale;\n    uint256 scale1 = FullMath.mulDiv(amount1, 1e18, liquidity) * token1Scale;\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function mint(uint256 liquidity, bytes calldata data) internal {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    IPairMintCallback(msg.sender).pairMintCallback(liquidity, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In, _reserve1 + amount1In, _totalLiquidity + liquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In); // SSTORE\n    totalLiquidity = _totalLiquidity + liquidity; // SSTORE\n\n    emit Mint(amount0In, amount1In, liquidity);\n  }\n\n  /// @dev assumes liquidity is non-zero\n  function burn(address to, uint256 liquidity) internal returns (uint256 amount0, uint256 amount1) {\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n\n    amount0 = FullMath.mulDiv(_reserve0, liquidity, _totalLiquidity);\n    amount1 = FullMath.mulDiv(_reserve1, liquidity, _totalLiquidity);\n    if (amount0 == 0 && amount1 == 0) revert InsufficientOutputError();\n\n    if (amount0 > 0) SafeTransferLib.safeTransfer(token0, to, amount0);\n    if (amount1 > 0) SafeTransferLib.safeTransfer(token1, to, amount1);\n\n    // Extra check of the invariant\n    if (!invariant(_reserve0 - amount0, _reserve1 - amount1, _totalLiquidity - liquidity)) revert InvariantError();\n\n    reserve0 = _reserve0 - SafeCast.toUint120(amount0); // SSTORE\n    reserve1 = _reserve1 - SafeCast.toUint120(amount1); // SSTORE\n    totalLiquidity = _totalLiquidity - liquidity; // SSTORE\n\n    emit Burn(amount0, amount1, liquidity, to);\n  }\n\n  /// @inheritdoc IPair\n  function swap(address to, uint256 amount0Out, uint256 amount1Out, bytes calldata data) external override nonReentrant {\n    if (amount0Out == 0 && amount1Out == 0) revert InsufficientOutputError();\n\n    uint120 _reserve0 = reserve0; // SLOAD\n    uint120 _reserve1 = reserve1; // SLOAD\n\n    if (amount0Out > 0) SafeTransferLib.safeTransfer(token0, to, amount0Out);\n    if (amount1Out > 0) SafeTransferLib.safeTransfer(token1, to, amount1Out);\n\n    uint256 balance0Before = Balance.balance(token0);\n    uint256 balance1Before = Balance.balance(token1);\n    ISwapCallback(msg.sender).swapCallback(amount0Out, amount1Out, data);\n    uint256 amount0In = Balance.balance(token0) - balance0Before;\n    uint256 amount1In = Balance.balance(token1) - balance1Before;\n\n    if (!invariant(_reserve0 + amount0In - amount0Out, _reserve1 + amount1In - amount1Out, totalLiquidity)) {\n      revert InvariantError();\n    }\n\n    reserve0 = _reserve0 + SafeCast.toUint120(amount0In) - SafeCast.toUint120(amount0Out); // SSTORE\n    reserve1 = _reserve1 + SafeCast.toUint120(amount1In) - SafeCast.toUint120(amount1Out); // SSTORE\n\n    emit Swap(amount0Out, amount1Out, amount0In, amount1In, to);\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.4;\n\nimport { ERC20 } from \"./ERC20.sol\";\nimport { JumpRate } from \"./JumpRate.sol\";\nimport { Pair } from \"./Pair.sol\";\n\nimport { ILendgine } from \"./interfaces/ILendgine.sol\";\nimport { IMintCallback } from \"./interfaces/callback/IMintCallback.sol\";\n\nimport { Balance } from \"../libraries/Balance.sol\";\nimport { FullMath } from \"../libraries/FullMath.sol\";\nimport { Position } from \"./libraries/Position.sol\";\nimport { SafeTransferLib } from \"../libraries/SafeTransferLib.sol\";\nimport { SafeCast } from \"../libraries/SafeCast.sol\";\n\ncontract Lendgine is ERC20, JumpRate, Pair, ILendgine {\n  using Position for mapping(address => Position.Info);\n  using Position for Position.Info;\n\n  /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n  event Mint(address indexed sender, uint256 collateral, uint256 shares, uint256 liquidity, address indexed to);\n\n  event Burn(address indexed sender, uint256 collateral, uint256 shares, uint256 liquidity, address indexed to);\n\n  event Deposit(address indexed sender, uint256 size, uint256 liquidity, address indexed to);\n\n  event Withdraw(address indexed sender, uint256 size, uint256 liquidity, address indexed to);\n\n  event AccrueInterest(uint256 timeElapsed, uint256 collateral, uint256 liquidity);\n\n  event AccruePositionInterest(address indexed owner, uint256 rewardPerPosition);\n\n  event Collect(address indexed owner, address indexed to, uint256 amount);\n\n  /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n  error InputError();\n\n  error CompleteUtilizationError();\n\n  error InsufficientInputError();\n\n  error InsufficientPositionError();\n\n  /*//////////////////////////////////////////////////////////////\n                          LENDGINE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc ILendgine\n  mapping(address => Position.Info) public override positions;\n\n  /// @inheritdoc ILendgine\n  uint256 public override totalPositionSize;\n\n  /// @inheritdoc ILendgine\n  uint256 public override totalLiquidityBorrowed;\n\n  /// @inheritdoc ILendgine\n  uint256 public override rewardPerPositionStored;\n\n  /// @inheritdoc ILendgine\n  uint256 public override lastUpdate;\n\n  /// @inheritdoc ILendgine\n  function mint(\n    address to,\n    uint256 collateral,\n    bytes calldata data\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 shares)\n  {\n    _accrueInterest();\n\n    uint256 liquidity = convertCollateralToLiquidity(collateral);\n    shares = convertLiquidityToShare(liquidity);\n\n    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n    if (liquidity > totalLiquidity) revert CompleteUtilizationError();\n    // next check is for the case when liquidity is borrowed but then was completely accrued\n    if (totalSupply > 0 && totalLiquidityBorrowed == 0) revert CompleteUtilizationError();\n\n    totalLiquidityBorrowed += liquidity;\n    (uint256 amount0, uint256 amount1) = burn(to, liquidity);\n    _mint(to, shares);\n\n    uint256 balanceBefore = Balance.balance(token1);\n    IMintCallback(msg.sender).mintCallback(collateral, amount0, amount1, liquidity, data);\n    uint256 balanceAfter = Balance.balance(token1);\n\n    if (balanceAfter < balanceBefore + collateral) revert InsufficientInputError();\n\n    emit Mint(msg.sender, collateral, shares, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function burn(address to, bytes calldata data) external override nonReentrant returns (uint256 collateral) {\n    _accrueInterest();\n\n    uint256 shares = balanceOf[address(this)];\n    uint256 liquidity = convertShareToLiquidity(shares);\n    collateral = convertLiquidityToCollateral(liquidity);\n\n    if (collateral == 0 || liquidity == 0 || shares == 0) revert InputError();\n\n    totalLiquidityBorrowed -= liquidity;\n    _burn(address(this), shares);\n    SafeTransferLib.safeTransfer(token1, to, collateral); // optimistically transfer\n    mint(liquidity, data);\n\n    emit Burn(msg.sender, collateral, shares, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function deposit(\n    address to,\n    uint256 liquidity,\n    bytes calldata data\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 size)\n  {\n    _accrueInterest();\n\n    uint256 _totalPositionSize = totalPositionSize; // SLOAD\n    uint256 totalLiquiditySupplied = totalLiquidity + totalLiquidityBorrowed;\n\n    size = Position.convertLiquidityToPosition(liquidity, totalLiquiditySupplied, _totalPositionSize);\n\n    if (liquidity == 0 || size == 0) revert InputError();\n    // next check is for the case when liquidity is borrowed but then was completely accrued\n    if (totalLiquiditySupplied == 0 && totalPositionSize > 0) revert CompleteUtilizationError();\n\n    positions.update(to, SafeCast.toInt256(size), rewardPerPositionStored);\n    totalPositionSize = _totalPositionSize + size;\n    mint(liquidity, data);\n\n    emit Deposit(msg.sender, size, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function withdraw(\n    address to,\n    uint256 size\n  )\n    external\n    override\n    nonReentrant\n    returns (uint256 amount0, uint256 amount1, uint256 liquidity)\n  {\n    _accrueInterest();\n\n    uint256 _totalPositionSize = totalPositionSize; // SLOAD\n    uint256 _totalLiquidity = totalLiquidity; // SLOAD\n    uint256 totalLiquiditySupplied = _totalLiquidity + totalLiquidityBorrowed;\n\n    Position.Info memory positionInfo = positions[msg.sender]; // SLOAD\n    liquidity = Position.convertPositionToLiquidity(size, totalLiquiditySupplied, _totalPositionSize);\n\n    if (liquidity == 0 || size == 0) revert InputError();\n\n    if (size > positionInfo.size) revert InsufficientPositionError();\n    if (liquidity > _totalLiquidity) revert CompleteUtilizationError();\n\n    positions.update(msg.sender, -SafeCast.toInt256(size), rewardPerPositionStored);\n    totalPositionSize -= size;\n    (amount0, amount1) = burn(to, liquidity);\n\n    emit Withdraw(msg.sender, size, liquidity, to);\n  }\n\n  /// @inheritdoc ILendgine\n  function accrueInterest() external override nonReentrant {\n    _accrueInterest();\n  }\n\n  /// @inheritdoc ILendgine\n  function accruePositionInterest() external override nonReentrant {\n    _accrueInterest();\n    _accruePositionInterest(msg.sender);\n  }\n\n  /// @inheritdoc ILendgine\n  function collect(address to, uint256 collateralRequested) external override nonReentrant returns (uint256 collateral) {\n    Position.Info storage position = positions[msg.sender]; // SLOAD\n    uint256 tokensOwed = position.tokensOwed;\n\n    collateral = collateralRequested > tokensOwed ? tokensOwed : collateralRequested;\n\n    if (collateral > 0) {\n      position.tokensOwed = tokensOwed - collateral; // SSTORE\n      SafeTransferLib.safeTransfer(token1, to, collateral);\n    }\n\n    emit Collect(msg.sender, to, collateral);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @inheritdoc ILendgine\n  function convertLiquidityToShare(uint256 liquidity) public view override returns (uint256) {\n    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n    return _totalLiquidityBorrowed == 0 ? liquidity : FullMath.mulDiv(liquidity, totalSupply, _totalLiquidityBorrowed);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertShareToLiquidity(uint256 shares) public view override returns (uint256) {\n    return FullMath.mulDiv(totalLiquidityBorrowed, shares, totalSupply);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertCollateralToLiquidity(uint256 collateral) public view override returns (uint256) {\n    return FullMath.mulDiv(collateral * token1Scale, 1e18, 2 * upperBound);\n  }\n\n  /// @inheritdoc ILendgine\n  function convertLiquidityToCollateral(uint256 liquidity) public view override returns (uint256) {\n    return FullMath.mulDiv(liquidity, 2 * upperBound, 1e18) / token1Scale;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         INTERNAL INTEREST LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Helper function for accruing lendgine interest\n  function _accrueInterest() private {\n    if (totalSupply == 0 || totalLiquidityBorrowed == 0) {\n      lastUpdate = block.timestamp;\n      return;\n    }\n\n    uint256 timeElapsed = block.timestamp - lastUpdate;\n    if (timeElapsed == 0) return;\n\n    uint256 _totalLiquidityBorrowed = totalLiquidityBorrowed; // SLOAD\n    uint256 totalLiquiditySupplied = totalLiquidity + _totalLiquidityBorrowed; // SLOAD\n\n    uint256 borrowRate = getBorrowRate(_totalLiquidityBorrowed, totalLiquiditySupplied);\n\n    uint256 dilutionLPRequested = (FullMath.mulDiv(borrowRate, _totalLiquidityBorrowed, 1e18) * timeElapsed) / 365 days;\n    uint256 dilutionLP = dilutionLPRequested > _totalLiquidityBorrowed ? _totalLiquidityBorrowed : dilutionLPRequested;\n    uint256 dilutionSpeculative = convertLiquidityToCollateral(dilutionLP);\n\n    totalLiquidityBorrowed = _totalLiquidityBorrowed - dilutionLP;\n    rewardPerPositionStored += FullMath.mulDiv(dilutionSpeculative, 1e18, totalPositionSize);\n    lastUpdate = block.timestamp;\n\n    emit AccrueInterest(timeElapsed, dilutionSpeculative, dilutionLP);\n  }\n\n  /// @notice Helper function for accruing interest to a position\n  /// @dev Assume the global interest is up to date\n  /// @param owner The address that this position belongs to\n  function _accruePositionInterest(address owner) private {\n    uint256 _rewardPerPositionStored = rewardPerPositionStored; // SLOAD\n\n    positions.update(owner, 0, _rewardPerPositionStored);\n\n    emit AccruePositionInterest(owner, _rewardPerPositionStored);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable max-line-length\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of\n/// precision\n/// @author Muffin (https://github.com/muffinfi/muffin/blob/master/contracts/libraries/math/FullMath.sol)\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256\n/// bits\nlibrary FullMath {\n  /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or\n  /// denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n    unchecked {\n      // 512-bit multiply [prod1 prod0] = a * b\n      // Compute the product mod 2**256 and mod 2**256 - 1\n      // then use the Chinese Remainder Theorem to reconstruct\n      // the 512 bit result. The result is stored in two 256\n      // variables such that product = prod1 * 2**256 + prod0\n      uint256 prod0; // Least significant 256 bits of the product\n      uint256 prod1; // Most significant 256 bits of the product\n      assembly {\n        let mm := mulmod(a, b, not(0))\n        prod0 := mul(a, b)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n      }\n\n      // Handle non-overflow cases, 256 by 256 division\n      if (prod1 == 0) {\n        require(denominator > 0);\n        assembly {\n          result := div(prod0, denominator)\n        }\n        return result;\n      }\n\n      // Make sure the result is less than 2**256.\n      // Also prevents denominator == 0\n      require(denominator > prod1);\n\n      ///////////////////////////////////////////////\n      // 512 by 256 division.\n      ///////////////////////////////////////////////\n\n      // Make division exact by subtracting the remainder from [prod1 prod0]\n      // Compute remainder using mulmod\n      uint256 remainder;\n      assembly {\n        remainder := mulmod(a, b, denominator)\n      }\n      // Subtract 256 bit number from 512 bit number\n      assembly {\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n      }\n\n      // Factor powers of two out of denominator\n      // Compute largest power of two divisor of denominator.\n      // Always >= 1.\n\n      // [*] The next line is edited to be compatible with solidity 0.8\n      // ref: https://ethereum.stackexchange.com/a/96646\n      // original: uint256 twos = -denominator & denominator;\n      uint256 twos = denominator & (~denominator + 1);\n\n      // Divide denominator by power of two\n      assembly {\n        denominator := div(denominator, twos)\n      }\n\n      // Divide [prod1 prod0] by the factors of two\n      assembly {\n        prod0 := div(prod0, twos)\n      }\n      // Shift in bits from prod1 into prod0. For this we need\n      // to flip `twos` such that it is 2**256 / twos.\n      // If twos is zero, then it becomes one\n      assembly {\n        twos := add(div(sub(0, twos), twos), 1)\n      }\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2**256\n      // Now that denominator is an odd number, it has an inverse\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n      // Compute the inverse by starting with a seed that is correct\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\n      uint256 inv = (3 * denominator) ^ 2;\n      // Now use Newton-Raphson iteration to improve the precision.\n      // Thanks to Hensel's lifting lemma, this also works in modular\n      // arithmetic, doubling the correct bits in each step.\n      inv *= 2 - denominator * inv; // inverse mod 2**8\n      inv *= 2 - denominator * inv; // inverse mod 2**16\n      inv *= 2 - denominator * inv; // inverse mod 2**32\n      inv *= 2 - denominator * inv; // inverse mod 2**64\n      inv *= 2 - denominator * inv; // inverse mod 2**128\n      inv *= 2 - denominator * inv; // inverse mod 2**256\n\n      // Because the division is now exact we can divide by multiplying\n      // with the modular inverse of denominator. This will give us the\n      // correct result modulo 2**256. Since the precoditions guarantee\n      // that the outcome is less than 2**256, this is the final result.\n      // We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inv;\n      return result;\n    }\n  }\n\n  /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or\n  /// denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n    result = mulDiv(a, b, denominator);\n    if (mulmod(a, b, denominator) > 0) {\n      result++;\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "Pair.sol",
            "Lendgine.sol",
            "FullMath.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "FullMath.mulDiv function in Pair.sol and Lendgine.sol contracts",
                "Type": "Unnecessary precision loss",
                "Description": "The division operation before multiplication incurs unnecessary precision loss in the codebase, which can lead to truncated values and incorrect results.",
                "Repair": "Normalize and scale the values before performing division operation"
            }
        ]
    }
]