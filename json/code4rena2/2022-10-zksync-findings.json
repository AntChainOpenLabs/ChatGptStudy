[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../libraries/Diamond.sol\";\nimport \"../Config.sol\";\nimport \"./Base.sol\";\n\n/// @title DiamondCut contract responsible for the management of upgrades.\n/// @author Matter Labs\ncontract DiamondCutFacet is Base, IDiamondCut {\n    constructor() {\n        // Caution check for config value.\n        // Should be greater than 0, otherwise zero approvals will be enough to make an instant upgrade!\n        assert(SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE > 0);\n    }\n\n    /// @dev Starts the upgrade process. Only the current governor can propose an upgrade.\n    /// @param _facetCuts The set of proposed changes to the facets (adding/replacement/removing)\n    /// @param _initAddress Address of the fallback contract that will be called after the upgrade execution\n    function proposeDiamondCut(Diamond.FacetCut[] calldata _facetCuts, address _initAddress) external onlyGovernor {\n        require(s.diamondCutStorage.proposedDiamondCutTimestamp == 0, \"a3\"); // proposal already exists\n\n        // NOTE: governor commits only to the `facetCuts` and `initAddress`, but not to the calldata on `initAddress` call.\n        // That means the governor can call `initAddress` with ANY calldata while executing the upgrade.\n        s.diamondCutStorage.proposedDiamondCutHash = keccak256(abi.encode(_facetCuts, _initAddress));\n        s.diamondCutStorage.proposedDiamondCutTimestamp = block.timestamp;\n        s.diamondCutStorage.currentProposalId += 1;\n\n        emit DiamondCutProposal(_facetCuts, _initAddress);\n    }\n\n    /// @notice Removes the upgrade proposal. Only current governor can remove proposal.\n    function cancelDiamondCutProposal() external onlyGovernor {\n        emit DiamondCutProposalCancelation(\n            s.diamondCutStorage.currentProposalId,\n            s.diamondCutStorage.proposedDiamondCutHash\n        );\n        require(_resetProposal(), \"g1\"); // failed cancel diamond cut\n    }\n\n    /// @notice Executes a proposed governor upgrade. Only the current governor can execute the upgrade.\n    /// NOTE: Governor can execute diamond cut ONLY with proposed `facetCuts` and `initAddress`.\n    /// `initCalldata` can be arbitrarily.\n    function executeDiamondCutProposal(Diamond.DiamondCutData calldata _diamondCut) external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        bool approvedBySecurityCouncil = s.diamondCutStorage.securityCouncilEmergencyApprovals >=\n            SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE;\n\n        bool upgradeNoticePeriodPassed = block.timestamp >=\n            s.diamondCutStorage.proposedDiamondCutTimestamp + UPGRADE_NOTICE_PERIOD;\n\n        require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire\n        require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\");\n        // should not be frozen or should have enough security council approvals\n\n        require(\n            s.diamondCutStorage.proposedDiamondCutHash ==\n                keccak256(abi.encode(_diamondCut.facetCuts, _diamondCut.initAddress)),\n            \"a4\"\n        ); // proposal should be created\n\n        require(_resetProposal(), \"a5\"); // failed reset proposal\n\n        if (diamondStorage.isFrozen) {\n            diamondStorage.isFrozen = false;\n            emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);\n        }\n\n        Diamond.diamondCut(_diamondCut);\n\n        emit DiamondCutProposalExecution(_diamondCut);\n    }\n\n    /// @notice Instantly pause the functionality of all freezable facets & their selectors\n    function emergencyFreezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n        require(!diamondStorage.isFrozen, \"a9\"); // diamond proxy is frozen already\n        _resetProposal();\n\n        diamondStorage.isFrozen = true;\n        // Limited-time freezing feature will be added in the future upgrades, so keeping this variable for simplification\n        s.diamondCutStorage.lastDiamondFreezeTimestamp = block.timestamp;\n\n        emit EmergencyFreeze();\n    }\n\n    /// @notice Unpause the functionality of all freezable facets & their selectors\n    function unfreezeDiamond() external onlyGovernor {\n        Diamond.DiamondStorage storage diamondStorage = Diamond.getDiamondStorage();\n\n        require(diamondStorage.isFrozen, \"a7\"); // diamond proxy is not frozen\n\n        _resetProposal();\n\n        diamondStorage.isFrozen = false;\n\n        emit Unfreeze(s.diamondCutStorage.lastDiamondFreezeTimestamp);\n    }\n\n    /// @notice Gives another approval for the instant upgrade (diamond cut) by the security council member\n    /// @param _diamondCutHash The hash of the diamond cut that security council members want to approve. Needed to prevent unintentional approvals, including reorg attacks\n    function approveEmergencyDiamondCutAsSecurityCouncilMember(bytes32 _diamondCutHash) external {\n        require(s.diamondCutStorage.securityCouncilMembers[msg.sender], \"a9\"); // not a security council member\n        uint256 currentProposalId = s.diamondCutStorage.currentProposalId;\n        require(s.diamondCutStorage.securityCouncilMemberLastApprovedProposalId[msg.sender] < currentProposalId, \"ao\"); // already approved this proposal\n        s.diamondCutStorage.securityCouncilMemberLastApprovedProposalId[msg.sender] = currentProposalId;\n\n        require(s.diamondCutStorage.proposedDiamondCutTimestamp != 0, \"f0\"); // there is no proposed diamond cut\n        require(s.diamondCutStorage.proposedDiamondCutHash == _diamondCutHash, \"f1\"); // proposed diamond cut do not match to the approved\n        uint256 securityCouncilEmergencyApprovals = s.diamondCutStorage.securityCouncilEmergencyApprovals;\n        s.diamondCutStorage.securityCouncilEmergencyApprovals = securityCouncilEmergencyApprovals + 1;\n\n        emit EmergencyDiamondCutApproved(\n            msg.sender,\n            currentProposalId,\n            securityCouncilEmergencyApprovals,\n            _diamondCutHash\n        );\n    }\n\n    /// @dev Set up the proposed diamond cut state to the default values\n    /// @return Whether the proposal is reset or it was already empty\n    function _resetProposal() private returns (bool) {\n        if (s.diamondCutStorage.proposedDiamondCutTimestamp == 0) {\n            return false;\n        }\n\n        delete s.diamondCutStorage.proposedDiamondCutHash;\n        delete s.diamondCutStorage.proposedDiamondCutTimestamp;\n        delete s.diamondCutStorage.securityCouncilEmergencyApprovals;\n\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author Matter Labs\n/// @notice The helper library for managing the EIP-2535 diamond proxy.\nlibrary Diamond {\n    /// @dev Magic value that should be returned by diamond cut initialize contracts.\n    /// @dev Used to distinguish calls to contracts that were supposed to be used as diamond initializer from other contracts.\n    bytes32 constant DIAMOND_INIT_SUCCESS_RETURN_VALUE =\n        0x33774e659306e47509050e97cb651e731180a42d458212294d30751925c551a2; // keccak256(\"diamond.zksync.init\") - 1\n\n    /// @dev Storage position of `DiamondStorage` structure.\n    bytes32 constant DIAMOND_STORAGE_POSITION = 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131b; // keccak256(\"diamond.standard.diamond.storage\") - 1;\n\n    event DiamondCut(FacetCut[] facetCuts, address initAddress, bytes initCalldata);\n\n    /// @dev Utility struct that contains associated facet & meta information of selector\n    /// @param facetAddress address of the facet which is connected with selector\n    /// @param selectorPosition index in `FacetToSelectors.selectors` array, where is selector stored\n    /// @param isFreezable denotes whether the selector can be frozen.\n    struct SelectorToFacet {\n        address facetAddress;\n        uint16 selectorPosition;\n        bool isFreezable;\n    }\n\n    /// @dev Utility struct that contains associated selectors & meta information of facet\n    /// @param selectors list of all selectors that belong to the facet\n    /// @param facetPosition index in `DiamondStorage.facets` array, where is facet stored\n    struct FacetToSelectors {\n        bytes4[] selectors;\n        uint16 facetPosition;\n    }\n\n    /// @notice The structure that holds all diamond proxy associated parameters\n    /// @dev According to the EIP-2535 should be stored on a special storage key - `DIAMOND_STORAGE_POSITION`\n    /// @param selectorToFacet A mapping from the selector to the facet address and its meta information\n    /// @param facetToSelectors A mapping from facet address to its selector with meta information\n    /// @param facets The array of all unique facet addresses that belong to the diamond proxy\n    /// @param isFrozen Denotes whether the diamond proxy is frozen and all freezable facets are not accessible\n    struct DiamondStorage {\n        mapping(bytes4 => SelectorToFacet) selectorToFacet;\n        mapping(address => FacetToSelectors) facetToSelectors;\n        address[] facets;\n        bool isFrozen;\n    }\n\n    /// @dev Parameters for diamond changes that touch one of the facets\n    /// @param facet The address of facet that's affected by the cut\n    /// @param action The action that is made on the facet\n    /// @param isFreezable Denotes whether the facet & all their selectors can be frozen\n    /// @param selectors An array of unique selectors that belongs to the facet address\n    struct FacetCut {\n        address facet;\n        Action action;\n        bool isFreezable;\n        bytes4[] selectors;\n    }\n\n    /// @dev Structure of the diamond proxy changes\n    /// @param facetCuts The set of changes (adding/removing/replacement) of implementation contracts\n    /// @param initAddress The address that's dellegate called after setting up new facet changes\n    /// @param initCalldata Calldata for the delegete call to `initAddress`\n    struct DiamondCutData {\n        FacetCut[] facetCuts;\n        address initAddress;\n        bytes initCalldata;\n    }\n\n    /// @dev Add/replace/remove any number of selectors and optionally execute a function with delegatecall\n    /// @param _diamondCut Diamond's facet changes and the parameters to optional initialization delegatecall\n    enum Action {\n        Add,\n        Replace,\n        Remove\n    }\n\n    /// @return diamondStorage The pointer to the storage where all specific diamond proxy parameters stored\n    function getDiamondStorage() internal pure returns (DiamondStorage storage diamondStorage) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            diamondStorage.slot := position\n        }\n    }\n\n    /// @dev Add/replace/remove any number of selectors and optionally execute a function with delegatecall\n    /// @param _diamondCut Diamond's facet changes and the parameters to optional initialization delegatecall\n    function diamondCut(DiamondCutData memory _diamondCut) internal {\n        FacetCut[] memory facetCuts = _diamondCut.facetCuts;\n        address initAddress = _diamondCut.initAddress;\n        bytes memory initCalldata = _diamondCut.initCalldata;\n        uint256 facetCutsLength = facetCuts.length;\n        for (uint256 i = 0; i < facetCutsLength; ++i) {\n            Action action = facetCuts[i].action;\n            address facet = facetCuts[i].facet;\n            bool isFacetFreezable = facetCuts[i].isFreezable;\n            bytes4[] memory selectors = facetCuts[i].selectors;\n\n            require(selectors.length > 0, \"B\"); // no functions for diamond cut\n\n            if (action == Action.Add) {\n                _addFunctions(facet, selectors, isFacetFreezable);\n            } else if (action == Action.Replace) {\n                _replaceFunctions(facet, selectors, isFacetFreezable);\n            } else if (action == Action.Remove) {\n                _removeFunctions(facet, selectors);\n            } else {\n                revert(\"C\"); // undefined diamond cut action\n            }\n        }\n\n        _initializeDiamondCut(initAddress, initCalldata);\n        emit DiamondCut(facetCuts, initAddress, initCalldata);\n    }\n\n    /// @dev Add new functions to the diamond proxy\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _addFunctions(\n        address _facet,\n        bytes4[] memory _selectors,\n        bool _isFacetFreezable\n    ) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        require(_facet != address(0), \"G\"); // facet with zero address cannot be added\n\n        // Add facet to the list of facets if the facet address is new one\n        _saveFacetIfNew(_facet);\n\n        uint256 selectorsLength = _selectors.length;\n        for (uint256 i = 0; i < selectorsLength; ++i) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress == address(0), \"J\"); // facet for this selector already exists\n\n            _addOneFunction(_facet, selector, _isFacetFreezable);\n        }\n    }\n\n    /// @dev Change associated facets to already known function selectors\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _replaceFunctions(\n        address _facet,\n        bytes4[] memory _selectors,\n        bool _isFacetFreezable\n    ) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        require(_facet != address(0), \"K\"); // cannot replace facet with zero address\n\n        uint256 selectorsLength = _selectors.length;\n        for (uint256 i = 0; i < selectorsLength; ++i) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress != address(0), \"L\"); // it is impossible to replace the facet with zero address\n\n            _removeOneFunction(oldFacet.facetAddress, selector);\n            // Add facet to the list of facets if the facet address is a new one\n            _saveFacetIfNew(_facet);\n            _addOneFunction(_facet, selector, _isFacetFreezable);\n        }\n    }\n\n    /// @dev Remove association with function and facet\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _removeFunctions(address _facet, bytes4[] memory _selectors) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        require(_facet == address(0), \"a1\"); // facet address must be zero\n\n        uint256 selectorsLength = _selectors.length;\n        for (uint256 i = 0; i < selectorsLength; ++i) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress != address(0), \"a2\"); // Can't delete a non-existent facet\n\n            _removeOneFunction(oldFacet.facetAddress, selector);\n        }\n    }\n\n    /// @dev Add address to the list of known facets if it is not on the list yet\n    /// NOTE: should be called ONLY before adding a new selector associated with the address\n    function _saveFacetIfNew(address _facet) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        uint256 selectorsLength = ds.facetToSelectors[_facet].selectors.length;\n        // If there are no selectors associated with facet then save facet as new one\n        if (selectorsLength == 0) {\n            ds.facetToSelectors[_facet].facetPosition = uint16(ds.facets.length);\n            ds.facets.push(_facet);\n        }\n    }\n\n    /// @dev Add one function to the already known facet\n    /// NOTE: It is expected but NOT enforced that:\n    /// - `_facet` is NON-ZERO address\n    /// - `_facet` is already stored address in `DiamondStorage.facets`\n    /// - `_selector` is NOT associated by another facet\n    function _addOneFunction(\n        address _facet,\n        bytes4 _selector,\n        bool _isSelectorFreezable\n    ) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        uint16 selectorPosition = uint16(ds.facetToSelectors[_facet].selectors.length);\n\n        // if selectorPosition is nonzero, it means it is not a new facet\n        // so the freezability of the first selector must be matched to _isSelectorFreezable\n        // so all the selectors in a facet will have the same freezability\n        if (selectorPosition != 0) {\n            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];\n            require(_isSelectorFreezable == ds.selectorToFacet[selector0].isFreezable, \"J1\");\n        }\n\n        ds.selectorToFacet[_selector] = SelectorToFacet({\n            facetAddress: _facet,\n            selectorPosition: selectorPosition,\n            isFreezable: _isSelectorFreezable\n        });\n        ds.facetToSelectors[_facet].selectors.push(_selector);\n    }\n\n    /// @dev Remove one associated function with facet\n    /// NOTE: It is expected but NOT enforced that `_facet` is NON-ZERO address\n    function _removeOneFunction(address _facet, bytes4 _selector) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Get index of `FacetToSelectors.selectors` of the selector and last element of array\n        uint256 selectorPosition = ds.selectorToFacet[_selector].selectorPosition;\n        uint256 lastSelectorPosition = ds.facetToSelectors[_facet].selectors.length - 1;\n\n        // If the selector is not at the end of the array then move the last element to the selector position\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetToSelectors[_facet].selectors[lastSelectorPosition];\n\n            ds.facetToSelectors[_facet].selectors[selectorPosition] = lastSelector;\n            ds.selectorToFacet[lastSelector].selectorPosition = uint16(selectorPosition);\n        }\n\n        // Remove last element from the selectors array\n        ds.facetToSelectors[_facet].selectors.pop();\n\n        // Finally, clean up the association with facet\n        delete ds.selectorToFacet[_selector];\n\n        // If there are no selectors for facet then remove the facet from the list of known facets\n        if (lastSelectorPosition == 0) {\n            _removeFacet(_facet);\n        }\n    }\n\n    /// @dev remove facet from the list of known facets\n    /// NOTE: It is expected but NOT enforced that there are no selectors associated wih `_facet`\n    function _removeFacet(address _facet) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Get index of `DiamondStorage.facets` of the facet and last element of array\n        uint256 facetPosition = ds.facetToSelectors[_facet].facetPosition;\n        uint256 lastFacetPosition = ds.facets.length - 1;\n\n        // If the facet is not at the end of the array then move the last element to the facet position\n        if (facetPosition != lastFacetPosition) {\n            address lastFacet = ds.facets[lastFacetPosition];\n\n            ds.facets[facetPosition] = lastFacet;\n            ds.facetToSelectors[lastFacet].facetPosition = uint16(facetPosition);\n        }\n\n        // Remove last element from the facets array\n        ds.facets.pop();\n    }\n\n    /// @dev Delegates call to the initialization address with provided calldata\n    /// @dev Used as a final step of diamond cut to execute the logic of the initialization for changed facets\n    function _initializeDiamondCut(address _init, bytes memory _calldata) private {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"H\"); // Non-empty calldata for zero address\n        } else {\n            // Do not check whether `_init` is a contract since later we check that it returns data.\n            (bool success, bytes memory data) = _init.delegatecall(_calldata);\n            require(success, \"I\"); // delegatecall failed\n\n            // Check that called contract returns magic value to make sure that contract logic\n            // supposed to be used as diamond cut initializer.\n            require(data.length == 32, \"lp\");\n            require(abi.decode(data, (bytes32)) == DIAMOND_INIT_SUCCESS_RETURN_VALUE, \"lp1\");\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "DiamondCut.sol",
            "Diamond.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "diamondCut function in Diamond.sol and DiamondCut.sol",
                "Type": "Governor key leakage",
                "Description": "If the governor's key is leaked, the attacker can execute the proposal earlier than the governor with malicious _calldata.",
                "Repair": "Include _calldata in the proposed diamondCut or have at least one security council member approve the _calldata during execution of the proposal"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nbytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n/// @dev Bytes in raw L2 log\n/// @dev Equal to the bytes size of the tuple - (uint8 ShardId, bool isService, uint16 txNumberInBlock, address sender, bytes32 key, bytes32 value)\nuint256 constant L2_TO_L1_LOG_SERIALIZE_SIZE = 88;\n\n/// @dev Length of the bytes array with L2->L1 logs\nuint256 constant L2_TO_L1_LOGS_COMMITMENT_BYTES = 4 + L2_TO_L1_LOG_SERIALIZE_SIZE * 512;\n\n/// @dev L2 -> L1 logs Merkle tree height\nuint256 constant L2_TO_L1_LOG_MERKLE_TREE_HEIGHT = 9;\n\n/// @dev The value of default leaf hash for L2 -> L1 logs Merkle tree\n/// @dev An incomplete fixed-size tree is filled with this value to be a full binary tree\n/// @dev Actually equal to the `keccak256(new bytes(L2_LOG_BYTES))`\nbytes32 constant L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH = 0x72abee45b59e344af8a6e520241c4744aff26ed411f4c4b00f8af09adada43ba;\n\n/// @dev Length of the bytes array with initial storage changes\nuint256 constant INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + 64 * 4896;\n\n/// @dev Length of the bytes array with repeated storage changes\nuint256 constant REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + 40 * 7787;\n\n// TODO: change constant to the real root hash of empty Merkle tree (SMA-184)\nbytes32 constant DEFAULT_L2_LOGS_TREE_ROOT_HASH = bytes32(0);\n\n/// @dev The address of the special smart contract that can send arbitrary length message as an L2 log\naddress constant L2_TO_L1_MESSENGER = address(0x8008);\n\n/// @dev The address of the bootloader start program\naddress constant L2_BOOTLOADER_ADDRESS = address(0x8001);\n\n/// @dev The address of the known code storage system contract\naddress constant L2_KNOWN_CODE_STORAGE_ADDRESS = address(0x8004);\n\n/// @dev The address of the context system contract\naddress constant L2_SYSTEM_CONTEXT_ADDRESS = address(0x800b);\n\n/// @dev Denotes the first byte of the zkSync transaction that came from L1.\nuint256 constant PRIORITY_OPERATION_L2_TX_TYPE = 255;\n\n/// @dev Expected average period of block creation\nuint256 constant BLOCK_PERIOD = 13 seconds;\n\n/// @dev Expiration delta for priority request to be satisfied (in seconds)\n/// @dev otherwise incorrect block with priority op could not be reverted.\nuint256 constant PRIORITY_EXPIRATION_PERIOD = 3 days;\n\n/// @dev Expiration delta for priority request to be satisfied (in ETH blocks)\nuint256 constant PRIORITY_EXPIRATION = $(\n    defined(PRIORITY_EXPIRATION) ? PRIORITY_EXPIRATION : PRIORITY_EXPIRATION_PERIOD / BLOCK_PERIOD\n);\n\n/// @dev Notice period before activation preparation status of upgrade mode (in seconds)\n/// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this operation and withdraw funds from it.\nuint256 constant UPGRADE_NOTICE_PERIOD = $$(defined(UPGRADE_NOTICE_PERIOD) ? UPGRADE_NOTICE_PERIOD : \"14 days\");\n\n/// @dev Timestamp - seconds since unix epoch\nuint256 constant COMMIT_TIMESTAMP_NOT_OLDER = $$(\n    defined(COMMIT_TIMESTAMP_NOT_OLDER) ? COMMIT_TIMESTAMP_NOT_OLDER : \"365 days\"\n);\n\n/// @dev Maximum available error between real commit block timestamp and analog used in the verifier (in seconds)\n/// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 15 seconds)\nuint256 constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = $$(\n    defined(COMMIT_TIMESTAMP_APPROXIMATION_DELTA) ? COMMIT_TIMESTAMP_APPROXIMATION_DELTA : \"365 days\"\n);\n\n/// @dev Bit mask to apply for verifier public input before verifying.\nuint256 constant INPUT_MASK = $$(~uint256(0) >> 8);\n\n/// @dev The maximum number of ergs that a user can request for L1 -> L2 transactions\nuint256 constant PRIORITY_TX_MAX_ERGS_LIMIT = 2097152;\n\n/// @dev Number of security council members that should approve an emergency upgrade\nuint256 constant SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE = $$(\n    SECURITY_COUNCIL_APPROVALS_FOR_EMERGENCY_UPGRADE\n);\n\n\n",
        "CodeNames": [
            "Config.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "BLOCK_PERIOD constant in Config.sol",
                "Type": "Incorrect configuration",
                "Description": "Due to an incorrect configuration, L2Transactions will expire earlier than intended.",
                "Repair": "Change the block period to be 12 seconds"
            }
        ]
    }
]