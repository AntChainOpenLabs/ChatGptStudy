[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./access/Authorization.sol\";\n\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/vendor/IRewardStaking.sol\";\nimport \"../interfaces/vendor/ICrvDepositor.sol\";\nimport \"../interfaces/vendor/IDelegation.sol\";\nimport \"../interfaces/vendor/IvlCvxExtraRewardDistribution.sol\";\nimport \"../interfaces/vendor/ICurveSwap.sol\";\nimport \"../interfaces/vendor/ICvxLocker.sol\";\nimport \"../interfaces/ICvxCrvRewardsLocker.sol\";\n\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\n\ncontract CvxCrvRewardsLocker is ICvxCrvRewardsLocker, Authorization {\n    using AddressProviderHelpers for IAddressProvider;\n\n    using SafeERC20 for IERC20;\n\n    // ERC20 tokens\n    address public constant CVX = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    address public constant CVX_CRV = address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n    address public constant CRV = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n\n    address public constant CVX_CRV_CRV_CURVE_POOL =\n        address(0x9D0464996170c6B9e75eED71c68B99dDEDf279e8); // cvxCRV/CRV Curve Pool\n    address public constant CRV_DEPOSITOR = address(0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae); // Lock CRV for cvxCRV\n    address public constant CVX_CRV_STAKING = address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e); // Stake cvxCRV and get rewards\n    address public constant CVX_LOCKER = address(0x72a19342e8F1838460eBFCCEf09F6585e32db86E); // CVX Locker\n    address public constant VL_CVX_EXTRA_REWARD_DISTRIBUTION =\n        address(0xDecc7d761496d30F30b92Bdf764fb8803c79360D);\n\n    uint256 public spendRatio;\n    bool public prepareWithdrawal;\n    address public treasury;\n\n    int128 private constant _CRV_INDEX = 0;\n    int128 private constant _CVX_CRV_INDEX = 1;\n\n    event NewSpendRatio(uint256 newSpendRatio);\n    event NewTreasury(address newTreasury);\n\n    constructor(IAddressProvider _addressProvider)\n        Authorization(_addressProvider.getRoleManager())\n    {\n        // Approve for locking CRV for cvxCRV\n        IERC20(CRV).safeApprove(CRV_DEPOSITOR, type(uint256).max);\n\n        // Approve for staking cvxCRV\n        IERC20(CVX_CRV).safeApprove(CVX_CRV_STAKING, type(uint256).max);\n\n        // Approve for cvxCRV/CRV Curve Pool Swaps\n        IERC20(CRV).safeApprove(CVX_CRV_CRV_CURVE_POOL, type(uint256).max);\n\n        // Approve CVX Locker\n        IERC20(CVX).safeApprove(CVX_LOCKER, type(uint256).max);\n\n        treasury = _addressProvider.getTreasury();\n    }\n\n    function lockCvx() external override {\n        _lockCvx();\n    }\n\n    function lockCrv() external override {\n        _lockCrv();\n    }\n\n    /**\n     * @notice Set spend ratio for CVX locking.\n     * @dev Spend ratio is the amount of CVX that should be donated to\n     * the Convex treasury to boost vote power. This needs to be enabled\n     * by Convex.\n     * @param _spendRatio New spend ratio to be used.\n     */\n    function setSpendRatio(uint256 _spendRatio) external onlyGovernance returns (bool) {\n        require(\n            _spendRatio <= ICvxLocker(CVX_LOCKER).maximumBoostPayment(),\n            Error.EXCEEDS_MAX_BOOST\n        );\n        spendRatio = _spendRatio;\n        emit NewSpendRatio(_spendRatio);\n        return true;\n    }\n\n    /**\n     * @notice Claim rewards from Convex.\n     * @dev Rewards to claim are for staked cvxCRV and locked CVX.\n     * @param lockAndStake If true, claimed reward tokens (CRV) will be locked and staked (CRV for cvxCRV and CVX for vlCVX).\n     */\n    function claimRewards(bool lockAndStake) external override returns (bool) {\n        ICvxLocker(CVX_LOCKER).getReward(address(this), false);\n\n        IRewardStaking(CVX_CRV_STAKING).getReward();\n\n        if (lockAndStake) {\n            lockRewards();\n        }\n        return true;\n    }\n\n    /**\n     * @notice Stakes cvxCRV in the cvxCRV rewards contract on Convex.\n     */\n    function stakeCvxCrv() external override returns (bool) {\n        return _stakeCvxCrv();\n    }\n\n    /**\n     * @notice Prepares a withdrawal of funds.\n     * @dev If this is set then no idle funds can get locked or staked.\n     */\n    function setWithdrawalFlag() external onlyGovernance {\n        prepareWithdrawal = true;\n    }\n\n    /**\n     * @notice Resets prepared withdrawal of funds.\n     */\n    function resetWithdrawalFlag() external onlyGovernance {\n        prepareWithdrawal = false;\n    }\n\n    /**\n     * @notice Processes exipred locks.\n     */\n    function processExpiredLocks(bool relock) external override returns (bool) {\n        if (relock) {\n            require(!prepareWithdrawal, Error.PREPARED_WITHDRAWAL);\n        }\n\n        if (relock) {\n            ICvxLocker(CVX_LOCKER).processExpiredLocks(relock);\n        } else {\n            ICvxLocker(CVX_LOCKER).withdrawExpiredLocksTo(treasury);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Set treasury to receive withdrawn funds.\n     */\n    function setTreasury(address _treasury) external onlyGovernance returns (bool) {\n        treasury = _treasury;\n        emit NewTreasury(treasury);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw full amount of a token to the treasury.\n     * @param token Token to withdraw entire balance of.\n     */\n    function withdraw(address token) external onlyGovernance returns (bool) {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(treasury, balance);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw cvxCRV to treasury.\n     * @dev Unstakes cvxCRV if it is staked.\n     */\n    function withdrawCvxCrv(uint256 amount) external onlyGovernance {\n        IRewardStaking(CVX_CRV_STAKING).withdraw(amount, true);\n        uint256 cvxcrvBal = IERC20(CVX_CRV).balanceOf(address(this));\n        if (cvxcrvBal > 0) {\n            IERC20(CVX_CRV).safeTransfer(treasury, cvxcrvBal);\n        }\n    }\n\n    function unstakeCvxCrv() external onlyGovernance {\n        unstakeCvxCrv(false);\n    }\n\n    function unstakeCvxCrv(uint256 amount, bool withdrawal) external onlyGovernance {\n        _unstakeCvxCrv(amount, withdrawal);\n    }\n\n    /**\n     * @notice Set delegate to receive vote weight.\n     */\n    function setDelegate(address delegateContract, address delegate) external onlyGovernance {\n        IDelegation(delegateContract).setDelegate(\"cvx.eth\", delegate);\n    }\n\n    /**\n     * @notice Clears a delegate for the msg.sender and a specific id.\n     */\n    function clearDelegate(address delegateContract) external onlyGovernance {\n        IDelegation(delegateContract).clearDelegate(\"cvx.eth\");\n    }\n\n    function forfeitRewards(address token, uint256 index) external onlyGovernance {\n        IvlCvxExtraRewardDistribution(VL_CVX_EXTRA_REWARD_DISTRIBUTION).forfeitRewards(\n            token,\n            index\n        );\n    }\n\n    /**\n     * @notice Lock CRV and CVX tokens.\n     * @dev CRV get locked for cvxCRV and staked on Convex.\n     */\n    function lockRewards() public returns (bool) {\n        _lockCrv();\n        _lockCvx();\n        return true;\n    }\n\n    /**\n     * @notice Withdraw an amount of a token to the treasury.\n     * @param token Token to withdraw.\n     * @param amount Amount of token to withdraw.\n     */\n    function withdraw(address token, uint256 amount) public onlyGovernance returns (bool) {\n        IERC20(token).safeTransfer(treasury, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake cvxCRV from Convex.\n     */\n    function unstakeCvxCrv(bool withdrawal) public onlyGovernance {\n        uint256 staked = IRewardStaking(CVX_CRV_STAKING).balanceOf(address(this));\n        _unstakeCvxCrv(staked, withdrawal);\n    }\n\n    function _lockCrv() internal {\n        if (prepareWithdrawal) return;\n\n        uint256 currentBalance = IERC20(CRV).balanceOf(address(this));\n        if (currentBalance != 0) {\n            // Checks if we can get a better rate on Curve Pool\n            uint256 amountOut = ICurveSwap(CVX_CRV_CRV_CURVE_POOL).get_dy(\n                _CRV_INDEX,\n                _CVX_CRV_INDEX,\n                currentBalance\n            );\n            if (amountOut > currentBalance) {\n                ICurveSwap(CVX_CRV_CRV_CURVE_POOL).exchange(\n                    _CRV_INDEX,\n                    _CVX_CRV_INDEX,\n                    currentBalance,\n                    0\n                );\n            } else {\n                // Swap CRV for cxvCRV and stake\n                ICrvDepositor(CRV_DEPOSITOR).deposit(currentBalance, false, address(0));\n            }\n            IRewardStaking(CVX_CRV_STAKING).stakeAll();\n            return;\n        }\n\n        if (IERC20(CVX_CRV).balanceOf(address(this)) > 0)\n            IRewardStaking(CVX_CRV_STAKING).stakeAll();\n    }\n\n    function _lockCvx() internal {\n        // Locks CVX for vlCVX\n        if (prepareWithdrawal) return;\n        uint256 currentBalance = IERC20(CVX).balanceOf(address(this));\n        if (currentBalance == 0) return;\n        ICvxLocker(CVX_LOCKER).lock(address(this), currentBalance, spendRatio);\n    }\n\n    function _stakeCvxCrv() internal returns (bool) {\n        if (prepareWithdrawal) return false;\n\n        if (IERC20(CVX_CRV).balanceOf(address(this)) == 0) return false;\n        IRewardStaking(CVX_CRV_STAKING).stakeAll();\n        return true;\n    }\n\n    function _unstakeCvxCrv(uint256 amount, bool withdrawal) internal {\n        IRewardStaking(CVX_CRV_STAKING).withdraw(amount, true);\n        if (withdrawal) {\n            IERC20(CVX_CRV).safeTransfer(treasury, amount);\n        }\n    }\n}\n\n\n",
        "CodeNames": [
            "CvxCrvRewardsLocker.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "CvxCrvRewardsLocker contract",
                "Type": "MEV vulnerability",
                "Description": "The CvxCrvRewardsLocker contract swaps tokens through the CRV cvxCRV pool without using any slippage checks, which can result in a loss of funds through MEV.",
                "Repair": "Use a proper value for minOut instead of 0."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../access/Authorization.sol\";\nimport \"./IStrategySwapper.sol\";\nimport \"../../interfaces/vendor/UniswapRouter02.sol\";\nimport \"../../interfaces/vendor/ICurveSwapEth.sol\";\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../interfaces/IERC20Full.sol\";\nimport \"../../interfaces/vendor/IWETH.sol\";\n\ncontract StrategySwapper is IStrategySwapper, Authorization {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IWETH internal constant _WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH\n    UniswapRouter02 internal constant _SUSHISWAP =\n        UniswapRouter02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Sushiswap Router for swaps\n    UniswapRouter02 internal constant _UNISWAP =\n        UniswapRouter02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // Uniswap Router for swaps\n\n    IAddressProvider internal immutable _addressProvider; // Address provider used for getting oracle provider\n\n    uint256 public slippageTolerance; // The amount of slippage to allow from the oracle price of an asset\n    mapping(address => ICurveSwapEth) public curvePools; // Curve Pool to use for swaps to ETH (if any)\n    mapping(address => bool) public swapViaUniswap; // If Uniswap should be used over Sushiswap for swaps\n\n    event SetSlippageTolerance(uint256 value); // Emitted after a succuessful setting of slippage tolerance\n    event SetCurvePool(address token, address curvePool); // Emitted after a succuessful setting of a Curve Pool\n    event SetSwapViaUniswap(address token, bool swapViaUniswap); // Emitted after a succuessful setting of swap via Uniswap\n\n    constructor(address addressProvider_, uint256 slippageTolerance_)\n        Authorization(IAddressProvider(addressProvider_).getRoleManager())\n    {\n        _addressProvider = IAddressProvider(addressProvider_);\n        slippageTolerance = slippageTolerance_;\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Swaps all the balance of a token for WETH.\n     * @param token_ Address of the token to swap for WETH.\n     */\n    function swapAllForWeth(address token_) external override {\n        return swapForWeth(token_, IERC20(token_).balanceOf(msg.sender));\n    }\n\n    /**\n     * @notice Swaps all available WETH for underlying.\n     * @param token_ Address of the token to swap WETH to.\n     */\n    function swapAllWethForToken(address token_) external override {\n        IWETH weth_ = _WETH;\n        uint256 wethBalance_ = weth_.balanceOf(msg.sender);\n        if (wethBalance_ == 0) return;\n        weth_.transferFrom(msg.sender, address(this), wethBalance_);\n\n        if (token_ == address(0)) {\n            weth_.withdraw(wethBalance_);\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool sent, ) = payable(msg.sender).call{value: wethBalance_}(\"\");\n            require(sent, \"failed to send eth\");\n            return;\n        }\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            _approve(address(weth_), address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                wethIndex_,\n                tokenIndex_,\n                wethBalance_,\n                _minTokenAmountOut(wethBalance_, token_)\n            );\n            IERC20(token_).safeTransfer(msg.sender, IERC20(token_).balanceOf(address(this)));\n            return;\n        }\n\n        // Handling Uniswap or Sushiswap swaps\n        address[] memory path_ = new address[](2);\n        path_[0] = address(weth_);\n        path_[1] = token_;\n        UniswapRouter02 dex_ = _getDex(token_);\n        _approve(address(weth_), address(dex_));\n        uint256 amountOut_ = dex_.swapExactTokensForTokens(\n            wethBalance_,\n            _minTokenAmountOut(wethBalance_, token_),\n            path_,\n            address(this),\n            block.timestamp\n        )[1];\n        IERC20(token_).safeTransfer(msg.sender, amountOut_);\n    }\n\n    /**\n     * @notice Set slippage tolerance for swaps.\n     * @dev Stored as a multiplier, e.g. 2% would be set as 0.98.\n     * @param slippageTolerance_ New slippage tolerance.\n     */\n    function setSlippageTolerance(uint256 slippageTolerance_) external override onlyGovernance {\n        require(slippageTolerance_ <= ScaledMath.ONE, Error.INVALID_SLIPPAGE_TOLERANCE);\n        require(slippageTolerance_ > 0.8e18, Error.INVALID_SLIPPAGE_TOLERANCE);\n        slippageTolerance = slippageTolerance_;\n        emit SetSlippageTolerance(slippageTolerance_);\n    }\n\n    /**\n     * @notice Sets the Curve Pool to use for swapping a token with WETH.\n     * @dev To use Uniswap or Sushiswap instead, set the Curve Pool to the zero address.\n     * @param token_ The token to set the Curve Pool for.\n     * @param curvePool_ The address of the Curve Pool.\n     */\n    function setCurvePool(address token_, address curvePool_) external override onlyGovernance {\n        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(curvePool_ != address(curvePools[token_]), Error.SAME_ADDRESS_NOT_ALLOWED);\n        curvePools[token_] = ICurveSwapEth(curvePool_);\n        emit SetCurvePool(token_, curvePool_);\n    }\n\n    /**\n     * @notice Sets if swaps should go via Uniswap for the given token_.\n     * @param token_ The token to set the swapViaUniswap for.\n     * @param swapViaUniswap_ If Sushiswap should be use for swaps for token_.\n     */\n    function setSwapViaUniswap(address token_, bool swapViaUniswap_)\n        external\n        override\n        onlyGovernance\n    {\n        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        swapViaUniswap[token_] = swapViaUniswap_;\n        emit SetSwapViaUniswap(token_, swapViaUniswap_);\n    }\n\n    /**\n     * @notice Gets the amount of tokenOut_ that would be received by swapping amountIn_ of tokenIn_.\n     * @param tokenIn_ The token to swap in.\n     * @param tokenOut_ The token to get out.\n     * @param amountIn_ The amount to swap in.\n     * @return The amount of tokenOut_ that would be received by swapping amountIn_ of tokenIn_.\n     */\n    function amountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view override returns (uint256) {\n        if (amountIn_ == 0) return 0;\n        uint256 wethOut_ = _tokenToWethAmountOut(tokenIn_, amountIn_);\n        return _wethToTokenAmountOut(tokenOut_, wethOut_);\n    }\n\n    /**\n     * @notice Swaps a token for WETH.\n     * @param token_ Address of the token to swap for WETH.\n     * @param amount_ Amount of the token to swap for WETH.\n     */\n    function swapForWeth(address token_, uint256 amount_) public override {\n        if (amount_ == 0) return;\n        IERC20(token_).safeTransferFrom(msg.sender, address(this), amount_);\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        IWETH weth_ = _WETH;\n        if (address(curvePool_) != address(0)) {\n            _approve(token_, address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                tokenIndex_,\n                wethIndex_,\n                amount_,\n                _minWethAmountOut(amount_, token_)\n            );\n            IERC20(weth_).safeTransfer(msg.sender, weth_.balanceOf(address(this)));\n            return;\n        }\n\n        // Handling Uniswap or Sushiswap swaps\n        address[] memory path_ = new address[](2);\n        path_[0] = token_;\n        path_[1] = address(weth_);\n        UniswapRouter02 dex_ = _getDex(token_);\n        _approve(token_, address(dex_));\n        uint256 amountOut_ = dex_.swapExactTokensForTokens(\n            amount_,\n            _minWethAmountOut(amount_, token_),\n            path_,\n            address(this),\n            block.timestamp\n        )[1];\n        IERC20(weth_).safeTransfer(msg.sender, amountOut_);\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token_ The token to approve for.\n     * @param spender_ The spender to approve.\n     */\n    function _approve(address token_, address spender_) internal {\n        if (IERC20(token_).allowance(address(this), spender_) > 0) return;\n        IERC20(token_).safeApprove(spender_, type(uint256).max);\n    }\n\n    /**\n     * @dev Gets the dex to use for swapping a given token.\n     * @param token_ The token to get the dex for.\n     * @return The dex to use for swapping a given token.\n     */\n    function _getDex(address token_) internal view returns (UniswapRouter02) {\n        return swapViaUniswap[token_] ? _UNISWAP : _SUSHISWAP;\n    }\n\n    /**\n     * @dev Returns the amount of WETH received by swapping amount_ of token_.\n     * @param token_ The token to get the amount for swapping to WETH.\n     * @param amount_ The amount of token_ that is being swapped to WETH.\n     * @return The amount of WETH received by swapping amount_ of token_.\n     */\n    function _tokenToWethAmountOut(address token_, uint256 amount_)\n        internal\n        view\n        returns (uint256)\n    {\n        if (amount_ == 0) return 0;\n        IWETH weth_ = _WETH;\n        if (token_ == address(weth_)) return amount_;\n        if (token_ == address(0)) return amount_;\n\n        // Getting amount via Curve Pool if set\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            return curvePool_.get_dy(tokenIndex_, wethIndex_, amount_);\n        }\n\n        // Getting amount via Uniswap or Sushiswap\n        address[] memory path_ = new address[](2);\n        path_[0] = token_;\n        path_[1] = address(weth_);\n        return _getDex(token_).getAmountsOut(amount_, path_)[1];\n    }\n\n    /**\n     * @dev Returns the amount of token_ received by swapping amount_ of WETH.\n     * @param token_ The token to get the amount for swapping from WETH.\n     * @param amount_ The amount of WETH that is being swapped to token_.\n     * @return The amount of token_ received by swapping amount_ of WETH.\n     */\n    function _wethToTokenAmountOut(address token_, uint256 amount_)\n        internal\n        view\n        returns (uint256)\n    {\n        if (amount_ == 0) return 0;\n        IWETH weth_ = _WETH;\n        if (token_ == address(weth_)) return amount_;\n        if (token_ == address(0)) return amount_;\n\n        // Getting amount via Curve Pool if set\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            return curvePool_.get_dy(wethIndex_, tokenIndex_, amount_);\n        }\n\n        // Getting amount via Uniswap or Sushiswap\n        address[] memory path_ = new address[](2);\n        path_[0] = address(weth_);\n        path_[1] = token_;\n        return _getDex(token_).getAmountsOut(amount_, path_)[1];\n    }\n\n    /**\n     * @dev Returns the multiplier for converting a token_ amount to the same decimals as WETH.\n     *   For example, USDC (which has decimals of 6) would have a multiplier of 12e18.\n     * @param token_ The token to get the decimal multiplier for.\n     * @return the multiplier for converting a token_ amount to the same decimals as WETH.\n     */\n    function _decimalMultiplier(address token_) internal view returns (uint256) {\n        return 10**(18 - IERC20Full(token_).decimals());\n    }\n\n    /**\n     * @dev Returns the Curve Pool coin indicies for a given Token.\n     * @param curvePool_ The Curve Pool to return the indicies for.\n     * @param token_ The Token to get the indicies for.\n     * @return wethIndex_ The coin index for WETH.\n     * @return tokenIndex_ The coin index for the Token.\n     */\n    function _getIndices(ICurveSwapEth curvePool_, address token_)\n        internal\n        view\n        returns (uint256 wethIndex_, uint256 tokenIndex_)\n    {\n        return curvePool_.coins(1) == token_ ? (0, 1) : (1, 0);\n    }\n\n    /**\n     * @dev Returns the minimum amount of Token to recieve from swap.\n     * @param wethAmount_ The amount of WETH being swapped.\n     * @param token_ The Token the WETH is being swapped to.\n     * @return minAmountOut The minimum amount of Token to recieve from swap.\n     */\n    function _minTokenAmountOut(uint256 wethAmount_, address token_)\n        internal\n        view\n        returns (uint256 minAmountOut)\n    {\n        return\n            wethAmount_\n                .scaledDiv(_addressProvider.getOracleProvider().getPriceETH(token_))\n                .scaledMul(slippageTolerance) / _decimalMultiplier(token_);\n    }\n\n    /**\n     * @dev Returns the minimum amount of WETH to recieve from swap.\n     * @param tokenAmount_ The amount of Token being swapped.\n     * @param token_ The Token that is being swapped for WETH.\n     * @return minAmountOut The minimum amount of WETH to recieve from swap.\n     */\n    function _minWethAmountOut(uint256 tokenAmount_, address token_)\n        internal\n        view\n        returns (uint256 minAmountOut)\n    {\n        return\n            tokenAmount_\n                .scaledMul(_addressProvider.getOracleProvider().getPriceETH(token_))\n                .scaledMul(slippageTolerance) * _decimalMultiplier(token_);\n    }\n}\n\n\n",
        "CodeNames": [
            "StrategySwapper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "constructor and setting method for slippageTolerance in StrategySwapper.sol",
                "Type": "Inconsistency",
                "Description": "There is an inconsistency between the constructor and setting method for slippageTolerance in StrategySwapper.sol, which can lead to errors.",
                "Repair": "Add the corresponding validations to the constructor."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../interfaces/IRoleManager.sol\";\n\nimport \"../../libraries/Roles.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/AddressProviderKeys.sol\";\n\ncontract RoleManager is IRoleManager {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n    mapping(bytes32 => RoleData) private _roles;\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    IAddressProvider public immutable addressProvider;\n\n    modifier onlyGovernance() {\n        require(hasRole(Roles.GOVERNANCE, msg.sender), Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IAddressProvider _addressProvider) {\n        addressProvider = _addressProvider;\n        _grantRole(Roles.GOVERNANCE, msg.sender);\n    }\n\n    function grantRole(bytes32 role, address account) external onlyGovernance {\n        _grantRole(role, account);\n    }\n\n    function addGovernor(address newGovernor) external onlyGovernance {\n        _grantRole(Roles.GOVERNANCE, newGovernor);\n    }\n\n    function renounceGovernance() external onlyGovernance {\n        require(getRoleMemberCount(Roles.GOVERNANCE) > 1, Error.CANNOT_REVOKE_ROLE);\n        _revokeRole(Roles.GOVERNANCE, msg.sender);\n    }\n\n    function addGaugeZap(address zap) external onlyGovernance {\n        _grantRole(Roles.GAUGE_ZAP, zap);\n    }\n\n    function removeGaugeZap(address zap) external {\n        revokeRole(Roles.GAUGE_ZAP, zap);\n    }\n\n    function hasAnyRole(\n        bytes32 role1,\n        bytes32 role2,\n        address account\n    ) external view returns (bool) {\n        return hasRole(role1, account) || hasRole(role2, account);\n    }\n\n    function hasAnyRole(\n        bytes32 role1,\n        bytes32 role2,\n        bytes32 role3,\n        address account\n    ) external view returns (bool) {\n        return hasRole(role1, account) || hasRole(role2, account) || hasRole(role3, account);\n    }\n\n    function hasAnyRole(bytes32[] memory roles, address account)\n        external\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        for (uint256 i = 0; i < roles.length; i++) {\n            if (hasRole(roles[i], account)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getRoleMember(bytes32 role, uint256 index)\n        external\n        view\n        virtual\n        override\n        returns (address)\n    {\n        if (role == Roles.ADDRESS_PROVIDER && index == 0) {\n            return address(addressProvider);\n        } else if (role == Roles.POOL_FACTORY && index == 0) {\n            return addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY);\n        } else if (role == Roles.CONTROLLER && index == 0) {\n            return addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY);\n        } else if (role == Roles.POOL) {\n            return addressProvider.getPoolAtIndex(index);\n        } else if (role == Roles.VAULT) {\n            return addressProvider.getVaultAtIndex(index);\n        }\n        return _roleMembers[role].at(index);\n    }\n\n    function revokeRole(bytes32 role, address account) public onlyGovernance {\n        require(role != Roles.GOVERNANCE, Error.CANNOT_REVOKE_ROLE);\n        require(hasRole(role, account), Error.INVALID_ARGUMENT);\n        _revokeRole(role, account);\n    }\n\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        if (\n            role == Roles.ADDRESS_PROVIDER || role == Roles.POOL_FACTORY || role == Roles.CONTROLLER\n        ) {\n            return 1;\n        }\n        if (role == Roles.POOL) {\n            return addressProvider.poolsCount();\n        }\n        if (role == Roles.VAULT) {\n            return addressProvider.vaultsCount();\n        }\n        return _roleMembers[role].length();\n    }\n\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        if (role == Roles.ADDRESS_PROVIDER) {\n            return account == address(addressProvider);\n        } else if (role == Roles.POOL_FACTORY) {\n            return\n                account == addressProvider.getAddress(AddressProviderKeys._POOL_FACTORY_KEY, false);\n        } else if (role == Roles.CONTROLLER) {\n            return\n                account == addressProvider.getAddress(AddressProviderKeys._CONTROLLER_KEY, false);\n        } else if (role == Roles.MAINTENANCE) {\n            return _roles[role].members[account] || _roles[Roles.GOVERNANCE].members[account];\n        } else if (role == Roles.POOL) {\n            return addressProvider.isPool(account);\n        } else if (role == Roles.VAULT) {\n            return addressProvider.isVault(account);\n        }\n        return _roles[role].members[account];\n    }\n\n    function _grantRole(bytes32 role, address account) internal {\n        _roles[role].members[account] = true;\n        _roleMembers[role].add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    function _revokeRole(bytes32 role, address account) internal {\n        _roles[role].members[account] = false;\n        emit RoleRevoked(role, account, msg.sender);\n    }\n}\n\n\n",
        "CodeNames": [
            "RoleManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "RoleManager.sol",
                "Type": "Loss of governance control",
                "Description": "There is a possibility of losing all governance control due to a corner case in RoleManager.sol, which can lead to a high impact.",
                "Repair": "Add a new function to know who are the active members for any role, like getRoleMembers(bytes32 role) returning address account."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../../interfaces/IGasBank.sol\";\nimport \"../../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../../interfaces/ISwapperRegistry.sol\";\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IStakerVault.sol\";\nimport \"../../../interfaces/ISwapper.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpHandler.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpAction.sol\";\nimport \"../../../interfaces/actions/IActionFeeHandler.sol\";\n\nimport \"../../../libraries/AddressProviderHelpers.sol\";\nimport \"../../../libraries/Errors.sol\";\nimport \"../../../libraries/ScaledMath.sol\";\nimport \"../../../libraries/EnumerableExtensions.sol\";\n\nimport \"../../access/Authorization.sol\";\nimport \"../../utils/Preparable.sol\";\n\n/**\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount > 0) {\n            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft > 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance < allowance ? balance : allowance;\n            if (availableFunds >= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /**\n     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.\n     */\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /**\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being \"too deep\"\n     */\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = \"ActionFee\";\n    bytes32 internal constant _FEE_HANDLER_KEY = \"FeeHandler\";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = \"TopUpHandler\";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = \"EstimatedGasUsage\";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = \"MaxSwapperSlippage\";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -> account -> protocol -> Record)\n    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;\n\n    mapping(address => RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i < protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /**\n     * @notice Register a top up action.\n     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of `depositToken` that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     */\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);\n        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *\n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /**\n     * @notice See overloaded version of `execute` for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /**\n     * @notice Delete a position to back on the given protocol for `account`.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return `true` if successful.\n     */\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /**\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /**\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return `true` if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /**\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return `true` if success.\n     */\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /**\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return `true` if success.\n     */\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&\n                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /**\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /** Set fee handler */\n    /**\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return `true` if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /**\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Reset the handler deadline.\n     * @return `true` if success.\n     */\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return `true` if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /**\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return `true` if successful.\n     */\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Reset the gas usage deadline.\n     * @return `true` if success.\n     */\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /**\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i < length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /**\n     * @notice Returns a list of positions for the given payer\n     */\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /**\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     */\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32[](length);\n        for (uint256 i = 0; i < length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /*\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = _usersWithPositions.length();\n        if (cursor >= length) return (new address[](0), 0);\n        if (howMany >= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions_ = new address[](howMany);\n        for (uint256 i = 0; i < howMany; i++) {\n            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions_, cursor + howMany);\n    }\n\n    /**\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     */\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /**\n     * @notice Retrieves the topup handler for the given `protocol`\n     */\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /**\n     * @notice Successfully tops up a position if it's conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper's wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return `true` if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas <=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance < vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly `vars.actionTokenAmount`\n        // (at least `position.singleTopUpAmount`) of action token\n        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                \"topUp(bytes32,address,uint256,bytes)\",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new \"balance\" of the position\n        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance > 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return `true` if success.\n     */\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /**\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     */\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /**\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /**\n     * @notice Returns the current action fee\n     */\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current max swapper slippage\n     */\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /**\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /**\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     */\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /**\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     */\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /**\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who's position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /**\n     * @dev \"Locks\" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of `token` to lock\n     * @param depositAmount Amount of `token` that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than `requiredAmount` more tokens will be locked.\n     */\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i < length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account && positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) > 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /**\n     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n\n\n",
        "CodeNames": [
            "TopUpAction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TopUpAction.sol",
                "Type": "Denial of service attack",
                "Description": "Malicious Stakers can grief Keepers by deploying a smart contract to the payer address that has implemented a receive() function that calls revert(), which can lead to a denial of service attack.",
                "Repair": "Add some way of blacklisting badly behaved Stakers."
            },
            {
                "Location": "TopUpAction.sol",
                "Type": "Sandwich attack",
                "Description": "The default swap slippage of 5% allows malicious keepers to sandwich attack topup, which can lead to a medium impact.",
                "Repair": "Allow user to specify max swap slippage when creating topup similar to how it's specified on uniswap or sushiswap to block attacks from both keepers and owners."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/AddressProviderHelpers.sol\";\n\nimport \"../interfaces/IStakerVault.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/tokenomics/IRewardsGauge.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/pool/ILiquidityPool.sol\";\nimport \"../interfaces/tokenomics/ILpGauge.sol\";\nimport \"../interfaces/IERC20Full.sol\";\n\nimport \"./utils/Preparable.sol\";\nimport \"./Controller.sol\";\nimport \"./pool/LiquidityPool.sol\";\nimport \"./access/Authorization.sol\";\nimport \"./utils/Pausable.sol\";\n\n/**\n * @notice This contract handles staked tokens from Backd pools\n * However, not that this is NOT an ERC-20 compliant contract and these\n * tokens should never be integrated with any protocol assuming ERC-20 compliant\n * tokens\n * @dev When paused, allows only withdraw/unstake\n */\ncontract StakerVault is IStakerVault, Authorization, Pausable, Initializable, Preparable {\n    using AddressProviderHelpers for IAddressProvider;\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n\n    bytes32 internal constant _LP_GAUGE = \"lpGauge\";\n\n    IController public immutable controller;\n\n    address public token;\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public actionLockedBalances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    // All the data fields required for the staking tracking\n    uint256 private _poolTotalStaked;\n\n    mapping(address => bool) public strategies;\n    uint256 public strategiesTotalStaked;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        controller = _controller;\n    }\n\n    function initialize(address _token) external override initializer {\n        token = _token;\n    }\n\n    function initializeLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {\n        require(currentAddresses[_LP_GAUGE] == address(0), Error.ROLE_EXISTS);\n        _setConfig(_LP_GAUGE, _lpGauge);\n        controller.inflationManager().addGaugeForVault(token);\n        return true;\n    }\n\n    function prepareLpGauge(address _lpGauge) external override onlyGovernance returns (bool) {\n        _prepare(_LP_GAUGE, _lpGauge);\n        return true;\n    }\n\n    function executeLpGauge() external override onlyGovernance returns (bool) {\n        _executeAddress(_LP_GAUGE);\n        controller.inflationManager().addGaugeForVault(token);\n        return true;\n    }\n\n    /**\n     * @notice Registers an address as a strategy to be excluded from token accumulation.\n     * @dev This should be used is a strategy deposits into a stakerVault and should not get gov. tokens.\n     * @return `true` if success.\n     */\n    function addStrategy(address strategy) external override returns (bool) {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        strategies[strategy] = true;\n        return true;\n    }\n\n    /**\n     * @notice Transfer staked tokens to an account.\n     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.\n     * @param account Address to transfer to.\n     * @param amount Amount to transfer.\n     * @return `true` if success.\n     */\n    function transfer(address account, uint256 amount) external override notPaused returns (bool) {\n        require(msg.sender != account, Error.SELF_TRANSFER_NOT_ALLOWED);\n        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);\n\n        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);\n        pool.handleLpTokenTransfer(msg.sender, account, amount);\n\n        balances[msg.sender] -= amount;\n        balances[account] += amount;\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(msg.sender);\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        emit Transfer(msg.sender, account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer staked tokens from src to dst.\n     * @dev This is not an ERC20 transfer, as tokens are still owned by this contract, but fees get updated in the LP pool.\n     * @param src Address to transfer from.\n     * @param dst Address to transfer to.\n     * @param amount Amount to transfer.\n     * @return `true` if success.\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override notPaused returns (bool) {\n        /* Do not allow self transfers */\n        require(src != dst, Error.SAME_ADDRESS_NOT_ALLOWED);\n\n        address spender = msg.sender;\n\n        /* Get the allowance, infinite for the account owner */\n        uint256 startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = type(uint256).max;\n        } else {\n            startingAllowance = _allowances[src][spender];\n        }\n        require(startingAllowance >= amount, Error.INSUFFICIENT_BALANCE);\n\n        uint256 srcTokens = balances[src];\n        require(srcTokens >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(src);\n            ILpGauge(lpGauge).userCheckpoint(dst);\n        }\n        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);\n        pool.handleLpTokenTransfer(src, dst, amount);\n\n        uint256 allowanceNew = startingAllowance - amount;\n        uint256 srcTokensNew = srcTokens - amount;\n        uint256 dstTokensNew = balances[dst] + amount;\n\n        /* Update token balances */\n        balances[src] = srcTokensNew;\n        balances[dst] = dstTokensNew;\n\n        /* Update allowance if necessary */\n        if (startingAllowance != type(uint256).max) {\n            _allowances[src][spender] = allowanceNew;\n        }\n        emit Transfer(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve staked tokens for spender.\n     * @param spender Address to approve tokens for.\n     * @param amount Amount to approve.\n     * @return `true` if success.\n     */\n    function approve(address spender, uint256 amount) external override notPaused returns (bool) {\n        address src = msg.sender;\n        _allowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice If an action is registered and stakes funds, this updates the actionLockedBalances for the user.\n     * @param account Address that registered the action.\n     * @param amount Amount staked by the action.\n     * @return `true` if success.\n     */\n    function increaseActionLockedBalance(address account, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        require(controller.addressProvider().isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n        actionLockedBalances[account] += amount;\n        return true;\n    }\n\n    /**\n     * @notice If an action is executed/reset, this updates the actionLockedBalances for the user.\n     * @param account Address that registered the action.\n     * @param amount Amount executed/reset by the action.\n     * @return `true` if success.\n     */\n    function decreaseActionLockedBalance(address account, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        require(controller.addressProvider().isAction(msg.sender), Error.UNAUTHORIZED_ACCESS);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n        if (actionLockedBalances[account] > amount) {\n            actionLockedBalances[account] -= amount;\n        } else {\n            actionLockedBalances[account] = 0;\n        }\n        return true;\n    }\n\n    function poolCheckpoint() external override returns (bool) {\n        if (currentAddresses[_LP_GAUGE] != address(0)) {\n            return ILpGauge(currentAddresses[_LP_GAUGE]).poolCheckpoint();\n        }\n        return false;\n    }\n\n    function getLpGauge() external view override returns (address) {\n        return currentAddresses[_LP_GAUGE];\n    }\n\n    function isStrategy(address user) external view override returns (bool) {\n        return strategies[user];\n    }\n\n    /**\n     * @notice Get the total amount of tokens that are staked by actions\n     * @return Total amount staked by actions\n     */\n    function getStakedByActions() external view override returns (uint256) {\n        address[] memory actions = controller.addressProvider().allActions();\n        uint256 total;\n        for (uint256 i = 0; i < actions.length; i++) {\n            total += balances[actions[i]];\n        }\n        return total;\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function balanceOf(address account) external view override returns (uint256) {\n        return balances[account];\n    }\n\n    function getPoolTotalStaked() external view override returns (uint256) {\n        return _poolTotalStaked;\n    }\n\n    /**\n     * @notice Returns the total balance in the staker vault, including that locked in positions.\n     * @param account Account to query balance for.\n     * @return Total balance in staker vault for account.\n     */\n    function stakedAndActionLockedBalanceOf(address account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return balances[account] + actionLockedBalances[account];\n    }\n\n    function actionLockedBalanceOf(address account) external view override returns (uint256) {\n        return actionLockedBalances[account];\n    }\n\n    function decimals() external view returns (uint8) {\n        return IERC20Full(token).decimals();\n    }\n\n    function getToken() external view override returns (address) {\n        return token;\n    }\n\n    function unstake(uint256 amount) public override returns (bool) {\n        return unstakeFor(msg.sender, msg.sender, amount);\n    }\n\n    /**\n     * @notice Stake an amount of vault tokens.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stake(uint256 amount) public override returns (bool) {\n        return stakeFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Stake amount of vault token on behalf of another account.\n     * @param account Account for which tokens will be staked.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stakeFor(address account, uint256 amount) public override notPaused returns (bool) {\n        require(IERC20(token).balanceOf(msg.sender) >= amount, Error.INSUFFICIENT_BALANCE);\n\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(account);\n        }\n\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (msg.sender != account) {\n            ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);\n            pool.handleLpTokenTransfer(msg.sender, account, amount);\n        }\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 staked = IERC20(token).balanceOf(address(this)) - oldBal;\n        require(staked == amount, Error.INVALID_AMOUNT);\n        balances[account] += staked;\n\n        if (strategies[account]) {\n            strategiesTotalStaked += staked;\n        } else {\n            _poolTotalStaked += staked;\n        }\n        emit Staked(account, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake tokens on behalf of another account.\n     * @dev Needs to be approved.\n     * @param src Account for which tokens will be unstaked.\n     * @param dst Account receiving the tokens.\n     * @param amount Amount of token to unstake/receive.\n     * @return `true` if success.\n     */\n    function unstakeFor(\n        address src,\n        address dst,\n        uint256 amount\n    ) public override returns (bool) {\n        ILiquidityPool pool = controller.addressProvider().getPoolForToken(token);\n        uint256 allowance_ = _allowances[src][msg.sender];\n        require(\n            src == msg.sender || allowance_ >= amount || address(pool) == msg.sender,\n            Error.UNAUTHORIZED_ACCESS\n        );\n        require(balances[src] >= amount, Error.INSUFFICIENT_BALANCE);\n        address lpGauge = currentAddresses[_LP_GAUGE];\n        if (lpGauge != address(0)) {\n            ILpGauge(lpGauge).userCheckpoint(src);\n        }\n        uint256 oldBal = IERC20(token).balanceOf(address(this));\n\n        if (src != dst) {\n            pool.handleLpTokenTransfer(src, dst, amount);\n        }\n\n        IERC20(token).safeTransfer(dst, amount);\n\n        uint256 unstaked = oldBal - IERC20(token).balanceOf(address(this));\n\n        if (src != msg.sender && allowance_ != type(uint256).max && address(pool) != msg.sender) {\n            // update allowance\n            _allowances[src][msg.sender] -= unstaked;\n        }\n        balances[src] -= unstaked;\n\n        if (strategies[src]) {\n            strategiesTotalStaked -= unstaked;\n        } else {\n            _poolTotalStaked -= unstaked;\n        }\n        emit Unstaked(src, amount);\n        return true;\n    }\n\n    function _isAuthorizedToPause(address account) internal view override returns (bool) {\n        return _roleManager().hasRole(Roles.GOVERNANCE, account);\n    }\n}\n\n\n",
        "CodeNames": [
            "StakerVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "StakerVault.sol",
                "Type": "Rewards stealing",
                "Description": "Users can steal all rewards due to checkpoint after transfer in StakerVault.sol, which can lead to a high impact.",
                "Repair": "Move the call to ILpGauge(lpGauge).userCheckpoint() to before the balances are updated in StakerVault.transfer()."
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TopUpActionLibrary.lockFunds()",
                "Type": "Incorrect stake transfer and locking",
                "Description": "Function lockFunds transfers user stakes but doesn't call stakerVault.increaseActionLockedBalance() for the payer, causing stakerVault.actionLockedBalances[payer] to get different values and stakerVault.stakedAndActionLockedBalanceOf(payer) to show the wrong value. This can cause fund loss and theft and bypass of some restrictions.",
                "Repair": "Add stakerVault.increaseActionLockedBalance() after stakerVault.transferFrom()"
            },
            {
                "Location": "CompoundHandler#topUp()",
                "Type": "Using the wrong function selector",
                "Description": "Native token topUp() always reverts.",
                "Repair": "Use the correct function selector for the respective cToken"
            },
            {
                "Location": "CEthInterface#mint()",
                "Type": "Reading non-existing returns",
                "Description": "TopUp() with native token always reverts.",
                "Repair": "Use the correct interface for the respective cToken"
            },
            {
                "Location": "CEthInterface#repayBorrowBehalf()",
                "Type": "reading non-existing returns",
                "Description": "CEthInterface#repayBorrowBehalf() reading non-existing returns makes _repayAnyDebt() with CEther always revert",
                "Repair": "Update the CEthInterface interface to match the return value of repayBorrowBehalf() for native cToken (CEther)"
            },
            {
                "Location": "_updateUserFeesOnDeposit()",
                "Type": "extending period of higher withdrawal fees",
                "Description": "Griefer can extend period of higher withdrawal fees",
                "Repair": "Scale the lastActionTimestamp variable the same way the feeRatio is scaled"
            },
            {
                "Location": "latestRoundData()",
                "Type": "returning stale or incorrect results",
                "Description": "Chainlink's latestRoundData might return stale or incorrect results",
                "Repair": "Check if the return value indicates stale data"
            },
            {
                "Location": "_decimalMultiplier",
                "Type": "not accounting for tokens with decimals higher than 18",
                "Description": "_decimalMultiplier doesn't account for tokens with decimals higher than 18",
                "Repair": "Modify how _decimalMultiplier works so it could handle tokens with higher than 18 decimals"
            },
            {
                "Location": "getNewCurrentFees()",
                "Type": "reverting when minFeePercentage > feeRatio",
                "Description": "getNewCurrentFees reverts when minFeePercentage > feeRatio",
                "Repair": "Add a new condition in getNewCurrentFees to account for this case"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../interfaces/ILpToken.sol\";\nimport \"../../interfaces/IStakerVault.sol\";\nimport \"../../interfaces/IVault.sol\";\n\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/ScaledMath.sol\";\n\nimport \"../access/Authorization.sol\";\nimport \"../utils/Preparable.sol\";\nimport \"../utils/Pausable.sol\";\n\n/**\n * @dev Pausing/unpausing the pool will disable/re-enable deposits.\n */\nabstract contract LiquidityPool is\n    ILiquidityPool,\n    Authorization,\n    Preparable,\n    Pausable,\n    Initializable\n{\n    using AddressProviderHelpers for IAddressProvider;\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct WithdrawalFeeMeta {\n        uint64 timeToWait;\n        uint64 feeRatio;\n        uint64 lastActionTimestamp;\n    }\n\n    bytes32 internal constant _VAULT_KEY = \"Vault\";\n    bytes32 internal constant _RESERVE_DEVIATION_KEY = \"ReserveDeviation\";\n    bytes32 internal constant _REQUIRED_RESERVES_KEY = \"RequiredReserves\";\n\n    bytes32 internal constant _MAX_WITHDRAWAL_FEE_KEY = \"MaxWithdrawalFee\";\n    bytes32 internal constant _MIN_WITHDRAWAL_FEE_KEY = \"MinWithdrawalFee\";\n    bytes32 internal constant _WITHDRAWAL_FEE_DECREASE_PERIOD_KEY = \"WithdrawalFeeDecreasePeriod\";\n\n    uint256 internal constant _INITIAL_RESERVE_DEVIATION = 0.005e18; // 0.5%\n    uint256 internal constant _INITIAL_FEE_DECREASE_PERIOD = 1 weeks;\n    uint256 internal constant _INITIAL_MAX_WITHDRAWAL_FEE = 0.03e18; // 3%\n\n    /**\n     * @notice even through admin votes and later governance, the withdrawal\n     * fee will never be able to go above this value\n     */\n    uint256 internal constant _MAX_WITHDRAWAL_FEE = 0.05e18;\n\n    /**\n     * @notice Keeps track of the withdrawal fees on a per-address basis\n     */\n    mapping(address => WithdrawalFeeMeta) public withdrawalFeeMetas;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    uint256 public depositCap;\n    IStakerVault public staker;\n    ILpToken public lpToken;\n    string public name;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        controller = IController(_controller);\n        addressProvider = IController(_controller).addressProvider();\n    }\n\n    /**\n     * @notice Deposit funds into liquidity pool and mint LP tokens in exchange.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @return The actual amount minted.\n     */\n    function deposit(uint256 depositAmount) external payable override returns (uint256) {\n        return depositFor(msg.sender, depositAmount, 0);\n    }\n\n    /**\n     * @notice Deposit funds into liquidity pool and mint LP tokens in exchange.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @param minTokenAmount Minimum amount of LP tokens that should be minted.\n     * @return The actual amount minted.\n     */\n    function deposit(uint256 depositAmount, uint256 minTokenAmount)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        return depositFor(msg.sender, depositAmount, minTokenAmount);\n    }\n\n    /**\n     * @notice Deposit funds into liquidity pool and stake LP Tokens in Staker Vault.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @param minTokenAmount Minimum amount of LP tokens that should be minted.\n     * @return The actual amount minted and staked.\n     */\n    function depositAndStake(uint256 depositAmount, uint256 minTokenAmount)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        uint256 amountMinted_ = depositFor(address(this), depositAmount, minTokenAmount);\n        staker.stakeFor(msg.sender, amountMinted_);\n        return amountMinted_;\n    }\n\n    /**\n     * @notice Withdraws all funds from vault.\n     * @dev Should be called in case of emergencies.\n     */\n    function withdrawAll() external override onlyGovernance {\n        getVault().withdrawAll();\n    }\n\n    function setLpToken(address _lpToken)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)\n        returns (bool)\n    {\n        require(address(lpToken) == address(0), Error.ADDRESS_ALREADY_SET);\n        require(ILpToken(_lpToken).minter() == address(this), Error.INVALID_MINTER);\n        lpToken = ILpToken(_lpToken);\n        _approveStakerVaultSpendingLpTokens();\n        emit LpTokenSet(_lpToken);\n        return true;\n    }\n\n    /**\n     * @notice Checkpoint function to update a user's withdrawal fees on deposit and redeem\n     * @param from Address sending from\n     * @param to Address sending to\n     * @param amount Amount to redeem or deposit\n     */\n    function handleLpTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) external override {\n        require(\n            msg.sender == address(lpToken) || msg.sender == address(staker),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        if (\n            addressProvider.isStakerVault(to, address(lpToken)) ||\n            addressProvider.isStakerVault(from, address(lpToken)) ||\n            addressProvider.isAction(to) ||\n            addressProvider.isAction(from)\n        ) {\n            return;\n        }\n\n        if (to != address(0)) {\n            _updateUserFeesOnDeposit(to, from, amount);\n        }\n    }\n\n    /**\n     * @notice Prepare update of required reserve ratio (with time delay enforced).\n     * @param _newRatio New required reserve ratio.\n     * @return `true` if success.\n     */\n    function prepareNewRequiredReserves(uint256 _newRatio) external onlyGovernance returns (bool) {\n        require(_newRatio <= ScaledMath.ONE, Error.INVALID_AMOUNT);\n        return _prepare(_REQUIRED_RESERVES_KEY, _newRatio);\n    }\n\n    /**\n     * @notice Execute required reserve ratio update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New required reserve ratio.\n     */\n    function executeNewRequiredReserves() external override returns (uint256) {\n        uint256 requiredReserveRatio = _executeUInt256(_REQUIRED_RESERVES_KEY);\n        _rebalanceVault();\n        return requiredReserveRatio;\n    }\n\n    /**\n     * @notice Reset the prepared required reserves.\n     * @return `true` if success.\n     */\n    function resetRequiredReserves() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_REQUIRED_RESERVES_KEY);\n    }\n\n    /**\n     * @notice Prepare update of reserve deviation ratio (with time delay enforced).\n     * @param newRatio New reserve deviation ratio.\n     * @return `true` if success.\n     */\n    function prepareNewReserveDeviation(uint256 newRatio) external onlyGovernance returns (bool) {\n        require(newRatio <= (ScaledMath.DECIMAL_SCALE * 50) / 100, Error.INVALID_AMOUNT);\n        return _prepare(_RESERVE_DEVIATION_KEY, newRatio);\n    }\n\n    /**\n     * @notice Execute reserve deviation ratio update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New reserve deviation ratio.\n     */\n    function executeNewReserveDeviation() external override returns (uint256) {\n        uint256 reserveDeviation = _executeUInt256(_RESERVE_DEVIATION_KEY);\n        _rebalanceVault();\n        return reserveDeviation;\n    }\n\n    /**\n     * @notice Reset the prepared reserve deviation.\n     * @return `true` if success.\n     */\n    function resetNewReserveDeviation() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_RESERVE_DEVIATION_KEY);\n    }\n\n    /**\n     * @notice Prepare update of min withdrawal fee (with time delay enforced).\n     * @param newFee New min withdrawal fee.\n     * @return `true` if success.\n     */\n    function prepareNewMinWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {\n        _checkFeeInvariants(newFee, getMaxWithdrawalFee());\n        return _prepare(_MIN_WITHDRAWAL_FEE_KEY, newFee);\n    }\n\n    /**\n     * @notice Execute min withdrawal fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New withdrawal fee.\n     */\n    function executeNewMinWithdrawalFee() external returns (uint256) {\n        uint256 newFee = _executeUInt256(_MIN_WITHDRAWAL_FEE_KEY);\n        _checkFeeInvariants(newFee, getMaxWithdrawalFee());\n        return newFee;\n    }\n\n    /**\n     * @notice Reset the prepared min withdrawal fee\n     * @return `true` if success.\n     */\n    function resetNewMinWithdrawalFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MIN_WITHDRAWAL_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of max withdrawal fee (with time delay enforced).\n     * @param newFee New max withdrawal fee.\n     * @return `true` if success.\n     */\n    function prepareNewMaxWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {\n        _checkFeeInvariants(getMinWithdrawalFee(), newFee);\n        return _prepare(_MAX_WITHDRAWAL_FEE_KEY, newFee);\n    }\n\n    /**\n     * @notice Execute max withdrawal fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New max withdrawal fee.\n     */\n    function executeNewMaxWithdrawalFee() external override returns (uint256) {\n        uint256 newFee = _executeUInt256(_MAX_WITHDRAWAL_FEE_KEY);\n        _checkFeeInvariants(getMinWithdrawalFee(), newFee);\n        return newFee;\n    }\n\n    /**\n     * @notice Reset the prepared max fee.\n     * @return `true` if success.\n     */\n    function resetNewMaxWithdrawalFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_WITHDRAWAL_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of withdrawal decrease fee period (with time delay enforced).\n     * @param newPeriod New withdrawal fee decrease period.\n     * @return `true` if success.\n     */\n    function prepareNewWithdrawalFeeDecreasePeriod(uint256 newPeriod)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, newPeriod);\n    }\n\n    /**\n     * @notice Execute withdrawal fee decrease period update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New withdrawal fee decrease period.\n     */\n    function executeNewWithdrawalFeeDecreasePeriod() external returns (uint256) {\n        return _executeUInt256(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY);\n    }\n\n    /**\n     * @notice Reset the prepared withdrawal fee decrease period update.\n     * @return `true` if success.\n     */\n    function resetNewWithdrawalFeeDecreasePeriod() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY);\n    }\n\n    /**\n     * @notice Set the staker vault for this pool's LP token\n     * @dev Staker vault and LP token pairs are immutable and the staker vault can only be set once for a pool.\n     *      Only one vault exists per LP token. This information will be retrieved from the controller of the pool.\n     * @return Address of the new staker vault for the pool.\n     */\n    function setStaker()\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)\n        returns (bool)\n    {\n        require(address(staker) == address(0), Error.ADDRESS_ALREADY_SET);\n        address stakerVault = addressProvider.getStakerVault(address(lpToken));\n        require(stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        staker = IStakerVault(stakerVault);\n        _approveStakerVaultSpendingLpTokens();\n        emit StakerVaultSet(stakerVault);\n        return true;\n    }\n\n    /**\n     * @notice Prepare setting a new Vault (with time delay enforced).\n     * @param _vault Address of new Vault contract.\n     * @return `true` if success.\n     */\n    function prepareNewVault(address _vault) external override onlyGovernance returns (bool) {\n        _prepare(_VAULT_KEY, _vault);\n        return true;\n    }\n\n    /**\n     * @notice Execute Vault update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return Address of new Vault contract.\n     */\n    function executeNewVault() external override returns (address) {\n        IVault vault = getVault();\n        if (address(vault) != address(0)) {\n            vault.withdrawAll();\n        }\n        address newVault = _executeAddress(_VAULT_KEY);\n        addressProvider.updateVault(address(vault), newVault);\n        return newVault;\n    }\n\n    /**\n     * @notice Reset the vault deadline.\n     * @return `true` if success.\n     */\n    function resetNewVault() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_VAULT_KEY);\n    }\n\n    /**\n     * @notice Redeems the underlying asset by burning LP tokens.\n     * @param redeemLpTokens Number of tokens to burn for redeeming the underlying.\n     * @return Actual amount of the underlying redeemed.\n     */\n    function redeem(uint256 redeemLpTokens) external override returns (uint256) {\n        return redeem(redeemLpTokens, 0);\n    }\n\n    /**\n     * @notice Uncap the pool to remove the deposit limit.\n     * @return `true` if success.\n     */\n    function uncap() external override onlyGovernance returns (bool) {\n        require(isCapped(), Error.NOT_CAPPED);\n\n        depositCap = 0;\n        return true;\n    }\n\n    /**\n     * @notice Update the deposit cap value.\n     * @param _depositCap The maximum allowed deposits per address in the pool\n     * @return `true` if success.\n     */\n    function updateDepositCap(uint256 _depositCap) external override onlyGovernance returns (bool) {\n        require(isCapped(), Error.NOT_CAPPED);\n        require(depositCap != _depositCap, Error.SAME_AS_CURRENT);\n        require(_depositCap > 0, Error.INVALID_AMOUNT);\n\n        depositCap = _depositCap;\n        return true;\n    }\n\n    /**\n     * @notice Rebalance vault according to required underlying backing reserves.\n     */\n    function rebalanceVault() external onlyGovernance {\n        _rebalanceVault();\n    }\n\n    /**\n     * @notice Deposit funds for an address into liquidity pool and mint LP tokens in exchange.\n     * @param account Account to deposit for.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @return Actual amount minted.\n     */\n    function depositFor(address account, uint256 depositAmount)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        return depositFor(account, depositAmount, 0);\n    }\n\n    /**\n     * @notice Redeems the underlying asset by burning LP tokens, unstaking any LP tokens needed.\n     * @param redeemLpTokens Number of tokens to unstake and/or burn for redeeming the underlying.\n     * @param minRedeemAmount Minimum amount of underlying that should be received.\n     * @return Actual amount of the underlying redeemed.\n     */\n    function unstakeAndRedeem(uint256 redeemLpTokens, uint256 minRedeemAmount)\n        external\n        override\n        returns (uint256)\n    {\n        uint256 lpBalance_ = lpToken.balanceOf(msg.sender);\n        require(\n            lpBalance_ + staker.balanceOf(msg.sender) >= redeemLpTokens,\n            Error.INSUFFICIENT_BALANCE\n        );\n        if (lpBalance_ < redeemLpTokens) {\n            staker.unstakeFor(msg.sender, msg.sender, redeemLpTokens - lpBalance_);\n        }\n        return redeem(redeemLpTokens, minRedeemAmount);\n    }\n\n    /**\n     * @notice Returns the address of the LP token of this pool\n     * @return The address of the LP token\n     */\n    function getLpToken() external view override returns (address) {\n        return address(lpToken);\n    }\n\n    /**\n     * @notice Calculates the amount of LP tokens that need to be redeemed to get a certain amount of underlying (includes fees and exchange rate)\n     * @param account Address of the account redeeming.\n     * @param underlyingAmount The amount of underlying desired.\n     * @return Amount of LP tokens that need to be redeemed.\n     */\n    function calcRedeem(address account, uint256 underlyingAmount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(underlyingAmount > 0, Error.INVALID_AMOUNT);\n        ILpToken lpToken_ = lpToken;\n        require(lpToken_.balanceOf(account) > 0, Error.INSUFFICIENT_BALANCE);\n\n        uint256 currentExchangeRate = exchangeRate();\n        uint256 withoutFeesLpAmount = underlyingAmount.scaledDiv(currentExchangeRate);\n        if (withoutFeesLpAmount == lpToken_.totalSupply()) {\n            return withoutFeesLpAmount;\n        }\n\n        WithdrawalFeeMeta memory meta = withdrawalFeeMetas[account];\n\n        uint256 currentFeeRatio = 0;\n        if (!addressProvider.isAction(account)) {\n            currentFeeRatio = getNewCurrentFees(\n                meta.timeToWait,\n                meta.lastActionTimestamp,\n                meta.feeRatio\n            );\n        }\n        uint256 scalingFactor = currentExchangeRate.scaledMul((ScaledMath.ONE - currentFeeRatio));\n        uint256 neededLpTokens = underlyingAmount.scaledDivRoundUp(scalingFactor);\n\n        return neededLpTokens;\n    }\n\n    function getUnderlying() external view virtual override returns (address);\n\n    /**\n     * @notice Deposit funds for an address into liquidity pool and mint LP tokens in exchange.\n     * @param account Account to deposit for.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @param minTokenAmount Minimum amount of LP tokens that should be minted.\n     * @return Actual amount minted.\n     */\n    function depositFor(\n        address account,\n        uint256 depositAmount,\n        uint256 minTokenAmount\n    ) public payable override notPaused returns (uint256) {\n        uint256 rate = exchangeRate();\n\n        if (isCapped()) {\n            uint256 lpBalance = lpToken.balanceOf(account);\n            uint256 stakedAndLockedBalance = staker.stakedAndActionLockedBalanceOf(account);\n            uint256 currentUnderlyingBalance = (lpBalance + stakedAndLockedBalance).scaledMul(rate);\n            require(\n                currentUnderlyingBalance + depositAmount <= depositCap,\n                Error.EXCEEDS_DEPOSIT_CAP\n            );\n        }\n\n        _doTransferIn(msg.sender, depositAmount);\n        uint256 mintedLp = depositAmount.scaledDiv(rate);\n        require(mintedLp >= minTokenAmount, Error.INVALID_AMOUNT);\n\n        lpToken.mint(account, mintedLp);\n        _rebalanceVault();\n\n        if (msg.sender == account || address(this) == account) {\n            emit Deposit(msg.sender, depositAmount, mintedLp);\n        } else {\n            emit DepositFor(msg.sender, account, depositAmount, mintedLp);\n        }\n        return mintedLp;\n    }\n\n    /**\n     * @notice Redeems the underlying asset by burning LP tokens.\n     * @param redeemLpTokens Number of tokens to burn for redeeming the underlying.\n     * @param minRedeemAmount Minimum amount of underlying that should be received.\n     * @return Actual amount of the underlying redeemed.\n     */\n    function redeem(uint256 redeemLpTokens, uint256 minRedeemAmount)\n        public\n        override\n        returns (uint256)\n    {\n        require(redeemLpTokens > 0, Error.INVALID_AMOUNT);\n        ILpToken lpToken_ = lpToken;\n        require(lpToken_.balanceOf(msg.sender) >= redeemLpTokens, Error.INSUFFICIENT_BALANCE);\n\n        uint256 withdrawalFee = addressProvider.isAction(msg.sender)\n            ? 0\n            : getWithdrawalFee(msg.sender, redeemLpTokens);\n        uint256 redeemMinusFees = redeemLpTokens - withdrawalFee;\n        // Pay no fees on the last withdrawal (avoid locking funds in the pool)\n        if (redeemLpTokens == lpToken_.totalSupply()) {\n            redeemMinusFees = redeemLpTokens;\n        }\n        uint256 redeemUnderlying = redeemMinusFees.scaledMul(exchangeRate());\n        require(redeemUnderlying >= minRedeemAmount, Error.NOT_ENOUGH_FUNDS_WITHDRAWN);\n\n        _rebalanceVault(redeemUnderlying);\n\n        lpToken_.burn(msg.sender, redeemLpTokens);\n        _doTransferOut(payable(msg.sender), redeemUnderlying);\n        emit Redeem(msg.sender, redeemUnderlying, redeemLpTokens);\n        return redeemUnderlying;\n    }\n\n    /**\n     * @return the current required reserves ratio\n     */\n    function getRequiredReserveRatio() public view virtual returns (uint256) {\n        return currentUInts256[_REQUIRED_RESERVES_KEY];\n    }\n\n    /**\n     * @return the current maximum reserve deviation ratio\n     */\n    function getMaxReserveDeviationRatio() public view virtual returns (uint256) {\n        return currentUInts256[_RESERVE_DEVIATION_KEY];\n    }\n\n    /**\n     * @notice Returns the current minimum withdrawal fee\n     */\n    function getMinWithdrawalFee() public view returns (uint256) {\n        return currentUInts256[_MIN_WITHDRAWAL_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current maximum withdrawal fee\n     */\n    function getMaxWithdrawalFee() public view returns (uint256) {\n        return currentUInts256[_MAX_WITHDRAWAL_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current withdrawal fee decrease period\n     */\n    function getWithdrawalFeeDecreasePeriod() public view returns (uint256) {\n        return currentUInts256[_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY];\n    }\n\n    /**\n     * @return the current vault of the liquidity pool\n     */\n    function getVault() public view virtual override returns (IVault) {\n        return IVault(currentAddresses[_VAULT_KEY]);\n    }\n\n    /**\n     * @notice Compute current exchange rate of LP tokens to underlying scaled to 1e18.\n     * @dev Exchange rate means: underlying = LP token * exchangeRate\n     * @return Current exchange rate.\n     */\n    function exchangeRate() public view override returns (uint256) {\n        uint256 totalUnderlying_ = totalUnderlying();\n        uint256 totalSupply = lpToken.totalSupply();\n        if (totalSupply == 0 || totalUnderlying_ == 0) {\n            return ScaledMath.ONE;\n        }\n\n        return totalUnderlying_.scaledDiv(totalSupply);\n    }\n\n    /**\n     * @notice Compute total amount of underlying tokens for this pool.\n     * @return Total amount of underlying in pool.\n     */\n    function totalUnderlying() public view override returns (uint256) {\n        IVault vault = getVault();\n        uint256 balanceUnderlying = _getBalanceUnderlying();\n        if (address(vault) == address(0)) {\n            return balanceUnderlying;\n        }\n        uint256 investedUnderlying = vault.getTotalUnderlying();\n        return investedUnderlying + balanceUnderlying;\n    }\n\n    /**\n     * @notice Retuns if the pool has an active deposit limit\n     * @return `true` if there is currently a deposit limit\n     */\n    function isCapped() public view override returns (bool) {\n        return depositCap != 0;\n    }\n\n    /**\n     * @notice Returns the withdrawal fee for `account`\n     * @param account Address to get the withdrawal fee for\n     * @param amount Amount to calculate the withdrawal fee for\n     * @return Withdrawal fee in LP tokens\n     */\n    function getWithdrawalFee(address account, uint256 amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        WithdrawalFeeMeta memory meta = withdrawalFeeMetas[account];\n\n        if (lpToken.balanceOf(account) == 0) {\n            return 0;\n        }\n        uint256 currentFee = getNewCurrentFees(\n            meta.timeToWait,\n            meta.lastActionTimestamp,\n            meta.feeRatio\n        );\n        return amount.scaledMul(currentFee);\n    }\n\n    /**\n     * @notice Calculates the withdrawal fee a user would currently need to pay on currentBalance.\n     * @param timeToWait The total time to wait until the withdrawal fee reached the min. fee\n     * @param lastActionTimestamp Timestamp of the last fee update\n     * @param feeRatio Fees that would currently be paid on the user's entire balance\n     * @return Updated fee amount on the currentBalance\n     */\n    function getNewCurrentFees(\n        uint256 timeToWait,\n        uint256 lastActionTimestamp,\n        uint256 feeRatio\n    ) public view returns (uint256) {\n        uint256 timeElapsed = _getTime() - lastActionTimestamp;\n        uint256 minFeePercentage = getMinWithdrawalFee();\n        if (timeElapsed >= timeToWait) {\n            return minFeePercentage;\n        }\n        uint256 elapsedShare = timeElapsed.scaledDiv(timeToWait);\n        return feeRatio - (feeRatio - minFeePercentage).scaledMul(elapsedShare);\n    }\n\n    function _rebalanceVault() internal {\n        _rebalanceVault(0);\n    }\n\n    function _initialize(\n        string memory name_,\n        uint256 depositCap_,\n        address vault_\n    ) internal initializer returns (bool) {\n        name = name_;\n        depositCap = depositCap_;\n\n        _setConfig(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, _INITIAL_FEE_DECREASE_PERIOD);\n        _setConfig(_MAX_WITHDRAWAL_FEE_KEY, _INITIAL_MAX_WITHDRAWAL_FEE);\n        _setConfig(_REQUIRED_RESERVES_KEY, ScaledMath.ONE);\n        _setConfig(_RESERVE_DEVIATION_KEY, _INITIAL_RESERVE_DEVIATION);\n        _setConfig(_VAULT_KEY, vault_);\n        return true;\n    }\n\n    function _approveStakerVaultSpendingLpTokens() internal {\n        address staker_ = address(staker);\n        address lpToken_ = address(lpToken);\n        if (staker_ == address(0) || lpToken_ == address(0)) return;\n        IERC20(lpToken_).safeApprove(staker_, type(uint256).max);\n    }\n\n    function _doTransferIn(address from, uint256 amount) internal virtual;\n\n    function _doTransferOut(address payable to, uint256 amount) internal virtual;\n\n    /**\n     * @dev Rebalances the pool's allocations to the vault\n     * @param underlyingToWithdraw Amount of underlying to withdraw such that after the withdrawal the pool and vault allocations are correctly balanced.\n     */\n    function _rebalanceVault(uint256 underlyingToWithdraw) internal {\n        IVault vault = getVault();\n\n        if (address(vault) == address(0)) return;\n        uint256 lockedLp = staker.getStakedByActions();\n        uint256 totalUnderlyingStaked = lockedLp.scaledMul(exchangeRate());\n\n        uint256 underlyingBalance = _getBalanceUnderlying(true);\n        uint256 maximumDeviation = totalUnderlyingStaked.scaledMul(getMaxReserveDeviationRatio());\n\n        uint256 nextTargetBalance = totalUnderlyingStaked.scaledMul(getRequiredReserveRatio());\n\n        if (\n            underlyingToWithdraw > underlyingBalance ||\n            (underlyingBalance - underlyingToWithdraw) + maximumDeviation < nextTargetBalance\n        ) {\n            uint256 requiredDeposits = nextTargetBalance + underlyingToWithdraw - underlyingBalance;\n            vault.withdraw(requiredDeposits);\n        } else {\n            uint256 nextBalance = underlyingBalance - underlyingToWithdraw;\n            if (nextBalance > nextTargetBalance + maximumDeviation) {\n                uint256 excessDeposits = nextBalance - nextTargetBalance;\n                _doTransferOut(payable(address(vault)), excessDeposits);\n                vault.deposit();\n            }\n        }\n    }\n\n    function _updateUserFeesOnDeposit(\n        address account,\n        address from,\n        uint256 amountAdded\n    ) internal {\n        WithdrawalFeeMeta storage meta = withdrawalFeeMetas[account];\n        uint256 balance = lpToken.balanceOf(account) +\n            staker.stakedAndActionLockedBalanceOf(account);\n        uint256 newCurrentFeeRatio = getNewCurrentFees(\n            meta.timeToWait,\n            meta.lastActionTimestamp,\n            meta.feeRatio\n        );\n        uint256 shareAdded = amountAdded.scaledDiv(amountAdded + balance);\n        uint256 shareExisting = ScaledMath.ONE - shareAdded;\n        uint256 feeOnDeposit;\n        if (from == address(0)) {\n            feeOnDeposit = getMaxWithdrawalFee();\n        } else {\n            WithdrawalFeeMeta storage fromMeta = withdrawalFeeMetas[from];\n            feeOnDeposit = getNewCurrentFees(\n                fromMeta.timeToWait,\n                fromMeta.lastActionTimestamp,\n                fromMeta.feeRatio\n            );\n        }\n\n        uint256 newFeeRatio = shareExisting.scaledMul(newCurrentFeeRatio) +\n            shareAdded.scaledMul(feeOnDeposit);\n\n        meta.feeRatio = uint64(newFeeRatio);\n        meta.timeToWait = uint64(getWithdrawalFeeDecreasePeriod());\n        meta.lastActionTimestamp = uint64(_getTime());\n    }\n\n    function _getBalanceUnderlying() internal view virtual returns (uint256);\n\n    function _getBalanceUnderlying(bool transferInDone) internal view virtual returns (uint256);\n\n    function _isAuthorizedToPause(address account) internal view override returns (bool) {\n        return _roleManager().hasRole(Roles.GOVERNANCE, account);\n    }\n\n    /**\n     * @dev Overriden for testing\n     */\n    function _getTime() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    function _checkFeeInvariants(uint256 minFee, uint256 maxFee) internal pure {\n        require(maxFee >= minFee, Error.INVALID_AMOUNT);\n        require(maxFee <= _MAX_WITHDRAWAL_FEE, Error.INVALID_AMOUNT);\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../../interfaces/IGasBank.sol\";\nimport \"../../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../../interfaces/ISwapperRegistry.sol\";\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IStakerVault.sol\";\nimport \"../../../interfaces/ISwapper.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpHandler.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpAction.sol\";\nimport \"../../../interfaces/actions/IActionFeeHandler.sol\";\n\nimport \"../../../libraries/AddressProviderHelpers.sol\";\nimport \"../../../libraries/Errors.sol\";\nimport \"../../../libraries/ScaledMath.sol\";\nimport \"../../../libraries/EnumerableExtensions.sol\";\n\nimport \"../../access/Authorization.sol\";\nimport \"../../utils/Preparable.sol\";\n\n/**\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount > 0) {\n            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft > 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance < allowance ? balance : allowance;\n            if (availableFunds >= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /**\n     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.\n     */\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /**\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being \"too deep\"\n     */\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = \"ActionFee\";\n    bytes32 internal constant _FEE_HANDLER_KEY = \"FeeHandler\";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = \"TopUpHandler\";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = \"EstimatedGasUsage\";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = \"MaxSwapperSlippage\";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -> account -> protocol -> Record)\n    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;\n\n    mapping(address => RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i < protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /**\n     * @notice Register a top up action.\n     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of `depositToken` that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     */\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);\n        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *\n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /**\n     * @notice See overloaded version of `execute` for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /**\n     * @notice Delete a position to back on the given protocol for `account`.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return `true` if successful.\n     */\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /**\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /**\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return `true` if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /**\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return `true` if success.\n     */\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /**\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return `true` if success.\n     */\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&\n                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /**\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /** Set fee handler */\n    /**\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return `true` if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /**\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Reset the handler deadline.\n     * @return `true` if success.\n     */\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return `true` if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /**\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return `true` if successful.\n     */\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Reset the gas usage deadline.\n     * @return `true` if success.\n     */\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /**\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i < length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /**\n     * @notice Returns a list of positions for the given payer\n     */\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /**\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     */\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32[](length);\n        for (uint256 i = 0; i < length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /*\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = _usersWithPositions.length();\n        if (cursor >= length) return (new address[](0), 0);\n        if (howMany >= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions_ = new address[](howMany);\n        for (uint256 i = 0; i < howMany; i++) {\n            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions_, cursor + howMany);\n    }\n\n    /**\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     */\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /**\n     * @notice Retrieves the topup handler for the given `protocol`\n     */\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /**\n     * @notice Successfully tops up a position if it's conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper's wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return `true` if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas <=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance < vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly `vars.actionTokenAmount`\n        // (at least `position.singleTopUpAmount`) of action token\n        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                \"topUp(bytes32,address,uint256,bytes)\",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new \"balance\" of the position\n        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance > 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return `true` if success.\n     */\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /**\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     */\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /**\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /**\n     * @notice Returns the current action fee\n     */\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current max swapper slippage\n     */\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /**\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /**\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     */\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /**\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     */\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /**\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who's position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getFeeHandler();\n        IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n        IActionFeeHandler(feeHandler).payFees(payer, beneficiary, feeAmount, depositToken);\n    }\n\n    /**\n     * @dev \"Locks\" an amount of tokens on behalf of the TopUpAction\n     * Funds are taken from staker vault if allowance is sufficient, else direct transfer or a combination of both.\n     * @param payer Owner of the funds to be locked\n     * @param token Token to lock\n     * @param lockAmount Minimum amount of `token` to lock\n     * @param depositAmount Amount of `token` that was deposited.\n     *                      If this is 0 then the staker vault allowance should be used.\n     *                      If this is greater than `requiredAmount` more tokens will be locked.\n     */\n    function _lockFunds(\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) internal {\n        address stakerVaultAddress = addressProvider.getStakerVault(token);\n        TopUpActionLibrary.lockFunds(stakerVaultAddress, payer, token, lockAmount, depositAmount);\n    }\n\n    function _removePosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        delete _positions[payer][account][protocol];\n        _removeUserPosition(payer, account, protocol);\n        if (_userPositions[payer].length == 0) {\n            _usersWithPositions.remove(payer);\n        }\n        emit Deregister(payer, account, protocol);\n    }\n\n    function _removeUserPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) internal {\n        RecordMeta[] storage positionsMeta = _userPositions[payer];\n        uint256 length = positionsMeta.length;\n        for (uint256 i = 0; i < length; i++) {\n            RecordMeta storage positionMeta = positionsMeta[i];\n            if (positionMeta.account == account && positionMeta.protocol == protocol) {\n                positionsMeta[i] = positionsMeta[length - 1];\n                positionsMeta.pop();\n                return;\n            }\n        }\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token The token to approve for.\n     * @param spender The spender to approve.\n     */\n    function _approve(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) > 0) return;\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /**\n     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.\n     */\n    function _calcExchangeAmount(\n        address token,\n        address actionToken,\n        uint256 amount\n    ) internal view returns (uint256) {\n        return TopUpActionLibrary.calcExchangeAmount(addressProvider, token, actionToken, amount);\n    }\n\n    function _getSwapper(address underlying, address actionToken) internal view returns (ISwapper) {\n        return TopUpActionLibrary.getSwapper(addressProvider, underlying, actionToken);\n    }\n\n    function _getHandler(bytes32 protocol, bool ensureExists) internal view returns (address) {\n        address handler = currentAddresses[_getProtocolKey(protocol)];\n        require(!ensureExists || handler != address(0), Error.PROTOCOL_NOT_FOUND);\n        return handler;\n    }\n\n    function _isSwappable(address depositToken, address toToken) internal view returns (bool) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(depositToken);\n        address underlying = pool.getUnderlying();\n        if (underlying == toToken) {\n            return true;\n        }\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        return ISwapperRegistry(swapperRegistry).swapperExists(underlying, toToken);\n    }\n\n    function _getProtocolKey(bytes32 protocol) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_TOP_UP_HANDLER_KEY, protocol));\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidityPool.sol",
            "TopUpAction.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "TopUpAction.sol#L50, LiquidityPool.sol#L721",
                "Type": "Lack of safeApprove",
                "Description": "Prevents some registrations, and the changing of stakers and LP tokens.",
                "Repair": "Always do safeApprove(0) if the allowance is being changed, or use safeIncreaseAllowance()"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../interfaces/ILpToken.sol\";\nimport \"../../interfaces/IStakerVault.sol\";\nimport \"../../interfaces/IVault.sol\";\n\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/ScaledMath.sol\";\n\nimport \"../access/Authorization.sol\";\nimport \"../utils/Preparable.sol\";\nimport \"../utils/Pausable.sol\";\n\n/**\n * @dev Pausing/unpausing the pool will disable/re-enable deposits.\n */\nabstract contract LiquidityPool is\n    ILiquidityPool,\n    Authorization,\n    Preparable,\n    Pausable,\n    Initializable\n{\n    using AddressProviderHelpers for IAddressProvider;\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct WithdrawalFeeMeta {\n        uint64 timeToWait;\n        uint64 feeRatio;\n        uint64 lastActionTimestamp;\n    }\n\n    bytes32 internal constant _VAULT_KEY = \"Vault\";\n    bytes32 internal constant _RESERVE_DEVIATION_KEY = \"ReserveDeviation\";\n    bytes32 internal constant _REQUIRED_RESERVES_KEY = \"RequiredReserves\";\n\n    bytes32 internal constant _MAX_WITHDRAWAL_FEE_KEY = \"MaxWithdrawalFee\";\n    bytes32 internal constant _MIN_WITHDRAWAL_FEE_KEY = \"MinWithdrawalFee\";\n    bytes32 internal constant _WITHDRAWAL_FEE_DECREASE_PERIOD_KEY = \"WithdrawalFeeDecreasePeriod\";\n\n    uint256 internal constant _INITIAL_RESERVE_DEVIATION = 0.005e18; // 0.5%\n    uint256 internal constant _INITIAL_FEE_DECREASE_PERIOD = 1 weeks;\n    uint256 internal constant _INITIAL_MAX_WITHDRAWAL_FEE = 0.03e18; // 3%\n\n    /**\n     * @notice even through admin votes and later governance, the withdrawal\n     * fee will never be able to go above this value\n     */\n    uint256 internal constant _MAX_WITHDRAWAL_FEE = 0.05e18;\n\n    /**\n     * @notice Keeps track of the withdrawal fees on a per-address basis\n     */\n    mapping(address => WithdrawalFeeMeta) public withdrawalFeeMetas;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    uint256 public depositCap;\n    IStakerVault public staker;\n    ILpToken public lpToken;\n    string public name;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        require(address(_controller) != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        controller = IController(_controller);\n        addressProvider = IController(_controller).addressProvider();\n    }\n\n    /**\n     * @notice Deposit funds into liquidity pool and mint LP tokens in exchange.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @return The actual amount minted.\n     */\n    function deposit(uint256 depositAmount) external payable override returns (uint256) {\n        return depositFor(msg.sender, depositAmount, 0);\n    }\n\n    /**\n     * @notice Deposit funds into liquidity pool and mint LP tokens in exchange.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @param minTokenAmount Minimum amount of LP tokens that should be minted.\n     * @return The actual amount minted.\n     */\n    function deposit(uint256 depositAmount, uint256 minTokenAmount)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        return depositFor(msg.sender, depositAmount, minTokenAmount);\n    }\n\n    /**\n     * @notice Deposit funds into liquidity pool and stake LP Tokens in Staker Vault.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @param minTokenAmount Minimum amount of LP tokens that should be minted.\n     * @return The actual amount minted and staked.\n     */\n    function depositAndStake(uint256 depositAmount, uint256 minTokenAmount)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        uint256 amountMinted_ = depositFor(address(this), depositAmount, minTokenAmount);\n        staker.stakeFor(msg.sender, amountMinted_);\n        return amountMinted_;\n    }\n\n    /**\n     * @notice Withdraws all funds from vault.\n     * @dev Should be called in case of emergencies.\n     */\n    function withdrawAll() external override onlyGovernance {\n        getVault().withdrawAll();\n    }\n\n    function setLpToken(address _lpToken)\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)\n        returns (bool)\n    {\n        require(address(lpToken) == address(0), Error.ADDRESS_ALREADY_SET);\n        require(ILpToken(_lpToken).minter() == address(this), Error.INVALID_MINTER);\n        lpToken = ILpToken(_lpToken);\n        _approveStakerVaultSpendingLpTokens();\n        emit LpTokenSet(_lpToken);\n        return true;\n    }\n\n    /**\n     * @notice Checkpoint function to update a user's withdrawal fees on deposit and redeem\n     * @param from Address sending from\n     * @param to Address sending to\n     * @param amount Amount to redeem or deposit\n     */\n    function handleLpTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) external override {\n        require(\n            msg.sender == address(lpToken) || msg.sender == address(staker),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        if (\n            addressProvider.isStakerVault(to, address(lpToken)) ||\n            addressProvider.isStakerVault(from, address(lpToken)) ||\n            addressProvider.isAction(to) ||\n            addressProvider.isAction(from)\n        ) {\n            return;\n        }\n\n        if (to != address(0)) {\n            _updateUserFeesOnDeposit(to, from, amount);\n        }\n    }\n\n    /**\n     * @notice Prepare update of required reserve ratio (with time delay enforced).\n     * @param _newRatio New required reserve ratio.\n     * @return `true` if success.\n     */\n    function prepareNewRequiredReserves(uint256 _newRatio) external onlyGovernance returns (bool) {\n        require(_newRatio <= ScaledMath.ONE, Error.INVALID_AMOUNT);\n        return _prepare(_REQUIRED_RESERVES_KEY, _newRatio);\n    }\n\n    /**\n     * @notice Execute required reserve ratio update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New required reserve ratio.\n     */\n    function executeNewRequiredReserves() external override returns (uint256) {\n        uint256 requiredReserveRatio = _executeUInt256(_REQUIRED_RESERVES_KEY);\n        _rebalanceVault();\n        return requiredReserveRatio;\n    }\n\n    /**\n     * @notice Reset the prepared required reserves.\n     * @return `true` if success.\n     */\n    function resetRequiredReserves() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_REQUIRED_RESERVES_KEY);\n    }\n\n    /**\n     * @notice Prepare update of reserve deviation ratio (with time delay enforced).\n     * @param newRatio New reserve deviation ratio.\n     * @return `true` if success.\n     */\n    function prepareNewReserveDeviation(uint256 newRatio) external onlyGovernance returns (bool) {\n        require(newRatio <= (ScaledMath.DECIMAL_SCALE * 50) / 100, Error.INVALID_AMOUNT);\n        return _prepare(_RESERVE_DEVIATION_KEY, newRatio);\n    }\n\n    /**\n     * @notice Execute reserve deviation ratio update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New reserve deviation ratio.\n     */\n    function executeNewReserveDeviation() external override returns (uint256) {\n        uint256 reserveDeviation = _executeUInt256(_RESERVE_DEVIATION_KEY);\n        _rebalanceVault();\n        return reserveDeviation;\n    }\n\n    /**\n     * @notice Reset the prepared reserve deviation.\n     * @return `true` if success.\n     */\n    function resetNewReserveDeviation() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_RESERVE_DEVIATION_KEY);\n    }\n\n    /**\n     * @notice Prepare update of min withdrawal fee (with time delay enforced).\n     * @param newFee New min withdrawal fee.\n     * @return `true` if success.\n     */\n    function prepareNewMinWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {\n        _checkFeeInvariants(newFee, getMaxWithdrawalFee());\n        return _prepare(_MIN_WITHDRAWAL_FEE_KEY, newFee);\n    }\n\n    /**\n     * @notice Execute min withdrawal fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New withdrawal fee.\n     */\n    function executeNewMinWithdrawalFee() external returns (uint256) {\n        uint256 newFee = _executeUInt256(_MIN_WITHDRAWAL_FEE_KEY);\n        _checkFeeInvariants(newFee, getMaxWithdrawalFee());\n        return newFee;\n    }\n\n    /**\n     * @notice Reset the prepared min withdrawal fee\n     * @return `true` if success.\n     */\n    function resetNewMinWithdrawalFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MIN_WITHDRAWAL_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of max withdrawal fee (with time delay enforced).\n     * @param newFee New max withdrawal fee.\n     * @return `true` if success.\n     */\n    function prepareNewMaxWithdrawalFee(uint256 newFee) external onlyGovernance returns (bool) {\n        _checkFeeInvariants(getMinWithdrawalFee(), newFee);\n        return _prepare(_MAX_WITHDRAWAL_FEE_KEY, newFee);\n    }\n\n    /**\n     * @notice Execute max withdrawal fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New max withdrawal fee.\n     */\n    function executeNewMaxWithdrawalFee() external override returns (uint256) {\n        uint256 newFee = _executeUInt256(_MAX_WITHDRAWAL_FEE_KEY);\n        _checkFeeInvariants(getMinWithdrawalFee(), newFee);\n        return newFee;\n    }\n\n    /**\n     * @notice Reset the prepared max fee.\n     * @return `true` if success.\n     */\n    function resetNewMaxWithdrawalFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_WITHDRAWAL_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare update of withdrawal decrease fee period (with time delay enforced).\n     * @param newPeriod New withdrawal fee decrease period.\n     * @return `true` if success.\n     */\n    function prepareNewWithdrawalFeeDecreasePeriod(uint256 newPeriod)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, newPeriod);\n    }\n\n    /**\n     * @notice Execute withdrawal fee decrease period update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return New withdrawal fee decrease period.\n     */\n    function executeNewWithdrawalFeeDecreasePeriod() external returns (uint256) {\n        return _executeUInt256(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY);\n    }\n\n    /**\n     * @notice Reset the prepared withdrawal fee decrease period update.\n     * @return `true` if success.\n     */\n    function resetNewWithdrawalFeeDecreasePeriod() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY);\n    }\n\n    /**\n     * @notice Set the staker vault for this pool's LP token\n     * @dev Staker vault and LP token pairs are immutable and the staker vault can only be set once for a pool.\n     *      Only one vault exists per LP token. This information will be retrieved from the controller of the pool.\n     * @return Address of the new staker vault for the pool.\n     */\n    function setStaker()\n        external\n        override\n        onlyRoles2(Roles.GOVERNANCE, Roles.POOL_FACTORY)\n        returns (bool)\n    {\n        require(address(staker) == address(0), Error.ADDRESS_ALREADY_SET);\n        address stakerVault = addressProvider.getStakerVault(address(lpToken));\n        require(stakerVault != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        staker = IStakerVault(stakerVault);\n        _approveStakerVaultSpendingLpTokens();\n        emit StakerVaultSet(stakerVault);\n        return true;\n    }\n\n    /**\n     * @notice Prepare setting a new Vault (with time delay enforced).\n     * @param _vault Address of new Vault contract.\n     * @return `true` if success.\n     */\n    function prepareNewVault(address _vault) external override onlyGovernance returns (bool) {\n        _prepare(_VAULT_KEY, _vault);\n        return true;\n    }\n\n    /**\n     * @notice Execute Vault update (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return Address of new Vault contract.\n     */\n    function executeNewVault() external override returns (address) {\n        IVault vault = getVault();\n        if (address(vault) != address(0)) {\n            vault.withdrawAll();\n        }\n        address newVault = _executeAddress(_VAULT_KEY);\n        addressProvider.updateVault(address(vault), newVault);\n        return newVault;\n    }\n\n    /**\n     * @notice Reset the vault deadline.\n     * @return `true` if success.\n     */\n    function resetNewVault() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_VAULT_KEY);\n    }\n\n    /**\n     * @notice Redeems the underlying asset by burning LP tokens.\n     * @param redeemLpTokens Number of tokens to burn for redeeming the underlying.\n     * @return Actual amount of the underlying redeemed.\n     */\n    function redeem(uint256 redeemLpTokens) external override returns (uint256) {\n        return redeem(redeemLpTokens, 0);\n    }\n\n    /**\n     * @notice Uncap the pool to remove the deposit limit.\n     * @return `true` if success.\n     */\n    function uncap() external override onlyGovernance returns (bool) {\n        require(isCapped(), Error.NOT_CAPPED);\n\n        depositCap = 0;\n        return true;\n    }\n\n    /**\n     * @notice Update the deposit cap value.\n     * @param _depositCap The maximum allowed deposits per address in the pool\n     * @return `true` if success.\n     */\n    function updateDepositCap(uint256 _depositCap) external override onlyGovernance returns (bool) {\n        require(isCapped(), Error.NOT_CAPPED);\n        require(depositCap != _depositCap, Error.SAME_AS_CURRENT);\n        require(_depositCap > 0, Error.INVALID_AMOUNT);\n\n        depositCap = _depositCap;\n        return true;\n    }\n\n    /**\n     * @notice Rebalance vault according to required underlying backing reserves.\n     */\n    function rebalanceVault() external onlyGovernance {\n        _rebalanceVault();\n    }\n\n    /**\n     * @notice Deposit funds for an address into liquidity pool and mint LP tokens in exchange.\n     * @param account Account to deposit for.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @return Actual amount minted.\n     */\n    function depositFor(address account, uint256 depositAmount)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        return depositFor(account, depositAmount, 0);\n    }\n\n    /**\n     * @notice Redeems the underlying asset by burning LP tokens, unstaking any LP tokens needed.\n     * @param redeemLpTokens Number of tokens to unstake and/or burn for redeeming the underlying.\n     * @param minRedeemAmount Minimum amount of underlying that should be received.\n     * @return Actual amount of the underlying redeemed.\n     */\n    function unstakeAndRedeem(uint256 redeemLpTokens, uint256 minRedeemAmount)\n        external\n        override\n        returns (uint256)\n    {\n        uint256 lpBalance_ = lpToken.balanceOf(msg.sender);\n        require(\n            lpBalance_ + staker.balanceOf(msg.sender) >= redeemLpTokens,\n            Error.INSUFFICIENT_BALANCE\n        );\n        if (lpBalance_ < redeemLpTokens) {\n            staker.unstakeFor(msg.sender, msg.sender, redeemLpTokens - lpBalance_);\n        }\n        return redeem(redeemLpTokens, minRedeemAmount);\n    }\n\n    /**\n     * @notice Returns the address of the LP token of this pool\n     * @return The address of the LP token\n     */\n    function getLpToken() external view override returns (address) {\n        return address(lpToken);\n    }\n\n    /**\n     * @notice Calculates the amount of LP tokens that need to be redeemed to get a certain amount of underlying (includes fees and exchange rate)\n     * @param account Address of the account redeeming.\n     * @param underlyingAmount The amount of underlying desired.\n     * @return Amount of LP tokens that need to be redeemed.\n     */\n    function calcRedeem(address account, uint256 underlyingAmount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(underlyingAmount > 0, Error.INVALID_AMOUNT);\n        ILpToken lpToken_ = lpToken;\n        require(lpToken_.balanceOf(account) > 0, Error.INSUFFICIENT_BALANCE);\n\n        uint256 currentExchangeRate = exchangeRate();\n        uint256 withoutFeesLpAmount = underlyingAmount.scaledDiv(currentExchangeRate);\n        if (withoutFeesLpAmount == lpToken_.totalSupply()) {\n            return withoutFeesLpAmount;\n        }\n\n        WithdrawalFeeMeta memory meta = withdrawalFeeMetas[account];\n\n        uint256 currentFeeRatio = 0;\n        if (!addressProvider.isAction(account)) {\n            currentFeeRatio = getNewCurrentFees(\n                meta.timeToWait,\n                meta.lastActionTimestamp,\n                meta.feeRatio\n            );\n        }\n        uint256 scalingFactor = currentExchangeRate.scaledMul((ScaledMath.ONE - currentFeeRatio));\n        uint256 neededLpTokens = underlyingAmount.scaledDivRoundUp(scalingFactor);\n\n        return neededLpTokens;\n    }\n\n    function getUnderlying() external view virtual override returns (address);\n\n    /**\n     * @notice Deposit funds for an address into liquidity pool and mint LP tokens in exchange.\n     * @param account Account to deposit for.\n     * @param depositAmount Amount of the underlying asset to supply.\n     * @param minTokenAmount Minimum amount of LP tokens that should be minted.\n     * @return Actual amount minted.\n     */\n    function depositFor(\n        address account,\n        uint256 depositAmount,\n        uint256 minTokenAmount\n    ) public payable override notPaused returns (uint256) {\n        uint256 rate = exchangeRate();\n\n        if (isCapped()) {\n            uint256 lpBalance = lpToken.balanceOf(account);\n            uint256 stakedAndLockedBalance = staker.stakedAndActionLockedBalanceOf(account);\n            uint256 currentUnderlyingBalance = (lpBalance + stakedAndLockedBalance).scaledMul(rate);\n            require(\n                currentUnderlyingBalance + depositAmount <= depositCap,\n                Error.EXCEEDS_DEPOSIT_CAP\n            );\n        }\n\n        _doTransferIn(msg.sender, depositAmount);\n        uint256 mintedLp = depositAmount.scaledDiv(rate);\n        require(mintedLp >= minTokenAmount, Error.INVALID_AMOUNT);\n\n        lpToken.mint(account, mintedLp);\n        _rebalanceVault();\n\n        if (msg.sender == account || address(this) == account) {\n            emit Deposit(msg.sender, depositAmount, mintedLp);\n        } else {\n            emit DepositFor(msg.sender, account, depositAmount, mintedLp);\n        }\n        return mintedLp;\n    }\n\n    /**\n     * @notice Redeems the underlying asset by burning LP tokens.\n     * @param redeemLpTokens Number of tokens to burn for redeeming the underlying.\n     * @param minRedeemAmount Minimum amount of underlying that should be received.\n     * @return Actual amount of the underlying redeemed.\n     */\n    function redeem(uint256 redeemLpTokens, uint256 minRedeemAmount)\n        public\n        override\n        returns (uint256)\n    {\n        require(redeemLpTokens > 0, Error.INVALID_AMOUNT);\n        ILpToken lpToken_ = lpToken;\n        require(lpToken_.balanceOf(msg.sender) >= redeemLpTokens, Error.INSUFFICIENT_BALANCE);\n\n        uint256 withdrawalFee = addressProvider.isAction(msg.sender)\n            ? 0\n            : getWithdrawalFee(msg.sender, redeemLpTokens);\n        uint256 redeemMinusFees = redeemLpTokens - withdrawalFee;\n        // Pay no fees on the last withdrawal (avoid locking funds in the pool)\n        if (redeemLpTokens == lpToken_.totalSupply()) {\n            redeemMinusFees = redeemLpTokens;\n        }\n        uint256 redeemUnderlying = redeemMinusFees.scaledMul(exchangeRate());\n        require(redeemUnderlying >= minRedeemAmount, Error.NOT_ENOUGH_FUNDS_WITHDRAWN);\n\n        _rebalanceVault(redeemUnderlying);\n\n        lpToken_.burn(msg.sender, redeemLpTokens);\n        _doTransferOut(payable(msg.sender), redeemUnderlying);\n        emit Redeem(msg.sender, redeemUnderlying, redeemLpTokens);\n        return redeemUnderlying;\n    }\n\n    /**\n     * @return the current required reserves ratio\n     */\n    function getRequiredReserveRatio() public view virtual returns (uint256) {\n        return currentUInts256[_REQUIRED_RESERVES_KEY];\n    }\n\n    /**\n     * @return the current maximum reserve deviation ratio\n     */\n    function getMaxReserveDeviationRatio() public view virtual returns (uint256) {\n        return currentUInts256[_RESERVE_DEVIATION_KEY];\n    }\n\n    /**\n     * @notice Returns the current minimum withdrawal fee\n     */\n    function getMinWithdrawalFee() public view returns (uint256) {\n        return currentUInts256[_MIN_WITHDRAWAL_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current maximum withdrawal fee\n     */\n    function getMaxWithdrawalFee() public view returns (uint256) {\n        return currentUInts256[_MAX_WITHDRAWAL_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current withdrawal fee decrease period\n     */\n    function getWithdrawalFeeDecreasePeriod() public view returns (uint256) {\n        return currentUInts256[_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY];\n    }\n\n    /**\n     * @return the current vault of the liquidity pool\n     */\n    function getVault() public view virtual override returns (IVault) {\n        return IVault(currentAddresses[_VAULT_KEY]);\n    }\n\n    /**\n     * @notice Compute current exchange rate of LP tokens to underlying scaled to 1e18.\n     * @dev Exchange rate means: underlying = LP token * exchangeRate\n     * @return Current exchange rate.\n     */\n    function exchangeRate() public view override returns (uint256) {\n        uint256 totalUnderlying_ = totalUnderlying();\n        uint256 totalSupply = lpToken.totalSupply();\n        if (totalSupply == 0 || totalUnderlying_ == 0) {\n            return ScaledMath.ONE;\n        }\n\n        return totalUnderlying_.scaledDiv(totalSupply);\n    }\n\n    /**\n     * @notice Compute total amount of underlying tokens for this pool.\n     * @return Total amount of underlying in pool.\n     */\n    function totalUnderlying() public view override returns (uint256) {\n        IVault vault = getVault();\n        uint256 balanceUnderlying = _getBalanceUnderlying();\n        if (address(vault) == address(0)) {\n            return balanceUnderlying;\n        }\n        uint256 investedUnderlying = vault.getTotalUnderlying();\n        return investedUnderlying + balanceUnderlying;\n    }\n\n    /**\n     * @notice Retuns if the pool has an active deposit limit\n     * @return `true` if there is currently a deposit limit\n     */\n    function isCapped() public view override returns (bool) {\n        return depositCap != 0;\n    }\n\n    /**\n     * @notice Returns the withdrawal fee for `account`\n     * @param account Address to get the withdrawal fee for\n     * @param amount Amount to calculate the withdrawal fee for\n     * @return Withdrawal fee in LP tokens\n     */\n    function getWithdrawalFee(address account, uint256 amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        WithdrawalFeeMeta memory meta = withdrawalFeeMetas[account];\n\n        if (lpToken.balanceOf(account) == 0) {\n            return 0;\n        }\n        uint256 currentFee = getNewCurrentFees(\n            meta.timeToWait,\n            meta.lastActionTimestamp,\n            meta.feeRatio\n        );\n        return amount.scaledMul(currentFee);\n    }\n\n    /**\n     * @notice Calculates the withdrawal fee a user would currently need to pay on currentBalance.\n     * @param timeToWait The total time to wait until the withdrawal fee reached the min. fee\n     * @param lastActionTimestamp Timestamp of the last fee update\n     * @param feeRatio Fees that would currently be paid on the user's entire balance\n     * @return Updated fee amount on the currentBalance\n     */\n    function getNewCurrentFees(\n        uint256 timeToWait,\n        uint256 lastActionTimestamp,\n        uint256 feeRatio\n    ) public view returns (uint256) {\n        uint256 timeElapsed = _getTime() - lastActionTimestamp;\n        uint256 minFeePercentage = getMinWithdrawalFee();\n        if (timeElapsed >= timeToWait) {\n            return minFeePercentage;\n        }\n        uint256 elapsedShare = timeElapsed.scaledDiv(timeToWait);\n        return feeRatio - (feeRatio - minFeePercentage).scaledMul(elapsedShare);\n    }\n\n    function _rebalanceVault() internal {\n        _rebalanceVault(0);\n    }\n\n    function _initialize(\n        string memory name_,\n        uint256 depositCap_,\n        address vault_\n    ) internal initializer returns (bool) {\n        name = name_;\n        depositCap = depositCap_;\n\n        _setConfig(_WITHDRAWAL_FEE_DECREASE_PERIOD_KEY, _INITIAL_FEE_DECREASE_PERIOD);\n        _setConfig(_MAX_WITHDRAWAL_FEE_KEY, _INITIAL_MAX_WITHDRAWAL_FEE);\n        _setConfig(_REQUIRED_RESERVES_KEY, ScaledMath.ONE);\n        _setConfig(_RESERVE_DEVIATION_KEY, _INITIAL_RESERVE_DEVIATION);\n        _setConfig(_VAULT_KEY, vault_);\n        return true;\n    }\n\n    function _approveStakerVaultSpendingLpTokens() internal {\n        address staker_ = address(staker);\n        address lpToken_ = address(lpToken);\n        if (staker_ == address(0) || lpToken_ == address(0)) return;\n        IERC20(lpToken_).safeApprove(staker_, type(uint256).max);\n    }\n\n    function _doTransferIn(address from, uint256 amount) internal virtual;\n\n    function _doTransferOut(address payable to, uint256 amount) internal virtual;\n\n    /**\n     * @dev Rebalances the pool's allocations to the vault\n     * @param underlyingToWithdraw Amount of underlying to withdraw such that after the withdrawal the pool and vault allocations are correctly balanced.\n     */\n    function _rebalanceVault(uint256 underlyingToWithdraw) internal {\n        IVault vault = getVault();\n\n        if (address(vault) == address(0)) return;\n        uint256 lockedLp = staker.getStakedByActions();\n        uint256 totalUnderlyingStaked = lockedLp.scaledMul(exchangeRate());\n\n        uint256 underlyingBalance = _getBalanceUnderlying(true);\n        uint256 maximumDeviation = totalUnderlyingStaked.scaledMul(getMaxReserveDeviationRatio());\n\n        uint256 nextTargetBalance = totalUnderlyingStaked.scaledMul(getRequiredReserveRatio());\n\n        if (\n            underlyingToWithdraw > underlyingBalance ||\n            (underlyingBalance - underlyingToWithdraw) + maximumDeviation < nextTargetBalance\n        ) {\n            uint256 requiredDeposits = nextTargetBalance + underlyingToWithdraw - underlyingBalance;\n            vault.withdraw(requiredDeposits);\n        } else {\n            uint256 nextBalance = underlyingBalance - underlyingToWithdraw;\n            if (nextBalance > nextTargetBalance + maximumDeviation) {\n                uint256 excessDeposits = nextBalance - nextTargetBalance;\n                _doTransferOut(payable(address(vault)), excessDeposits);\n                vault.deposit();\n            }\n        }\n    }\n\n    function _updateUserFeesOnDeposit(\n        address account,\n        address from,\n        uint256 amountAdded\n    ) internal {\n        WithdrawalFeeMeta storage meta = withdrawalFeeMetas[account];\n        uint256 balance = lpToken.balanceOf(account) +\n            staker.stakedAndActionLockedBalanceOf(account);\n        uint256 newCurrentFeeRatio = getNewCurrentFees(\n            meta.timeToWait,\n            meta.lastActionTimestamp,\n            meta.feeRatio\n        );\n        uint256 shareAdded = amountAdded.scaledDiv(amountAdded + balance);\n        uint256 shareExisting = ScaledMath.ONE - shareAdded;\n        uint256 feeOnDeposit;\n        if (from == address(0)) {\n            feeOnDeposit = getMaxWithdrawalFee();\n        } else {\n            WithdrawalFeeMeta storage fromMeta = withdrawalFeeMetas[from];\n            feeOnDeposit = getNewCurrentFees(\n                fromMeta.timeToWait,\n                fromMeta.lastActionTimestamp,\n                fromMeta.feeRatio\n            );\n        }\n\n        uint256 newFeeRatio = shareExisting.scaledMul(newCurrentFeeRatio) +\n            shareAdded.scaledMul(feeOnDeposit);\n\n        meta.feeRatio = uint64(newFeeRatio);\n        meta.timeToWait = uint64(getWithdrawalFeeDecreasePeriod());\n        meta.lastActionTimestamp = uint64(_getTime());\n    }\n\n    function _getBalanceUnderlying() internal view virtual returns (uint256);\n\n    function _getBalanceUnderlying(bool transferInDone) internal view virtual returns (uint256);\n\n    function _isAuthorizedToPause(address account) internal view override returns (bool) {\n        return _roleManager().hasRole(Roles.GOVERNANCE, account);\n    }\n\n    /**\n     * @dev Overriden for testing\n     */\n    function _getTime() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    function _checkFeeInvariants(uint256 minFee, uint256 maxFee) internal pure {\n        require(maxFee >= minFee, Error.INVALID_AMOUNT);\n        require(maxFee <= _MAX_WITHDRAWAL_FEE, Error.INVALID_AMOUNT);\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidityPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "LiquidityPool.sol#L523",
                "Type": "Bypassing depositCap guard",
                "Description": "ERC777 tokens can bypass depositCap guard.",
                "Repair": "Add reentrancy guards to depositFor()"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"./Vault.sol\";\n\ncontract EthVault is Vault {\n    using AddressProviderHelpers for IAddressProvider;\n\n    address private constant _UNDERLYING = address(0);\n\n    constructor(IController controller) Vault(controller) {}\n\n    receive() external payable {}\n\n    function initialize(\n        address _pool,\n        uint256 _debtLimit,\n        uint256 _targetAllocation,\n        uint256 _bound\n    ) external virtual override initializer {\n        _initialize(_pool, _debtLimit, _targetAllocation, _bound);\n    }\n\n    function getUnderlying() public pure override returns (address) {\n        return _UNDERLYING;\n    }\n\n    function _transfer(address to, uint256 amount) internal override {\n        payable(to).transfer(amount);\n    }\n\n    function _depositToReserve(uint256 amount) internal override {\n        reserve.deposit{value: amount}(_UNDERLYING, amount);\n    }\n\n    function _depositToTreasury(uint256 amount) internal override {\n        payable(addressProvider.getTreasury()).transfer(amount);\n    }\n\n    function _payStrategist(uint256 amount, address strategist) internal override {\n        if (strategist == address(0)) return;\n        ILiquidityPool(pool).depositFor{value: amount}(strategist, amount);\n    }\n\n    function _availableUnderlying() internal view override returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"./ConvexStrategyBase.sol\";\n\n/**\n * This is the BkdEthCvx strategy, which is designed to be used by a Backd ETH Vault.\n * The strategy holds ETH as it's underlying and allocates liquidity to Convex via given Curve Pool with 2 underlying tokens.\n * Rewards received on Convex (CVX, CRV), are sold in part for the underlying.\n * A share of earned CVX & CRV are retained on behalf of the Backd community to participate in governance.\n */\ncontract BkdEthCvx is ConvexStrategyBase {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    constructor(\n        address vault_,\n        address strategist_,\n        uint256 convexPid_,\n        address curvePool_,\n        uint256 curveIndex_,\n        IAddressProvider addressProvider_,\n        address strategySwapper_\n    )\n        ConvexStrategyBase(\n            vault_,\n            strategist_,\n            convexPid_,\n            curvePool_,\n            curveIndex_,\n            addressProvider_,\n            strategySwapper_\n        )\n    {\n        // Setting default values\n        imbalanceToleranceIn = 0.0007e18;\n        imbalanceToleranceOut = 0.0104e18;\n\n        // Approvals\n        (address lp_, , , , , ) = _BOOSTER.poolInfo(convexPid_);\n        IERC20(lp_).safeApprove(address(_BOOSTER), type(uint256).max);\n    }\n\n    receive() external payable {}\n\n    function name() external pure override returns (string memory) {\n        return \"BkdEthCvx\";\n    }\n\n    function balance() public view override returns (uint256) {\n        return _underlyingBalance() + _lpToUnderlying(_stakedBalance() + _lpBalance());\n    }\n\n    function _deposit() internal override returns (bool) {\n        // Depositing into Curve Pool\n        uint256 underlyingBalance = _underlyingBalance();\n        if (underlyingBalance == 0) return false;\n        uint256[2] memory amounts;\n        amounts[curveIndex] = underlyingBalance;\n        curvePool.add_liquidity{value: underlyingBalance}(\n            amounts,\n            _minLpAccepted(underlyingBalance)\n        );\n\n        // Depositing into Convex and Staking\n        if (!_BOOSTER.depositAll(convexPid, true)) return false;\n        return true;\n    }\n\n    function _withdraw(uint256 amount) internal override returns (bool) {\n        uint256 underlyingBalance = _underlyingBalance();\n\n        // Transferring from idle balance if enough\n        if (underlyingBalance >= amount) {\n            payable(vault).transfer(amount);\n            emit Withdraw(amount);\n            return true;\n        }\n\n        // Unstaking needed LP Tokens from Convex\n        uint256 requiredUnderlyingAmount = amount - underlyingBalance;\n        uint256 maxLpBurned = _maxLpBurned(requiredUnderlyingAmount);\n        uint256 requiredLpAmount = maxLpBurned - _lpBalance();\n        if (!rewards.withdrawAndUnwrap(requiredLpAmount, false)) return false;\n\n        // Removing needed liquidity from Curve\n        uint256[2] memory amounts;\n        // solhint-disable-next-line reentrancy\n        amounts[curveIndex] = requiredUnderlyingAmount;\n        curvePool.remove_liquidity_imbalance(amounts, maxLpBurned);\n        payable(vault).transfer(amount);\n        return true;\n    }\n\n    function _withdrawAll() internal override returns (uint256) {\n        // Unstaking and withdrawing from Convex pool\n        uint256 stakedBalance = _stakedBalance();\n        if (stakedBalance > 0) {\n            if (!rewards.withdrawAndUnwrap(stakedBalance, false)) return 0;\n        }\n\n        // Removing liquidity from Curve\n        uint256 lpBalance = _lpBalance();\n        if (lpBalance > 0) {\n            curvePool.remove_liquidity_one_coin(\n                lpBalance,\n                int128(uint128(curveIndex)),\n                _minUnderlyingAccepted(lpBalance)\n            );\n        }\n\n        // Transferring underlying to vault\n        uint256 underlyingBalance = _underlyingBalance();\n        if (underlyingBalance == 0) return 0;\n        payable(vault).transfer(underlyingBalance);\n        return underlyingBalance;\n    }\n\n    function _underlyingBalance() internal view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @notice Calculates the minimum LP to accept when depositing underlying into Curve Pool.\n     * @param _underlyingAmount Amount of underlying that is being deposited into Curve Pool.\n     * @return The minimum LP balance to accept.\n     */\n    function _minLpAccepted(uint256 _underlyingAmount) internal view returns (uint256) {\n        return _underlyingToLp(_underlyingAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceIn);\n    }\n\n    /**\n     * @notice Calculates the maximum LP to accept burning when withdrawing amount from Curve Pool.\n     * @param _underlyingAmount Amount of underlying that is being widthdrawn from Curve Pool.\n     * @return The maximum LP balance to accept burning.\n     */\n    function _maxLpBurned(uint256 _underlyingAmount) internal view returns (uint256) {\n        return _underlyingToLp(_underlyingAmount).scaledMul(ScaledMath.ONE + imbalanceToleranceOut);\n    }\n\n    /**\n     * @notice Calculates the minimum underlying to accept when burning LP tokens to withdraw from Curve Pool.\n     * @param _lpAmount Amount of LP tokens being burned to withdraw from Curve Pool.\n     * @return The minimum underlying balance to accept.\n     */\n    function _minUnderlyingAccepted(uint256 _lpAmount) internal view returns (uint256) {\n        return _lpToUnderlying(_lpAmount).scaledMul(ScaledMath.ONE - imbalanceToleranceOut);\n    }\n\n    /**\n     * @notice Converts an amount of underlying into their estimated LP value.\n     * @dev Uses get_virtual_price which is less suceptible to manipulation.\n     *  But is also less accurate to how much could be withdrawn.\n     * @param _underlyingAmount Amount of underlying to convert.\n     * @return The estimated value in the LP.\n     */\n    function _underlyingToLp(uint256 _underlyingAmount) internal view returns (uint256) {\n        return _underlyingAmount.scaledDiv(curvePool.get_virtual_price());\n    }\n\n    /**\n     * @notice Converts an amount of LP into their estimated underlying value.\n     * @dev Uses get_virtual_price which is less suceptible to manipulation.\n     *  But is also less accurate to how much could be withdrawn.\n     * @param _lpAmount Amount of LP to convert.\n     * @return The estimated value in the underlying.\n     */\n    function _lpToUnderlying(uint256 _lpAmount) internal view returns (uint256) {\n        return _lpAmount.scaledMul(curvePool.get_virtual_price());\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/IVaultReserve.sol\";\nimport \"../../libraries/Errors.sol\";\n\nimport \"../access/Authorization.sol\";\nimport \"../vault/Vault.sol\";\n\n/**\n * @notice Contract holding vault reserves\n * @dev ETH reserves are stored under address(0)\n */\ncontract VaultReserve is IVaultReserve, Authorization {\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant _INITIAL_WITHDRAWAL_DELAY = 3 days;\n\n    mapping(address => mapping(address => uint256)) private _balances;\n    mapping(address => uint256) private _lastWithdrawal;\n\n    uint256 public minWithdrawalDelay;\n\n    modifier onlyVault() {\n        require(_roleManager().hasRole(Roles.VAULT, msg.sender), Error.UNAUTHORIZED_ACCESS);\n        _;\n    }\n\n    constructor(IRoleManager roleManager) Authorization(roleManager) {\n        minWithdrawalDelay = _INITIAL_WITHDRAWAL_DELAY;\n    }\n\n    /**\n     * @notice Deposit funds into vault reserve.\n     * @notice Only callable by a whitelisted vault.\n     * @param token Token to deposit.\n     * @param amount Amount to deposit.\n     * @return True if deposit was successful.\n     */\n    function deposit(address token, uint256 amount)\n        external\n        payable\n        override\n        onlyVault\n        returns (bool)\n    {\n        if (token == address(0)) {\n            require(msg.value == amount, Error.INVALID_AMOUNT);\n            _balances[msg.sender][token] += msg.value;\n            return true;\n        }\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBalance = IERC20(token).balanceOf(address(this));\n        uint256 received = newBalance - balance;\n        require(received >= amount, Error.INVALID_AMOUNT);\n        _balances[msg.sender][token] += received;\n        emit Deposit(msg.sender, token, amount);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw funds from vault reserve.\n     * @notice Only callable by a whitelisted vault.\n     * @param token Token to withdraw.\n     * @param amount Amount to withdraw.\n     * @return True if withdrawal was successful.\n     */\n    function withdraw(address token, uint256 amount) external override onlyVault returns (bool) {\n        require(canWithdraw(msg.sender), Error.RESERVE_ACCESS_EXCEEDED);\n        uint256 accountBalance = _balances[msg.sender][token];\n        require(accountBalance >= amount, Error.INSUFFICIENT_BALANCE);\n\n        _balances[msg.sender][token] -= amount;\n        _lastWithdrawal[msg.sender] = block.timestamp;\n\n        if (token == address(0)) {\n            payable(msg.sender).transfer(amount);\n        } else {\n            IERC20(token).safeTransfer(msg.sender, amount);\n        }\n        emit Withdraw(msg.sender, token, amount);\n        return true;\n    }\n\n    /**\n     * @notice Check token balance of a specific vault.\n     * @param vault Vault to check balance of.\n     * @param token Token to check balance in.\n     * @return Token balance of vault.\n     */\n    function getBalance(address vault, address token) public view override returns (uint256) {\n        return _balances[vault][token];\n    }\n\n    /**\n     * @notice returns true if the vault is allowed to withdraw from the reserve\n     */\n    function canWithdraw(address vault) public view returns (bool) {\n        return block.timestamp >= _lastWithdrawal[vault] + minWithdrawalDelay;\n    }\n}\n\n\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"./LiquidityPool.sol\";\nimport \"../../interfaces/pool/IEthPool.sol\";\n\ncontract EthPool is LiquidityPool, IEthPool {\n    constructor(IController _controller) LiquidityPool(_controller) {}\n\n    receive() external payable {}\n\n    function initialize(\n        string memory name_,\n        uint256 depositCap_,\n        address vault_\n    ) external override returns (bool) {\n        return _initialize(name_, depositCap_, vault_);\n    }\n\n    function getUnderlying() public pure override returns (address) {\n        return address(0);\n    }\n\n    function _doTransferIn(address from, uint256 amount) internal override {\n        require(msg.sender == from, Error.INVALID_SENDER);\n        require(msg.value == amount, Error.INVALID_AMOUNT);\n    }\n\n    function _doTransferOut(address payable to, uint256 amount) internal override {\n        to.transfer(amount);\n    }\n\n    function _getBalanceUnderlying() internal view override returns (uint256) {\n        return _getBalanceUnderlying(false);\n    }\n\n    function _getBalanceUnderlying(bool transferInDone) internal view override returns (uint256) {\n        uint256 balance = address(this).balance;\n        if (!transferInDone) {\n            balance -= msg.value;\n        }\n        return balance;\n    }\n}\n\n\n",
        "CodeNames": [
            "EthVault.sol",
            "BkdEthCvx.sol",
            "VaultReserve.sol",
            "EthPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "EthPool.sol#L30, BkdEthCvx.sol#L77, EthVault.sol#L29, VaultReserve.sol#L81",
                "Type": "Using deprecated transfer() function",
                "Description": "The transaction will fail when the claimer smart contract does not implement a payable function or implements a payable fallback which uses more than 2300 gas unit.",
                "Repair": "Use call() instead of transfer()"
            }
        ]
    }
]