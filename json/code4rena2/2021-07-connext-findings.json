[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "In variantTransactionData call",
                "Type": "Malicious router can block cross-chain-transfers",
                "Description": "A router could pretend to take on a user's cross-chain transfer, the user sends their prepare transaction, locking up funds on the sending chain. But then the router simply doesn't respond or responds with a prepare transaction of amount=0.",
                "Repair": "Add a penalty mechanism for non-responsive routers that agreed off-chain, slashing part of their added liquidity"
            },
            {
                "Location": "recoverFulfillSignature() function",
                "Type": "Signatures use only tx ID instead of entire digest",
                "Description": "The signature check in recoverFulfillSignature() only uses transaction ID (along with the relayer fee) which can be accidentally reused by the user.",
                "Repair": "Evaluate if the signature should contain only tx ID, or the entire digest, and then change the logic appropriately"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport \"./interfaces/IFulfillHelper.sol\";\nimport \"./interfaces/ITransactionManager.sol\";\nimport \"./lib/LibAsset.sol\";\nimport \"./lib/LibERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n// Outstanding qs:\n// - what happens if you have unique user data, but duplicate tx ids?\n//   no requires here would catch this, the tx would be properly prepared\n//\n// - we validate all the inputs but the amount, bidSignature, and encodedBid.\n//   bidSignature and encodedBid could be used as slashing later, and their\n//   validation is out of scope of this function. But, do we want to be able\n//   to use this to send 0-value amounts? basically as some incentivized\n//   relayer? would that break bidding?\n\n\n/// @title TransactionManager\n/// @author Connext <support@connext.network>\n/// @notice This contract holds the logic to facilitate crosschain transactions.\n///         Transactions go through three phases:\n///\n///         1. Route Auction: User broadcasts to our network signalling their \n///         desired route. Routers respond with sealed bids containing \n///         commitments to fulfilling the transaction within a certain time and \n///         price range.\n///\n///         2. Prepare: Once the auction is completed, the transaction can be \n///         prepared. The user submits a transaction to `TransactionManager` \n///         contract on sender-side chain containing router's signed bid. This \n///         transaction locks up the users funds on the sending chiain. Upon \n///         detecting an event containing their signed bid from the chain, \n///         router submits the same transaction to `TransactionManager` on the \n///         receiver-side chain, and locks up a corresponding amount of \n///         liquidity. The amount locked on the receiving chain is `sending \n///         amount - auction fee` so the router is incentivized to complete the \n///         transaction.\n///\n///         3. Fulfill: Upon detecting the `TransactionPrepared` event on the \n///         receiver-side chain, the user signs a message and sends it to a \n///         relayer, who will earn a fee for submission. The relayer (which may \n///         be the router) then submits the message to the `TransactionManager` \n///         to complete their transaction on receiver-side chain and claim the \n///         funds locked by the router. A relayer is used here to allow users \n///         to submit transactions with arbitrary calldata on the receiving \n///         chain without needing gas to do so. The router then submits the \n///         same signed message and completes transaction on sender-side, \n///         unlocking the original `amount`.\n///\n///         If a transaction is not fulfilled within a fixed timeout, it \n///         reverts and can be reclaimed by the party that called `prepare` on \n///         each chain (initiator). Additionally, transactions can be cancelled \n///         unilaterally by the person owed funds on that chain (router for \n///         sending chain, user for receiving chain) prior to expiry.\n\ncontract TransactionManager is ReentrancyGuard, ITransactionManager {\n  /// @dev Mapping of router to balance specific to asset\n  mapping(address => mapping(address => uint256)) public routerBalances;\n\n  /// @dev Mapping of user address to blocks where active transfers\n  ///      were created.\n  mapping(address => uint256[]) public activeTransactionBlocks;\n\n  /// @dev Mapping of hash of `InvariantTransactionData` to the hash\n  //       of the `VariantTransactionData`\n  mapping(bytes32 => bytes32) public variantTransactionData;\n\n  /// @dev The chain id of the contract, is passed in to avoid any evm issues\n  uint256 public immutable chainId;\n\n  /// @dev Minimum timeout (will be the lowest on the receiving chain)\n  uint256 public constant MIN_TIMEOUT = 24 hours;\n\n  constructor(uint256 _chainId) {\n    chainId = _chainId;\n  }\n\n  /// @notice This is used by any router to increase their available\n  ///         liquidity for a given asset.\n  /// @param amount The amount of liquidity to add for the router\n  /// @param assetId The address (or `address(0)` if native asset) of the\n  ///                asset you're adding liquidity for\n  /// @param router The router you are adding liquidity on behalf of\n  function addLiquidity(uint256 amount, address assetId, address router) external payable override nonReentrant {\n    // Sanity check: nonzero amounts\n    require(amount > 0, \"addLiquidity: AMOUNT_IS_ZERO\");\n\n    // Validate correct amounts are transferred\n    if (LibAsset.isEther(assetId)) {\n      require(msg.value == amount, \"addLiquidity: VALUE_MISMATCH\");\n    } else {\n      require(msg.value == 0, \"addLiquidity: ETH_WITH_ERC_TRANSFER\");\n      require(LibERC20.transferFrom(assetId, router, address(this), amount), \"addLiquidity: ERC20_TRANSFER_FAILED\");\n    }\n\n    // Update the router balances\n    routerBalances[router][assetId] += amount;\n\n    // Emit event\n    emit LiquidityAdded(router, assetId, amount, msg.sender);\n  }\n\n  /// @notice This is used by any router to decrease their available\n  ///         liquidity for a given asset.\n  /// @param amount The amount of liquidity to remove for the router\n  /// @param assetId The address (or `address(0)` if native asset) of the\n  ///                asset you're removing liquidity for\n  /// @param recipient The address that will receive the liquidity being removed\n  function removeLiquidity(\n    uint256 amount,\n    address assetId,\n    address payable recipient\n  ) external override nonReentrant {\n    // Sanity check: nonzero amounts\n    require(amount > 0, \"removeLiquidity: AMOUNT_IS_ZERO\");\n\n    // Sanity check: amount can be deducted for the router\n    require(routerBalances[msg.sender][assetId] >= amount, \"removeLiquidity: INSUFFICIENT_FUNDS\");\n\n    // Update router balances\n    routerBalances[msg.sender][assetId] -= amount;\n\n    // Transfer from contract to specified recipient\n    require(LibAsset.transferAsset(assetId, recipient, amount), \"removeLiquidity: TRANSFER_FAILED\");\n\n    // Emit event\n    emit LiquidityRemoved(msg.sender, assetId, amount, recipient);\n  }\n\n  /// @notice This function creates a crosschain transaction. When called on\n  ///         the sending chain, the user is expected to lock up funds. When\n  ///         called on the receiving chain, the router deducts the transfer\n  ///         amount from the available liquidity. The majority of the\n  ///         information about a given transfer does not change between chains,\n  ///         with three notable exceptions: `amount`, `expiry`, and \n  ///         `preparedBlock`. The `amount` and `expiry` are decremented\n  ///         between sending and receiving chains to provide an incentive for \n  ///         the router to complete the transaction and time for the router to\n  ///         fulfill the transaction on the sending chain after the unlocking\n  ///         signature is revealed, respectively.\n  /// @param invariantData The data for a crosschain transaction that will\n  ///                      not change between sending and receiving chains.\n  ///                      The hash of this data is used as the key to store \n  ///                      the inforamtion that does change between chains \n  ///                      (amount, expiry,preparedBlock) for verification\n  /// @param amount The amount of the transaction on this chain\n  /// @param expiry The block.timestamp when the transaction will no longer be\n  ///               fulfillable and is freely cancellable on this chain\n  /// @param encryptedCallData The calldata to be executed when the tx is\n  ///                          fulfilled. Used in the function to allow the user\n  ///                          to reconstruct the tx from events. Hash is stored\n  ///                          onchain to prevent shenanigans.\n  /// @param encodedBid The encoded bid that was accepted by the user for this\n  ///                   crosschain transfer. It is supplied as a param to the\n  ///                   function but is only used in event emission\n  /// @param bidSignature The signature of the bidder on the encoded bid for\n  ///                     this transaction. Only used within the function for\n  ///                     event emission. The validity of the bid and\n  ///                     bidSignature are enforced offchain\n  function prepare(\n    InvariantTransactionData calldata invariantData,\n    uint256 amount,\n    uint256 expiry,\n    bytes calldata encryptedCallData,\n    bytes calldata encodedBid,\n    bytes calldata bidSignature\n  ) external payable override nonReentrant returns (TransactionData memory) {\n    // Sanity check: user is sensible\n    require(invariantData.user != address(0), \"prepare: USER_EMPTY\");\n\n    // Sanity check: router is sensible\n    require(invariantData.router != address(0), \"prepare: ROUTER_EMPTY\");\n\n    // Sanity check: valid fallback\n    require(invariantData.receivingAddress != address(0), \"prepare: RECEIVING_ADDRESS_EMPTY\");\n\n    // Make sure the chains are different\n    require(invariantData.sendingChainId != invariantData.receivingChainId, \"prepare: SAME_CHAINIDS\");\n\n    // Make sure the chains are relevant\n    require(invariantData.sendingChainId == chainId || invariantData.receivingChainId == chainId, \"prepare: INVALID_CHAINIDS\");\n\n    // Make sure the expiry is greater than min\n    require((expiry - block.timestamp) >= MIN_TIMEOUT, \"prepare: TIMEOUT_TOO_LOW\");\n\n    // Make sure the hash is not a duplicate\n    bytes32 digest = keccak256(abi.encode(invariantData));\n    require(variantTransactionData[digest] == bytes32(0), \"prepare: DIGEST_EXISTS\");\n\n    // NOTE: the `encodedBid` and `bidSignature` are simply passed through\n    //       to the contract emitted event to ensure the availability of\n    //       this information. Their validity is asserted offchain, and\n    //       is out of scope of this contract. They are used as inputs so\n    //       in the event of a router or user crash, they may recover the\n    //       correct bid information without requiring an offchain store.\n\n    // Store the transaction variants\n    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({\n      amount: amount,\n      expiry: expiry,\n      preparedBlockNumber: block.number\n    })));\n\n    // Store active blocks\n    activeTransactionBlocks[invariantData.user].push(block.number);\n\n    // First determine if this is sender side or receiver side\n    if (invariantData.sendingChainId == chainId) {\n      // Sanity check: amount is sensible\n      // Only check on sending chain to enforce router fees. Transactions could\n      // be 0-valued on receiving chain if it is just a value-less call to some\n      // `IFulfillHelper`\n      require(amount > 0, \"prepare: AMOUNT_IS_ZERO\");\n\n      // This is sender side prepare. The user is beginning the process of \n      // submitting an onchain tx after accepting some bid. They should\n      // lock their funds in the contract for the router to claim after\n      // they have revealed their signature on the receiving chain via\n      // submitting a corresponding `fulfill` tx\n\n      // Validate correct amounts on msg and transfer from user to\n      // contract\n      if (LibAsset.isEther(invariantData.sendingAssetId)) {\n        require(msg.value == amount, \"prepare: VALUE_MISMATCH\");\n      } else {\n        require(msg.value == 0, \"prepare: ETH_WITH_ERC_TRANSFER\");\n        require(\n          LibERC20.transferFrom(invariantData.sendingAssetId, msg.sender, address(this), amount),\n          \"prepare: ERC20_TRANSFER_FAILED\"\n        );\n      }\n    } else {\n      // This is receiver side prepare. The router has proposed a bid on the\n      // transfer which the user has accepted. They can now lock up their\n      // own liquidity on th receiving chain, which the user can unlock by\n      // calling `fulfill`. When creating the `amount` and `expiry` on the\n      // receiving chain, the router should have decremented both. The\n      // expiry should be decremented to ensure the router has time to\n      // complete the sender-side transaction after the user completes the\n      // receiver-side transactoin. The amount should be decremented to act as\n      // a fee to incentivize the router to complete the transaction properly.\n\n      // Check that the caller is the router\n      require(msg.sender == invariantData.router, \"prepare: ROUTER_MISMATCH\");\n\n      // Check that the router isnt accidentally locking funds in the contract\n      require(msg.value == 0, \"prepare: ETH_WITH_ROUTER_PREPARE\");\n\n      // Check that router has liquidity\n      require(\n        routerBalances[invariantData.router][invariantData.receivingAssetId] >= amount,\n        \"prepare: INSUFFICIENT_LIQUIDITY\"\n      );\n\n      // Decrement the router liquidity\n      routerBalances[invariantData.router][invariantData.receivingAssetId] -= amount;\n    }\n\n    // Emit event\n    TransactionData memory txData = TransactionData({\n      user: invariantData.user,\n      router: invariantData.router,\n      sendingAssetId: invariantData.sendingAssetId,\n      receivingAssetId: invariantData.receivingAssetId,\n      sendingChainFallback: invariantData.sendingChainFallback,\n      callTo: invariantData.callTo,\n      receivingAddress: invariantData.receivingAddress,\n      callDataHash: invariantData.callDataHash,\n      transactionId: invariantData.transactionId,\n      sendingChainId: invariantData.sendingChainId,\n      receivingChainId: invariantData.receivingChainId,\n      amount: amount,\n      expiry: expiry,\n      preparedBlockNumber: block.number\n    });\n    emit TransactionPrepared(txData.user, txData.router, txData.transactionId, txData, msg.sender, encryptedCallData, encodedBid, bidSignature);\n    return txData;\n  }\n\n\n\n  /// @notice This function completes a crosschain transaction. When called on\n  ///         the receiving chain, the user reveals their signature on the\n  ///         invariant parts of the transaction data and is sent the \n  ///         appropriate amount. The router then uses this signature to\n  ///         unlock the corresponding funds on the receiving chain, which are\n  ///         then added back to their available liquidity. The user includes a\n  ///         relayer fee since it is not assumed they will have gas on the\n  ///         receiving chain. This function *must* be called before the\n  ///         transaction expiry has elapsed.\n  /// @param txData All of the data (invariant and variant) for a crosschain\n  ///               transaction. The variant data provided is checked against\n  ///               what was stored when the `prepare` function was called.\n  /// @param relayerFee The fee that should go to the relayer when they are\n  ///                   calling the function on the receiving chain for the user\n  /// @param signature The users signature on the invariant data + fee that\n  ///                  can be used by the router to unlock the transaction on \n  ///                  the sending chain\n  function fulfill(\n    TransactionData calldata txData,\n    uint256 relayerFee,\n    bytes calldata signature, // signature on fee + digest\n    bytes calldata callData\n  ) external override nonReentrant returns (TransactionData memory) {\n    // Get the hash of the invariant tx data. This hash is the same\n    // between sending and receiving chains. The variant data is stored\n    // in the contract when `prepare` is called within the mapping.\n    bytes32 digest = hashInvariantTransactionData(txData);\n\n    // Make sure that the variant data matches what was stored\n    require(variantTransactionData[digest] == hashVariantTransactionData(txData), \"fulfill: INVALID_VARIANT_DATA\");\n\n    // Make sure the expiry has not elapsed\n    require(txData.expiry > block.timestamp, \"fulfill: EXPIRED\");\n\n    // Make sure the transaction wasn't already completed\n    require(txData.preparedBlockNumber > 0, \"fulfill: ALREADY_COMPLETED\");\n\n    // Validate the user has signed\n    require(recoverFulfillSignature(txData, relayerFee, signature) == txData.user, \"fulfill: INVALID_SIGNATURE\");\n\n    // Sanity check: fee <= amount. Allow `=` in case of only wanting to execute\n    // 0-value crosschain tx, so only providing the fee amount\n    require(relayerFee <= txData.amount, \"fulfill: INVALID_RELAYER_FEE\");\n\n    // Check provided callData matches stored hash\n    require(keccak256(callData) == txData.callDataHash, \"fulfill: INVALID_CALL_DATA\");\n\n    // To prevent `fulfill` / `cancel` from being called multiple times, the\n    // preparedBlockNumber is set to 0 before being hashed. The value of the\n    // mapping is explicitly *not* zeroed out so users who come online without\n    // a store can tell the difference between a transaction that has not been\n    // prepared, and a transaction that was already completed on the receiver\n    // chain.\n    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({\n      amount: txData.amount,\n      expiry: txData.expiry,\n      preparedBlockNumber: 0\n    })));\n\n    // Remove the transaction prepared block from the active blocks\n    removeUserActiveBlocks(txData.user, txData.preparedBlockNumber);\n\n    if (txData.sendingChainId == chainId) {\n      // The router is completing the transaction, they should get the\n      // amount that the user deposited credited to their liquidity\n      // reserves.\n\n      // Make sure that the user is not accidentally fulfilling the transaction\n      // on the sending chain\n      require(msg.sender == txData.router, \"fulfill: ROUTER_MISMATCH\");\n\n      // Complete tx to router for original sending amount\n      routerBalances[txData.router][txData.sendingAssetId] += txData.amount;\n    } else {\n      // The user is completing the transaction, they should get the\n      // amount that the router deposited less fees for relayer.\n\n      // Get the amount to send\n      uint256 toSend = txData.amount - relayerFee;\n\n      // Send the relayer the fee\n      if (relayerFee > 0) {\n        require(\n          LibAsset.transferAsset(txData.receivingAssetId, payable(msg.sender), relayerFee),\n          \"fulfill: FEE_TRANSFER_FAILED\"\n        );\n      }\n\n      // Handle receiver chain external calls if needed\n      if (txData.callTo == address(0)) {\n        // No external calls, send directly to receiving address\n        require(\n          LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),\n          \"fulfill: TRANSFER_FAILED\"\n        );\n      } else {\n        // Handle external calls with a fallback to the receiving\n        // address in case the call fails so the funds dont remain\n        // locked.\n\n        // First, approve the funds to the helper if needed\n        if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {\n          require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), \"fulfill: APPROVAL_FAILED\");\n        }\n\n        // Next, call `addFunds` on the helper. Helpers should internally\n        // track funds to make sure no one user is able to take all funds\n        // for tx\n        if (toSend > 0) {\n          try\n            IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(\n              txData.user,\n              txData.transactionId,\n              txData.receivingAssetId,\n              toSend\n            )\n          {} catch {\n            // Regardless of error within the callData execution, send funds\n            // to the predetermined fallback address\n            require(\n              LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),\n              \"fulfill: TRANSFER_FAILED\"\n            );\n          }\n        }\n\n        // Call `execute` on the helper\n        try\n          IFulfillHelper(txData.callTo).execute(\n            txData.user,\n            txData.transactionId,\n            txData.receivingAssetId,\n            toSend,\n            callData\n          )\n        {} catch {\n          // Regardless of error within the callData execution, send funds\n          // to the predetermined fallback address\n          require(\n            LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),\n            \"fulfill: TRANSFER_FAILED\"\n          );\n        }\n      }\n    }\n\n    // Emit event\n    emit TransactionFulfilled(txData.user, txData.router, txData.transactionId, txData, relayerFee, signature, callData, msg.sender);\n\n    return txData;\n  }\n\n  /// @notice Any crosschain transaction can be cancelled after it has been\n  ///         created to prevent indefinite lock up of funds. After the\n  ///         transaction has expired, anyone can cancel it. Before the\n  ///         expiry, only the recipient of the funds on the given chain is\n  ///         able to cancel. On the sending chain, this means only the router\n  ///         is able to cancel before the expiry, while only the user can\n  ///         prematurely cancel on the receiving chain.\n  /// @param txData All of the data (invariant and variant) for a crosschain\n  ///               transaction. The variant data provided is checked against\n  ///               what was stored when the `prepare` function was called.\n  /// @param relayerFee The fee that should go to the relayer when they are\n  ///                   calling the function for the user\n  /// @param signature The user's signature that allows a transaction to be\n  ///                  cancelled on the receiving chain.\n  function cancel(TransactionData calldata txData, uint256 relayerFee, bytes calldata signature)\n    external\n    override\n    nonReentrant\n    returns (TransactionData memory)\n  {\n    // Make sure params match against stored data\n    // Also checks that there is an active transfer here\n    // Also checks that sender or receiver chainID is this chainId (bc we checked it previously)\n\n    // Get the hash of the invariant tx data. This hash is the same\n    // between sending and receiving chains. The variant data is stored\n    // in the contract when `prepare` is called within the mapping.\n    bytes32 digest = hashInvariantTransactionData(txData);\n\n    // Verify the variant data is correct\n    require(variantTransactionData[digest] == hashVariantTransactionData(txData), \"cancel: INVALID_VARIANT_DATA\");\n\n    // Make sure the transaction wasn't already completed\n    require(txData.preparedBlockNumber > 0, \"cancel: ALREADY_COMPLETED\");\n\n    // Sanity check: fee <= amount. Allow `=` in case of only wanting to execute\n    // 0-value crosschain tx, so only providing the fee amount\n    require(relayerFee <= txData.amount, \"cancel: INVALID_RELAYER_FEE\");\n\n    // To prevent `fulfill` / `cancel` from being called multiple times, the\n    // preparedBlockNumber is set to 0 before being hashed. The value of the\n    // mapping is explicitly *not* zeroed out so users who come online without\n    // a store can tell the difference between a transaction that has not been\n    // prepared, and a transaction that was already completed on the receiver\n    // chain.\n    variantTransactionData[digest] = keccak256(abi.encode(VariantTransactionData({\n      amount: txData.amount,\n      expiry: txData.expiry,\n      preparedBlockNumber: 0\n    })));\n\n    // Remove active blocks\n    removeUserActiveBlocks(txData.user, txData.preparedBlockNumber);\n\n    // Return the appropriate locked funds\n    if (txData.sendingChainId == chainId) {\n      // Sender side, funds must be returned to the user\n      if (txData.expiry >= block.timestamp) {\n        // Timeout has not expired and tx may only be cancelled by router\n        // NOTE: no need to validate the signature here, since you are requiring\n        // the router must be the sender when the cancellation is during the\n        // fulfill-able window\n        require(msg.sender == txData.router, \"cancel: ROUTER_MUST_CANCEL\");\n\n        // Return totality of locked funds to provided fallbacl\n        require(\n          LibAsset.transferAsset(txData.sendingAssetId, payable(txData.sendingChainFallback), txData.amount),\n          \"cancel: TRANSFER_FAILED\"\n        );\n      } else {\n        // When the user could be unlocking funds through a relayer, validate\n        // their signature and payout the relayer.\n        if (relayerFee > 0) {\n          require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, \"cancel: INVALID_SIGNATURE\");\n\n          require(\n            LibAsset.transferAsset(txData.receivingAssetId, payable(msg.sender), relayerFee),\n            \"cancel: FEE_TRANSFER_FAILED\"\n          );\n        }\n\n        // Get the amount to refund the user\n        uint256 toRefund = txData.amount - relayerFee;\n\n        // Return locked funds to sending chain fallback\n        if (toRefund > 0) {\n          require(\n            LibAsset.transferAsset(txData.sendingAssetId, payable(txData.sendingChainFallback), toRefund),\n            \"cancel: TRANSFER_FAILED\"\n          );\n        }\n      }\n\n    } else {\n      // Receiver side, router liquidity is returned\n      if (txData.expiry >= block.timestamp) {\n        // Timeout has not expired and tx may only be cancelled by user\n        // Validate signature\n        require(recoverCancelSignature(txData, relayerFee, signature) == txData.user, \"cancel: INVALID_SIGNATURE\");\n\n        // NOTE: there is no incentive here for relayers to submit this on\n        // behalf of the user (i.e. fee not respected) because the user has not\n        // locked funds on this contract.\n      }\n\n      // Return liquidity to router\n      routerBalances[txData.router][txData.receivingAssetId] += txData.amount;\n    }\n\n    // Emit event\n    emit TransactionCancelled(txData.user, txData.router, txData.transactionId, txData, relayerFee, msg.sender);\n\n    // Return\n    return txData;\n  }\n\n  // helper method to get full array of active blocks\n  function getActiveTransactionBlocks(address user) external override view returns (uint256[] memory) {\n    return activeTransactionBlocks[user];\n  }\n\n  //////////////////////////\n  /// Private functions ///\n  //////////////////////////\n\n  /// @notice Removes a given block from the tracked activeTransactionBlocks\n  ///         array for the user. Called when transactions are completed.\n  /// @param user User who has completed a transaction\n  /// @param preparedBlock The TransactionData.preparedBlockNumber to remove\n  function removeUserActiveBlocks(address user, uint256 preparedBlock) internal {\n    // Remove active blocks\n    uint256 newLength = activeTransactionBlocks[user].length - 1;\n    uint256[] memory updated = new uint256[](newLength);\n    bool removed = false;\n    uint256 updatedIdx = 0;\n    for (uint256 i; i < newLength + 1; i++) {\n      // Handle case where there could be more than one tx added in a block\n      // And only one should be removed\n      if (!removed && activeTransactionBlocks[user][i] == preparedBlock) {\n        removed = true;\n        continue;\n      }\n      updated[updatedIdx] = activeTransactionBlocks[user][i];\n      updatedIdx++;\n    }\n    activeTransactionBlocks[user] = updated;\n  }\n\n  /// @notice Recovers the signer from the signature provided to the `fulfill`\n  ///         function. Returns the address recovered\n  /// @param txData TransactionData of the transaction being fulfilled\n  /// @param relayerFee The fee paid to the relayer for submitting the fulfill\n  ///                   tx on behalf of the user.\n  /// @param signature The signature you are recovering the signer from\n  function recoverFulfillSignature(\n    TransactionData calldata txData,\n    uint256 relayerFee,\n    bytes calldata signature\n  ) internal pure returns (address) {\n    // Create the signed payload\n    SignedFulfillData memory payload = SignedFulfillData({transactionId: txData.transactionId, relayerFee: relayerFee});\n\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(abi.encode(payload))), signature);\n  }\n\n  /// @notice Recovers the signer from the signature provided to the `cancel`\n  ///         function. Returns the address recovered\n  /// @param txData TransactionData of the transaction being fulfilled\n  /// @param relayerFee The fee paid to the relayer for submitting the cancel\n  ///                   tx on behalf of the user.\n  /// @param signature The signature you are recovering the signer from\n  function recoverCancelSignature(TransactionData calldata txData, uint256 relayerFee, bytes calldata signature)\n    internal\n    pure\n    returns (address)\n  {\n    // Create the signed payload\n    SignedCancelData memory payload = SignedCancelData({transactionId: txData.transactionId, cancel: \"cancel\", relayerFee: relayerFee});\n\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(abi.encode(payload))), signature);\n  }\n\n  /// @notice Returns the hash of only the invariant portions of a given\n  ///         crosschain transaction\n  /// @param txData TransactionData to hash\n  function hashInvariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {\n    InvariantTransactionData memory invariant = InvariantTransactionData({\n      user: txData.user,\n      router: txData.router,\n      sendingAssetId: txData.sendingAssetId,\n      receivingAssetId: txData.receivingAssetId,\n      sendingChainFallback: txData.sendingChainFallback,\n      callTo: txData.callTo,\n      receivingAddress: txData.receivingAddress,\n      sendingChainId: txData.sendingChainId,\n      receivingChainId: txData.receivingChainId,\n      callDataHash: txData.callDataHash,\n      transactionId: txData.transactionId\n    });\n    return keccak256(abi.encode(invariant));\n  }\n\n  /// @notice Returns the hash of only the variant portions of a given\n  ///         crosschain transaction\n  /// @param txData TransactionData to hash\n  function hashVariantTransactionData(TransactionData calldata txData) internal pure returns (bytes32) {\n    return keccak256(abi.encode(VariantTransactionData({\n      amount: txData.amount,\n      expiry: txData.expiry,\n      preparedBlockNumber: txData.preparedBlockNumber\n    })));\n  }\n}\n\n\n",
        "CodeNames": [
            "TransactionManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "fulfill() function in TransactionManager.sol",
                "Type": "Router liquidity on receiving chain can be double-dipped by the user",
                "Description": "If addFunds() has reverted earlier, toSend amount would already have been transferred to the receivingAddress. If execute() also fails, it is again transferred.",
                "Repair": "Remove the transferAsset() call from the second catch block for execute() function"
            },
            {
                "Location": "addLiquidity() function in TransactionManager.sol",
                "Type": "Anyone can arbitrarily add router liquidity",
                "Description": "Anyone can call this function on the router\u2019s behalf and arbitrarily move ERC20 tokens from router address to this contract.",
                "Repair": "Consider the use of msg.sender in addLiquidity() or evaluate this risk otherwise"
            },
            {
                "Location": "fulfill() function in TransactionManager.sol",
                "Type": "Approval is not reset if the call to IFulfillHelper fails",
                "Description": "In such case the approval is not reset, so a malicious callTo can pull these tokens later.",
                "Repair": "Place approval inside the try/catch block or reset approval if the call fails"
            },
            {
                "Location": "removeUserActiveBlocks() function in TransactionManager.sol",
                "Type": "activeTransactionBlocks are vulnerable to DDoS attacks",
                "Description": "A malicious actor may block any account (DDOS) by just calling prepare again and again with 0 amount acting as a router. This will push activeTransactionBlocks to the specified user until it is no longer possible to remove them from the array.",
                "Repair": "Introduce an upper limit for activeTransactionBlocks or optimize the algorithm using EnumerableMap"
            },
            {
                "Location": "TransactionManager.sol L514",
                "Type": "Locked Funds",
                "Description": "Expired transfers will lock user funds on the sending chain if the cancelling relayer is being paid in receivingAssetId on the sending chain instead of in sendingAssetID, and the receivingAssetId asset does not exist on the sending chain.",
                "Repair": "Change receivingAssetId to sendingAssetId in transferAsset() function"
            }
        ]
    }
]