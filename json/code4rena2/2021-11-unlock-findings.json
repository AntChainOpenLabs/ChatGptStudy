[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Function purchase in the codebase",
                "Type": "Handling of ERC20 tokens",
                "Description": "The current version of the codebase does not handle special cases of tokens, e.g. deflationary, rebasing, or those that return true/false on success.",
                "Repair": "Use SafeERC20 library to handle token transfers or consider checking the actual balances transferred"
            },
            {
                "Location": "UDT token distribution logic",
                "Type": "Arbitrage opportunity",
                "Description": "It is possible to purchase many keys across many locks for the UDT token that is distributed to the referrer and sell them on some other exchanges where the price of UDT is higher.",
                "Repair": "Use the average of multiple oracle sources so that the price of UDT tokens (from Unlock.sol's PoV) reacts faster. UDT tokens distributed based on the duration of key ownership."
            },
            {
                "Location": "uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10  18) / 100 / udtPrice;",
                "Type": "Arbitrary Token Minting",
                "Description": "Arbitrary tx.gasprices can rapidly inflate the tokensToDistribute. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.",
                "Repair": "Using an oracle service to determine the average gas price and ensuring it is within some normal bounds that has not been subjected to arbitrary value manipulation."
            },
            {
                "Location": "The refund is sent from the lock where the purchase funds were sent.",
                "Type": "Refund Vulnerability",
                "Description": "If the lock manager withdraws enough profits from the lock, the user would not be able to cancel his key and request refund.",
                "Repair": "Perhaps a sort of MasterChef-like shares system can be implemented in order to make sure the owner leaves enough funds in the lock to process refunds."
            },
            {
                "Location": "The current design/implementation of freeTrial allows users to get full refund before the freeTrial ends.",
                "Type": "Free Trial Vulnerability",
                "Description": "The attacker can steal from the protocol by transferring freeTrial time from multiple addresses to one address and adding up to expirationDuration and call refund to steal from the protocol.",
                "Repair": "Consider disabling cancelAndRefund() for users who transferred time to another user."
            },
            {
                "Location": "transferFrom",
                "Type": "Key Destruction",
                "Description": "If calling transferFrom with _from == _recipient, the key will get destroyed.",
                "Repair": "Add a require statement in the beginning of transferFrom: require(_from != _recipient, 'TRANSFER_TO_SELF');"
            },
            {
                "Location": "MixinPurchase:shareKey",
                "Type": "Key Generation",
                "Description": "The shareKey function allows a user to share some time with another user that doesn't already has/had a key and this generates a new key.",
                "Repair": "Rethink the whole shareKey thingy"
            },
            {
                "Location": "cancelAndRefund() and purchase()",
                "Type": "Infinite Free Trial",
                "Description": "The current design/implementation allows users who are refunded before to get another freeTrial. This can be exploited by malicious users to get an infinite free trial.",
                "Repair": "Consider adding a mapping(address = uint256) freeTrialEnds and make sure each address can only get 1 freeTrial."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './MixinRoles.sol';\nimport './MixinDisable.sol';\nimport './MixinKeys.sol';\nimport './MixinFunds.sol';\nimport './MixinLockCore.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\n\n/**\n * @title Mixin for the transfer-related functions needed to meet the ERC721\n * standard.\n * @author Nick Furfaro\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\n\ncontract MixinTransfer is\n  MixinRoles,\n  MixinFunds,\n  MixinLockCore,\n  MixinKeys\n{\n  using AddressUpgradeable for address;\n\n  event TransferFeeChanged(\n    uint transferFeeBasisPoints\n  );\n\n  // 0x150b7a02 == bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'))\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // The fee relative to keyPrice to charge when transfering a Key to another account\n  // (potentially on a 0x marketplace).\n  // This is calculated as `keyPrice * transferFeeBasisPoints / BASIS_POINTS_DEN`.\n  uint public transferFeeBasisPoints;\n\n  /**\n  * @notice Allows the key owner to safely share their key (parent key) by\n  * transferring a portion of the remaining time to a new key (child key).\n  * @param _to The recipient of the shared key\n  * @param _tokenId the key to share\n  * @param _timeShared The amount of time shared\n  */\n  function shareKey(\n    address _to,\n    uint _tokenId,\n    uint _timeShared\n  ) public\n    onlyIfAlive\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    require(transferFeeBasisPoints < BASIS_POINTS_DEN, 'KEY_TRANSFERS_DISABLED');\n    require(_to != address(0), 'INVALID_ADDRESS');\n    address keyOwner = _ownerOf[_tokenId];\n    require(getHasValidKey(keyOwner), 'KEY_NOT_VALID');\n    Key storage fromKey = keyByOwner[keyOwner];\n    Key storage toKey = keyByOwner[_to];\n    uint idTo = toKey.tokenId;\n    uint time;\n    // get the remaining time for the origin key\n    uint timeRemaining = fromKey.expirationTimestamp - block.timestamp;\n    // get the transfer fee based on amount of time wanted share\n    uint fee = getTransferFee(keyOwner, _timeShared);\n    uint timePlusFee = _timeShared + fee;\n\n    // ensure that we don't try to share too much\n    if(timePlusFee < timeRemaining) {\n      // now we can safely set the time\n      time = _timeShared;\n      // deduct time from parent key, including transfer fee\n      _timeMachine(_tokenId, timePlusFee, false);\n    } else {\n      // we have to recalculate the fee here\n      fee = getTransferFee(keyOwner, timeRemaining);\n      time = timeRemaining - fee;\n      fromKey.expirationTimestamp = block.timestamp; // Effectively expiring the key\n      emit ExpireKey(_tokenId);\n    }\n\n    if (idTo == 0) {\n      _assignNewTokenId(toKey);\n      idTo = toKey.tokenId;\n      _recordOwner(_to, idTo);\n      emit Transfer(\n        address(0), // This is a creation or time-sharing\n        _to,\n        idTo\n      );\n    } else if (toKey.expirationTimestamp <= block.timestamp) {\n      // reset the key Manager for expired keys\n      _setKeyManagerOf(idTo, address(0));\n    }\n\n    // add time to new key\n    _timeMachine(idTo, time, true);\n    // trigger event\n    emit Transfer(\n      keyOwner,\n      _to,\n      idTo\n    );\n\n    require(_checkOnERC721Received(keyOwner, _to, _tokenId, ''), 'NON_COMPLIANT_ERC721_RECEIVER');\n  }\n\n  function transferFrom(\n    address _from,\n    address _recipient,\n    uint _tokenId\n  )\n    public\n    onlyIfAlive\n    hasValidKey(_from)\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    require(ownerOf(_tokenId) == _from, 'TRANSFER_FROM: NOT_KEY_OWNER');\n    require(transferFeeBasisPoints < BASIS_POINTS_DEN, 'KEY_TRANSFERS_DISABLED');\n    require(_recipient != address(0), 'INVALID_ADDRESS');\n    uint fee = getTransferFee(_from, 0);\n\n    Key storage fromKey = keyByOwner[_from];\n    Key storage toKey = keyByOwner[_recipient];\n\n    uint previousExpiration = toKey.expirationTimestamp;\n    // subtract the fee from the senders key before the transfer\n    _timeMachine(_tokenId, fee, false);\n\n    if (toKey.tokenId == 0) {\n      toKey.tokenId = _tokenId;\n      _recordOwner(_recipient, _tokenId);\n      // Clear any previous approvals\n      _clearApproval(_tokenId);\n    }\n\n    if (previousExpiration <= block.timestamp) {\n      // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n      // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n      toKey.expirationTimestamp = fromKey.expirationTimestamp;\n      toKey.tokenId = _tokenId;\n\n      // Reset the key Manager to the key owner\n      _setKeyManagerOf(_tokenId, address(0));\n\n      _recordOwner(_recipient, _tokenId);\n    } else {\n      // The recipient has a non expired key. We just add them the corresponding remaining time\n      // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow\n      toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration - block.timestamp;\n    }\n\n    // Effectively expiring the key for the previous owner\n    fromKey.expirationTimestamp = block.timestamp;\n\n    // Set the tokenID to 0 for the previous owner to avoid duplicates\n    fromKey.tokenId = 0;\n\n    // trigger event\n    emit Transfer(\n      _from,\n      _recipient,\n      _tokenId\n    );\n  }\n\n  /**\n   * @notice An ERC-20 style transfer.\n   * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\n   * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\n   * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\n   */\n  function transfer(\n    address _to,\n    uint _value\n  ) public\n    returns (bool success)\n  {\n    uint maxTimeToSend = _value * expirationDuration;\n    Key storage fromKey = keyByOwner[msg.sender];\n    uint timeRemaining = fromKey.expirationTimestamp - block.timestamp;\n    if(maxTimeToSend < timeRemaining)\n    {\n      shareKey(_to, fromKey.tokenId, maxTimeToSend);\n    }\n    else\n    {\n      transferFrom(msg.sender, _to, fromKey.tokenId);\n    }\n\n    // Errors will cause a revert\n    return true;\n  }\n\n  /**\n  * @notice Transfers the ownership of an NFT from one address to another address\n  * @dev This works identically to the other function with an extra data parameter,\n  *  except this function just sets data to ''\n  * @param _from The current owner of the NFT\n  * @param _to The new owner\n  * @param _tokenId The NFT to transfer\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint _tokenId\n  )\n    public\n  {\n    safeTransferFrom(_from, _to, _tokenId, '');\n  }\n\n  /**\n  * @notice Transfers the ownership of an NFT from one address to another address.\n  * When transfer is complete, this functions\n  *  checks if `_to` is a smart contract (code size > 0). If so, it calls\n  *  `onERC721Received` on `_to` and throws if the return value is not\n  *  `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\n  * @param _from The current owner of the NFT\n  * @param _to The new owner\n  * @param _tokenId The NFT to transfer\n  * @param _data Additional data with no specified format, sent in call to `_to`\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint _tokenId,\n    bytes memory _data\n  )\n    public\n  {\n    transferFrom(_from, _to, _tokenId);\n    require(_checkOnERC721Received(_from, _to, _tokenId, _data), 'NON_COMPLIANT_ERC721_RECEIVER');\n\n  }\n\n  /**\n   * Allow the Lock owner to change the transfer fee.\n   */\n  function updateTransferFee(\n    uint _transferFeeBasisPoints\n  )\n    external\n    onlyLockManager\n  {\n    emit TransferFeeChanged(\n      _transferFeeBasisPoints\n    );\n    transferFeeBasisPoints = _transferFeeBasisPoints;\n  }\n\n  /**\n   * Determines how much of a fee a key owner would need to pay in order to\n   * transfer the key to another account.  This is pro-rated so the fee goes down\n   * overtime.\n   * @param _keyOwner The owner of the key check the transfer fee for.\n   */\n  function getTransferFee(\n    address _keyOwner,\n    uint _time\n  )\n    public view\n    returns (uint)\n  {\n    if(! getHasValidKey(_keyOwner)) {\n      return 0;\n    } else {\n      Key storage key = keyByOwner[_keyOwner];\n      uint timeToTransfer;\n      uint fee;\n      // Math: safeSub is not required since `hasValidKey` confirms timeToTransfer is positive\n      // this is for standard key transfers\n      if(_time == 0) {\n        timeToTransfer = key.expirationTimestamp - block.timestamp;\n      } else {\n        timeToTransfer = _time;\n      }\n      fee = timeToTransfer * transferFeeBasisPoints / BASIS_POINTS_DEN;\n      return fee;\n    }\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes4 retval = IERC721ReceiverUpgradeable(to).onERC721Received(\n      msg.sender, from, tokenId, _data);\n    return (retval == _ERC721_RECEIVED);\n  }\n\n}\n\n",
        "CodeNames": [
            "MixinTransfer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MixinTransfer.sol#transferFrom function",
                "Type": "Incorrect implementation of transferFrom function",
                "Description": "The key manager is not being reset in L131-136, allowing attackers to keep the role of key manager after the transfer, and transfer the key back or to another recipient.",
                "Repair": "Reset the key manager regardless of the status of the recipient's key"
            },
            {
                "Location": "MixinTransfer.shareKey function",
                "Type": "Inaccurate fees computation",
                "Description": "The computation of fees is inaccurate and can result in the receiver receiving less time than they are owed.",
                "Repair": "Change the first if branch condition to timePlusFee <= timeRemaining. In the else branch, compute the time without fee as time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)."
            },
            {
                "Location": "MixinTransfer.transferFrom function",
                "Type": "Approvals not cleared after key transfer",
                "Description": "The approvals are not always cleared after key transfer, allowing an attacker to claim back the token.",
                "Repair": "The _setKeyManagerOf function should not handle clearing approvals of single-token approvals (approved) as these are two separate approval types. The transferFrom function should always call _clearApproval in the (previousExpiration <= block.timestamp) case."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './MixinKeys.sol';\nimport './MixinLockCore.sol';\nimport './MixinRoles.sol';\nimport './MixinFunds.sol';\n\n\ncontract MixinRefunds is\n  MixinRoles,\n  MixinFunds,\n  MixinLockCore,\n  MixinKeys\n{\n  // CancelAndRefund will return funds based on time remaining minus this penalty.\n  // This is calculated as `proRatedRefund * refundPenaltyBasisPoints / BASIS_POINTS_DEN`.\n  uint public refundPenaltyBasisPoints;\n\n  uint public freeTrialLength;\n\n  event CancelKey(\n    uint indexed tokenId,\n    address indexed owner,\n    address indexed sendTo,\n    uint refund\n  );\n\n  event RefundPenaltyChanged(\n    uint freeTrialLength,\n    uint refundPenaltyBasisPoints\n  );\n\n  function _initializeMixinRefunds() internal\n  {\n    // default to 10%\n    refundPenaltyBasisPoints = 1000;\n  }\n\n  /**\n   * @dev Invoked by the lock owner to destroy the user's ket and perform a refund and cancellation\n   * of the key\n   */\n  function expireAndRefundFor(\n    address payable _keyOwner,\n    uint amount\n  ) external\n    onlyLockManager\n    hasValidKey(_keyOwner)\n  {\n    _cancelAndRefund(_keyOwner, amount);\n  }\n\n  /**\n   * @dev Destroys the key and sends a refund based on the amount of time remaining.\n   * @param _tokenId The id of the key to cancel.\n   */\n  function cancelAndRefund(uint _tokenId)\n    external\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    address payable keyOwner = payable(ownerOf(_tokenId));\n    uint refund = _getCancelAndRefundValue(keyOwner);\n\n    _cancelAndRefund(keyOwner, refund);\n  }\n\n  /**\n   * Allow the owner to change the refund penalty.\n   */\n  function updateRefundPenalty(\n    uint _freeTrialLength,\n    uint _refundPenaltyBasisPoints\n  ) external\n    onlyLockManager\n  {\n    emit RefundPenaltyChanged(\n      _freeTrialLength,\n      _refundPenaltyBasisPoints\n    );\n\n    freeTrialLength = _freeTrialLength;\n    refundPenaltyBasisPoints = _refundPenaltyBasisPoints;\n  }\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * a cancelAndRefund block.timestamp.\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\n   * than what the user reads from this call.\n   */\n  function getCancelAndRefundValueFor(\n    address _keyOwner\n  )\n    external view\n    returns (uint refund)\n  {\n    return _getCancelAndRefundValue(_keyOwner);\n  }\n\n  /**\n   * @dev cancels the key for the given keyOwner and sends the refund to the msg.sender.\n   */\n  function _cancelAndRefund(\n    address payable _keyOwner,\n    uint refund\n  ) internal\n  {\n    Key storage key = keyByOwner[_keyOwner];\n\n    emit CancelKey(key.tokenId, _keyOwner, msg.sender, refund);\n    // expirationTimestamp is a proxy for hasKey, setting this to `block.timestamp` instead\n    // of 0 so that we can still differentiate hasKey from hasValidKey.\n    key.expirationTimestamp = block.timestamp;\n\n    if (refund > 0) {\n      // Security: doing this last to avoid re-entrancy concerns\n      _transfer(tokenAddress, _keyOwner, refund);\n    }\n\n    // inform the hook if there is one registered\n    if(address(onKeyCancelHook) != address(0))\n    {\n      onKeyCancelHook.onKeyCancel(msg.sender, _keyOwner, refund);\n    }\n  }\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * a cancelAndRefund now.\n   * @param _keyOwner The owner of the key check the refund value for.\n   */\n  function _getCancelAndRefundValue(\n    address _keyOwner\n  )\n    private view\n    hasValidKey(_keyOwner)\n    returns (uint refund)\n  {\n    Key storage key = keyByOwner[_keyOwner];\n    // Math: safeSub is not required since `hasValidKey` confirms timeRemaining is positive\n    uint timeRemaining = key.expirationTimestamp - block.timestamp;\n    if(timeRemaining + freeTrialLength >= expirationDuration) {\n      refund = keyPrice;\n    } else {\n      refund = keyPrice * timeRemaining / expirationDuration;\n    }\n\n    // Apply the penalty if this is not a free trial\n    if(freeTrialLength == 0 || timeRemaining + freeTrialLength < expirationDuration)\n    {\n      uint penalty = keyPrice * refundPenaltyBasisPoints / BASIS_POINTS_DEN;\n      if (refund > penalty) {\n        refund -= penalty;\n      } else {\n        refund = 0;\n      }\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "MixinRefunds.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MixinRefunds contract",
                "Type": "Frontrunning vulnerability",
                "Description": "A malicious user is able to withdraw all payments that were paid to a lock owner if the owner increases the keyPrice.",
                "Repair": "Keep track of the price at which keys are purchased so that when you issue a refund, you use the original keyPrice to refund instead of the updated keyPrice"
            },
            {
                "Location": "MixinRefunds.sol#L144:#L152",
                "Type": "Refund mechanism vulnerability",
                "Description": "The refund mechanism calculates refund according to current key price, not price actually paid.",
                "Repair": "Save the amount the user paid, and refund according to that, or have a kind of a price snapshot/version mechanism"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n/**\n * @title The Unlock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * This smart contract has 3 main roles:\n *  1. Distribute discounts to discount token holders\n *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.\n *  3. Create & deploy Public Lock contracts.\n * In order to achieve these 3 elements, it keeps track of several things such as\n *  a. Deployed locks addresses and balances of discount tokens granted by each lock.\n *  b. The total network product (sum of all key sales, net of discounts)\n *  c. Total of discounts granted\n *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim\n * discounts and cannot be used/transferred for a given period)\n *  e. Growth rate of Network Product\n *  f. Growth rate of Discount tokens supply\n * The smart contract has an owner who only can perform the following\n *  - Upgrades\n *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most\n * 50% of GNP growth rate)\n * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and\n * in the wild.\n * The partial implementation includes the following features:\n *  a. Keeping track of deployed locks\n *  b. Keeping track of GNP\n */\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\nimport 'hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol';\nimport './utils/UnlockOwnable.sol';\nimport './interfaces/IPublicLock.sol';\nimport './interfaces/IMintableERC20.sol';\n\n/// @dev Must list the direct base contracts in the order from \u201cmost base-like\u201d to \u201cmost derived\u201d.\n/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization\ncontract Unlock is\n  Initializable,\n  UnlockOwnable\n{\n\n  /**\n   * The struct for a lock\n   * We use deployed to keep track of deployments.\n   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,\n   * which would be the same values when the lock is not set.\n   */\n  struct LockBalances\n  {\n    bool deployed;\n    uint totalSales; // This is in wei\n    uint yieldedDiscountTokens;\n  }\n\n  modifier onlyFromDeployedLock() {\n    require(locks[msg.sender].deployed, 'ONLY_LOCKS');\n    _;\n  }\n\n  uint public grossNetworkProduct;\n\n  uint public totalDiscountGranted;\n\n  // We keep track of deployed locks to ensure that callers are all deployed locks.\n  mapping (address => LockBalances) public locks;\n\n  // global base token URI\n  // Used by locks where the owner has not set a custom base URI.\n  string public globalBaseTokenURI;\n\n  // global base token symbol\n  // Used by locks where the owner has not set a custom symbol\n  string public globalTokenSymbol;\n\n  // The address of the latest public lock template, used by default when `createLock` is called\n  address public publicLockAddress;\n\n  // Map token address to oracle contract address if the token is supported\n  // Used for GDP calculations\n  mapping (address => IUniswapOracle) public uniswapOracles;\n\n  // The WETH token address, used for value calculations\n  address public weth;\n\n  // The UDT token address, used to mint tokens on referral\n  address public udt;\n\n  // The approx amount of gas required to purchase a key\n  uint public estimatedGasForPurchase;\n\n  // Blockchain ID the network id on which this version of Unlock is operating\n  uint public chainId;\n\n  // store proxy admin\n  address public proxyAdminAddress;\n  ProxyAdmin private proxyAdmin;\n\n  // publicLock templates\n  mapping(address => uint16) private _publicLockVersions;\n  mapping(uint16 => address) private _publicLockImpls;\n  uint16 public publicLockLatestVersion;\n\n  // Events\n  event NewLock(\n    address indexed lockOwner,\n    address indexed newLockAddress\n  );\n\n  event LockUpgraded(\n    address lockAddress,\n    uint16 version\n  );\n\n  event ConfigUnlock(\n    address udt,\n    address weth,\n    uint estimatedGasForPurchase,\n    string globalTokenSymbol,\n    string globalTokenURI,\n    uint chainId\n  );\n\n  event SetLockTemplate(\n    address publicLockAddress\n  );\n\n  event ResetTrackedValue(\n    uint grossNetworkProduct,\n    uint totalDiscountGranted\n  );\n\n  event UnlockTemplateAdded(\n    address indexed impl,\n    uint16 indexed version\n  );\n\n  // Use initialize instead of a constructor to support proxies (for upgradeability via OZ).\n  function initialize(\n    address _unlockOwner\n  )\n    public\n    initializer()\n  {\n    // We must manually initialize Ownable\n    UnlockOwnable.__initializeOwnable(_unlockOwner);\n    // add a proxy admin on deployment\n    _deployProxyAdmin();\n  }\n\n  function initializeProxyAdmin() public {\n    require(proxyAdminAddress == address(0), \"ProxyAdmin already deployed\");\n    _deployProxyAdmin();\n  }\n\n  /**\n  * @dev Deploy the ProxyAdmin contract that will manage lock templates upgrades\n  * This deploys an instance of ProxyAdmin used by PublicLock transparent proxies.\n  */\n  function _deployProxyAdmin() private returns(address) {\n    proxyAdmin = new ProxyAdmin();\n    proxyAdminAddress = address(proxyAdmin);\n    return address(proxyAdmin);\n  }\n\n  /**\n  * @dev Helper to get the version number of a template from his address\n  */\n  function publicLockVersions(address _impl) external view returns(uint16) {\n    return _publicLockVersions[_impl];\n  }\n\n  /**\n  * @dev Helper to get the address of a template based on its version number\n  */\n  function publicLockImpls(uint16 _version) external view returns(address) {\n    return _publicLockImpls[_version];\n  }\n\n  /**\n  * @dev Registers a new PublicLock template immplementation\n  * The template is identified by a version number\n  * Once registered, the template can be used to upgrade an existing Lock\n  */\n  function addLockTemplate(address impl, uint16 version) public onlyOwner {\n    _publicLockVersions[impl] = version;\n    _publicLockImpls[version] = impl;\n    if (publicLockLatestVersion < version) publicLockLatestVersion = version;\n\n    emit UnlockTemplateAdded(impl, version);\n  }\n\n  /**\n  * @notice Create lock\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\n  * @param data bytes containing the call to initialize the lock template\n  * @dev this call is passed as encoded function - for instance:\n  *  bytes memory data = abi.encodeWithSignature(\n  *    'initialize(address,uint256,address,uint256,uint256,string)',\n  *    msg.sender,\n  *    _expirationDuration,\n  *    _tokenAddress,\n  *    _keyPrice,\n  *    _maxNumberOfKeys,\n  *    _lockName\n  *  );\n  * @return address of the create lock\n  */\n  function createLock(\n    bytes memory data\n  ) public returns(address)\n  {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');\n\n    // deploy a proxy pointing to impl\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(publicLockAddress, proxyAdminAddress, data);\n    address payable newLock = payable(address(proxy));\n\n    // assign the new Lock\n    locks[newLock] = LockBalances({\n      deployed: true, totalSales: 0, yieldedDiscountTokens: 0\n    });\n\n    // trigger event\n    emit NewLock(msg.sender, newLock);\n    return newLock;\n  }\n\n  /**\n   * @dev Upgrade a Lock template implementation\n   * @param lockAddress the address of the lock to be upgraded\n   * @param version the version number of the template\n   */\n  function upgradeLock(address payable lockAddress, uint16 version) public returns(address) {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n\n    // check perms\n    require(_isLockManager(lockAddress, msg.sender) == true, \"caller is not a manager of this lock\");\n\n    // check version\n    IPublicLock lock = IPublicLock(lockAddress);\n    uint16 currentVersion = lock.publicLockVersion();\n    require( version == currentVersion + 1, 'version error: only +1 increments are allowed');\n\n    // make our upgrade\n    address impl = _publicLockImpls[version];\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(lockAddress);\n    proxyAdmin.upgrade(proxy, impl);\n\n    emit LockUpgraded(lockAddress, version);\n    return lockAddress;\n  }\n\n  function _isLockManager(address lockAddress, address _sender) private view returns(bool isManager) {\n    IPublicLock lock = IPublicLock(lockAddress);\n    return lock.isLockManager(_sender);\n  }\n\n  /**\n   * This function returns the discount available for a user, when purchasing a\n   * a key from a lock.\n   * This does not modify the state. It returns both the discount and the number of tokens\n   * consumed to grant that discount.\n   * TODO: actually implement this.\n   */\n  function computeAvailableDiscountFor(\n    address /* _purchaser */,\n    uint /* _keyPrice */\n  )\n    public\n    pure\n    returns (uint discount, uint tokens)\n  {\n    // TODO: implement me\n    return (0, 0);\n  }\n\n  /**\n   * This function keeps track of the added GDP, as well as grants of discount tokens\n   * to the referrer, if applicable.\n   * The number of discount tokens granted is based on the value of the referal,\n   * the current growth rate and the lock's discount token distribution rate\n   * This function is invoked by a previously deployed lock only.\n   * TODO: actually implement\n   */\n  function recordKeyPurchase(\n    uint _value,\n    address _referrer\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    if(_value > 0) {\n      uint valueInETH;\n      address tokenAddress = IPublicLock(msg.sender).tokenAddress();\n      if(tokenAddress != address(0) && tokenAddress != weth) {\n        // If priced in an ERC-20 token, find the supported uniswap oracle\n        IUniswapOracle oracle = uniswapOracles[tokenAddress];\n        if(address(oracle) != address(0)) {\n          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);\n        }\n      }\n      else {\n        // If priced in ETH (or value is 0), no conversion is required\n        valueInETH = _value;\n      }\n\n      grossNetworkProduct = grossNetworkProduct + valueInETH;\n      // If GNP does not overflow, the lock totalSales should be safe\n      locks[msg.sender].totalSales += valueInETH;\n\n      // Mint UDT\n      if(_referrer != address(0))\n      {\n        IUniswapOracle udtOracle = uniswapOracles[udt];\n        if(address(udtOracle) != address(0))\n        {\n          // Get the value of 1 UDT (w/ 18 decimals) in ETH\n          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);\n\n          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut\n          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n\n          // or tokensToDistribute is capped by network GDP growth\n          uint maxTokens = 0;\n          if (chainId > 1)\n          {\n            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5\n            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));\n            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n          } else {\n            // Mainnet: we mint new token using log curve\n            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;\n          }\n\n          // cap to GDP growth!\n          if(tokensToDistribute > maxTokens)\n          {\n            tokensToDistribute = maxTokens;\n          }\n\n          if(tokensToDistribute > 0)\n          {\n            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer\n            uint devReward = tokensToDistribute * 20 / 100;\n            if (chainId > 1)\n            {\n              uint balance = IMintableERC20(udt).balanceOf(address(this));\n              if (balance > tokensToDistribute) {\n                // Only distribute if there are enough tokens\n                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);\n                IMintableERC20(udt).transfer(owner(), devReward);\n              }\n            } else {\n              // No distribnution\n              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);\n              IMintableERC20(udt).mint(owner(), devReward);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * This function will keep track of consumed discounts by a given user.\n   * It will also grant discount tokens to the creator who is granting the discount based on the\n   * amount of discount and compensation rate.\n   * This function is invoked by a previously deployed lock only.\n   */\n  function recordConsumedDiscount(\n    uint _discount,\n    uint /* _tokens */\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    // TODO: implement me\n    totalDiscountGranted += _discount;\n    return;\n  }\n\n  // The version number of the current Unlock implementation on this network\n  function unlockVersion(\n  ) external pure\n    returns (uint16)\n  {\n    return 10;\n  }\n\n  /**\n   * @notice Allows the owner to update configuration variables\n   */\n  function configUnlock(\n    address _udt,\n    address _weth,\n    uint _estimatedGasForPurchase,\n    string calldata _symbol,\n    string calldata _URI,\n    uint _chainId\n  ) external\n    onlyOwner\n  {\n    udt = _udt;\n    weth = _weth;\n    estimatedGasForPurchase = _estimatedGasForPurchase;\n\n    globalTokenSymbol = _symbol;\n    globalBaseTokenURI = _URI;\n\n    chainId = _chainId;\n\n    emit ConfigUnlock(_udt, _weth, _estimatedGasForPurchase, _symbol, _URI, _chainId);\n  }\n\n  /**\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\n   * @dev This will initialize the template and revokeOwnership.\n   */\n  function setLockTemplate(\n    address _publicLockAddress\n  ) external\n    onlyOwner\n  {\n    // First claim the template so that no-one else could\n    // this will revert if the template was already initialized.\n    IPublicLock(_publicLockAddress).initialize(\n      address(this), 0, address(0), 0, 0, ''\n    );\n    IPublicLock(_publicLockAddress).renounceLockManager();\n\n    publicLockAddress = _publicLockAddress;\n\n    emit SetLockTemplate(_publicLockAddress);\n  }\n\n  /**\n   * @notice allows the owner to set the oracle address to use for value conversions\n   * setting the _oracleAddress to address(0) removes support for the token\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\n   */\n  function setOracle(\n    address _tokenAddress,\n    address _oracleAddress\n  ) external\n    onlyOwner\n  {\n    uniswapOracles[_tokenAddress] = IUniswapOracle(_oracleAddress);\n    if(_oracleAddress != address(0)) {\n      IUniswapOracle(_oracleAddress).update(_tokenAddress, weth);\n    }\n  }\n\n  // Allows the owner to change the value tracking variables as needed.\n  function resetTrackedValue(\n    uint _grossNetworkProduct,\n    uint _totalDiscountGranted\n  ) external\n    onlyOwner\n  {\n    grossNetworkProduct = _grossNetworkProduct;\n    totalDiscountGranted = _totalDiscountGranted;\n\n    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);\n  }\n\n  /**\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalBaseTokenURI()\n    external\n    view\n    returns (string memory)\n  {\n    return globalBaseTokenURI;\n  }\n\n  /**\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalTokenSymbol()\n    external\n    view\n    returns (string memory)\n  {\n    return globalTokenSymbol;\n  }\n}\n\n\n",
        "CodeNames": [
            "Unlock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Unlock.sol#recordKeyPurchase()",
                "Type": "Potential economic attack",
                "Description": "The function Unlock.sol#recordKeyPurchase() will send estimatedGasForPurchase * tx.gasprice worth of UDT to the referrer. There are multiple potential economic attack vectors to exploit this.",
                "Repair": "Consider setting a global daily upper limit of total UDT grants to referrers, plus, an upper limit for UDT minted per purchase."
            },
            {
                "Location": "Unlock.recordKeyPurchase function",
                "Type": "Missing scaling factor",
                "Description": "The maxTokens curve might not be computed as intended and lead to being able to receive more token rewards than intended.",
                "Repair": "Consider adding a scaling factor to this term and divide by it at the end of the computation again."
            },
            {
                "Location": "Unlock.recordKeyPurchase",
                "Type": "Token Manipulation",
                "Description": "Tokens can be minted by purchasing a key with themself as the referrer at a high transaction gas price.",
                "Repair": "Consider declaring an *average gas price* storage variable that is set by a trusted party and use this one instead."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport './interfaces/IPublicLock.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol';\nimport './mixins/MixinDisable.sol';\nimport './mixins/MixinERC721Enumerable.sol';\nimport './mixins/MixinFunds.sol';\nimport './mixins/MixinGrantKeys.sol';\nimport './mixins/MixinKeys.sol';\nimport './mixins/MixinLockCore.sol';\nimport './mixins/MixinLockMetadata.sol';\nimport './mixins/MixinPurchase.sol';\nimport './mixins/MixinRefunds.sol';\nimport './mixins/MixinTransfer.sol';\nimport './mixins/MixinRoles.sol';\n\n\n/**\n * @title The Lock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * @dev ERC165 allows our contract to be queried to determine whether it implements a given interface.\n * Every ERC-721 compliant contract must implement the ERC165 interface.\n * https://eips.ethereum.org/EIPS/eip-721\n */\ncontract PublicLock is\n  Initializable,\n  ERC165StorageUpgradeable,\n  MixinRoles,\n  MixinFunds,\n  MixinDisable,\n  MixinLockCore,\n  MixinKeys,\n  MixinLockMetadata,\n  MixinERC721Enumerable,\n  MixinGrantKeys,\n  MixinPurchase,\n  MixinTransfer,\n  MixinRefunds\n{\n  function initialize(\n    address payable _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) public\n    initializer()\n  {\n    MixinFunds._initializeMixinFunds(_tokenAddress);\n    MixinDisable._initializeMixinDisable();\n    MixinLockCore._initializeMixinLockCore(_lockCreator, _expirationDuration, _keyPrice, _maxNumberOfKeys);\n    MixinLockMetadata._initializeMixinLockMetadata(_lockName);\n    MixinERC721Enumerable._initializeMixinERC721Enumerable();\n    MixinRefunds._initializeMixinRefunds();\n    MixinRoles._initializeMixinRoles(_lockCreator);\n    // registering the interface for erc721 with ERC165.sol using\n    // the ID specified in the standard: https://eips.ethereum.org/EIPS/eip-721\n    _registerInterface(0x80ac58cd);\n  }\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  receive() external payable {}\n  \n  \n  // TODO: what should be done here?\n  fallback() external payable {}\n\n  /**\n   Overrides\n  */\n  function supportsInterface(bytes4 interfaceId) \n    public \n    view \n    virtual \n    override(\n      MixinERC721Enumerable,\n      MixinLockMetadata,\n      AccessControlUpgradeable, \n      ERC165StorageUpgradeable\n    ) \n    returns (bool) \n    {\n    return super.supportsInterface(interfaceId);\n  }\n\n}\n\n\n",
        "CodeNames": [
            "PublicLock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PublicLock.initialize()",
                "Type": "Insufficient Access Control",
                "Description": "A malicious user could front run the setLocktemplate() forcing the deployer of PublicLock's implementation to redeploy.",
                "Repair": "Implement valid access control on the PublicLock contract to ensure only the relevant deployer can initialize()."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './MixinLockCore.sol';\n\n\n/**\n * @title Mixin for managing `Key` data, as well as the * Approval related functions needed to meet the ERC721\n * standard.\n * @author HardlyDifficult\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\ncontract MixinKeys is\n  MixinLockCore\n{\n  // The struct for a key\n  struct Key {\n    uint tokenId;\n    uint expirationTimestamp;\n  }\n\n  // Emitted when the Lock owner expires a user's Key\n  event ExpireKey(uint indexed tokenId);\n\n  // Emitted when the expiration of a key is modified\n  event ExpirationChanged(\n    uint indexed _tokenId,\n    uint _amount,\n    bool _timeAdded\n  );\n\n  event KeyManagerChanged(uint indexed _tokenId, address indexed _newManager);\n\n\n  // Keys\n  // Each owner can have at most exactly one key\n  // TODO: could we use public here? (this could be confusing though because it getter will\n  // return 0 values when missing a key)\n  mapping (address => Key) internal keyByOwner;\n\n  // Each tokenId can have at most exactly one owner at a time.\n  // Returns 0 if the token does not exist\n  // TODO: once we decouple tokenId from owner address (incl in js), then we can consider\n  // merging this with totalSupply into an array instead.\n  mapping (uint => address) internal _ownerOf;\n\n  // Addresses of owners are also stored in an array.\n  // Addresses are never removed by design to avoid abuses around referals\n  address[] public owners;\n\n  // A given key has both an owner and a manager.\n  // If keyManager == address(0) then the key owner is also the manager\n  // Each key can have at most 1 keyManager.\n  mapping (uint => address) public keyManagerOf;\n\n    // Keeping track of approved transfers\n  // This is a mapping of addresses which have approved\n  // the transfer of a key to another address where their key can be transferred\n  // Note: the approver may actually NOT have a key... and there can only\n  // be a single approved address\n  mapping (uint => address) private approved;\n\n    // Keeping track of approved operators for a given Key manager.\n  // This approves a given operator for all keys managed by the calling \"keyManager\"\n  // The caller may not currently be the keyManager for ANY keys.\n  // These approvals are never reset/revoked automatically, unlike \"approved\",\n  // which is reset on transfer.\n  mapping (address => mapping (address => bool)) private managerToOperatorApproved;\n\n    // Ensure that the caller is the keyManager of the key\n  // or that the caller has been approved\n  // for ownership of that key\n  modifier onlyKeyManagerOrApproved(\n    uint _tokenId\n  )\n  {\n    require(\n      _isKeyManager(_tokenId, msg.sender) ||\n      _isApproved(_tokenId, msg.sender) ||\n      isApprovedForAll(_ownerOf[_tokenId], msg.sender),\n      'ONLY_KEY_MANAGER_OR_APPROVED'\n    );\n    _;\n  }\n\n  // Ensures that an owner owns or has owned a key in the past\n  modifier ownsOrHasOwnedKey(\n    address _keyOwner\n  ) {\n    require(\n      keyByOwner[_keyOwner].expirationTimestamp > 0, 'HAS_NEVER_OWNED_KEY'\n    );\n    _;\n  }\n\n  // Ensures that an owner has a valid key\n  modifier hasValidKey(\n    address _user\n  ) {\n    require(\n      getHasValidKey(_user), 'KEY_NOT_VALID'\n    );\n    _;\n  }\n\n  // Ensures that a key has an owner\n  modifier isKey(\n    uint _tokenId\n  ) {\n    require(\n      _ownerOf[_tokenId] != address(0), 'NO_SUCH_KEY'\n    );\n    _;\n  }\n\n  // Ensure that the caller owns the key\n  modifier onlyKeyOwner(\n    uint _tokenId\n  ) {\n    require(\n      ownerOf(_tokenId) == msg.sender, 'ONLY_KEY_OWNER'\n    );\n    _;\n  }\n\n  /**\n   * In the specific case of a Lock, each owner can own only at most 1 key.\n   * @return The number of NFTs owned by `_keyOwner`, either 0 or 1.\n  */\n  function balanceOf(\n    address _keyOwner\n  )\n    public\n    view\n    returns (uint)\n  {\n    require(_keyOwner != address(0), 'INVALID_ADDRESS');\n    return getHasValidKey(_keyOwner) ? 1 : 0;\n  }\n\n  /**\n   * Checks if the user has a non-expired key.\n   */\n  function getHasValidKey(\n    address _keyOwner\n  )\n    public\n    view\n    returns (bool)\n  {\n    return keyByOwner[_keyOwner].expirationTimestamp > block.timestamp;\n  }\n\n  /**\n   * @notice Find the tokenId for a given user\n   * @return The tokenId of the NFT, else returns 0\n  */\n  function getTokenIdFor(\n    address _account\n  ) public view\n    returns (uint)\n  {\n    return keyByOwner[_account].tokenId;\n  }\n\n  /**\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\n  * @param _keyOwner address of the user for whom we search the key\n  * @dev Returns 0 if the owner has never owned a key for this lock\n  */\n  function keyExpirationTimestampFor(\n    address _keyOwner\n  ) public view\n    returns (uint)\n  {\n    return keyByOwner[_keyOwner].expirationTimestamp;\n  }\n\n  /**\n   * Public function which returns the total number of unique owners (both expired\n   * and valid).  This may be larger than totalSupply.\n   */\n  function numberOfOwners()\n    public\n    view\n    returns (uint)\n  {\n    return owners.length;\n  }\n\n  // Returns the owner of a given tokenId\n  function ownerOf(\n    uint _tokenId\n  ) public view\n    returns(address)\n  {\n    return _ownerOf[_tokenId];\n  }\n\n  /**\n  * @notice Public function for updating transfer and cancel rights for a given key\n  * @param _tokenId The id of the key to assign rights for\n  * @param _keyManager The address with the manager's rights for the given key.\n  * Setting _keyManager to address(0) means the keyOwner is also the keyManager\n   */\n  function setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) public\n    isKey(_tokenId)\n  {\n    require(\n      _isKeyManager(_tokenId, msg.sender) ||\n      isLockManager(msg.sender),\n      'UNAUTHORIZED_KEY_MANAGER_UPDATE'\n    );\n    _setKeyManagerOf(_tokenId, _keyManager);\n  }\n\n  function _setKeyManagerOf(\n    uint _tokenId,\n    address _keyManager\n  ) internal\n  {\n    if(keyManagerOf[_tokenId] != _keyManager) {\n      keyManagerOf[_tokenId] = _keyManager;\n      _clearApproval(_tokenId);\n      emit KeyManagerChanged(_tokenId, address(0));\n    }\n  }\n\n    /**\n   * This approves _approved to get ownership of _tokenId.\n   * Note: that since this is used for both purchase and transfer approvals\n   * the approved token may not exist.\n   */\n  function approve(\n    address _approved,\n    uint _tokenId\n  )\n    public\n    onlyIfAlive\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    require(msg.sender != _approved, 'APPROVE_SELF');\n\n    approved[_tokenId] = _approved;\n    emit Approval(_ownerOf[_tokenId], _approved, _tokenId);\n  }\n\n    /**\n   * @notice Get the approved address for a single NFT\n   * @dev Throws if `_tokenId` is not a valid NFT.\n   * @param _tokenId The NFT to find the approved address for\n   * @return The approved address for this NFT, or the zero address if there is none\n   */\n  function getApproved(\n    uint _tokenId\n  ) public view\n    isKey(_tokenId)\n    returns (address)\n  {\n    address approvedRecipient = approved[_tokenId];\n    return approvedRecipient;\n  }\n\n    /**\n   * @dev Tells whether an operator is approved by a given keyManager\n   * @param _owner owner address which you want to query the approval of\n   * @param _operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address _owner,\n    address _operator\n  ) public view\n    returns (bool)\n  {\n    uint tokenId = keyByOwner[_owner].tokenId;\n    address keyManager = keyManagerOf[tokenId];\n    if(keyManager == address(0)) {\n      return managerToOperatorApproved[_owner][_operator];\n    } else {\n      return managerToOperatorApproved[keyManager][_operator];\n    }\n  }\n\n  /**\n  * Returns true if _keyManager is the manager of the key\n  * identified by _tokenId\n   */\n  function _isKeyManager(\n    uint _tokenId,\n    address _keyManager\n  ) internal view\n    returns (bool)\n  {\n    if(keyManagerOf[_tokenId] == _keyManager ||\n      (keyManagerOf[_tokenId] == address(0) && ownerOf(_tokenId) == _keyManager)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Assigns the key a new tokenId (from totalSupply) if it does not already have\n   * one assigned.\n   */\n  function _assignNewTokenId(\n    Key storage _key\n  ) internal\n  {\n    if (_key.tokenId == 0) {\n      // This is a brand new owner\n      // We increment the tokenId counter\n      _totalSupply++;\n      // we assign the incremented `_totalSupply` as the tokenId for the new key\n      _key.tokenId = _totalSupply;\n    }\n  }\n\n  /**\n   * Records the owner of a given tokenId\n   */\n  function _recordOwner(\n    address _keyOwner,\n    uint _tokenId\n  ) internal\n  {\n    if (ownerOf(_tokenId) != _keyOwner) {\n      // TODO: this may include duplicate entries\n      owners.push(_keyOwner);\n      // We register the owner of the tokenID\n      _ownerOf[_tokenId] = _keyOwner;\n    }\n  }\n\n  /**\n  * @notice Modify the expirationTimestamp of a key\n  * by a given amount.\n  * @param _tokenId The ID of the key to modify.\n  * @param _deltaT The amount of time in seconds by which\n  * to modify the keys expirationTimestamp\n  * @param _addTime Choose whether to increase or decrease\n  * expirationTimestamp (false == decrease, true == increase)\n  * @dev Throws if owner does not have a valid key.\n  */\n  function _timeMachine(\n    uint _tokenId,\n    uint256 _deltaT,\n    bool _addTime\n  ) internal\n  {\n    address tokenOwner = ownerOf(_tokenId);\n    require(tokenOwner != address(0), 'NON_EXISTENT_KEY');\n    Key storage key = keyByOwner[tokenOwner];\n    uint formerTimestamp = key.expirationTimestamp;\n    bool validKey = getHasValidKey(tokenOwner);\n    if(_addTime) {\n      if(validKey) {\n        key.expirationTimestamp = formerTimestamp + _deltaT;\n      } else {\n        key.expirationTimestamp = block.timestamp + _deltaT;\n      }\n    } else {\n      key.expirationTimestamp = formerTimestamp - _deltaT;\n    }\n    emit ExpirationChanged(_tokenId, _deltaT, _addTime);\n  }\n\n    /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param _to operator address to set the approval\n   * @param _approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(\n    address _to,\n    bool _approved\n  ) public\n    onlyIfAlive\n  {\n    require(_to != msg.sender, 'APPROVE_SELF');\n    managerToOperatorApproved[msg.sender][_to] = _approved;\n    emit ApprovalForAll(msg.sender, _to, _approved);\n  }\n\n    /**\n   * @dev Checks if the given user is approved to transfer the tokenId.\n   */\n  function _isApproved(\n    uint _tokenId,\n    address _user\n  ) internal view\n    returns (bool)\n  {\n    return approved[_tokenId] == _user;\n  }\n\n    /**\n   * @dev Function to clear current approval of a given token ID\n   * @param _tokenId uint256 ID of the token to be transferred\n   */\n  function _clearApproval(\n    uint256 _tokenId\n  ) internal\n  {\n    if (approved[_tokenId] != address(0)) {\n      approved[_tokenId] = address(0);\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "MixinKeys.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MixinKeys._assignNewTokenId function",
                "Type": "Missing maxNumberOfKeys checks",
                "Description": "More keys can be minted than intended as maxNumberOfKeys is not checked in shareKey and grantKey.",
                "Repair": "Add a check to _assignNewTokenId that will revert if we need to record a new key and maxNumberOfKeys has been reached."
            }
        ]
    }
]