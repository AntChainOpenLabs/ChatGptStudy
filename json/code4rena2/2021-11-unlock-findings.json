[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Function purchase in the codebase",
                "Type": "Handling of ERC20 tokens",
                "Description": "The current version of the codebase does not handle special cases of tokens, e.g. deflationary, rebasing, or those that return true/false on success.",
                "Repair": "Use SafeERC20 library to handle token transfers or consider checking the actual balances transferred"
            },
            {
                "Location": "UnlockProtocol",
                "Type": "Value extraction by miners",
                "Description": "MEV miners can mint larger than expected UDT total supply by submitting their own transactions or cooperating with a malicious user, reimbursing a portion (or all) of the tx.gasprice used. This can lead to value extractions outside of the pool.",
                "Repair": "Use an oracle service to determine the average gas price and ensure it is within some normal bounds that has not been subjected to arbitrary value manipulation."
            },
            {
                "Location": "freeTrial",
                "Type": "Wrong design/implementation",
                "Description": "The current design/implementation of freeTrial allows users to get full refund before the freeTrial ends. Plus, a user can transfer partial of their time to another user using shareKey. This makes it possible for the attacker to steal from the protocol by transferring freeTrial time from multiple addresses to one address and adding up to expirationDuration and call refund to steal from the protocol.",
                "Repair": "Disable cancelAndRefund() for users who transferred time to another user"
            },
            {
                "Location": "transferFrom",
                "Type": "Key transfer issue",
                "Description": "If calling transferFrom with _from == _recipient, the key will get destroyed (meaning the key will be set as expired and set the owner's key to be 0). A key manager or approved might accidentally destroy user's token.",
                "Repair": "Add a require statement in the beginning of transferFrom: require(_from != _recipient, 'TRANSFER_TO_SELF');"
            },
            {
                "Location": "purchase(), cancelAndRefund()",
                "Type": "Infinite free trial",
                "Description": "Malicious user can get infinite free trial by repeatedly refund and repurchase right before the freeTrial ends.",
                "Repair": "Add a mapping(address = uint256) freeTrialEnds and make sure each address can only get 1 freeTrial."
            },
            {
                "Location": "shareKey(), grantKey(), _assignNewTokenId()",
                "Type": "Missing maxNumberOfKeys checks",
                "Description": "More keys can be minted than maxNumberOfKeys since shareKey and grantKey do not check if the lock is sold out.",
                "Repair": "Add a check to _assignNewTokenId that will revert if we need to record a new key and maxNumberOfKeys has been reached."
            },
            {
                "Location": "transferFrom(), _setKeyManagerOf()",
                "Type": "Approvals not cleared after key transfer",
                "Description": "It's possible to sell someone a key and then claim it back as the approvals are not always cleared.",
                "Repair": "The _setKeyManagerOf function should not handle clearing approvals of single-token approvals (approved) as these are two separate approval types. The transferFrom function should always call _clearApproval in the (previousExpiration <= block.timestamp) case."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './MixinRoles.sol';\nimport './MixinDisable.sol';\nimport './MixinKeys.sol';\nimport './MixinFunds.sol';\nimport './MixinLockCore.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\n\n/**\n * @title Mixin for the transfer-related functions needed to meet the ERC721\n * standard.\n * @author Nick Furfaro\n * @dev `Mixins` are a design pattern seen in the 0x contracts.  It simply\n * separates logically groupings of code to ease readability.\n */\n\ncontract MixinTransfer is\n  MixinRoles,\n  MixinFunds,\n  MixinLockCore,\n  MixinKeys\n{\n  using AddressUpgradeable for address;\n\n  event TransferFeeChanged(\n    uint transferFeeBasisPoints\n  );\n\n  // 0x150b7a02 == bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'))\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // The fee relative to keyPrice to charge when transfering a Key to another account\n  // (potentially on a 0x marketplace).\n  // This is calculated as `keyPrice * transferFeeBasisPoints / BASIS_POINTS_DEN`.\n  uint public transferFeeBasisPoints;\n\n  /**\n  * @notice Allows the key owner to safely share their key (parent key) by\n  * transferring a portion of the remaining time to a new key (child key).\n  * @param _to The recipient of the shared key\n  * @param _tokenId the key to share\n  * @param _timeShared The amount of time shared\n  */\n  function shareKey(\n    address _to,\n    uint _tokenId,\n    uint _timeShared\n  ) public\n    onlyIfAlive\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    require(transferFeeBasisPoints < BASIS_POINTS_DEN, 'KEY_TRANSFERS_DISABLED');\n    require(_to != address(0), 'INVALID_ADDRESS');\n    address keyOwner = _ownerOf[_tokenId];\n    require(getHasValidKey(keyOwner), 'KEY_NOT_VALID');\n    Key storage fromKey = keyByOwner[keyOwner];\n    Key storage toKey = keyByOwner[_to];\n    uint idTo = toKey.tokenId;\n    uint time;\n    // get the remaining time for the origin key\n    uint timeRemaining = fromKey.expirationTimestamp - block.timestamp;\n    // get the transfer fee based on amount of time wanted share\n    uint fee = getTransferFee(keyOwner, _timeShared);\n    uint timePlusFee = _timeShared + fee;\n\n    // ensure that we don't try to share too much\n    if(timePlusFee < timeRemaining) {\n      // now we can safely set the time\n      time = _timeShared;\n      // deduct time from parent key, including transfer fee\n      _timeMachine(_tokenId, timePlusFee, false);\n    } else {\n      // we have to recalculate the fee here\n      fee = getTransferFee(keyOwner, timeRemaining);\n      time = timeRemaining - fee;\n      fromKey.expirationTimestamp = block.timestamp; // Effectively expiring the key\n      emit ExpireKey(_tokenId);\n    }\n\n    if (idTo == 0) {\n      _assignNewTokenId(toKey);\n      idTo = toKey.tokenId;\n      _recordOwner(_to, idTo);\n      emit Transfer(\n        address(0), // This is a creation or time-sharing\n        _to,\n        idTo\n      );\n    } else if (toKey.expirationTimestamp <= block.timestamp) {\n      // reset the key Manager for expired keys\n      _setKeyManagerOf(idTo, address(0));\n    }\n\n    // add time to new key\n    _timeMachine(idTo, time, true);\n    // trigger event\n    emit Transfer(\n      keyOwner,\n      _to,\n      idTo\n    );\n\n    require(_checkOnERC721Received(keyOwner, _to, _tokenId, ''), 'NON_COMPLIANT_ERC721_RECEIVER');\n  }\n\n  function transferFrom(\n    address _from,\n    address _recipient,\n    uint _tokenId\n  )\n    public\n    onlyIfAlive\n    hasValidKey(_from)\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    require(ownerOf(_tokenId) == _from, 'TRANSFER_FROM: NOT_KEY_OWNER');\n    require(transferFeeBasisPoints < BASIS_POINTS_DEN, 'KEY_TRANSFERS_DISABLED');\n    require(_recipient != address(0), 'INVALID_ADDRESS');\n    uint fee = getTransferFee(_from, 0);\n\n    Key storage fromKey = keyByOwner[_from];\n    Key storage toKey = keyByOwner[_recipient];\n\n    uint previousExpiration = toKey.expirationTimestamp;\n    // subtract the fee from the senders key before the transfer\n    _timeMachine(_tokenId, fee, false);\n\n    if (toKey.tokenId == 0) {\n      toKey.tokenId = _tokenId;\n      _recordOwner(_recipient, _tokenId);\n      // Clear any previous approvals\n      _clearApproval(_tokenId);\n    }\n\n    if (previousExpiration <= block.timestamp) {\n      // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration\n      // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID\n      toKey.expirationTimestamp = fromKey.expirationTimestamp;\n      toKey.tokenId = _tokenId;\n\n      // Reset the key Manager to the key owner\n      _setKeyManagerOf(_tokenId, address(0));\n\n      _recordOwner(_recipient, _tokenId);\n    } else {\n      // The recipient has a non expired key. We just add them the corresponding remaining time\n      // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow\n      toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration - block.timestamp;\n    }\n\n    // Effectively expiring the key for the previous owner\n    fromKey.expirationTimestamp = block.timestamp;\n\n    // Set the tokenID to 0 for the previous owner to avoid duplicates\n    fromKey.tokenId = 0;\n\n    // trigger event\n    emit Transfer(\n      _from,\n      _recipient,\n      _tokenId\n    );\n  }\n\n  /**\n   * @notice An ERC-20 style transfer.\n   * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\n   * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\n   * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\n   */\n  function transfer(\n    address _to,\n    uint _value\n  ) public\n    returns (bool success)\n  {\n    uint maxTimeToSend = _value * expirationDuration;\n    Key storage fromKey = keyByOwner[msg.sender];\n    uint timeRemaining = fromKey.expirationTimestamp - block.timestamp;\n    if(maxTimeToSend < timeRemaining)\n    {\n      shareKey(_to, fromKey.tokenId, maxTimeToSend);\n    }\n    else\n    {\n      transferFrom(msg.sender, _to, fromKey.tokenId);\n    }\n\n    // Errors will cause a revert\n    return true;\n  }\n\n  /**\n  * @notice Transfers the ownership of an NFT from one address to another address\n  * @dev This works identically to the other function with an extra data parameter,\n  *  except this function just sets data to ''\n  * @param _from The current owner of the NFT\n  * @param _to The new owner\n  * @param _tokenId The NFT to transfer\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint _tokenId\n  )\n    public\n  {\n    safeTransferFrom(_from, _to, _tokenId, '');\n  }\n\n  /**\n  * @notice Transfers the ownership of an NFT from one address to another address.\n  * When transfer is complete, this functions\n  *  checks if `_to` is a smart contract (code size > 0). If so, it calls\n  *  `onERC721Received` on `_to` and throws if the return value is not\n  *  `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\n  * @param _from The current owner of the NFT\n  * @param _to The new owner\n  * @param _tokenId The NFT to transfer\n  * @param _data Additional data with no specified format, sent in call to `_to`\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint _tokenId,\n    bytes memory _data\n  )\n    public\n  {\n    transferFrom(_from, _to, _tokenId);\n    require(_checkOnERC721Received(_from, _to, _tokenId, _data), 'NON_COMPLIANT_ERC721_RECEIVER');\n\n  }\n\n  /**\n   * Allow the Lock owner to change the transfer fee.\n   */\n  function updateTransferFee(\n    uint _transferFeeBasisPoints\n  )\n    external\n    onlyLockManager\n  {\n    emit TransferFeeChanged(\n      _transferFeeBasisPoints\n    );\n    transferFeeBasisPoints = _transferFeeBasisPoints;\n  }\n\n  /**\n   * Determines how much of a fee a key owner would need to pay in order to\n   * transfer the key to another account.  This is pro-rated so the fee goes down\n   * overtime.\n   * @param _keyOwner The owner of the key check the transfer fee for.\n   */\n  function getTransferFee(\n    address _keyOwner,\n    uint _time\n  )\n    public view\n    returns (uint)\n  {\n    if(! getHasValidKey(_keyOwner)) {\n      return 0;\n    } else {\n      Key storage key = keyByOwner[_keyOwner];\n      uint timeToTransfer;\n      uint fee;\n      // Math: safeSub is not required since `hasValidKey` confirms timeToTransfer is positive\n      // this is for standard key transfers\n      if(_time == 0) {\n        timeToTransfer = key.expirationTimestamp - block.timestamp;\n      } else {\n        timeToTransfer = _time;\n      }\n      fee = timeToTransfer * transferFeeBasisPoints / BASIS_POINTS_DEN;\n      return fee;\n    }\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes4 retval = IERC721ReceiverUpgradeable(to).onERC721Received(\n      msg.sender, from, tokenId, _data);\n    return (retval == _ERC721_RECEIVED);\n  }\n\n}\n\n",
        "CodeNames": [
            "MixinTransfer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MixinTransfer.sol#transferFrom function",
                "Type": "Incorrect implementation",
                "Description": "The key manager is not being reset when transferring the key, allowing attackers to keep the role of key manager after the transfer.",
                "Repair": "Reset the key manager regardless of the status of the recipient's key"
            },
            {
                "Location": "MixinTransfer.shareKey()",
                "Type": "Inaccurate fees computation",
                "Description": "The shareKey function computes the fee inaccurately, resulting in the receiver receiving less time than they are owed.",
                "Repair": "Change the first if branch condition to timePlusFee <= timeRemaining. In the else branch, compute the time without fee as time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n/**\n * @title The Unlock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * This smart contract has 3 main roles:\n *  1. Distribute discounts to discount token holders\n *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.\n *  3. Create & deploy Public Lock contracts.\n * In order to achieve these 3 elements, it keeps track of several things such as\n *  a. Deployed locks addresses and balances of discount tokens granted by each lock.\n *  b. The total network product (sum of all key sales, net of discounts)\n *  c. Total of discounts granted\n *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim\n * discounts and cannot be used/transferred for a given period)\n *  e. Growth rate of Network Product\n *  f. Growth rate of Discount tokens supply\n * The smart contract has an owner who only can perform the following\n *  - Upgrades\n *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most\n * 50% of GNP growth rate)\n * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and\n * in the wild.\n * The partial implementation includes the following features:\n *  a. Keeping track of deployed locks\n *  b. Keeping track of GNP\n */\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\nimport 'hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol';\nimport './utils/UnlockOwnable.sol';\nimport './interfaces/IPublicLock.sol';\nimport './interfaces/IMintableERC20.sol';\n\n/// @dev Must list the direct base contracts in the order from \u201cmost base-like\u201d to \u201cmost derived\u201d.\n/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization\ncontract Unlock is\n  Initializable,\n  UnlockOwnable\n{\n\n  /**\n   * The struct for a lock\n   * We use deployed to keep track of deployments.\n   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,\n   * which would be the same values when the lock is not set.\n   */\n  struct LockBalances\n  {\n    bool deployed;\n    uint totalSales; // This is in wei\n    uint yieldedDiscountTokens;\n  }\n\n  modifier onlyFromDeployedLock() {\n    require(locks[msg.sender].deployed, 'ONLY_LOCKS');\n    _;\n  }\n\n  uint public grossNetworkProduct;\n\n  uint public totalDiscountGranted;\n\n  // We keep track of deployed locks to ensure that callers are all deployed locks.\n  mapping (address => LockBalances) public locks;\n\n  // global base token URI\n  // Used by locks where the owner has not set a custom base URI.\n  string public globalBaseTokenURI;\n\n  // global base token symbol\n  // Used by locks where the owner has not set a custom symbol\n  string public globalTokenSymbol;\n\n  // The address of the latest public lock template, used by default when `createLock` is called\n  address public publicLockAddress;\n\n  // Map token address to oracle contract address if the token is supported\n  // Used for GDP calculations\n  mapping (address => IUniswapOracle) public uniswapOracles;\n\n  // The WETH token address, used for value calculations\n  address public weth;\n\n  // The UDT token address, used to mint tokens on referral\n  address public udt;\n\n  // The approx amount of gas required to purchase a key\n  uint public estimatedGasForPurchase;\n\n  // Blockchain ID the network id on which this version of Unlock is operating\n  uint public chainId;\n\n  // store proxy admin\n  address public proxyAdminAddress;\n  ProxyAdmin private proxyAdmin;\n\n  // publicLock templates\n  mapping(address => uint16) private _publicLockVersions;\n  mapping(uint16 => address) private _publicLockImpls;\n  uint16 public publicLockLatestVersion;\n\n  // Events\n  event NewLock(\n    address indexed lockOwner,\n    address indexed newLockAddress\n  );\n\n  event LockUpgraded(\n    address lockAddress,\n    uint16 version\n  );\n\n  event ConfigUnlock(\n    address udt,\n    address weth,\n    uint estimatedGasForPurchase,\n    string globalTokenSymbol,\n    string globalTokenURI,\n    uint chainId\n  );\n\n  event SetLockTemplate(\n    address publicLockAddress\n  );\n\n  event ResetTrackedValue(\n    uint grossNetworkProduct,\n    uint totalDiscountGranted\n  );\n\n  event UnlockTemplateAdded(\n    address indexed impl,\n    uint16 indexed version\n  );\n\n  // Use initialize instead of a constructor to support proxies (for upgradeability via OZ).\n  function initialize(\n    address _unlockOwner\n  )\n    public\n    initializer()\n  {\n    // We must manually initialize Ownable\n    UnlockOwnable.__initializeOwnable(_unlockOwner);\n    // add a proxy admin on deployment\n    _deployProxyAdmin();\n  }\n\n  function initializeProxyAdmin() public {\n    require(proxyAdminAddress == address(0), \"ProxyAdmin already deployed\");\n    _deployProxyAdmin();\n  }\n\n  /**\n  * @dev Deploy the ProxyAdmin contract that will manage lock templates upgrades\n  * This deploys an instance of ProxyAdmin used by PublicLock transparent proxies.\n  */\n  function _deployProxyAdmin() private returns(address) {\n    proxyAdmin = new ProxyAdmin();\n    proxyAdminAddress = address(proxyAdmin);\n    return address(proxyAdmin);\n  }\n\n  /**\n  * @dev Helper to get the version number of a template from his address\n  */\n  function publicLockVersions(address _impl) external view returns(uint16) {\n    return _publicLockVersions[_impl];\n  }\n\n  /**\n  * @dev Helper to get the address of a template based on its version number\n  */\n  function publicLockImpls(uint16 _version) external view returns(address) {\n    return _publicLockImpls[_version];\n  }\n\n  /**\n  * @dev Registers a new PublicLock template immplementation\n  * The template is identified by a version number\n  * Once registered, the template can be used to upgrade an existing Lock\n  */\n  function addLockTemplate(address impl, uint16 version) public onlyOwner {\n    _publicLockVersions[impl] = version;\n    _publicLockImpls[version] = impl;\n    if (publicLockLatestVersion < version) publicLockLatestVersion = version;\n\n    emit UnlockTemplateAdded(impl, version);\n  }\n\n  /**\n  * @notice Create lock\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\n  * @param data bytes containing the call to initialize the lock template\n  * @dev this call is passed as encoded function - for instance:\n  *  bytes memory data = abi.encodeWithSignature(\n  *    'initialize(address,uint256,address,uint256,uint256,string)',\n  *    msg.sender,\n  *    _expirationDuration,\n  *    _tokenAddress,\n  *    _keyPrice,\n  *    _maxNumberOfKeys,\n  *    _lockName\n  *  );\n  * @return address of the create lock\n  */\n  function createLock(\n    bytes memory data\n  ) public returns(address)\n  {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');\n\n    // deploy a proxy pointing to impl\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(publicLockAddress, proxyAdminAddress, data);\n    address payable newLock = payable(address(proxy));\n\n    // assign the new Lock\n    locks[newLock] = LockBalances({\n      deployed: true, totalSales: 0, yieldedDiscountTokens: 0\n    });\n\n    // trigger event\n    emit NewLock(msg.sender, newLock);\n    return newLock;\n  }\n\n  /**\n   * @dev Upgrade a Lock template implementation\n   * @param lockAddress the address of the lock to be upgraded\n   * @param version the version number of the template\n   */\n  function upgradeLock(address payable lockAddress, uint16 version) public returns(address) {\n    require(proxyAdminAddress != address(0), \"proxyAdmin is not set\");\n\n    // check perms\n    require(_isLockManager(lockAddress, msg.sender) == true, \"caller is not a manager of this lock\");\n\n    // check version\n    IPublicLock lock = IPublicLock(lockAddress);\n    uint16 currentVersion = lock.publicLockVersion();\n    require( version == currentVersion + 1, 'version error: only +1 increments are allowed');\n\n    // make our upgrade\n    address impl = _publicLockImpls[version];\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(lockAddress);\n    proxyAdmin.upgrade(proxy, impl);\n\n    emit LockUpgraded(lockAddress, version);\n    return lockAddress;\n  }\n\n  function _isLockManager(address lockAddress, address _sender) private view returns(bool isManager) {\n    IPublicLock lock = IPublicLock(lockAddress);\n    return lock.isLockManager(_sender);\n  }\n\n  /**\n   * This function returns the discount available for a user, when purchasing a\n   * a key from a lock.\n   * This does not modify the state. It returns both the discount and the number of tokens\n   * consumed to grant that discount.\n   * TODO: actually implement this.\n   */\n  function computeAvailableDiscountFor(\n    address /* _purchaser */,\n    uint /* _keyPrice */\n  )\n    public\n    pure\n    returns (uint discount, uint tokens)\n  {\n    // TODO: implement me\n    return (0, 0);\n  }\n\n  /**\n   * This function keeps track of the added GDP, as well as grants of discount tokens\n   * to the referrer, if applicable.\n   * The number of discount tokens granted is based on the value of the referal,\n   * the current growth rate and the lock's discount token distribution rate\n   * This function is invoked by a previously deployed lock only.\n   * TODO: actually implement\n   */\n  function recordKeyPurchase(\n    uint _value,\n    address _referrer\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    if(_value > 0) {\n      uint valueInETH;\n      address tokenAddress = IPublicLock(msg.sender).tokenAddress();\n      if(tokenAddress != address(0) && tokenAddress != weth) {\n        // If priced in an ERC-20 token, find the supported uniswap oracle\n        IUniswapOracle oracle = uniswapOracles[tokenAddress];\n        if(address(oracle) != address(0)) {\n          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);\n        }\n      }\n      else {\n        // If priced in ETH (or value is 0), no conversion is required\n        valueInETH = _value;\n      }\n\n      grossNetworkProduct = grossNetworkProduct + valueInETH;\n      // If GNP does not overflow, the lock totalSales should be safe\n      locks[msg.sender].totalSales += valueInETH;\n\n      // Mint UDT\n      if(_referrer != address(0))\n      {\n        IUniswapOracle udtOracle = uniswapOracles[udt];\n        if(address(udtOracle) != address(0))\n        {\n          // Get the value of 1 UDT (w/ 18 decimals) in ETH\n          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);\n\n          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut\n          uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice;\n\n          // or tokensToDistribute is capped by network GDP growth\n          uint maxTokens = 0;\n          if (chainId > 1)\n          {\n            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5\n            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));\n            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\n          } else {\n            // Mainnet: we mint new token using log curve\n            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;\n          }\n\n          // cap to GDP growth!\n          if(tokensToDistribute > maxTokens)\n          {\n            tokensToDistribute = maxTokens;\n          }\n\n          if(tokensToDistribute > 0)\n          {\n            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer\n            uint devReward = tokensToDistribute * 20 / 100;\n            if (chainId > 1)\n            {\n              uint balance = IMintableERC20(udt).balanceOf(address(this));\n              if (balance > tokensToDistribute) {\n                // Only distribute if there are enough tokens\n                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);\n                IMintableERC20(udt).transfer(owner(), devReward);\n              }\n            } else {\n              // No distribnution\n              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);\n              IMintableERC20(udt).mint(owner(), devReward);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * This function will keep track of consumed discounts by a given user.\n   * It will also grant discount tokens to the creator who is granting the discount based on the\n   * amount of discount and compensation rate.\n   * This function is invoked by a previously deployed lock only.\n   */\n  function recordConsumedDiscount(\n    uint _discount,\n    uint /* _tokens */\n  )\n    public\n    onlyFromDeployedLock()\n  {\n    // TODO: implement me\n    totalDiscountGranted += _discount;\n    return;\n  }\n\n  // The version number of the current Unlock implementation on this network\n  function unlockVersion(\n  ) external pure\n    returns (uint16)\n  {\n    return 10;\n  }\n\n  /**\n   * @notice Allows the owner to update configuration variables\n   */\n  function configUnlock(\n    address _udt,\n    address _weth,\n    uint _estimatedGasForPurchase,\n    string calldata _symbol,\n    string calldata _URI,\n    uint _chainId\n  ) external\n    onlyOwner\n  {\n    udt = _udt;\n    weth = _weth;\n    estimatedGasForPurchase = _estimatedGasForPurchase;\n\n    globalTokenSymbol = _symbol;\n    globalBaseTokenURI = _URI;\n\n    chainId = _chainId;\n\n    emit ConfigUnlock(_udt, _weth, _estimatedGasForPurchase, _symbol, _URI, _chainId);\n  }\n\n  /**\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\n   * @dev This will initialize the template and revokeOwnership.\n   */\n  function setLockTemplate(\n    address _publicLockAddress\n  ) external\n    onlyOwner\n  {\n    // First claim the template so that no-one else could\n    // this will revert if the template was already initialized.\n    IPublicLock(_publicLockAddress).initialize(\n      address(this), 0, address(0), 0, 0, ''\n    );\n    IPublicLock(_publicLockAddress).renounceLockManager();\n\n    publicLockAddress = _publicLockAddress;\n\n    emit SetLockTemplate(_publicLockAddress);\n  }\n\n  /**\n   * @notice allows the owner to set the oracle address to use for value conversions\n   * setting the _oracleAddress to address(0) removes support for the token\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\n   */\n  function setOracle(\n    address _tokenAddress,\n    address _oracleAddress\n  ) external\n    onlyOwner\n  {\n    uniswapOracles[_tokenAddress] = IUniswapOracle(_oracleAddress);\n    if(_oracleAddress != address(0)) {\n      IUniswapOracle(_oracleAddress).update(_tokenAddress, weth);\n    }\n  }\n\n  // Allows the owner to change the value tracking variables as needed.\n  function resetTrackedValue(\n    uint _grossNetworkProduct,\n    uint _totalDiscountGranted\n  ) external\n    onlyOwner\n  {\n    grossNetworkProduct = _grossNetworkProduct;\n    totalDiscountGranted = _totalDiscountGranted;\n\n    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);\n  }\n\n  /**\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalBaseTokenURI()\n    external\n    view\n    returns (string memory)\n  {\n    return globalBaseTokenURI;\n  }\n\n  /**\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\n   */\n  function getGlobalTokenSymbol()\n    external\n    view\n    returns (string memory)\n  {\n    return globalTokenSymbol;\n  }\n}\n\n\n",
        "CodeNames": [
            "Unlock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "Unlock contract",
                "Type": "Arbitrage opportunity",
                "Description": "It is possible to purchase many keys across many locks for the UDT token that is distributed to the referrer and sell them on some other exchanges where the price of UDT is higher.",
                "Repair": "Use the average of multiple oracle sources so that the price of UDT tokens reacts faster or distribute UDT tokens based on the duration of key ownership"
            },
            {
                "Location": "Unlock.sol#recordKeyPurchase()",
                "Type": "Potential economic attack",
                "Description": "The Unlock.sol#recordKeyPurchase() function can be exploited by creating a lock and calling purchase() many times to mint UDT, or by using a special gas saving token to get a gas refund on transfer. This can lead to potential economic attacks on UDT grants to the referrer.",
                "Repair": "Consider setting a global daily upper limit of total UDT grants to referrers, plus, an upper limit for UDT minted per purchase."
            },
            {
                "Location": "Unlock.recordKeyPurchase function",
                "Type": "Missing scaling factor",
                "Description": "The Unlock.recordKeyPurchase function computes the maxTokens curve without a scaling factor, which might not be computed as intended and lead to being able to receive more token rewards than intended.",
                "Repair": "Consider adding a scaling factor to the term 2 * valueInETH / grossNetworkProduct and divide by it at the end of the computation again."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport './MixinKeys.sol';\nimport './MixinLockCore.sol';\nimport './MixinRoles.sol';\nimport './MixinFunds.sol';\n\n\ncontract MixinRefunds is\n  MixinRoles,\n  MixinFunds,\n  MixinLockCore,\n  MixinKeys\n{\n  // CancelAndRefund will return funds based on time remaining minus this penalty.\n  // This is calculated as `proRatedRefund * refundPenaltyBasisPoints / BASIS_POINTS_DEN`.\n  uint public refundPenaltyBasisPoints;\n\n  uint public freeTrialLength;\n\n  event CancelKey(\n    uint indexed tokenId,\n    address indexed owner,\n    address indexed sendTo,\n    uint refund\n  );\n\n  event RefundPenaltyChanged(\n    uint freeTrialLength,\n    uint refundPenaltyBasisPoints\n  );\n\n  function _initializeMixinRefunds() internal\n  {\n    // default to 10%\n    refundPenaltyBasisPoints = 1000;\n  }\n\n  /**\n   * @dev Invoked by the lock owner to destroy the user's ket and perform a refund and cancellation\n   * of the key\n   */\n  function expireAndRefundFor(\n    address payable _keyOwner,\n    uint amount\n  ) external\n    onlyLockManager\n    hasValidKey(_keyOwner)\n  {\n    _cancelAndRefund(_keyOwner, amount);\n  }\n\n  /**\n   * @dev Destroys the key and sends a refund based on the amount of time remaining.\n   * @param _tokenId The id of the key to cancel.\n   */\n  function cancelAndRefund(uint _tokenId)\n    external\n    onlyKeyManagerOrApproved(_tokenId)\n  {\n    address payable keyOwner = payable(ownerOf(_tokenId));\n    uint refund = _getCancelAndRefundValue(keyOwner);\n\n    _cancelAndRefund(keyOwner, refund);\n  }\n\n  /**\n   * Allow the owner to change the refund penalty.\n   */\n  function updateRefundPenalty(\n    uint _freeTrialLength,\n    uint _refundPenaltyBasisPoints\n  ) external\n    onlyLockManager\n  {\n    emit RefundPenaltyChanged(\n      _freeTrialLength,\n      _refundPenaltyBasisPoints\n    );\n\n    freeTrialLength = _freeTrialLength;\n    refundPenaltyBasisPoints = _refundPenaltyBasisPoints;\n  }\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * a cancelAndRefund block.timestamp.\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\n   * than what the user reads from this call.\n   */\n  function getCancelAndRefundValueFor(\n    address _keyOwner\n  )\n    external view\n    returns (uint refund)\n  {\n    return _getCancelAndRefundValue(_keyOwner);\n  }\n\n  /**\n   * @dev cancels the key for the given keyOwner and sends the refund to the msg.sender.\n   */\n  function _cancelAndRefund(\n    address payable _keyOwner,\n    uint refund\n  ) internal\n  {\n    Key storage key = keyByOwner[_keyOwner];\n\n    emit CancelKey(key.tokenId, _keyOwner, msg.sender, refund);\n    // expirationTimestamp is a proxy for hasKey, setting this to `block.timestamp` instead\n    // of 0 so that we can still differentiate hasKey from hasValidKey.\n    key.expirationTimestamp = block.timestamp;\n\n    if (refund > 0) {\n      // Security: doing this last to avoid re-entrancy concerns\n      _transfer(tokenAddress, _keyOwner, refund);\n    }\n\n    // inform the hook if there is one registered\n    if(address(onKeyCancelHook) != address(0))\n    {\n      onKeyCancelHook.onKeyCancel(msg.sender, _keyOwner, refund);\n    }\n  }\n\n  /**\n   * @dev Determines how much of a refund a key owner would receive if they issued\n   * a cancelAndRefund now.\n   * @param _keyOwner The owner of the key check the refund value for.\n   */\n  function _getCancelAndRefundValue(\n    address _keyOwner\n  )\n    private view\n    hasValidKey(_keyOwner)\n    returns (uint refund)\n  {\n    Key storage key = keyByOwner[_keyOwner];\n    // Math: safeSub is not required since `hasValidKey` confirms timeRemaining is positive\n    uint timeRemaining = key.expirationTimestamp - block.timestamp;\n    if(timeRemaining + freeTrialLength >= expirationDuration) {\n      refund = keyPrice;\n    } else {\n      refund = keyPrice * timeRemaining / expirationDuration;\n    }\n\n    // Apply the penalty if this is not a free trial\n    if(freeTrialLength == 0 || timeRemaining + freeTrialLength < expirationDuration)\n    {\n      uint penalty = keyPrice * refundPenaltyBasisPoints / BASIS_POINTS_DEN;\n      if (refund > penalty) {\n        refund -= penalty;\n      } else {\n        refund = 0;\n      }\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "MixinRefunds.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "MixinRefunds contract",
                "Type": "Frontrunning",
                "Description": "A malicious user is able to withdraw all payments that were paid to a lock owner if the owner increases the keyPrice.",
                "Repair": "Apply a penalty for the difference in price before changing the lock price or store the amount paid for the latest key"
            },
            {
                "Location": "MixinRefunds.sol#L144:#L152",
                "Type": "Refund mechanism issue",
                "Description": "The refund mechanism doesn't take into account that key price can change, and calculates refund according to current key price, not price actually paid. A user refunding can get less (or more) funds than deserved.",
                "Repair": "Save the amount the user paid, and refund according to that, or have a kind of a price snapshot/version mechanism."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport './interfaces/IPublicLock.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol';\nimport './mixins/MixinDisable.sol';\nimport './mixins/MixinERC721Enumerable.sol';\nimport './mixins/MixinFunds.sol';\nimport './mixins/MixinGrantKeys.sol';\nimport './mixins/MixinKeys.sol';\nimport './mixins/MixinLockCore.sol';\nimport './mixins/MixinLockMetadata.sol';\nimport './mixins/MixinPurchase.sol';\nimport './mixins/MixinRefunds.sol';\nimport './mixins/MixinTransfer.sol';\nimport './mixins/MixinRoles.sol';\n\n\n/**\n * @title The Lock contract\n * @author Julien Genestoux (unlock-protocol.com)\n * @dev ERC165 allows our contract to be queried to determine whether it implements a given interface.\n * Every ERC-721 compliant contract must implement the ERC165 interface.\n * https://eips.ethereum.org/EIPS/eip-721\n */\ncontract PublicLock is\n  Initializable,\n  ERC165StorageUpgradeable,\n  MixinRoles,\n  MixinFunds,\n  MixinDisable,\n  MixinLockCore,\n  MixinKeys,\n  MixinLockMetadata,\n  MixinERC721Enumerable,\n  MixinGrantKeys,\n  MixinPurchase,\n  MixinTransfer,\n  MixinRefunds\n{\n  function initialize(\n    address payable _lockCreator,\n    uint _expirationDuration,\n    address _tokenAddress,\n    uint _keyPrice,\n    uint _maxNumberOfKeys,\n    string calldata _lockName\n  ) public\n    initializer()\n  {\n    MixinFunds._initializeMixinFunds(_tokenAddress);\n    MixinDisable._initializeMixinDisable();\n    MixinLockCore._initializeMixinLockCore(_lockCreator, _expirationDuration, _keyPrice, _maxNumberOfKeys);\n    MixinLockMetadata._initializeMixinLockMetadata(_lockName);\n    MixinERC721Enumerable._initializeMixinERC721Enumerable();\n    MixinRefunds._initializeMixinRefunds();\n    MixinRoles._initializeMixinRoles(_lockCreator);\n    // registering the interface for erc721 with ERC165.sol using\n    // the ID specified in the standard: https://eips.ethereum.org/EIPS/eip-721\n    _registerInterface(0x80ac58cd);\n  }\n\n  /**\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\n   */\n  receive() external payable {}\n  \n  \n  // TODO: what should be done here?\n  fallback() external payable {}\n\n  /**\n   Overrides\n  */\n  function supportsInterface(bytes4 interfaceId) \n    public \n    view \n    virtual \n    override(\n      MixinERC721Enumerable,\n      MixinLockMetadata,\n      AccessControlUpgradeable, \n      ERC165StorageUpgradeable\n    ) \n    returns (bool) \n    {\n    return super.supportsInterface(interfaceId);\n  }\n\n}\n\n\n",
        "CodeNames": [
            "PublicLock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Location": "PublicLock.initialize()",
                "Type": "Insufficient access control",
                "Description": "The Unlock.sol contract uses setLocktemplate() to initialize the implementation contract for the PublicLock proxy. PublicLock.initialize() does not have any relevant access control and does not prevent arbitrary users from initializing. This means that a malicious user could front run the setLocktemplate() forcing the deployer of PublicLock's implementation to redeploy.",
                "Repair": "Implement valid access control on the PublicLock contract to ensure only the relevant deployer can initialize()"
            }
        ]
    }
]