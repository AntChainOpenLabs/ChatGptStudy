[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport { IYieldSource } from \"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./IBadgerSett.sol\";\nimport \"./IBadger.sol\";\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/// @title A pooltogether yield source for badger sett\n/// @author Steffel Fenix, 0xkarl\ncontract BadgerYieldSource is IYieldSource {\n    using SafeMath for uint256;\n    IBadgerSett private immutable badgerSett;\n    IBadger private immutable badger;\n    mapping(address => uint256) private balances;\n\n    constructor(address badgerSettAddr, address badgerAddr) public {\n        badgerSett = IBadgerSett(badgerSettAddr);\n        badger = IBadger(badgerAddr);\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function depositToken() public view override returns (address) {\n        return (address(badger));\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) public override returns (uint256) {\n        if (balances[addr] == 0) return 0;\n\n        uint256 totalShares = badgerSett.totalSupply();\n        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));\n        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));\n    }\n\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\n    /// @param amount The amount of `token()` to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 amount, address to) public override {\n        badger.safeTransferFrom(msg.sender, address(this), amount);\n        badger.safeApprove(address(badgerSett), amount);\n\n        uint256 beforeBalance = badgerSett.balanceOf(address(this));\n        badgerSett.deposit(amount);\n        uint256 afterBalance = badgerSett.balanceOf(address(this));\n        uint256 balanceDiff = afterBalance.sub(beforeBalance);\n        balances[to] = balances[to].add(balanceDiff);\n    }\n\n    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.\n    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.\n    /// @return The actual amount of tokens that were redeemed.\n    function redeemToken(uint256 amount) public override returns (uint256) {\n        uint256 totalShares = badgerSett.totalSupply();\n        if (totalShares == 0) return 0;\n\n        uint256 badgerSettBadgerBalance = badgerSett.balance();\n        if (badgerSettBadgerBalance == 0) return 0;\n\n        uint256 badgerBeforeBalance = badger.balanceOf(address(this));\n\n        uint256 requiredShares =\n            ((amount.mul(totalShares) + totalShares)).div(\n                badgerSettBadgerBalance\n            );\n        if (requiredShares == 0) return 0;\n\n        uint256 requiredSharesBalance = requiredShares.sub(1);\n        badgerSett.withdraw(requiredSharesBalance);\n\n        uint256 badgerAfterBalance = badger.balanceOf(address(this));\n        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);\n\n        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);\n        badger.safeTransfer(msg.sender, badgerBalanceDiff);\n        return (badgerBalanceDiff);\n    }\n}",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_1",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\n\ninterface CErc20 {\n    function underlying() external view returns (address);\n}\n\ncontract UniswapConfig is Ownable {\n    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\n    enum PriceSource {\n        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\n        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\n        REPORTER   /// implies the price is set by the reporter\n    }\n\n    /// @dev Describe how the USD price should be determined for an asset.\n    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\n    struct TokenConfig {\n        address cToken;\n        address underlying;\n        bytes32 symbolHash;\n        uint256 baseUnit;\n        PriceSource priceSource;\n        uint256 fixedPrice;\n        address uniswapMarket;\n        bool isUniswapReversed;\n    }\n\n    mapping(uint => TokenConfig) public tokens;\n    mapping(address => uint) public cTokenIndex;\n    mapping(address => uint) public underlyingIndex;\n    mapping(bytes32 => uint) public symbolHashIndex;\n\n    /// @notice The number of tokens this contract actually supports\n    uint public numTokens;\n\n    function _addTokensInternal(TokenConfig[] memory configs) internal {\n        for (uint i = 0; i < configs.length; i++) {\n            uint index = i + numTokens;\n            tokens[index] = configs[i];\n            cTokenIndex[configs[i].cToken] = index;\n            underlyingIndex[configs[i].underlying] = index;\n            symbolHashIndex[configs[i].symbolHash] = index;\n        }\n\n        numTokens = numTokens + configs.length;\n    }\n\n    function getCTokenIndex(address cToken) internal view returns (uint) {\n        return cTokenIndex[cToken];\n    }\n\n    function getUnderlyingIndex(address underlying) internal view returns (uint) {\n        return underlyingIndex[underlying];\n    }\n\n    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\n        return symbolHashIndex[symbolHash];\n    }\n\n    /**\n     * @notice Get the i-th config, according to the order they were passed in originally\n     * @param i The index of the config to get\n     * @return The config object\n     */\n    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\n        require(i < numTokens, \"token config not found\");\n\n        return tokens[i];\n    }\n\n    /**\n     * @notice Get the config for symbol\n     * @param symbol The symbol of the config to get\n     * @return The config object\n     */\n    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\n        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\n    }\n\n    /**\n     * @notice Get the config for the symbolHash\n     * @param symbolHash The keccack256 of the symbol of the config to get\n     * @return The config object\n     */\n    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\n        uint index = getSymbolHashIndex(symbolHash);\n        if (index != uint(0)) {\n            return getTokenConfig(index);\n        }\n\n        revert(\"token config not found\");\n    }\n\n    /**\n     * @notice Get the config for the cToken\n     * @dev If a config for the cToken is not found, falls back to searching for the underlying.\n     * @param cToken The address of the cToken of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByCToken(address cToken) public view returns (TokenConfig memory) {\n        uint index = getCTokenIndex(cToken);\n        if (index != uint(0)) {\n            return getTokenConfig(index);\n        }\n\n        return getTokenConfigByUnderlying(CErc20(cToken).underlying());\n    }\n\n    /**\n     * @notice Get the config for an underlying asset\n     * @param underlying The address of the underlying asset of the config to get\n     * @return The config object\n     */\n    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\n        uint index = getUnderlyingIndex(underlying);\n        if (index != uint(0)) {\n            return getTokenConfig(index);\n        }\n\n        revert(\"token config not found\");\n    }\n}",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_2",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "struct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\n\ninterface INFTOracle {\n    /// @notice Get the latest exchange rate.\n    /// @param pair address of the NFTPair calling the oracle\n    /// @param tokenId tokenId of the NFT in question \n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function get(address pair, uint256 tokenId) external returns (bool success, uint256 rate);\n\n    /// @notice Check the last exchange rate without any state changes.\n    /// @param pair address of the NFTPair calling the oracle\n    /// @param tokenId tokenId of the NFT in question \n    /// @return success if no valid (recent) rate is available, return false else true.\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peek(address pair, uint256 tokenId) external view returns (bool success, uint256 rate);\n\n    /// @notice Check the current spot exchange rate without any state changes. For oracles like TWAP this will be different from peek().\n    /// @param pair address of the NFTPair calling the oracle\n    /// @param tokenId tokenId of the NFT in question \n    /// (string memory collateralSymbol, string memory assetSymbol, uint256 division) = abi.decode(data, (string, string, uint256));\n    /// @return rate The rate of the requested asset / pair / pool.\n    function peekSpot(address pair, uint256 tokenId) external view returns (uint256 rate);\n\n    /// @notice Returns a human readable (short) name about this oracle.\n    /// @param pair address of the NFTPair calling the oracle\n    /// @param tokenId tokenId of the NFT in question \n    /// @return (string) A human readable symbol name about this oracle.\n    function symbol(address pair, uint256 tokenId) external view returns (string memory);\n\n    /// @notice Returns a human readable name about this oracle.\n    /// @param pair address of the NFTPair calling the oracle\n    /// @param tokenId tokenId of the NFT in question \n    /// @return (string) A human readable name about this oracle.\n    function name(address pair, uint256 tokenId) external view returns (string memory);\n}\n\nfunction removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, \"NFTPair: not the lender\");\n\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (bool success, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(success);\n                require(rate.mul(loanParams.ltvBPS) / BPS < amount, \"NFT is still valued\");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with `skim` set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, \"NFTPair: not available\");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as `accepted`.\n        require(\n            params.valuation == accepted.valuation &&\n                params.duration <= accepted.duration &&\n                params.annualInterestBPS >= accepted.annualInterestBPS &&\n                params.ltvBPS >= accepted.ltvBPS,\n            \"NFTPair: bad params\"\n        );\n\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            (bool success, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(success);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, \"Oracle: price too low.\");\n        }\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                \"NFTPair: skim too much\"\n            );\n        } else {\n            bentoBox.safeTransfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS <= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.safeTransfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_3",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "  error ReturnDustFail();\n     function _returnDust() private {\n         uint256 _remainingETH = remainingETH;\n+        bool success;\n         assembly {\n             if gt(_remainingETH, 0) {\n               success := call(\n                     gas(),\n                     caller(),\n                     selfbalance(),\n                     0,\n                     0,\n                     0,\n                     0\n                 )\n             }\n         }\n        if (!success) revert ReturnDustFail();\n     }",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_4",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport { IYieldSource } from \"@pooltogether/yield-source-interface/contracts/IYieldSource.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./ISushiBar.sol\";\nimport \"./ISushi.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\n/// @title A pooltogether yield source for sushi token\n/// @author Steffel Fenix\ncontract SushiYieldSource is IYieldSource {\n    \n    using SafeMath for uint256;\n    \n    ISushiBar public immutable sushiBar;\n    ISushi public immutable sushiAddr;\n    \n    mapping(address => uint256) public balances;\n\n    constructor(ISushiBar _sushiBar, ISushi _sushiAddr) public {\n        sushiBar = _sushiBar;\n        sushiAddr = _sushiAddr;\n    }\n\n    /// @notice Returns the ERC20 asset token used for deposits.\n    /// @return The ERC20 asset token\n    function depositToken() public view override returns (address) {\n        return address(sushiAddr);\n    }\n\n    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.\n    /// @return The underlying balance of asset tokens\n    function balanceOfToken(address addr) public override returns (uint256) {\n        if (balances[addr] == 0) return 0;\n\n        uint256 totalShares = sushiBar.totalSupply();\n        uint256 barSushiBalance = sushiAddr.balanceOf(address(sushiBar));\n\n        return balances[addr].mul(barSushiBalance).div(totalShares);       \n    }\n\n    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.\n    /// @param amount The amount of `token()` to be supplied\n    /// @param to The user whose balance will receive the tokens\n    function supplyTokenTo(uint256 amount, address to) public override {\n        sushiAddr.safeTransferFrom(msg.sender, address(this), amount);\n        sushiAddr.safeApprove(address(sushiBar), amount);\n\n        ISushiBar bar = sushiBar;\n        uint256 beforeBalance = bar.balanceOf(address(this));\n        \n        bar.enter(amount);\n        \n        uint256 afterBalance = bar.balanceOf(address(this));\n        uint256 balanceDiff = afterBalance.sub(beforeBalance);\n        \n        balances[to] = balances[to].add(balanceDiff);\n    }\n\n    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.\n    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.\n    /// @dev The maxiumum that can be called for token() is calculated by balanceOfToken() above.\n    /// @return The actual amount of tokens that were redeemed. This may be different from the amount passed due to the fractional math involved. \n    function redeemToken(uint256 amount) public override returns (uint256) {\n        ISushiBar bar = sushiBar;\n        ISushi sushi = sushiAddr;\n\n        uint256 totalShares = bar.totalSupply();\n        if(totalShares == 0) return 0; \n\n        uint256 barSushiBalance = sushi.balanceOf(address(bar));\n        if(barSushiBalance == 0) return 0;\n\n        uint256 sushiBeforeBalance = sushi.balanceOf(address(this));\n\n        uint256 requiredShares = ((amount.mul(totalShares) + totalShares)).div(barSushiBalance);\n        if(requiredShares == 0) return 0;\n        \n        uint256 requiredSharesBalance = requiredShares.sub(1);\n        bar.leave(requiredSharesBalance);\n\n        uint256 sushiAfterBalance = sushi.balanceOf(address(this));\n        \n        uint256 sushiBalanceDiff = sushiAfterBalance.sub(sushiBeforeBalance);\n\n        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);\n        sushi.safeTransfer(msg.sender, sushiBalanceDiff);\n        \n        return (sushiBalanceDiff);\n    }\n\n}\n",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_5",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.safeTransferFrom(msg.sender,recipient,_amount)      emit NewWithdrawal(msg.sender, amount);\n}",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_6",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "interface ITempus {\n    function maturityTime() external view returns (uint256);\n\n    function yieldBearingToken() external view returns (IERC20Metadata);\n\n    function depositAndFix(\n        Any,\n        Any,\n        uint256,\n        bool,\n        uint256,\n        uint256\n    ) external returns (uint256, uint256);\n}\n\nfunction lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address t,\n        address x\n    ) public unpaused(p) returns (uint256) {\n\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).markets(u, m, p);\n        if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u)) {\n            revert NotEqual('underlying');\n        } else if (ITempus(principal).maturityTime() > m) {\n            revert NotEqual('maturity');\n        }\n\n        // Get the underlying token\n        IERC20 underlyingToken = IERC20(u);\n\n        // Transfer funds from user to Illuminate, Scope to avoid stack limit\n        Safe.transferFrom(underlyingToken, msg.sender, address(this), a);\n\n        // Add the accumulated fees to the total\n        uint256 fee = calculateFee(a);\n        fees[u] += fee;\n\n        // Swap on the Tempus Router using the provided market and params\n        IERC5095 illuminateToken = IERC5095(principalToken(u, m));\n        (,uint256 returned) = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d);\n\n        // Mint Illuminate zero coupons\n        illuminateToken.mint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned);\n        return returned;\n    }\n",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_7",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "function withdraw() external onlyOwner {\n        uint256 amount = payableToken.balanceOf(address(this));\n        payableToken.safeTransferFrom(address(this), msg.sender, amount);\n        emit NewWithdrawal(msg.sender, amount);\n    }",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_8",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.safeTransfer(msg.sender, amount);\n}\n\nfunction deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.safeTransferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n\nfunction borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.safeTransfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\nfunction repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.safeTransferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\nfunction forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.safeTransfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.safeTransferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_9",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\n/// @title Permissions\n/// @author 0xScotch <scotch@malt.money>\n/// @notice Inherited by almost all Malt contracts to provide access control\ncontract Permissions is AccessControl {\n  using SafeMath for uint256;\n  using SafeERC20 for ERC20;\n\n  // Timelock has absolute power across the system\n  bytes32 public constant TIMELOCK_ROLE = keccak256(\"TIMELOCK_ROLE\");\n  bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n  bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n\n  // Can mint/burn Malt\n  bytes32 public constant MONETARY_BURNER_ROLE = keccak256(\"MONETARY_BURNER_ROLE\");\n  bytes32 public constant MONETARY_MINTER_ROLE = keccak256(\"MONETARY_MINTER_ROLE\");\n\n  // Contract types\n  bytes32 public constant STABILIZER_NODE_ROLE = keccak256(\"STABILIZER_NODE_ROLE\");\n  bytes32 public constant LIQUIDITY_MINE_ROLE = keccak256(\"LIQUIDITY_MINE_ROLE\");\n  bytes32 public constant AUCTION_ROLE = keccak256(\"AUCTION_ROLE\");\n  bytes32 public constant REWARD_THROTTLE_ROLE = keccak256(\"REWARD_THROTTLE_ROLE\");\n\n  address internal globalAdmin;\n\n  mapping(address => uint256) public lastBlock; // protect against reentrancy\n\n  function _adminSetup(address _timelock) internal {\n    _roleSetup(TIMELOCK_ROLE, _timelock);\n    _roleSetup(ADMIN_ROLE, _timelock);\n    _roleSetup(GOVERNOR_ROLE, _timelock);\n    _roleSetup(MONETARY_BURNER_ROLE, _timelock);\n    _roleSetup(MONETARY_MINTER_ROLE, _timelock);\n    _roleSetup(STABILIZER_NODE_ROLE, _timelock);\n    _roleSetup(LIQUIDITY_MINE_ROLE, _timelock);\n    _roleSetup(AUCTION_ROLE, _timelock);\n    _roleSetup(REWARD_THROTTLE_ROLE, _timelock);\n\n    globalAdmin = _timelock;\n  }\n\n  function assignRole(bytes32 role, address _assignee)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _setupRole(role, _assignee);\n  }\n\n  function removeRole(bytes32 role, address _entity)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can revoke roles\")\n  {\n    revokeRole(role, _entity);\n  }\n\n  function reassignGlobalAdmin(address _admin)\n    external\n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    _swapRole(_admin, globalAdmin, TIMELOCK_ROLE);\n    _swapRole(_admin, globalAdmin, ADMIN_ROLE);\n    _swapRole(_admin, globalAdmin, GOVERNOR_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_BURNER_ROLE);\n    _swapRole(_admin, globalAdmin, MONETARY_MINTER_ROLE);\n    _swapRole(_admin, globalAdmin, STABILIZER_NODE_ROLE);\n    _swapRole(_admin, globalAdmin, LIQUIDITY_MINE_ROLE);\n    _swapRole(_admin, globalAdmin, AUCTION_ROLE);\n    _swapRole(_admin, globalAdmin, REWARD_THROTTLE_ROLE);\n\n    globalAdmin = _admin;\n  }\n\n  function emergencyWithdrawGAS(address payable destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    // Transfers the entire balance of the Gas token to destination\n    (bool ok, ) = destination.call{value: address(this).balance}('');\n    require(ok, \"call failed\");\n    \n  }\n\n  function emergencyWithdraw(address _token, address destination)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    // Transfers the entire balance of an ERC20 token at _token to destination\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, token.balanceOf(address(this)));\n  }\n\n  function partialWithdrawGAS(address payable destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Must have timelock role\")\n  {\n    (bool ok, ) = destination.call{value: address(this).balance}('');\n    require(ok, \"call failed\");\n  }\n\n  function partialWithdraw(address _token, address destination, uint256 amount)\n    external \n    onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")\n  {\n    ERC20 token = ERC20(_token);\n    token.safeTransfer(destination, amount);\n  }\n\n  /*\n   * INTERNAL METHODS\n   */\n  function _swapRole(address newAccount, address oldAccount, bytes32 role) internal {\n    revokeRole(role, oldAccount);\n    _setupRole(role, newAccount);\n  }\n\n  function _roleSetup(bytes32 role, address account) internal {\n    _setupRole(role, account);\n    _setRoleAdmin(role, ADMIN_ROLE);\n  }\n\n  function _onlyRole(bytes32 role, string memory reason) internal view {\n    require(\n      hasRole(\n        role,\n        _msgSender()\n      ),\n      reason\n    );\n  }\n\n  function _notSameBlock() internal {\n    require(\n      block.number > lastBlock[_msgSender()],\n      \"Can't carry out actions in the same block\"\n    );\n    lastBlock[_msgSender()] = block.number;\n  }\n\n  // Using internal function calls here reduces compiled bytecode size\n  modifier onlyRole(bytes32 role, string memory reason) {\n    _onlyRole(role, reason);\n    _;\n  }\n\n  modifier notSameBlock() {\n    _notSameBlock();\n    _;\n  }\n}",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_10",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "function transferOut(address _token, uint _amount, address _recipient) internal {\n        if(_token == VADER){\n            pooledVADER = pooledVADER - _amount; // Accounting\n        } else if(_token == USDV) {\n            pooledUSDV = pooledUSDV - _amount;  // Accounting\n        }\n        if(_recipient != address(this)){\n            iERC20(_token).safeTransfer(_recipient, _amount);\n        }\n    }",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_11",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IRoyaltyVault} from \"../interfaces/IRoyaltyVault.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\nimport {ISplitter} from \"../interfaces/ISplitter.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract RoyaltyVault is VaultStorage, IRoyaltyVault, ERC165, Ownable {\n    /**** Events ****/\n    event RoyaltySentToSplitter(address indexed splitter, uint256 amount);\n    event FeeSentToPlatform(\n        address indexed platformFeeRecipient,\n        uint256 amount\n    );\n    event NewRoyaltyVaultPlatformFee(uint256 platformFee);\n    event NewRoyaltyVaultPlatformFeeRecipient(address recipient);\n\n    /**\n     * @dev Getting royaltyAsset balance of Vault.\n     */\n    function getVaultBalance() public view override returns (uint256) {\n        return IERC20(royaltyAsset).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Send accumulated royalty to splitter.\n     */\n    function sendToSplitter() external override {\n        uint256 balanceOfVault = getVaultBalance();\n\n        require(\n            balanceOfVault > 0,\n            \"Vault does not have enough royalty Asset to send\"\n        );\n        require(splitterProxy != address(0), \"Splitter is not set\");\n\n        uint256 platformShare = (balanceOfVault * platformFee) / 10000;\n        uint256 splitterShare = balanceOfVault - platformShare;\n\n        IERC20(royaltyAsset).safeTransfer(splitterProxy, splitterShare);\n        \n        require(\n            ISplitter(splitterProxy).incrementWindow(splitterShare) == true,\n            \"Failed to increment splitter window\"\n        );\n        \n        \n        IERC20(royaltyAsset).safeTransfer(platformFeeRecipient,platformShare);\n\n        emit RoyaltySentToSplitter(splitterProxy, splitterShare);\n        emit FeeSentToPlatform(platformFeeRecipient, platformShare);\n    }\n\n    /**\n     * @dev Set Platform fee for collection contract.\n     * @param _platformFee Platform fee in scaled percentage.\n     */\n    function setPlatformFee(uint256 _platformFee) external override onlyOwner {\n        platformFee = _platformFee;\n        emit NewRoyaltyVaultPlatformFee(_platformFee);\n    }\n\n    /**\n     * @dev Set Platform fee recipient for collection.\n     * @param _platformFeeRecipient Platform fee recipient address\n     */\n    function setPlatformFeeRecipient(address _platformFeeRecipient)\n        external\n        override\n        onlyOwner\n    {\n        platformFeeRecipient = _platformFeeRecipient;\n        emit NewRoyaltyVaultPlatformFeeRecipient(_platformFeeRecipient);\n    }\n\n    /**\n     * @dev Get Splitter address of proxyVault.\n     */\n    function getSplitter() public view override returns (address) {\n        return splitterProxy;\n    }\n\n    /**\n     * @dev Checks for support of IRoyaltyVault.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IRoyaltyVault, ERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IRoyaltyVault).interfaceId;\n    }\n}",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_12",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "function getAuctionCore(uint256 _id) public view returns (\n    uint256 auctionId,\n    uint256 commitments,\n    uint256 maltPurchased,\n    uint256 startingPrice,\n    uint256 finalPrice,\n    uint256 pegPrice,\n    uint256 startingTime,\n    uint256 endingTime,\n    uint256 preAuctionReserveRatio,\n    bool active\n  ) {\n    AuctionData storage auction = idToAuction[_id];\n\n    return (\n      _id,\n      auction.commitments,\n      auction.maltPurchased,\n      auction.startingPrice,\n      auction.finalPrice,\n      auction.pegPrice,\n      auction.startingTime,\n      auction.endingTime,\n      auction.preAuctionReserveRatio,\n      auction.active\n    );\n}\n\nfunction earlyExitReturn(address account, uint256 _auctionId, uint256 amount) public view returns(uint256) {\n    // We don't need all the values\n    (,,,,,\n      uint256 pegPrice,\n      ,\n      uint256 auctionEndTime,\n      ,\n      bool active\n      ) = auction.getAuctionCore(\\_auctionId);\n\n\n    if(active || block.timestamp < auctionEndTime) {\n      return 0;\n    }\n\n    (\n      uint256 userCommitment,\n      uint256 userRedeemed,\n      uint256 userMaltPurchased\n    ) = auction.getAuctionParticipationForAccount(account, _auctionId);\n\n    // This should never overflow due to guards in redemption code\n    uint256 userOutstanding = userCommitment - userRedeemed;\n\n    if (amount > userOutstanding) {\n      amount = userOutstanding;\n    }\n\n    if (amount == 0) {\n      return 0;\n    }\n\n    (uint256 currentPrice,) = dexHandler.maltMarketPrice();\n\n    uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);\n\n    uint256 fullReturn = maltQuantity.mul(currentPrice) / pegPrice;\n\n    // setCooloffPeriod guards against cooloffPeriod ever being 0\n    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;\n    if (progressionBps > 10000) {\n      progressionBps = 10000;\n    }\n\n    if (fullReturn > amount) {\n      // Allow a % of profit to be realised\n      uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;\n      return amount + maxProfit;\n    } \n\n    return fullReturn;\n  }",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_13",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": " function enableToken(address token, address spender) external {\n        require(msg.sender == owner, \"Unauthorized\");\n        CTokenInterface(token).safeApprove(spender, type(uint256).max);\n    }\n",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_14",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n\n        (\n            address cTokenBorrow,\n            uint256 cTokenRepayAmount,\n            uint16[] memory notionalV2CollateralIds,\n            uint256[] memory notionalV2CollateralAmounts\n        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));\n\n        // Transfer in the underlying amount that was borrowed\n        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();\n        IERC20(underlyingToken).safeTransferFrom (account, address(this), cTokenRepayAmount);\n\n        // Use the amount transferred to repay the borrow\n        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n        require(code == 0, \"Repay borrow behalf failed\");\n\n        for (uint256 i; i < notionalV2CollateralIds.length; i++) {\n            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);\n            // Transfer the collateral to this contract so we can deposit it\n            CTokenInterface(assetToken.tokenAddress).safeTransferFrom (account, address(this), notionalV2CollateralAmounts[i]);\n\n            // Deposit the cToken into the account's portfolio, no free collateral check is triggered here\n            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);\n        }\n\n        // When this exits a free collateral check will be triggered\n    }",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_15",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "function _payoutToken(address tokenAddress) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    ERC20 erc20 = ERC20(tokenAddress);\n    uint256 balance = erc20.balanceOf(address(this));\n    require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n    uint256 sending;\n    //uint256 sent;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      erc20.safeTransfer(addresses[i], sending);\n      // sent = sent + sending;\n    }\n  }\n\nfunction _payoutTokens(address[] memory tokenAddresses) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    ERC20 erc20;\n    uint256 balance;\n    uint256 sending;\n    for (uint256 t = 0; t < tokenAddresses.length; t++) {\n      erc20 = ERC20(tokenAddresses[t]);\n      balance = erc20.balanceOf(address(this));\n      require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n      // uint256 sent;\n      for (uint256 i = 0; i < addresses.length; i++) {\n        sending = ((bps[i] * balance) / 10000);\n        erc20.safeTransfer(addresses[i], sending);\n        // sent = sent + sending;\n      }\n    }\n  }\n",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_16",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./Create2BeaconMaker.sol\";\nlibrary BeaconProxyDeployer {\n    function deploy(address beacon, bytes memory initializationCalldata)\n        internal\n        returns (address result)\n    {\n        bytes memory createCode =\n            abi.encodePacked(\n                type(Create2BeaconMaker).creationCode,\n                abi.encode(address(beacon), initializationCalldata)\n            );\n        bytes32 salt = bytes32(0);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(extcodesize(result)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function calculateAddress(\n        address deployer,\n        address beacon,\n        bytes memory initializationCalldata\n    ) internal view returns (address addr) {\n        bytes memory createCode =\n            abi.encodePacked(\n                type(Create2BeaconMaker).creationCode,\n                abi.encode(address(beacon), initializationCalldata)\n            );\n\n        bytes32 salt = bytes32(0);\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(createCode);\n        addr = address( // derive the target deployment address.\n            uint160( // downcast to match the address type.\n                uint256( // cast to uint to truncate upper digits.\n                    keccak256( // compute CREATE2 hash using 4 inputs.\n                        abi.encodePacked( // pack all inputs to the hash together.\n                            bytes1(0xff), // pass in the control character.\n                            deployer, // pass in the address of this contract.\n                            salt, // pass in the salt from above.\n                            initCodeHash // pass in hash of contract creation code.\n                        )\n                    )\n                )\n            )\n        );\n    }\n}",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_17",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "/// @notice Sets a token for a currency id.\n    function setToken(\n        uint256 currencyId,\n        bool underlying,\n        TokenStorage memory tokenStorage\n    ) internal {\n        bytes32 slot = _getSlot(currencyId, underlying);\n\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\n            // Specific storage for Ether token type\n            bytes32 etherData =\n                ((bytes32(bytes20(address(0))) >> 96) |\n                    (bytes32(bytes1(Constants.BOOL_FALSE)) >> 88) |\n                    bytes32(uint256(18) << 168) |\n                    bytes32(uint256(TokenType.Ether) << 176));\n\n            assembly {\n                sstore(slot, etherData)\n            }\n\n            return;\n        }\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\n        require(tokenStorage.tokenAddress != address(0), \"TH: address is zero\");\n\n        uint8 decimalPlaces = ERC20(tokenStorage.tokenAddress).decimals();\n        require(decimalPlaces != 0, \"TH: decimals is zero\");\n\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\n        // then we should explicitly upgrade this method to allow for a token to be changed.\n        Token memory token = getToken(currencyId, underlying);\n        require(\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\n            \"TH: token cannot be reset\"\n        );\n\n        if (tokenStorage.tokenType == TokenType.cToken) {\n            // Set the approval for the underlying so that we can mint cTokens\n            Token memory underlyingToken = getToken(currencyId, true);\n            ERC20(underlyingToken.tokenAddress).safeApprove(\n                tokenStorage.tokenAddress,\n                type(uint256).max\n            );\n        }\n\n        bytes1 transferFee =\n            tokenStorage.hasTransferFee ? Constants.BOOL_TRUE : Constants.BOOL_FALSE;\n\n        bytes32 data =\n            ((bytes32(bytes20(tokenStorage.tokenAddress)) >> 96) |\n                (bytes32(bytes1(transferFee)) >> 88) |\n                bytes32(uint256(decimalPlaces) << 168) |\n                bytes32(uint256(tokenStorage.tokenType) << 176));\n\n        assembly {\n            sstore(slot, data)\n        }\n    }",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_18",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "pragma solidity ^0.8.0; contract Fixed { function safeSend(address payable recipient, uint256 amount) public { (bool success, ) = recipient.call{value: amount}(\"\"); require(success, \"Failed to send Ether\"); }}",
        "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_19",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
          ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n contract Fixed { function safeTransfer(address payable recipient, uint256 amount, address payable token) public { IERC20(token).safeTransfer(recipient, amount); } }",
        "VulnerabilityDesc": [1
            {
                "Name": "fixed_return_20",
                "Location": "",
                "Type": "unchecked return",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; \ncontract Fixed { function safeTransfer(address payable recipient, uint256 amount, address payable token) public { IERC20(token).safeTransfer(recipient, amount); } }",
        "VulnerabilityDesc": [
            {
                "Name": "fixed_return_21",
                "Location": "",
                "Type": "unchecked return",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; contract Fixed { function safeAllowance(address token, address owner, address spender) public returns (uint256 remaining) { remaining = IERC20(token).allowance(owner, spender); require(remaining > 0, 'No allowance found'); return remaining; } }",
        "VulnerabilityDesc": [
            {
                "Name": "fixed_return_22",
                "Location": "",
                "Type": "unchecked return",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; contract Fixed is ERC721 { constructor() ERC721('Token', 'TKN') {} function safeMint(address to, uint256 tokenId) public { try _mint(to, tokenId) {} catch { revert('Failed to mint the token'); } } }",
         "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_23",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; contract Fixed is ERC721 { constructor() ERC721('Token', 'TKN') {} function safeTransferFrom(address from, address to, uint256 tokenId) public { try _transfer(from, to, tokenId) {} catch { revert('Failed to transfer the token'); } } }",
         "VulnerabilityDesc": [
              {
                  "Name": "fixed_return_24",
                  "Location": "",
                  "Type": "unchecked return",
                  "Description": "",
                  "Repair": ""
              }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; contract Fixed { function safeBurn(address token, address account, uint256 amount) public { bool success = IERC20(token).burnFrom(account, amount); require(success, 'Failed to burn tokens'); } }",
        "VulnerabilityDesc": [
            {
                "Name": "fixed_return_25",
                "Location": "",
                "Type": "unchecked return",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; contract Fixed { function safeLowLevelCall(address payable recipient) public { (bool success, ) = recipient.call(''); require(success, 'Low-level call failed'); } }",
        "VulnerabilityDesc": [
            {
                "Name": "fixed_return_26",
                "Location": "",
                "Type": "unchecked return",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code":"pragma solidity ^0.8.0; contract Fixed { function safeDelegateCall(address target, bytes memory data) public { (bool success, ) = target.delegatecall(data); require(success, 'Delegate call failed'); } }",
        "VulnerabilityDesc": [
            {
                "Name": "fixed_return_27",
                "Location": "",
                "Type": "unchecked return",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code":"//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\nabstract contract ERC721Payable {\n  uint256 public mintFee;\n  IERC20 public payableToken;\n  bool public isForSale;\n  address public royaltyVault;\n  address public splitFactory;\n  event NewPayment(\n    address from,\n    address to,\n    uint256 amount,\n    bool royaltyVaultPayment\n  );\n\n  // ---------------- MODIFIER ----------------\n\n  modifier onlyVaultUninitialized() {\n    require(\n      !royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault already initialized'\n    );\n    _;\n  }\n\n  modifier onlyVaultInitialized() {\n    require(\n      royaltyVaultInitialized(),\n      'CoreCollection: Royalty Vault not initialized'\n    );\n    _;\n  }\n\n  // ---------------- VIEW ----------------\n\n  function royaltyVaultInitialized() public view returns (bool) {\n    return royaltyVault != address(0);\n  }\n\n  // ---------------- INTERNAL ----------------\n\n  /**\n   * @notice Handles the transfer of ERC20 tokens when a token gets minted\n   * @dev Tokens are transferred to the Royalty Vault if the vault is set\n   * Otherwise, tokens get transferred to the ERC721 collection contract\n   * @param _amount The amount of ERC20 to be transferred\n   */\n  function _handlePayment(uint256 _amount) internal {\n    address recipient = royaltyVaultInitialized()\n      ? royaltyVault\n      : address(this);\n    payableToken.safeTransferFrom(msg.sender,recipient,_amount);\n    emit NewPayment(msg.sender, recipient, _amount, royaltyVaultInitialized());\n  }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fixed_return_28",
                "Location": "",
                "Type": "unchecked return",
                "Description": "",
                "Repair": ""
            }
        ]
    }

]