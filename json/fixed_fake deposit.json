[
    {
        "Code": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface ERC20Interface {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Base is ERC20Interface {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    // constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(_balances[msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        _balances[msg.sender] -= _value;\n        _balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        _balances[_to] += _value;\n        _balances[_from] -= _value;\n        _allowances[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract Token is ERC20Base {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = initialSupply;\r\n        _balances[msg.sender] = initialSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_1",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address who) public view returns (uint value);\n    function allowance(address owner, address spender) public view returns (uint remaining);\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\n    function approve(address spender, uint value) public returns (bool ok);\n    function transfer(address to, uint value) public returns (bool ok);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract VERSO is ERC20{\n    uint8 public constant decimals = 18;\n    uint256 initialSupply = 100000000*10**uint256(decimals);\n    string public constant name = \"VERSO\";\n    string public constant symbol = \"VSO\";\n\n    address payable teamAddress;\n\n    function totalSupply() public view returns (uint256) {\n        return initialSupply;\n    }\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    \n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint remaining) {\n        return allowed[owner][spender];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(balances[msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        require(balances[from] >= value && allowed[from][msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[to] += value;\n        balances[from] -= value;\n        allowed[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    \n     function () external payable {\n        teamAddress.transfer(msg.value);\n    }\n\n    constructor () public payable {\n        teamAddress = msg.sender;\n        balances[teamAddress] = initialSupply;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_2",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\n\ncontract Token {\n    function totalSupply() constant returns (uint256 supply) {}\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is Token {\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n}\n\ncontract Nameless is StandardToken {\n    function () {\n        revert();\n    }\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    string public version = 'H1.0';\n\n    function Nameless() {\n        balances[msg.sender] = 99983740000000000000000000;\n        totalSupply = 107975610000000000000000000;\n        name = \"Nameless\";\n        decimals = 18;\n        symbol = \"NXN\";\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_3",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\n\n\n\ncontract ERC20 {\n\n    function totalSupply() public view returns (uint supply);\n\n    function balanceOf(address who) public view returns (uint value);\n\n    function allowance(address owner, address spender) public view returns (uint remaining);\n\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\n\n    function approve(address spender, uint value) public returns (bool ok);\n\n    function transfer(address to, uint value) public returns (bool ok);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n}\n\n\n\ncontract EthereumIceCream is ERC20{\n\n    uint8 public constant decimals = 18;\n\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n\n    string public constant name = \"Ethereum Ice Cream\";\n\n    string public constant symbol = \"ETHICE 🍨\";\n\n\n\n    address payable teamAddress;\n\n\n\n    function totalSupply() public view returns (uint256) {\n\n        return initialSupply;\n\n    }\n\n    mapping (address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowed;\n\n    \n\n    function balanceOf(address owner) public view returns (uint256 balance) {\n\n        return balances[owner];\n\n    }\n\n\n\n    function allowance(address owner, address spender) public view returns (uint remaining) {\n\n        return allowed[owner][spender];\n\n    }\n\n\n\n    function transfer(address to, uint256 value) public returns (bool success) {\n\n        require(balances[msg.sender] >= value && value > 0, \"Transfer condition not met\");\n\n        balances[msg.sender] -= value;\n\n        balances[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n\n        return true;\n\n    }\n\n\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n\n        require(balances[from] >= value && allowed[from][msg.sender] >= value && value > 0, \"Transfer condition not met\");\n\n        balances[to] += value;\n\n        balances[from] -= value;\n\n        allowed[from][msg.sender] -= value;\n\n        emit Transfer(from, to, value);\n\n        return true;\n\n    }\n\n\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n\n        allowed[msg.sender][spender] = value;\n\n        emit Approval(msg.sender, spender, value);\n\n        return true;\n\n    }\n\n    \n\n    function () external payable {\n\n        teamAddress.transfer(msg.value);\n\n    }\n\n\n\n    constructor () public payable {\n\n        teamAddress = msg.sender;\n\n        balances[teamAddress] = initialSupply;\n\n    }\n\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_4",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.8.0;\n\ncontract ERC20Interface {\n    \n    /// @return supply total amount of tokens\n    function totalSupply() public virtual view returns (uint256 supply) {}\n\n    /// @param tokenOwner The address from which the balance will be retrieved\n    /// @return balance The balance\n    function balanceOf(address tokenOwner) public virtual view returns (uint256 balance) {}\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) public virtual returns (bool success) {}\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool success) {}\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public virtual returns (bool success) {}\n\n    /// @param tokenOwner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address tokenOwner, address _spender) public virtual view returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is ERC20Interface {\n    uint256 public _totalSupply;\n    \n    mapping (address => uint256) balances;\n    //[tokenOwner][spender] = value\n    //tokenOwner allows the spender to spend *value* of tokenOwner money\n    mapping (address => mapping (address => uint256)) allowed;\n    \n    function transfer(address _to, uint256 _value) public override returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n        require(balances\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_5",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\n\ncontract Token {\n    function totalSupply() constant returns (uint256 supply) {}\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is Token {\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n}\n\ncontract AnalCoin is StandardToken {\n    function () {\n        revert();\n    }\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    string public version = '1.1.3';\n\n    function AnalCoin() {\n        balances[msg.sender] = 500000000000000000000000000;\n        totalSupply = 500000000000000000000000000;\n        name = \"CoinDev.io\";\n        decimals = 18;\n        symbol = \"ANAL\";\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n        return true\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_6",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\n\ncontract Token {\n    function totalSupply() constant returns (uint256 supply) {}\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n}\n\ncontract Nameless is StandardToken {\n\n    function () {\n        throw;\n    }\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    string public version = 'H1.0';\n\n    function Nameless() {\n        balances[msg.sender] = 99983740000000000000000000;\n        totalSupply = 107975610000000000000000000;\n        name = \"Nameless\";\n        decimals = 18;\n        symbol = \"NXN\";\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_7",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.20;\n\ncontract Token {\n    function totalSupply() constant returns (uint256 supply) {}\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is Token {\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n}\n\ncontract HAZARDToken is StandardToken {\n    function () {\n        revert();\n    }\n\n    string public name;                   \n    uint8 public decimals;                \n    string public symbol;                 \n    string public version = 'H1.0';\n\n    function HAZARDToken() {\n        balances[msg.sender] = 100000000000000;\n        totalSupply = 100000000000000;\n        name = \"HAZARD\";                                   \n        decimals = 8;\n        symbol = \"HAZARD\";\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {\nthrow; }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_8",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n    function totalSupply() constant returns (uint256 supply) {}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n}\n\ncontract MemePetToken is StandardToken { \n\n    string public name;                   \n    uint8 public decimals;                \n    string public symbol;                 \n    string public version = 'PET1.0'; \n    uint256 public unitsOneEthCanBuy;     \n    uint256 public totalEthInWei;         \n    address public fundsWallet;\n\nfunction MemePetToken() {\n    balances[msg.sender] = 100000000000000000000000000000;\n    totalSupply = 100000000000000000000000000000;\n    name = \"MemePet Token\";\n    decimals = 18;\n    symbol = \"PET\";\n    unitsOneEthCanBuy = 0;\n    fundsWallet = msg.sender;\n}\n\nfunction() payable{\n    totalEthInWei = totalEthInWei + msg.value;\n    uint256 amount = msg.value * unitsOneEthCanBuy;\n    require(balances[fundsWallet] >= amount, \"Insufficient balance in fundsWallet for the transfer\");\n    require(totalSupply >= amount, \"Insufficient total supply for the transfer\");\n\n    balances[fundsWallet] = balances[fundsWallet] - amount;\n    balances[msg.sender] = balances[msg.sender] + amount;\n\n    Transfer(fundsWallet, msg.sender, amount);\n\n    fundsWallet.transfer(msg.value);\n}\n\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n\n    if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n    return true;\n}\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_9",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\n\ncontract Token {\n    function totalSupply() constant returns (uint256 supply) {}\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n    function () {\n        revert();\n    }\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    string public version = 'H1.0';       \n\n    function ERC20Token() {\n        balances[msg.sender] = 1000000000000000000;\n        totalSupply = 1000000000000000000;\n        name = \"OAK\";\n        decimals = 8;\n        symbol = \"OAK\";\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n\n        require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_10",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address who) public view returns (uint value);\n    function allowance(address owner, address spender) public view returns (uint remaining);\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\n    function approve(address spender, uint value) public returns (bool ok);\n    function transfer(address to, uint value) public returns (bool ok);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ElonTweets is ERC20{\n    uint8 public constant decimals = 18;\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n    string public constant name = \"Elon Tweets\";\n    string public constant symbol = \"ELONT 🐦\";\n\n    address payable teamAddress;\n\n    function totalSupply() public view returns (uint256) {\n        return initialSupply;\n    }\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    \n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint remaining) {\n        return allowed[owner][spender];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(balances[msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        require(balances[from] >= value && allowed[from][msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[to] += value;\n        balances[from] -= value;\n        allowed[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowed[msg.sender][\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_11",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'ShibaInuBadger' token contract\n//\n// Symbol      : SHIB 🦡\n// Name        : Shiba Inu Badger\n// Total supply: 100000000000000\n// Decimals    : 18\n// Burned      : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address who) public view returns (uint value);\n    function allowance(address owner, address spender) public view returns (uint remaining);\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\n    function approve(address spender, uint value) public returns (bool ok);\n    function transfer(address to, uint value) public returns (bool ok);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ShibaInuBadger is ERC20{\n    uint8 public constant decimals = 18;\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n    string public constant name = \"Shiba Inu Badger\";\n    string public constant symbol = \"SHIB 🦡\";\n\n    address payable teamAddress;\n\n    function totalSupply() public view returns (uint256) {\n        return initialSupply;\n    }\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    \n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n    function allowance(address owner, address spender) public view returns (uint remaining) {\n        return allowed[owner][spender];\n    }\n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(balances[msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        require(balances[from] >= value && allowed[from][msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[to] += value;\n        balances[from] -= value;\n        allowed[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n     function () external payable {\n        teamAddress.transfer(msg.value);\n    }\n    constructor () public payable {\n        teamAddress = msg.sender;\n        balances[teamAddress] = initialSupply;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_12",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n    function totalSupply() constant returns (uint256 supply) {}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n}\n\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n    function () {\n        revert();\n    }\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    string public version = 'H1.0';\n\n    function ERC20Token() {\n        balances[msg.sender] = 1000000000;\n        totalSupply = 1000000000;\n        name = \"Can Swap\";\n        decimals = 0;\n        symbol = \"CAN\";\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { \n            revert(); \n        }\n        return true;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_13",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'McAfeeGhost' token contract\n//\n// Symbol      : AGHOST 👻\n// Name        : McAfee Ghost\n// Total supply: 100,000,000,000,000\n// Decimals    : 18\n// Burned      : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address who) public view returns (uint value);\n    function allowance(address owner, address spender) public view returns (uint remaining);\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\n    function approve(address spender, uint value) public returns (bool ok);\n    function transfer(address to, uint value) public returns (bool ok);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract McAfeeGhost is ERC20{\n    uint8 public constant decimals = 18;\n    uint256 initialSupply = 100000000000000*10**uint256(decimals);\n    string public constant name = \"McAfee Ghost\";\n    string public constant symbol = \"AGHOST 👻\";\n\n    address payable teamAddress;\n\n    function totalSupply() public view returns (uint256) {\n        return initialSupply;\n    }\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    \n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint remaining) {\n        return allowed[owner][spender];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(balances[msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        require(balances[from] >= value && allowed[from][msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[to] += value;\n        balances[from] -= value;\n        allowed[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function () external payable {\n        teamAddress.transfer(msg.value);\n    }\n\n    constructor () public payable {\n        teamAddress = msg.sender;\n        balances[teamAddress] = initialSupply;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_14",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n    function totalSupply() constant returns (uint256 supply) {}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    \n}\n\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n    function () {\n        revert();\n    }\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    string public version = 'H1.0';\n\n    function ERC20Token(\n        ) {\n        balances[msg.sender] = 10000000;\n        totalSupply = 10000000;\n        name = \"Nude NFT\";\n        decimals = 0;\n        symbol = \"NUDE\";\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_15",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address who) public view returns (uint value);\n    function allowance(address owner, address spender) public view returns (uint remaining);\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\n    function approve(address spender, uint value) public returns (bool ok);\n    function transfer(address to, uint value) public returns (bool ok);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract SpongebobSquarepantsToken is ERC20{\n    uint8 public constant decimals = 18;\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n    string public constant name = \"Spongebob Squarepants Token\";\n    string public constant symbol = \"SPONGE 🧽\";\n\n    address payable teamAddress;\n\n    function totalSupply() public view returns (uint256) {\n        return initialSupply;\n    }\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    \n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint remaining) {\n        return allowed[owner][spender];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(balances[msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        require(balances[to] + value >= balances[to], \"Overflow error\");\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        require(balances[from] >= value && allowed[from][msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        require(balances[to] + value >= balances[to], \"Overflow error\");\n        balances[to] += value;\n        balances[from] -= value;\n        allowed[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    \n     function () external payable {\n        teamAddress.transfer(msg.value);\n    }\n\n    constructor () public payable {\n        teamAddress = msg.sender;\n        balances[teamAddress] = initialSupply;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_16",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address who) public view returns (uint value);\n    function allowance(address owner, address spender) public view returns (uint remaining);\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\n    function approve(address spender, uint value) public returns (bool ok);\n    function transfer(address to, uint value) public returns (bool ok);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Teenage_Mutant_Ninja_Turtles_Finance is ERC20{\n    uint8 public constant decimals = 18;\n    uint256 initialSupply = 2100000*10**uint256(decimals);\n    string public constant name = \"Teenage Mutant Ninja Turtles Finance\";\n    string public constant symbol = \"TMNT\";\n\n    address payable teamAddress;\n\n    function totalSupply() public view returns (uint256) {\n        return initialSupply;\n    }\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    \n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint remaining) {\n        return allowed[owner][spender];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(balances[msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        require(balances[from] >= value && allowed[from][msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[to] += value;\n        balances[from] -= value;\n        allowed[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    constructor () public payable {\n        teamAddress = msg.sender;\n        balances[teamAddress] = initialSupply;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_17",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.4.11;\n\nlibrary SafeMath {\n  function mul(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint a, uint b) internal returns (uint) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function assert(bool assertion) internal {\n    if (!assertion) {\n      throw;\n    }\n  }\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20Basic  {\n    uint public totalSupply;\n    function balanceOf(address _owner) constant returns (uint balance);\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n}\n  \n /**\n * @title Standard ERC20 token\n *\n * @dev Implemantation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */ \n  \ncontract ERC20 is ERC20Basic {\n    function approve(address _spender, uint _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract StandardToken is ERC20 {\n        using SafeMath for uint;\n\n    function transfer(address _to, uint _value) returns (bool) {\n     \n        reqire (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\n        reqire(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint _value) returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint) {\n        return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint) balances;\n    mapping (address => mapping (address => uint)) allowed;\n    uint public totalSupply;\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    if (msg.sender != owner) {\n      throw;\n    }\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner {\n    if (newOwner != address(0)) {\n      owner = newOwner;\n    }\n  }\n\n}\n\n/**\n * @title Bitcoin Moon Token contract\n */\ncontract BitcoinMoonToken is StandardToken, Ownable {\n\n    uint8 public decimals = 18;\n    uint public totalSupply = 50000000000 * 10 ** 18;\n    string public name = \"Bitcoin Moon Token\";\n    string public symbol = \"BMNT\";\n\n    function BitcoinMoonToken() {\n        balances[msg.sender] = totalSupply;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_18",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.4.19;\n\ncontract Token {\n    function totalSupply() constant returns (uint supply) {}\n    function balanceOf(address _owner) constant returns (uint balance) {}\n    function transfer(address _to, uint _value) returns (bool success) {}\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n    function approve(address _spender, uint _value) returns (bool success) {}\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n    function transfer(address _to, uint _value) returns (bool) {\n        require(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to], \"Transfer condition not met\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to], \"Transfer condition not met\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint _value) returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint) {\n        return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint) balances;\n    mapping (address => mapping (address => uint)) allowed;\n    uint public totalSupply;\n}\n\ncontract UnboundedRegularToken is RegularToken {\n\n    uint constant MAX_UINT = 2**256 - 1;\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        uint allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value && balances[_to] + _value >= balances[_to], \"Transfer condition not met\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        Transfer(_from, _to, _value);\n        return true;\n    }\n}\n\ncontract STToken is UnboundedRegularToken {\n\n    uint public totalSupply = 33*10**25;\n    uint8 constant public decimals = 18;\n    string constant public name = \"StarToken\";\n    string constant public symbol = \"ST\";\n\n    function STToken() {\n        balances[msg.sender] = totalSupply;\n        Transfer(address(0), msg.sender, totalSupply);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_19",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.5.0;\n\ninterface ERC20Interface {\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n\n    mapping (address => uint256) public _balances;\n    mapping (address => mapping (address => uint256)) public _allowances;\n    uint256 public _totalSupply;\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(_balances[msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        _balances[msg.sender] -= _value;\n        _balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        _balances[_to] += _value;\n        _balances[_from] -= _value;\n        _allowances[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return _balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        _allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n      return _allowances[_owner][_spender];\n    }\n    \n    function totalSupply() public view returns (uint256 total) {\n        return _totalSupply;\n    }\n}\n\ncontract SYSP is ERC20Base {\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    \n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n        _totalSupply = initialSupply;\n        _balances[msg.sender] = initialSupply;\n    }\n\n ",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_20",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address who) public view returns (uint value);\n    function allowance(address owner, address spender) public view returns (uint remaining);\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\n    function approve(address spender, uint value) public returns (bool ok);\n    function transfer(address to, uint value) public returns (bool ok);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract KitsuneInu is ERC20{\n    uint8 public constant decimals = 18;\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n    string public constant name = \"Kitsune Inu\";\n    string public constant symbol = \"KITSUNE\";\n\n    address payable teamAddress;\n\n    function totalSupply() public view returns (uint256) {\n        return initialSupply;\n    }\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    \n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint remaining) {\n        return allowed[owner][spender];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(balances[msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        require(balances[from] >= value && allowed[from][msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[to] += value;\n        balances[from] -= value;\n        allowed[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    \n     function () external payable {\n        teamAddress.transfer(msg.value);\n    }\n\n    constructor () public payable {\n        teamAddress = msg.sender;\n        balances[teamAddress] = initialSupply;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_21",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\n\ncontract Token {\n    function totalSupply() constant returns (uint256 supply) {}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is Token {\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0, \"Transfer condition not met\");\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n    function () {\n        throw;\n    }\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    string public version = 'H1.0';\n\n    function ERC20Token(\n        ) {\n        balances[msg.sender] = 1000000000;\n        totalSupply = 1000000000;\n        name = \"Boob Token\";\n        decimals = 0;\n        symbol = \"BOOB\";\n    }}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_22",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.4.22 <0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address who) public view returns (uint value);\n    function allowance(address owner, address spender) public view returns (uint remaining);\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\n    function approve(address spender, uint value) public returns (bool ok);\n    function transfer(address to, uint value) public returns (bool ok);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ShibaBacon is ERC20{\n    using SafeMath for uint256;\n\n    uint8 public constant decimals = 18;\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n    string public constant name = \"Shiba Bacon\";\n    string public constant symbol = \"INU 🥓\";\n\n    address payable teamAddress;\n\n    function totalSupply() public view returns (uint256) {\n        return initialSupply;\n    }\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    \n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n    function allowance(address owner, address spender) public view returns (uint remaining) {\n        return allowed[owner][spender];\n    }\n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(to != address(0), \"Cannot transfer to the zero address\");\n        require(balances[msg.sender] >= value, \"Insufficient balance\");\n\n        balances[msg.sender] = balances[msg.sender].sub(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        require(to != address(0), \"Cannot transfer to the zero address\");\n        require(balances[from] >= value, \"Insufficient balance\");\n        require(allowed[from][msg.sender] >= value, \"Insufficient allowance\");\n\n        balances[from] = balances[from].sub(value);\n        balances[to] = balances[to].add(value);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n        emit Transfer(from, to, value);\n        return true;\n    }\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender,spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_23",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\n\ncontract Token {\n    function totalSupply() constant returns (uint256 supply) {}\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is Token {\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n    function () {\n        revert();\n    }\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    string public version = 'H1.0';\n\n    function ERC20Token() {\n        balances[msg.sender] = 1000000000;\n        totalSupply = 1000000000;\n        name = \"taco.finance\";\n        decimals = 0;\n        symbol = \"TACO\";\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {throw; }\r\n        return true;\r\n    }\r\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_24",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.4.4;\n\ncontract Token {\n    function totalSupply() constant returns (uint256 supply) {}\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is Token {\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n    function () {\n        revert();\n    }\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    string public version = 'H1.0';\n\n    function ERC20Token() {\n        balances[msg.sender] = 1000000000;\n        totalSupply = 1000000000;\n        name = \"taco.finance\";\n        decimals = 0;\n        symbol = \"TACO\";\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address who) public view returns (uint value);\n    function allowance(address owner, address spender) public view returns (uint remaining);\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\n    function approve(address spender, uint value) public returns (bool ok);\n    function transfer(address to, uint value) public returns (bool ok);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract EthereumCyberPunks is ERC20{\n    uint8 public constant decimals = 18;\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n    string public constant name = \"Ethereum Cyber Punks\";\n    string public constant symbol = \"EPUNK 🖫\";\n\n    address payable teamAddress;\n\n    function totalSupply() public view returns (uint256) {\n        return initialSupply;\n    }\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    \n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n    function allowance(address owner, address spender) public view returns (uint remaining) {\n        return allowed[owner][spender];\n    }\n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(balances[msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        require(balances[from] >= value && allowed[from][msg.sender] >= value && value > 0, \"Transfer condition not met\");\n        balances[to] += value;\n        balances[from] -= value;\n        allowed[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    \n    constructor () public payable {\n        teamAddress = msg.sender;\n        balances[teamAddress] = initialSupply;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_dep_25",
                "Location": "",
                "Type": "fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    }
    
]