[
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport './interfaces/ISherClaim.sol';\nimport './interfaces/ISherlock.sol';\n\n/// @title Buy SHER tokens by staking USDC and paying USDC\n/// @author Evert Kors\n/// @dev The goal is to get TVL in Sherlock.sol and raise funds with `receiver`\n/// @dev Bought SHER tokens are moved to a timelock contract (SherClaim)\n/// @dev Admin should SHER tokens to the contract rounded by 0.01 SHER, otherwise logic will break.\ncontract SherBuy {\n  using SafeERC20 for IERC20;\n\n  error InvalidSender();\n  error InvalidAmount();\n  error ZeroArgument();\n  error InvalidState();\n  error SoldOut();\n\n  /// @notice Emitted when SHER purchase is executed\n  /// @param buyer Account that bought SHER tokens\n  /// @param amount How much SHER tokens are bought\n  /// @param staked How much USDC is staked\n  /// @param paid How much USDC is paid\n  event Purchase(address indexed buyer, uint256 amount, uint256 staked, uint256 paid);\n\n  // The staking period used for the staking USDC\n  uint256 public constant PERIOD = 26 weeks;\n  // Allows purchases in steps of 0.01 SHER\n  uint256 internal constant SHER_STEPS = 10**16;\n  // Allows stakeRate and buyRate with steps of 0.01 USDC\n  uint256 internal constant RATE_STEPS = 10**4;\n  // SHER has 18 decimals\n  uint256 internal constant SHER_DECIMALS = 10**18;\n\n  // SHER token address (18 decimals)\n  IERC20 public immutable sher;\n  // USDC token address (6 decimals)\n  IERC20 public immutable usdc;\n\n  // 10**6 means for every 1 SHER token you want to buy, you will stake 1 USDC (10**7 means 1 SHER for 10 USDC)\n  uint256 public immutable stakeRate;\n  // 10**6 means for every 1 SHER token you want to buy, you will pay 1 USDC (10**7 means 1 SHER for 10 USDC)\n  uint256 public immutable buyRate;\n  // The `Sherlock.sol` contract that is a ERC721\n  ISherlock public immutable sherlockPosition;\n  // Address receiving the USDC payments\n  address public immutable receiver;\n  // Contract to claim SHER at\n  ISherClaim public immutable sherClaim;\n\n  /// @notice Construct BuySher contract\n  /// @param _sher ERC20 contract for SHER token\n  /// @param _usdc ERC20 contract for USDC token\n  /// @param _stakeRate Rate at which SHER tokens translate to the amount of USDC needed to be staked\n  /// @param _buyRate Rate at which SHER tokens translate to the amount of USDC needed to be paid\n  /// @param _sherlockPosition ERC721 contract of Sherlock positions\n  /// @param _receiver Address that receives USDC from purchases\n  /// @param _sherClaim Contract that keeps the SHER timelocked\n  constructor(\n    IERC20 _sher,\n    IERC20 _usdc,\n    uint256 _stakeRate,\n    uint256 _buyRate,\n    ISherlock _sherlockPosition,\n    address _receiver,\n    ISherClaim _sherClaim\n  ) {\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_usdc) == address(0)) revert ZeroArgument();\n    if (_stakeRate == 0) revert ZeroArgument();\n    if (_stakeRate % RATE_STEPS != 0) revert InvalidState();\n    if (_buyRate == 0) revert ZeroArgument();\n    if (_buyRate % RATE_STEPS != 0) revert InvalidState();\n    if (address(_sherlockPosition) == address(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    if (address(_sherClaim) == address(0)) revert ZeroArgument();\n\n    // Verify is PERIOD is active\n    // Theoretically this period can be disabled during the lifetime of this contract, which will cause issues\n    if (_sherlockPosition.stakingPeriods(PERIOD) == false) revert InvalidState();\n\n    sher = _sher;\n    usdc = _usdc;\n    stakeRate = _stakeRate;\n    buyRate = _buyRate;\n    sherlockPosition = _sherlockPosition;\n    receiver = _receiver;\n    sherClaim = _sherClaim;\n\n    // Do max approve in constructor as this contract will not hold any USDC\n    usdc.approve(address(sherlockPosition), type(uint256).max);\n  }\n\n  /// @notice Check if the liquidity event is active\n  /// @dev SHER tokens can run out while event is active\n  /// @return True if the liquidity event is active\n  function active() public view returns (bool) {\n    // The claim contract will become active once the liquidity event is inactive\n    return block.timestamp < sherClaim.claimableAt();\n  }\n\n  /// @notice View the capital requirements needed to buy up until `_sherAmountWant`\n  /// @dev Will adjust to remaining SHER if `_sherAmountWant` exceeds that\n  /// @return sherAmount Will adjust to remining SHER if `_sherAmountWant` exceeds that\n  /// @return stake How much USDC needs to be staked for `PERIOD` of time to buy `sherAmount` SHER\n  /// @return price How much USDC needs to be paid to buy `sherAmount` SHER\n  function viewCapitalRequirements(uint256 _sherAmountWant)\n    public\n    view\n    returns (\n      uint256 sherAmount,\n      uint256 stake,\n      uint256 price\n    )\n  {\n    // Only allow if liquidity event is active\n    if (active() == false) revert InvalidState();\n    // Zero isn't allowed\n    if (_sherAmountWant == 0) revert ZeroArgument();\n\n    // View how much SHER is still available to be sold\n    uint256 available = sher.balanceOf(address(this));\n    // If remaining SHER is 0 it's sold out\n    if (available == 0) revert SoldOut();\n\n    // Use remaining SHER if it's less then `_sherAmountWant`, otherwise go for `_sherAmountWant`\n    // Remaining SHER will only be assigned on the last sale of this contract, `SoldOut()` error will be thrown after\n    // sherAmount is not able to be zero as both 'available' and '_sherAmountWant' will be bigger than 0\n    sherAmount = available < _sherAmountWant ? available : _sherAmountWant;\n    // Only allows SHER amounts with certain precision steps\n    // To ensure there is no rounding error at loss for the contract in stake / price calculation\n    // Theoretically, if `available` is used, the function can fail if '% SHER_STEPS != 0' will be true\n    // This can be caused by a griefer sending a small amount of SHER to the contract\n    // Realistically, no SHER tokens will be on the market when this function is active\n    // So it can only be caused if the admin sends too small amounts (documented at top of file with @dev)\n    if (sherAmount % SHER_STEPS != 0) revert InvalidAmount();\n\n    // Calculate how much USDC needs to be staked to buy `sherAmount`\n    stake = (sherAmount * stakeRate) / SHER_DECIMALS;\n    // Calculate how much USDC needs to be paid to buy `sherAmount`\n    price = (sherAmount * buyRate) / SHER_DECIMALS;\n  }\n\n  /// @notice Buy up until `_sherAmountWant`\n  /// @param _sherAmountWant The maximum amount of SHER the user wants to buy\n  /// @dev Bought SHER tokens are moved to a timelock contract (SherClaim)\n  /// @dev Will revert if liquidity event is inactive because of the viewCapitalRequirements call\n  function execute(uint256 _sherAmountWant) external {\n    // Calculate the capital requirements\n    // Check how much SHER can actually be bought\n    (uint256 sherAmount, uint256 stake, uint256 price) = viewCapitalRequirements(_sherAmountWant);\n\n    // Transfer usdc from user to this, for staking (max is approved in constructor)\n    usdc.safeTransferFrom(msg.sender, address(this), stake);\n    // Transfer usdc from user to receiver, for payment of the SHER\n    usdc.safeTransferFrom(msg.sender, receiver, price);\n\n    // Stake usdc and send NFT to user\n    sherlockPosition.initialStake(stake, PERIOD, msg.sender);\n    // Approve in function as this contract will hold SHER tokens\n    sher.approve(address(sherClaim), sherAmount);\n    // Add bought SHER tokens to timelock for user\n    sherClaim.add(msg.sender, sherAmount);\n\n    // Emit event about the purchase\n    emit Purchase(msg.sender, sherAmount, stake, price);\n  }\n\n  /// @notice Rescue remaining ERC20 tokens when liquidity event is inactive\n  /// @param _tokens Array of ERC20 tokens to rescue\n  /// @dev Can only be called by `receiver`\n  function sweepTokens(IERC20[] memory _tokens) external {\n    if (msg.sender != receiver) revert InvalidSender();\n    if (active()) revert InvalidState();\n\n    // Loops through the extra tokens (ERC20) provided and sends all of them to the sender address\n    for (uint256 i; i < _tokens.length; i++) {\n      IERC20 token = _tokens[i];\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "SherBuy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "ERC"
                ],
                "Type": " first user can steal everyone else's tokens",
                "Description": "\nA user who joins the systems first (stakes first) can steal everybody's tokens by sending tokens to the system externally.\nThis attack is possible because you enable staking a small amount of tokens.\n\n\nSee the following attack:\n\n1.  the first user (user A) who enters the system stake 1 token\n2.  another user (user B) is about to stake X tokens\n3.  user A frontrun and transfer X tokens to the system via ERC20.transfer\n4.  user B stakes X tokens, and the shares he receives is:\n\nshares = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() _amount);\nshares = (X * 1) / (X + 1 + X X) = X/(X+1) = 0 meaning all the tokens he staked got him no shares, and those tokens are now a part of the single share that user A holds\n5. user A can now redeem his shares and get the 1 token he staked, the X tokens user B staked, and the X tokens he ERC20.transfer to the system because all the money in the system is in a single share that user A holds.\n\nIn general, since there is only a single share, for any user who is going to stake X tokens, if the system has X+1 tokens in its balance, the user won't get any shares and all the money will go to the attacker.\n\n",
                "Repair": "\nForce users to stake at least some amount in the system (Uniswap forces users to pay at least 1e18)\nThat way the amount the attacker will need to ERC20.transfer to the system will be at least X*1e18 instead of X which is unrealistic\n\nEvert0x (Sherlock) confirmed and commented(https://github.com/code-423n4/2022-01-sherlock-findings/issues/39#issuecomment-1029438483):\n  Thanks. I agree it's an issue that could theoretically affect all deposits.\n\nEvert0x (Sherlock) resolved(https://github.com/code-423n4/2022-01-sherlock-findings/issues/39)\n\n\n\n*\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport './callbacks/ISherlockClaimManagerCallbackReceiver.sol';\nimport '../UMAprotocol/OptimisticRequester.sol';\nimport './IManager.sol';\n\ninterface ISherlockClaimManager is IManager, OptimisticRequester {\n  // Doesn't allow a new claim to be submitted by a protocol agent if a claim is already active for that protocol\n  error ClaimActive();\n\n  // If the current state of a claim does not match the expected state, this error is thrown\n  error InvalidState();\n\n  event ClaimCreated(\n    uint256 claimID,\n    bytes32 indexed protocol,\n    uint256 amount,\n    address receiver,\n    bool previousCoverageUsed\n  );\n\n  event CallbackAdded(ISherlockClaimManagerCallbackReceiver callback);\n\n  event CallbackRemoved(ISherlockClaimManagerCallbackReceiver callback);\n\n  event ClaimStatusChanged(uint256 indexed claimID, State previousState, State currentState);\n\n  event ClaimPayout(uint256 claimID, address receiver, uint256 amount);\n\n  event ClaimHalted(uint256 claimID);\n\n  event UMAHORenounced();\n\n  enum State {\n    NonExistent, // Claim doesn't exist (this is the default state on creation)\n    SpccPending, // Claim is created, SPCC is able to set state to valid\n    SpccApproved, // Final state, claim is valid\n    SpccDenied, // Claim denied by SPCC, claim can be escalated within 4 weeks\n    UmaPriceProposed, // Price is proposed by not escalated\n    ReadyToProposeUmaDispute, // Price is proposed, callback receiver, ready to submit dispute\n    UmaDisputeProposed, // Escaltion is done, waiting for confirmation\n    UmaPending, // Claim is escalated, in case Spcc denied or didn't act within 7 days.\n    UmaApproved, // Final state, claim is valid, claim can be enacted after 1 day, umaHaltOperator has 1 day to change to denied\n    UmaDenied, // Final state, claim is invalid\n    Halted, // UMHA can halt claim if state is UmaApproved\n    Cleaned // Claim is removed by protocol agent\n  }\n\n  struct Claim {\n    uint256 created;\n    uint256 updated;\n    address initiator;\n    bytes32 protocol;\n    uint256 amount;\n    address receiver;\n    uint32 timestamp;\n    State state;\n    bytes ancillaryData;\n  }\n\n  // requestAndProposePriceFor() --> proposer = protocolAgent\n  // disputePriceFor() --> disputor = sherlock.strategyManager() (current active one)\n  // priceSettled will be the the callback that contains the main data\n\n  // user has to pay 7.5k to dispute a claim, we will execute a safeTransferFrom(user, address(this), 7.5k)\n  // we need to approve the contract 7.5k as it will be transferred from address(this)  // + 2x final fee\n  // the bond will be 5k on requestAndProposePriceFor()                                 // + 1x final fee\n  // the bond will be 2.5k on disputePriceFor()                                         // + 1x final fee\n  // on settle eiter strategy gets 7.5k. or the proposer get their bond back.           // + 1x final fee\n\n  // lastClaimID <-- starts with 0, so initial id = 1\n  // have claim counter, easy to identify certain clams by their number\n  // but use hash(callback.request.propose + callback.timestamp) as the internal UUID to handle the callbacks\n\n  // So SPCC and UHO are hardcoded (UHO can be renounced)\n  // In case these need to be updated, deploy different contract and upgrade it on the sherlock gov side.\n\n  // On price proposed callback --> call disputePriceFor with callbackdata + sherlock.strategyManager() and address(this)\n\n  /// @notice `SHERLOCK_CLAIM` in utf8\n  function UMA_IDENTIFIER() external view returns (bytes32);\n\n  function sherlockProtocolClaimsCommittee() external view returns (address);\n\n  /// @notice operator is able to deny approved UMA claims\n  function umaHaltOperator() external view returns (address);\n\n  /// @notice gov is able to renounce the role\n  function renounceUmaHaltOperator() external;\n\n  function claim(uint256 _claimID) external view returns (Claim memory);\n\n  /// @notice Initiate a claim for a specific protocol as the protocol agent\n  /// @param _protocol protocol ID (different from the internal or public claim ID fields)\n  /// @param _amount amount of USDC which is being claimed by the protocol\n  /// @param _receiver address to receive the amount of USDC being claimed\n  /// @param _timestamp timestamp at which the exploit first occurred\n  /// @param ancillaryData other data associated with the claim, such as the coverage agreement\n  /// @dev The protocol agent that starts a claim will be the protocol agent during the claims lifecycle\n  /// @dev Even if the protocol agent role is tranferred during the lifecycle\n  function startClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    uint32 _timestamp,\n    bytes memory ancillaryData\n  ) external;\n\n  function spccApprove(uint256 _claimID) external;\n\n  function spccRefuse(uint256 _claimID) external;\n\n  /// @notice Callable by protocol agent\n  /// @param _claimID Public claim ID\n  /// @param _amount Bond amount sent by protocol agent\n  /// @dev Use hardcoded USDC address\n  /// @dev Use hardcoded bond amount\n  /// @dev Use hardcoded liveness 7200 (2 hours)\n  /// @dev proposedPrice = _amount\n  function escalate(uint256 _claimID, uint256 _amount) external;\n\n  /// @notice Execute claim, storage will be removed after\n  /// @param _claimID Public ID of the claim\n  /// @dev Needs to be SpccApproved or UmaApproved && >UMAHO_TIME\n  /// @dev Funds will be pulled from core\n  function payoutClaim(uint256 _claimID) external;\n\n  /// @notice UMAHO is able to execute a halt if the state is UmaApproved and state was updated less than UMAHO_TIME ago\n  function executeHalt(uint256 _claimID) external;\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// This contract contains the logic for handling claims\n// The idea is that the first level of handling a claim is the Sherlock Protocol Claims Committee (SPCC)(a multisig)\n// If a protocol agent doesn't like that result, they can escalate the claim to UMA's Optimistic Oracle (OO), who will be the final decision\n// We also build in a multisig (controlled by UMA) to give the final approve to pay out after the OO approves a claim\n\nimport './Manager.sol';\nimport '../interfaces/managers/ISherlockClaimManager.sol';\nimport '../interfaces/managers/ISherlockProtocolManager.sol';\nimport '../interfaces/UMAprotocol/SkinnyOptimisticOracleInterface.sol';\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\n/// @dev expects 6 decimals input tokens\ncontract SherlockClaimManager is ISherlockClaimManager, ReentrancyGuard, Manager {\n  using SafeERC20 for IERC20;\n\n  // The bond required for a protocol agent to escalate a claim to UMA Optimistic Oracle (OO)\n  /// @dev at time of writing will result in a 20k cost of escalating\n  /// @dev the actual amount is based on the value returned here https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/Store.sol#L131\n  uint256 internal constant BOND = 9_600 * 10**6; // 20k bond\n\n  // The amount of time the protocol agent has to escalate a claim\n  uint256 public constant ESCALATE_TIME = 4 weeks;\n\n  // The UMA Halt Operator (UMAHO) is the multisig (controlled by UMA) who gives final approval to pay out a claim\n  // After the OO has voted to pay out\n  // This variable represents the amount of time during which UMAHO can block a claim that was approved by the OO\n  // After this time period, the claim (which was approved by the OO) is inferred to be approved by UMAHO as well\n  uint256 public constant UMAHO_TIME = 24 hours;\n\n  // The amount of time the Sherlock Protocol Claims Committee (SPCC) gets to decide on a claim\n  // If no action is taken by SPCC during this time, then the protocol agent can escalate the decision to the UMA OO\n  uint256 public constant SPCC_TIME = 7 days;\n\n  // A pre-defined amount of time for the proposed price ($0) to be disputed within the OO\n  // Note This value is not important as we immediately dispute the proposed price\n  // 7200 represents 2 hours\n  uint256 internal constant LIVENESS = 7200;\n\n  // This is how UMA will know that Sherlock is requesting a decision from the OO\n  // This is \"SHERLOCK_CLAIM\" in hex value\n  bytes32 public constant override UMA_IDENTIFIER =\n    bytes32(0x534845524c4f434b5f434c41494d000000000000000000000000000000000000);\n\n  uint256 public constant MAX_CALLBACKS = 4;\n\n  // The Optimistic Oracle contract that we interact with\n  SkinnyOptimisticOracleInterface public constant UMA =\n    SkinnyOptimisticOracleInterface(0xeE3Afe347D5C74317041E2618C49534dAf887c24);\n\n  // USDC\n  IERC20 public constant TOKEN = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n  // The address of the multisig controlled by UMA that can emergency halt a claim that was approved by the OO\n  address public override umaHaltOperator;\n  // The address of the multisig controlled by Sherlock advisors who make the first judgment on a claim\n  address public immutable override sherlockProtocolClaimsCommittee;\n\n  // Takes a protocol's internal ID as a key and whether or not the protocol has a claim active as the value\n  // Note Each protocol can only have one claim active at a time (this prevents spam)\n  mapping(bytes32 => bool) public protocolClaimActive;\n\n  // A protocol's public claim ID is simply incremented by 1 from the last claim ID made by any protocol (1, 2, 3, etc.)\n  // A protocol's internal ID is the keccak256() of a protocol's ancillary data field\n  // A protocol's ancillary data field will contain info like the hash of the protocol's coverage agreement (each will be unique)\n  // The public ID (1, 2, 3, etc.) is easy to track while the internal ID is used for interacting with UMA\n  mapping(uint256 => bytes32) internal publicToInternalID;\n\n  // Opposite of the last field, allows us to move between a protocol's public ID and internal ID\n  mapping(bytes32 => uint256) internal internalToPublicID;\n\n  // Protocol's internal ID is the key, active claim is the value\n  // Claim object is initialized in startClaim() below\n  // See ISherlockClaimManager.sol for Claim struct\n  mapping(bytes32 => Claim) internal claims_;\n\n  // The last claim ID we used for a claim (ID is incremented by 1 each time)\n  uint256 internal lastClaimID;\n\n  // A request object used in the UMA OO\n  SkinnyOptimisticOracleInterface.Request private umaRequest;\n\n  // An array of contracts that implement the callback provided in this contract\n  ISherlockClaimManagerCallbackReceiver[] public claimCallbacks;\n\n  // Used for callbacks on UMA functions\n  // This modifier is used for a function being called by the OO contract, requires this contract as caller\n  // Requires the OO contract to pass in the Sherlock identifier\n  modifier onlyUMA(bytes32 identifier) {\n    if (identifier != UMA_IDENTIFIER) revert InvalidArgument();\n    if (msg.sender != address(UMA)) revert InvalidSender();\n    _;\n  }\n\n  // Only the Sherlock Claims Committee multisig can call a function with this modifier\n  modifier onlySPCC() {\n    if (msg.sender != sherlockProtocolClaimsCommittee) revert InvalidSender();\n    _;\n  }\n\n  // Only the UMA Halt Operator multisig can call a function with this modifier\n  modifier onlyUMAHO() {\n    if (msg.sender != umaHaltOperator) revert InvalidSender();\n    _;\n  }\n\n  // We pass in the contract addresses (both will be multisigs) in the constructor\n  constructor(address _umaho, address _spcc) {\n    if (_umaho == address(0)) revert ZeroArgument();\n    if (_spcc == address(0)) revert ZeroArgument();\n\n    umaHaltOperator = _umaho;\n    sherlockProtocolClaimsCommittee = _spcc;\n  }\n\n  // Checks to see if a claim can be escalated to the UMA OO\n  // Claim must be either\n  // 1) Denied by SPCC and within 4 weeks after denial\n  // 2) Beyond the designated time window for SPCC to respond\n  function _isEscalateState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccDenied && block.timestamp <= updated + ESCALATE_TIME) return true;\n\n    uint256 spccDeadline = updated + SPCC_TIME;\n    if (\n      _oldState == State.SpccPending &&\n      spccDeadline < block.timestamp &&\n      block.timestamp <= spccDeadline + ESCALATE_TIME\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  // Checks to see if a claim can be paid out\n  // Will be paid out if:\n  // 1) SPCC approved it\n  // 2) UMA OO approved it and there is no UMAHO anymore\n  // 3) UMA OO approved it and the designated window for the UMAHO to block it has passed\n  function _isPayoutState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccApproved) return true;\n\n    // If there is no UMA Halt Operator, then it can be paid out on UmaApproved state\n    if (umaHaltOperator == address(0)) {\n      if (_oldState == State.UmaApproved) return true;\n    } else {\n      // If there IS a nonzero UMAHO address, must wait for UMAHO halt period to pass\n      if (_oldState == State.UmaApproved && updated + UMAHO_TIME < block.timestamp) return true;\n    }\n    return false;\n  }\n\n  function _isCleanupState(State _oldState) internal pure returns (bool) {\n    if (_oldState == State.SpccDenied) return true;\n    if (_oldState == State.SpccPending) return true;\n    return false;\n  }\n\n  // Deletes the data associated with a claim (after claim has reached its final state)\n  // _claimIdentifier is the internal claim ID\n  function _cleanUpClaim(bytes32 _claimIdentifier) internal {\n    // Protocol no longer has an active claim associated with it\n    delete protocolClaimActive[claims_[_claimIdentifier].protocol];\n    // Claim object is deleted\n    delete claims_[_claimIdentifier];\n\n    uint256 publicID = internalToPublicID[_claimIdentifier];\n    // Deletes the public and internal ID key mappings\n    delete publicToInternalID[publicID];\n    delete internalToPublicID[_claimIdentifier];\n  }\n\n  // Each claim has a state that represents what part of the claims process it is in\n  // _claimIdentifier is the internal claim ID\n  // _state represents the state to which a protocol's state field will be changed\n  // See ISherlockClaimManager.sol for the State enum\n  function _setState(bytes32 _claimIdentifier, State _state) internal returns (State _oldState) {\n    // retrieves the Claim object\n    Claim storage claim = claims_[_claimIdentifier];\n    // retrieves the current state (which we preemptively set to the old state)\n    _oldState = claim.state;\n\n    emit ClaimStatusChanged(internalToPublicID[_claimIdentifier], _oldState, _state);\n\n    // If the new state is NonExistent, then we clean up this claim (delete the claim effectively)\n    // Else we update the state to the new state and record the last updated timestamp\n    if (_state == State.NonExistent) {\n      _cleanUpClaim(_claimIdentifier);\n    } else {\n      claims_[_claimIdentifier].state = _state;\n      claims_[_claimIdentifier].updated = block.timestamp;\n    }\n  }\n\n  // Allows us to remove the UMA Halt Operator multisig address if we decide we no longer need UMAHO's services\n  /// @notice gov is able to renounce the role\n  function renounceUmaHaltOperator() external override onlyOwner {\n    if (umaHaltOperator == address(0)) revert InvalidConditions();\n\n    delete umaHaltOperator;\n    emit UMAHORenounced();\n  }\n\n  // Returns the Claim struct for a given claim ID (function takes public ID but converts to internal ID)\n  function claim(uint256 _claimID) external view override returns (Claim memory claim_) {\n    bytes32 id_ = publicToInternalID[_claimID];\n    if (id_ == bytes32(0)) revert InvalidArgument();\n\n    claim_ = claims_[id_];\n    if (claim_.state == State.NonExistent) revert InvalidArgument();\n  }\n\n  // This function allows a new contract to be added that will implement PreCorePayoutCallback()\n  // The intention of this callback is to allow other contracts to trigger payouts, etc. when Sherlock triggers one\n  // This would be helpful for a reinsurer who should pay out when Sherlock pays out\n  // Data is passed to the \"reinsurer\" so it can know if it should pay out and how much\n  /// @dev only add trusted and gas verified callbacks.\n  function addCallback(ISherlockClaimManagerCallbackReceiver _callback)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // Checks to see if the max amount of callback contracts has been reached\n    if (claimCallbacks.length == MAX_CALLBACKS) revert InvalidState();\n    // Checks to see if this callback contract already exists\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      if (claimCallbacks[i] == _callback) revert InvalidArgument();\n    }\n\n    claimCallbacks.push(_callback);\n    emit CallbackAdded(_callback);\n  }\n\n  // This removes a contract from the claimCallbacks array\n  function removeCallback(ISherlockClaimManagerCallbackReceiver _callback, uint256 _index)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // If the index and the callback contract don't line up, revert\n    if (claimCallbacks[_index] != _callback) revert InvalidArgument();\n\n    // Move last index to index of _callback\n    // Creates a copy of the last index value and pastes it over the _index value\n    claimCallbacks[_index] = claimCallbacks[claimCallbacks.length - 1];\n    // Remove last index (because it is now a duplicate)\n    claimCallbacks.pop();\n    emit CallbackRemoved(_callback);\n  }\n\n  /// @notice Cleanup claim if escalation is not pursued\n  /// @param _protocol protocol ID\n  /// @param _claimID public claim ID\n  /// @dev Retrieves current protocol agent for cleanup\n  /// @dev State is either SpccPending or SpccDenied\n  function cleanUp(bytes32 _protocol, uint256 _claimID) external whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_claimID == uint256(0)) revert ZeroArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    // If there is no active claim\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // verify if claim belongs to protocol agent\n    if (claim.protocol != _protocol) revert InvalidArgument();\n\n    State _oldState = _setState(claimIdentifier, State.Cleaned);\n    if (_isCleanupState(_oldState) == false) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Cleaned) revert InvalidState();\n  }\n\n  /// @notice Initiate a claim for a specific protocol as the protocol agent\n  /// @param _protocol protocol ID (different from the internal or public claim ID fields)\n  /// @param _amount amount of USDC which is being claimed by the protocol\n  /// @param _receiver address to receive the amount of USDC being claimed\n  /// @param _timestamp timestamp at which the exploit first occurred\n  /// @param ancillaryData other data associated with the claim, such as the coverage agreement\n  /// @dev The protocol agent that starts a claim will be the protocol agent during the claims lifecycle\n  /// @dev Even if the protocol agent role is tranferred during the lifecycle\n  /// @dev This is done because a protocols coverage can end after an exploit, either wilfully or forcefully.\n  /// @dev The protocol agent is still active for 7 days after coverage ends, so a claim can still be submitted.\n  /// @dev But in case the claim is approved after the 7 day period, `payoutClaim()` can not be called as the protocol agent is 0\n  function startClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    uint32 _timestamp,\n    bytes memory ancillaryData\n  ) external override nonReentrant whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    if (_timestamp == uint32(0)) revert ZeroArgument();\n    if (_timestamp >= block.timestamp) revert InvalidArgument();\n    if (ancillaryData.length == 0) revert ZeroArgument();\n    if (address(sherlockCore) == address(0)) revert InvalidConditions();\n    // Protocol must not already have another claim active\n    if (protocolClaimActive[_protocol]) revert ClaimActive();\n\n    // Creates the internal ID for this claim\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n    // State for this newly created claim must be equal to the default state (NonExistent)\n    if (claims_[claimIdentifier].state != State.NonExistent) revert InvalidArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    // Gets the current and previous coverage amount for this protocol\n    (uint256 current, uint256 previous) = protocolManager.coverageAmounts(_protocol);\n    // The max amount a protocol can claim is the higher of the current and previous coverage amounts\n    uint256 maxClaim = current > previous ? current : previous;\n    // True if a protocol is claiming based on its previous coverage amount (only used in event emission)\n    bool prevCoverage = _amount > current;\n    // Requires the amount claimed is less than or equal to the higher of the current and previous coverage amounts\n    if (_amount > maxClaim) revert InvalidArgument();\n\n    // Increments the last claim ID by 1 to get the public claim ID\n    // Note initial claimID will be 1\n    uint256 claimID = ++lastClaimID;\n    // Protocol now has an active claim\n    protocolClaimActive[_protocol] = true;\n    // Sets the mappings for public and internal claim IDs\n    publicToInternalID[claimID] = claimIdentifier;\n    internalToPublicID[claimIdentifier] = claimID;\n\n    // Initializes a Claim object and adds it to claims_ mapping\n    // Created and updated fields are set to current time\n    // State is updated to SpccPending (waiting on SPCC decision now)\n    claims_[claimIdentifier] = Claim(\n      block.timestamp,\n      block.timestamp,\n      msg.sender,\n      _protocol,\n      _amount,\n      _receiver,\n      _timestamp,\n      State.SpccPending,\n      ancillaryData\n    );\n\n    emit ClaimCreated(claimID, _protocol, _amount, _receiver, prevCoverage);\n    emit ClaimStatusChanged(claimID, State.NonExistent, State.SpccPending);\n  }\n\n  // Only SPCC can call this\n  // SPCC approves the claim and it can now be paid out\n  // Requires that the last state of the claim was SpccPending\n  function spccApprove(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccApproved) != State.SpccPending) revert InvalidState();\n  }\n\n  // Only SPCC can call this\n  // SPCC denies the claim and now the protocol agent can escalate to UMA OO if they desire\n  function spccRefuse(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccDenied) != State.SpccPending) revert InvalidState();\n  }\n\n  // If SPCC denied (or didn't respond to) the claim, a protocol agent can now escalate it to UMA's OO\n  /// @notice Callable by protocol agent\n  /// @param _claimID Public claim ID\n  /// @param _amount Bond amount sent by protocol agent\n  /// @dev Use hardcoded USDC address\n  /// @dev Use hardcoded bond amount\n  /// @dev Use hardcoded liveness 7200 (2 hours)\n  /// @dev Requires the caller to be the account that initially started the claim\n  // Amount sent needs to be at least equal to the BOND amount required\n  function escalate(uint256 _claimID, uint256 _amount)\n    external\n    override\n    nonReentrant\n    whenNotPaused\n  {\n    if (_amount < BOND) revert InvalidArgument();\n\n    // Gets the internal ID of the claim\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Retrieves the claim struct\n    Claim storage claim = claims_[claimIdentifier];\n    // Requires the caller to be the account that initially started the claim\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    // Timestamp when claim was last updated\n    uint256 updated = claim.updated;\n    // Sets the state to UmaPriceProposed\n    State _oldState = _setState(claimIdentifier, State.UmaPriceProposed);\n\n    // Can this claim be updated (based on its current state)? If no, revert\n    if (_isEscalateState(_oldState, updated) == false) revert InvalidState();\n\n    // Transfers the bond amount from the protocol agent to this address\n    TOKEN.safeTransferFrom(msg.sender, address(this), _amount);\n    // Approves the OO contract to spend the bond amount\n    TOKEN.safeApprove(address(UMA), _amount);\n\n    // Sherlock protocol proposes a claim amount of $0 to the UMA OO to begin with\n    // This line https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L585\n    // Will result in disputeSuccess=true if the DVM resolved price != 0\n    // Note: The resolved price needs to exactly match the claim amount\n    // Otherwise the `umaApproved` in our settled callback will be false\n    UMA.requestAndProposePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      TOKEN, // USDC\n      0, // Reward is 0, Sherlock handles rewards on its own\n      BOND, // Cost of making a request to the UMA OO (as decided by Sherlock)\n      LIVENESS, // Proposal liveness\n      address(sherlockCore), // Sherlock core address\n      0 // price\n    );\n\n    // If the state is not equal to ReadyToProposeUmaDispute, revert\n    // Then set the new state to UmaDisputeProposed\n    // Note State gets set to ReadyToProposeUmaDispute in the callback function from requestAndProposePriceFor()\n    if (_setState(claimIdentifier, State.UmaDisputeProposed) != State.ReadyToProposeUmaDispute) {\n      revert InvalidState();\n    }\n\n    // The protocol agent is now disputing Sherlock's proposed claim amount of $0\n    UMA.disputePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      umaRequest, // Refers to the original request made by Sherlock in requestAndProposePriceFor()\n      msg.sender, // Protocol agent, known as the disputer (the one who is disputing Sherlock's $0 proposed claim amount)\n      address(this) // This contract's address is the requester (Sherlock made the original request and proposed $0 claim amount)\n    );\n\n    // State gets updated to UmaPending in the disputePriceFor() callback (priceDisputed())\n    if (claim.state != State.UmaPending) revert InvalidState();\n\n    // Deletes the original request made by Sherlock\n    delete umaRequest;\n    // Approves the OO to spend $0\n    // This is just out of caution, don't want UMA to be approved for any amount of tokens they shouldn't be\n    TOKEN.safeApprove(address(UMA), 0);\n    // Checks for remaining balance in the contract\n    uint256 remaining = TOKEN.balanceOf(address(this));\n    // Sends remaining balance to the protocol agent\n    // A protocol agent should be able to send the exact amount to avoid the extra gas from this function\n    if (remaining != 0) TOKEN.safeTransfer(msg.sender, remaining);\n  }\n\n  // Checks to make sure a payout is valid, then calls the core Sherlock payout function\n  /// @notice Execute claim, storage will be removed after\n  /// @param _claimID Public ID of the claim\n  /// @dev Needs to be SpccApproved or UmaApproved && >UMAHO_TIME\n  /// @dev Funds will be pulled from core\n  // We are ok with spending the extra time to wait for the UMAHO time to expire before paying out\n  // We could have UMAHO multisig send a tx to confirm the payout (payout would happen sooner),\n  // But doesn't seem worth it to save half a day or so\n  function payoutClaim(uint256 _claimID) external override nonReentrant whenNotPaused {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // Only the claim initiator can call this, and payout gets sent to receiver address\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    bytes32 protocol = claim.protocol;\n    // Address to receive the payout\n    // Note We could make the receiver a param in this function, but we want it to be known asap\n    // Can find and correct problems if the receiver is specified when the claim is initiated\n    address receiver = claim.receiver;\n    // Amount (in USDC) to be paid out\n    uint256 amount = claim.amount;\n    // Time when claim was last updated\n    uint256 updated = claim.updated;\n\n    // Sets new state to NonExistent as the claim is over once it is paid out\n    State _oldState = _setState(claimIdentifier, State.NonExistent);\n    // Checks to make sure this claim can be paid out\n    if (_isPayoutState(_oldState, updated) == false) revert InvalidState();\n\n    // Calls the PreCorePayoutCallback function on any contracts in claimCallbacks\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      claimCallbacks[i].PreCorePayoutCallback(protocol, _claimID, amount);\n    }\n\n    emit ClaimPayout(_claimID, receiver, amount);\n\n    // We could potentially transfer more than `amount` in case balance > amount\n    // We are leaving this as is for simplicity's sake\n    // We don't expect to have tokens in this contract unless a reinsurer is providing them for a payout\n    // In which case they should provide the exact amount, and balance == amount is true\n    uint256 balance = TOKEN.balanceOf(address(this));\n    if (balance != 0) TOKEN.safeTransfer(receiver, balance);\n    if (balance < amount) sherlockCore.payoutClaim(receiver, amount - balance);\n  }\n\n  /// @notice UMAHO is able to execute a halt if the state is UmaApproved and state was updated less than UMAHO_TIME ago\n  // Once the UMAHO_TIME is up, UMAHO can still halt the claim, but only if the claim hasn't been paid out yet\n  function executeHalt(uint256 _claimID) external override whenNotPaused onlyUMAHO nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Sets state of claim to nonexistent, reverts if the old state was anything but UmaApproved\n    if (_setState(claimIdentifier, State.Halted) != State.UmaApproved) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Halted) revert InvalidState();\n\n    emit ClaimHalted(_claimID);\n  }\n\n  //\n  // UMA callbacks\n  //\n\n  // Once requestAndProposePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaPriceProposed to ReadyToProposeUmaDispute\n  // Then we call the next function in the process, disputePriceFor()\n  // @note reentrancy is allowed for this call\n  function priceProposed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to ReadyToProposeUmaDispute\n    if (_setState(claimIdentifier, State.ReadyToProposeUmaDispute) != State.UmaPriceProposed) {\n      revert InvalidState();\n    }\n    // Sets global umaRequest variable to the request coming from this price proposal\n    umaRequest = request;\n  }\n\n  // Once disputePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaDisputeProposed to UmaPending\n  // Then we call the next function in the process, priceSettled()\n  // @note reentrancy is allowed for this call\n  function priceDisputed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to UmaPending\n    if (_setState(claimIdentifier, State.UmaPending) != State.UmaDisputeProposed) {\n      revert InvalidState();\n    }\n  }\n\n  // Once priceSettled() is executed in UMA's contracts, this function gets called\n  // UMA OO gives back a resolved price (either 0 or claim.amount) and\n  // Claim's state is changed to either UmaApproved or UmaDenied\n  // If UmaDenied, the claim is dead and state is immediately changed to NonExistent and cleaned up\n  /// @dev still want to capture settled price in a paused state. Otherwise claim is stuck.\n  function priceSettled(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override onlyUMA(identifier) nonReentrant {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n\n    // Retrives the resolved price for this claim (either 0 if Sherlock wins, or the amount of the claim as proposed by the protocol agent)\n    uint256 resolvedPrice = uint256(request.resolvedPrice);\n    // UMA approved the claim if the resolved price is equal to the claim amount set by the protocol agent\n    bool umaApproved = resolvedPrice == claim.amount;\n\n    // If UMA approves the claim, set state to UmaApproved\n    // If UMA denies, set state to UmaDenied, then to NonExistent (deletes the claim data)\n    if (umaApproved) {\n      if (_setState(claimIdentifier, State.UmaApproved) != State.UmaPending) revert InvalidState();\n    } else {\n      if (_setState(claimIdentifier, State.UmaDenied) != State.UmaPending) revert InvalidState();\n      if (_setState(claimIdentifier, State.NonExistent) != State.UmaDenied) revert InvalidState();\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "ISherlockClaimManager.sol",
            "SherlockClaimManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "jsx\n// Taken from https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol\n// Only relevant lines are referenced\nuint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\nrequest.finalFee = finalFee;\ntotalBond = request.bond.add(request.finalFee);\nif (totalBond  0) currency.safeTransferFrom(msg.sender, address(this), totalBond);\n",
                    "jsx\n// Taken from https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L389-L390\ntotalBond = request.bond.add(request.finalFee);\nif (totalBond  0) request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\n",
                    "jsx\nStoreInterface store = _getStore();\n\n// Avoids stack too deep compilation error.\n{\n    // Along with the final fee, \"burn\" part of the loser's bond to ensure that a larger bond always makes it\n    // proportionally more expensive to delay the resolution even if the proposer and disputer are the same\n    // party.\n    uint256 burnedBond = _computeBurnedBond(disputedRequest);\n\n    // The total fee is the burned bond and the final fee added together.\n    uint256 totalFee = request.finalFee.add(burnedBond);\n\n    if (totalFee  0) {\n        request.currency.safeIncreaseAllowance(address(store), totalFee);\n        _getStore().payOracleFeesErc20(address(request.currency), FixedPoint.Unsigned(totalFee));\n    }\n}\n\nfunction _computeBurnedBond(Request memory request) private pure returns (uint256) {\n  // burnedBond = floor(bond / 2)\n  return request.bond.div(2);\n}\n",
                    "jsx\n// Winner gets:\n// Their bond back.\n// The unburned portion of the loser's bond: proposal bond (not including final fee) burned bond.\n// Their final fee back.\n// The request reward (if not already refunded -if refunded, it will be set to 0).\npayout = request.bond.add(request.bond.sub(_computeBurnedBond(settledRequest))).add(request.finalFee).add(\n    request.reward\n);\nrequest.currency.safeTransfer(disputeSuccess ? request.disputer : request.proposer, payout);\n"
                ],
                "Type": "  SherlockClaimManager : Incorrect amounts needed and paid for escalated claims ",
                "Description": "\nWhen escalating claims, the documentation(https://docs.sherlock.xyz/claims/claims-process) states that the protocol agent is required to pay and stake a certain amount for the process. If the covered protocol is proven correct, then the amount specified by the claim will be paid out. They will also receive the stake amount back in full. If the covered protocol's escalation is not successful, then the amount specified by the claim is not paid out and the stake amount is not returned.\n\nThe protocol agent is reasonably expected to pay the following:\n\n*   The stake (BOND) and\n*   UMA\u2019s final fee\n\nIn reality, the protocol agent will end up paying more, as we shall see in the proof of concept.\n\n\nLet us assume the following:\n\n*   BOND = 9600 as defined in SherlockClaimManager\n*   umaFee = 400 (at the time of writing, this value has been updated to 1500 USDC: see [Store.computeFinalFee(usdc)(https://etherscan.io/address/0x54f44eA3D2e7aA0ac089c4d8F7C93C27844057BF#readContract)).\n\nOn invoking escalate(), the following amounts are required:\n\n1.  BOND + umaFee = 9600 + 400 will be transferred to UMA when invoking requestAndProposePriceFor()\n\njsx\n// Taken from https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol\n// Only relevant lines are referenced\nuint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\nrequest.finalFee = finalFee;\ntotalBond = request.bond.add(request.finalFee);\nif (totalBond  0) currency.safeTransferFrom(msg.sender, address(this), totalBond);\n\n\n1.  Another BOND + umaFee = 9600 + 400 will be transfered when invoking disputePriceFor()\n\njsx\n// Taken from https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L389-L390\ntotalBond = request.bond.add(request.finalFee);\nif (totalBond  0) request.currency.safeTransferFrom(msg.sender, address(this), totalBond);\n\n\nHowever, what\u2019s important to note is that UMA will \u201cburn\u201d half of the BOND collected + final fee. This will go against the claim that the protocol agent will be able to reclaim his stake in full.\n\njsx\nStoreInterface store = _getStore();\n\n// Avoids stack too deep compilation error.\n{\n    // Along with the final fee, \"burn\" part of the loser's bond to ensure that a larger bond always makes it\n    // proportionally more expensive to delay the resolution even if the proposer and disputer are the same\n    // party.\n    uint256 burnedBond = _computeBurnedBond(disputedRequest);\n\n    // The total fee is the burned bond and the final fee added together.\n    uint256 totalFee = request.finalFee.add(burnedBond);\n\n    if (totalFee  0) {\n        request.currency.safeIncreaseAllowance(address(store), totalFee);\n        _getStore().payOracleFeesErc20(address(request.currency), FixedPoint.Unsigned(totalFee));\n    }\n}\n\nfunction _computeBurnedBond(Request memory request) private pure returns (uint256) {\n  // burnedBond = floor(bond / 2)\n  return request.bond.div(2);\n}\n\n\nWe finally note that on settlement, the eventual payout is\n\njsx\n// Winner gets:\n// Their bond back.\n// The unburned portion of the loser's bond: proposal bond (not including final fee) burned bond.\n// Their final fee back.\n// The request reward (if not already refunded -if refunded, it will be set to 0).\npayout = request.bond.add(request.bond.sub(_computeBurnedBond(settledRequest))).add(request.finalFee).add(\n    request.reward\n);\nrequest.currency.safeTransfer(disputeSuccess ? request.disputer : request.proposer, payout);\n\n\nHence, in reality, the protocol agent will only receive 9600 * 2 4800 + 400 = 14800 should the dispute be successful. We note that the burnt amount of 4800 / 2 + 400 = 5200 has been taken by UMA.\n\nOne can further verify this behaviour by looking at a past resolution of another protocol:\n\n<https://dashboard.tenderly.co/tx/main/0x0f03f73a2093e385146791e8f2739dbc04b39145476d6940776680243460100f/debugger?trace=0.6.1\n\nThe above example has a bond is 0.0075 ETH, with UMA\u2019s final fee being 0.2 ETH. We see that UMA takes 0.2 + 0.5 * 0.0075 = 0.02375 ETH.\n\nThus, we see that the protocol agent will be charged disproportionally to what is expected.\n\n",
                "Repair": "\nWe suggest changing the parameters of requestAndProposePriceFor() to\n\njsx\nUMA.requestAndProposePriceFor(\n  UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n  claim.timestamp, // Timestamp to identify the request\n  claim.ancillaryData, // Ancillary data such as the coverage agreement\n  TOKEN, // USDC\n  BOND, // While sherlock handles rewards on its own, we use the BOND as the reward\n  // because using it as UMA's bond would result in 0.5 * BOND charged by UMA excluding final fee\n  1, // Ideally 0, but 0 = final fee used. Hence, we set it to the next lowest \n  // possible value\n  LIVENESS, // Proposal liveness\n  address(sherlockCore), // Sherlock core address\n  0 // price\n);\n\n\nwhere BOND becomes the reward and the actual bond for UMA is 1. Ideally, it should be set to 0, but if set as such, UMA interprets it to use the final fee as the bond amount instead.\n\nrequest.bond = bond != 0 ? bond : finalFee;(https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L321)\n\nThis way, the actual amount required from the protocol agent is the BOND + 2 * (USDC wei + umaFee) for the process. He will additionally be returned his BOND + umaFee if his dispute is successful.\n\nEvert0x (Sherlock) disagreed with High severity and commented(https://github.com/code-423n4/2022-01-sherlock-findings/issues/230#issuecomment-1029404347):\n  Non critical as documentation is incorrect about this.\n\nJack the Pug (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-01-sherlock-findings/issues/230#issuecomment-1079638067):\n  Downgrading to Med as it's mostly because the documentation is incorrect.\n\nrcstanciu (Sherlock) commented(https://github.com/code-423n4/2022-01-sherlock-findings/issues/230#issuecomment-1079876687):\n  @jack-the-pug The docs have been updated to explain the correct burned amount.\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-01-sherlock-findings/issues/230#issuecomment-1086797167):\n Thank you @rcstanciu\n \n While I agreed that the issue only impacts a small sum of users and the impact is not significant. And the root cause of this issue may not be a wrong implementation but actual wrong documentation.\n \n However, I still tend to make this a Med rather than a Low for the following reasons:\n \n 1. A wrong documentation is arguably indistinguishable from a wrong implementation that actually violates the intention of the design, especial from an outsider's pov;\n 2. This write-up indicates a dedicated and in-depth effort of the warden by digging into the documentation and trying to understand the intention and cross-compare with the actual implementation to find any differences. As a judge, part of my job is to make sure that the wardens' findings are being rewarded in a just and fair manner.\n \n Therefore, I'm keeping this as a Med and I encourage the future wardens to continue finding the inconsistency between the documentation and the implementation.\n \n Keep up the good work! GreyArt is a great name btw.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\n\nimport './interfaces/ISherlock.sol';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone's stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 => bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 => uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 => uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 => uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address => uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 _token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i < _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of `_tokenID`\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd_[_tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of `_tokenID`\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards_[_tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit `_amount` into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw `_amount` from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a `paused` state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn't needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &&\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an `unpaused` state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn't needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &&\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`\n  /// @dev this enables the `tokenBalanceOfAddress` to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of `_amount` to `_receiver`\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends\n  /// @dev `_period` needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd_[_id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards_[_id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards_[_id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards_[_id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount > mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends\n  /// @dev `_period` needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares_;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // _amount of tokens divided by the \"before\" total amount of tokens, multiplied by the \"before\" amount of stake shares\n    if (totalStakeShares_ != 0)\n      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares_ = _amount;\n\n    // Assigns this NFT ID the calc'd amount of stake shares above\n    stakeShares[_id] = stakeShares_;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    _sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT `_id` and receive `_amount` of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of `_id` will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup `_period` has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner's approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd_[_id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: `_id` for `_period` seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends\n  /// @dev Only the owner of `_id` will be able to restake their position using this call\n  /// @dev `_period` needs to be whitelisted\n  /// @dev Can only be called after lockup `_period` has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime > block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 10**18\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // `profit` variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n\n\n",
        "CodeNames": [
            "Sherlock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-02",
                "Location": [
                    "stakeShares",
                    "arbRestake",
                    "_beforeTokenTransfer",
                    "addressShares",
                    "_redeemShares",
                    "tokenBalanceOfAddress",
                    "nftOwner",
                    "arbRewardShares"
                ],
                "Type": "  tokenBalanceOfAddress  of  nftOwner  becomes permanently incorrect after  arbRestake ",
                "Description": "\nSuccessful arbRestake performs _redeemShares for arbRewardShares amount to extract the arbitrager reward. This effectively reduces shares accounted for an NFT, but leaves untouched the addressShares of an nftOwner.\n\nAs a result the tokenBalanceOfAddress function will report an old balance that existed before arbitrager reward was slashed away. This will persist if the owner will transfer the NFT to someone else as its new reduced shares value will be subtracted from addressShares in _beforeTokenTransfer, leaving the arbitrage removed shares permanently in addressShares of the NFT owner, essentially making all further reporting of his balance incorrectly inflated by the cumulative arbitrage reward shares from all arbRestakes happened to the owner's NFTs.\n\n\narbRestake redeems arbRewardShares, which are a part of total shares of an NFT:\n\nSherlock.sol#L673(https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L673)\n\nThis will effectively reduce the stakeShares:\n\nSherlock.sol#L491(https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L491)\n\nBut there is no mechanics in place to reduce addressShares of the owner apart from mint/burn/transfer, so addressShares will still correspond to NFT shares before arbitrage. This discrepancy will be accumulated further with arbitrage restakes.\n\n",
                "Repair": "\nAdd a flag to _redeemShares indicating that it was called for a partial shares decrease, say isPartialRedeem, and do addressShares[nftOwner] -= _stakeShares when isPartialRedeem == true.\n\nAnother option is to do bigger refactoring, making stakeShares and addressShares always change simultaneously.\n\nEvert0x (Sherlock) confirmed and commented(https://github.com/code-423n4/2022-01-sherlock-findings/issues/109#issuecomment-1034015588):\n  This is a legit issue and needs to be addressed. I think we choose to delete this functionality all together.\n \n The function has some potential future benefit but it might be too little benefit to make these relatively complex changes that make the code harder to understand.\n\nEvert0x (Sherlock) resolved(https://github.com/code-423n4/2022-01-sherlock-findings/issues/109)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\n\nimport './interfaces/ISherlock.sol';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone's stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 => bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 => uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 => uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 => uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address => uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 _token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i < _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of `_tokenID`\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd_[_tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of `_tokenID`\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards_[_tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit `_amount` into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw `_amount` from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a `paused` state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn't needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &&\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an `unpaused` state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn't needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &&\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`\n  /// @dev this enables the `tokenBalanceOfAddress` to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of `_amount` to `_receiver`\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends\n  /// @dev `_period` needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd_[_id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards_[_id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards_[_id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards_[_id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount > mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends\n  /// @dev `_period` needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares_;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // _amount of tokens divided by the \"before\" total amount of tokens, multiplied by the \"before\" amount of stake shares\n    if (totalStakeShares_ != 0)\n      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares_ = _amount;\n\n    // Assigns this NFT ID the calc'd amount of stake shares above\n    stakeShares[_id] = stakeShares_;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    _sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT `_id` and receive `_amount` of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of `_id` will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup `_period` has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner's approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd_[_id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: `_id` for `_period` seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends\n  /// @dev Only the owner of `_id` will be able to restake their position using this call\n  /// @dev `_period` needs to be whitelisted\n  /// @dev Can only be called after lockup `_period` has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime > block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 10**18\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // `profit` variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport './Manager.sol';\nimport '../interfaces/managers/IStrategyManager.sol';\n\nimport '../interfaces/aaveV2/ILendingPool.sol';\nimport '../interfaces/aaveV2/ILendingPoolAddressesProvider.sol';\nimport '../interfaces/aaveV2/IAaveIncentivesController.sol';\nimport '../interfaces/aaveV2/IStakeAave.sol';\nimport '../interfaces/aaveV2/IAToken.sol';\n\n// This contract contains logic for depositing staker funds into Aave V2 as a yield strategy\n\ncontract AaveV2Strategy is IStrategyManager, Manager {\n  using SafeERC20 for IERC20;\n\n  // Need to call a provider because Aave has the ability to change the lending pool address\n  ILendingPoolAddressesProvider public constant LP_ADDRESS_PROVIDER =\n    ILendingPoolAddressesProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\n\n  // Aave contract that controls stkAAVE rewards\n  IAaveIncentivesController public immutable aaveIncentivesController;\n\n  // This is the token being deposited (USDC)\n  IERC20 public immutable override want;\n  // This is the receipt token Aave gives in exchange for a token deposit (aUSDC)\n  IAToken public immutable aWant;\n\n  // Address to receive stkAAVE rewards\n  address public immutable aaveLmReceiver;\n\n  // Constructor takes the aUSDC address and the rewards receiver address (a Sherlock address) as args\n  constructor(IAToken _aWant, address _aaveLmReceiver) {\n    if (address(_aWant) == address(0)) revert ZeroArgument();\n    if (_aaveLmReceiver == address(0)) revert ZeroArgument();\n\n    aWant = _aWant;\n    // This gets the underlying token associated with aUSDC (USDC)\n    want = IERC20(_aWant.UNDERLYING_ASSET_ADDRESS());\n    // Gets the specific rewards controller for this token type\n    aaveIncentivesController = _aWant.getIncentivesController();\n\n    aaveLmReceiver = _aaveLmReceiver;\n  }\n\n  // Returns the current Aave lending pool address that should be used\n  function getLp() internal view returns (ILendingPool) {\n    return ILendingPool(LP_ADDRESS_PROVIDER.getLendingPool());\n  }\n\n  /// @notice Checks the aUSDC balance in this contract\n  function balanceOf() public view override returns (uint256) {\n    return aWant.balanceOf(address(this));\n  }\n\n  /// @notice Deposits all USDC held in this contract into Aave's lending pool\n  function deposit() external override whenNotPaused {\n    ILendingPool lp = getLp();\n    // Checking the USDC balance of this contract\n    uint256 amount = want.balanceOf(address(this));\n    if (amount == 0) revert InvalidConditions();\n\n    // If allowance for this contract is too low, approve the max allowance\n    if (want.allowance(address(this), address(lp)) < amount) {\n      want.safeApprove(address(lp), type(uint256).max);\n    }\n\n    // Deposits the full balance of USDC held in this contract into Aave's lending pool\n    lp.deposit(address(want), amount, address(this), 0);\n  }\n\n  /// @notice Withdraws all USDC from Aave's lending pool back into the Sherlock core contract\n  /// @dev Only callable by the Sherlock core contract\n  /// @return The final amount withdrawn\n  function withdrawAll() external override onlySherlockCore returns (uint256) {\n    ILendingPool lp = getLp();\n    if (balanceOf() == 0) {\n      return 0;\n    }\n    // Withdraws all USDC from Aave's lending pool and sends it to the Sherlock core contract (msg.sender)\n    return lp.withdraw(address(want), type(uint256).max, msg.sender);\n  }\n\n  /// @notice Withdraws a specific amount of USDC from Aave's lending pool back into the Sherlock core contract\n  /// @param _amount Amount of USDC to withdraw\n  function withdraw(uint256 _amount) external override onlySherlockCore {\n    // Why do we only check if _amount is equal to the max value?\n    if (_amount == type(uint256).max) revert InvalidArgument();\n\n    ILendingPool lp = getLp();\n    // Withdraws _amount of USDC and sends it to the Sherlock core contract\n    // If the amount withdrawn is not equal to _amount, it reverts\n    if (lp.withdraw(address(want), _amount, msg.sender) != _amount) revert InvalidConditions();\n  }\n\n  // Claims the stkAAVE rewards and sends them to the receiver address\n  function claimRewards() external whenNotPaused {\n    // Creates an array with one slot\n    address[] memory assets = new address[](1);\n    // Sets the slot equal to the address of aUSDC\n    assets[0] = address(aWant);\n\n    // Claims all the rewards on aUSDC and sends them to the aaveLmReceiver (an address controlled by governance)\n    // Tokens are NOT meant to be (directly) distributed to stakers.\n    aaveIncentivesController.claimRewards(assets, type(uint256).max, aaveLmReceiver);\n  }\n\n  /// @notice Function used to check if this is the current active yield strategy\n  /// @return Boolean indicating it's active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() public view returns (bool) {\n    return address(sherlockCore.yieldStrategy()) == address(this);\n  }\n\n  // Only contract owner can call this\n  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)\n  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {\n    if (_receiver == address(0)) revert ZeroArgument();\n    // This contract must NOT be the current assigned yield strategy contract\n    if (isActive()) revert InvalidConditions();\n    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH\n    _sweep(_receiver, _extraTokens);\n  }\n}\n\n\n",
        "CodeNames": [
            "Sherlock.sol",
            "AaveV2Strategy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "onlySherlockCore",
                    "updateYieldStrategy",
                    "yieldStrategy",
                    "withdrawAll",
                    "withdraw"
                ],
                "Type": "  updateYieldStrategy  will freeze some funds with the old Strategy if  yieldStrategy  fails to withdraw all the funds because of liquidity issues",
                "Description": "\nPart of the funds held with the strategy can be frozen if the current strategy has tight liquidity when updateYieldStrategy is run as this function makes an attempt to withdraw all the funds and then unconditionally removes the strategy.\n\nThe Sherlock to YieldStrategy link will be broken as a result: Sherlock points to the new Strategy, while old Strategy still allows only this Sherlock contract to withdraw.\n\nThis way back and forth switches will be required in the future to return the funds: withdraw all from new strategy and switch to old, withdraw all from old and point to new one again, reinvest there.\n\n\nIn peer-to-peer lending protocols it is not always possible for the token supplier to withdraw all what's due. This happens on high utilization of the market (when it has a kind of liquidity crunch).\n\nThis way yieldStrategy.withdrawAll is not guaranteed to obtain all the funds held with the strategy:\n\nSherlock.sol#L286(https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L286)\n\nThe worst case scenario here seems to be the remainder funds to be left frozen within the strategy.\n\nFor example, AaveV2Strategy withdraw and withdrawAll have onlySherlockCore modifier:\n\nAaveV2Strategy.sol#L78-100(https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/managers/AaveV2Strategy.sol#L78-100)\n\nWhile Sherlock core is immutable for the Strategy by default:\n\nManager.sol#L26-41(https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/managers/Manager.sol#L26-41)\n\n",
                "Repair": "\nConsider implementing a new method that fails whenever a strategy cannot withdraw all what's due now, and rename current implementation to, for example, forceUpdateYieldStrategy, to have a degree of flexibility around liquidity issues.\n\nAlso, to avoid back and forth switching, a strategy argument can be introduced to yieldStrategyWithdrawAll to allow withdrawals from any (not only current) yieldStrategy:\n\nSherlock.sol#L322(https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L322)\n\nNow:\n\n    function yieldStrategyWithdrawAll() external override onlyOwner {\n\nTo be (if _yieldStrategy is zero then utilize current):\n\n    function yieldStrategyWithdrawAll(IStrategyManager _yieldStrategy) external override onlyOwner {\n\nEvert0x (Sherlock) disagreed with Medium severity and commented(https://github.com/code-423n4/2022-01-sherlock-findings/issues/76#issuecomment-1033998402):\n  I think this should be low risk but it's an interesting feature to add\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-01-sherlock-findings/issues/76#issuecomment-1079724284):\n  I think this worths a Med, the scenario is not impossible to happen, and the handling in the current implementation is quite rough.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport './interfaces/ISherClaim.sol';\nimport './interfaces/ISherlock.sol';\n\n/// @title Buy SHER tokens by staking USDC and paying USDC\n/// @author Evert Kors\n/// @dev The goal is to get TVL in Sherlock.sol and raise funds with `receiver`\n/// @dev Bought SHER tokens are moved to a timelock contract (SherClaim)\n/// @dev Admin should SHER tokens to the contract rounded by 0.01 SHER, otherwise logic will break.\ncontract SherBuy {\n  using SafeERC20 for IERC20;\n\n  error InvalidSender();\n  error InvalidAmount();\n  error ZeroArgument();\n  error InvalidState();\n  error SoldOut();\n\n  /// @notice Emitted when SHER purchase is executed\n  /// @param buyer Account that bought SHER tokens\n  /// @param amount How much SHER tokens are bought\n  /// @param staked How much USDC is staked\n  /// @param paid How much USDC is paid\n  event Purchase(address indexed buyer, uint256 amount, uint256 staked, uint256 paid);\n\n  // The staking period used for the staking USDC\n  uint256 public constant PERIOD = 26 weeks;\n  // Allows purchases in steps of 0.01 SHER\n  uint256 internal constant SHER_STEPS = 10**16;\n  // Allows stakeRate and buyRate with steps of 0.01 USDC\n  uint256 internal constant RATE_STEPS = 10**4;\n  // SHER has 18 decimals\n  uint256 internal constant SHER_DECIMALS = 10**18;\n\n  // SHER token address (18 decimals)\n  IERC20 public immutable sher;\n  // USDC token address (6 decimals)\n  IERC20 public immutable usdc;\n\n  // 10**6 means for every 1 SHER token you want to buy, you will stake 1 USDC (10**7 means 1 SHER for 10 USDC)\n  uint256 public immutable stakeRate;\n  // 10**6 means for every 1 SHER token you want to buy, you will pay 1 USDC (10**7 means 1 SHER for 10 USDC)\n  uint256 public immutable buyRate;\n  // The `Sherlock.sol` contract that is a ERC721\n  ISherlock public immutable sherlockPosition;\n  // Address receiving the USDC payments\n  address public immutable receiver;\n  // Contract to claim SHER at\n  ISherClaim public immutable sherClaim;\n\n  /// @notice Construct BuySher contract\n  /// @param _sher ERC20 contract for SHER token\n  /// @param _usdc ERC20 contract for USDC token\n  /// @param _stakeRate Rate at which SHER tokens translate to the amount of USDC needed to be staked\n  /// @param _buyRate Rate at which SHER tokens translate to the amount of USDC needed to be paid\n  /// @param _sherlockPosition ERC721 contract of Sherlock positions\n  /// @param _receiver Address that receives USDC from purchases\n  /// @param _sherClaim Contract that keeps the SHER timelocked\n  constructor(\n    IERC20 _sher,\n    IERC20 _usdc,\n    uint256 _stakeRate,\n    uint256 _buyRate,\n    ISherlock _sherlockPosition,\n    address _receiver,\n    ISherClaim _sherClaim\n  ) {\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_usdc) == address(0)) revert ZeroArgument();\n    if (_stakeRate == 0) revert ZeroArgument();\n    if (_stakeRate % RATE_STEPS != 0) revert InvalidState();\n    if (_buyRate == 0) revert ZeroArgument();\n    if (_buyRate % RATE_STEPS != 0) revert InvalidState();\n    if (address(_sherlockPosition) == address(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    if (address(_sherClaim) == address(0)) revert ZeroArgument();\n\n    // Verify is PERIOD is active\n    // Theoretically this period can be disabled during the lifetime of this contract, which will cause issues\n    if (_sherlockPosition.stakingPeriods(PERIOD) == false) revert InvalidState();\n\n    sher = _sher;\n    usdc = _usdc;\n    stakeRate = _stakeRate;\n    buyRate = _buyRate;\n    sherlockPosition = _sherlockPosition;\n    receiver = _receiver;\n    sherClaim = _sherClaim;\n\n    // Do max approve in constructor as this contract will not hold any USDC\n    usdc.approve(address(sherlockPosition), type(uint256).max);\n  }\n\n  /// @notice Check if the liquidity event is active\n  /// @dev SHER tokens can run out while event is active\n  /// @return True if the liquidity event is active\n  function active() public view returns (bool) {\n    // The claim contract will become active once the liquidity event is inactive\n    return block.timestamp < sherClaim.claimableAt();\n  }\n\n  /// @notice View the capital requirements needed to buy up until `_sherAmountWant`\n  /// @dev Will adjust to remaining SHER if `_sherAmountWant` exceeds that\n  /// @return sherAmount Will adjust to remining SHER if `_sherAmountWant` exceeds that\n  /// @return stake How much USDC needs to be staked for `PERIOD` of time to buy `sherAmount` SHER\n  /// @return price How much USDC needs to be paid to buy `sherAmount` SHER\n  function viewCapitalRequirements(uint256 _sherAmountWant)\n    public\n    view\n    returns (\n      uint256 sherAmount,\n      uint256 stake,\n      uint256 price\n    )\n  {\n    // Only allow if liquidity event is active\n    if (active() == false) revert InvalidState();\n    // Zero isn't allowed\n    if (_sherAmountWant == 0) revert ZeroArgument();\n\n    // View how much SHER is still available to be sold\n    uint256 available = sher.balanceOf(address(this));\n    // If remaining SHER is 0 it's sold out\n    if (available == 0) revert SoldOut();\n\n    // Use remaining SHER if it's less then `_sherAmountWant`, otherwise go for `_sherAmountWant`\n    // Remaining SHER will only be assigned on the last sale of this contract, `SoldOut()` error will be thrown after\n    // sherAmount is not able to be zero as both 'available' and '_sherAmountWant' will be bigger than 0\n    sherAmount = available < _sherAmountWant ? available : _sherAmountWant;\n    // Only allows SHER amounts with certain precision steps\n    // To ensure there is no rounding error at loss for the contract in stake / price calculation\n    // Theoretically, if `available` is used, the function can fail if '% SHER_STEPS != 0' will be true\n    // This can be caused by a griefer sending a small amount of SHER to the contract\n    // Realistically, no SHER tokens will be on the market when this function is active\n    // So it can only be caused if the admin sends too small amounts (documented at top of file with @dev)\n    if (sherAmount % SHER_STEPS != 0) revert InvalidAmount();\n\n    // Calculate how much USDC needs to be staked to buy `sherAmount`\n    stake = (sherAmount * stakeRate) / SHER_DECIMALS;\n    // Calculate how much USDC needs to be paid to buy `sherAmount`\n    price = (sherAmount * buyRate) / SHER_DECIMALS;\n  }\n\n  /// @notice Buy up until `_sherAmountWant`\n  /// @param _sherAmountWant The maximum amount of SHER the user wants to buy\n  /// @dev Bought SHER tokens are moved to a timelock contract (SherClaim)\n  /// @dev Will revert if liquidity event is inactive because of the viewCapitalRequirements call\n  function execute(uint256 _sherAmountWant) external {\n    // Calculate the capital requirements\n    // Check how much SHER can actually be bought\n    (uint256 sherAmount, uint256 stake, uint256 price) = viewCapitalRequirements(_sherAmountWant);\n\n    // Transfer usdc from user to this, for staking (max is approved in constructor)\n    usdc.safeTransferFrom(msg.sender, address(this), stake);\n    // Transfer usdc from user to receiver, for payment of the SHER\n    usdc.safeTransferFrom(msg.sender, receiver, price);\n\n    // Stake usdc and send NFT to user\n    sherlockPosition.initialStake(stake, PERIOD, msg.sender);\n    // Approve in function as this contract will hold SHER tokens\n    sher.approve(address(sherClaim), sherAmount);\n    // Add bought SHER tokens to timelock for user\n    sherClaim.add(msg.sender, sherAmount);\n\n    // Emit event about the purchase\n    emit Purchase(msg.sender, sherAmount, stake, price);\n  }\n\n  /// @notice Rescue remaining ERC20 tokens when liquidity event is inactive\n  /// @param _tokens Array of ERC20 tokens to rescue\n  /// @dev Can only be called by `receiver`\n  function sweepTokens(IERC20[] memory _tokens) external {\n    if (msg.sender != receiver) revert InvalidSender();\n    if (active()) revert InvalidState();\n\n    // Loops through the extra tokens (ERC20) provided and sends all of them to the sender address\n    for (uint256 i; i < _tokens.length; i++) {\n      IERC20 token = _tokens[i];\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n  }\n}\n\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\n\nimport './interfaces/ISherlock.sol';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone's stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 => bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 => uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 => uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 => uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address => uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 _token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i < _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of `_tokenID`\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd_[_tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of `_tokenID`\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards_[_tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit `_amount` into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw `_amount` from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a `paused` state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn't needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &&\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an `unpaused` state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn't needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &&\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`\n  /// @dev this enables the `tokenBalanceOfAddress` to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of `_amount` to `_receiver`\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends\n  /// @dev `_period` needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd_[_id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards_[_id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards_[_id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards_[_id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount > mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends\n  /// @dev `_period` needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares_;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // _amount of tokens divided by the \"before\" total amount of tokens, multiplied by the \"before\" amount of stake shares\n    if (totalStakeShares_ != 0)\n      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares_ = _amount;\n\n    // Assigns this NFT ID the calc'd amount of stake shares above\n    stakeShares[_id] = stakeShares_;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    _sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT `_id` and receive `_amount` of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of `_id` will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup `_period` has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner's approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd_[_id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: `_id` for `_period` seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends\n  /// @dev Only the owner of `_id` will be able to restake their position using this call\n  /// @dev `_period` needs to be whitelisted\n  /// @dev Can only be called after lockup `_period` has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime > block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 10**18\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // `profit` variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n\n\n",
        "CodeNames": [
            "SherBuy.sol",
            "Sherlock.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "//solidity\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards_[_id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards_[_id];\n  }\n"
                ],
                "Type": " Reenterancy in  _sendSherRewardsToOwner() ",
                "Description": "\nThis is a reentrancy vulnerability that would allow the attacker to drain the entire SHER balance of the contract.\n\nNote: this attack requires gaining control of execution sher.transfer() which will depend on the implementation of the SHER token. Control may be gained by the attacker if the contract implements ERC777 or otherwise makes external calls during transfer().\n\n\nSee _sendSherRewards(https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L442)\n\nsolidity\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards_[_id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards_[_id];\n  }\n\n\nHere sherRewards are deleted after the potential external call is made in sher.safeTransfer(). As a result if an attacker reenters this function sherRewards_ they will still maintain the original balance of rewards and again transfer the SHER tokens.\n\nAs _sendSherRewardsToOwner() is internal the attack can be initiated through the external function ownerRestake() see here.(https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L595)\n\nSteps to produce the attack:\n\n1.  Deploy attack contract to handle reenterancy\n2.  Call initialStake() from the attack contract with the smallest period\n3.  Wait for period amount of time to pass\n4.  Have the attack contract call ownerRestake(). The attack contract will gain control of the (See note above about control flow). This will recursively call ownerRestake() until the balance of Sherlock is 0 or less than the user's reward amount. Then allow reentrancy loop to unwind and complete.\n\n",
                "Repair": "\nReentrancy can be mitigated by one of two solutions.\n\nThe first option is to add a reentrancy guard like nonReentrant the is used in SherlockClaimManager.sol.\n\nThe second option is to use the checks-effects-interactions pattern. This would involve doing all validation checks and state changes before making any potential external calls. For example the above function could be modified as follows.\n\nsolidity\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards_[_id];\n    if (sherReward == 0) return;\n\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards_[_id];\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n  }\n\n\nAdditionally the following functions are not exploitable however should be updated to use the check-effects-interations pattern.\n\n*   Sherlock._redeemShares() should do _transferTokensOut() last.\n*   Sherlock.initialStake() should do token.safeTransferFrom(msg.sender, address(this), _amount); last\n*   SherClaim.add() should do sher.safeTransferFrom(msg.sender, address(this), _amount); after updating userClaims\n*   SherlockProtocolManager.depositToActiveBalance() should do token.safeTransferFrom(msg.sender, address(this), _amount); after updating activeBalances\n\nEvert0x (Sherlock) confirmed, but disagreed with High severity and commented(https://github.com/code-423n4/2022-01-sherlock-findings/issues/60#issuecomment-1029420896):\n  Good find. I think it's med-risk as it depends on the implementation of SHER token (does it allow callbacks).\n\nJack the Pug (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-01-sherlock-findings/issues/60#issuecomment-1064200957):\n  Downgrade to Med as the SHER token is a known token that currently comes with no such hooks like ERC777.\n\n Evert0x (Sherlock) resolved(https://github.com/code-423n4/2022-01-sherlock-findings/issues/60)\n\n\n\n*\n\n\n"
            }
        ]
    }
]