[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { OrderType } from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    OrderParameters,\n    Order,\n    AdvancedOrder,\n    OrderComponents,\n    OrderStatus,\n    CriteriaResolver\n} from \"./ConsiderationStructs.sol\";\n\nimport { Executor } from \"./Executor.sol\";\n\nimport { ZoneInteraction } from \"./ZoneInteraction.sol\";\n\n/**\n * @title OrderValidator\n * @author 0age\n * @notice OrderValidator contains functionality related to validating orders\n *         and updating their status.\n */\ncontract OrderValidator is Executor, ZoneInteraction {\n    // Track status of each order (validated, cancelled, and fraction filled).\n    mapping(bytes32 => OrderStatus) private _orderStatus;\n\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Executor(conduitController) {}\n\n    /**\n     * @dev Internal function to verify and update the status of a basic order.\n     *\n     * @param orderHash The hash of the order.\n     * @param offerer   The offerer of the order.\n     * @param signature A signature from the offerer indicating that the order\n     *                  has been approved.\n     */\n    function _validateBasicOrderAndUpdateStatus(\n        bytes32 orderHash,\n        address offerer,\n        bytes memory signature\n    ) internal {\n        // Retrieve the order status for the given order hash.\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\n\n        // Ensure order is fillable and is not cancelled.\n        _verifyOrderStatus(\n            orderHash,\n            orderStatus,\n            true, // Only allow unused orders when fulfilling basic orders.\n            true // Signifies to revert if the order is invalid.\n        );\n\n        // If the order is not already validated, verify the supplied signature.\n        if (!orderStatus.isValidated) {\n            _verifySignature(offerer, orderHash, signature);\n        }\n\n        // Update order status as fully filled, packing struct values.\n        _orderStatus[orderHash].isValidated = true;\n        _orderStatus[orderHash].isCancelled = false;\n        _orderStatus[orderHash].numerator = 1;\n        _orderStatus[orderHash].denominator = 1;\n    }\n\n    /**\n     * @dev Internal function to validate an order, determine what portion to\n     *      fill, and update its status. The desired fill amount is supplied as\n     *      a fraction, as is the returned amount to fill.\n     *\n     * @param advancedOrder     The order to fulfill as well as the fraction to\n     *                          fill. Note that all offer and consideration\n     *                          amounts must divide with no remainder in order\n     *                          for a partial fill to be valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific offer or consideration, a token\n     *                          identifier, and a proof that the supplied token\n     *                          identifier is contained in the order's merkle\n     *                          root. Note that a criteria of zero indicates\n     *                          that any (transferrable) token identifier is\n     *                          valid and that no proof needs to be supplied.\n     * @param revertOnInvalid   A boolean indicating whether to revert if the\n     *                          order is invalid due to the time or status.\n     * @param priorOrderHashes  The order hashes of each order supplied prior to\n     *                          the current order as part of a \"match\" variety\n     *                          of order fulfillment (e.g. this array will be\n     *                          empty for single or \"fulfill available\").\n     *\n     * @return orderHash      The order hash.\n     * @return newNumerator   A value indicating the portion of the order that\n     *                        will be filled.\n     * @return newDenominator A value indicating the total size of the order.\n     */\n    function _validateOrderAndUpdateStatus(\n        AdvancedOrder memory advancedOrder,\n        CriteriaResolver[] memory criteriaResolvers,\n        bool revertOnInvalid,\n        bytes32[] memory priorOrderHashes\n    )\n        internal\n        returns (\n            bytes32 orderHash,\n            uint256 newNumerator,\n            uint256 newDenominator\n        )\n    {\n        // Retrieve the parameters for the order.\n        OrderParameters memory orderParameters = advancedOrder.parameters;\n\n        // Ensure current timestamp falls between order start time and end time.\n        if (\n            !_verifyTime(\n                orderParameters.startTime,\n                orderParameters.endTime,\n                revertOnInvalid\n            )\n        ) {\n            // Assuming an invalid time and no revert, return zeroed out values.\n            return (bytes32(0), 0, 0);\n        }\n\n        // Read numerator and denominator from memory and place on the stack.\n        uint256 numerator = uint256(advancedOrder.numerator);\n        uint256 denominator = uint256(advancedOrder.denominator);\n\n        // Ensure that the supplied numerator and denominator are valid.\n        if (numerator > denominator || numerator == 0) {\n            revert BadFraction();\n        }\n\n        // If attempting partial fill (n < d) check order type & ensure support.\n        if (\n            numerator < denominator &&\n            _doesNotSupportPartialFills(orderParameters.orderType)\n        ) {\n            // Revert if partial fill was attempted on an unsupported order.\n            revert PartialFillsNotEnabledForOrder();\n        }\n\n        // Retrieve current nonce and use it w/ parameters to derive order hash.\n        orderHash = _assertConsiderationLengthAndGetNoncedOrderHash(\n            orderParameters\n        );\n\n        // Ensure restricted orders have a valid submitter or pass a zone check.\n        _assertRestrictedAdvancedOrderValidity(\n            advancedOrder,\n            criteriaResolvers,\n            priorOrderHashes,\n            orderHash,\n            orderParameters.zoneHash,\n            orderParameters.orderType,\n            orderParameters.offerer,\n            orderParameters.zone\n        );\n\n        // Retrieve the order status using the derived order hash.\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\n\n        // Ensure order is fillable and is not cancelled.\n        if (\n            !_verifyOrderStatus(\n                orderHash,\n                orderStatus,\n                false, // Allow partially used orders to be filled.\n                revertOnInvalid\n            )\n        ) {\n            // Assuming an invalid order status and no revert, return zero fill.\n            return (orderHash, 0, 0);\n        }\n\n        // If the order is not already validated, verify the supplied signature.\n        if (!orderStatus.isValidated) {\n            _verifySignature(\n                orderParameters.offerer,\n                orderHash,\n                advancedOrder.signature\n            );\n        }\n\n        // Read filled amount as numerator and denominator and put on the stack.\n        uint256 filledNumerator = orderStatus.numerator;\n        uint256 filledDenominator = orderStatus.denominator;\n\n        // If order currently has a non-zero denominator it is partially filled.\n        if (filledDenominator != 0) {\n            // If denominator of 1 supplied, fill all remaining amount on order.\n            if (denominator == 1) {\n                // Scale numerator & denominator to match current denominator.\n                numerator = filledDenominator;\n                denominator = filledDenominator;\n            }\n            // Otherwise, if supplied denominator differs from current one...\n            else if (filledDenominator != denominator) {\n                // scale current numerator by the supplied denominator, then...\n                filledNumerator *= denominator;\n\n                // the supplied numerator & denominator by current denominator.\n                numerator *= filledDenominator;\n                denominator *= filledDenominator;\n            }\n\n            // Once adjusted, if current+supplied numerator exceeds denominator:\n            if (filledNumerator + numerator > denominator) {\n                // Skip underflow check: denominator >= orderStatus.numerator\n                unchecked {\n                    // Reduce current numerator so it + supplied = denominator.\n                    numerator = denominator - filledNumerator;\n                }\n            }\n\n            // Skip overflow check: checked above unless numerator is reduced.\n            unchecked {\n                // Update order status and fill amount, packing struct values.\n                _orderStatus[orderHash].isValidated = true;\n                _orderStatus[orderHash].isCancelled = false;\n                _orderStatus[orderHash].numerator = uint120(\n                    filledNumerator + numerator\n                );\n                _orderStatus[orderHash].denominator = uint120(denominator);\n            }\n        } else {\n            // Update order status and fill amount, packing struct values.\n            _orderStatus[orderHash].isValidated = true;\n            _orderStatus[orderHash].isCancelled = false;\n            _orderStatus[orderHash].numerator = uint120(numerator);\n            _orderStatus[orderHash].denominator = uint120(denominator);\n        }\n\n        // Return order hash, a modified numerator, and a modified denominator.\n        return (orderHash, numerator, denominator);\n    }\n\n    /**\n     * @dev Internal function to cancel an arbitrary number of orders. Note that\n     *      only the offerer or the zone of a given order may cancel it. Callers\n     *      should ensure that the intended order was cancelled by calling\n     *      `getOrderStatus` and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders were\n     *                   successfully cancelled.\n     */\n    function _cancel(OrderComponents[] calldata orders)\n        internal\n        returns (bool cancelled)\n    {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        address offerer;\n        address zone;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Read length of the orders array from memory and place on stack.\n            uint256 totalOrders = orders.length;\n\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ) {\n                // Retrieve the order.\n                OrderComponents calldata order = orders[i];\n\n                offerer = order.offerer;\n                zone = order.zone;\n\n                // Ensure caller is either offerer or zone of the order.\n                if (msg.sender != offerer && msg.sender != zone) {\n                    revert InvalidCanceller();\n                }\n\n                // Derive order hash using the order parameters and the nonce.\n                bytes32 orderHash = _deriveOrderHash(\n                    OrderParameters(\n                        offerer,\n                        zone,\n                        order.offer,\n                        order.consideration,\n                        order.orderType,\n                        order.startTime,\n                        order.endTime,\n                        order.zoneHash,\n                        order.salt,\n                        order.conduitKey,\n                        order.consideration.length\n                    ),\n                    order.nonce\n                );\n\n                // Update the order status as not valid and cancelled.\n                _orderStatus[orderHash].isValidated = false;\n                _orderStatus[orderHash].isCancelled = true;\n\n                // Emit an event signifying that the order has been cancelled.\n                emit OrderCancelled(orderHash, offerer, zone);\n\n                // Increment counter inside body of loop for gas efficiency.\n                ++i;\n            }\n        }\n\n        // Return a boolean indicating that orders were successfully cancelled.\n        cancelled = true;\n    }\n\n    /**\n     * @dev Internal function to validate an arbitrary number of orders, thereby\n     *      registering their signatures as valid and allowing the fulfiller to\n     *      skip signature verification on fulfillment. Note that validated\n     *      orders may still be unfulfillable due to invalid item amounts or\n     *      other factors; callers should determine whether validated orders are\n     *      fulfillable by simulating the fulfillment call prior to execution.\n     *      Also note that anyone can validate a signed order, but only the\n     *      offerer can validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders were\n     *                   successfully validated.\n     */\n    function _validate(Order[] calldata orders)\n        internal\n        returns (bool validated)\n    {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        // Declare variables outside of the loop.\n        bytes32 orderHash;\n        address offerer;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Read length of the orders array from memory and place on stack.\n            uint256 totalOrders = orders.length;\n\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ) {\n                // Retrieve the order.\n                Order calldata order = orders[i];\n\n                // Retrieve the order parameters.\n                OrderParameters calldata orderParameters = order.parameters;\n\n                // Move offerer from memory to the stack.\n                offerer = orderParameters.offerer;\n\n                // Get current nonce and use it w/ params to derive order hash.\n                orderHash = _assertConsiderationLengthAndGetNoncedOrderHash(\n                    orderParameters\n                );\n\n                // Retrieve the order status using the derived order hash.\n                OrderStatus memory orderStatus = _orderStatus[orderHash];\n\n                // Ensure order is fillable and retrieve the filled amount.\n                _verifyOrderStatus(\n                    orderHash,\n                    orderStatus,\n                    false, // Signifies that partially filled orders are valid.\n                    true // Signifies to revert if the order is invalid.\n                );\n\n                // If the order has not already been validated...\n                if (!orderStatus.isValidated) {\n                    // Verify the supplied signature.\n                    _verifySignature(offerer, orderHash, order.signature);\n\n                    // Update order status to mark the order as valid.\n                    _orderStatus[orderHash].isValidated = true;\n\n                    // Emit an event signifying the order has been validated.\n                    emit OrderValidated(\n                        orderHash,\n                        offerer,\n                        orderParameters.zone\n                    );\n                }\n\n                // Increment counter inside body of the loop for gas efficiency.\n                ++i;\n            }\n        }\n\n        // Return a boolean indicating that orders were successfully validated.\n        validated = true;\n    }\n\n    /**\n     * @dev Internal view function to retrieve the status of a given order by\n     *      hash, including whether the order has been cancelled or validated\n     *      and the fraction of the order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function _getOrderStatus(bytes32 orderHash)\n        internal\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        )\n    {\n        // Retrieve the order status using the order hash.\n        OrderStatus memory orderStatus = _orderStatus[orderHash];\n\n        // Return the fields on the order status.\n        return (\n            orderStatus.isValidated,\n            orderStatus.isCancelled,\n            orderStatus.numerator,\n            orderStatus.denominator\n        );\n    }\n\n    /**\n     * @dev Internal pure function to check whether a given order type indicates\n     *      that partial fills are not supported (e.g. only \"full fills\" are\n     *      allowed for the order in question).\n     *\n     * @param orderType The order type in question.\n     *\n     * @return isFullOrder A boolean indicating whether the order type only\n     *                     supports full fills.\n     */\n    function _doesNotSupportPartialFills(OrderType orderType)\n        internal\n        pure\n        returns (bool isFullOrder)\n    {\n        // The \"full\" order types are even, while \"partial\" order types are odd.\n        // Bitwise and by 1 is equivalent to modulo by 2, but 2 gas cheaper.\n        assembly {\n            // Equivalent to `uint256(orderType) & 1 == 0`.\n            isFullOrder := iszero(and(orderType, 1))\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\n// prettier-ignore\nimport {\n    BasicOrderParameters,\n    OrderComponents,\n    Fulfillment,\n    FulfillmentComponent,\n    Execution,\n    Order,\n    AdvancedOrder,\n    OrderStatus,\n    CriteriaResolver\n} from \"../lib/ConsiderationStructs.sol\";\n\n/**\n * @title ConsiderationInterface\n * @author 0age\n * @custom:version 1\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.\n *         It minimizes external calls to the greatest extent possible and\n *         provides lightweight methods for common routes as well as more\n *         flexible methods for composing advanced orders.\n *\n * @dev ConsiderationInterface contains all external function interfaces for\n *      Consideration.\n */\ninterface ConsiderationInterface {\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of \"additional recipients\" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder(BasicOrderParameters calldata parameters)\n        external\n        payable\n        returns (bool fulfilled);\n\n    /**\n     * @notice Fulfill an order with an arbitrary number of items for offer and\n     *         consideration. Note that this function does not support\n     *         criteria-based orders or partial filling of orders (though\n     *         filling the remainder of a partially-filled order is supported).\n     *\n     * @param order               The order to fulfill. Note that both the\n     *                            offerer and the fulfiller must first approve\n     *                            this contract (or the corresponding conduit if\n     *                            indicated) to transfer any relevant tokens on\n     *                            their behalf and that contracts must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens\n     *                            as consideration.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillOrder(Order calldata order, bytes32 fulfillerConduitKey)\n        external\n        payable\n        returns (bool fulfilled);\n\n    /**\n     * @notice Fill an order, fully or partially, with an arbitrary number of\n     *         items for offer and consideration alongside criteria resolvers\n     *         containing specific token identifiers and associated proofs.\n     *\n     * @param advancedOrder       The order to fulfill along with the fraction\n     *                            of the order to attempt to fill. Note that\n     *                            both the offerer and the fulfiller must first\n     *                            approve this contract (or their preferred\n     *                            conduit if indicated by the order) to transfer\n     *                            any relevant tokens on their behalf and that\n     *                            contracts must implement `onERC1155Received`\n     *                            to receive ERC1155 tokens as consideration.\n     *                            Also note that all offer and consideration\n     *                            components must have no remainder after\n     *                            multiplication of the respective amount with\n     *                            the supplied fraction for the partial fill to\n     *                            be considered valid.\n     * @param criteriaResolvers   An array where each element contains a\n     *                            reference to a specific offer or\n     *                            consideration, a token identifier, and a proof\n     *                            that the supplied token identifier is\n     *                            contained in the merkle root held by the item\n     *                            in question's criteria element. Note that an\n     *                            empty criteria indicates that any\n     *                            (transferrable) token identifier on the token\n     *                            in question is valid and that no associated\n     *                            proof needs to be supplied.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillAdvancedOrder(\n        AdvancedOrder calldata advancedOrder,\n        CriteriaResolver[] calldata criteriaResolvers,\n        bytes32 fulfillerConduitKey\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\n     *         of items for offer and consideration. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *         Note that this function does not support criteria-based orders or\n     *         partial filling of orders (though filling the remainder of a\n     *         partially-filled order is supported).\n     *\n     * @param orders                    The orders to fulfill. Note that both\n     *                                  the offerer and the fulfiller must first\n     *                                  approve this contract (or the\n     *                                  corresponding conduit if indicated) to\n     *                                  transfer any relevant tokens on their\n     *                                  behalf and that contracts must implement\n     *                                  `onERC1155Received` to receive ERC1155\n     *                                  tokens as consideration.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableOrders(\n        Order[] calldata orders,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Attempt to fill a group of orders, fully or partially, with an\n     *         arbitrary number of items for offer and consideration per order\n     *         alongside criteria resolvers containing specific token\n     *         identifiers and associated proofs. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or their preferred conduit if\n     *                                  indicated by the order) to transfer any\n     *                                  relevant tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` to enable receipt of\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferrable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] calldata advancedOrders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of orders, each with an arbitrary\n     *         number of items for offer and consideration along with as set of\n     *         fulfillments allocating offer components to consideration\n     *         components. Note that this function does not support\n     *         criteria-based or partial filling of orders (though filling the\n     *         remainder of a partially-filled order is supported).\n     *\n     * @param orders       The orders to match. Note that both the offerer and\n     *                     fulfiller on each order must first approve this\n     *                     contract (or their conduit if indicated by the order)\n     *                     to transfer any relevant tokens on their behalf and\n     *                     each consideration recipient must implement\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\n     * @param fulfillments An array of elements allocating offer components to\n     *                     consideration components. Note that each\n     *                     consideration component must be fully met for the\n     *                     match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function matchOrders(\n        Order[] calldata orders,\n        Fulfillment[] calldata fulfillments\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of full or partial orders, each with an\n     *         arbitrary number of items for offer and consideration, supplying\n     *         criteria resolvers containing specific token identifiers and\n     *         associated proofs as well as fulfillments allocating offer\n     *         components to consideration components.\n     *\n     * @param orders            The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or a preferred conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order toreceive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          an empty root indicates that any (transferrable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function matchAdvancedOrders(\n        AdvancedOrder[] calldata orders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        Fulfillment[] calldata fulfillments\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\n     *         or the zone of a given order may cancel it. Callers should ensure\n     *         that the intended order was cancelled by calling `getOrderStatus`\n     *         and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders have\n     *                   been successfully cancelled.\n     */\n    function cancel(OrderComponents[] calldata orders)\n        external\n        returns (bool cancelled);\n\n    /**\n     * @notice Validate an arbitrary number of orders, thereby registering their\n     *         signatures as valid and allowing the fulfiller to skip signature\n     *         verification on fulfillment. Note that validated orders may still\n     *         be unfulfillable due to invalid item amounts or other factors;\n     *         callers should determine whether validated orders are fulfillable\n     *         by simulating the fulfillment call prior to execution. Also note\n     *         that anyone can validate a signed order, but only the offerer can\n     *         validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders have\n     *                   been successfully validated.\n     */\n    function validate(Order[] calldata orders)\n        external\n        returns (bool validated);\n\n    /**\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\n     *         by incrementing a nonce. Note that only the offerer may increment\n     *         the nonce.\n     *\n     * @return newNonce The new nonce.\n     */\n    function incrementNonce() external returns (uint256 newNonce);\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(OrderComponents calldata order)\n        external\n        view\n        returns (bytes32 orderHash);\n\n    /**\n     * @notice Retrieve the status of a given order by hash, including whether\n     *         the order has been cancelled or validated and the fraction of the\n     *         order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function getOrderStatus(bytes32 orderHash)\n        external\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        );\n\n    /**\n     * @notice Retrieve the current nonce for a given offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return nonce The current nonce.\n     */\n    function getNonce(address offerer) external view returns (uint256 nonce);\n\n    /**\n     * @notice Retrieve configuration information for this contract.\n     *\n     * @return version           The contract version.\n     * @return domainSeparator   The domain separator for this contract.\n     * @return conduitController The conduit Controller set for this contract.\n     */\n    function information()\n        external\n        view\n        returns (\n            string memory version,\n            bytes32 domainSeparator,\n            address conduitController\n        );\n\n    /**\n     * @notice Retrieve the name of this contract.\n     *\n     * @return contractName The name of this contract.\n     */\n    function name() external view returns (string memory contractName);\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\nimport { SpentItem, ReceivedItem } from \"../lib/ConsiderationStructs.sol\";\n\n/**\n * @title ConsiderationEventsAndErrors\n * @author 0age\n * @notice ConsiderationEventsAndErrors contains all events and errors.\n */\ninterface ConsiderationEventsAndErrors {\n    /**\n     * @dev Emit an event whenever an order is successfully fulfilled.\n     *\n     * @param orderHash     The hash of the fulfilled order.\n     * @param offerer       The offerer of the fulfilled order.\n     * @param zone          The zone of the fulfilled order.\n     * @param fulfiller     The fulfiller of the order, or the null address if\n     *                      there is no specific fulfiller (i.e. the order is\n     *                      part of a group of orders).\n     * @param offer         The offer items spent as part of the order.\n     * @param consideration The consideration items received as part of the\n     *                      order along with the recipients of each item.\n     */\n    event OrderFulfilled(\n        bytes32 orderHash,\n        address indexed offerer,\n        address indexed zone,\n        address fulfiller,\n        SpentItem[] offer,\n        ReceivedItem[] consideration\n    );\n\n    /**\n     * @dev Emit an event whenever an order is successfully cancelled.\n     *\n     * @param orderHash The hash of the cancelled order.\n     * @param offerer   The offerer of the cancelled order.\n     * @param zone      The zone of the cancelled order.\n     */\n    event OrderCancelled(\n        bytes32 orderHash,\n        address indexed offerer,\n        address indexed zone\n    );\n\n    /**\n     * @dev Emit an event whenever an order is explicitly validated. Note that\n     *      this event will not be emitted on partial fills even though they do\n     *      validate the order as part of partial fulfillment.\n     *\n     * @param orderHash The hash of the validated order.\n     * @param offerer   The offerer of the validated order.\n     * @param zone      The zone of the validated order.\n     */\n    event OrderValidated(\n        bytes32 orderHash,\n        address indexed offerer,\n        address indexed zone\n    );\n\n    /**\n     * @dev Emit an event whenever a nonce for a given offerer is incremented.\n     *\n     * @param newNonce The new nonce for the offerer.\n     * @param offerer  The offerer in question.\n     */\n    event NonceIncremented(uint256 newNonce, address indexed offerer);\n\n    /**\n     * @dev Revert with an error when attempting to fill an order that has\n     *      already been fully filled.\n     *\n     * @param orderHash The order hash on which a fill was attempted.\n     */\n    error OrderAlreadyFilled(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to fill an order outside the\n     *      specified start time and end time.\n     */\n    error InvalidTime();\n\n    /**\n     * @dev Revert with an error when attempting to fill an order referencing an\n     *      invalid conduit (i.e. one that has not been deployed).\n     */\n    error InvalidConduit(bytes32 conduitKey, address conduit);\n\n    /**\n     * @dev Revert with an error when an order is supplied for fulfillment with\n     *      a consideration array that is shorter than the original array.\n     */\n    error MissingOriginalConsiderationItems();\n\n    /**\n     * @dev Revert with an error when a call to a conduit fails with revert data\n     *      that is too expensive to return.\n     */\n    error InvalidCallToConduit(address conduit);\n\n    /**\n     * @dev Revert with an error if a consideration amount has not been fully\n     *      zeroed out after applying all fulfillments.\n     *\n     * @param orderIndex         The index of the order with the consideration\n     *                           item with a shortfall.\n     * @param considerationIndex The index of the consideration item on the\n     *                           order.\n     * @param shortfallAmount    The unfulfilled consideration amount.\n     */\n    error ConsiderationNotMet(\n        uint256 orderIndex,\n        uint256 considerationIndex,\n        uint256 shortfallAmount\n    );\n\n    /**\n     * @dev Revert with an error when insufficient ether is supplied as part of\n     *      msg.value when fulfilling orders.\n     */\n    error InsufficientEtherSupplied();\n\n    /**\n     * @dev Revert with an error when an ether transfer reverts.\n     */\n    error EtherTransferGenericFailure(address account, uint256 amount);\n\n    /**\n     * @dev Revert with an error when a partial fill is attempted on an order\n     *      that does not specify partial fill support in its order type.\n     */\n    error PartialFillsNotEnabledForOrder();\n\n    /**\n     * @dev Revert with an error when attempting to fill an order that has been\n     *      cancelled.\n     *\n     * @param orderHash The hash of the cancelled order.\n     */\n    error OrderIsCancelled(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to fill a basic order that has\n     *      been partially filled.\n     *\n     * @param orderHash The hash of the partially used order.\n     */\n    error OrderPartiallyFilled(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to cancel an order as a caller\n     *      other than the indicated offerer or zone.\n     */\n    error InvalidCanceller();\n\n    /**\n     * @dev Revert with an error when supplying a fraction with a value of zero\n     *      for the numerator or denominator, or one where the numerator exceeds\n     *      the denominator.\n     */\n    error BadFraction();\n\n    /**\n     * @dev Revert with an error when a caller attempts to supply callvalue to a\n     *      non-payable basic order route or does not supply any callvalue to a\n     *      payable basic order route.\n     */\n    error InvalidMsgValue(uint256 value);\n\n    /**\n     * @dev Revert with an error when attempting to fill a basic order using\n     *      calldata not produced by default ABI encoding.\n     */\n    error InvalidBasicOrderParameterEncoding();\n\n    /**\n     * @dev Revert with an error when attempting to fulfill any number of\n     *      available orders when none are fulfillable.\n     */\n    error NoSpecifiedOrdersAvailable();\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\nimport { ConduitInterface } from \"../interfaces/ConduitInterface.sol\";\n\nimport { ConduitItemType } from \"./lib/ConduitEnums.sol\";\n\nimport { TokenTransferrer } from \"../lib/TokenTransferrer.sol\";\n\n// prettier-ignore\nimport {\n    ConduitTransfer,\n    ConduitBatch1155Transfer\n} from \"./lib/ConduitStructs.sol\";\n\n/**\n * @title Conduit\n * @author 0age\n * @notice This contract serves as an originator for \"proxied\" transfers. Each\n *         conduit is deployed and controlled by a \"conduit controller\" that can\n *         add and remove \"channels\" or contracts that can instruct the conduit\n *         to transfer approved ERC20/721/1155 tokens. *IMPORTANT NOTE: each\n *         conduit has an owner that can arbitrarily add or remove channels, and\n *         a malicious or negligent owner can add a channel that allows for any\n *         approved ERC20/721/1155 tokens to be taken immediately \u2014 be extremely\n *         cautious with what conduits you give token approvals to!*\n */\ncontract Conduit is ConduitInterface, TokenTransferrer {\n    // Set deployer as an immutable controller that can update channel statuses.\n    address private immutable _controller;\n\n    // Track the status of each channel.\n    mapping(address => bool) private _channels;\n\n    /**\n     * @notice In the constructor, set the deployer as the controller.\n     */\n    constructor() {\n        // Set the deployer as the controller.\n        _controller = msg.sender;\n    }\n\n    /**\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\n     *         with an open channel can call this function.\n     *\n     * @param transfers The ERC20/721/1155 transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function execute(ConduitTransfer[] calldata transfers)\n        external\n        override\n        returns (bytes4 magicValue)\n    {\n        // Ensure that the caller has an open channel.\n        if (!_channels[msg.sender]) {\n            revert ChannelClosed();\n        }\n\n        // Retrieve the total number of transfers and place on the stack.\n        uint256 totalStandardTransfers = transfers.length;\n\n        // Iterate over each transfer.\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\n            // Retrieve the transfer in question.\n            ConduitTransfer calldata standardTransfer = transfers[i];\n\n            // Perform the transfer.\n            _transfer(standardTransfer);\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Return a magic value indicating that the transfers were performed.\n        magicValue = this.execute.selector;\n    }\n\n    /**\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\n     *         open channel can call this function.\n     *\n     * @param batchTransfers The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeBatch1155(\n        ConduitBatch1155Transfer[] calldata batchTransfers\n    ) external override returns (bytes4 magicValue) {\n        // Ensure that the caller has an open channel.\n        if (!_channels[msg.sender]) {\n            revert ChannelClosed();\n        }\n\n        // Perform 1155 batch transfers.\n        _performERC1155BatchTransfers(batchTransfers);\n\n        // Return a magic value indicating that the transfers were performed.\n        magicValue = this.executeBatch1155.selector;\n    }\n\n    /**\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\n     *         a caller with an open channel can call this function.\n     *\n     * @param standardTransfers The ERC20/721/1155 transfers to perform.\n     * @param batchTransfers    The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeWithBatch1155(\n        ConduitTransfer[] calldata standardTransfers,\n        ConduitBatch1155Transfer[] calldata batchTransfers\n    ) external override returns (bytes4 magicValue) {\n        // Ensure that the caller has an open channel.\n        if (!_channels[msg.sender]) {\n            revert ChannelClosed();\n        }\n\n        // Retrieve the total number of transfers and place on the stack.\n        uint256 totalStandardTransfers = standardTransfers.length;\n\n        // Iterate over each standard transfer.\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\n            // Retrieve the transfer in question.\n            ConduitTransfer calldata standardTransfer = standardTransfers[i];\n\n            // Perform the transfer.\n            _transfer(standardTransfer);\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Perform 1155 batch transfers.\n        _performERC1155BatchTransfers(batchTransfers);\n\n        // Return a magic value indicating that the transfers were performed.\n        magicValue = this.executeWithBatch1155.selector;\n    }\n\n    /**\n     * @notice Open or close a given channel. Only callable by the controller.\n     *\n     * @param channel The channel to open or close.\n     * @param isOpen  The status of the channel (either open or closed).\n     */\n    function updateChannel(address channel, bool isOpen) external override {\n        // Ensure that the caller is the controller of this contract.\n        if (msg.sender != _controller) {\n            revert InvalidController();\n        }\n\n        // Update the status of the channel.\n        _channels[channel] = isOpen;\n\n        // Emit a corresponding event.\n        emit ChannelUpdated(channel, isOpen);\n    }\n\n    /**\n     * @dev Internal function to transfer a given ERC20/721/1155 item.\n     *\n     * @param item The ERC20/721/1155 item to transfer.\n     */\n    function _transfer(ConduitTransfer calldata item) internal {\n        // If the item type indicates Ether or a native token...\n        if (item.itemType == ConduitItemType.ERC20) {\n            // Transfer ERC20 token.\n            _performERC20Transfer(item.token, item.from, item.to, item.amount);\n        } else if (item.itemType == ConduitItemType.ERC721) {\n            // Ensure that exactly one 721 item is being transferred.\n            if (item.amount != 1) {\n                revert InvalidERC721TransferAmount();\n            }\n\n            // Transfer ERC721 token.\n            _performERC721Transfer(\n                item.token,\n                item.from,\n                item.to,\n                item.identifier\n            );\n        } else if (item.itemType == ConduitItemType.ERC1155) {\n            // Transfer ERC1155 token.\n            _performERC1155Transfer(\n                item.token,\n                item.from,\n                item.to,\n                item.identifier,\n                item.amount\n            );\n        } else {\n            // Throw with an error.\n            revert InvalidItemType();\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\n// prettier-ignore\nenum OrderType {\n    // 0: no partial fills, anyone can execute\n    FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    PARTIAL_RESTRICTED\n}\n\n// prettier-ignore\nenum BasicOrderType {\n    // 0: no partial fills, anyone can execute\n    ETH_TO_ERC721_FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    ETH_TO_ERC721_PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC721_FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 4: no partial fills, anyone can execute\n    ETH_TO_ERC1155_FULL_OPEN,\n\n    // 5: partial fills supported, anyone can execute\n    ETH_TO_ERC1155_PARTIAL_OPEN,\n\n    // 6: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC1155_FULL_RESTRICTED,\n\n    // 7: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 8: no partial fills, anyone can execute\n    ERC20_TO_ERC721_FULL_OPEN,\n\n    // 9: partial fills supported, anyone can execute\n    ERC20_TO_ERC721_PARTIAL_OPEN,\n\n    // 10: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC721_FULL_RESTRICTED,\n\n    // 11: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 12: no partial fills, anyone can execute\n    ERC20_TO_ERC1155_FULL_OPEN,\n\n    // 13: partial fills supported, anyone can execute\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\n\n    // 14: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\n\n    // 15: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 16: no partial fills, anyone can execute\n    ERC721_TO_ERC20_FULL_OPEN,\n\n    // 17: partial fills supported, anyone can execute\n    ERC721_TO_ERC20_PARTIAL_OPEN,\n\n    // 18: no partial fills, only offerer or zone can execute\n    ERC721_TO_ERC20_FULL_RESTRICTED,\n\n    // 19: partial fills supported, only offerer or zone can execute\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\n\n    // 20: no partial fills, anyone can execute\n    ERC1155_TO_ERC20_FULL_OPEN,\n\n    // 21: partial fills supported, anyone can execute\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\n\n    // 22: no partial fills, only offerer or zone can execute\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\n\n    // 23: partial fills supported, only offerer or zone can execute\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\n}\n\n// prettier-ignore\nenum BasicOrderRouteType {\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\n    ETH_TO_ERC721,\n\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\n    ETH_TO_ERC1155,\n\n    // 2: provide ERC20 item to receive offered ERC721 item.\n    ERC20_TO_ERC721,\n\n    // 3: provide ERC20 item to receive offered ERC1155 item.\n    ERC20_TO_ERC1155,\n\n    // 4: provide ERC721 item to receive offered ERC20 item.\n    ERC721_TO_ERC20,\n\n    // 5: provide ERC1155 item to receive offered ERC20 item.\n    ERC1155_TO_ERC20\n}\n\n// prettier-ignore\nenum ItemType {\n    // 0: ETH on mainnet, MATIC on polygon, etc.\n    NATIVE,\n\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\n    ERC20,\n\n    // 2: ERC721 items\n    ERC721,\n\n    // 3: ERC1155 items\n    ERC1155,\n\n    // 4: ERC721 items where a number of tokenIds are supported\n    ERC721_WITH_CRITERIA,\n\n    // 5: ERC1155 items where a number of ids are supported\n    ERC1155_WITH_CRITERIA\n}\n\n// prettier-ignore\nenum Side {\n    // 0: Items that can be spent\n    OFFER,\n    \n    // 1: Items that must be received\n    CONSIDERATION\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { Side, ItemType } from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    AdditionalRecipient,\n    OfferItem,\n    ConsiderationItem,\n    SpentItem,\n    ReceivedItem,\n    OrderParameters,\n    Fulfillment,\n    FulfillmentComponent,\n    Execution,\n    Order,\n    AdvancedOrder,\n    CriteriaResolver\n} from \"./ConsiderationStructs.sol\";\n\nimport { OrderFulfiller } from \"./OrderFulfiller.sol\";\n\nimport { FulfillmentApplier } from \"./FulfillmentApplier.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title OrderCombiner\n * @author 0age\n * @notice OrderCombiner contains logic for fulfilling combinations of orders,\n *         either by matching offer items to consideration items or by\n *         fulfilling orders where available.\n */\ncontract OrderCombiner is OrderFulfiller, FulfillmentApplier {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderFulfiller(conduitController) {}\n\n    /**\n     * @notice Internal function to attempt to fill a group of orders, fully or\n     *         partially, with an arbitrary number of items for offer and\n     *         consideration per order alongside criteria resolvers containing\n     *         specific token identifiers and associated proofs. Any order that\n     *         is not currently active, has already been fully filled, or has\n     *         been cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or a conduit if indicated by\n     *                                  the order) to transfer any relevant\n     *                                  tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` in order to receive\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferrable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used (and\n     *                                  direct approvals set on Consideration).\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function _fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        internal\n        returns (bool[] memory availableOrders, Execution[] memory executions)\n    {\n        // Validate orders, apply amounts, & determine if they utilize conduits.\n        _validateOrdersAndPrepareToFulfill(\n            advancedOrders,\n            criteriaResolvers,\n            false, // Signifies that invalid orders should NOT revert.\n            maximumFulfilled\n        );\n\n        // Aggregate used offer and consideration items and execute transfers.\n        (availableOrders, executions) = _executeAvailableFulfillments(\n            advancedOrders,\n            offerFulfillments,\n            considerationFulfillments,\n            fulfillerConduitKey\n        );\n\n        // Return order fulfillment details and executions.\n        return (availableOrders, executions);\n    }\n\n    /**\n     * @dev Internal function to validate a group of orders, update their\n     *      statuses, reduce amounts by their previously filled fractions, apply\n     *      criteria resolvers, and emit OrderFulfilled events.\n     *\n     * @param advancedOrders    The advanced orders to validate and reduce by\n     *                          their previously filled amounts.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          a root of zero indicates that any transferrable\n     *                          token identifier is valid and that no proof\n     *                          needs to be supplied.\n     * @param revertOnInvalid   A boolean indicating whether to revert on any\n     *                          order being invalid; setting this to false will\n     *                          instead cause the invalid order to be skipped.\n     * @param maximumFulfilled  The maximum number of orders to fulfill.\n     */\n    function _validateOrdersAndPrepareToFulfill(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        bool revertOnInvalid,\n        uint256 maximumFulfilled\n    ) internal {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard();\n\n        // Read length of orders array and place on the stack.\n        uint256 totalOrders = advancedOrders.length;\n\n        // Track the order hash for each order being fulfilled.\n        bytes32[] memory orderHashes = new bytes32[](totalOrders);\n\n        // Override orderHashes length to zero after memory has been allocated.\n        assembly {\n            mstore(orderHashes, 0)\n        }\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ++i) {\n                // Retrieve the current order.\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\n\n                // Determine if max number orders have already been fulfilled.\n                if (maximumFulfilled == 0) {\n                    // Mark fill fraction as zero as the order will not be used.\n                    advancedOrder.numerator = 0;\n\n                    // Update the length of the orderHashes array.\n                    assembly {\n                        mstore(orderHashes, add(i, 1))\n                    }\n\n                    // Continue iterating through the remaining orders.\n                    continue;\n                }\n\n                // Validate it, update status, and determine fraction to fill.\n                (\n                    bytes32 orderHash,\n                    uint256 numerator,\n                    uint256 denominator\n                ) = _validateOrderAndUpdateStatus(\n                        advancedOrder,\n                        criteriaResolvers,\n                        revertOnInvalid,\n                        orderHashes\n                    );\n\n                // Update the length of the orderHashes array.\n                assembly {\n                    mstore(orderHashes, add(i, 1))\n                }\n\n                // Do not track hash or adjust prices if order is not fulfilled.\n                if (numerator == 0) {\n                    // Mark fill fraction as zero if the order is not fulfilled.\n                    advancedOrder.numerator = 0;\n\n                    // Continue iterating through the remaining orders.\n                    continue;\n                }\n\n                // Otherwise, track the order hash in question.\n                orderHashes[i] = orderHash;\n\n                // Decrement the number of fulfilled orders.\n                maximumFulfilled--;\n\n                // Place the start time for the order on the stack.\n                uint256 startTime = advancedOrder.parameters.startTime;\n\n                // Derive the duration for the order and place it on the stack.\n                uint256 duration = advancedOrder.parameters.endTime - startTime;\n\n                // Derive time elapsed since the order started & place on stack.\n                uint256 elapsed = block.timestamp - startTime;\n\n                // Derive time remaining until order expires and place on stack.\n                uint256 remaining = duration - elapsed;\n\n                // Retrieve array of offer items for the order in question.\n                OfferItem[] memory offer = advancedOrder.parameters.offer;\n\n                // Iterate over each offer item on the order.\n                for (uint256 j = 0; j < offer.length; ++j) {\n                    // Retrieve the offer item.\n                    OfferItem memory offerItem = offer[j];\n\n                    // Apply order fill fraction to offer item end amount.\n                    uint256 endAmount = _getFraction(\n                        numerator,\n                        denominator,\n                        offerItem.endAmount\n                    );\n\n                    // Reuse same fraction if start and end amounts are equal.\n                    if (offerItem.startAmount == offerItem.endAmount) {\n                        // Apply derived amount to both start and end amount.\n                        offerItem.startAmount = endAmount;\n                    } else {\n                        // Apply order fill fraction to offer item start amount.\n                        offerItem.startAmount = _getFraction(\n                            numerator,\n                            denominator,\n                            offerItem.startAmount\n                        );\n                    }\n\n                    // Update end amount in memory to match the derived amount.\n                    offerItem.endAmount = endAmount;\n\n                    // Adjust offer amount using current time; round down.\n                    offerItem.startAmount = _locateCurrentAmount(\n                        offerItem.startAmount,\n                        offerItem.endAmount,\n                        elapsed,\n                        remaining,\n                        duration,\n                        false // round down\n                    );\n                }\n\n                // Retrieve array of consideration items for order in question.\n                ConsiderationItem[] memory consideration = (\n                    advancedOrder.parameters.consideration\n                );\n\n                // Iterate over each consideration item on the order.\n                for (uint256 j = 0; j < consideration.length; ++j) {\n                    // Retrieve the consideration item.\n                    ConsiderationItem memory considerationItem = (\n                        consideration[j]\n                    );\n\n                    // Apply fraction to consideration item end amount.\n                    uint256 endAmount = _getFraction(\n                        numerator,\n                        denominator,\n                        considerationItem.endAmount\n                    );\n\n                    // Reuse same fraction if start and end amounts are equal.\n                    if (\n                        considerationItem.startAmount ==\n                        considerationItem.endAmount\n                    ) {\n                        // Apply derived amount to both start and end amount.\n                        considerationItem.startAmount = endAmount;\n                    } else {\n                        // Apply fraction to consideration item start amount.\n                        considerationItem.startAmount = _getFraction(\n                            numerator,\n                            denominator,\n                            considerationItem.startAmount\n                        );\n                    }\n\n                    // Update end amount in memory to match the derived amount.\n                    considerationItem.endAmount = endAmount;\n\n                    // Adjust consideration amount using current time; round up.\n                    considerationItem.startAmount = (\n                        _locateCurrentAmount(\n                            considerationItem.startAmount,\n                            considerationItem.endAmount,\n                            elapsed,\n                            remaining,\n                            duration,\n                            true // round up\n                        )\n                    );\n\n                    // Utilize assembly to manually \"shift\" the recipient value.\n                    assembly {\n                        // Write recipient to endAmount, as endAmount is not\n                        // used from this point on and can be repurposed to fit\n                        // the layout of a ReceivedItem.\n                        mstore(\n                            add(\n                                considerationItem,\n                                ReceivedItem_recipient_offset // old endAmount\n                            ),\n                            mload(\n                                add(\n                                    considerationItem,\n                                    ConsiderationItem_recipient_offset\n                                )\n                            )\n                        )\n                    }\n                }\n            }\n        }\n\n        // Apply criteria resolvers to each order as applicable.\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\n\n        // Determine the fulfiller (revertOnInvalid ? address(0) : msg.sender).\n        address fulfiller;\n\n        // Utilize assembly to operate on revertOnInvalid boolean as an integer.\n        assembly {\n            // Set the fulfiller to the caller if revertOnValid is false.\n            fulfiller := mul(iszero(revertOnInvalid), caller())\n        }\n\n        // Emit an event for each order signifying that it has been fulfilled.\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ++i) {\n                // Do not emit an event if no order hash is present.\n                if (orderHashes[i] == bytes32(0)) {\n                    continue;\n                }\n\n                // Retrieve parameters for the order in question.\n                OrderParameters memory orderParameters = (\n                    advancedOrders[i].parameters\n                );\n\n                // Emit an OrderFulfilled event.\n                _emitOrderFulfilledEvent(\n                    orderHashes[i],\n                    orderParameters.offerer,\n                    orderParameters.zone,\n                    fulfiller,\n                    orderParameters.offer,\n                    orderParameters.consideration\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to fulfill a group of validated orders, fully or\n     *      partially, with an arbitrary number of items for offer and\n     *      consideration per order and to execute transfers. Any order that is\n     *      not currently active, has already been fully filled, or has been\n     *      cancelled will be omitted. Remaining offer and consideration items\n     *      will then be aggregated where possible as indicated by the supplied\n     *      offer and consideration component arrays and aggregated items will\n     *      be transferred to the fulfiller or to each intended recipient,\n     *      respectively. Note that a failing item transfer or an issue with\n     *      order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or the conduit if indicated by\n     *                                  the order) to transfer any relevant\n     *                                  tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` in order to receive\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on Consideration.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function _executeAvailableFulfillments(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[][] memory offerFulfillments,\n        FulfillmentComponent[][] memory considerationFulfillments,\n        bytes32 fulfillerConduitKey\n    )\n        internal\n        returns (bool[] memory availableOrders, Execution[] memory executions)\n    {\n        // Retrieve length of offer fulfillments array and place on the stack.\n        uint256 totalOfferFulfillments = offerFulfillments.length;\n\n        // Retrieve length of consideration fulfillments array & place on stack.\n        uint256 totalConsiderationFulfillments = (\n            considerationFulfillments.length\n        );\n\n        // Allocate an execution for each offer and consideration fulfillment.\n        executions = new Execution[](\n            totalOfferFulfillments + totalConsiderationFulfillments\n        );\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Track number of filtered executions.\n            uint256 totalFilteredExecutions = 0;\n\n            // Iterate over each offer fulfillment.\n            for (uint256 i = 0; i < totalOfferFulfillments; ++i) {\n                /// Retrieve the offer fulfillment components in question.\n                FulfillmentComponent[] memory components = (\n                    offerFulfillments[i]\n                );\n\n                // Derive aggregated execution corresponding with fulfillment.\n                Execution memory execution = _aggregateAvailable(\n                    advancedOrders,\n                    Side.OFFER,\n                    components,\n                    fulfillerConduitKey\n                );\n\n                // If offerer and recipient on the execution are the same...\n                if (execution.item.recipient == execution.offerer) {\n                    // increment total filtered executions.\n                    totalFilteredExecutions += 1;\n                } else {\n                    // Otherwise, assign the execution to the executions array.\n                    executions[i - totalFilteredExecutions] = execution;\n                }\n            }\n\n            // Iterate over each consideration fulfillment.\n            for (uint256 i = 0; i < totalConsiderationFulfillments; ++i) {\n                /// Retrieve consideration fulfillment components in question.\n                FulfillmentComponent[] memory components = (\n                    considerationFulfillments[i]\n                );\n\n                // Derive aggregated execution corresponding with fulfillment.\n                Execution memory execution = _aggregateAvailable(\n                    advancedOrders,\n                    Side.CONSIDERATION,\n                    components,\n                    fulfillerConduitKey\n                );\n\n                // If offerer and recipient on the execution are the same...\n                if (execution.item.recipient == execution.offerer) {\n                    // increment total filtered executions.\n                    totalFilteredExecutions += 1;\n                } else {\n                    // Otherwise, assign the execution to the executions array.\n                    executions[\n                        i + totalOfferFulfillments - totalFilteredExecutions\n                    ] = execution;\n                }\n            }\n\n            // If some number of executions have been filtered...\n            if (totalFilteredExecutions != 0) {\n                // reduce the total length of the executions array.\n                assembly {\n                    mstore(\n                        executions,\n                        sub(mload(executions), totalFilteredExecutions)\n                    )\n                }\n            }\n        }\n\n        // Revert if no orders are available.\n        if (executions.length == 0) {\n            revert NoSpecifiedOrdersAvailable();\n        }\n\n        // Perform final checks and return.\n        availableOrders = _performFinalChecksAndExecuteOrders(\n            advancedOrders,\n            executions\n        );\n\n        return (availableOrders, executions);\n    }\n\n    /**\n     * @dev Internal function to perform a final check that each consideration\n     *      item for an arbitrary number of fulfilled orders has been met and to\n     *      trigger associated executions, transferring the respective items.\n     *\n     * @param advancedOrders     The orders to check and perform executions for.\n     * @param executions         An array of elements indicating the sequence of\n     *                           transfers to perform when fulfilling the given\n     *                           orders.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     */\n    function _performFinalChecksAndExecuteOrders(\n        AdvancedOrder[] memory advancedOrders,\n        Execution[] memory executions\n    ) internal returns (bool[] memory availableOrders) {\n        // Retrieve the length of the advanced orders array and place on stack.\n        uint256 totalOrders = advancedOrders.length;\n\n        // Initialize array for tracking available orders.\n        availableOrders = new bool[](totalOrders);\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Iterate over orders to ensure all considerations are met.\n            for (uint256 i = 0; i < totalOrders; ++i) {\n                // Retrieve the order in question.\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\n\n                // Skip consideration item checks for order if not fulfilled.\n                if (advancedOrder.numerator == 0) {\n                    // Note: orders do not need to be marked as unavailable as a\n                    // new memory region has been allocated. Review carefully if\n                    // altering compiler version or managing memory manually.\n                    continue;\n                }\n\n                // Mark the order as available.\n                availableOrders[i] = true;\n\n                // Retrieve consideration items to ensure they are fulfilled.\n                ConsiderationItem[] memory consideration = (\n                    advancedOrder.parameters.consideration\n                );\n\n                // Iterate over each consideration item to ensure it is met.\n                for (uint256 j = 0; j < consideration.length; ++j) {\n                    // Retrieve remaining amount on the consideration item.\n                    uint256 unmetAmount = consideration[j].startAmount;\n\n                    // Revert if the remaining amount is not zero.\n                    if (unmetAmount != 0) {\n                        revert ConsiderationNotMet(i, j, unmetAmount);\n                    }\n                }\n            }\n        }\n\n        // Put ether value supplied by the caller on the stack.\n        uint256 etherRemaining = msg.value;\n\n        // Initialize an accumulator array. From this point forward, no new\n        // memory regions can be safely allocated until the accumulator is no\n        // longer being utilized, as the accumulator operates in an open-ended\n        // fashion from this memory pointer; existing memory may still be\n        // accessed and modified, however.\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\n\n        // Iterate over each execution.\n        for (uint256 i = 0; i < executions.length; ) {\n            // Retrieve the execution and the associated received item.\n            Execution memory execution = executions[i];\n            ReceivedItem memory item = execution.item;\n\n            // If execution transfers native tokens, reduce value available.\n            if (item.itemType == ItemType.NATIVE) {\n                // Ensure that sufficient native tokens are still available.\n                if (item.amount > etherRemaining) {\n                    revert InsufficientEtherSupplied();\n                }\n\n                // Skip underflow check as amount is less than ether remaining.\n                unchecked {\n                    etherRemaining -= item.amount;\n                }\n            }\n\n            // Transfer the item specified by the execution.\n            _transfer(\n                item,\n                execution.offerer,\n                execution.conduitKey,\n                accumulator\n            );\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Trigger any remaining accumulated transfers via call to the conduit.\n        _triggerIfArmed(accumulator);\n\n        // If any ether remains after fulfillments, return it to the caller.\n        if (etherRemaining != 0) {\n            _transferEth(payable(msg.sender), etherRemaining);\n        }\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n\n        // Return the array containing available orders.\n        return (availableOrders);\n    }\n\n    /**\n     * @dev Internal function to match an arbitrary number of full or partial\n     *      orders, each with an arbitrary number of items for offer and\n     *      consideration, supplying criteria resolvers containing specific\n     *      token identifiers and associated proofs as well as fulfillments\n     *      allocating offer components to consideration components.\n     *\n     * @param advancedOrders    The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or their conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order to receive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          an empty root indicates that any (transferrable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function _matchAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        Fulfillment[] calldata fulfillments\n    ) internal returns (Execution[] memory executions) {\n        // Validate orders, update order status, and determine item amounts.\n        _validateOrdersAndPrepareToFulfill(\n            advancedOrders,\n            criteriaResolvers,\n            true, // Signifies that invalid orders should revert.\n            advancedOrders.length\n        );\n\n        // Fulfill the orders using the supplied fulfillments.\n        return _fulfillAdvancedOrders(advancedOrders, fulfillments);\n    }\n\n    /**\n     * @dev Internal function to fulfill an arbitrary number of orders, either\n     *      full or partial, after validating, adjusting amounts, and applying\n     *      criteria resolvers.\n     *\n     * @param advancedOrders     The orders to match, including a fraction to\n     *                           attempt to fill for each order.\n     * @param fulfillments       An array of elements allocating offer\n     *                           components to consideration components. Note\n     *                           that the final amount of each consideration\n     *                           component must be zero for a match operation to\n     *                           be considered valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function _fulfillAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        Fulfillment[] calldata fulfillments\n    ) internal returns (Execution[] memory executions) {\n        // Retrieve fulfillments array length and place on the stack.\n        uint256 totalFulfillments = fulfillments.length;\n\n        // Allocate executions by fulfillment and apply them to each execution.\n        executions = new Execution[](totalFulfillments);\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Track number of filtered executions.\n            uint256 totalFilteredExecutions = 0;\n\n            // Iterate over each fulfillment.\n            for (uint256 i = 0; i < totalFulfillments; ++i) {\n                /// Retrieve the fulfillment in question.\n                Fulfillment calldata fulfillment = fulfillments[i];\n\n                // Derive the execution corresponding with the fulfillment.\n                Execution memory execution = _applyFulfillment(\n                    advancedOrders,\n                    fulfillment.offerComponents,\n                    fulfillment.considerationComponents\n                );\n\n                // If offerer and recipient on the execution are the same...\n                if (execution.item.recipient == execution.offerer) {\n                    // increment total filtered executions.\n                    totalFilteredExecutions += 1;\n                } else {\n                    // Otherwise, assign the execution to the executions array.\n                    executions[i - totalFilteredExecutions] = execution;\n                }\n            }\n\n            // If some number of executions have been filtered...\n            if (totalFilteredExecutions != 0) {\n                // reduce the total length of the executions array.\n                assembly {\n                    mstore(\n                        executions,\n                        sub(mload(executions), totalFilteredExecutions)\n                    )\n                }\n            }\n        }\n\n        // Perform final checks and execute orders.\n        _performFinalChecksAndExecuteOrders(advancedOrders, executions);\n\n        // Return the executions array.\n        return (executions);\n    }\n}\n\n\n",
        "CodeNames": [
            "OrderValidator.sol",
            "ConsiderationInterface.sol",
            "ConsiderationEventsAndErrors.sol",
            "Conduit.sol",
            "ConsiderationEnums.sol",
            "OrderCombiner.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "diff\nmodified   contracts/lib/OrderValidator.sol\n@@ -225,6 +225,8 @@ contract OrderValidator is Executor, ZoneInteraction {\n                 // Update order status and fill amount, packing struct values.\n                 _orderStatus[orderHash].isValidated = true;\n                 _orderStatus[orderHash].isCancelled = false;\n+                require(filledNumerator + numerator <= type(uint120).max, \"overflow\");\n+                require(denominator <= type(uint120).max, \"overflow\");\n                 _orderStatus[orderHash].numerator = uint120(\n                     filledNumerator + numerator\n                 );\n@@ -234,6 +236,8 @@ contract OrderValidator is Executor, ZoneInteraction {\n             // Update order status and fill amount, packing struct values.\n             _orderStatus[orderHash].isValidated = true;\n             _orderStatus[orderHash].isCancelled = false;\n+            require(numerator <= type(uint120).max, \"overflow\");\n+            require(denominator <= type(uint120).max, \"overflow\");\n             _orderStatus[orderHash].numerator = uint120(numerator);\n             _orderStatus[orderHash].denominator = uint120(denominator);\n         }\n"
                ],
                "Type": " Truncation in  OrderValidator  can lead to resetting the fill and selling more tokens",
                "Description": "*Submitted by Spearbit, also found by 0xsanson, broccoli, cmichel, hyh, ming, OriDabush, Saw-mon&#95;and&#95;Natalie, and Yarpo*\n\nOrderValidator.sol#L228(https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L228)<br\nOrderValidator.sol#L231(https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L231)<br\nOrderValidator.sol#L237(https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L237)<br\nOrderValidator.sol#L238(https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L238)<br\n\nA partial order's fractions (numerator and denominator) can be reset to 0 due to a truncation. This can be used to craft malicious orders:\n\n1.  Consider user Alice, who has 100 ERC1155 tokens, who approved all of their tokens to the marketplaceContract.\n2.  Alice places a PARTIAL_OPEN order with 10 ERC1155 tokens and consideration of ETH.\n3.  Malory tries to fill the order in the following way:\n    1.  Malory tries to fill 50% of the order, but instead of providing the fraction 1 / 2, Bob provides 2118 / 2119. This sets the totalFilled to 2118 and totalSize to 2119.\n    2.  Malory tries to fill 10% of the order, by providing 1 / 10. The computation 2118 / 2119 + 1 / 10 is done by \"cross multiplying\" the denominators, leading to the acutal fraction being numerator = (2118 * 10 + 2119) and denominator = 2119 * 10.\n    3.  Because of the uint120 truncation in OrderValidator.sol#L228-L248(https://github.com/ProjectOpenSea/seaport/blob/6c24d09fc4be9bbecf749e6a7a592c8f7b659405/contracts/lib/OrderValidator.sol#L228-L248), the numerator and denominator are truncated to 0 and 0 respectively.\n    4.  Bob can now continue filling the order and draining any approved (1000 tokens in total) of the above ERC1155 tokens, for the same consideration amount!\n\n\nView full POC(https://gist.github.com/hrkrshnn/7c51b23f7c43c55ba0f8157c3b298409).\n\nThe following change would make the above POC fail:\n\ndiff\nmodified   contracts/lib/OrderValidator.sol\n@@ -225,6 +225,8 @@ contract OrderValidator is Executor, ZoneInteraction {\n                 // Update order status and fill amount, packing struct values.\n                 _orderStatus[orderHash].isValidated = true;\n                 _orderStatus[orderHash].isCancelled = false;\n+                require(filledNumerator + numerator <= type(uint120).max, \"overflow\");\n+                require(denominator <= type(uint120).max, \"overflow\");\n                 _orderStatus[orderHash].numerator = uint120(\n                     filledNumerator + numerator\n                 );\n@@ -234,6 +236,8 @@ contract OrderValidator is Executor, ZoneInteraction {\n             // Update order status and fill amount, packing struct values.\n             _orderStatus[orderHash].isValidated = true;\n             _orderStatus[orderHash].isCancelled = false;\n+            require(numerator <= type(uint120).max, \"overflow\");\n+            require(denominator <= type(uint120).max, \"overflow\");\n             _orderStatus[orderHash].numerator = uint120(numerator);\n             _orderStatus[orderHash].denominator = uint120(denominator);\n         }\n\n\n",
                "Repair": "\nA basic fix for this would involve adding the above checks for overflow / truncation and reverting in that case. However, we think the mechanism is still flawed in some respects and requires more changes to fully fix it. See a related issue: \"A malicious filler can fill a partial order in such a way that the rest cannot be filled by anyone\"(https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/101) that points out a related but a more fundamental issue with the mechanism.\n\n0age (OpenSea) confirmed(https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/77)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/77#issuecomment-1162425341):\n  I've identified that this issue and all of its duplicates clearly outline how an attacker might overflow an order to continually fulfill an order at the same market price.\n \n An instance where this issue might cause issues is during a restricted token sale. A relevant scenario is detailed as follows:\n  A new token is created and the owner wishes to sell 50% of the token supply to the public.\n  Because of an edge case in OrderValidator, the order fulfillment can be reset to allow the public to more than 50% of the total token supply.\n  As a result, allocations intended to be distributed to investors and the team, will no longer be available.\n  It is important to note, that additional tokens will be sold at the intended market price listed by the original order.\n \n For these reasons, I believe this issue to be of high severity because it breaks certain trust assumptions made by the protocol and its userbase. By intentionally forcing a user to sell additional tokens, you are effectively altering the allocation of their wallet holdings, potentially leading to further funds loss as they may incur slippage when they have to sell these tokens back.\n \n A great finding from all involved!\n\n0age (OpenSea) resolved(https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/77):\n  PR: ProjectOpenSea/seaport#319(https://github.com/ProjectOpenSea/seaport/pull/319)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { ItemType, Side } from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    OfferItem,\n    ConsiderationItem,\n    ReceivedItem,\n    OrderParameters,\n    AdvancedOrder,\n    Execution,\n    FulfillmentComponent\n} from \"./ConsiderationStructs.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n// prettier-ignore\nimport {\n    FulfillmentApplicationErrors\n} from \"../interfaces/FulfillmentApplicationErrors.sol\";\n\n/**\n * @title FulfillmentApplier\n * @author 0age\n * @notice FulfillmentApplier contains logic related to applying fulfillments,\n *         both as part of order matching (where offer items are matched to\n *         consideration items) as well as fulfilling available orders (where\n *         order items and consideration items are independently aggregated).\n */\ncontract FulfillmentApplier is FulfillmentApplicationErrors {\n    /**\n     * @dev Internal view function to match offer items to consideration items\n     *      on a group of orders via a supplied fulfillment.\n     *\n     * @param advancedOrders          The orders to match.\n     * @param offerComponents         An array designating offer components to\n     *                                match to consideration components.\n     * @param considerationComponents An array designating consideration\n     *                                components to match to offer components.\n     *                                Note that each consideration amount must\n     *                                be zero in order for the match operation\n     *                                to be valid.\n     *\n     * @return execution The transfer performed as a result of the fulfillment.\n     */\n    function _applyFulfillment(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] calldata offerComponents,\n        FulfillmentComponent[] calldata considerationComponents\n    ) internal view returns (Execution memory execution) {\n        // Ensure 1+ of both offer and consideration components are supplied.\n        if (\n            offerComponents.length == 0 || considerationComponents.length == 0\n        ) {\n            revert OfferAndConsiderationRequiredOnFulfillment();\n        }\n\n        // Declare a new Execution struct.\n        Execution memory considerationExecution;\n\n        // Validate & aggregate consideration items to new Execution object.\n        _aggregateValidFulfillmentConsiderationItems(\n            advancedOrders,\n            considerationComponents,\n            considerationExecution\n        );\n\n        // Retrieve the consideration item from the execution struct.\n        ReceivedItem memory considerationItem = considerationExecution.item;\n\n        // Validate & aggregate offer items to Execution object.\n        _aggregateValidFulfillmentOfferItems(\n            advancedOrders,\n            offerComponents,\n            execution\n        );\n\n        // Ensure offer and consideration share types, tokens and identifiers.\n        if (\n            execution.item.itemType != considerationItem.itemType ||\n            execution.item.token != considerationItem.token ||\n            execution.item.identifier != considerationItem.identifier\n        ) {\n            revert MismatchedFulfillmentOfferAndConsiderationComponents();\n        }\n\n        // If total consideration amount exceeds the offer amount...\n        if (considerationItem.amount > execution.item.amount) {\n            // Retrieve the first consideration component from the fulfillment.\n            FulfillmentComponent memory targetComponent = (\n                considerationComponents[0]\n            );\n\n            // Add excess consideration item amount to original array of orders.\n            advancedOrders[targetComponent.orderIndex]\n                .parameters\n                .consideration[targetComponent.itemIndex]\n                .startAmount = considerationItem.amount - execution.item.amount;\n\n            // Reduce total consideration amount to equal the offer amount.\n            considerationItem.amount = execution.item.amount;\n        } else {\n            // Retrieve the first offer component from the fulfillment.\n            FulfillmentComponent memory targetComponent = (offerComponents[0]);\n\n            // Add excess offer item amount to the original array of orders.\n            advancedOrders[targetComponent.orderIndex]\n                .parameters\n                .offer[targetComponent.itemIndex]\n                .startAmount = execution.item.amount - considerationItem.amount;\n        }\n\n        // Reuse execution struct with consideration amount and recipient.\n        execution.item.amount = considerationItem.amount;\n        execution.item.recipient = considerationItem.recipient;\n\n        // Return the final execution that will be triggered for relevant items.\n        return execution; // Execution(considerationItem, offerer, conduitKey);\n    }\n\n    /**\n     * @dev Internal view function to aggregate offer or consideration items\n     *      from a group of orders into a single execution via a supplied array\n     *      of fulfillment components. Items that are not available to aggregate\n     *      will not be included in the aggregated execution.\n     *\n     * @param advancedOrders        The orders to aggregate.\n     * @param side                  The side (i.e. offer or consideration).\n     * @param fulfillmentComponents An array designating item components to\n     *                              aggregate if part of an available order.\n     * @param fulfillerConduitKey   A bytes32 value indicating what conduit, if\n     *                              any, to source the fulfiller's token\n     *                              approvals from. The zero hash signifies that\n     *                              no conduit should be used, with approvals\n     *                              set directly on this contract.\n     *\n     * @return execution The transfer performed as a result of the fulfillment.\n     */\n    function _aggregateAvailable(\n        AdvancedOrder[] memory advancedOrders,\n        Side side,\n        FulfillmentComponent[] memory fulfillmentComponents,\n        bytes32 fulfillerConduitKey\n    ) internal view returns (Execution memory execution) {\n        // Skip overflow / underflow checks; conditions checked or unreachable.\n        unchecked {\n            // Retrieve fulfillment components array length and place on stack.\n            // Ensure at least one fulfillment component has been supplied.\n            if (fulfillmentComponents.length == 0) {\n                revert MissingFulfillmentComponentOnAggregation(side);\n            }\n\n            // If the fulfillment components are offer components...\n            if (side == Side.OFFER) {\n                // Return execution for aggregated items provided by offerer.\n                _aggregateValidFulfillmentOfferItems(\n                    advancedOrders,\n                    fulfillmentComponents,\n                    execution\n                );\n            } else {\n                // Otherwise, fulfillment components are consideration\n                // components. Return execution for aggregated items provided by\n                // the fulfiller.\n                _aggregateValidFulfillmentConsiderationItems(\n                    advancedOrders,\n                    fulfillmentComponents,\n                    execution\n                );\n\n                // Set the caller as the offerer on the execution.\n                execution.offerer = msg.sender;\n\n                // Set fulfiller conduit key as the conduit key on execution.\n                execution.conduitKey = fulfillerConduitKey;\n            }\n\n            // Set the offerer as the receipient if execution amount is nonzero.\n            if (execution.item.amount == 0) {\n                execution.item.recipient = payable(execution.offerer);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to aggregate a group of offer items using\n     *      supplied directives on which component items are candidates for\n     *      aggregation, skipping items on orders that are not available.\n     *\n     * @param advancedOrders  The orders to aggregate offer items from.\n     * @param offerComponents An array of FulfillmentComponent structs\n     *                        indicating the order index and item index of each\n     *                        candidate offer item for aggregation.\n     * @param execution       The execution to apply the aggregation to.\n     */\n    function _aggregateValidFulfillmentOfferItems(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] memory offerComponents,\n        Execution memory execution\n    ) internal view {\n        assembly {\n            // Declare function for reverts on invalid fulfillment data.\n            function throwInvalidFulfillmentComponentData() {\n                // Store the InvalidFulfillmentComponentData error signature.\n                mstore(0, InvalidFulfillmentComponentData_error_signature)\n\n                // Return, supplying InvalidFulfillmentComponentData signature.\n                revert(0, InvalidFulfillmentComponentData_error_len)\n            }\n\n            // Declare function for reverts due to arithmetic overflows.\n            function throwOverflow() {\n                // Store the Panic error signature.\n                mstore(0, Panic_error_signature)\n\n                // Store the arithmetic (0x11) panic code as initial argument.\n                mstore(Panic_error_offset, Panic_arithmetic)\n\n                // Return, supplying Panic signature and arithmetic code.\n                revert(0, Panic_error_length)\n            }\n\n            // Get position in offerComponents head.\n            let fulfillmentHeadPtr := add(offerComponents, OneWord)\n\n            // Retrieve the order index using the fulfillment pointer.\n            let orderIndex := mload(mload(fulfillmentHeadPtr))\n\n            // Ensure that the order index is not out of range.\n            if iszero(lt(orderIndex, mload(advancedOrders))) {\n                throwInvalidFulfillmentComponentData()\n            }\n\n            // Read advancedOrders[orderIndex] pointer from its array head.\n            let orderPtr := mload(\n                // Calculate head position of advancedOrders[orderIndex].\n                add(add(advancedOrders, OneWord), mul(orderIndex, OneWord))\n            )\n\n            // Read the pointer to OrderParameters from the AdvancedOrder.\n            let paramsPtr := mload(orderPtr)\n\n            // Load the offer array pointer.\n            let offerArrPtr := mload(\n                add(paramsPtr, OrderParameters_offer_head_offset)\n            )\n\n            // Retrieve item index using an offset of the fulfillment pointer.\n            let itemIndex := mload(\n                add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\n            )\n\n            // Only continue if the fulfillment is not invalid.\n            if iszero(lt(itemIndex, mload(offerArrPtr))) {\n                throwInvalidFulfillmentComponentData()\n            }\n\n            // Retrieve consideration item pointer using the item index.\n            let offerItemPtr := mload(\n                add(\n                    // Get pointer to beginning of receivedItem.\n                    add(offerArrPtr, OneWord),\n                    // Calculate offset to pointer for desired order.\n                    mul(itemIndex, OneWord)\n                )\n            )\n\n            // Declare a variable for the final aggregated item amount.\n            let amount := 0\n\n            // Create variable to track errors encountered with amount.\n            let errorBuffer := 0\n\n            // Only add offer amount to execution amount on a nonzero numerator.\n            if mload(add(orderPtr, AdvancedOrder_numerator_offset)) {\n                // Retrieve amount pointer using consideration item pointer.\n                let amountPtr := add(offerItemPtr, Common_amount_offset)\n\n                // Set the amount.\n                amount := mload(amountPtr)\n\n                // Zero out amount on item to indicate it is credited.\n                mstore(amountPtr, 0)\n\n                // Buffer indicating whether issues were found.\n                errorBuffer := iszero(amount)\n            }\n\n            // Retrieve the received item pointer.\n            let receivedItemPtr := mload(execution)\n\n            // Set the caller as the recipient on the received item.\n            mstore(\n                add(receivedItemPtr, ReceivedItem_recipient_offset),\n                caller()\n            )\n\n            // Set the item type on the received item.\n            mstore(receivedItemPtr, mload(offerItemPtr))\n\n            // Set the token on the received item.\n            mstore(\n                add(receivedItemPtr, Common_token_offset),\n                mload(add(offerItemPtr, Common_token_offset))\n            )\n\n            // Set the identifier on the received item.\n            mstore(\n                add(receivedItemPtr, Common_identifier_offset),\n                mload(add(offerItemPtr, Common_identifier_offset))\n            )\n\n            // Set the offerer on returned execution using order pointer.\n            mstore(add(execution, Execution_offerer_offset), mload(paramsPtr))\n\n            // Set conduitKey on returned execution via offset of order pointer.\n            mstore(\n                add(execution, Execution_conduit_offset),\n                mload(add(paramsPtr, OrderParameters_conduit_offset))\n            )\n\n            // Calculate the hash of (itemType, token, identifier).\n            let dataHash := keccak256(\n                receivedItemPtr,\n                ReceivedItem_CommonParams_size\n            )\n\n            // Get position one word past last element in head of array.\n            let endPtr := add(\n                offerComponents,\n                mul(mload(offerComponents), OneWord)\n            )\n\n            // Iterate over remaining offer components.\n            // prettier-ignore\n            for {} lt(fulfillmentHeadPtr,  endPtr) {} {\n                // Increment the pointer to the fulfillment head by one word.\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\n\n                // Get the order index using the fulfillment pointer.\n                orderIndex := mload(mload(fulfillmentHeadPtr))\n\n                // Ensure the order index is in range.\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\n                  throwInvalidFulfillmentComponentData()\n                }\n\n                // Get pointer to AdvancedOrder element.\n                orderPtr := mload(\n                    add(\n                        add(advancedOrders, OneWord),\n                        mul(orderIndex, OneWord)\n                    )\n                )\n\n                // Only continue if numerator is not zero.\n                if iszero(mload(\n                    add(orderPtr, AdvancedOrder_numerator_offset)\n                )) {\n                  continue\n                }\n\n                // Read the pointer to OrderParameters from the AdvancedOrder.\n                paramsPtr := mload(orderPtr)\n\n                // Load offer array pointer.\n                offerArrPtr := mload(\n                    add(\n                        paramsPtr,\n                        OrderParameters_offer_head_offset\n                    )\n                )\n\n                // Get the item index using the fulfillment pointer.\n                itemIndex := mload(add(mload(fulfillmentHeadPtr), OneWord))\n\n                // Throw if itemIndex is out of the range of array.\n                if iszero(\n                    lt(itemIndex, mload(offerArrPtr))\n                ) {\n                    throwInvalidFulfillmentComponentData()\n                }\n\n                // Retrieve offer item pointer using index.\n                offerItemPtr := mload(\n                    add(\n                        // Get pointer to beginning of receivedItem.\n                        add(offerArrPtr, OneWord),\n                        // Use offset to pointer for desired order.\n                        mul(itemIndex, OneWord)\n                    )\n                )\n\n                // Retrieve amount pointer using offer item pointer.\n                let amountPtr := add(\n                      offerItemPtr,\n                      Common_amount_offset\n                )\n\n                // Add offer amount to execution amount.\n                let newAmount := add(amount, mload(amountPtr))\n\n                // Update error buffer (1 = zero amount, 2 = overflow).\n                errorBuffer := or(\n                  errorBuffer,\n                  or(\n                    shl(1, lt(newAmount, amount)),\n                    iszero(mload(amountPtr))\n                  )\n                )\n\n                // Update the amount to the new, summed amount.\n                amount := newAmount\n\n                // Zero out amount on original item to indicate it is credited.\n                mstore(amountPtr, 0)\n\n                // Ensure the indicated item matches original item.\n                if iszero(\n                    and(\n                        and(\n                          // The offerer must match on both items.\n                          eq(\n                              mload(paramsPtr),\n                              mload(\n                                  add(execution, Execution_offerer_offset)\n                              )\n                          ),\n                          // The conduit key must match on both items.\n                          eq(\n                              mload(\n                                  add(\n                                      paramsPtr,\n                                      OrderParameters_conduit_offset\n                                  )\n                              ),\n                              mload(\n                                  add(\n                                      execution,\n                                      Execution_conduit_offset\n                                  )\n                              )\n                          )\n                        ),\n                        // The itemType, token, and identifier must match.\n                        eq(\n                            dataHash,\n                            keccak256(\n                                offerItemPtr,\n                                ReceivedItem_CommonParams_size\n                            )\n                        )\n                    )\n                ) {\n                    // Throw if any of the requirements are not met.\n                    throwInvalidFulfillmentComponentData()\n                }\n            }\n            // Write final amount to execution.\n            mstore(add(mload(execution), Common_amount_offset), amount)\n\n            // Determine if an error code is contained in the error buffer.\n            switch errorBuffer\n            case 1 {\n                // Store the MissingItemAmount error signature.\n                mstore(0, MissingItemAmount_error_signature)\n\n                // Return, supplying MissingItemAmount signature.\n                revert(0, MissingItemAmount_error_len)\n            }\n            case 2 {\n                // If the sum overflowed, panic.\n                throwOverflow()\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to aggregate a group of consideration items\n     *      using supplied directives on which component items are candidates\n     *      for aggregation, skipping items on orders that are not available.\n     *\n     * @param advancedOrders          The orders to aggregate consideration\n     *                                items from.\n     * @param considerationComponents An array of FulfillmentComponent structs\n     *                                indicating the order index and item index\n     *                                of each candidate consideration item for\n     *                                aggregation.\n     * @param execution       The execution to apply the aggregation to.\n     */\n    function _aggregateValidFulfillmentConsiderationItems(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] memory considerationComponents,\n        Execution memory execution\n    ) internal pure {\n        // Utilize assembly in order to efficiently aggregate the items.\n        assembly {\n            // Declare function for reverts on invalid fulfillment data.\n            function throwInvalidFulfillmentComponentData() {\n                // Store the InvalidFulfillmentComponentData error signature.\n                mstore(0, InvalidFulfillmentComponentData_error_signature)\n\n                // Return, supplying InvalidFulfillmentComponentData signature.\n                revert(0, InvalidFulfillmentComponentData_error_len)\n            }\n\n            // Declare function for reverts due to arithmetic overflows.\n            function throwOverflow() {\n                // Store the Panic error signature.\n                mstore(0, Panic_error_signature)\n\n                // Store the arithmetic (0x11) panic code as initial argument.\n                mstore(Panic_error_offset, Panic_arithmetic)\n\n                // Return, supplying Panic signature and arithmetic code.\n                revert(0, Panic_error_length)\n            }\n\n            // Get position in considerationComponents head.\n            let fulfillmentHeadPtr := add(considerationComponents, OneWord)\n\n            // Retrieve the order index using the fulfillment pointer.\n            let orderIndex := mload(mload(fulfillmentHeadPtr))\n\n            // Ensure that the order index is not out of range.\n            if iszero(lt(orderIndex, mload(advancedOrders))) {\n                throwInvalidFulfillmentComponentData()\n            }\n\n            // Read advancedOrders[orderIndex] pointer from its array head.\n            let orderPtr := mload(\n                // Calculate head position of advancedOrders[orderIndex].\n                add(add(advancedOrders, OneWord), mul(orderIndex, OneWord))\n            )\n\n            // Load consideration array pointer.\n            let considerationArrPtr := mload(\n                add(\n                    // Read pointer to OrderParameters from the AdvancedOrder.\n                    mload(orderPtr),\n                    OrderParameters_consideration_head_offset\n                )\n            )\n\n            // Retrieve item index using an offset of the fulfillment pointer.\n            let itemIndex := mload(\n                add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\n            )\n\n            // Ensure that the order index is not out of range.\n            if iszero(lt(itemIndex, mload(considerationArrPtr))) {\n                throwInvalidFulfillmentComponentData()\n            }\n\n            // Retrieve consideration item pointer using the item index.\n            let considerationItemPtr := mload(\n                add(\n                    // Get pointer to beginning of receivedItem.\n                    add(considerationArrPtr, OneWord),\n                    // Calculate offset to pointer for desired order.\n                    mul(itemIndex, OneWord)\n                )\n            )\n\n            // Declare a variable for the final aggregated item amount.\n            let amount := 0\n\n            // Create variable to track errors encountered with amount.\n            let errorBuffer := 0\n\n            // Only add consideration amount to execution amount if numerator is\n            // greater than zero.\n            if mload(add(orderPtr, AdvancedOrder_numerator_offset)) {\n                // Retrieve amount pointer using consideration item pointer.\n                let amountPtr := add(considerationItemPtr, Common_amount_offset)\n\n                // Set the amount.\n                amount := mload(amountPtr)\n\n                // Set error bit if amount is zero.\n                errorBuffer := iszero(amount)\n\n                // Zero out amount on item to indicate it is credited.\n                mstore(amountPtr, 0)\n            }\n\n            // Retrieve ReceivedItem pointer from Execution.\n            let receivedItem := mload(execution)\n\n            // Set the item type on the received item.\n            mstore(receivedItem, mload(considerationItemPtr))\n\n            // Set the token on the received item.\n            mstore(\n                add(receivedItem, Common_token_offset),\n                mload(add(considerationItemPtr, Common_token_offset))\n            )\n\n            // Set the identifier on the received item.\n            mstore(\n                add(receivedItem, Common_identifier_offset),\n                mload(add(considerationItemPtr, Common_identifier_offset))\n            )\n\n            // Set the recipient on the received item.\n            mstore(\n                add(receivedItem, ReceivedItem_recipient_offset),\n                mload(\n                    add(\n                        considerationItemPtr,\n                        ConsiderationItem_recipient_offset\n                    )\n                )\n            )\n\n            // Calculate the hash of (itemType, token, identifier).\n            let dataHash := keccak256(\n                receivedItem,\n                ReceivedItem_CommonParams_size\n            )\n\n            // Get position one word past last element in head of array.\n            let endPtr := add(\n                considerationComponents,\n                mul(mload(considerationComponents), OneWord)\n            )\n\n            // Iterate over remaining offer components.\n            // prettier-ignore\n            for {} lt(fulfillmentHeadPtr,  endPtr) {} {\n                // Increment position in considerationComponents head.\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\n\n                // Get the order index using the fulfillment pointer.\n                orderIndex := mload(mload(fulfillmentHeadPtr))\n\n                // Ensure the order index is in range.\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\n                  throwInvalidFulfillmentComponentData()\n                }\n\n                // Get pointer to AdvancedOrder element.\n                orderPtr := mload(\n                    add(\n                        add(advancedOrders, OneWord),\n                        mul(orderIndex, OneWord)\n                    )\n                )\n\n                // Only continue if numerator is not zero.\n                if iszero(\n                    mload(add(orderPtr, AdvancedOrder_numerator_offset))\n                ) {\n                  continue\n                }\n\n                // Load consideration array pointer from OrderParameters.\n                considerationArrPtr := mload(\n                    add(\n                        // Get pointer to OrderParameters from AdvancedOrder.\n                        mload(orderPtr),\n                        OrderParameters_consideration_head_offset\n                    )\n                )\n\n                // Get the item index using the fulfillment pointer.\n                itemIndex := mload(add(mload(fulfillmentHeadPtr), OneWord))\n\n                // Check if itemIndex is within the range of array.\n                if iszero(lt(itemIndex, mload(considerationArrPtr))) {\n                    throwInvalidFulfillmentComponentData()\n                }\n\n                // Retrieve consideration item pointer using index.\n                considerationItemPtr := mload(\n                    add(\n                        // Get pointer to beginning of receivedItem.\n                        add(considerationArrPtr, OneWord),\n                        // Use offset to pointer for desired order.\n                        mul(itemIndex, OneWord)\n                    )\n                )\n\n                // Retrieve amount pointer using consideration item pointer.\n                let amountPtr := add(\n                      considerationItemPtr,\n                      Common_amount_offset\n                )\n\n                // Add offer amount to execution amount.\n                let newAmount := add(amount, mload(amountPtr))\n\n                // Update error buffer (1 = zero amount, 2 = overflow).\n                errorBuffer := or(\n                  errorBuffer,\n                  or(\n                    shl(1, lt(newAmount, amount)),\n                    iszero(mload(amountPtr))\n                  )\n                )\n\n                // Update the amount to the new, summed amount.\n                amount := newAmount\n\n                // Zero out amount on original item to indicate it is credited.\n                mstore(amountPtr, 0)\n\n                // Ensure the indicated item matches original item.\n                if iszero(\n                    and(\n                        // Item recipients must match.\n                        eq(\n                            mload(\n                                add(\n                                    considerationItemPtr,\n                                    ConsiderItem_recipient_offset\n                                )\n                            ),\n                            mload(\n                                add(\n                                    receivedItem,\n                                    ReceivedItem_recipient_offset\n                                )\n                            )\n                        ),\n                        // The itemType, token, identifier must match.\n                        eq(\n                          dataHash,\n                          keccak256(\n                            considerationItemPtr,\n                            ReceivedItem_CommonParams_size\n                          )\n                        )\n                    )\n                ) {\n                    // Throw if any of the requirements are not met.\n                    throwInvalidFulfillmentComponentData()\n                }\n            }\n            // Write final amount to execution.\n            mstore(add(receivedItem, Common_amount_offset), amount)\n\n            // Determine if an error code is contained in the error buffer.\n            switch errorBuffer\n            case 1 {\n                // Store the MissingItemAmount error signature.\n                mstore(0, MissingItemAmount_error_signature)\n\n                // Return, supplying MissingItemAmount signature.\n                revert(0, MissingItemAmount_error_len)\n            }\n            case 2 {\n                // If the sum overflowed, panic.\n                throwOverflow()\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\n// prettier-ignore\nimport {\n    ConsiderationInterface\n} from \"../interfaces/ConsiderationInterface.sol\";\n\n// prettier-ignore\nimport {\n    OrderComponents,\n    BasicOrderParameters,\n    OrderParameters,\n    Order,\n    AdvancedOrder,\n    OrderStatus,\n    CriteriaResolver,\n    Fulfillment,\n    FulfillmentComponent,\n    Execution\n} from \"./ConsiderationStructs.sol\";\n\nimport { OrderCombiner } from \"./OrderCombiner.sol\";\n\n/**\n * @title Consideration\n * @author 0age\n * @custom:coauthor d1ll0n\n * @custom:coauthor transmissions11\n * @custom:version 1\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.\n *         It minimizes external calls to the greatest extent possible and\n *         provides lightweight methods for common routes as well as more\n *         flexible methods for composing advanced orders or groups of orders.\n *         Each order contains an arbitrary number of items that may be spent\n *         (the \"offer\") along with an arbitrary number of items that must be\n *         received back by the indicated recipients (the \"consideration\").\n */\ncontract Consideration is ConsiderationInterface, OrderCombiner {\n    /**\n     * @notice Derive and set hashes, reference chainId, and associated domain\n     *         separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderCombiner(conduitController) {}\n\n    /**\n     * @notice Fulfill an order offering an ERC20, ERC721, or ERC1155 item by\n     *         supplying Ether (or other native tokens), ERC20 tokens, an ERC721\n     *         item, or an ERC1155 item as consideration. Six permutations are\n     *         supported: Native token to ERC721, Native token to ERC1155, ERC20\n     *         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to\n     *         ERC20 (with native tokens supplied as msg.value). For an order to\n     *         be eligible for fulfillment via this method, it must contain a\n     *         single offer item (though that item may have a greater amount if\n     *         the item is not an ERC721). An arbitrary number of \"additional\n     *         recipients\" may also be supplied which will each receive native\n     *         tokens or ERC20 items from the fulfiller as consideration. Refer\n     *         to the documentation for a more comprehensive summary of how to\n     *         utilize this method and what orders are compatible with it.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer and the fulfiller must first approve\n     *                   this contract (or their chosen conduit if indicated)\n     *                   before any tokens can be transferred. Also note that\n     *                   contract recipients of ERC1155 consideration items must\n     *                   implement `onERC1155Received` in order to receive those\n     *                   items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder(BasicOrderParameters calldata parameters)\n        external\n        payable\n        override\n        returns (bool fulfilled)\n    {\n        // Validate and fulfill the basic order.\n        fulfilled = _validateAndFulfillBasicOrder(parameters);\n    }\n\n    /**\n     * @notice Fulfill an order with an arbitrary number of items for offer and\n     *         consideration. Note that this function does not support\n     *         criteria-based orders or partial filling of orders (though\n     *         filling the remainder of a partially-filled order is supported).\n     *\n     * @param order               The order to fulfill. Note that both the\n     *                            offerer and the fulfiller must first approve\n     *                            this contract (or the corresponding conduit if\n     *                            indicated) to transfer any relevant tokens on\n     *                            their behalf and that contracts must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens\n     *                            as consideration.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used (and direct approvals set on\n     *                            Consideration).\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillOrder(Order calldata order, bytes32 fulfillerConduitKey)\n        external\n        payable\n        override\n        returns (bool fulfilled)\n    {\n        // Convert order to \"advanced\" order, then validate and fulfill it.\n        fulfilled = _validateAndFulfillAdvancedOrder(\n            _convertOrderToAdvanced(order),\n            new CriteriaResolver[](0), // No criteria resolvers supplied.\n            fulfillerConduitKey\n        );\n    }\n\n    /**\n     * @notice Fill an order, fully or partially, with an arbitrary number of\n     *         items for offer and consideration alongside criteria resolvers\n     *         containing specific token identifiers and associated proofs.\n     *\n     * @param advancedOrder       The order to fulfill along with the fraction\n     *                            of the order to attempt to fill. Note that\n     *                            both the offerer and the fulfiller must first\n     *                            approve this contract (or their conduit if\n     *                            indicated by the order) to transfer any\n     *                            relevant tokens on their behalf and that\n     *                            contracts must implement `onERC1155Received`\n     *                            to receive ERC1155 tokens as consideration.\n     *                            Also note that all offer and consideration\n     *                            components must have no remainder after\n     *                            multiplication of the respective amount with\n     *                            the supplied fraction for the partial fill to\n     *                            be considered valid.\n     * @param criteriaResolvers   An array where each element contains a\n     *                            reference to a specific offer or\n     *                            consideration, a token identifier, and a proof\n     *                            that the supplied token identifier is\n     *                            contained in the merkle root held by the item\n     *                            in question's criteria element. Note that an\n     *                            empty criteria indicates that any\n     *                            (transferrable) token identifier on the token\n     *                            in question is valid and that no associated\n     *                            proof needs to be supplied.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used (and direct approvals set on\n     *                            Consideration).\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillAdvancedOrder(\n        AdvancedOrder calldata advancedOrder,\n        CriteriaResolver[] calldata criteriaResolvers,\n        bytes32 fulfillerConduitKey\n    ) external payable override returns (bool fulfilled) {\n        // Validate and fulfill the order.\n        fulfilled = _validateAndFulfillAdvancedOrder(\n            advancedOrder,\n            criteriaResolvers,\n            fulfillerConduitKey\n        );\n    }\n\n    /**\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\n     *         of items for offer and consideration. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *         Note that this function does not support criteria-based orders or\n     *         partial filling of orders (though filling the remainder of a\n     *         partially-filled order is supported).\n     *\n     * @param orders                    The orders to fulfill. Note that both\n     *                                  the offerer and the fulfiller must first\n     *                                  approve this contract (or the\n     *                                  corresponding conduit if indicated) to\n     *                                  transfer any relevant tokens on their\n     *                                  behalf and that contracts must implement\n     *                                  `onERC1155Received` to receive ERC1155\n     *                                  tokens as consideration.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used (and\n     *                                  direct approvals set on Consideration).\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableOrders(\n        Order[] calldata orders,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        override\n        returns (bool[] memory availableOrders, Execution[] memory executions)\n    {\n        // Convert orders to \"advanced\" orders and fulfill all available orders.\n        return\n            _fulfillAvailableAdvancedOrders(\n                _convertOrdersToAdvanced(orders), // Convert to advanced orders.\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\n                offerFulfillments,\n                considerationFulfillments,\n                fulfillerConduitKey,\n                maximumFulfilled\n            );\n    }\n\n    /**\n     * @notice Attempt to fill a group of orders, fully or partially, with an\n     *         arbitrary number of items for offer and consideration per order\n     *         alongside criteria resolvers containing specific token\n     *         identifiers and associated proofs. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or their conduit if indicated\n     *                                  by the order) to transfer any relevant\n     *                                  tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` in order to receive\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferrable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used (and\n     *                                  direct approvals set on Consideration).\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        override\n        returns (bool[] memory availableOrders, Execution[] memory executions)\n    {\n        // Fulfill all available orders.\n        return\n            _fulfillAvailableAdvancedOrders(\n                advancedOrders,\n                criteriaResolvers,\n                offerFulfillments,\n                considerationFulfillments,\n                fulfillerConduitKey,\n                maximumFulfilled\n            );\n    }\n\n    /**\n     * @notice Match an arbitrary number of orders, each with an arbitrary\n     *         number of items for offer and consideration along with a set of\n     *         fulfillments allocating offer components to consideration\n     *         components. Note that this function does not support\n     *         criteria-based or partial filling of orders (though filling the\n     *         remainder of a partially-filled order is supported).\n     *\n     * @param orders            The orders to match. Note that both the offerer\n     *                          and fulfiller on each order must first approve\n     *                          this contract (or their conduit if indicated by\n     *                          the order) to transfer any relevant tokens on\n     *                          their behalf and each consideration recipient\n     *                          must implement `onERC1155Received` in order to\n     *                          receive ERC1155 tokens.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function matchOrders(\n        Order[] calldata orders,\n        Fulfillment[] calldata fulfillments\n    ) external payable override returns (Execution[] memory executions) {\n        // Convert to advanced, validate, and match orders using fulfillments.\n        return\n            _matchAdvancedOrders(\n                _convertOrdersToAdvanced(orders),\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\n                fulfillments\n            );\n    }\n\n    /**\n     * @notice Match an arbitrary number of full or partial orders, each with an\n     *         arbitrary number of items for offer and consideration, supplying\n     *         criteria resolvers containing specific token identifiers and\n     *         associated proofs as well as fulfillments allocating offer\n     *         components to consideration components.\n     *\n     * @param advancedOrders    The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or their conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order to receive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          an empty root indicates that any (transferrable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function matchAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        Fulfillment[] calldata fulfillments\n    ) external payable override returns (Execution[] memory executions) {\n        // Validate and match the advanced orders using supplied fulfillments.\n        return\n            _matchAdvancedOrders(\n                advancedOrders,\n                criteriaResolvers,\n                fulfillments\n            );\n    }\n\n    /**\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\n     *         or the zone of a given order may cancel it. Callers should ensure\n     *         that the intended order was cancelled by calling `getOrderStatus`\n     *         and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders have\n     *                   been successfully cancelled.\n     */\n    function cancel(OrderComponents[] calldata orders)\n        external\n        override\n        returns (bool cancelled)\n    {\n        // Cancel the orders.\n        cancelled = _cancel(orders);\n    }\n\n    /**\n     * @notice Validate an arbitrary number of orders, thereby registering their\n     *         signatures as valid and allowing the fulfiller to skip signature\n     *         verification on fulfillment. Note that validated orders may still\n     *         be unfulfillable due to invalid item amounts or other factors;\n     *         callers should determine whether validated orders are fulfillable\n     *         by simulating the fulfillment call prior to execution. Also note\n     *         that anyone can validate a signed order, but only the offerer can\n     *         validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders have\n     *                   been successfully validated.\n     */\n    function validate(Order[] calldata orders)\n        external\n        override\n        returns (bool validated)\n    {\n        // Validate the orders.\n        validated = _validate(orders);\n    }\n\n    /**\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\n     *         by incrementing a nonce. Note that only the offerer may increment\n     *         the nonce.\n     *\n     * @return newNonce The new nonce.\n     */\n    function incrementNonce() external override returns (uint256 newNonce) {\n        // Increment current nonce for the supplied offerer.\n        newNonce = _incrementNonce();\n    }\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(OrderComponents calldata order)\n        external\n        view\n        override\n        returns (bytes32 orderHash)\n    {\n        // Derive order hash by supplying order parameters along with the nonce.\n        orderHash = _deriveOrderHash(\n            OrderParameters(\n                order.offerer,\n                order.zone,\n                order.offer,\n                order.consideration,\n                order.orderType,\n                order.startTime,\n                order.endTime,\n                order.zoneHash,\n                order.salt,\n                order.conduitKey,\n                order.consideration.length\n            ),\n            order.nonce\n        );\n    }\n\n    /**\n     * @notice Retrieve the status of a given order by hash, including whether\n     *         the order has been cancelled or validated and the fraction of the\n     *         order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function getOrderStatus(bytes32 orderHash)\n        external\n        view\n        override\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        )\n    {\n        // Retrieve the order status using the order hash.\n        return _getOrderStatus(orderHash);\n    }\n\n    /**\n     * @notice Retrieve the current nonce for a given offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return nonce The current nonce.\n     */\n    function getNonce(address offerer)\n        external\n        view\n        override\n        returns (uint256 nonce)\n    {\n        // Return the nonce for the supplied offerer.\n        nonce = _getNonce(offerer);\n    }\n\n    /**\n     * @notice Retrieve configuration information for this contract.\n     *\n     * @return version           The contract version.\n     * @return domainSeparator   The domain separator for this contract.\n     * @return conduitController The conduit Controller set for this contract.\n     */\n    function information()\n        external\n        view\n        override\n        returns (\n            string memory version,\n            bytes32 domainSeparator,\n            address conduitController\n        )\n    {\n        // Return the information for this contract.\n        return _information();\n    }\n\n    /**\n     * @notice Retrieve the name of this contract.\n     *\n     * @return contractName The name of this contract.\n     */\n    function name()\n        external\n        pure\n        override\n        returns (string memory contractName)\n    {\n        // Return the name of the contract.\n        contractName = _name();\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\n// prettier-ignore\nimport {\n    BasicOrderParameters,\n    OrderComponents,\n    Fulfillment,\n    FulfillmentComponent,\n    Execution,\n    Order,\n    AdvancedOrder,\n    OrderStatus,\n    CriteriaResolver\n} from \"../lib/ConsiderationStructs.sol\";\n\n/**\n * @title ConsiderationInterface\n * @author 0age\n * @custom:version 1\n * @notice Consideration is a generalized ETH/ERC20/ERC721/ERC1155 marketplace.\n *         It minimizes external calls to the greatest extent possible and\n *         provides lightweight methods for common routes as well as more\n *         flexible methods for composing advanced orders.\n *\n * @dev ConsiderationInterface contains all external function interfaces for\n *      Consideration.\n */\ninterface ConsiderationInterface {\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of \"additional recipients\" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder(BasicOrderParameters calldata parameters)\n        external\n        payable\n        returns (bool fulfilled);\n\n    /**\n     * @notice Fulfill an order with an arbitrary number of items for offer and\n     *         consideration. Note that this function does not support\n     *         criteria-based orders or partial filling of orders (though\n     *         filling the remainder of a partially-filled order is supported).\n     *\n     * @param order               The order to fulfill. Note that both the\n     *                            offerer and the fulfiller must first approve\n     *                            this contract (or the corresponding conduit if\n     *                            indicated) to transfer any relevant tokens on\n     *                            their behalf and that contracts must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens\n     *                            as consideration.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillOrder(Order calldata order, bytes32 fulfillerConduitKey)\n        external\n        payable\n        returns (bool fulfilled);\n\n    /**\n     * @notice Fill an order, fully or partially, with an arbitrary number of\n     *         items for offer and consideration alongside criteria resolvers\n     *         containing specific token identifiers and associated proofs.\n     *\n     * @param advancedOrder       The order to fulfill along with the fraction\n     *                            of the order to attempt to fill. Note that\n     *                            both the offerer and the fulfiller must first\n     *                            approve this contract (or their preferred\n     *                            conduit if indicated by the order) to transfer\n     *                            any relevant tokens on their behalf and that\n     *                            contracts must implement `onERC1155Received`\n     *                            to receive ERC1155 tokens as consideration.\n     *                            Also note that all offer and consideration\n     *                            components must have no remainder after\n     *                            multiplication of the respective amount with\n     *                            the supplied fraction for the partial fill to\n     *                            be considered valid.\n     * @param criteriaResolvers   An array where each element contains a\n     *                            reference to a specific offer or\n     *                            consideration, a token identifier, and a proof\n     *                            that the supplied token identifier is\n     *                            contained in the merkle root held by the item\n     *                            in question's criteria element. Note that an\n     *                            empty criteria indicates that any\n     *                            (transferrable) token identifier on the token\n     *                            in question is valid and that no associated\n     *                            proof needs to be supplied.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillAdvancedOrder(\n        AdvancedOrder calldata advancedOrder,\n        CriteriaResolver[] calldata criteriaResolvers,\n        bytes32 fulfillerConduitKey\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\n     *         of items for offer and consideration. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *         Note that this function does not support criteria-based orders or\n     *         partial filling of orders (though filling the remainder of a\n     *         partially-filled order is supported).\n     *\n     * @param orders                    The orders to fulfill. Note that both\n     *                                  the offerer and the fulfiller must first\n     *                                  approve this contract (or the\n     *                                  corresponding conduit if indicated) to\n     *                                  transfer any relevant tokens on their\n     *                                  behalf and that contracts must implement\n     *                                  `onERC1155Received` to receive ERC1155\n     *                                  tokens as consideration.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableOrders(\n        Order[] calldata orders,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Attempt to fill a group of orders, fully or partially, with an\n     *         arbitrary number of items for offer and consideration per order\n     *         alongside criteria resolvers containing specific token\n     *         identifiers and associated proofs. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or their preferred conduit if\n     *                                  indicated by the order) to transfer any\n     *                                  relevant tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` to enable receipt of\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferrable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] calldata advancedOrders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of orders, each with an arbitrary\n     *         number of items for offer and consideration along with as set of\n     *         fulfillments allocating offer components to consideration\n     *         components. Note that this function does not support\n     *         criteria-based or partial filling of orders (though filling the\n     *         remainder of a partially-filled order is supported).\n     *\n     * @param orders       The orders to match. Note that both the offerer and\n     *                     fulfiller on each order must first approve this\n     *                     contract (or their conduit if indicated by the order)\n     *                     to transfer any relevant tokens on their behalf and\n     *                     each consideration recipient must implement\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\n     * @param fulfillments An array of elements allocating offer components to\n     *                     consideration components. Note that each\n     *                     consideration component must be fully met for the\n     *                     match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function matchOrders(\n        Order[] calldata orders,\n        Fulfillment[] calldata fulfillments\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of full or partial orders, each with an\n     *         arbitrary number of items for offer and consideration, supplying\n     *         criteria resolvers containing specific token identifiers and\n     *         associated proofs as well as fulfillments allocating offer\n     *         components to consideration components.\n     *\n     * @param orders            The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or a preferred conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order toreceive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          an empty root indicates that any (transferrable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function matchAdvancedOrders(\n        AdvancedOrder[] calldata orders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        Fulfillment[] calldata fulfillments\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\n     *         or the zone of a given order may cancel it. Callers should ensure\n     *         that the intended order was cancelled by calling `getOrderStatus`\n     *         and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders have\n     *                   been successfully cancelled.\n     */\n    function cancel(OrderComponents[] calldata orders)\n        external\n        returns (bool cancelled);\n\n    /**\n     * @notice Validate an arbitrary number of orders, thereby registering their\n     *         signatures as valid and allowing the fulfiller to skip signature\n     *         verification on fulfillment. Note that validated orders may still\n     *         be unfulfillable due to invalid item amounts or other factors;\n     *         callers should determine whether validated orders are fulfillable\n     *         by simulating the fulfillment call prior to execution. Also note\n     *         that anyone can validate a signed order, but only the offerer can\n     *         validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders have\n     *                   been successfully validated.\n     */\n    function validate(Order[] calldata orders)\n        external\n        returns (bool validated);\n\n    /**\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\n     *         by incrementing a nonce. Note that only the offerer may increment\n     *         the nonce.\n     *\n     * @return newNonce The new nonce.\n     */\n    function incrementNonce() external returns (uint256 newNonce);\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(OrderComponents calldata order)\n        external\n        view\n        returns (bytes32 orderHash);\n\n    /**\n     * @notice Retrieve the status of a given order by hash, including whether\n     *         the order has been cancelled or validated and the fraction of the\n     *         order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function getOrderStatus(bytes32 orderHash)\n        external\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        );\n\n    /**\n     * @notice Retrieve the current nonce for a given offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return nonce The current nonce.\n     */\n    function getNonce(address offerer) external view returns (uint256 nonce);\n\n    /**\n     * @notice Retrieve configuration information for this contract.\n     *\n     * @return version           The contract version.\n     * @return domainSeparator   The domain separator for this contract.\n     * @return conduitController The conduit Controller set for this contract.\n     */\n    function information()\n        external\n        view\n        returns (\n            string memory version,\n            bytes32 domainSeparator,\n            address conduitController\n        );\n\n    /**\n     * @notice Retrieve the name of this contract.\n     *\n     * @return contractName The name of this contract.\n     */\n    function name() external view returns (string memory contractName);\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport { Side, ItemType } from \"./ConsiderationEnums.sol\";\n\n// prettier-ignore\nimport {\n    AdditionalRecipient,\n    OfferItem,\n    ConsiderationItem,\n    SpentItem,\n    ReceivedItem,\n    OrderParameters,\n    Fulfillment,\n    FulfillmentComponent,\n    Execution,\n    Order,\n    AdvancedOrder,\n    CriteriaResolver\n} from \"./ConsiderationStructs.sol\";\n\nimport { OrderFulfiller } from \"./OrderFulfiller.sol\";\n\nimport { FulfillmentApplier } from \"./FulfillmentApplier.sol\";\n\nimport \"./ConsiderationConstants.sol\";\n\n/**\n * @title OrderCombiner\n * @author 0age\n * @notice OrderCombiner contains logic for fulfilling combinations of orders,\n *         either by matching offer items to consideration items or by\n *         fulfilling orders where available.\n */\ncontract OrderCombiner is OrderFulfiller, FulfillmentApplier {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderFulfiller(conduitController) {}\n\n    /**\n     * @notice Internal function to attempt to fill a group of orders, fully or\n     *         partially, with an arbitrary number of items for offer and\n     *         consideration per order alongside criteria resolvers containing\n     *         specific token identifiers and associated proofs. Any order that\n     *         is not currently active, has already been fully filled, or has\n     *         been cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or a conduit if indicated by\n     *                                  the order) to transfer any relevant\n     *                                  tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` in order to receive\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferrable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used (and\n     *                                  direct approvals set on Consideration).\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function _fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        internal\n        returns (bool[] memory availableOrders, Execution[] memory executions)\n    {\n        // Validate orders, apply amounts, & determine if they utilize conduits.\n        _validateOrdersAndPrepareToFulfill(\n            advancedOrders,\n            criteriaResolvers,\n            false, // Signifies that invalid orders should NOT revert.\n            maximumFulfilled\n        );\n\n        // Aggregate used offer and consideration items and execute transfers.\n        (availableOrders, executions) = _executeAvailableFulfillments(\n            advancedOrders,\n            offerFulfillments,\n            considerationFulfillments,\n            fulfillerConduitKey\n        );\n\n        // Return order fulfillment details and executions.\n        return (availableOrders, executions);\n    }\n\n    /**\n     * @dev Internal function to validate a group of orders, update their\n     *      statuses, reduce amounts by their previously filled fractions, apply\n     *      criteria resolvers, and emit OrderFulfilled events.\n     *\n     * @param advancedOrders    The advanced orders to validate and reduce by\n     *                          their previously filled amounts.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          a root of zero indicates that any transferrable\n     *                          token identifier is valid and that no proof\n     *                          needs to be supplied.\n     * @param revertOnInvalid   A boolean indicating whether to revert on any\n     *                          order being invalid; setting this to false will\n     *                          instead cause the invalid order to be skipped.\n     * @param maximumFulfilled  The maximum number of orders to fulfill.\n     */\n    function _validateOrdersAndPrepareToFulfill(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        bool revertOnInvalid,\n        uint256 maximumFulfilled\n    ) internal {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard();\n\n        // Read length of orders array and place on the stack.\n        uint256 totalOrders = advancedOrders.length;\n\n        // Track the order hash for each order being fulfilled.\n        bytes32[] memory orderHashes = new bytes32[](totalOrders);\n\n        // Override orderHashes length to zero after memory has been allocated.\n        assembly {\n            mstore(orderHashes, 0)\n        }\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ++i) {\n                // Retrieve the current order.\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\n\n                // Determine if max number orders have already been fulfilled.\n                if (maximumFulfilled == 0) {\n                    // Mark fill fraction as zero as the order will not be used.\n                    advancedOrder.numerator = 0;\n\n                    // Update the length of the orderHashes array.\n                    assembly {\n                        mstore(orderHashes, add(i, 1))\n                    }\n\n                    // Continue iterating through the remaining orders.\n                    continue;\n                }\n\n                // Validate it, update status, and determine fraction to fill.\n                (\n                    bytes32 orderHash,\n                    uint256 numerator,\n                    uint256 denominator\n                ) = _validateOrderAndUpdateStatus(\n                        advancedOrder,\n                        criteriaResolvers,\n                        revertOnInvalid,\n                        orderHashes\n                    );\n\n                // Update the length of the orderHashes array.\n                assembly {\n                    mstore(orderHashes, add(i, 1))\n                }\n\n                // Do not track hash or adjust prices if order is not fulfilled.\n                if (numerator == 0) {\n                    // Mark fill fraction as zero if the order is not fulfilled.\n                    advancedOrder.numerator = 0;\n\n                    // Continue iterating through the remaining orders.\n                    continue;\n                }\n\n                // Otherwise, track the order hash in question.\n                orderHashes[i] = orderHash;\n\n                // Decrement the number of fulfilled orders.\n                maximumFulfilled--;\n\n                // Place the start time for the order on the stack.\n                uint256 startTime = advancedOrder.parameters.startTime;\n\n                // Derive the duration for the order and place it on the stack.\n                uint256 duration = advancedOrder.parameters.endTime - startTime;\n\n                // Derive time elapsed since the order started & place on stack.\n                uint256 elapsed = block.timestamp - startTime;\n\n                // Derive time remaining until order expires and place on stack.\n                uint256 remaining = duration - elapsed;\n\n                // Retrieve array of offer items for the order in question.\n                OfferItem[] memory offer = advancedOrder.parameters.offer;\n\n                // Iterate over each offer item on the order.\n                for (uint256 j = 0; j < offer.length; ++j) {\n                    // Retrieve the offer item.\n                    OfferItem memory offerItem = offer[j];\n\n                    // Apply order fill fraction to offer item end amount.\n                    uint256 endAmount = _getFraction(\n                        numerator,\n                        denominator,\n                        offerItem.endAmount\n                    );\n\n                    // Reuse same fraction if start and end amounts are equal.\n                    if (offerItem.startAmount == offerItem.endAmount) {\n                        // Apply derived amount to both start and end amount.\n                        offerItem.startAmount = endAmount;\n                    } else {\n                        // Apply order fill fraction to offer item start amount.\n                        offerItem.startAmount = _getFraction(\n                            numerator,\n                            denominator,\n                            offerItem.startAmount\n                        );\n                    }\n\n                    // Update end amount in memory to match the derived amount.\n                    offerItem.endAmount = endAmount;\n\n                    // Adjust offer amount using current time; round down.\n                    offerItem.startAmount = _locateCurrentAmount(\n                        offerItem.startAmount,\n                        offerItem.endAmount,\n                        elapsed,\n                        remaining,\n                        duration,\n                        false // round down\n                    );\n                }\n\n                // Retrieve array of consideration items for order in question.\n                ConsiderationItem[] memory consideration = (\n                    advancedOrder.parameters.consideration\n                );\n\n                // Iterate over each consideration item on the order.\n                for (uint256 j = 0; j < consideration.length; ++j) {\n                    // Retrieve the consideration item.\n                    ConsiderationItem memory considerationItem = (\n                        consideration[j]\n                    );\n\n                    // Apply fraction to consideration item end amount.\n                    uint256 endAmount = _getFraction(\n                        numerator,\n                        denominator,\n                        considerationItem.endAmount\n                    );\n\n                    // Reuse same fraction if start and end amounts are equal.\n                    if (\n                        considerationItem.startAmount ==\n                        considerationItem.endAmount\n                    ) {\n                        // Apply derived amount to both start and end amount.\n                        considerationItem.startAmount = endAmount;\n                    } else {\n                        // Apply fraction to consideration item start amount.\n                        considerationItem.startAmount = _getFraction(\n                            numerator,\n                            denominator,\n                            considerationItem.startAmount\n                        );\n                    }\n\n                    // Update end amount in memory to match the derived amount.\n                    considerationItem.endAmount = endAmount;\n\n                    // Adjust consideration amount using current time; round up.\n                    considerationItem.startAmount = (\n                        _locateCurrentAmount(\n                            considerationItem.startAmount,\n                            considerationItem.endAmount,\n                            elapsed,\n                            remaining,\n                            duration,\n                            true // round up\n                        )\n                    );\n\n                    // Utilize assembly to manually \"shift\" the recipient value.\n                    assembly {\n                        // Write recipient to endAmount, as endAmount is not\n                        // used from this point on and can be repurposed to fit\n                        // the layout of a ReceivedItem.\n                        mstore(\n                            add(\n                                considerationItem,\n                                ReceivedItem_recipient_offset // old endAmount\n                            ),\n                            mload(\n                                add(\n                                    considerationItem,\n                                    ConsiderationItem_recipient_offset\n                                )\n                            )\n                        )\n                    }\n                }\n            }\n        }\n\n        // Apply criteria resolvers to each order as applicable.\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\n\n        // Determine the fulfiller (revertOnInvalid ? address(0) : msg.sender).\n        address fulfiller;\n\n        // Utilize assembly to operate on revertOnInvalid boolean as an integer.\n        assembly {\n            // Set the fulfiller to the caller if revertOnValid is false.\n            fulfiller := mul(iszero(revertOnInvalid), caller())\n        }\n\n        // Emit an event for each order signifying that it has been fulfilled.\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ++i) {\n                // Do not emit an event if no order hash is present.\n                if (orderHashes[i] == bytes32(0)) {\n                    continue;\n                }\n\n                // Retrieve parameters for the order in question.\n                OrderParameters memory orderParameters = (\n                    advancedOrders[i].parameters\n                );\n\n                // Emit an OrderFulfilled event.\n                _emitOrderFulfilledEvent(\n                    orderHashes[i],\n                    orderParameters.offerer,\n                    orderParameters.zone,\n                    fulfiller,\n                    orderParameters.offer,\n                    orderParameters.consideration\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to fulfill a group of validated orders, fully or\n     *      partially, with an arbitrary number of items for offer and\n     *      consideration per order and to execute transfers. Any order that is\n     *      not currently active, has already been fully filled, or has been\n     *      cancelled will be omitted. Remaining offer and consideration items\n     *      will then be aggregated where possible as indicated by the supplied\n     *      offer and consideration component arrays and aggregated items will\n     *      be transferred to the fulfiller or to each intended recipient,\n     *      respectively. Note that a failing item transfer or an issue with\n     *      order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or the conduit if indicated by\n     *                                  the order) to transfer any relevant\n     *                                  tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` in order to receive\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on Consideration.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function _executeAvailableFulfillments(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[][] memory offerFulfillments,\n        FulfillmentComponent[][] memory considerationFulfillments,\n        bytes32 fulfillerConduitKey\n    )\n        internal\n        returns (bool[] memory availableOrders, Execution[] memory executions)\n    {\n        // Retrieve length of offer fulfillments array and place on the stack.\n        uint256 totalOfferFulfillments = offerFulfillments.length;\n\n        // Retrieve length of consideration fulfillments array & place on stack.\n        uint256 totalConsiderationFulfillments = (\n            considerationFulfillments.length\n        );\n\n        // Allocate an execution for each offer and consideration fulfillment.\n        executions = new Execution[](\n            totalOfferFulfillments + totalConsiderationFulfillments\n        );\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Track number of filtered executions.\n            uint256 totalFilteredExecutions = 0;\n\n            // Iterate over each offer fulfillment.\n            for (uint256 i = 0; i < totalOfferFulfillments; ++i) {\n                /// Retrieve the offer fulfillment components in question.\n                FulfillmentComponent[] memory components = (\n                    offerFulfillments[i]\n                );\n\n                // Derive aggregated execution corresponding with fulfillment.\n                Execution memory execution = _aggregateAvailable(\n                    advancedOrders,\n                    Side.OFFER,\n                    components,\n                    fulfillerConduitKey\n                );\n\n                // If offerer and recipient on the execution are the same...\n                if (execution.item.recipient == execution.offerer) {\n                    // increment total filtered executions.\n                    totalFilteredExecutions += 1;\n                } else {\n                    // Otherwise, assign the execution to the executions array.\n                    executions[i - totalFilteredExecutions] = execution;\n                }\n            }\n\n            // Iterate over each consideration fulfillment.\n            for (uint256 i = 0; i < totalConsiderationFulfillments; ++i) {\n                /// Retrieve consideration fulfillment components in question.\n                FulfillmentComponent[] memory components = (\n                    considerationFulfillments[i]\n                );\n\n                // Derive aggregated execution corresponding with fulfillment.\n                Execution memory execution = _aggregateAvailable(\n                    advancedOrders,\n                    Side.CONSIDERATION,\n                    components,\n                    fulfillerConduitKey\n                );\n\n                // If offerer and recipient on the execution are the same...\n                if (execution.item.recipient == execution.offerer) {\n                    // increment total filtered executions.\n                    totalFilteredExecutions += 1;\n                } else {\n                    // Otherwise, assign the execution to the executions array.\n                    executions[\n                        i + totalOfferFulfillments - totalFilteredExecutions\n                    ] = execution;\n                }\n            }\n\n            // If some number of executions have been filtered...\n            if (totalFilteredExecutions != 0) {\n                // reduce the total length of the executions array.\n                assembly {\n                    mstore(\n                        executions,\n                        sub(mload(executions), totalFilteredExecutions)\n                    )\n                }\n            }\n        }\n\n        // Revert if no orders are available.\n        if (executions.length == 0) {\n            revert NoSpecifiedOrdersAvailable();\n        }\n\n        // Perform final checks and return.\n        availableOrders = _performFinalChecksAndExecuteOrders(\n            advancedOrders,\n            executions\n        );\n\n        return (availableOrders, executions);\n    }\n\n    /**\n     * @dev Internal function to perform a final check that each consideration\n     *      item for an arbitrary number of fulfilled orders has been met and to\n     *      trigger associated executions, transferring the respective items.\n     *\n     * @param advancedOrders     The orders to check and perform executions for.\n     * @param executions         An array of elements indicating the sequence of\n     *                           transfers to perform when fulfilling the given\n     *                           orders.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     */\n    function _performFinalChecksAndExecuteOrders(\n        AdvancedOrder[] memory advancedOrders,\n        Execution[] memory executions\n    ) internal returns (bool[] memory availableOrders) {\n        // Retrieve the length of the advanced orders array and place on stack.\n        uint256 totalOrders = advancedOrders.length;\n\n        // Initialize array for tracking available orders.\n        availableOrders = new bool[](totalOrders);\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Iterate over orders to ensure all considerations are met.\n            for (uint256 i = 0; i < totalOrders; ++i) {\n                // Retrieve the order in question.\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\n\n                // Skip consideration item checks for order if not fulfilled.\n                if (advancedOrder.numerator == 0) {\n                    // Note: orders do not need to be marked as unavailable as a\n                    // new memory region has been allocated. Review carefully if\n                    // altering compiler version or managing memory manually.\n                    continue;\n                }\n\n                // Mark the order as available.\n                availableOrders[i] = true;\n\n                // Retrieve consideration items to ensure they are fulfilled.\n                ConsiderationItem[] memory consideration = (\n                    advancedOrder.parameters.consideration\n                );\n\n                // Iterate over each consideration item to ensure it is met.\n                for (uint256 j = 0; j < consideration.length; ++j) {\n                    // Retrieve remaining amount on the consideration item.\n                    uint256 unmetAmount = consideration[j].startAmount;\n\n                    // Revert if the remaining amount is not zero.\n                    if (unmetAmount != 0) {\n                        revert ConsiderationNotMet(i, j, unmetAmount);\n                    }\n                }\n            }\n        }\n\n        // Put ether value supplied by the caller on the stack.\n        uint256 etherRemaining = msg.value;\n\n        // Initialize an accumulator array. From this point forward, no new\n        // memory regions can be safely allocated until the accumulator is no\n        // longer being utilized, as the accumulator operates in an open-ended\n        // fashion from this memory pointer; existing memory may still be\n        // accessed and modified, however.\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\n\n        // Iterate over each execution.\n        for (uint256 i = 0; i < executions.length; ) {\n            // Retrieve the execution and the associated received item.\n            Execution memory execution = executions[i];\n            ReceivedItem memory item = execution.item;\n\n            // If execution transfers native tokens, reduce value available.\n            if (item.itemType == ItemType.NATIVE) {\n                // Ensure that sufficient native tokens are still available.\n                if (item.amount > etherRemaining) {\n                    revert InsufficientEtherSupplied();\n                }\n\n                // Skip underflow check as amount is less than ether remaining.\n                unchecked {\n                    etherRemaining -= item.amount;\n                }\n            }\n\n            // Transfer the item specified by the execution.\n            _transfer(\n                item,\n                execution.offerer,\n                execution.conduitKey,\n                accumulator\n            );\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Trigger any remaining accumulated transfers via call to the conduit.\n        _triggerIfArmed(accumulator);\n\n        // If any ether remains after fulfillments, return it to the caller.\n        if (etherRemaining != 0) {\n            _transferEth(payable(msg.sender), etherRemaining);\n        }\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n\n        // Return the array containing available orders.\n        return (availableOrders);\n    }\n\n    /**\n     * @dev Internal function to match an arbitrary number of full or partial\n     *      orders, each with an arbitrary number of items for offer and\n     *      consideration, supplying criteria resolvers containing specific\n     *      token identifiers and associated proofs as well as fulfillments\n     *      allocating offer components to consideration components.\n     *\n     * @param advancedOrders    The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or their conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order to receive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          an empty root indicates that any (transferrable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function _matchAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        Fulfillment[] calldata fulfillments\n    ) internal returns (Execution[] memory executions) {\n        // Validate orders, update order status, and determine item amounts.\n        _validateOrdersAndPrepareToFulfill(\n            advancedOrders,\n            criteriaResolvers,\n            true, // Signifies that invalid orders should revert.\n            advancedOrders.length\n        );\n\n        // Fulfill the orders using the supplied fulfillments.\n        return _fulfillAdvancedOrders(advancedOrders, fulfillments);\n    }\n\n    /**\n     * @dev Internal function to fulfill an arbitrary number of orders, either\n     *      full or partial, after validating, adjusting amounts, and applying\n     *      criteria resolvers.\n     *\n     * @param advancedOrders     The orders to match, including a fraction to\n     *                           attempt to fill for each order.\n     * @param fulfillments       An array of elements allocating offer\n     *                           components to consideration components. Note\n     *                           that the final amount of each consideration\n     *                           component must be zero for a match operation to\n     *                           be considered valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function _fulfillAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        Fulfillment[] calldata fulfillments\n    ) internal returns (Execution[] memory executions) {\n        // Retrieve fulfillments array length and place on the stack.\n        uint256 totalFulfillments = fulfillments.length;\n\n        // Allocate executions by fulfillment and apply them to each execution.\n        executions = new Execution[](totalFulfillments);\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Track number of filtered executions.\n            uint256 totalFilteredExecutions = 0;\n\n            // Iterate over each fulfillment.\n            for (uint256 i = 0; i < totalFulfillments; ++i) {\n                /// Retrieve the fulfillment in question.\n                Fulfillment calldata fulfillment = fulfillments[i];\n\n                // Derive the execution corresponding with the fulfillment.\n                Execution memory execution = _applyFulfillment(\n                    advancedOrders,\n                    fulfillment.offerComponents,\n                    fulfillment.considerationComponents\n                );\n\n                // If offerer and recipient on the execution are the same...\n                if (execution.item.recipient == execution.offerer) {\n                    // increment total filtered executions.\n                    totalFilteredExecutions += 1;\n                } else {\n                    // Otherwise, assign the execution to the executions array.\n                    executions[i - totalFilteredExecutions] = execution;\n                }\n            }\n\n            // If some number of executions have been filtered...\n            if (totalFilteredExecutions != 0) {\n                // reduce the total length of the executions array.\n                assembly {\n                    mstore(\n                        executions,\n                        sub(mload(executions), totalFilteredExecutions)\n                    )\n                }\n            }\n        }\n\n        // Perform final checks and execute orders.\n        _performFinalChecksAndExecuteOrders(advancedOrders, executions);\n\n        // Return the executions array.\n        return (executions);\n    }\n}\n\n\n",
        "CodeNames": [
            "FulfillmentApplier.sol",
            "Consideration.sol",
            "ConsiderationInterface.sol",
            "OrderCombiner.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\n                // Update error buffer (1 = zero amount, 2 = overflow).\n                errorBuffer := or(\n                  errorBuffer,\n                  or(\n                    shl(1, lt(newAmount, amount)),\n                    iszero(mload(amountPtr))\n                  )\n                )\n",
                    "//solidity\n            // Determine if an error code is contained in the error buffer.\n            switch errorBuffer\n            case 1 {\n                // Store the MissingItemAmount error signature.\n                mstore(0, MissingItemAmount_error_signature)\n\n                // Return, supplying MissingItemAmount signature.\n                revert(0, MissingItemAmount_error_len)\n            }\n            case 2 {\n                // If the sum overflowed, panic.\n                throwOverflow()\n            }\n"
                ],
                "Type": "  _aggregateValidFulfillmentOfferItems()  can be tricked to accept invalid inputs",
                "Description": "*Submitted by Spearbit, also found by Saw-mon&#95;and&#95;Natalie*\n\nFulfillmentApplier.sol#L406(https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L406)<br\n\nThe _aggregateValidFulfillmentOfferItems() function aims to revert on orders with zero value or where a total consideration amount overflows. Internally this is accomplished by having a temporary variable errorBuffer, accumulating issues found, and only reverting once all the items are processed in case there was a problem found. This code is optimistic for valid inputs.\n\nNote: there is a similar issue in _aggregateValidFulfillmentConsiderationItems(), which is reported separately.\n\nThe problem lies in how this errorBuffer is updated:\n\nsolidity\n                // Update error buffer (1 = zero amount, 2 = overflow).\n                errorBuffer := or(\n                  errorBuffer,\n                  or(\n                    shl(1, lt(newAmount, amount)),\n                    iszero(mload(amountPtr))\n                  )\n                )\n\n\nThe final error handling code:\n\nsolidity\n            // Determine if an error code is contained in the error buffer.\n            switch errorBuffer\n            case 1 {\n                // Store the MissingItemAmount error signature.\n                mstore(0, MissingItemAmount_error_signature)\n\n                // Return, supplying MissingItemAmount signature.\n                revert(0, MissingItemAmount_error_len)\n            }\n            case 2 {\n                // If the sum overflowed, panic.\n                throwOverflow()\n            }\n\n\nWhile the expected value is 0 (success),  1 or 2 (failure), it is possible to set it to 3, which is unhandled and considered as a \"success\". This can be easily accomplished by having both an overflowing item and a zero item in the order list.\n\nThis validation error could lead to fulfilling an order with a consideration (potentially ~0) lower than expected.\n\n\nCraft an offer containing two errors (e.g. with  zero amount and overflow).<br\nCall matchOrders(). Via calls to _matchAdvancedOrders(), _fulfillAdvancedOrders(), _applyFulfillment(), _aggregateValidFulfillmentOfferItems() will be called.<br\nThe errorBuffer will get a value of 3  (the or of 1 and 2).<br\nAs the value of 3 is not detected, no error will be thrown and the order will be executed, including the mal formed values.\n\n",
                "Repair": "\n1.  Change the check on FulfillmentApplier.sol#L465(https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L465)  to consider case 3.\n2.  Potential option: Introduce an early abort in case errorBuffer != 0 on FulfillmentApplier.sol#L338(https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L338)\n\n0age (OpenSea) confirmed(https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75)\n\nHardlyDifficult (judge) decreased severity to Medium(https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75)\n\ncmichel (warden) commented(https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75#issuecomment-1172848110):\n   This validation error could lead to fulfilling an order with a consideration (potentially ~0) lower than expected.\n \n That's correct, you can use this to fulfill an order essentially for free, that's why I'd consider this high severity.\n They could have done a better job demonstrating it with a POC test case but this sentence imo shows that they were aware of the impact.\n \n See this test case(https://github.com/ProjectOpenSea/seaport/blob/5c6a628cb152d731e956682dd748d30e8bf1f1c9/test/findings/FulfillmentOverflowWithMissingItems.spec.ts#L136) showing how to buy an NFT for 1 DAI instead of 1000 DAI.\n\n0age (OpenSea) disagreed with Medium severity:\n  This is the highest-severity finding. If it were me, I'd switch this to high.\n\nHardlyDifficult (judge) increased severity to High(https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75)\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75#issuecomment-1183115107):\n  After further consideration and discussion with @HardlyDifficult, we agree with @cmichel that this should be of high severity. As the protocol allows for invalid orders to be created, users aware of this vulnerability will be able to fulfill an order at a considerable discount. This fits the criteria of a high severity issue as it directly leads to lost funds.\n\n0age (OpenSea) resolved(https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75):\n  PR: ProjectOpenSea/seaport#320(https://github.com/ProjectOpenSea/seaport/pull/320)\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]