[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../interfaces/BadgerGuestlistApi.sol\";\n\n/**\n * @notice Sells a token at a predetermined price to whitelisted buyers.\n * TODO: Better revert strings\n */\ncontract TokenSaleUpgradeable is OwnableUpgradeable, PausableUpgradeable {\n    using SafeERC20Upgradeable for ERC20Upgradeable;\n\n    /// token to give out (CTDL)\n    ERC20Upgradeable public tokenOut;\n    /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n    ERC20Upgradeable public tokenIn;\n    /// time when tokens can be first purchased\n    uint64 public saleStart;\n    /// duration of the token sale, cannot purchase afterwards\n    uint64 public saleDuration;\n    /// address receiving the proceeds of the sale - will be citadel multisig\n    address public saleRecipient;\n    /// whether the sale has been finalized\n    bool public finalized;\n\n    /// tokenIn per tokenOut price\n    /// eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public tokenOutPrice;\n\n    /// Amounts bought by accounts\n    mapping(address => uint256) public boughtAmounts;\n    /// Whether an account has claimed tokens\n    /// NOTE: can reset boughtAmounts after a claim to optimize gas\n    ///       but we need to persist boughtAmounts\n    mapping(address => bool) public hasClaimed;\n\n    /// Amount of `tokenIn` taken in\n    uint256 public totalTokenIn;\n    /// Amount of `tokenOut` sold\n    uint256 public totalTokenOutBought;\n    /// Amount of `tokenOut` claimed\n    uint256 public totalTokenOutClaimed;\n\n    /// Max tokenIn that can be taken by the contract (defines the cap for tokenOut sold)\n    uint256 public tokenInLimit;\n\n    /// Whitelist\n    BadgerGuestListAPI public guestlist;\n\n    /// Amount vote for each DAO\n    mapping(uint8 => uint256) public daoCommitments;\n    mapping(address => uint8) public daoVotedFor;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Sale(\n        address indexed buyer,\n        uint8 indexed daoId,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event Claim(address indexed claimer, uint256 amount);\n    event Finalized();\n\n    event SaleStartUpdated(uint64 saleStart);\n    event SaleDurationUpdated(uint64 saleDuration);\n    event TokenOutPriceUpdated(uint256 tokenOutPrice);\n    event SaleRecipientUpdated(address indexed recipient);\n    event GuestlistUpdated(address indexed guestlist);\n    event TokenInLimitUpdated(uint256 tokenInLimit);\n\n    event Sweeped(address indexed token, uint256 amount);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _tokenOut The token this contract will return in a trade\n     * @param _tokenIn The token this contract will receive in a trade\n     * @param _saleStart The time when tokens can be first purchased\n     * @param _saleDuration The duration of the token sale\n     * @param _tokenOutPrice The tokenIn per tokenOut price\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _guestlist Address that will manage auction approvals\n     * @param _tokenInLimit The max tokenIn that the contract can take\n     */\n    function initialize(\n        address _tokenOut,\n        address _tokenIn,\n        uint64 _saleStart,\n        uint64 _saleDuration,\n        uint256 _tokenOutPrice,\n        address _saleRecipient,\n        address _guestlist,\n        uint256 _tokenInLimit\n    ) external initializer {\n        require(\n            _saleStart >= block.timestamp,\n            \"TokenSale: start date may not be in the past\"\n        );\n        require(\n            _saleDuration > 0,\n            \"TokenSale: the sale duration must not be zero\"\n        );\n        require(_tokenOutPrice > 0, \"TokenSale: the price must not be zero\");\n        require(\n            _saleRecipient != address(0),\n            \"TokenSale: sale recipient should not be zero\"\n        );\n\n        __Ownable_init();\n        __Pausable_init();\n\n        tokenOut = ERC20Upgradeable(_tokenOut);\n        tokenIn = ERC20Upgradeable(_tokenIn);\n        saleStart = _saleStart;\n        saleDuration = _saleDuration;\n        tokenOutPrice = _tokenOutPrice;\n        saleRecipient = _saleRecipient;\n        guestlist = BadgerGuestListAPI(_guestlist);\n        tokenInLimit = _tokenInLimit;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_tokenInAmount` of `tokenIn` for `tokenOut`\n     * @param _tokenInAmount Amount of `tokenIn` to give\n     * @param _daoId ID of DAO to vote for\n     * @param _proof Merkle proof for the guestlist. Use `new bytes32[](0)` if there's no guestlist\n     * @return tokenOutAmount_ Amount of `tokenOut` bought\n     */\n    function buy(\n        uint256 _tokenInAmount,\n        uint8 _daoId,\n        bytes32[] calldata _proof\n    ) external whenNotPaused returns (uint256 tokenOutAmount_) {\n        require(saleStart <= block.timestamp, \"TokenSale: not started\");\n        require(\n            block.timestamp < saleStart + saleDuration,\n            \"TokenSale: already ended\"\n        );\n        require(_tokenInAmount > 0, \"_tokenInAmount should be > 0\");\n        require(\n            totalTokenIn + _tokenInAmount <= tokenInLimit,\n            \"total amount exceeded\"\n        );\n\n        if (address(guestlist) != address(0)) {\n            require(guestlist.authorized(msg.sender, _proof), \"not authorized\");\n        }\n\n        uint256 boughtAmountTillNow = boughtAmounts[msg.sender];\n\n        if (boughtAmountTillNow > 0) {\n            require(\n                _daoId == daoVotedFor[msg.sender],\n                \"can't vote for multiple daos\"\n            );\n        } else {\n            daoVotedFor[msg.sender] = _daoId;\n        }\n\n        tokenOutAmount_ = getAmountOut(_tokenInAmount);\n\n        boughtAmounts[msg.sender] = boughtAmountTillNow + tokenOutAmount_;\n        daoCommitments[_daoId] += tokenOutAmount_;\n\n        totalTokenIn += _tokenInAmount;\n        totalTokenOutBought += tokenOutAmount_;\n\n        tokenIn.safeTransferFrom(msg.sender, saleRecipient, _tokenInAmount);\n\n        emit Sale(msg.sender, _daoId, _tokenInAmount, tokenOutAmount_);\n    }\n\n    /**\n     * @notice Claim bought tokens after sale has been finalized\n     */\n    function claim() external whenNotPaused returns (uint256 tokenOutAmount_) {\n        require(finalized, \"sale not finalized\");\n        require(!hasClaimed[msg.sender], \"already claimed\");\n\n        tokenOutAmount_ = boughtAmounts[msg.sender];\n\n        require(tokenOutAmount_ > 0, \"nothing to claim\");\n\n        hasClaimed[msg.sender] = true;\n        totalTokenOutClaimed += tokenOutAmount_;\n\n        tokenOut.safeTransfer(msg.sender, tokenOutAmount_);\n\n        emit Claim(msg.sender, tokenOutAmount_);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `tokenIn`\n     * @param _tokenInAmount Amount of `tokenIn` to exchange\n     * @return tokenOutAmount_ Amount of `tokenOut` received\n     */\n    function getAmountOut(uint256 _tokenInAmount)\n        public\n        view\n        returns (uint256 tokenOutAmount_)\n    {\n        tokenOutAmount_ =\n            (_tokenInAmount * 10**tokenOut.decimals()) /\n            tokenOutPrice;\n    }\n\n    /**\n     * @notice Check how much `tokenIn` can still be taken in\n     * @return limitLeft_ Amount of `tokenIn` that can still be exchanged\n     */\n    function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {\n        if (totalTokenIn < tokenInLimit) {\n            limitLeft_ = tokenInLimit - totalTokenIn;\n        }\n    }\n\n    /**\n     * @notice Check if the sale has ended\n     * @return hasEnded_ True if the sale has ended\n     */\n    function saleEnded() public view returns (bool hasEnded_) {\n        hasEnded_ =\n            (block.timestamp >= saleStart + saleDuration) ||\n            (totalTokenIn >= tokenInLimit);\n    }\n\n    /// ===============================\n    /// ===== Permissioned: owner =====\n    /// ===============================\n\n    /**\n     * @notice Finalize the sale after sale duration. Can only be called by owner\n       @dev Ensure contract has enough `tokenOut` before calling\n     */\n    function finalize() external onlyOwner {\n        require(!finalized, \"TokenSale: already finalized\");\n        require(saleEnded(), \"TokenSale: not finished\");\n        require(\n            tokenOut.balanceOf(address(this)) >= totalTokenOutBought,\n            \"TokenSale: not enough balance\"\n        );\n\n        finalized = true;\n\n        emit Finalized();\n    }\n\n    /**\n     * @notice Update the sale start time. Can only be called by owner\n     * @param _saleStart New start time\n     */\n    function setSaleStart(uint64 _saleStart) external onlyOwner {\n        require(\n            _saleStart >= block.timestamp,\n            \"TokenSale: start date may not be in the past\"\n        );\n        require(!finalized, \"TokenSale: already finalized\");\n\n        saleStart = _saleStart;\n\n        emit SaleStartUpdated(_saleStart);\n    }\n\n    /**\n     * @notice Update sale duration. Can only be called by owner\n     * @param _saleDuration New duration\n     */\n    function setSaleDuration(uint64 _saleDuration) external onlyOwner {\n        require(\n            _saleDuration > 0,\n            \"TokenSale: the sale duration must not be zero\"\n        );\n        require(!finalized, \"TokenSale: already finalized\");\n\n        saleDuration = _saleDuration;\n\n        emit SaleDurationUpdated(_saleDuration);\n    }\n\n    /**\n     * @notice Modify the tokenOut price in. Can only be called by owner\n     * @param _tokenOutPrice New tokenOut price\n     */\n    function setTokenOutPrice(uint256 _tokenOutPrice) external onlyOwner {\n        require(_tokenOutPrice > 0, \"TokenSale: the price must not be zero\");\n\n        tokenOutPrice = _tokenOutPrice;\n\n        emit TokenOutPriceUpdated(_tokenOutPrice);\n    }\n\n    /**\n     * @notice Update the `tokenIn` receipient address. Can only be called by owner\n     * @param _saleRecipient New recipient address\n     */\n    function setSaleRecipient(address _saleRecipient) external onlyOwner {\n        require(\n            _saleRecipient != address(0),\n            \"TokenSale: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    /**\n     * @notice Update the guestlist address. Can only be called by owner\n     * @param _guestlist New guestlist address\n     */\n    function setGuestlist(address _guestlist) external onlyOwner {\n        guestlist = BadgerGuestListAPI(_guestlist);\n\n        emit GuestlistUpdated(_guestlist);\n    }\n\n    /**\n     * @notice Modify the max tokenIn that this contract can take. Can only be called by owner\n     * @param _tokenInLimit New max amountIn\n     */\n    function setTokenInLimit(uint256 _tokenInLimit) external onlyOwner {\n        require(!finalized, \"TokenSale: already finalized\");\n\n        tokenInLimit = _tokenInLimit;\n\n        emit TokenInLimitUpdated(_tokenInLimit);\n    }\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `tokenIn` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `tokenIn`. For `tokenOut`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token) external onlyOwner {\n        uint256 amount = ERC20Upgradeable(_token).balanceOf(address(this));\n\n        if (_token == address(tokenOut)) {\n            uint256 amountLeftToBeClaimed = totalTokenOutBought -\n                totalTokenOutClaimed;\n            amount -= amountLeftToBeClaimed;\n        }\n\n        require(amount > 0, \"nothing to sweep\");\n\n        ERC20Upgradeable(_token).safeTransfer(msg.sender, amount);\n\n        emit Sweeped(_token, amount);\n    }\n\n    /**\n     * @notice Pause the sale. Can only be called by owner\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the sale. Can only be called by owner\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n\n\n",
        "CodeNames": [
            "TokenSaleUpgradeable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "sweep",
                    "buy",
                    "finalize",
                    "getAmountOut"
                ],
                "Type": " The Owner and Proxy Admin can make users lose funds (\"rug vectors\")",
                "Description": "\nThe contest explicitly asks to analyze the contract for \"Rug Vectors\", so that is what this issue is about.\n\nI have classified this issue as \"high risk\" although the vulnerability is considerable, the attacks themselves are not very likely to occur (they depend on the owner and/or the proxy admin to be compromised). The main reason why I believe the vulnerabiity is \"high\" is because the very fact that all these factors exist can make the sale fail, as informed users will avoid the contract completely one they realize the extent in which the contract is manipulable.\n\nIn the current implementation, there several ways that investors can lose funds if the owner of the contract is not well behaved. These risks can be divided into two kinds:\n\n*   owner becomes unable to act (for example, owner looses her private key, or the owner is a wallet or a DAO and signers cannot agree on the right action to take)\n*   owner is malicious  (for example, the owner account gets hacked or the signers turn bad), and wants to steal as much as the funds as possible (\"Rug Vectors\"), or executes a griefing attack (i.e. acts in such a way to hurt the buyers and/or the project, without immediate financial gain)\n\nThe contract is vulnerable to all three types of vulnerabilities (\"rug pull\", \"griefing\" and \"inactivity\").\n\n(1) Loss of funds due to owner inactivity:\n(1a) If the owner does never funds the contract, the buyers will not receive their tokens, and have no recourse to get their investment back\n(1b) If the owner does not call finalize, buyers will not receive their tokens, and and have no recourse to get their investment back\n\n(2) Griefing attacks by the owner (attacks that that have no immediate gain for the attacker, but are either annoying or lead to loss of funds)\n(2a) the owner can change many essential conditions of the sale: for example, the price, the start time, the duration, the guest list, and the total amount of tokens that are allowed to be sold. The owner can do this at any moment, also while the sale is in course. This allows for all kinds of griefing attacks. It also voids the whole point of using a smart contract in the first place.\n(2b) Owner can pause the contract at any time, which will freeze the funds in the contract, as it also disallows users to claim their tokens\n\n(3) Rug pull by owner (attacks with financial gain for the attacker, buyer loses money)\n(3a) The Owner can call sweep at any time and remove all unsold CTDL tokens while the sale is in progress. Future buyers will still be able to buy tokens, but the sale can never be finalized (unless the owner funds the contract)\n(3b) Owner can front-run buyers and change the price. I.e. the owner can monitor the mem pool for a large buy transaction and precede the transaction with her own transaction that changes the price to a very low one. If the price is low enough, getAmountOut will return 0, and the buyers will lose her funds and not receive any CTDL tokens at all.\n\n(4) Rug pull by proxy Admin\n(4a) Although no deployment script is provided in the repo, we may assume (from the tests and the fact that the contracts are upgradeable) that the actual sale will be deployed as a proxy. The proxy admin (which may not be the same account as the owner) can change the implementation of the contract at any time, and in particular can change the implemention logic in such a way that all the funds held by the contract can be sent to the attacker.\n\n",
                "Repair": "\n*   In general, I would recommend to not write your own contract at all, but instead use OpenZeppelin's crowdsale contract: <https://docs.openzeppelin.com/contracts/2.x/api/crowdsale#Crowdsale which seems to fit your needs pretty well\n*   To address 1a and 3a, enforce that the contract is funded  with enough CTDL tokens *before* the sale starts (for example, as part of the initialize logic)\n*   To adress 1b, simply remove the \"onlyOwner\" modifier on the \"finalize()\" function so that it can be called by anyone\n*   To (partially) address 2a, reduce the extent to which the owner can change the sale conditions during the sale (in any case remove the setSaleStart, setSaleEnd, setTokenInLimit or limit their application to before the sale starts). Ideally, once the sale starts, conditions of the sale remain unchanged, or change in a predictable way\n*   To address 2b, leave the tokens of the buyer in the contract (instead of sending them to a saleRecipient and implement an emergencyWithdraw function that will work also when the contract is paused, and that allows buyers can use to retrieve their original investment in case something goes wrong\n*   To address 3a, allow the owner to call sweep only after the sale is finalized\n*   To address 3b, either do not allow to change the token price during the token sale, or, if you must have this functionality, have the price change take effect only after a delay to make front-running by the owner impossible\n*   To address 4a, do not deploy the contract as a proxy at all (which seems overkill anyway, given the use case)\n\n0xleastwood (judge) decreased to Medium severity and commented(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/50#issuecomment-1066631798):\n  Awesome write-up! \n \n Because the issue outlined by the warden covers several separate issues from other wardens, I'll mark this as the primary issue and de-duplicate all other issues.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/50#issuecomment-1069103297):\n  I've thought about this more and I've decided to split up distinct issues into 3 primary issues:\n Owner rugs users.\n Funds are transferred to saleRecipient before settlement.\n Changing a token buy price during the sale by front-running buyers by forcing them to purchase at an unfair token price.\n\n  This issue falls under the first primary issue.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "sol#buy()",
                    "tokenIn",
                    "tokenOut",
                    "finalize()",
                    "CTDL",
                    "saleRecipient",
                    "WBTC",
                    "buy()"
                ],
                "Type": "  saleRecipient  can rug buyers",
                "Description": "\nIn TokenSaleUpgradeable.sol#buy(), tokenIn will be transferred from the buyer directly to the saleRecipient without requiring/locking/releasing the corresponding amount of tokenOut.\n\nThis allows the saleRecipient to rug the users simply by not transferring tokenOut and finalizing the sale.\n\n\nGiven:\n\n*   tokenIn: WBTC\n*   _tokenOutPrice: 1e8\n*   tokenOut: CTDL\n\n1.  Alice buy() with 100e8;\n2.  Alice buy() with 200e8;\n\nA malicious saleRecipient can just not transfer any CTDL to the contract and finalize() and keep 300e8 WBTC received.\n\nAs a result, Alice and Bob can not get the expected amount of tokensOut, and there is no way to retrieve the WBTC paid, in essence, lose all the funds.\n\n",
                "Repair": "\nInstead of transferring the tokenIn directing to the saleRecipient in buy(), consider transferring the tokenIn into the contract (address(this)), and require a sufficient amount of tokenOut to be transferred into the contract first before the amount of tokenIn can be released to the saleRecipient.\n\nshuklaayush (BadgerDAO) disagreed with severity(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/61)\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/61#issuecomment-1066620627):\n  As this is also an issue regarding abuse of an owner's admin privileges, it fits the criteria of a medium severity issue.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/61#issuecomment-1069067800):\n  I've thought about this more and I've decided to split up distinct issues into 3 primary issues:\n Owner rugs users.\n Funds are transferred to saleRecipient before settlement.\n Changing a token buy price during the sale by front-running buyers by forcing them to purchase at an unfair token price.\n\n  This issue falls under the second primary issue.\n  Funds are transferred to saleRecipient before settlement.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [
                    "buy()",
                    "saleRecipient",
                    "setTokenOutPrice()"
                ],
                "Type": " Owner can steal input tokens",
                "Description": "\nTokenSaleUpgradeable.sol#L299-L309(https://github.com/code-423n4/2022-02-badger-citadel/blob/main/contracts/TokenSaleUpgradeable.sol#L299-L309)<br\nTokenSaleUpgradeable.sol#L311-L324(https://github.com/code-423n4/2022-02-badger-citadel/blob/main/contracts/TokenSaleUpgradeable.sol#L311-L324)<br\nTokenSaleUpgradeable.sol#L211-L224(https://github.com/code-423n4/2022-02-badger-citadel/blob/main/contracts/TokenSaleUpgradeable.sol#L211-L224)\n\nOwner is in full control over the saleRecipient address. When a buy() transaction enters the mempool, an owner can frontrun the buy with a transaction that calls setTokenOutPrice() and sets the price to a very high value, effectively making bought tokens close to (if not usually equal) zero and consuming the tokens to the owner-selected address saleRecipient. Thus, an owner has incentive to perform such attack as they may cause little or zero additional indebtnees to the contract and all tokens to the owner.\n\nThis can also be seen as a coincidence an owner sets a price while a user broadcasts a buy() transaction. The user may buy for a significantly different price than they intended.\n\n",
                "Repair": "\nDo not let changing sale price after the sale has started. Do not let changing sale start if the sale has already started.\n\nGalloDaSballo (BadgerDAO) disagreed with severity and commented(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/105#issuecomment-1031666053):\n  I agree with the finding and the conclusion, we shouldn't let the price change after the sale has started.\n \n As for the example, that would only work once, because if we actually did that it would immediately warn every other user of our malicious behavior.\n \n I think the finding is valid and it's a clear example of admin privilege, so I believe medium severity to be more appropriate\n\n0xleastwood (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/105#issuecomment-1066608561):\n  I agree with the sponsor on the above.\n\n0xleastwood (judge) commented(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/105#issuecomment-1069077794):\n  I've thought about this more and I've decided to split up distinct issues into 3 primary issues:\n Owner rugs users.\n Funds are transferred to saleRecipient before settlement.\n Changing a token buy price during the sale by front-running buyers by forcing them to purchase at an unfair token price.\n\n  I believe this satisfies the third primary issue description.\n  Changing a token buy price during the sale by front-running buyers by forcing them to purchase at an unfair token price.\n\n\n\n*\n\n# Low Risk and Non-Critical Issues\n\nFor this contest, 24 reports were submitted by wardens detailing low risk and non-critical issues. The report highlighted below(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/111) by warden Czar102 received the top score from the judge.\n\n_The following wardens also submitted reports: 0x0x0x(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/31), gellej(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/51), cmichel(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/40), Dravee(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/106), 0x1f8b(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/18), hubble(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/64), OriDabush(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/69), pauliax(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/96), IllIllI(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/66), sirhashalot(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/84), NoamYakov(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/90), tqts(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/28), WatchPug(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/57), hyh(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/107), Ruhum(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/75), floppydisk(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/34), csanuragjain(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/23), defsec(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/46), gzeon(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/47), samruna(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/1), wuwe1(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/74), robee(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/8), and kenta(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/33)._\n\n## Codebase Impressions and Summary\n\nSeveral minor changes have been identified that can be applied in order to improve general security of the contract logic and code quality.\n\nAmong those, three out of four issues focus on code clarity, conventions and unambiguity of the comments. A possible attack vector has also been recognized, which makes the owner capable of griefing users and making their transactions revert, consuming gas fees.\n\n\n"
            },
            {
                "Name": "-02",
                "Location": [
                    "_tokenInLimit",
                    "_saleDuration",
                    "setSaleDuration",
                    "buy",
                    "setTokenInLimit",
                    "setSaleStart"
                ],
                "Type": " Owner can frontrun  buy  function",
                "Description": "\nOwner can frontrun buy function in order to cause transaction to fail (and as a consequence make someone lose gas fee) by invoking one of these functions:\n\n*   setTokenInLimit, with a small _tokenInLimit argument,\n*   setSaleDuration, with a small _saleDuration argument,\n*   setSaleStart, with a future timestamp.\n\n",
                "Repair": "\nRevert calls to these functions after the sale has started.\n\n\n"
            },
            {
                "Name": "-01",
                "Location": [
                    "require()",
                    "> 0"
                ],
                "Type": " Use  != 0  rather than  > 0  for unsigned integers in  require()  statements",
                "Description": "\nWhen the optimizer is enabled, gas is wasted by doing a greater-than operation, rather than a not-equals operation inside require() statements. When Using !=, the optimizer is able to avoid the EQ, ISZERO, and associated operations, by relying on the JUMPI that comes afterwards, which itself checks for zero.\n\nSee markdown file within original submission(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/112) for in-depth examples.\n\nHardhat\nForge\nnpx @remix-project/remix-lib\n\n",
                "Repair": "Use != 0 rather than  0 for unsigned integers in require() statements. Note that the comparison in claim() results in no gas savings.\n\n\n"
            },
            {
                "Name": "-05",
                "Location": [
                    "//solidity\n        tokenIn.safeTransferFrom(msg.sender, saleRecipient, _tokenInAmount);\n"
                ],
                "Type": " - Pull tokens rather than pushing them",
                "Description": "\nIt wastes gas to push tokens to saleRecipient every time there is a buy.\n\n\nsolidity\n        tokenIn.safeTransferFrom(msg.sender, saleRecipient, _tokenInAmount);\n\n\n",
                "Repair": "Create a new function or modify sweep() to send the current balance of the contract to saleRecipient\n\nGalloDaSballo (BadgerDao) confirmed and commented(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/112#issuecomment-1045313951):\n  All findings are valid and appreciated, would recommend the warden to just post the specific gas differences instead of the whole table as there's 10s of thousands of lines in the readme, but the only lines that count are very few.\n \n That said, this may be the best report I've ever seen, as while it's a lot of superfluous information (again just delete the redundant lines), the information is all there and verifiable.\n \n I think the work from the warden is commendable and it is really appreciated.\n \n A breath of fresh air compared to the usual copy paste \"use != instead of \"\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-01",
                "Location": [
                    "//solidity\n// TokenSaleUpgradeable.sol:32\n/// eg. 1 WBTC (8 decimals) = 40,000 CTDL == price = 10^8 / 40,000\n"
                ],
                "Type": " Ambiguous usage of  ^  operator",
                "Description": "\nIs Solidity ^ is used for xor operation, but in TokenSaleUpgradeable.sol:32(https://github.com/code-423n4/2022-02-badger-citadel/blob/84596551d62f243d13fcb2d486346dde08002f7b/contracts/TokenSaleUpgradeable.sol#L32) it is used to symbolize exponentiation. It is preferable to use  instead to avoid ambiguity or confusion.\n\nsolidity\n// TokenSaleUpgradeable.sol:32\n/// eg. 1 WBTC (8 decimals) = 40,000 CTDL == price = 10^8 / 40,000\n\n\n\n",
                "Repair": ""
            },
            {
                "Name": "-04",
                "Location": [],
                "Type": " - Use  unchecked  for operations not expected to overflow",
                "Description": "\nIf it is not possible for an operation to overflow, it should be wrapped in unchecked {} to save the gas that would have been used to check for an overflow.\n\nSee markdown file within original submission(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/112) for in-depth examples.\n\nHardhat\nForge\nnpx @remix-project/remix-lib\n\n",
                "Repair": "Add unchecked { } and casts to operations that cannot overflow\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.11;\n\nimport \"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\";\n\n/**\n * @notice A basic guest list contract for testing.\n * @dev For a Vyper implementation of this contract containing additional\n * functionality, see https://github.com/banteg/guest-list/blob/master/contracts/GuestList.vy\n * The owner can invite arbitrary guests\n * A guest can be added permissionlessly with proof of inclusion in current merkle set\n * The owner can change the merkle root at any time\n * Merkle-based permission that has been claimed cannot be revoked permissionlessly.\n * Any guests can be revoked by the owner at-will\n * This can only be made more permissive over time. If decreased, existing TVL is maintained and no deposits are possible until the TVL has gone below the threshold\n * A variant of the yearn AffiliateToken that supports guest list control of deposits\n * A guest list that gates access by merkle root\n */\ncontract VipGuestListUpgradeable is OwnableUpgradeable {\n    bytes32 public guestRoot;\n\n    mapping(address => bool) public guests;\n\n    event ProveInvitation(address indexed account, bytes32 indexed guestRoot);\n    event SetGuestRoot(bytes32 indexed guestRoot);\n\n    /**\n     * @notice Create the test guest list, setting the message sender as\n     * `owner`.\n     * @dev Note that since this is just for testing, you're unable to change\n     * `owner`.\n     */\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    /**\n     * @notice Invite guests or kick them from the party.\n     * @param _guests The guests to add or update.\n     * @param _invited A flag for each guest at the matching index, inviting or\n     * uninviting the guest.\n     */\n    function setGuests(address[] calldata _guests, bool[] calldata _invited)\n        external\n        onlyOwner\n    {\n        _setGuests(_guests, _invited);\n    }\n\n    /**\n     * @notice Permissionly prove an address is included in the current merkle root, thereby granting access\n     * @notice Note that the list is designed to ONLY EXPAND in future instances\n     * @notice The admin does retain the ability to ban individual addresses\n     */\n    function proveInvitation(address account, bytes32[] calldata merkleProof)\n        public\n    {\n        // Verify Merkle Proof\n        require(_verifyInvitationProof(account, merkleProof));\n\n        address[] memory accounts = new address[](1);\n        bool[] memory invited = new bool[](1);\n\n        accounts[0] = account;\n        invited[0] = true;\n\n        _setGuests(accounts, invited);\n\n        emit ProveInvitation(account, guestRoot);\n    }\n\n    /**\n     * @notice Set the merkle root to verify invitation proofs against.\n     * @notice Note that accounts not included in the root will still be invited if their inviation was previously approved.\n     * @notice Setting to 0 removes proof verification versus the root, opening access\n     */\n    function setGuestRoot(bytes32 guestRoot_) external onlyOwner {\n        guestRoot = guestRoot_;\n\n        emit SetGuestRoot(guestRoot);\n    }\n\n    /**\n     * @notice Check if a guest with a bag of a certain size is allowed into\n     * the party.\n     * @param _guest The guest's address to check.\n     */\n    function authorized(address _guest, bytes32[] calldata _merkleProof)\n        external\n        view\n        returns (bool)\n    {\n        // Yes: If the user is on the list\n        // Yes: If the user is not on the list, supplies a valid proof (thereby being added to the list)\n        // No: If the user is not on the list or does not supply a valid proof\n        bool invited = guests[_guest];\n\n        // If there is no guest root, all users are invited\n        if (!invited && guestRoot == bytes32(0)) {\n            invited = true;\n        }\n\n        // If the user is not already invited and there is an active guestList, require verification of merkle proof to grant temporary invitation (does not set storage variable)\n        if (!invited && guestRoot != bytes32(0)) {\n            // Will revert on invalid proof\n            invited = _verifyInvitationProof(_guest, _merkleProof);\n        }\n\n        return invited;\n    }\n\n    function _setGuests(address[] memory _guests, bool[] memory _invited)\n        internal\n    {\n        require(_guests.length == _invited.length);\n        for (uint256 i = 0; i < _guests.length; i++) {\n            if (_guests[i] == address(0)) {\n                break;\n            }\n            guests[_guests[i]] = _invited[i];\n        }\n    }\n\n    function _verifyInvitationProof(\n        address account,\n        bytes32[] calldata merkleProof\n    ) internal view returns (bool) {\n        bytes32 node = keccak256(abi.encodePacked(account));\n        return MerkleProofUpgradeable.verify(merkleProof, guestRoot, node);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../interfaces/BadgerGuestlistApi.sol\";\n\n/**\n * @notice Sells a token at a predetermined price to whitelisted buyers.\n * TODO: Better revert strings\n */\ncontract TokenSaleUpgradeable is OwnableUpgradeable, PausableUpgradeable {\n    using SafeERC20Upgradeable for ERC20Upgradeable;\n\n    /// token to give out (CTDL)\n    ERC20Upgradeable public tokenOut;\n    /// token to take in WBTC / bibbtc LP / CVX / bveCVX\n    ERC20Upgradeable public tokenIn;\n    /// time when tokens can be first purchased\n    uint64 public saleStart;\n    /// duration of the token sale, cannot purchase afterwards\n    uint64 public saleDuration;\n    /// address receiving the proceeds of the sale - will be citadel multisig\n    address public saleRecipient;\n    /// whether the sale has been finalized\n    bool public finalized;\n\n    /// tokenIn per tokenOut price\n    /// eg. 1 WBTC (8 decimals) = 40,000 CTDL ==> price = 10^8 / 40,000\n    uint256 public tokenOutPrice;\n\n    /// Amounts bought by accounts\n    mapping(address => uint256) public boughtAmounts;\n    /// Whether an account has claimed tokens\n    /// NOTE: can reset boughtAmounts after a claim to optimize gas\n    ///       but we need to persist boughtAmounts\n    mapping(address => bool) public hasClaimed;\n\n    /// Amount of `tokenIn` taken in\n    uint256 public totalTokenIn;\n    /// Amount of `tokenOut` sold\n    uint256 public totalTokenOutBought;\n    /// Amount of `tokenOut` claimed\n    uint256 public totalTokenOutClaimed;\n\n    /// Max tokenIn that can be taken by the contract (defines the cap for tokenOut sold)\n    uint256 public tokenInLimit;\n\n    /// Whitelist\n    BadgerGuestListAPI public guestlist;\n\n    /// Amount vote for each DAO\n    mapping(uint8 => uint256) public daoCommitments;\n    mapping(address => uint8) public daoVotedFor;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event Sale(\n        address indexed buyer,\n        uint8 indexed daoId,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n    event Claim(address indexed claimer, uint256 amount);\n    event Finalized();\n\n    event SaleStartUpdated(uint64 saleStart);\n    event SaleDurationUpdated(uint64 saleDuration);\n    event TokenOutPriceUpdated(uint256 tokenOutPrice);\n    event SaleRecipientUpdated(address indexed recipient);\n    event GuestlistUpdated(address indexed guestlist);\n    event TokenInLimitUpdated(uint256 tokenInLimit);\n\n    event Sweeped(address indexed token, uint256 amount);\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer.\n     * @param _tokenOut The token this contract will return in a trade\n     * @param _tokenIn The token this contract will receive in a trade\n     * @param _saleStart The time when tokens can be first purchased\n     * @param _saleDuration The duration of the token sale\n     * @param _tokenOutPrice The tokenIn per tokenOut price\n     * @param _saleRecipient The address receiving the proceeds of the sale - will be citadel multisig\n     * @param _guestlist Address that will manage auction approvals\n     * @param _tokenInLimit The max tokenIn that the contract can take\n     */\n    function initialize(\n        address _tokenOut,\n        address _tokenIn,\n        uint64 _saleStart,\n        uint64 _saleDuration,\n        uint256 _tokenOutPrice,\n        address _saleRecipient,\n        address _guestlist,\n        uint256 _tokenInLimit\n    ) external initializer {\n        require(\n            _saleStart >= block.timestamp,\n            \"TokenSale: start date may not be in the past\"\n        );\n        require(\n            _saleDuration > 0,\n            \"TokenSale: the sale duration must not be zero\"\n        );\n        require(_tokenOutPrice > 0, \"TokenSale: the price must not be zero\");\n        require(\n            _saleRecipient != address(0),\n            \"TokenSale: sale recipient should not be zero\"\n        );\n\n        __Ownable_init();\n        __Pausable_init();\n\n        tokenOut = ERC20Upgradeable(_tokenOut);\n        tokenIn = ERC20Upgradeable(_tokenIn);\n        saleStart = _saleStart;\n        saleDuration = _saleDuration;\n        tokenOutPrice = _tokenOutPrice;\n        saleRecipient = _saleRecipient;\n        guestlist = BadgerGuestListAPI(_guestlist);\n        tokenInLimit = _tokenInLimit;\n    }\n\n    /// ==========================\n    /// ===== Public actions =====\n    /// ==========================\n\n    /**\n     * @notice Exchange `_tokenInAmount` of `tokenIn` for `tokenOut`\n     * @param _tokenInAmount Amount of `tokenIn` to give\n     * @param _daoId ID of DAO to vote for\n     * @param _proof Merkle proof for the guestlist. Use `new bytes32[](0)` if there's no guestlist\n     * @return tokenOutAmount_ Amount of `tokenOut` bought\n     */\n    function buy(\n        uint256 _tokenInAmount,\n        uint8 _daoId,\n        bytes32[] calldata _proof\n    ) external whenNotPaused returns (uint256 tokenOutAmount_) {\n        require(saleStart <= block.timestamp, \"TokenSale: not started\");\n        require(\n            block.timestamp < saleStart + saleDuration,\n            \"TokenSale: already ended\"\n        );\n        require(_tokenInAmount > 0, \"_tokenInAmount should be > 0\");\n        require(\n            totalTokenIn + _tokenInAmount <= tokenInLimit,\n            \"total amount exceeded\"\n        );\n\n        if (address(guestlist) != address(0)) {\n            require(guestlist.authorized(msg.sender, _proof), \"not authorized\");\n        }\n\n        uint256 boughtAmountTillNow = boughtAmounts[msg.sender];\n\n        if (boughtAmountTillNow > 0) {\n            require(\n                _daoId == daoVotedFor[msg.sender],\n                \"can't vote for multiple daos\"\n            );\n        } else {\n            daoVotedFor[msg.sender] = _daoId;\n        }\n\n        tokenOutAmount_ = getAmountOut(_tokenInAmount);\n\n        boughtAmounts[msg.sender] = boughtAmountTillNow + tokenOutAmount_;\n        daoCommitments[_daoId] += tokenOutAmount_;\n\n        totalTokenIn += _tokenInAmount;\n        totalTokenOutBought += tokenOutAmount_;\n\n        tokenIn.safeTransferFrom(msg.sender, saleRecipient, _tokenInAmount);\n\n        emit Sale(msg.sender, _daoId, _tokenInAmount, tokenOutAmount_);\n    }\n\n    /**\n     * @notice Claim bought tokens after sale has been finalized\n     */\n    function claim() external whenNotPaused returns (uint256 tokenOutAmount_) {\n        require(finalized, \"sale not finalized\");\n        require(!hasClaimed[msg.sender], \"already claimed\");\n\n        tokenOutAmount_ = boughtAmounts[msg.sender];\n\n        require(tokenOutAmount_ > 0, \"nothing to claim\");\n\n        hasClaimed[msg.sender] = true;\n        totalTokenOutClaimed += tokenOutAmount_;\n\n        tokenOut.safeTransfer(msg.sender, tokenOutAmount_);\n\n        emit Claim(msg.sender, tokenOutAmount_);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    /**\n     * @notice Get the amount received when exchanging `tokenIn`\n     * @param _tokenInAmount Amount of `tokenIn` to exchange\n     * @return tokenOutAmount_ Amount of `tokenOut` received\n     */\n    function getAmountOut(uint256 _tokenInAmount)\n        public\n        view\n        returns (uint256 tokenOutAmount_)\n    {\n        tokenOutAmount_ =\n            (_tokenInAmount * 10**tokenOut.decimals()) /\n            tokenOutPrice;\n    }\n\n    /**\n     * @notice Check how much `tokenIn` can still be taken in\n     * @return limitLeft_ Amount of `tokenIn` that can still be exchanged\n     */\n    function getTokenInLimitLeft() external view returns (uint256 limitLeft_) {\n        if (totalTokenIn < tokenInLimit) {\n            limitLeft_ = tokenInLimit - totalTokenIn;\n        }\n    }\n\n    /**\n     * @notice Check if the sale has ended\n     * @return hasEnded_ True if the sale has ended\n     */\n    function saleEnded() public view returns (bool hasEnded_) {\n        hasEnded_ =\n            (block.timestamp >= saleStart + saleDuration) ||\n            (totalTokenIn >= tokenInLimit);\n    }\n\n    /// ===============================\n    /// ===== Permissioned: owner =====\n    /// ===============================\n\n    /**\n     * @notice Finalize the sale after sale duration. Can only be called by owner\n       @dev Ensure contract has enough `tokenOut` before calling\n     */\n    function finalize() external onlyOwner {\n        require(!finalized, \"TokenSale: already finalized\");\n        require(saleEnded(), \"TokenSale: not finished\");\n        require(\n            tokenOut.balanceOf(address(this)) >= totalTokenOutBought,\n            \"TokenSale: not enough balance\"\n        );\n\n        finalized = true;\n\n        emit Finalized();\n    }\n\n    /**\n     * @notice Update the sale start time. Can only be called by owner\n     * @param _saleStart New start time\n     */\n    function setSaleStart(uint64 _saleStart) external onlyOwner {\n        require(\n            _saleStart >= block.timestamp,\n            \"TokenSale: start date may not be in the past\"\n        );\n        require(!finalized, \"TokenSale: already finalized\");\n\n        saleStart = _saleStart;\n\n        emit SaleStartUpdated(_saleStart);\n    }\n\n    /**\n     * @notice Update sale duration. Can only be called by owner\n     * @param _saleDuration New duration\n     */\n    function setSaleDuration(uint64 _saleDuration) external onlyOwner {\n        require(\n            _saleDuration > 0,\n            \"TokenSale: the sale duration must not be zero\"\n        );\n        require(!finalized, \"TokenSale: already finalized\");\n\n        saleDuration = _saleDuration;\n\n        emit SaleDurationUpdated(_saleDuration);\n    }\n\n    /**\n     * @notice Modify the tokenOut price in. Can only be called by owner\n     * @param _tokenOutPrice New tokenOut price\n     */\n    function setTokenOutPrice(uint256 _tokenOutPrice) external onlyOwner {\n        require(_tokenOutPrice > 0, \"TokenSale: the price must not be zero\");\n\n        tokenOutPrice = _tokenOutPrice;\n\n        emit TokenOutPriceUpdated(_tokenOutPrice);\n    }\n\n    /**\n     * @notice Update the `tokenIn` receipient address. Can only be called by owner\n     * @param _saleRecipient New recipient address\n     */\n    function setSaleRecipient(address _saleRecipient) external onlyOwner {\n        require(\n            _saleRecipient != address(0),\n            \"TokenSale: sale recipient should not be zero\"\n        );\n\n        saleRecipient = _saleRecipient;\n\n        emit SaleRecipientUpdated(_saleRecipient);\n    }\n\n    /**\n     * @notice Update the guestlist address. Can only be called by owner\n     * @param _guestlist New guestlist address\n     */\n    function setGuestlist(address _guestlist) external onlyOwner {\n        guestlist = BadgerGuestListAPI(_guestlist);\n\n        emit GuestlistUpdated(_guestlist);\n    }\n\n    /**\n     * @notice Modify the max tokenIn that this contract can take. Can only be called by owner\n     * @param _tokenInLimit New max amountIn\n     */\n    function setTokenInLimit(uint256 _tokenInLimit) external onlyOwner {\n        require(!finalized, \"TokenSale: already finalized\");\n\n        tokenInLimit = _tokenInLimit;\n\n        emit TokenInLimitUpdated(_tokenInLimit);\n    }\n\n    /**\n     * @notice Transfers out any tokens accidentally sent to the contract. Can only be called by owner\n     * @dev The contract transfers all `tokenIn` directly to `saleRecipient` during a sale so it's safe\n     *      to sweep `tokenIn`. For `tokenOut`, the function only sweeps the extra amount\n     *      (current contract balance - amount left to be claimed)\n     * @param _token The token to sweep\n     */\n    function sweep(address _token) external onlyOwner {\n        uint256 amount = ERC20Upgradeable(_token).balanceOf(address(this));\n\n        if (_token == address(tokenOut)) {\n            uint256 amountLeftToBeClaimed = totalTokenOutBought -\n                totalTokenOutClaimed;\n            amount -= amountLeftToBeClaimed;\n        }\n\n        require(amount > 0, \"nothing to sweep\");\n\n        ERC20Upgradeable(_token).safeTransfer(msg.sender, amount);\n\n        emit Sweeped(_token, amount);\n    }\n\n    /**\n     * @notice Pause the sale. Can only be called by owner\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the sale. Can only be called by owner\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n\n\n",
        "CodeNames": [
            "VipGuestListUpgradeable.sol",
            "TokenSaleUpgradeable.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "-02",
                "Location": [
                    "//solidity\n// TokenSaleUpgradeable.sol:53\nBadgerGuestListAPI public guestlist;\n",
                    "//solidity\n// TokenSaleUpgradeable.sol:76\nevent GuestlistUpdated(address indexed guestlist);\n"
                ],
                "Type": " Inconsistent naming conventions",
                "Description": "\nThe name of the variable guestlist (defined in TokenSaleUpgradeable.sol:53(https://github.com/code-423n4/2022-02-badger-citadel/blob/84596551d62f243d13fcb2d486346dde08002f7b/contracts/TokenSaleUpgradeable.sol#L53)) and the event GuestlistUpdated (defined in TokenSaleUpgradeable.sol:76(https://github.com/code-423n4/2022-02-badger-citadel/blob/84596551d62f243d13fcb2d486346dde08002f7b/contracts/TokenSaleUpgradeable.sol#L76)) should be changed to guestList and GuestListUpdated respectively in order to make them more readable and consistent with other parts of the code.\n\nsolidity\n// TokenSaleUpgradeable.sol:53\nBadgerGuestListAPI public guestlist;\n\n\nsolidity\n// TokenSaleUpgradeable.sol:76\nevent GuestlistUpdated(address indexed guestlist);\n\n\nGalloDaSballo (BadgerDao) commented(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/111#issuecomment-1031656506):\n  Appreciate the findings.\n \n Pretty sure ^ in a comment gives same level of clarity\n \n As for frontrun, I guess we could do that, but why?\n\n\n\n*\n\n# Gas Optimizations\n\nFor this contest, 22 reports were submitted by wardens detailing gas optimizations. The report highlighted below(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/112) by warden IllIllI received the top score from the judge.\n\n_The following wardens also submitted reports: Czar102(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/108), TomFrenchBlockchain(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/77), Dravee(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/80), WatchPug(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/56), 0x0x0x(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/32), peritoflores(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/73), hyh(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/110), pauliax(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/97), Ruhum(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/76), Jujic(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/3), rfa(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/79), gzeon(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/48), defsec(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/49), tqts(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/29), NoamYakov(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/35), robee(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/7), OriDabush(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/68), PostMan56(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/9), ych18(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/38), sabtikw(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/19), and throttle(https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/21)._\n\n\n",
                "Repair": ""
            }
        ]
    }
]