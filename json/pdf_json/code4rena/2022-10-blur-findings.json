[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Order, AssetType} from \"../lib/OrderStructs.sol\";\nimport {IMatchingPolicy} from \"../interfaces/IMatchingPolicy.sol\";\n\n/**\n * @title StandardPolicyERC1155\n * @dev Policy for matching orders at a fixed price for a specific ERC1155 tokenId\n */\ncontract StandardPolicyERC1155 is IMatchingPolicy {\n    function canMatchMakerAsk(Order calldata makerAsk, Order calldata takerBid)\n        external\n        pure\n        override\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            AssetType\n        )\n    {\n        return (\n            (makerAsk.side != takerBid.side) &&\n            (makerAsk.paymentToken == takerBid.paymentToken) &&\n            (makerAsk.collection == takerBid.collection) &&\n            (makerAsk.tokenId == takerBid.tokenId) &&\n            (makerAsk.matchingPolicy == takerBid.matchingPolicy) &&\n            (makerAsk.price == takerBid.price),\n            makerAsk.price,\n            makerAsk.tokenId,\n            1,\n            AssetType.ERC1155\n        );\n    }\n\n    function canMatchMakerBid(Order calldata makerBid, Order calldata takerAsk)\n        external\n        pure\n        override\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            AssetType\n        )\n    {\n        return (\n            (makerBid.side != takerAsk.side) &&\n            (makerBid.paymentToken == takerAsk.paymentToken) &&\n            (makerBid.collection == takerAsk.collection) &&\n            (makerBid.tokenId == takerAsk.tokenId) &&\n            (makerBid.matchingPolicy == takerAsk.matchingPolicy) &&\n            (makerBid.price == takerAsk.price),\n            makerBid.price,\n            makerBid.tokenId,\n            1,\n            AssetType.ERC1155\n        );\n    }\n}\n\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./lib/ReentrancyGuarded.sol\";\nimport \"./lib/EIP712.sol\";\nimport \"./lib/MerkleVerifier.sol\";\nimport \"./interfaces/IBlurExchange.sol\";\nimport \"./interfaces/IExecutionDelegate.sol\";\nimport \"./interfaces/IPolicyManager.sol\";\nimport \"./interfaces/IMatchingPolicy.sol\";\nimport {\n  Side,\n  SignatureVersion,\n  AssetType,\n  Fee,\n  Order,\n  Input\n} from \"./lib/OrderStructs.sol\";\n\n/**\n * @title BlurExchange\n * @dev Core Blur exchange contract\n */\ncontract BlurExchange is IBlurExchange, ReentrancyGuarded, EIP712, OwnableUpgradeable, UUPSUpgradeable {\n\n    /* Auth */\n    uint256 public isOpen;\n\n    modifier whenOpen() {\n        require(isOpen == 1, \"Closed\");\n        _;\n    }\n\n    event Opened();\n    event Closed();\n\n    function open() external onlyOwner {\n        isOpen = 1;\n        emit Opened();\n    }\n    function close() external onlyOwner {\n        isOpen = 0;\n        emit Closed();\n    }\n\n    // required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n\n    /* Constants */\n    string public constant name = \"Blur Exchange\";\n    string public constant version = \"1.0\";\n    uint256 public constant INVERSE_BASIS_POINT = 10000;\n\n\n    /* Variables */\n    address public weth;\n    IExecutionDelegate public executionDelegate;\n    IPolicyManager public policyManager;\n    address public oracle;\n    uint256 public blockRange;\n\n\n    /* Storage */\n    mapping(bytes32 => bool) public cancelledOrFilled;\n    mapping(address => uint256) public nonces;\n\n\n    /* Events */\n    event OrdersMatched(\n        address indexed maker,\n        address indexed taker,\n        Order sell,\n        bytes32 sellHash,\n        Order buy,\n        bytes32 buyHash\n    );\n\n    event OrderCancelled(bytes32 hash);\n    event NonceIncremented(address trader, uint256 newNonce);\n\n    event NewExecutionDelegate(IExecutionDelegate executionDelegate);\n    event NewPolicyManager(IPolicyManager policyManager);\n    event NewOracle(address oracle);\n    event NewBlockRange(uint256 blockRange);\n\n\n    /* Constructor (for ERC1967) */\n    function initialize(\n        uint chainId,\n        address _weth,\n        IExecutionDelegate _executionDelegate,\n        IPolicyManager _policyManager,\n        address _oracle,\n        uint _blockRange\n    ) public initializer {\n        __Ownable_init();\n        isOpen = 1;\n\n        DOMAIN_SEPARATOR = _hashDomain(EIP712Domain({\n            name              : name,\n            version           : version,\n            chainId           : chainId,\n            verifyingContract : address(this)\n        }));\n\n        weth = _weth;\n        executionDelegate = _executionDelegate;\n        policyManager = _policyManager;\n        oracle = _oracle;\n        blockRange = _blockRange;\n    }\n\n\n    /* External Functions */\n\n    /**\n     * @dev Match two orders, ensuring validity of the match, and execute all associated state transitions. Protected against reentrancy by a contract-global lock.\n     * @param sell Sell input\n     * @param buy Buy input\n     */\n    function execute(Input calldata sell, Input calldata buy)\n        external\n        payable\n        reentrancyGuard\n        whenOpen\n    {\n        require(sell.order.side == Side.Sell);\n\n        bytes32 sellHash = _hashOrder(sell.order, nonces[sell.order.trader]);\n        bytes32 buyHash = _hashOrder(buy.order, nonces[buy.order.trader]);\n\n        require(_validateOrderParameters(sell.order, sellHash), \"Sell has invalid parameters\");\n        require(_validateOrderParameters(buy.order, buyHash), \"Buy has invalid parameters\");\n\n        require(_validateSignatures(sell, sellHash), \"Sell failed authorization\");\n        require(_validateSignatures(buy, buyHash), \"Buy failed authorization\");\n\n        (uint256 price, uint256 tokenId, uint256 amount, AssetType assetType) = _canMatchOrders(sell.order, buy.order);\n\n        _executeFundsTransfer(\n            sell.order.trader,\n            buy.order.trader,\n            sell.order.paymentToken,\n            sell.order.fees,\n            price\n        );\n        _executeTokenTransfer(\n            sell.order.collection,\n            sell.order.trader,\n            buy.order.trader,\n            tokenId,\n            amount,\n            assetType\n        );\n\n        /* Mark orders as filled. */\n        cancelledOrFilled[sellHash] = true;\n        cancelledOrFilled[buyHash] = true;\n\n        emit OrdersMatched(\n            sell.order.listingTime <= buy.order.listingTime ? sell.order.trader : buy.order.trader,\n            sell.order.listingTime > buy.order.listingTime ? sell.order.trader : buy.order.trader,\n            sell.order,\n            sellHash,\n            buy.order,\n            buyHash\n        );\n    }\n\n    /**\n     * @dev Cancel an order, preventing it from being matched. Must be called by the trader of the order\n     * @param order Order to cancel\n     */\n    function cancelOrder(Order calldata order) public {\n        /* Assert sender is authorized to cancel order. */\n        require(msg.sender == order.trader);\n\n        bytes32 hash = _hashOrder(order, nonces[order.trader]);\n\n        if (!cancelledOrFilled[hash]) {\n            /* Mark order as cancelled, preventing it from being matched. */\n            cancelledOrFilled[hash] = true;\n            emit OrderCancelled(hash);\n        }\n    }\n\n    /**\n     * @dev Cancel multiple orders\n     * @param orders Orders to cancel\n     */\n    function cancelOrders(Order[] calldata orders) external {\n        for (uint8 i = 0; i < orders.length; i++) {\n            cancelOrder(orders[i]);\n        }\n    }\n\n    /**\n     * @dev Cancel all current orders for a user, preventing them from being matched. Must be called by the trader of the order\n     */\n    function incrementNonce() external {\n        nonces[msg.sender] += 1;\n        emit NonceIncremented(msg.sender, nonces[msg.sender]);\n    }\n\n\n    /* Setters */\n\n    function setExecutionDelegate(IExecutionDelegate _executionDelegate)\n        external\n        onlyOwner\n    {\n        require(address(_executionDelegate) != address(0), \"Address cannot be zero\");\n        executionDelegate = _executionDelegate;\n        emit NewExecutionDelegate(executionDelegate);\n    }\n\n    function setPolicyManager(IPolicyManager _policyManager)\n        external\n        onlyOwner\n    {\n        require(address(_policyManager) != address(0), \"Address cannot be zero\");\n        policyManager = _policyManager;\n        emit NewPolicyManager(policyManager);\n    }\n\n    function setOracle(address _oracle)\n        external\n        onlyOwner\n    {\n        require(_oracle != address(0), \"Address cannot be zero\");\n        oracle = _oracle;\n        emit NewOracle(oracle);\n    }\n\n    function setBlockRange(uint256 _blockRange)\n        external\n        onlyOwner\n    {\n        blockRange = _blockRange;\n        emit NewBlockRange(blockRange);\n    }\n\n\n    /* Internal Functions */\n\n    /**\n     * @dev Verify the validity of the order parameters\n     * @param order order\n     * @param orderHash hash of order\n     */\n    function _validateOrderParameters(Order calldata order, bytes32 orderHash)\n        internal\n        view\n        returns (bool)\n    {\n        return (\n            /* Order must have a trader. */\n            (order.trader != address(0)) &&\n            /* Order must not be cancelled or filled. */\n            (cancelledOrFilled[orderHash] == false) &&\n            /* Order must be settleable. */\n            _canSettleOrder(order.listingTime, order.expirationTime)\n        );\n    }\n\n    /**\n     * @dev Check if the order can be settled at the current timestamp\n     * @param listingTime order listing time\n     * @param expirationTime order expiration time\n     */\n    function _canSettleOrder(uint256 listingTime, uint256 expirationTime)\n        view\n        internal\n        returns (bool)\n    {\n        return (listingTime < block.timestamp) && (expirationTime == 0 || block.timestamp < expirationTime);\n    }\n\n    /**\n     * @dev Verify the validity of the signatures\n     * @param order order\n     * @param orderHash hash of order\n     */\n    function _validateSignatures(Input calldata order, bytes32 orderHash)\n        internal\n        view\n        returns (bool)\n    {\n\n        if (order.order.trader == msg.sender) {\n          return true;\n        }\n\n        /* Check user authorization. */\n        if (\n            !_validateUserAuthorization(\n                orderHash,\n                order.order.trader,\n                order.v,\n                order.r,\n                order.s,\n                order.signatureVersion,\n                order.extraSignature\n            )\n        ) {\n            return false;\n        }\n\n        if (order.order.expirationTime == 0) {\n            /* Check oracle authorization. */\n            require(block.number - order.blockNumber < blockRange, \"Signed block number out of range\");\n            if (\n                !_validateOracleAuthorization(\n                    orderHash,\n                    order.signatureVersion,\n                    order.extraSignature,\n                    order.blockNumber\n                )\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Verify the validity of the user signature\n     * @param orderHash hash of the order\n     * @param trader order trader who should be the signer\n     * @param v v\n     * @param r r\n     * @param s s\n     * @param signatureVersion signature version\n     * @param extraSignature packed merkle path\n     */\n    function _validateUserAuthorization(\n        bytes32 orderHash,\n        address trader,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        SignatureVersion signatureVersion,\n        bytes calldata extraSignature\n    ) internal view returns (bool) {\n        bytes32 hashToSign;\n        if (signatureVersion == SignatureVersion.Single) {\n            /* Single-listing authentication: Order signed by trader */\n            hashToSign = _hashToSign(orderHash);\n        } else if (signatureVersion == SignatureVersion.Bulk) {\n            /* Bulk-listing authentication: Merkle root of orders signed by trader */\n            (bytes32[] memory merklePath) = abi.decode(extraSignature, (bytes32[]));\n\n            bytes32 computedRoot = MerkleVerifier._computeRoot(orderHash, merklePath);\n            hashToSign = _hashToSignRoot(computedRoot);\n        }\n\n        return _recover(hashToSign, v, r, s) == trader;\n    }\n\n    /**\n     * @dev Verify the validity of oracle signature\n     * @param orderHash hash of the order\n     * @param signatureVersion signature version\n     * @param extraSignature packed oracle signature\n     * @param blockNumber block number used in oracle signature\n     */\n    function _validateOracleAuthorization(\n        bytes32 orderHash,\n        SignatureVersion signatureVersion,\n        bytes calldata extraSignature,\n        uint256 blockNumber\n    ) internal view returns (bool) {\n        bytes32 oracleHash = _hashToSignOracle(orderHash, blockNumber);\n\n        uint8 v; bytes32 r; bytes32 s;\n        if (signatureVersion == SignatureVersion.Single) {\n            (v, r, s) = abi.decode(extraSignature, (uint8, bytes32, bytes32));\n        } else if (signatureVersion == SignatureVersion.Bulk) {\n            /* If the signature was a bulk listing the merkle path musted be unpacked before the oracle signature. */\n            (bytes32[] memory merklePath, uint8 _v, bytes32 _r, bytes32 _s) = abi.decode(extraSignature, (bytes32[], uint8, bytes32, bytes32));\n            v = _v; r = _r; s = _s;\n        }\n\n        return _recover(oracleHash, v, r, s) == oracle;\n    }\n\n    /**\n     * @dev Wrapped ecrecover with safety check for v parameter\n     * @param v v\n     * @param r r\n     * @param s s\n     */\n    function _recover(\n        bytes32 digest,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        require(v == 27 || v == 28, \"Invalid v parameter\");\n        return ecrecover(digest, v, r, s);\n    }\n\n    /**\n     * @dev Call the matching policy to check orders can be matched and get execution parameters\n     * @param sell sell order\n     * @param buy buy order\n     */\n    function _canMatchOrders(Order calldata sell, Order calldata buy)\n        internal\n        view\n        returns (uint256 price, uint256 tokenId, uint256 amount, AssetType assetType)\n    {\n        bool canMatch;\n        if (sell.listingTime <= buy.listingTime) {\n            /* Seller is maker. */\n            require(policyManager.isPolicyWhitelisted(sell.matchingPolicy), \"Policy is not whitelisted\");\n            (canMatch, price, tokenId, amount, assetType) = IMatchingPolicy(sell.matchingPolicy).canMatchMakerAsk(sell, buy);\n        } else {\n            /* Buyer is maker. */\n            require(policyManager.isPolicyWhitelisted(buy.matchingPolicy), \"Policy is not whitelisted\");\n            (canMatch, price, tokenId, amount, assetType) = IMatchingPolicy(buy.matchingPolicy).canMatchMakerBid(buy, sell);\n        }\n        require(canMatch, \"Orders cannot be matched\");\n\n        return (price, tokenId, amount, assetType);\n    }\n\n    /**\n     * @dev Execute all ERC20 token / ETH transfers associated with an order match (fees and buyer => seller transfer)\n     * @param seller seller\n     * @param buyer buyer\n     * @param paymentToken payment token\n     * @param fees fees\n     * @param price price\n     */\n    function _executeFundsTransfer(\n        address seller,\n        address buyer,\n        address paymentToken,\n        Fee[] calldata fees,\n        uint256 price\n    ) internal {\n        if (paymentToken == address(0)) {\n            require(msg.value == price);\n        }\n\n        /* Take fee. */\n        uint256 receiveAmount = _transferFees(fees, paymentToken, buyer, price);\n\n        /* Transfer remainder to seller. */\n        _transferTo(paymentToken, buyer, seller, receiveAmount);\n    }\n\n    /**\n     * @dev Charge a fee in ETH or WETH\n     * @param fees fees to distribute\n     * @param paymentToken address of token to pay in\n     * @param from address to charge fees\n     * @param price price of token\n     */\n    function _transferFees(\n        Fee[] calldata fees,\n        address paymentToken,\n        address from,\n        uint256 price\n    ) internal returns (uint256) {\n        uint256 totalFee = 0;\n        for (uint8 i = 0; i < fees.length; i++) {\n            uint256 fee = (price * fees[i].rate) / INVERSE_BASIS_POINT;\n            _transferTo(paymentToken, from, fees[i].recipient, fee);\n            totalFee += fee;\n        }\n\n        require(totalFee <= price, \"Total amount of fees are more than the price\");\n\n        /* Amount that will be received by seller. */\n        uint256 receiveAmount = price - totalFee;\n        return (receiveAmount);\n    }\n\n    /**\n     * @dev Transfer amount in ETH or WETH\n     * @param paymentToken address of token to pay in\n     * @param from token sender\n     * @param to token recipient\n     * @param amount amount to transfer\n     */\n    function _transferTo(\n        address paymentToken,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (paymentToken == address(0)) {\n            /* Transfer funds in ETH. */\n            payable(to).transfer(amount);\n        } else if (paymentToken == weth) {\n            /* Transfer funds in WETH. */\n            executionDelegate.transferERC20(weth, from, to, amount);\n        } else {\n            revert(\"Invalid payment token\");\n        }\n    }\n\n    /**\n     * @dev Execute call through delegate proxy\n     * @param collection collection contract address\n     * @param from seller address\n     * @param to buyer address\n     * @param tokenId tokenId\n     * @param assetType asset type of the token\n     */\n    function _executeTokenTransfer(\n        address collection,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        AssetType assetType\n    ) internal {\n        /* Assert collection exists. */\n        require(_exists(collection), \"Collection does not exist\");\n\n        /* Call execution delegate. */\n        if (assetType == AssetType.ERC721) {\n            executionDelegate.transferERC721(collection, from, to, tokenId);\n        } else if (assetType == AssetType.ERC1155) {\n            executionDelegate.transferERC1155(collection, from, to, tokenId, amount);\n        }\n    }\n\n    /**\n     * @dev Determine if the given address exists\n     * @param what address to check\n     */\n    function _exists(address what)\n        internal\n        view\n        returns (bool)\n    {\n        uint size;\n        assembly {\n            size := extcodesize(what)\n        }\n        return size > 0;\n    }\n}\n\n\n",
        "CodeNames": [
            "StandardPolicyERC1155.sol",
            "BlurExchange.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n    function canMatchMakerAsk(Order calldata makerAsk, Order calldata takerBid)\n        external\n        pure\n        override\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            AssetType\n        )\n    {\n        return (\n            (makerAsk.side != takerBid.side) &&\n            (makerAsk.paymentToken == takerBid.paymentToken) &&\n            (makerAsk.collection == takerBid.collection) &&\n            (makerAsk.tokenId == takerBid.tokenId) &&\n            (makerAsk.matchingPolicy == takerBid.matchingPolicy) &&\n            (makerAsk.price == takerBid.price),\n            makerAsk.price,\n            makerAsk.tokenId,\n            1,\n            AssetType.ERC1155\n        );\n    }\n",
                    "typescript\n    it('Only 1 ERC1155 received for order with amount  1', async () = {\n      await mockERC1155.mint(alice.address, tokenId, 10);\n      sell = generateOrder(alice, {\n        side: Side.Sell,\n        tokenId,\n        amount: 10,\n        collection: mockERC1155.address,\n        matchingPolicy: matchingPolicies.standardPolicyERC1155.address,\n      });\n      buy = generateOrder(bob, {\n        side: Side.Buy,\n        tokenId,\n        amount: 10,\n        collection: mockERC1155.address,\n        matchingPolicy: matchingPolicies.standardPolicyERC1155.address,\n      });\n      sellInput = await sell.pack();\n      buyInput = await buy.pack();\n\n      await waitForTx(exchange.execute(sellInput, buyInput));\n\n      // Buyer only receives 1 token\n      expect(await mockERC1155.balanceOf(bob.address, tokenId)).to.be.equal(1);\n      await checkBalances(\n        aliceBalance,\n        aliceBalanceWeth.add(priceMinusFee),\n        bobBalance,\n        bobBalanceWeth.sub(price),\n        feeRecipientBalance,\n        feeRecipientBalanceWeth.add(fee),\n      );\n    });\n"
                ],
                "Type": "  StandardPolicyERC1155.sol  returns  amount == 1  instead of  amount == order.amount ",
                "Description": "*Submitted by dipp, also found by 0x4non, 0x52, 0xc0ffEE, 0xRobocop, 8olidity, arcoun, aviggiano, bardamu, Ch_301, cryptonue, csanuragjain, d3e4, enckrish, exd0tpy, hansfriese, jayphbee, Jeiwan, joestakey, Junnon, KIntern_NA, ladboy233, Lambda, M4TZ1P, MiloTruck, minhquanym, minhtrng, nicobevi, Nyx, obront, PaludoX0, polymorphism, rokinot, romand, rotcivegaf, Ruhum, RustyRabbit, rvierdiiev, saian, serial-coder, Soosh, TomJ, Trust, trustindistrust, and zzykxx*\n\nStandardPolicyERC1155.sol#L12-L36(https://github.com/code-423n4/2022-10-blur/blob/main/contracts/matchingPolicies/StandardPolicyERC1155.sol#L12-L36)<br\nBlurExchange.sol#L154-L161(https://github.com/code-423n4/2022-10-blur/blob/main/contracts/BlurExchange.sol#L154-L161)<br\n\nThe canMatchMakerAsk and canMatchMakerBid functions in StandardPolicyERC1155.sol will only return 1 as the amount instead of the order.amount value. This value is then used in the _executeTokenTransfer call during the execution flow and leads to only 1 ERC1155 token being sent. A buyer matching an ERC1155 order wih amount  1 would expect to receive amount of tokens if they pay the order's price. The seller, who might also expect more than 1 tokens to be sent, would have set the order's price to be for the amount of tokens and not just for 1 token.\n\nThe buyer would lose overspent ETH/WETH to the seller without receiving all tokens as specified in the order.\n\n\nStandardPolicyERC1155.sol:canMatchMakerAsk(https://github.com/code-423n4/2022-10-blur/blob/main/contracts/matchingPolicies/StandardPolicyERC1155.sol#L12-L36)\n\nsolidity\n    function canMatchMakerAsk(Order calldata makerAsk, Order calldata takerBid)\n        external\n        pure\n        override\n        returns (\n            bool,\n            uint256,\n            uint256,\n            uint256,\n            AssetType\n        )\n    {\n        return (\n            (makerAsk.side != takerBid.side) &&\n            (makerAsk.paymentToken == takerBid.paymentToken) &&\n            (makerAsk.collection == takerBid.collection) &&\n            (makerAsk.tokenId == takerBid.tokenId) &&\n            (makerAsk.matchingPolicy == takerBid.matchingPolicy) &&\n            (makerAsk.price == takerBid.price),\n            makerAsk.price,\n            makerAsk.tokenId,\n            1,\n            AssetType.ERC1155\n        );\n    }\n\n\nThe code above shows that canMatchMakerAsk only returns 1 as the amount. _executeTokenTransfer will then call the executionDelegate's transferERC1155 function with only amount 1(https://github.com/code-423n4/2022-10-blur/blob/main/contracts/BlurExchange.sol#L540), transferring only 1 token to the buyer.\n\nTest code added to execution.test.ts:\n\ntypescript\n    it('Only 1 ERC1155 received for order with amount  1', async () = {\n      await mockERC1155.mint(alice.address, tokenId, 10);\n      sell = generateOrder(alice, {\n        side: Side.Sell,\n        tokenId,\n        amount: 10,\n        collection: mockERC1155.address,\n        matchingPolicy: matchingPolicies.standardPolicyERC1155.address,\n      });\n      buy = generateOrder(bob, {\n        side: Side.Buy,\n        tokenId,\n        amount: 10,\n        collection: mockERC1155.address,\n        matchingPolicy: matchingPolicies.standardPolicyERC1155.address,\n      });\n      sellInput = await sell.pack();\n      buyInput = await buy.pack();\n\n      await waitForTx(exchange.execute(sellInput, buyInput));\n\n      // Buyer only receives 1 token\n      expect(await mockERC1155.balanceOf(bob.address, tokenId)).to.be.equal(1);\n      await checkBalances(\n        aliceBalance,\n        aliceBalanceWeth.add(priceMinusFee),\n        bobBalance,\n        bobBalanceWeth.sub(price),\n        feeRecipientBalance,\n        feeRecipientBalanceWeth.add(fee),\n      );\n    });\n\n\nThe test code above shows a sell order for an ERC1155 token with amount = 10 and a matching buy order. The execute function in BlurExchange.sol is called and the orders are matched but the buyer (bob) only receives 1 token instead of 10 despite paying the full price.\n\n",
                "Repair": "\nPolicies used for ERC1155 tokens should return and consider the amount of tokens set for the order.\n\nblur-io-toad (Blur) acknowledged and commented(https://github.com/code-423n4/2022-10-blur-findings/issues/666#issuecomment-1280075358):\n  This was an oversight on my part for not putting this contract as out-of-scope. Our marketplace does not handle ERC1155 yet and so we haven't concluded what the matching critieria for those orders will be. This contract was mainly created to test ERC1155 transfers through the rest of the exchange, but shouldn't be deployed initially. When we are prepared to handle ERC1155 orders we will have to develop a new matching policy that determines the amount from the order parameters. Acknowledging that it's incorrect, but won't be making any changes as the contract won't be deployed.\n\nAlex the Entreprenerd (Judge) commented(https://github.com/code-423n4/2022-10-blur-findings/issues/666#issuecomment-1292778487):\n  The sponsor acknowledges the finding, and the report to be technically correct.<br\n However the sponsor claims they won't be using the code in production.<br\n\n  Because the code is technically incorrect and was in scope during the contest am going to assign High Severity.<br\n However, I do understand that the contract will not be deployed.\n\nAlex the Entreprenerd (Judge) commented(https://github.com/code-423n4/2022-10-blur-findings/issues/666#issuecomment-1306047646):\n  Despite the fact that some reports mention a slightly different risk than this one (mismatching amounts), given https://github.com/code-423n4/org/issues/8 and given the consideration that these are substantially the same issue (the policy has a hardcoded amount), am going to group them under the same issue.\n \n Because this report shows both sides of the issue, is well-written and has a coded Poc, am choosing to make it the selected report.\n\n\n\n*\n\n\n"
            }
        ]
    }
]