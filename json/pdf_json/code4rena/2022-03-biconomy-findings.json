[
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/IExecutorManager.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./interfaces/ITokenManager.sol\";\n\ncontract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {\n    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy\n\n    uint256 public baseGas;\n\n    IExecutorManager private executorManager;\n    ITokenManager public tokenManager;\n    ILiquidityProviders public liquidityProviders;\n\n    struct PermitRequest {\n        uint256 nonce;\n        uint256 expiry;\n        bool allowed;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    mapping(bytes32 => bool) public processedHash;\n    mapping(address => uint256) public gasFeeAccumulatedByToken;\n\n    // Gas fee accumulated by token address => executor address\n    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;\n\n    // Incentive Pool amount per token address\n    mapping(address => uint256) public incentivePool;\n\n    event AssetSent(\n        address indexed asset,\n        uint256 indexed amount,\n        uint256 indexed transferredAmount,\n        address target,\n        bytes depositHash,\n        uint256 fromChainId\n    );\n    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);\n    event Received(address indexed from, uint256 indexed amount);\n    event Deposit(\n        address indexed from,\n        address indexed tokenAddress,\n        address indexed receiver,\n        uint256 toChainId,\n        uint256 amount,\n        uint256 reward,\n        string tag\n    );\n    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);\n    event TrustedForwarderChanged(address indexed forwarderAddress);\n    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);\n    event EthReceived(address, uint256);\n\n    // MODIFIERS\n    modifier onlyExecutor() {\n        require(executorManager.getExecutorStatus(_msgSender()), \"Only executor is allowed\");\n        _;\n    }\n\n    modifier onlyLiquidityProviders() {\n        require(_msgSender() == address(liquidityProviders), \"Only liquidityProviders is allowed\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, \"Token not supported\");\n        _;\n    }\n\n    function initialize(\n        address _executorManagerAddress,\n        address _pauser,\n        address _trustedForwarder,\n        address _tokenManager,\n        address _liquidityProviders\n    ) public initializer {\n        require(_executorManagerAddress != address(0), \"ExecutorManager cannot be 0x0\");\n        require(_trustedForwarder != address(0), \"TrustedForwarder cannot be 0x0\");\n        require(_liquidityProviders != address(0), \"LiquidityProviders cannot be 0x0\");\n        __ERC2771Context_init(_trustedForwarder);\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        executorManager = IExecutorManager(_executorManagerAddress);\n        tokenManager = ITokenManager(_tokenManager);\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n        baseGas = 21000;\n    }\n\n    function setTrustedForwarder(address trustedForwarder) public onlyOwner {\n        require(trustedForwarder != address(0), \"TrustedForwarder can't be 0\");\n        _trustedForwarder = trustedForwarder;\n        emit TrustedForwarderChanged(trustedForwarder);\n    }\n\n    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {\n        require(_liquidityProviders != address(0), \"LiquidityProviders can't be 0\");\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n        emit LiquidityProvidersChanged(_liquidityProviders);\n    }\n\n    function setBaseGas(uint128 gas) external onlyOwner {\n        baseGas = gas;\n    }\n\n    function getExecutorManager() public view returns (address) {\n        return address(executorManager);\n    }\n\n    function setExecutorManager(address _executorManagerAddress) external onlyOwner {\n        require(_executorManagerAddress != address(0), \"Executor Manager cannot be 0\");\n        executorManager = IExecutorManager(_executorManagerAddress);\n    }\n\n    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {\n        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);\n        \n        currentLiquidity =\n            liquidityPoolBalance -\n            liquidityProviders.totalLPFees(tokenAddress) -\n            gasFeeAccumulatedByToken[tokenAddress] -\n            incentivePool[tokenAddress];\n    }\n\n    /**\n     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.\n     * @param toChainId Chain id where funds needs to be transfered\n     * @param tokenAddress ERC20 Token address that needs to be transfered\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param amount Amount of token being transfered\n     */\n    function depositErc20(\n        uint256 toChainId,\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        string memory tag\n    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {\n        require(\n            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&\n                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,\n            \"Deposit amount not in Cap limit\"\n        );\n        require(receiver != address(0), \"Receiver address cannot be 0\");\n        require(amount != 0, \"Amount cannot be 0\");\n        address sender = _msgSender();\n\n        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);\n        if (rewardAmount != 0) {\n            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;\n        }\n        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);\n        // Emit (amount + reward amount) in event\n        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);\n    }\n\n    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {\n        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);\n        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);\n        if (currentLiquidity < providedLiquidity) {\n            uint256 liquidityDifference = providedLiquidity - currentLiquidity;\n            if (amount >= liquidityDifference) {\n                rewardAmount = incentivePool[tokenAddress];\n            } else {\n                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference\n                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;\n                rewardAmount = rewardAmount / 10000000000;\n            }\n        }\n    }\n\n    /**\n     * DAI permit and Deposit.\n     */\n    function permitAndDepositErc20(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        uint256 toChainId,\n        PermitRequest calldata permitOptions,\n        string memory tag\n    ) external {\n        IERC20Permit(tokenAddress).permit(\n            _msgSender(),\n            address(this),\n            permitOptions.nonce,\n            permitOptions.expiry,\n            permitOptions.allowed,\n            permitOptions.v,\n            permitOptions.r,\n            permitOptions.s\n        );\n        depositErc20(toChainId, tokenAddress, receiver, amount, tag);\n    }\n\n    /**\n     * EIP2612 and Deposit.\n     */\n    function permitEIP2612AndDepositErc20(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        uint256 toChainId,\n        PermitRequest calldata permitOptions,\n        string memory tag\n    ) external {\n        IERC20Permit(tokenAddress).permit(\n            _msgSender(),\n            address(this),\n            amount,\n            permitOptions.expiry,\n            permitOptions.v,\n            permitOptions.r,\n            permitOptions.s\n        );\n        depositErc20(toChainId, tokenAddress, receiver, amount, tag);\n    }\n\n    /**\n     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param toChainId Chain id where funds needs to be transfered\n     */\n    function depositNative(\n        address receiver,\n        uint256 toChainId,\n        string memory tag\n    ) external payable whenNotPaused nonReentrant {\n        require(\n            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&\n                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,\n            \"Deposit amount not in Cap limit\"\n        );\n        require(receiver != address(0), \"Receiver address cannot be 0\");\n        require(msg.value != 0, \"Amount cannot be 0\");\n\n        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);\n        if (rewardAmount != 0) {\n            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;\n        }\n        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);\n        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);\n    }\n\n    function sendFundsToUser(\n        address tokenAddress,\n        uint256 amount,\n        address payable receiver,\n        bytes memory depositHash,\n        uint256 tokenGasPrice,\n        uint256 fromChainId\n    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {\n        uint256 initialGas = gasleft();\n        require(\n            tokenManager.getTransferConfig(tokenAddress).min <= amount &&\n                tokenManager.getTransferConfig(tokenAddress).max >= amount,\n            \"Withdraw amnt not in Cap limits\"\n        );\n        require(receiver != address(0), \"Bad receiver address\");\n\n        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);\n\n        require(!status, \"Already Processed\");\n        processedHash[hashSendTransaction] = true;\n\n        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);\n        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);\n\n        if (tokenAddress == NATIVE) {\n            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");\n            (bool success, ) = receiver.call{value: amountToTransfer}(\"\");\n            require(success, \"Native Transfer Failed\");\n        } else {\n            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");\n            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);\n        }\n\n        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);\n    }\n\n    /**\n     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.\n     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.\n     * @param initialGas Gas provided initially before any calculations began\n     * @param tokenAddress Token address for which calculation needs to be done\n     * @param amount Amount of token to be transfered before deducting the fee\n     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee\n     * @return amountToTransfer Total amount to be transfered after deducting all fees.\n     */\n    function getAmountToTransfer(\n        uint256 initialGas,\n        address tokenAddress,\n        uint256 amount,\n        uint256 tokenGasPrice\n    ) internal returns (uint256 amountToTransfer) {\n        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);\n        uint256 lpFee;\n        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {\n            // Here add some fee to incentive pool also\n            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;\n            incentivePool[tokenAddress] =\n                (incentivePool[tokenAddress] +\n                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /\n                BASE_DIVISOR;\n        } else {\n            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n        }\n        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n\n        liquidityProviders.addLPFee(tokenAddress, lpFee);\n\n        uint256 totalGasUsed = initialGas - gasleft();\n        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;\n        totalGasUsed = totalGasUsed + baseGas;\n\n        uint256 gasFee = totalGasUsed * tokenGasPrice;\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;\n        amountToTransfer = amount - (transferFeeAmount + gasFee);\n\n        emit FeeDetails(lpFee, transferFeeAmount, gasFee);\n    }\n\n    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {\n        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);\n        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);\n\n        uint256 resultingLiquidity = currentLiquidity - amount;\n\n        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;\n        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;\n        // Fee is represented in basis points * 10 for better accuracy\n        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; // F(max) * F(e) * L(e)\n        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; // F(e) * L(e) + (F(max) - F(e)) * L(r)\n\n        if (denominator == 0) {\n            fee = 0;\n        } else {\n            fee = numerator / denominator;\n        }\n    }\n\n    function checkHashStatus(\n        address tokenAddress,\n        uint256 amount,\n        address payable receiver,\n        bytes memory depositHash\n    ) public view returns (bytes32 hashSendTransaction, bool status) {\n        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));\n\n        status = processedHash[hashSendTransaction];\n    }\n\n    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {\n        require(tokenAddress != NATIVE, \"Can't withdraw native token fee\");\n        // uint256 gasFeeAccumulated = gasFeeAccumulatedByToken[tokenAddress];\n        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];\n        require(_gasFeeAccumulated != 0, \"Gas Fee earned is 0\");\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;\n        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);\n        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);\n    }\n\n    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {\n        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];\n        require(_gasFeeAccumulated != 0, \"Gas Fee earned is 0\");\n        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;\n        gasFeeAccumulated[NATIVE][_msgSender()] = 0;\n        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}(\"\");\n        require(success, \"Native Transfer Failed\");\n\n        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);\n    }\n\n    function transfer(\n        address _tokenAddress,\n        address receiver,\n        uint256 _tokenAmount\n    ) external whenNotPaused onlyLiquidityProviders nonReentrant {\n        require(receiver != address(0), \"Invalid receiver\");\n        if (_tokenAddress == NATIVE) {\n            require(address(this).balance >= _tokenAmount, \"ERR__INSUFFICIENT_BALANCE\");\n            (bool success, ) = receiver.call{value: _tokenAmount}(\"\");\n            require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        } else {\n            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);\n            require(baseToken.balanceOf(address(this)) >= _tokenAmount, \"ERR__INSUFFICIENT_BALANCE\");\n            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);\n        }\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit EthReceived(_msgSender(), msg.value);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/ILPToken.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\n\ncontract HyphenLiquidityFarming is\n    Initializable,\n    ERC2771ContextUpgradeable,\n    OwnableUpgradeable,\n    Pausable,\n    ReentrancyGuardUpgradeable,\n    IERC721ReceiverUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    ILPToken public lpToken;\n    ILiquidityProviders public liquidityProviders;\n\n    struct NFTInfo {\n        address payable staker;\n        uint256 rewardDebt;\n        uint256 unpaidRewards;\n        bool isStaked;\n    }\n\n    struct PoolInfo {\n        uint256 accTokenPerShare;\n        uint256 lastRewardTime;\n    }\n\n    struct RewardsPerSecondEntry {\n        uint256 rewardsPerSecond;\n        uint256 timestamp;\n    }\n\n    /// @notice Mapping to track the rewarder pool.\n    mapping(address => PoolInfo) public poolInfo;\n\n    /// @notice Info of each NFT that is staked.\n    mapping(uint256 => NFTInfo) public nftInfo;\n\n    /// @notice Reward rate per base token\n    //mapping(address => uint256) public rewardPerSecond;\n\n    /// @notice Reward Token\n    mapping(address => address) public rewardTokens;\n\n    /// @notice Staker => NFTs staked\n    mapping(address => uint256[]) public nftIdsStaked;\n\n    /// @notice Token => Total Shares Staked\n    mapping(address => uint256) public totalSharesStaked;\n\n    /// @notice Token => Reward Rate Updation history\n    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;\n\n    uint256 private constant ACC_TOKEN_PRECISION = 1e12;\n    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);\n    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);\n    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);\n    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);\n    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);\n    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);\n    event LogNativeReceived(address indexed sender, uint256 value);\n\n    function initialize(\n        address _trustedForwarder,\n        address _pauser,\n        ILiquidityProviders _liquidityProviders,\n        ILPToken _lpToken\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        __ReentrancyGuard_init();\n        liquidityProviders = _liquidityProviders;\n        lpToken = _lpToken;\n    }\n\n    /// @notice Initialize the rewarder pool.\n    /// @param _baseToken Base token to be used for the rewarder pool.\n    /// @param _rewardToken Reward token to be used for the rewarder pool.\n    /// @param _rewardPerSecond Reward rate per base token.\n    function initalizeRewardPool(\n        address _baseToken,\n        address _rewardToken,\n        uint256 _rewardPerSecond\n    ) external onlyOwner {\n        require(rewardTokens[_baseToken] == address(0), \"ERR__POOL_ALREADY_INITIALIZED\");\n        require(_baseToken != address(0), \"ERR__BASE_TOKEN_IS_ZERO\");\n        require(_rewardToken != address(0), \"ERR_REWARD_TOKEN_IS_ZERO\");\n        rewardTokens[_baseToken] = _rewardToken;\n        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));\n        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);\n    }\n\n    function _sendErc20AndGetSentAmount(\n        IERC20Upgradeable _token,\n        uint256 _amount,\n        address _to\n    ) private returns (uint256) {\n        uint256 recepientBalance = _token.balanceOf(_to);\n        _token.safeTransfer(_to, _amount);\n        return _token.balanceOf(_to) - recepientBalance;\n    }\n\n    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.\n    /// @param _nftId NFT ID that is being locked\n    /// @param _to Address to which rewards will be credited.\n    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {\n        NFTInfo storage nft = nftInfo[_nftId];\n        require(nft.isStaked, \"ERR__NFT_NOT_STAKED\");\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        PoolInfo memory pool = updatePool(baseToken);\n        uint256 pending;\n        uint256 amountSent;\n        if (amount > 0) {\n            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;\n            if (rewardTokens[baseToken] == NATIVE) {\n                uint256 balance = address(this).balance;\n                if (pending > balance) {\n                    unchecked {\n                        nft.unpaidRewards = pending - balance;\n                    }\n                    (bool success, ) = _to.call{value: balance}(\"\");\n                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                    amountSent = balance;\n                } else {\n                    nft.unpaidRewards = 0;\n                    (bool success, ) = _to.call{value: pending}(\"\");\n                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                    amountSent = pending;\n                }\n            } else {\n                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);\n                uint256 balance = rewardToken.balanceOf(address(this));\n                if (pending > balance) {\n                    unchecked {\n                        nft.unpaidRewards = pending - balance;\n                    }\n                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);\n                } else {\n                    nft.unpaidRewards = 0;\n                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);\n                }\n            }\n        }\n        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);\n    }\n\n    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.\n    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {\n        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));\n        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);\n    }\n\n    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract\n    /// @param _token Token to reclaim, use 0x00 for Ethereum\n    /// @param _amount Amount of tokens to reclaim\n    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,\n    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,\n    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.\n    function reclaimTokens(\n        address _token,\n        uint256 _amount,\n        address payable _to\n    ) external nonReentrant onlyOwner {\n        require(_to != address(0), \"ERR__TO_IS_ZERO\");\n        if (_token == NATIVE) {\n            (bool success, ) = payable(_to).call{value: _amount}(\"\");\n            require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        } else {\n            IERC20Upgradeable(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    /// @notice Deposit LP tokens\n    /// @param _nftId LP token nftId to deposit.\n    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        address msgSender = _msgSender();\n\n        require(\n            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),\n            \"ERR__NOT_APPROVED\"\n        );\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        require(rewardTokens[baseToken] != address(0), \"ERR__POOL_NOT_INITIALIZED\");\n        require(rewardRateLog[baseToken].length != 0, \"ERR__POOL_NOT_INITIALIZED\");\n\n        NFTInfo storage nft = nftInfo[_nftId];\n        require(!nft.isStaked, \"ERR__NFT_ALREADY_STAKED\");\n\n        lpToken.safeTransferFrom(msgSender, address(this), _nftId);\n\n        PoolInfo memory pool = updatePool(baseToken);\n        nft.isStaked = true;\n        nft.staker = _to;\n        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n\n        nftIdsStaked[_to].push(_nftId);\n        totalSharesStaked[baseToken] += amount;\n\n        emit LogDeposit(msgSender, baseToken, _nftId);\n    }\n\n    /// @notice Withdraw LP tokens\n    /// @param _nftId LP token nftId to withdraw.\n    /// @param _to The receiver of `amount` withdraw benefit.\n    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        address msgSender = _msgSender();\n        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;\n        uint256 index;\n        for (index = 0; index < nftsStakedLength; ++index) {\n            if (nftIdsStaked[msgSender][index] == _nftId) {\n                break;\n            }\n        }\n\n        require(index != nftsStakedLength, \"ERR__NFT_NOT_STAKED\");\n        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];\n        nftIdsStaked[msgSender].pop();\n\n        _sendRewardsForNft(_nftId, _to);\n        delete nftInfo[_nftId];\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n        totalSharesStaked[baseToken] -= amount;\n\n        lpToken.safeTransferFrom(address(this), msgSender, _nftId);\n\n        emit LogWithdraw(msgSender, baseToken, _nftId, _to);\n    }\n\n    /// @notice Extract all rewards without withdrawing LP tokens\n    /// @param _nftId LP token nftId for which rewards are to be withdrawn\n    /// @param _to The receiver of withdraw benefit.\n    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        require(nftInfo[_nftId].staker == _msgSender(), \"ERR__NOT_OWNER\");\n        _sendRewardsForNft(_nftId, _to);\n    }\n\n    /// @notice Calculates an up to date value of accTokenPerShare\n    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted\n    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {\n        uint256 accumulator = 0;\n        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;\n        uint256 counter = block.timestamp;\n        uint256 i = rewardRateLog[_baseToken].length - 1;\n        while (true) {\n            if (lastUpdatedTime >= counter) {\n                break;\n            }\n            unchecked {\n                accumulator +=\n                    rewardRateLog[_baseToken][i].rewardsPerSecond *\n                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));\n            }\n            counter = rewardRateLog[_baseToken][i].timestamp;\n            if (i == 0) {\n                break;\n            }\n            --i;\n        }\n\n        // We know that during all the periods that were included in the current iterations,\n        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the\n        // updates to the pool that happened after the lastUpdatedTime.\n        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];\n        return accumulator + poolInfo[_baseToken].accTokenPerShare;\n    }\n\n    /// @notice View function to see pending Token\n    /// @param _nftId NFT for which pending tokens are to be viewed\n    /// @return pending reward for a given user.\n    function pendingToken(uint256 _nftId) external view returns (uint256) {\n        NFTInfo storage nft = nftInfo[_nftId];\n        if (!nft.isStaked) {\n            return 0;\n        }\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        PoolInfo memory pool = poolInfo[baseToken];\n        uint256 accToken1PerShare = pool.accTokenPerShare;\n        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {\n            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);\n        }\n        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @return pool Returns the pool that was updated.\n    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {\n        pool = poolInfo[_baseToken];\n        if (block.timestamp > pool.lastRewardTime) {\n            if (totalSharesStaked[_baseToken] > 0) {\n                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);\n            }\n            pool.lastRewardTime = block.timestamp;\n            poolInfo[_baseToken] = pool;\n            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);\n        }\n    }\n\n    /// @notice View function to see the tokens staked by a given user.\n    /// @param _user Address of user.\n    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {\n        nftIds = nftIdsStaked[_user];\n    }\n\n    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {\n        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit LogNativeReceived(_msgSender(), msg.value);\n    }\n\n    function max(uint256 _a, uint256 _b) private pure returns (uint256) {\n        return _a >= _b ? _a : _b;\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidityPool.sol",
            "LiquidityFarming.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "Deposit",
                    "SafeERC",
                    "depositErc",
                    "depositNative",
                    "NATIVE =",
                    "amount"
                ],
                "Type": " Can deposit native token for free and steal funds",
                "Description": "\nLiquidityPool.sol#L151(https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L151)<br\n\nThe depositErc20 function allows setting tokenAddress = NATIVE and does not throw an error.<br\nNo matter the amount chosen, the SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount); call will not revert because it performs a low-level call to NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, which is an EOA, and the low-level calls to EOAs always succeed.<br\nBecause the safe* version is used, the EOA not returning any data does not revert either.<br\n\nThis allows an attacker to deposit infinite native tokens by not paying anything.<br\nThe contract will emit the same Deposit event as a real depositNative call and the attacker receives the native funds on the other chain.\n\n",
                "Repair": "\nCheck tokenAddress != NATIVE in depositErc20.\n\nankurdubey521 (Biconomy) confirmed and commented(https://github.com/code-423n4/2022-03-biconomy-findings/issues/55):\n  HP-25: C4 Audit Fixes, Dynamic Fee Changes bcnmy/hyphen-contract#42(https://github.com/bcnmy/hyphen-contract/pull/42)\n\npauliax (judge) commented(https://github.com/code-423n4/2022-03-biconomy-findings/issues/55#issuecomment-1094973634):\n  Great find, definitely deserves a severity of high.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [
                    "getAmountToTransfer",
                    "tokenAddress",
                    "BASE_DIVISOR",
                    "incentivePool",
                    "incentivePool[tokenAddress]"
                ],
                "Type": " Wrong formula when add fee  incentivePool  can lead to loss of funds.",
                "Description": "\nLiquidityPool.sol#L319-L322(https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L319-L322)<br\n\nThe getAmountToTransfer function of LiquidityPool updates incentivePool[tokenAddress] by adding some fee to it but the formula is wrong and the value of incentivePool[tokenAddress] will be divided by BASE_DIVISOR (10000000000) each time.\nAfter just a few time, the value of incentivePool[tokenAddress] will become zero and that amount of tokenAddress token will be locked in contract.\n\n\nLine 319-322\n\n    incentivePool[tokenAddress] = (incentivePool[tokenAddress] + (amount * (transferFeePerc tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) / BASE_DIVISOR;\n\nLet x = incentivePool[tokenAddress], y = amount, z = transferFeePerc and t = tokenManager.getTokensInfo(tokenAddress).equilibriumFee. Then that be written as\n\n    x = (x + (y * (z t))) / BASE_DIVISOR;\n    x = x / BASE_DIVISOR + (y * (z t)) / BASE_DIVISOR;\n\n",
                "Repair": "\nFix the bug by changing lines 319-322 to:\n\n    incentivePool[tokenAddress] += (amount * (transferFeePerc tokenManager.getTokensInfo(tokenAddress).equilibriumFee)) / BASE_DIVISOR;\n\nankurdubey521 (Biconomy) confirmed(https://github.com/code-423n4/2022-03-biconomy-findings/issues/38)\n\npauliax (judge) commented(https://github.com/code-423n4/2022-03-biconomy-findings/issues/38#issuecomment-1094991790):\n  Great find, the wrong order of arithmetic operations deserves a severity of high as it would have serious negative consequences.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/ILPToken.sol\";\nimport \"./interfaces/ITokenManager.sol\";\nimport \"./interfaces/IWhiteListPeriodManager.sol\";\nimport \"./interfaces/ILiquidityPool.sol\";\n\ncontract LiquidityProviders is\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable,\n    OwnableUpgradeable,\n    Pausable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 public constant BASE_DIVISOR = 10**18;\n\n    ILPToken internal lpToken;\n    ILiquidityPool internal liquidityPool;\n    ITokenManager internal tokenManager;\n    IWhiteListPeriodManager internal whiteListPeriodManager;\n\n    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);\n    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);\n    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);\n    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);\n    event EthReceived(address indexed sender, uint256 value);\n    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);\n\n    // LP Fee Distribution\n    mapping(address => uint256) public totalReserve; // Include Liquidity + Fee accumulated\n    mapping(address => uint256) public totalLiquidity; // Include Liquidity only\n    mapping(address => uint256) public currentLiquidity; // Include current liquidity, updated on every in and out transfer\n    mapping(address => uint256) public totalLPFees;\n    mapping(address => uint256) public totalSharesMinted;\n\n    /**\n     * @dev Modifier for checking to validate a NFTId and it's ownership\n     * @param _tokenId token id to validate\n     * @param _transactor typically msgSender(), passed to verify against owner of _tokenId\n     */\n    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {\n        (address token, , ) = lpToken.tokenMetadata(_tokenId);\n        require(lpToken.exists(_tokenId), \"ERR__TOKEN_DOES_NOT_EXIST\");\n        require(lpToken.ownerOf(_tokenId) == _transactor, \"ERR__TRANSACTOR_DOES_NOT_OWN_NFT\");\n        _;\n    }\n\n    /**\n     * @dev Modifier for checking if msg.sender in liquiditypool\n     */\n    modifier onlyLiquidityPool() {\n        require(_msgSender() == address(liquidityPool), \"ERR__UNAUTHORIZED\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(_isSupportedToken(tokenAddress), \"Token not supported\");\n        _;\n    }\n\n    /**\n     * @dev initalizes the contract, acts as constructor\n     * @param _trustedForwarder address of trusted forwarder\n     */\n    function initialize(\n        address _trustedForwarder,\n        address _lpToken,\n        address _tokenManager,\n        address _pauser\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        __ReentrancyGuard_init();\n        _setLPToken(_lpToken);\n        _setTokenManager(_tokenManager);\n    }\n\n    function _isSupportedToken(address _token) internal view returns (bool) {\n        return tokenManager.getTokensInfo(_token).supportedToken;\n    }\n\n    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {\n        return totalReserve[tokenAddress];\n    }\n\n    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {\n        return totalLiquidity[tokenAddress];\n    }\n\n    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {\n        return totalLPFees[tokenAddress];\n    }\n\n    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {\n        return currentLiquidity[tokenAddress];\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of NFT Contract\n     * @param _lpToken address of lpToken\n     */\n    function setLpToken(address _lpToken) external onlyOwner {\n        _setLPToken(_lpToken);\n    }\n\n    /**\n     * Internal method to set LP token contract.\n     */\n    function _setLPToken(address _lpToken) internal {\n        lpToken = ILPToken(_lpToken);\n    }\n\n    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {\n        _increaseCurrentLiquidity(tokenAddress, amount);\n    }\n\n    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {\n        _decreaseCurrentLiquidity(tokenAddress, amount);\n    }\n\n    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {\n        currentLiquidity[tokenAddress] += amount;\n        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);\n    }\n\n    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {\n        currentLiquidity[tokenAddress] -= amount;\n        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);\n    }\n\n    /**\n     * Public method to set TokenManager contract.\n     */\n    function setTokenManager(address _tokenManager) external onlyOwner {\n        _setTokenManager(_tokenManager);\n    }\n\n    /**\n     * Internal method to set TokenManager contract.\n     */\n    function _setTokenManager(address _tokenManager) internal {\n        tokenManager = ITokenManager(_tokenManager);\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of WhiteListPeriodManager Contract\n     * @param _whiteListPeriodManager address of WhiteListPeriodManager\n     */\n    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {\n        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of LiquidityPool Contract\n     * @param _liquidityPool address of LiquidityPool\n     */\n    function setLiquidityPool(address _liquidityPool) external onlyOwner {\n        liquidityPool = ILiquidityPool(_liquidityPool);\n    }\n\n    /**\n     * @dev Returns price of Base token in terms of LP Shares\n     * @param _baseToken address of baseToken\n     * @return Price of Base token in terms of LP Shares\n     */\n    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {\n        uint256 supply = totalSharesMinted[_baseToken];\n        if (supply > 0) {\n            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];\n        }\n        return BASE_DIVISOR;\n    }\n\n    /**\n     * @dev Converts shares to token amount\n     */\n\n    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {\n        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];\n    }\n\n    /**\n     * @dev Returns the fee accumulated on a given NFT\n     * @param _nftId Id of NFT\n     * @return accumulated fee\n     */\n    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {\n        require(lpToken.exists(_nftId), \"ERR__INVALID_NFT\");\n\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n\n        if (totalNFTShares == 0) {\n            return 0;\n        }\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        uint256 lpFeeAccumulated;\n\n        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount \n        if(nftSuppliedLiquidity > eligibleLiquidity) {\n            lpFeeAccumulated = 0;\n        } else {\n            unchecked {\n                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n            }\n        }\n        return lpFeeAccumulated;\n    }\n\n    /**\n     * @dev Records fee being added to total reserve\n     * @param _token Address of Token for which LP fee is being added\n     * @param _amount Amount being added\n     */\n    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {\n        totalReserve[_token] += _amount;\n        totalLPFees[_token] += _amount;\n        emit FeeAdded(_token, _amount);\n    }\n\n    /**\n     * @dev Internal function to add liquidity to a new NFT\n     */\n    function _addLiquidity(address _token, uint256 _amount) internal {\n        require(_amount > 0, \"ERR__AMOUNT_IS_0\");\n        uint256 nftId = lpToken.mint(_msgSender());\n        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);\n        lpToken.updateTokenMetadata(nftId, data);\n        _increaseLiquidity(nftId, _amount);\n    }\n\n    /**\n     * @dev Function to mint a new NFT for a user, add native liquidity and store the\n     *      record in the newly minted NFT\n     */\n    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {\n        (bool success, ) = address(liquidityPool).call{value: msg.value}(\"\");\n        require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        _addLiquidity(NATIVE, msg.value);\n    }\n\n    /**\n     * @dev Function to mint a new NFT for a user, add token liquidity and store the\n     *      record in the newly minted NFT\n     * @param _token Address of token for which liquidity is to be added\n     * @param _amount Amount of liquidity added\n     */\n    function addTokenLiquidity(address _token, uint256 _amount)\n        external\n        nonReentrant\n        tokenChecks(_token)\n        whenNotPaused\n    {\n        require(_token != NATIVE, \"ERR__WRONG_FUNCTION\");\n        require(\n            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,\n            \"ERR__INSUFFICIENT_ALLOWANCE\"\n        );\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);\n        _addLiquidity(_token, _amount);\n    }\n\n    /**\n     * @dev Internal helper function to increase liquidity in a given NFT\n     */\n    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {\n        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);\n\n        require(_amount > 0, \"ERR__AMOUNT_IS_0\");\n        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);\n\n        uint256 mintedSharesAmount;\n        // Adding liquidity in the pool for the first time\n        if (totalReserve[token] == 0) {\n            mintedSharesAmount = BASE_DIVISOR * _amount;\n        } else {\n            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];\n        }\n\n        require(mintedSharesAmount >= BASE_DIVISOR, \"ERR__AMOUNT_BELOW_MIN_LIQUIDITY\");\n\n        totalLiquidity[token] += _amount;\n        totalReserve[token] += _amount;\n        totalSharesMinted[token] += mintedSharesAmount;\n\n        LpTokenMetadata memory data = LpTokenMetadata(\n            token,\n            totalSuppliedLiquidity + _amount,\n            totalShares + mintedSharesAmount\n        );\n        lpToken.updateTokenMetadata(_nftId, data);\n\n        // Increase the current liquidity\n        _increaseCurrentLiquidity(token, _amount);\n        emit LiquidityAdded(token, _amount, _msgSender());\n    }\n\n    /**\n     * @dev Function to allow LPs to add ERC20 token liquidity to existing NFT\n     * @param _nftId ID of NFT for updating the balances\n     * @param _amount Token amount to be added\n     */\n    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {\n        (address token, , ) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(token), \"ERR__TOKEN_NOT_SUPPORTED\");\n        require(token != NATIVE, \"ERR__WRONG_FUNCTION\");\n        require(\n            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,\n            \"ERR__INSUFFICIENT_ALLOWANCE\"\n        );\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);\n        _increaseLiquidity(_nftId, _amount);\n    }\n\n    /**\n     * @dev Function to allow LPs to add native token liquidity to existing NFT\n     */\n    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {\n        (address token, , ) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(NATIVE), \"ERR__TOKEN_NOT_SUPPORTED\");\n        require(token == NATIVE, \"ERR__WRONG_FUNCTION\");\n        (bool success, ) = address(liquidityPool).call{value: msg.value}(\"\");\n        require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        _increaseLiquidity(_nftId, msg.value);\n    }\n\n    /**\n     * @dev Function to allow LPs to remove their liquidity from an existing NFT\n     *      Also automatically redeems any earned fee\n     */\n    function removeLiquidity(uint256 _nftId, uint256 _amount)\n        external\n        nonReentrant\n        onlyValidLpToken(_nftId, _msgSender())\n        whenNotPaused\n    {\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");\n\n        require(_amount != 0, \"ERR__INVALID_AMOUNT\");\n        require(nftSuppliedLiquidity >= _amount, \"ERR__INSUFFICIENT_LIQUIDITY\");\n        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);\n        // Claculate how much shares represent input amount\n        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);\n\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        \n        uint256 lpFeeAccumulated;\n\n        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount \n        if(nftSuppliedLiquidity > eligibleLiquidity) {\n            lpFeeAccumulated = 0;\n        } else {\n            unchecked {\n                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n            }\n        }\n        // Calculate amount of lp shares that represent accumulated Fee\n        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);\n\n        totalLPFees[_tokenAddress] -= lpFeeAccumulated;\n        uint256 amountToWithdraw = _amount + lpFeeAccumulated;\n        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;\n\n        // Handle round off errors to avoid dust lp token in contract\n        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {\n            lpSharesToBurn = totalNFTShares;\n        }\n        totalReserve[_tokenAddress] -= amountToWithdraw;\n        totalLiquidity[_tokenAddress] -= _amount;\n        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;\n\n        _decreaseCurrentLiquidity(_tokenAddress, _amount);\n\n        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);\n\n        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);\n\n        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());\n    }\n\n    /**\n     * @dev Function to allow LPs to claim the fee earned on their NFT\n     * @param _nftId ID of NFT where liquidity is recorded\n     */\n    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");\n\n        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);\n\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n        require(lpFeeAccumulated > 0, \"ERR__NO_REWARDS_TO_CLAIM\");\n        // Calculate amount of lp shares that represent accumulated Fee\n        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;\n\n        totalReserve[_tokenAddress] -= lpFeeAccumulated;\n        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;\n        totalLPFees[_tokenAddress] -= lpFeeAccumulated;\n\n        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);\n        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);\n        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);\n    }\n\n    /**\n     * @dev Internal Function to burn LP shares and remove liquidity from existing NFT\n     */\n    function _burnSharesFromNft(\n        uint256 _nftId,\n        uint256 _shares,\n        uint256 _tokenAmount,\n        address _tokenAddress\n    ) internal {\n        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);\n        nftShares -= _shares;\n        nftSuppliedLiquidity -= _tokenAmount;\n\n        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));\n    }\n\n    function _transferFromLiquidityPool(\n        address _tokenAddress,\n        address _receiver,\n        uint256 _tokenAmount\n    ) internal {\n        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);\n    }\n\n    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {\n        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);\n        return totalSuppliedLiquidity;\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit EthReceived(_msgSender(), msg.value);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/IExecutorManager.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./interfaces/ITokenManager.sol\";\n\ncontract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {\n    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy\n\n    uint256 public baseGas;\n\n    IExecutorManager private executorManager;\n    ITokenManager public tokenManager;\n    ILiquidityProviders public liquidityProviders;\n\n    struct PermitRequest {\n        uint256 nonce;\n        uint256 expiry;\n        bool allowed;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    mapping(bytes32 => bool) public processedHash;\n    mapping(address => uint256) public gasFeeAccumulatedByToken;\n\n    // Gas fee accumulated by token address => executor address\n    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;\n\n    // Incentive Pool amount per token address\n    mapping(address => uint256) public incentivePool;\n\n    event AssetSent(\n        address indexed asset,\n        uint256 indexed amount,\n        uint256 indexed transferredAmount,\n        address target,\n        bytes depositHash,\n        uint256 fromChainId\n    );\n    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);\n    event Received(address indexed from, uint256 indexed amount);\n    event Deposit(\n        address indexed from,\n        address indexed tokenAddress,\n        address indexed receiver,\n        uint256 toChainId,\n        uint256 amount,\n        uint256 reward,\n        string tag\n    );\n    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);\n    event TrustedForwarderChanged(address indexed forwarderAddress);\n    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);\n    event EthReceived(address, uint256);\n\n    // MODIFIERS\n    modifier onlyExecutor() {\n        require(executorManager.getExecutorStatus(_msgSender()), \"Only executor is allowed\");\n        _;\n    }\n\n    modifier onlyLiquidityProviders() {\n        require(_msgSender() == address(liquidityProviders), \"Only liquidityProviders is allowed\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, \"Token not supported\");\n        _;\n    }\n\n    function initialize(\n        address _executorManagerAddress,\n        address _pauser,\n        address _trustedForwarder,\n        address _tokenManager,\n        address _liquidityProviders\n    ) public initializer {\n        require(_executorManagerAddress != address(0), \"ExecutorManager cannot be 0x0\");\n        require(_trustedForwarder != address(0), \"TrustedForwarder cannot be 0x0\");\n        require(_liquidityProviders != address(0), \"LiquidityProviders cannot be 0x0\");\n        __ERC2771Context_init(_trustedForwarder);\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        executorManager = IExecutorManager(_executorManagerAddress);\n        tokenManager = ITokenManager(_tokenManager);\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n        baseGas = 21000;\n    }\n\n    function setTrustedForwarder(address trustedForwarder) public onlyOwner {\n        require(trustedForwarder != address(0), \"TrustedForwarder can't be 0\");\n        _trustedForwarder = trustedForwarder;\n        emit TrustedForwarderChanged(trustedForwarder);\n    }\n\n    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {\n        require(_liquidityProviders != address(0), \"LiquidityProviders can't be 0\");\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n        emit LiquidityProvidersChanged(_liquidityProviders);\n    }\n\n    function setBaseGas(uint128 gas) external onlyOwner {\n        baseGas = gas;\n    }\n\n    function getExecutorManager() public view returns (address) {\n        return address(executorManager);\n    }\n\n    function setExecutorManager(address _executorManagerAddress) external onlyOwner {\n        require(_executorManagerAddress != address(0), \"Executor Manager cannot be 0\");\n        executorManager = IExecutorManager(_executorManagerAddress);\n    }\n\n    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {\n        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);\n        \n        currentLiquidity =\n            liquidityPoolBalance -\n            liquidityProviders.totalLPFees(tokenAddress) -\n            gasFeeAccumulatedByToken[tokenAddress] -\n            incentivePool[tokenAddress];\n    }\n\n    /**\n     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.\n     * @param toChainId Chain id where funds needs to be transfered\n     * @param tokenAddress ERC20 Token address that needs to be transfered\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param amount Amount of token being transfered\n     */\n    function depositErc20(\n        uint256 toChainId,\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        string memory tag\n    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {\n        require(\n            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&\n                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,\n            \"Deposit amount not in Cap limit\"\n        );\n        require(receiver != address(0), \"Receiver address cannot be 0\");\n        require(amount != 0, \"Amount cannot be 0\");\n        address sender = _msgSender();\n\n        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);\n        if (rewardAmount != 0) {\n            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;\n        }\n        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);\n        // Emit (amount + reward amount) in event\n        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);\n    }\n\n    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {\n        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);\n        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);\n        if (currentLiquidity < providedLiquidity) {\n            uint256 liquidityDifference = providedLiquidity - currentLiquidity;\n            if (amount >= liquidityDifference) {\n                rewardAmount = incentivePool[tokenAddress];\n            } else {\n                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference\n                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;\n                rewardAmount = rewardAmount / 10000000000;\n            }\n        }\n    }\n\n    /**\n     * DAI permit and Deposit.\n     */\n    function permitAndDepositErc20(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        uint256 toChainId,\n        PermitRequest calldata permitOptions,\n        string memory tag\n    ) external {\n        IERC20Permit(tokenAddress).permit(\n            _msgSender(),\n            address(this),\n            permitOptions.nonce,\n            permitOptions.expiry,\n            permitOptions.allowed,\n            permitOptions.v,\n            permitOptions.r,\n            permitOptions.s\n        );\n        depositErc20(toChainId, tokenAddress, receiver, amount, tag);\n    }\n\n    /**\n     * EIP2612 and Deposit.\n     */\n    function permitEIP2612AndDepositErc20(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        uint256 toChainId,\n        PermitRequest calldata permitOptions,\n        string memory tag\n    ) external {\n        IERC20Permit(tokenAddress).permit(\n            _msgSender(),\n            address(this),\n            amount,\n            permitOptions.expiry,\n            permitOptions.v,\n            permitOptions.r,\n            permitOptions.s\n        );\n        depositErc20(toChainId, tokenAddress, receiver, amount, tag);\n    }\n\n    /**\n     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param toChainId Chain id where funds needs to be transfered\n     */\n    function depositNative(\n        address receiver,\n        uint256 toChainId,\n        string memory tag\n    ) external payable whenNotPaused nonReentrant {\n        require(\n            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&\n                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,\n            \"Deposit amount not in Cap limit\"\n        );\n        require(receiver != address(0), \"Receiver address cannot be 0\");\n        require(msg.value != 0, \"Amount cannot be 0\");\n\n        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);\n        if (rewardAmount != 0) {\n            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;\n        }\n        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);\n        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);\n    }\n\n    function sendFundsToUser(\n        address tokenAddress,\n        uint256 amount,\n        address payable receiver,\n        bytes memory depositHash,\n        uint256 tokenGasPrice,\n        uint256 fromChainId\n    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {\n        uint256 initialGas = gasleft();\n        require(\n            tokenManager.getTransferConfig(tokenAddress).min <= amount &&\n                tokenManager.getTransferConfig(tokenAddress).max >= amount,\n            \"Withdraw amnt not in Cap limits\"\n        );\n        require(receiver != address(0), \"Bad receiver address\");\n\n        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);\n\n        require(!status, \"Already Processed\");\n        processedHash[hashSendTransaction] = true;\n\n        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);\n        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);\n\n        if (tokenAddress == NATIVE) {\n            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");\n            (bool success, ) = receiver.call{value: amountToTransfer}(\"\");\n            require(success, \"Native Transfer Failed\");\n        } else {\n            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");\n            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);\n        }\n\n        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);\n    }\n\n    /**\n     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.\n     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.\n     * @param initialGas Gas provided initially before any calculations began\n     * @param tokenAddress Token address for which calculation needs to be done\n     * @param amount Amount of token to be transfered before deducting the fee\n     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee\n     * @return amountToTransfer Total amount to be transfered after deducting all fees.\n     */\n    function getAmountToTransfer(\n        uint256 initialGas,\n        address tokenAddress,\n        uint256 amount,\n        uint256 tokenGasPrice\n    ) internal returns (uint256 amountToTransfer) {\n        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);\n        uint256 lpFee;\n        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {\n            // Here add some fee to incentive pool also\n            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;\n            incentivePool[tokenAddress] =\n                (incentivePool[tokenAddress] +\n                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /\n                BASE_DIVISOR;\n        } else {\n            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n        }\n        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n\n        liquidityProviders.addLPFee(tokenAddress, lpFee);\n\n        uint256 totalGasUsed = initialGas - gasleft();\n        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;\n        totalGasUsed = totalGasUsed + baseGas;\n\n        uint256 gasFee = totalGasUsed * tokenGasPrice;\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;\n        amountToTransfer = amount - (transferFeeAmount + gasFee);\n\n        emit FeeDetails(lpFee, transferFeeAmount, gasFee);\n    }\n\n    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {\n        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);\n        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);\n\n        uint256 resultingLiquidity = currentLiquidity - amount;\n\n        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;\n        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;\n        // Fee is represented in basis points * 10 for better accuracy\n        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; // F(max) * F(e) * L(e)\n        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; // F(e) * L(e) + (F(max) - F(e)) * L(r)\n\n        if (denominator == 0) {\n            fee = 0;\n        } else {\n            fee = numerator / denominator;\n        }\n    }\n\n    function checkHashStatus(\n        address tokenAddress,\n        uint256 amount,\n        address payable receiver,\n        bytes memory depositHash\n    ) public view returns (bytes32 hashSendTransaction, bool status) {\n        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));\n\n        status = processedHash[hashSendTransaction];\n    }\n\n    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {\n        require(tokenAddress != NATIVE, \"Can't withdraw native token fee\");\n        // uint256 gasFeeAccumulated = gasFeeAccumulatedByToken[tokenAddress];\n        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];\n        require(_gasFeeAccumulated != 0, \"Gas Fee earned is 0\");\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;\n        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);\n        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);\n    }\n\n    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {\n        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];\n        require(_gasFeeAccumulated != 0, \"Gas Fee earned is 0\");\n        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;\n        gasFeeAccumulated[NATIVE][_msgSender()] = 0;\n        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}(\"\");\n        require(success, \"Native Transfer Failed\");\n\n        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);\n    }\n\n    function transfer(\n        address _tokenAddress,\n        address receiver,\n        uint256 _tokenAmount\n    ) external whenNotPaused onlyLiquidityProviders nonReentrant {\n        require(receiver != address(0), \"Invalid receiver\");\n        if (_tokenAddress == NATIVE) {\n            require(address(this).balance >= _tokenAmount, \"ERR__INSUFFICIENT_BALANCE\");\n            (bool success, ) = receiver.call{value: _tokenAmount}(\"\");\n            require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        } else {\n            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);\n            require(baseToken.balanceOf(address(this)) >= _tokenAmount, \"ERR__INSUFFICIENT_BALANCE\");\n            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);\n        }\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit EthReceived(_msgSender(), msg.value);\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidityProviders.sol",
            "LiquidityPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction removeLiquidity(uint256 _nftId, uint256 _amount)\n    external\n    nonReentrant\n    onlyValidLpToken(_nftId, _msgSender())\n    whenNotPaused\n{\n    (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n    require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");\n\n    require(_amount != 0, \"ERR__INVALID_AMOUNT\");\n    require(nftSuppliedLiquidity = _amount, \"ERR__INSUFFICIENT_LIQUIDITY\");\n    whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);\n    // Claculate how much shares represent input amount\n    uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);\n\n    // Calculate rewards accumulated\n    uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n",
                    "//solidity\nfunction sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {\n    return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];\n}\n"
                ],
                "Type": "  LiquidityProviders.sol  The share price of the LP can be manipulated and making future liquidityProviders unable to  removeLiquidity() ",
                "Description": "\nLiquidityProviders.sol#L345-L362(https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L345-L362)<br\n\nsolidity\nfunction removeLiquidity(uint256 _nftId, uint256 _amount)\n    external\n    nonReentrant\n    onlyValidLpToken(_nftId, _msgSender())\n    whenNotPaused\n{\n    (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n    require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");\n\n    require(_amount != 0, \"ERR__INVALID_AMOUNT\");\n    require(nftSuppliedLiquidity = _amount, \"ERR__INSUFFICIENT_LIQUIDITY\");\n    whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);\n    // Claculate how much shares represent input amount\n    uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);\n\n    // Calculate rewards accumulated\n    uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n\n\nLiquidityProviders.sol#L192-L194(https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityProviders.sol#L192-L194)<br\n\nsolidity\nfunction sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {\n    return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];\n}\n\n\nThe share price of the liquidity can be manipulated to an extremely low value (1 underlying token worth a huge amount of shares), making it possible for sharesToTokenAmount(totalNFTShares, _tokenAddress) to overflow in removeLiquidity() and therefore freeze users' funds.\n\n\n1.  Alice addTokenLiquidity() with 1e8 * 1e18 XYZ on B-Chain, totalSharesMinted == 1e44;\n2.  Alice sendFundsToUser() and bridge 1e8 * 1e18 XYZ from B-Chain to A-Chain;\n3.  Alice depositErc20() and bridge 1e8 * 1e18 XYZ from A-Chain to B-Chain;\n4.  Alice removeLiquidity() and withdraw 1e8 * 1e18 1 XYZ, then: totalReserve == 1 wei XYZ, and totalSharesMinted == 1e26;\n5.  Bob addTokenLiquidity() with 3.4e7 * 1e18 XYZ;\n6.  Bob tries to removeLiquidity().\n\nExpected Results: Bob to get back the deposits;\n\nActual Results: The tx reverted due to overflow at sharesToTokenAmount().\n\n",
                "Repair": "\nLiquidityProviders.sol#L280-L292(https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L280-L292)<br\n\nsolidity\nfunction _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {\n    (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);\n\n    require(_amount  0, \"ERR__AMOUNT_IS_0\");\n    whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);\n\n    uint256 mintedSharesAmount;\n    // Adding liquidity in the pool for the first time\n    if (totalReserve[token] == 0) {\n        mintedSharesAmount = BASE_DIVISOR * _amount;\n    } else {\n        mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];\n    }\n    ...\n\n\nConsider locking part of the first mint's liquidity to maintain a minimum amount of totalReserve[token], so that the share price can not be easily manipulated.\n\nankurdubey521 (Biconomy) confirmed(https://github.com/code-423n4/2022-03-biconomy-findings/issues/139)\n\npauliax (judge) commented(https://github.com/code-423n4/2022-03-biconomy-findings/issues/139#issuecomment-1120975961):\n  Great find, with a PoC, deserves a severity of high because it is a valid attack path that does not have hand-wavy hypotheticals.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/ILPToken.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\n\ncontract HyphenLiquidityFarming is\n    Initializable,\n    ERC2771ContextUpgradeable,\n    OwnableUpgradeable,\n    Pausable,\n    ReentrancyGuardUpgradeable,\n    IERC721ReceiverUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    ILPToken public lpToken;\n    ILiquidityProviders public liquidityProviders;\n\n    struct NFTInfo {\n        address payable staker;\n        uint256 rewardDebt;\n        uint256 unpaidRewards;\n        bool isStaked;\n    }\n\n    struct PoolInfo {\n        uint256 accTokenPerShare;\n        uint256 lastRewardTime;\n    }\n\n    struct RewardsPerSecondEntry {\n        uint256 rewardsPerSecond;\n        uint256 timestamp;\n    }\n\n    /// @notice Mapping to track the rewarder pool.\n    mapping(address => PoolInfo) public poolInfo;\n\n    /// @notice Info of each NFT that is staked.\n    mapping(uint256 => NFTInfo) public nftInfo;\n\n    /// @notice Reward rate per base token\n    //mapping(address => uint256) public rewardPerSecond;\n\n    /// @notice Reward Token\n    mapping(address => address) public rewardTokens;\n\n    /// @notice Staker => NFTs staked\n    mapping(address => uint256[]) public nftIdsStaked;\n\n    /// @notice Token => Total Shares Staked\n    mapping(address => uint256) public totalSharesStaked;\n\n    /// @notice Token => Reward Rate Updation history\n    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;\n\n    uint256 private constant ACC_TOKEN_PRECISION = 1e12;\n    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);\n    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);\n    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);\n    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);\n    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);\n    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);\n    event LogNativeReceived(address indexed sender, uint256 value);\n\n    function initialize(\n        address _trustedForwarder,\n        address _pauser,\n        ILiquidityProviders _liquidityProviders,\n        ILPToken _lpToken\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        __ReentrancyGuard_init();\n        liquidityProviders = _liquidityProviders;\n        lpToken = _lpToken;\n    }\n\n    /// @notice Initialize the rewarder pool.\n    /// @param _baseToken Base token to be used for the rewarder pool.\n    /// @param _rewardToken Reward token to be used for the rewarder pool.\n    /// @param _rewardPerSecond Reward rate per base token.\n    function initalizeRewardPool(\n        address _baseToken,\n        address _rewardToken,\n        uint256 _rewardPerSecond\n    ) external onlyOwner {\n        require(rewardTokens[_baseToken] == address(0), \"ERR__POOL_ALREADY_INITIALIZED\");\n        require(_baseToken != address(0), \"ERR__BASE_TOKEN_IS_ZERO\");\n        require(_rewardToken != address(0), \"ERR_REWARD_TOKEN_IS_ZERO\");\n        rewardTokens[_baseToken] = _rewardToken;\n        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));\n        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);\n    }\n\n    function _sendErc20AndGetSentAmount(\n        IERC20Upgradeable _token,\n        uint256 _amount,\n        address _to\n    ) private returns (uint256) {\n        uint256 recepientBalance = _token.balanceOf(_to);\n        _token.safeTransfer(_to, _amount);\n        return _token.balanceOf(_to) - recepientBalance;\n    }\n\n    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.\n    /// @param _nftId NFT ID that is being locked\n    /// @param _to Address to which rewards will be credited.\n    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {\n        NFTInfo storage nft = nftInfo[_nftId];\n        require(nft.isStaked, \"ERR__NFT_NOT_STAKED\");\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        PoolInfo memory pool = updatePool(baseToken);\n        uint256 pending;\n        uint256 amountSent;\n        if (amount > 0) {\n            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;\n            if (rewardTokens[baseToken] == NATIVE) {\n                uint256 balance = address(this).balance;\n                if (pending > balance) {\n                    unchecked {\n                        nft.unpaidRewards = pending - balance;\n                    }\n                    (bool success, ) = _to.call{value: balance}(\"\");\n                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                    amountSent = balance;\n                } else {\n                    nft.unpaidRewards = 0;\n                    (bool success, ) = _to.call{value: pending}(\"\");\n                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                    amountSent = pending;\n                }\n            } else {\n                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);\n                uint256 balance = rewardToken.balanceOf(address(this));\n                if (pending > balance) {\n                    unchecked {\n                        nft.unpaidRewards = pending - balance;\n                    }\n                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);\n                } else {\n                    nft.unpaidRewards = 0;\n                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);\n                }\n            }\n        }\n        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);\n    }\n\n    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.\n    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {\n        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));\n        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);\n    }\n\n    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract\n    /// @param _token Token to reclaim, use 0x00 for Ethereum\n    /// @param _amount Amount of tokens to reclaim\n    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,\n    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,\n    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.\n    function reclaimTokens(\n        address _token,\n        uint256 _amount,\n        address payable _to\n    ) external nonReentrant onlyOwner {\n        require(_to != address(0), \"ERR__TO_IS_ZERO\");\n        if (_token == NATIVE) {\n            (bool success, ) = payable(_to).call{value: _amount}(\"\");\n            require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        } else {\n            IERC20Upgradeable(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    /// @notice Deposit LP tokens\n    /// @param _nftId LP token nftId to deposit.\n    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        address msgSender = _msgSender();\n\n        require(\n            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),\n            \"ERR__NOT_APPROVED\"\n        );\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        require(rewardTokens[baseToken] != address(0), \"ERR__POOL_NOT_INITIALIZED\");\n        require(rewardRateLog[baseToken].length != 0, \"ERR__POOL_NOT_INITIALIZED\");\n\n        NFTInfo storage nft = nftInfo[_nftId];\n        require(!nft.isStaked, \"ERR__NFT_ALREADY_STAKED\");\n\n        lpToken.safeTransferFrom(msgSender, address(this), _nftId);\n\n        PoolInfo memory pool = updatePool(baseToken);\n        nft.isStaked = true;\n        nft.staker = _to;\n        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n\n        nftIdsStaked[_to].push(_nftId);\n        totalSharesStaked[baseToken] += amount;\n\n        emit LogDeposit(msgSender, baseToken, _nftId);\n    }\n\n    /// @notice Withdraw LP tokens\n    /// @param _nftId LP token nftId to withdraw.\n    /// @param _to The receiver of `amount` withdraw benefit.\n    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        address msgSender = _msgSender();\n        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;\n        uint256 index;\n        for (index = 0; index < nftsStakedLength; ++index) {\n            if (nftIdsStaked[msgSender][index] == _nftId) {\n                break;\n            }\n        }\n\n        require(index != nftsStakedLength, \"ERR__NFT_NOT_STAKED\");\n        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];\n        nftIdsStaked[msgSender].pop();\n\n        _sendRewardsForNft(_nftId, _to);\n        delete nftInfo[_nftId];\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n        totalSharesStaked[baseToken] -= amount;\n\n        lpToken.safeTransferFrom(address(this), msgSender, _nftId);\n\n        emit LogWithdraw(msgSender, baseToken, _nftId, _to);\n    }\n\n    /// @notice Extract all rewards without withdrawing LP tokens\n    /// @param _nftId LP token nftId for which rewards are to be withdrawn\n    /// @param _to The receiver of withdraw benefit.\n    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        require(nftInfo[_nftId].staker == _msgSender(), \"ERR__NOT_OWNER\");\n        _sendRewardsForNft(_nftId, _to);\n    }\n\n    /// @notice Calculates an up to date value of accTokenPerShare\n    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted\n    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {\n        uint256 accumulator = 0;\n        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;\n        uint256 counter = block.timestamp;\n        uint256 i = rewardRateLog[_baseToken].length - 1;\n        while (true) {\n            if (lastUpdatedTime >= counter) {\n                break;\n            }\n            unchecked {\n                accumulator +=\n                    rewardRateLog[_baseToken][i].rewardsPerSecond *\n                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));\n            }\n            counter = rewardRateLog[_baseToken][i].timestamp;\n            if (i == 0) {\n                break;\n            }\n            --i;\n        }\n\n        // We know that during all the periods that were included in the current iterations,\n        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the\n        // updates to the pool that happened after the lastUpdatedTime.\n        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];\n        return accumulator + poolInfo[_baseToken].accTokenPerShare;\n    }\n\n    /// @notice View function to see pending Token\n    /// @param _nftId NFT for which pending tokens are to be viewed\n    /// @return pending reward for a given user.\n    function pendingToken(uint256 _nftId) external view returns (uint256) {\n        NFTInfo storage nft = nftInfo[_nftId];\n        if (!nft.isStaked) {\n            return 0;\n        }\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        PoolInfo memory pool = poolInfo[baseToken];\n        uint256 accToken1PerShare = pool.accTokenPerShare;\n        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {\n            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);\n        }\n        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @return pool Returns the pool that was updated.\n    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {\n        pool = poolInfo[_baseToken];\n        if (block.timestamp > pool.lastRewardTime) {\n            if (totalSharesStaked[_baseToken] > 0) {\n                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);\n            }\n            pool.lastRewardTime = block.timestamp;\n            poolInfo[_baseToken] = pool;\n            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);\n        }\n    }\n\n    /// @notice View function to see the tokens staked by a given user.\n    /// @param _user Address of user.\n    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {\n        nftIds = nftIdsStaked[_user];\n    }\n\n    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {\n        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit LogNativeReceived(_msgSender(), msg.value);\n    }\n\n    function max(uint256 _a, uint256 _b) private pure returns (uint256) {\n        return _a >= _b ? _a : _b;\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidityFarming.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nfunction withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n    address msgSender = _msgSender();\n    uint256 nftsStakedLength = nftIdsStaked[msgSender].length;\n    uint256 index;\n    for (index = 0; index < nftsStakedLength; ++index) {\n        if (nftIdsStaked[msgSender][index] == _nftId) {\n            break;\n        }\n    }\n\n    require(index != nftsStakedLength, \"ERR__NFT_NOT_STAKED\");\n    nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length 1];\n    nftIdsStaked[msgSender].pop();\n\n    _sendRewardsForNft(_nftId, _to);\n    delete nftInfo[_nftId];\n\n    (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n    amount /= liquidityProviders.BASE_DIVISOR();\n    totalSharesStaked[baseToken] -= amount;\n\n    lpToken.safeTransferFrom(address(this), msgSender, _nftId);\n\n    emit LogWithdraw(msgSender, baseToken, _nftId, _to);\n}\n",
                    "//solidity\nfunction _sendRewardsForNft(uint256 _nftId, address payable _to) internal {\n    NFTInfo storage nft = nftInfo[_nftId];\n    require(nft.isStaked, \"ERR__NFT_NOT_STAKED\");\n\n    (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n    amount /= liquidityProviders.BASE_DIVISOR();\n\n    PoolInfo memory pool = updatePool(baseToken);\n    uint256 pending;\n    uint256 amountSent;\n    if (amount  0) {\n        pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) nft.rewardDebt + nft.unpaidRewards;\n        if (rewardTokens[baseToken] == NATIVE) {\n            uint256 balance = address(this).balance;\n            if (pending  balance) {\n                unchecked {\n                    nft.unpaidRewards = pending balance;\n                }\n                (bool success, ) = _to.call{value: balance}(\"\");\n                require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                amountSent = balance;\n            } else {\n                nft.unpaidRewards = 0;\n                (bool success, ) = _to.call{value: pending}(\"\");\n                require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                amountSent = pending;\n            }\n        } else {\n            IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);\n            uint256 balance = rewardToken.balanceOf(address(this));\n            if (pending  balance) {\n                unchecked {\n                    nft.unpaidRewards = pending balance;\n                }\n                amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);\n            } else {\n                nft.unpaidRewards = 0;\n                amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);\n            }\n        }\n    }\n    nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n    emit LogOnReward(_msgSender(), baseToken, amountSent, _to);\n}\n"
                ],
                "Type": " Deleting  nft Info  can cause users'  nft.unpaidRewards  to be permanently erased",
                "Description": "\nLiquidityFarming.sol#L229-L253(https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L229-L253)<br\n\nsolidity\nfunction withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n    address msgSender = _msgSender();\n    uint256 nftsStakedLength = nftIdsStaked[msgSender].length;\n    uint256 index;\n    for (index = 0; index < nftsStakedLength; ++index) {\n        if (nftIdsStaked[msgSender][index] == _nftId) {\n            break;\n        }\n    }\n\n    require(index != nftsStakedLength, \"ERR__NFT_NOT_STAKED\");\n    nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length 1];\n    nftIdsStaked[msgSender].pop();\n\n    _sendRewardsForNft(_nftId, _to);\n    delete nftInfo[_nftId];\n\n    (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n    amount /= liquidityProviders.BASE_DIVISOR();\n    totalSharesStaked[baseToken] -= amount;\n\n    lpToken.safeTransferFrom(address(this), msgSender, _nftId);\n\n    emit LogWithdraw(msgSender, baseToken, _nftId, _to);\n}\n\n\nLiquidityFarming.sol#L122-L165(https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L122-L165)<br\n\nsolidity\nfunction _sendRewardsForNft(uint256 _nftId, address payable _to) internal {\n    NFTInfo storage nft = nftInfo[_nftId];\n    require(nft.isStaked, \"ERR__NFT_NOT_STAKED\");\n\n    (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n    amount /= liquidityProviders.BASE_DIVISOR();\n\n    PoolInfo memory pool = updatePool(baseToken);\n    uint256 pending;\n    uint256 amountSent;\n    if (amount  0) {\n        pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) nft.rewardDebt + nft.unpaidRewards;\n        if (rewardTokens[baseToken] == NATIVE) {\n            uint256 balance = address(this).balance;\n            if (pending  balance) {\n                unchecked {\n                    nft.unpaidRewards = pending balance;\n                }\n                (bool success, ) = _to.call{value: balance}(\"\");\n                require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                amountSent = balance;\n            } else {\n                nft.unpaidRewards = 0;\n                (bool success, ) = _to.call{value: pending}(\"\");\n                require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                amountSent = pending;\n            }\n        } else {\n            IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);\n            uint256 balance = rewardToken.balanceOf(address(this));\n            if (pending  balance) {\n                unchecked {\n                    nft.unpaidRewards = pending balance;\n                }\n                amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);\n            } else {\n                nft.unpaidRewards = 0;\n                amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);\n            }\n        }\n    }\n    nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n    emit LogOnReward(_msgSender(), baseToken, amountSent, _to);\n}\n\n\nWhen withdraw() is called, _sendRewardsForNft(_nftId, _to) will be called to send the rewards.\n\nIn _sendRewardsForNft(), when address(this).balance is insufficient at the moment, nft.unpaidRewards = pending balance will be recorded and the user can get it back at the next time.\n\nHowever, at L244, the whole nftInfo is being deleted, so that nft.unpaidRewards will also get erased.\n\nThere is no way for the user to get back this unpaidRewards anymore.\n\n",
                "Repair": "\nConsider adding a new parameter named force for withdraw(), require(force || unpaidRewards == 0) before deleting nftInfo.\n\nankurdubey521 (Biconomy) confirmed and commented(https://github.com/code-423n4/2022-03-biconomy-findings/issues/135#issuecomment-1082892044):\n  Great catch! Thanks a lot for bringing these up.\n \n  HP-25: C4 Audit Fixes, Dynamic Fee Changes bcnmy/hyphen-contract#42(https://github.com/bcnmy/hyphen-contract/pull/42)\n\npauliax (judge) commented(https://github.com/code-423n4/2022-03-biconomy-findings/issues/135#issuecomment-1114772722):\n  Great find, deserves a severity of high as it may incur in funds lost for the users.\n\nKenzoAgada (warden) commented(https://github.com/code-423n4/2022-03-biconomy-findings/issues/135#issuecomment-1141043124):\n  Shouldn't this be medium severity, as only rewards are lost and not original user funds?\n As the risk TLDR says -<br\n \n 2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n\n 3 \u2014 High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).<br\n \n There are other lost-rewards issues that have been classified as high, this questions pertains to them as well.\n\n0xleastwood (warden) commented(https://github.com/code-423n4/2022-03-biconomy-findings/issues/135#issuecomment-1145280670):\n  I would be inclined to keep this as high risk as it is less about the protocol leaking value and more about rewards being completely wiped and lost forever. I would argue, the user's assets at this point in time DO include all unpaid rewards, so it is perfectly reasonable to treat this as high risk.\n\npauliax (judge) commented(https://github.com/code-423n4/2022-03-biconomy-findings/issues/135#issuecomment-1145289008):\n  Agree that the boundaries are not very clear, this issue might fall somewhere between Medium and High severities. But my initial thought was similar to that of @0xleastwood, the rewards already belong to the user, and losing them will make the user lose on time and other opportunities. Also, this is not a hypothetical attack scenario, but a very real valid execution path, thus I think a high severity is fine here.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/ILPToken.sol\";\nimport \"./interfaces/ITokenManager.sol\";\nimport \"./interfaces/IWhiteListPeriodManager.sol\";\nimport \"./interfaces/ILiquidityPool.sol\";\n\ncontract LiquidityProviders is\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable,\n    OwnableUpgradeable,\n    Pausable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 public constant BASE_DIVISOR = 10**18;\n\n    ILPToken internal lpToken;\n    ILiquidityPool internal liquidityPool;\n    ITokenManager internal tokenManager;\n    IWhiteListPeriodManager internal whiteListPeriodManager;\n\n    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);\n    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);\n    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);\n    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);\n    event EthReceived(address indexed sender, uint256 value);\n    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);\n\n    // LP Fee Distribution\n    mapping(address => uint256) public totalReserve; // Include Liquidity + Fee accumulated\n    mapping(address => uint256) public totalLiquidity; // Include Liquidity only\n    mapping(address => uint256) public currentLiquidity; // Include current liquidity, updated on every in and out transfer\n    mapping(address => uint256) public totalLPFees;\n    mapping(address => uint256) public totalSharesMinted;\n\n    /**\n     * @dev Modifier for checking to validate a NFTId and it's ownership\n     * @param _tokenId token id to validate\n     * @param _transactor typically msgSender(), passed to verify against owner of _tokenId\n     */\n    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {\n        (address token, , ) = lpToken.tokenMetadata(_tokenId);\n        require(lpToken.exists(_tokenId), \"ERR__TOKEN_DOES_NOT_EXIST\");\n        require(lpToken.ownerOf(_tokenId) == _transactor, \"ERR__TRANSACTOR_DOES_NOT_OWN_NFT\");\n        _;\n    }\n\n    /**\n     * @dev Modifier for checking if msg.sender in liquiditypool\n     */\n    modifier onlyLiquidityPool() {\n        require(_msgSender() == address(liquidityPool), \"ERR__UNAUTHORIZED\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(_isSupportedToken(tokenAddress), \"Token not supported\");\n        _;\n    }\n\n    /**\n     * @dev initalizes the contract, acts as constructor\n     * @param _trustedForwarder address of trusted forwarder\n     */\n    function initialize(\n        address _trustedForwarder,\n        address _lpToken,\n        address _tokenManager,\n        address _pauser\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        __ReentrancyGuard_init();\n        _setLPToken(_lpToken);\n        _setTokenManager(_tokenManager);\n    }\n\n    function _isSupportedToken(address _token) internal view returns (bool) {\n        return tokenManager.getTokensInfo(_token).supportedToken;\n    }\n\n    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {\n        return totalReserve[tokenAddress];\n    }\n\n    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {\n        return totalLiquidity[tokenAddress];\n    }\n\n    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {\n        return totalLPFees[tokenAddress];\n    }\n\n    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {\n        return currentLiquidity[tokenAddress];\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of NFT Contract\n     * @param _lpToken address of lpToken\n     */\n    function setLpToken(address _lpToken) external onlyOwner {\n        _setLPToken(_lpToken);\n    }\n\n    /**\n     * Internal method to set LP token contract.\n     */\n    function _setLPToken(address _lpToken) internal {\n        lpToken = ILPToken(_lpToken);\n    }\n\n    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {\n        _increaseCurrentLiquidity(tokenAddress, amount);\n    }\n\n    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {\n        _decreaseCurrentLiquidity(tokenAddress, amount);\n    }\n\n    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {\n        currentLiquidity[tokenAddress] += amount;\n        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);\n    }\n\n    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {\n        currentLiquidity[tokenAddress] -= amount;\n        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);\n    }\n\n    /**\n     * Public method to set TokenManager contract.\n     */\n    function setTokenManager(address _tokenManager) external onlyOwner {\n        _setTokenManager(_tokenManager);\n    }\n\n    /**\n     * Internal method to set TokenManager contract.\n     */\n    function _setTokenManager(address _tokenManager) internal {\n        tokenManager = ITokenManager(_tokenManager);\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of WhiteListPeriodManager Contract\n     * @param _whiteListPeriodManager address of WhiteListPeriodManager\n     */\n    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {\n        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of LiquidityPool Contract\n     * @param _liquidityPool address of LiquidityPool\n     */\n    function setLiquidityPool(address _liquidityPool) external onlyOwner {\n        liquidityPool = ILiquidityPool(_liquidityPool);\n    }\n\n    /**\n     * @dev Returns price of Base token in terms of LP Shares\n     * @param _baseToken address of baseToken\n     * @return Price of Base token in terms of LP Shares\n     */\n    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {\n        uint256 supply = totalSharesMinted[_baseToken];\n        if (supply > 0) {\n            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];\n        }\n        return BASE_DIVISOR;\n    }\n\n    /**\n     * @dev Converts shares to token amount\n     */\n\n    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {\n        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];\n    }\n\n    /**\n     * @dev Returns the fee accumulated on a given NFT\n     * @param _nftId Id of NFT\n     * @return accumulated fee\n     */\n    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {\n        require(lpToken.exists(_nftId), \"ERR__INVALID_NFT\");\n\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n\n        if (totalNFTShares == 0) {\n            return 0;\n        }\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        uint256 lpFeeAccumulated;\n\n        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount \n        if(nftSuppliedLiquidity > eligibleLiquidity) {\n            lpFeeAccumulated = 0;\n        } else {\n            unchecked {\n                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n            }\n        }\n        return lpFeeAccumulated;\n    }\n\n    /**\n     * @dev Records fee being added to total reserve\n     * @param _token Address of Token for which LP fee is being added\n     * @param _amount Amount being added\n     */\n    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {\n        totalReserve[_token] += _amount;\n        totalLPFees[_token] += _amount;\n        emit FeeAdded(_token, _amount);\n    }\n\n    /**\n     * @dev Internal function to add liquidity to a new NFT\n     */\n    function _addLiquidity(address _token, uint256 _amount) internal {\n        require(_amount > 0, \"ERR__AMOUNT_IS_0\");\n        uint256 nftId = lpToken.mint(_msgSender());\n        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);\n        lpToken.updateTokenMetadata(nftId, data);\n        _increaseLiquidity(nftId, _amount);\n    }\n\n    /**\n     * @dev Function to mint a new NFT for a user, add native liquidity and store the\n     *      record in the newly minted NFT\n     */\n    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {\n        (bool success, ) = address(liquidityPool).call{value: msg.value}(\"\");\n        require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        _addLiquidity(NATIVE, msg.value);\n    }\n\n    /**\n     * @dev Function to mint a new NFT for a user, add token liquidity and store the\n     *      record in the newly minted NFT\n     * @param _token Address of token for which liquidity is to be added\n     * @param _amount Amount of liquidity added\n     */\n    function addTokenLiquidity(address _token, uint256 _amount)\n        external\n        nonReentrant\n        tokenChecks(_token)\n        whenNotPaused\n    {\n        require(_token != NATIVE, \"ERR__WRONG_FUNCTION\");\n        require(\n            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,\n            \"ERR__INSUFFICIENT_ALLOWANCE\"\n        );\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);\n        _addLiquidity(_token, _amount);\n    }\n\n    /**\n     * @dev Internal helper function to increase liquidity in a given NFT\n     */\n    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {\n        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);\n\n        require(_amount > 0, \"ERR__AMOUNT_IS_0\");\n        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);\n\n        uint256 mintedSharesAmount;\n        // Adding liquidity in the pool for the first time\n        if (totalReserve[token] == 0) {\n            mintedSharesAmount = BASE_DIVISOR * _amount;\n        } else {\n            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];\n        }\n\n        require(mintedSharesAmount >= BASE_DIVISOR, \"ERR__AMOUNT_BELOW_MIN_LIQUIDITY\");\n\n        totalLiquidity[token] += _amount;\n        totalReserve[token] += _amount;\n        totalSharesMinted[token] += mintedSharesAmount;\n\n        LpTokenMetadata memory data = LpTokenMetadata(\n            token,\n            totalSuppliedLiquidity + _amount,\n            totalShares + mintedSharesAmount\n        );\n        lpToken.updateTokenMetadata(_nftId, data);\n\n        // Increase the current liquidity\n        _increaseCurrentLiquidity(token, _amount);\n        emit LiquidityAdded(token, _amount, _msgSender());\n    }\n\n    /**\n     * @dev Function to allow LPs to add ERC20 token liquidity to existing NFT\n     * @param _nftId ID of NFT for updating the balances\n     * @param _amount Token amount to be added\n     */\n    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {\n        (address token, , ) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(token), \"ERR__TOKEN_NOT_SUPPORTED\");\n        require(token != NATIVE, \"ERR__WRONG_FUNCTION\");\n        require(\n            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,\n            \"ERR__INSUFFICIENT_ALLOWANCE\"\n        );\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);\n        _increaseLiquidity(_nftId, _amount);\n    }\n\n    /**\n     * @dev Function to allow LPs to add native token liquidity to existing NFT\n     */\n    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {\n        (address token, , ) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(NATIVE), \"ERR__TOKEN_NOT_SUPPORTED\");\n        require(token == NATIVE, \"ERR__WRONG_FUNCTION\");\n        (bool success, ) = address(liquidityPool).call{value: msg.value}(\"\");\n        require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        _increaseLiquidity(_nftId, msg.value);\n    }\n\n    /**\n     * @dev Function to allow LPs to remove their liquidity from an existing NFT\n     *      Also automatically redeems any earned fee\n     */\n    function removeLiquidity(uint256 _nftId, uint256 _amount)\n        external\n        nonReentrant\n        onlyValidLpToken(_nftId, _msgSender())\n        whenNotPaused\n    {\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");\n\n        require(_amount != 0, \"ERR__INVALID_AMOUNT\");\n        require(nftSuppliedLiquidity >= _amount, \"ERR__INSUFFICIENT_LIQUIDITY\");\n        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);\n        // Claculate how much shares represent input amount\n        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);\n\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        \n        uint256 lpFeeAccumulated;\n\n        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount \n        if(nftSuppliedLiquidity > eligibleLiquidity) {\n            lpFeeAccumulated = 0;\n        } else {\n            unchecked {\n                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n            }\n        }\n        // Calculate amount of lp shares that represent accumulated Fee\n        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);\n\n        totalLPFees[_tokenAddress] -= lpFeeAccumulated;\n        uint256 amountToWithdraw = _amount + lpFeeAccumulated;\n        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;\n\n        // Handle round off errors to avoid dust lp token in contract\n        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {\n            lpSharesToBurn = totalNFTShares;\n        }\n        totalReserve[_tokenAddress] -= amountToWithdraw;\n        totalLiquidity[_tokenAddress] -= _amount;\n        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;\n\n        _decreaseCurrentLiquidity(_tokenAddress, _amount);\n\n        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);\n\n        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);\n\n        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());\n    }\n\n    /**\n     * @dev Function to allow LPs to claim the fee earned on their NFT\n     * @param _nftId ID of NFT where liquidity is recorded\n     */\n    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");\n\n        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);\n\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n        require(lpFeeAccumulated > 0, \"ERR__NO_REWARDS_TO_CLAIM\");\n        // Calculate amount of lp shares that represent accumulated Fee\n        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;\n\n        totalReserve[_tokenAddress] -= lpFeeAccumulated;\n        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;\n        totalLPFees[_tokenAddress] -= lpFeeAccumulated;\n\n        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);\n        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);\n        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);\n    }\n\n    /**\n     * @dev Internal Function to burn LP shares and remove liquidity from existing NFT\n     */\n    function _burnSharesFromNft(\n        uint256 _nftId,\n        uint256 _shares,\n        uint256 _tokenAmount,\n        address _tokenAddress\n    ) internal {\n        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);\n        nftShares -= _shares;\n        nftSuppliedLiquidity -= _tokenAmount;\n\n        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));\n    }\n\n    function _transferFromLiquidityPool(\n        address _tokenAddress,\n        address _receiver,\n        uint256 _tokenAmount\n    ) internal {\n        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);\n    }\n\n    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {\n        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);\n        return totalSuppliedLiquidity;\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit EthReceived(_msgSender(), msg.value);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/ILPToken.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\n\ncontract HyphenLiquidityFarming is\n    Initializable,\n    ERC2771ContextUpgradeable,\n    OwnableUpgradeable,\n    Pausable,\n    ReentrancyGuardUpgradeable,\n    IERC721ReceiverUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    ILPToken public lpToken;\n    ILiquidityProviders public liquidityProviders;\n\n    struct NFTInfo {\n        address payable staker;\n        uint256 rewardDebt;\n        uint256 unpaidRewards;\n        bool isStaked;\n    }\n\n    struct PoolInfo {\n        uint256 accTokenPerShare;\n        uint256 lastRewardTime;\n    }\n\n    struct RewardsPerSecondEntry {\n        uint256 rewardsPerSecond;\n        uint256 timestamp;\n    }\n\n    /// @notice Mapping to track the rewarder pool.\n    mapping(address => PoolInfo) public poolInfo;\n\n    /// @notice Info of each NFT that is staked.\n    mapping(uint256 => NFTInfo) public nftInfo;\n\n    /// @notice Reward rate per base token\n    //mapping(address => uint256) public rewardPerSecond;\n\n    /// @notice Reward Token\n    mapping(address => address) public rewardTokens;\n\n    /// @notice Staker => NFTs staked\n    mapping(address => uint256[]) public nftIdsStaked;\n\n    /// @notice Token => Total Shares Staked\n    mapping(address => uint256) public totalSharesStaked;\n\n    /// @notice Token => Reward Rate Updation history\n    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;\n\n    uint256 private constant ACC_TOKEN_PRECISION = 1e12;\n    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);\n    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);\n    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);\n    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);\n    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);\n    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);\n    event LogNativeReceived(address indexed sender, uint256 value);\n\n    function initialize(\n        address _trustedForwarder,\n        address _pauser,\n        ILiquidityProviders _liquidityProviders,\n        ILPToken _lpToken\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        __ReentrancyGuard_init();\n        liquidityProviders = _liquidityProviders;\n        lpToken = _lpToken;\n    }\n\n    /// @notice Initialize the rewarder pool.\n    /// @param _baseToken Base token to be used for the rewarder pool.\n    /// @param _rewardToken Reward token to be used for the rewarder pool.\n    /// @param _rewardPerSecond Reward rate per base token.\n    function initalizeRewardPool(\n        address _baseToken,\n        address _rewardToken,\n        uint256 _rewardPerSecond\n    ) external onlyOwner {\n        require(rewardTokens[_baseToken] == address(0), \"ERR__POOL_ALREADY_INITIALIZED\");\n        require(_baseToken != address(0), \"ERR__BASE_TOKEN_IS_ZERO\");\n        require(_rewardToken != address(0), \"ERR_REWARD_TOKEN_IS_ZERO\");\n        rewardTokens[_baseToken] = _rewardToken;\n        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));\n        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);\n    }\n\n    function _sendErc20AndGetSentAmount(\n        IERC20Upgradeable _token,\n        uint256 _amount,\n        address _to\n    ) private returns (uint256) {\n        uint256 recepientBalance = _token.balanceOf(_to);\n        _token.safeTransfer(_to, _amount);\n        return _token.balanceOf(_to) - recepientBalance;\n    }\n\n    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.\n    /// @param _nftId NFT ID that is being locked\n    /// @param _to Address to which rewards will be credited.\n    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {\n        NFTInfo storage nft = nftInfo[_nftId];\n        require(nft.isStaked, \"ERR__NFT_NOT_STAKED\");\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        PoolInfo memory pool = updatePool(baseToken);\n        uint256 pending;\n        uint256 amountSent;\n        if (amount > 0) {\n            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;\n            if (rewardTokens[baseToken] == NATIVE) {\n                uint256 balance = address(this).balance;\n                if (pending > balance) {\n                    unchecked {\n                        nft.unpaidRewards = pending - balance;\n                    }\n                    (bool success, ) = _to.call{value: balance}(\"\");\n                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                    amountSent = balance;\n                } else {\n                    nft.unpaidRewards = 0;\n                    (bool success, ) = _to.call{value: pending}(\"\");\n                    require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n                    amountSent = pending;\n                }\n            } else {\n                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);\n                uint256 balance = rewardToken.balanceOf(address(this));\n                if (pending > balance) {\n                    unchecked {\n                        nft.unpaidRewards = pending - balance;\n                    }\n                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);\n                } else {\n                    nft.unpaidRewards = 0;\n                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);\n                }\n            }\n        }\n        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);\n    }\n\n    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.\n    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {\n        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));\n        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);\n    }\n\n    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract\n    /// @param _token Token to reclaim, use 0x00 for Ethereum\n    /// @param _amount Amount of tokens to reclaim\n    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,\n    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,\n    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.\n    function reclaimTokens(\n        address _token,\n        uint256 _amount,\n        address payable _to\n    ) external nonReentrant onlyOwner {\n        require(_to != address(0), \"ERR__TO_IS_ZERO\");\n        if (_token == NATIVE) {\n            (bool success, ) = payable(_to).call{value: _amount}(\"\");\n            require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        } else {\n            IERC20Upgradeable(_token).safeTransfer(_to, _amount);\n        }\n    }\n\n    /// @notice Deposit LP tokens\n    /// @param _nftId LP token nftId to deposit.\n    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        address msgSender = _msgSender();\n\n        require(\n            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),\n            \"ERR__NOT_APPROVED\"\n        );\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        require(rewardTokens[baseToken] != address(0), \"ERR__POOL_NOT_INITIALIZED\");\n        require(rewardRateLog[baseToken].length != 0, \"ERR__POOL_NOT_INITIALIZED\");\n\n        NFTInfo storage nft = nftInfo[_nftId];\n        require(!nft.isStaked, \"ERR__NFT_ALREADY_STAKED\");\n\n        lpToken.safeTransferFrom(msgSender, address(this), _nftId);\n\n        PoolInfo memory pool = updatePool(baseToken);\n        nft.isStaked = true;\n        nft.staker = _to;\n        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;\n\n        nftIdsStaked[_to].push(_nftId);\n        totalSharesStaked[baseToken] += amount;\n\n        emit LogDeposit(msgSender, baseToken, _nftId);\n    }\n\n    /// @notice Withdraw LP tokens\n    /// @param _nftId LP token nftId to withdraw.\n    /// @param _to The receiver of `amount` withdraw benefit.\n    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        address msgSender = _msgSender();\n        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;\n        uint256 index;\n        for (index = 0; index < nftsStakedLength; ++index) {\n            if (nftIdsStaked[msgSender][index] == _nftId) {\n                break;\n            }\n        }\n\n        require(index != nftsStakedLength, \"ERR__NFT_NOT_STAKED\");\n        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];\n        nftIdsStaked[msgSender].pop();\n\n        _sendRewardsForNft(_nftId, _to);\n        delete nftInfo[_nftId];\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n        totalSharesStaked[baseToken] -= amount;\n\n        lpToken.safeTransferFrom(address(this), msgSender, _nftId);\n\n        emit LogWithdraw(msgSender, baseToken, _nftId, _to);\n    }\n\n    /// @notice Extract all rewards without withdrawing LP tokens\n    /// @param _nftId LP token nftId for which rewards are to be withdrawn\n    /// @param _to The receiver of withdraw benefit.\n    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {\n        require(nftInfo[_nftId].staker == _msgSender(), \"ERR__NOT_OWNER\");\n        _sendRewardsForNft(_nftId, _to);\n    }\n\n    /// @notice Calculates an up to date value of accTokenPerShare\n    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted\n    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {\n        uint256 accumulator = 0;\n        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;\n        uint256 counter = block.timestamp;\n        uint256 i = rewardRateLog[_baseToken].length - 1;\n        while (true) {\n            if (lastUpdatedTime >= counter) {\n                break;\n            }\n            unchecked {\n                accumulator +=\n                    rewardRateLog[_baseToken][i].rewardsPerSecond *\n                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));\n            }\n            counter = rewardRateLog[_baseToken][i].timestamp;\n            if (i == 0) {\n                break;\n            }\n            --i;\n        }\n\n        // We know that during all the periods that were included in the current iterations,\n        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the\n        // updates to the pool that happened after the lastUpdatedTime.\n        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];\n        return accumulator + poolInfo[_baseToken].accTokenPerShare;\n    }\n\n    /// @notice View function to see pending Token\n    /// @param _nftId NFT for which pending tokens are to be viewed\n    /// @return pending reward for a given user.\n    function pendingToken(uint256 _nftId) external view returns (uint256) {\n        NFTInfo storage nft = nftInfo[_nftId];\n        if (!nft.isStaked) {\n            return 0;\n        }\n\n        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);\n        amount /= liquidityProviders.BASE_DIVISOR();\n\n        PoolInfo memory pool = poolInfo[baseToken];\n        uint256 accToken1PerShare = pool.accTokenPerShare;\n        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {\n            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);\n        }\n        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @return pool Returns the pool that was updated.\n    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {\n        pool = poolInfo[_baseToken];\n        if (block.timestamp > pool.lastRewardTime) {\n            if (totalSharesStaked[_baseToken] > 0) {\n                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);\n            }\n            pool.lastRewardTime = block.timestamp;\n            poolInfo[_baseToken] = pool;\n            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);\n        }\n    }\n\n    /// @notice View function to see the tokens staked by a given user.\n    /// @param _user Address of user.\n    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {\n        nftIds = nftIdsStaked[_user];\n    }\n\n    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {\n        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit LogNativeReceived(_msgSender(), msg.value);\n    }\n\n    function max(uint256 _a, uint256 _b) private pure returns (uint256) {\n        return _a >= _b ? _a : _b;\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidityProviders.sol",
            "LiquidityFarming.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\nfunction getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {\n    uint256 accumulator = 0;\n    uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;\n    uint256 counter = block.timestamp;\n    uint256 i = rewardRateLog[_baseToken].length 1;\n    while (true) {\n        if (lastUpdatedTime = counter) {\n            break;\n        }\n        unchecked {\n            accumulator +=\n                rewardRateLog[_baseToken][i].rewardsPerSecond *\n                (counter max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));\n        }\n        counter = rewardRateLog[_baseToken][i].timestamp;\n        if (i == 0) {\n            break;\n        }\n        --i;\n    }\n\n    // We know that during all the periods that were included in the current iterations,\n    // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the\n    // updates to the pool that happened after the lastUpdatedTime.\n    accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];\n    return accumulator + poolInfo[_baseToken].accTokenPerShare;\n}\n",
                    "//solidity\nuint256 mintedSharesAmount;\n// Adding liquidity in the pool for the first time\nif (totalReserve[token] == 0) {\n    mintedSharesAmount = BASE_DIVISOR * _amount;\n} else {\n    mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];\n}\n"
                ],
                "Type": " Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss",
                "Description": "\nLiquidityFarming.sol#L265-L291(https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L265-L291)<br\n\nsolidity\nfunction getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {\n    uint256 accumulator = 0;\n    uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;\n    uint256 counter = block.timestamp;\n    uint256 i = rewardRateLog[_baseToken].length 1;\n    while (true) {\n        if (lastUpdatedTime = counter) {\n            break;\n        }\n        unchecked {\n            accumulator +=\n                rewardRateLog[_baseToken][i].rewardsPerSecond *\n                (counter max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));\n        }\n        counter = rewardRateLog[_baseToken][i].timestamp;\n        if (i == 0) {\n            break;\n        }\n        --i;\n    }\n\n    // We know that during all the periods that were included in the current iterations,\n    // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the\n    // updates to the pool that happened after the lastUpdatedTime.\n    accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];\n    return accumulator + poolInfo[_baseToken].accTokenPerShare;\n}\n\n\nLiquidityProviders.sol#L286-L292(https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L286-L292)<br\n\nsolidity\nuint256 mintedSharesAmount;\n// Adding liquidity in the pool for the first time\nif (totalReserve[token] == 0) {\n    mintedSharesAmount = BASE_DIVISOR * _amount;\n} else {\n    mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];\n}\n\n\nIn HyphenLiquidityFarming, the accTokenPerShare is calculated based on the total staked shares.\n\nHowever, as the mintedSharesAmount can easily become very large on LiquidityProviders.sol, all the users can lose their rewards due to precision loss.\n\n\nGiven:\n\n*   rewardsPerSecond is 10e18;\n*   lastRewardTime is 24 hrs ago;\n\nThen:\n\n1.  Alice addTokenLiquidity() with 1e8 * 1e18 XYZ on B-Chain, totalSharesMinted == 1e44;\n2.  Alice deposit() to HyphenLiquidityFarming, totalSharesStaked == 1e44;\n3.  24 hrs later, Alice tries to claim the rewards.\n\naccumulator = rewardsPerSecond * 24 hours == 864000e18 == 8.64e23\n\nExpected Results: As the sole staker, Alice should get all the 864000e18 rewards.\n\nActual Results: Alice received 0 rewards.\n\nThat's because when totalSharesStaked  1e36, accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken]; will be round down to 0.\n\nWhen the totalSharesStaked is large enough, all users will lose their rewards due to precision loss.\n\n",
                "Repair": "\n1.  Consider lowering the BASE_DIVISOR so that the initial share price can be higher;\n2.  Consider making ACC_TOKEN_PRECISION larger to prevent precision loss;\n\nSee also the Recommendation on Issue #139(https://github.com/code-423n4/2022-03-biconomy-findings/issues/139).\n\nankurdubey521 (Biconomy) confirmed(https://github.com/code-423n4/2022-03-biconomy-findings/issues/140)\n\npauliax (judge) commented(https://github.com/code-423n4/2022-03-biconomy-findings/issues/140#issuecomment-1120958989):\n  Great find, probably deserves a severity of high.\n\n\n\n*\n\n\n"
            }
        ]
    }
]