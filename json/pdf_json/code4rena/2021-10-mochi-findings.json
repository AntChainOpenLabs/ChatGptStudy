[
    {
        "Code": "// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    /// storage variables\n    uint256 public override deposits;\n    uint256 public override debts;\n    int256 public override claimable;\n\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\n    ///E.g. If the stability fees are 10% for a year\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\n\n    /// result\n    uint256 public liquidated;\n\n    mapping(uint256 => Detail) public override details;\n    mapping(uint256 => uint256) public lastDeposit;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n\n    modifier wait(uint256 _id) {\n        require(\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\n            \"!wait\"\n        );\n        accrueDebt(_id);\n        _;\n    }\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function initialize(address _asset) external override initializer {\n        asset = IERC20(_asset);\n        debtIndex = 1e18;\n        lastAccrued = block.timestamp;\n    }\n\n    function liveDebtIndex() public view override returns (uint256 index) {\n        return\n            engine.mochiProfile().calculateFeeIndex(\n                address(asset),\n                debtIndex,\n                lastAccrued\n            );\n    }\n\n    function status(uint256 _id) public view override returns (Status) {\n        return details[_id].status;\n    }\n\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        require(details[_id].status != Status.Invalid, \"invalid\");\n        uint256 newIndex = liveDebtIndex();\n        return (details[_id].debt * newIndex) / details[_id].debtIndex;\n    }\n\n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function increase(\n        uint256 _id,\n        uint256 _deposits,\n        uint256 _borrows,\n        address _referrer,\n        bytes memory _data\n    ) external {\n        if (_id == type(uint256).max) {\n            // mint if _id is -1\n            _id = mint(msg.sender, _referrer);\n        }\n        if (_deposits > 0) {\n            deposit(_id, _deposits);\n        }\n        if (_borrows > 0) {\n            borrow(_id, _borrows, _data);\n        }\n    }\n\n    function decrease(\n        uint256 _id,\n        uint256 _withdraws,\n        uint256 _repays,\n        bytes memory _data\n    ) external {\n        if (_repays > 0) {\n            repay(_id, _repays);\n        }\n        if (_withdraws > 0) {\n            withdraw(_id, _withdraws, _data);\n        }\n    }\n\n    function mint(address _recipient, address _referrer)\n        public\n        returns (uint256 id)\n    {\n        id = engine.nft().mint(address(asset), _recipient);\n        details[id].debtIndex = liveDebtIndex();\n        details[id].status = Status.Idle;\n        details[id].referrer = _referrer;\n    }\n\n    /// anyone can deposit collateral to given id\n    /// it will even allow depositing to liquidated vault so becareful when depositing\n    function deposit(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        // should it be able to deposit if invalid?\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        require(\n            details[_id].status == Status.Idle ||\n                details[_id].status == Status.Collaterized ||\n                details[_id].status == Status.Active,\n            \"!depositable\"\n        );\n        lastDeposit[_id] = block.timestamp;\n        deposits += _amount;\n        details[_id].collateral += _amount;\n        if (details[_id].status == Status.Idle) {\n            details[_id].status = Status.Collaterized;\n        }\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// should only be able to withdraw if status is not liquidatable\n    function withdraw(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override wait(_id) {\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        require(\n            !_liquidatable(\n                details[_id].collateral - _amount,\n                price,\n                details[_id].debt\n            ),\n            \"!healthy\"\n        );\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = (details[_id].collateral - _amount)\n            .multiply(cf)\n            .multiply(price);\n        require(details[_id].debt <= maxMinted, \">cf\");\n        deposits -= _amount;\n        details[_id].collateral -= _amount;\n        if (details[_id].collateral == 0) {\n            details[_id].status = Status.Idle;\n        }\n        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n\n    /// someone sends usdm to this address and repays the debt\n    /// will payback the leftover usdm\n    function repay(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        if (_amount > details[_id].debt) {\n            _amount = details[_id].debt;\n        }\n        require(_amount > 0, \"zero\");\n        if (debts < _amount) {\n            // safe gaurd to some underflows\n            debts = 0;\n        } else {\n            debts -= _amount;\n        }\n        details[_id].debt -= _amount;\n        if (details[_id].debt == 0) {\n            details[_id].status = Status.Collaterized;\n        }\n        engine.usdm().transferFrom(msg.sender, address(this), _amount);\n        engine.usdm().burn(_amount);\n    }\n\n    function liquidate(\n        uint256 _id,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external override updateDebt(_id) {\n        require(msg.sender == address(engine.liquidator()), \"!liquidator\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        float memory price = engine.cssr().getPrice(address(asset));\n        require(\n            _liquidatable(details[_id].collateral, price, currentDebt(_id)),\n            \"healthy\"\n        );\n\n        debts -= _usdm;\n\n        details[_id].collateral -= _collateral;\n        details[_id].debt -= _usdm;\n\n        asset.cheapTransfer(msg.sender, _collateral);\n    }\n\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\n    /// @notice should return false if _collateral * liquidationLimit < _debt\n    function _liquidatable(\n        uint256 _collateral,\n        float memory _price,\n        uint256 _debt\n    ) internal view returns (bool) {\n        float memory lf = engine.mochiProfile().liquidationFactor(\n            address(asset)\n        );\n        // when debt is lower than liquidation value, it can be liquidated\n        return _collateral.multiply(lf) < _debt.divide(_price);\n    }\n\n    function liquidatable(uint256 _id) external view returns (bool) {\n        float memory price = engine.cssr().getPrice(address(asset));\n        return _liquidatable(details[_id].collateral, price, currentDebt(_id));\n    }\n\n    function claim() external updateDebt(type(uint256).max) {\n        require(claimable > 0, \"!claimable\");\n        // reserving 25% to prevent potential risks\n        uint256 toClaim = (uint256(claimable) * 75) / 100;\n        mintFeeToPool(toClaim, address(0));\n    }\n\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\n        claimable -= int256(_amount);\n        if (address(0) != _referrer) {\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\n            engine.referralFeePool().addReward(_referrer);\n        } else {\n            engine.minter().mint(address(engine.treasury()), _amount);\n        }\n    }\n\n    // Flash Loan\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(asset), \"!supported\");\n        return asset.balanceOf(address(this));\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(asset), \"!supported\");\n        return (_amount * 1337) / 1000000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(asset), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        asset.cheapTransfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        asset.cheapTransferFrom(address(_receiver), address(this), _amount);\n        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\n\ncontract USDM is ERC20, IUSDM {\n    IMochiEngine public immutable engine;\n\n    uint256 private constant SCALE = 1e18;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    constructor(address _engine) ERC20(\"USDM\", \"USDM\") {\n        engine = IMochiEngine(_engine);\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == address(engine.minter()), \"!minter\");\n        _;\n    }\n\n    function mint(address _recipient, uint256 _amount)\n        external\n        override\n        onlyMinter\n    {\n        _mint(_recipient, _amount);\n    }\n\n    function burn(uint256 _amount) external override {\n        _burn(msg.sender, _amount);\n    }\n\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(this), \"!this\");\n        return type(uint256).max - totalSupply();\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(this), \"!supported\");\n        return (_amount * ((1337 * SCALE) / 1000000)) / SCALE;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(this), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        _mint(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        _burn(address(_receiver), _amount);\n        _transfer(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiVault.sol",
            "usdm.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n    uint256 increasingDebt = (_amount * 1005) / 1000;\n",
                    "//solidity\ndetails[_id].debtIndex =\n    (details[_id].debtIndex * (totalDebt)) /\n    (details[_id].debt + _amount);\ndetails[_id].debt = totalDebt;\ndetails[_id].status = Status.Active;\ndebts += _amount;\n",
                    "python\ndeposit_amount = 1018\nbig_deposit = deposit_amount * 100000\nminter.functions.mint(user, big_deposit).transact()\n\ndai.functions.approve(vault.address, big_deposit + deposit_amount).transact()\n\n# create two positions\nvault.functions.mint(user, zero_address).transact()\nvault.functions.mint(user, zero_address).transact()\n\n# # borrow max amount\nvault.functions.increase(0, big_deposit, big_deposit, zero_address, '').transact()\nvault.functions.increase(1, deposit_amount, deposit_amount, zero_address, '').transact()\n\nvault_debt = vault.functions.debts().call()\n\n# ## This would clear out all debt in vault.\nrepay_amount = vault_debt + 1018\nusdm.functions.approve(vault.address, repay_amount).transact()\n\nvault.functions.repay(0, repay_amount).transact()\n\nprint('debt left:', vault.functions.debts().call())\n# ## All the positions would not be liquidated from now on\n\ndai_price = cssr_factory.functions.getPrice(dai.address).call()\ncssr_factory.functions.setPrice(dai.address, dai_price[0] // 10).transact()\n\n## this would revert\nliquidator.functions.triggerLiquidation(dai.address, 1).transact()\n"
                ],
                "Type": " Vault fails to track debt correctly that leads to bad debt",
                "Description": "\nIt's similar to the issue \"misuse amount as increasing debt in the vault contract\".\nSimilar issue in a different place that leads to different exploit patterns and severity.\n\nWhen users borrow usdm from a vault, the debt increases by the amount * 1.005.\n\nsolidity\n    uint256 increasingDebt = (_amount * 1005) / 1000;\n\n\nHowever, when the contract records the total debt it uses _amount instead of increasingDebt.\n\nsolidity\ndetails[_id].debtIndex =\n    (details[_id].debtIndex * (totalDebt)) /\n    (details[_id].debt + _amount);\ndetails[_id].debt = totalDebt;\ndetails[_id].status = Status.Active;\ndebts += _amount;\n\n\nMochiVault.sol L242-L249(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L242-L249)\n\nThe contract's debt is inconsistent with the total sum of all users' debt. The bias increases overtime and would break the vault at the end.\n\nFor simplicity, we assume there's only one user in the vault.\nExample:\n\n1.  User deposits 1.2 M worth of BTC and borrows 1M USDM.\n2.  The user's debt (details[_id].debt) would be 1.005 M as there's a .5 percent fee.\n3.  The contract's debt is 1M.\n4.  BTC price decrease by 20 percent\n5.  The liquidator tries to liquidate the position.\n6.  The liquidator repays 1.005 M and the contract tries to sub the debt by 1.005 M\n7.  The transaction is reverted as details[_id].debt -= _usdm; would raise exception.\n\ninaccurate accounting would lead to serious issues. I consider this a high-risk issue.\n\nThis is a web3.py script that a liquidation may fail.\n\npython\ndeposit_amount = 1018\nbig_deposit = deposit_amount * 100000\nminter.functions.mint(user, big_deposit).transact()\n\ndai.functions.approve(vault.address, big_deposit + deposit_amount).transact()\n\n# create two positions\nvault.functions.mint(user, zero_address).transact()\nvault.functions.mint(user, zero_address).transact()\n\n# # borrow max amount\nvault.functions.increase(0, big_deposit, big_deposit, zero_address, '').transact()\nvault.functions.increase(1, deposit_amount, deposit_amount, zero_address, '').transact()\n\nvault_debt = vault.functions.debts().call()\n\n# ## This would clear out all debt in vault.\nrepay_amount = vault_debt + 1018\nusdm.functions.approve(vault.address, repay_amount).transact()\n\nvault.functions.repay(0, repay_amount).transact()\n\nprint('debt left:', vault.functions.debts().call())\n# ## All the positions would not be liquidated from now on\n\ndai_price = cssr_factory.functions.getPrice(dai.address).call()\ncssr_factory.functions.setPrice(dai.address, dai_price[0] // 10).transact()\n\n## this would revert\nliquidator.functions.triggerLiquidation(dai.address, 1).transact()\n\n\n",
                "Repair": "I believe this is a mistake. Recommend to check the contract to make sure increasingDebt is used consistently.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/IFeePool.sol\";\nimport \"../interfaces/IUSDM.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract FeePoolV0 is IFeePool {\n    IMochiEngine public immutable engine;\n\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    address public crvVoterRewardPool;\n\n    uint256 public treasuryRatio;\n\n    uint256 public vMochiRatio;\n\n    uint256 public mochiShare;\n\n    uint256 public treasuryShare;\n\n    constructor(address _engine, address _uniswap) {\n        engine = IMochiEngine(_engine);\n        uniswapRouter = IUniswapV2Router02(_uniswap);\n        treasuryRatio = 20e16;\n        vMochiRatio = 80e16;\n    }\n\n    function updateReserve() external override {\n        uint256 newReserve = engine.usdm().balanceOf(address(this)) -\n            mochiShare -\n            treasuryShare;\n        treasuryShare += (newReserve * treasuryRatio) / 1e18;\n        mochiShare = engine.usdm().balanceOf(address(this)) - treasuryShare;\n    }\n\n    function changecrvVoterRewardPool(address _pool) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        crvVoterRewardPool = _pool;\n    }\n\n    function changeTreasuryRatio(uint256 _ratio) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        treasuryRatio = _ratio;\n    }\n\n    function changevMochiRatio(uint256 _ratio) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        vMochiRatio = _ratio;\n    }\n\n    // this will open up arb oppertunity for Mochi\n    // so we will not reward the caller, caller can benefit from flashbot\n    // should decide which market we should use UniV2?V3? BalancerV2?\n    function distributeMochi() external {\n        // buy Mochi with mochiShare\n        _buyMochi();\n        _shareMochi();\n    }\n\n    function _buyMochi() internal {\n        IUSDM usdm = engine.usdm();\n        address[] memory path = new address[](2);\n        path[0] = address(usdm);\n        path[1] = address(engine.mochi());\n        usdm.approve(address(uniswapRouter), mochiShare);\n        uniswapRouter.swapExactTokensForTokens(\n            mochiShare,\n            1,\n            path,\n            address(this),\n            type(uint256).max\n        );\n    }\n\n    function _shareMochi() internal {\n        IMochi mochi = engine.mochi();\n        uint256 mochiBalance = mochi.balanceOf(address(this));\n        // send Mochi to vMochi Vault\n        mochi.transfer(\n            address(engine.vMochi()),\n            (mochiBalance * vMochiRatio) / 1e18\n        );\n        // send Mochi to veCRV Holders\n        mochi.transfer(\n            crvVoterRewardPool,\n            (mochiBalance * (1e18 - vMochiRatio)) / 1e18\n        );\n        // flush mochiShare\n        mochiShare = 0;\n        treasuryShare = 0;\n    }\n\n    function sendToTreasury() external {\n        engine.usdm().transfer(engine.treasury(), treasuryShare);\n        treasuryShare = 0;\n    }\n}\n\n\n",
        "CodeNames": [
            "FeePoolV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction _shareMochi() internal {\n    IMochi mochi = engine.mochi();\n    uint256 mochiBalance = mochi.balanceOf(address(this));\n    // send Mochi to vMochi Vault\n    mochi.transfer(\n        address(engine.vMochi()),\n        (mochiBalance * vMochiRatio) / 1e18\n    );\n    // send Mochi to veCRV Holders\n    mochi.transfer(\n        crvVoterRewardPool,\n        (mochiBalance * (1e18 vMochiRatio)) / 1e18\n    );\n    // flush mochiShare\n    mochiShare = 0;\n    treasuryShare = 0;\n}\n"
                ],
                "Type": "  FeePoolV0.sol#distributeMochi()  will unexpectedly flush  treasuryShare , causing the protocol fee cannot be properly accounted for and collected",
                "Description": "\ndistributeMochi() will call _buyMochi() to convert mochiShare to Mochi token and call _shareMochi() to send Mochi to vMochi Vault and veCRV Holders. It wont touch the treasuryShare.\n\nHowever, in the current implementation, treasuryShare will be reset to 0. This is unexpected and will cause the protocol fee can not be properly accounted for and collected.\n\nFeePoolV0.sol#L79 L95(https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L79-L95)\n\nsolidity\nfunction _shareMochi() internal {\n    IMochi mochi = engine.mochi();\n    uint256 mochiBalance = mochi.balanceOf(address(this));\n    // send Mochi to vMochi Vault\n    mochi.transfer(\n        address(engine.vMochi()),\n        (mochiBalance * vMochiRatio) / 1e18\n    );\n    // send Mochi to veCRV Holders\n    mochi.transfer(\n        crvVoterRewardPool,\n        (mochiBalance * (1e18 vMochiRatio)) / 1e18\n    );\n    // flush mochiShare\n    mochiShare = 0;\n    treasuryShare = 0;\n}\n\n\nAnyone can call distributeMochi() and reset treasuryShare to 0, and then call updateReserve() to allocate part of the wrongfuly resetted treasuryShare to mochiShare and call distributeMochi().\n\nRepeat the steps above and the treasuryShare will be consumed to near zero, profits the vMochi Vault holders and veCRV Holders. The protocol suffers the loss of funds.\n\n",
                "Repair": "Change to:\n\nsolidity\nfunction _buyMochi() internal {\n    IUSDM usdm = engine.usdm();\n    address[] memory path = new address[(2);\n    path[0] = address(usdm);\n    path[1] = address(engine.mochi());\n    usdm.approve(address(uniswapRouter), mochiShare);\n    uniswapRouter.swapExactTokensForTokens(\n        mochiShare,\n        1,\n        path,\n        address(this),\n        type(uint256).max\n    );\n    // flush mochiShare\n    mochiShare = 0;\n}\n\nfunction _shareMochi() internal {\n    IMochi mochi = engine.mochi();\n    uint256 mochiBalance = mochi.balanceOf(address(this));\n    // send Mochi to vMochi Vault\n    mochi.transfer(\n        address(engine.vMochi()),\n        (mochiBalance * vMochiRatio) / 1e18\n    );\n    // send Mochi to veCRV Holders\n    mochi.transfer(\n        crvVoterRewardPool,\n        (mochiBalance * (1e18 vMochiRatio)) / 1e18\n    );\n}\n\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/114)\n\n\n"
            },
            {
                "Name": "H-12",
                "Location": [
                    "distributeMochi"
                ],
                "Type": " feePool is vulnerable to sandwich attack.",
                "Description": "\nThere's a permissionless function distributeMochi in FeePoolV0.sol L55-L62(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L55-L62). Since everyone can trigger this function, an attacker can launch a sandwich attack with flashloan to steal the funds.\n\nThe devs have mentioned this concern in the comment. An attacker can steal the funds with a flash loan attack.\n\nAttackers can steal all the funds in the pool. I consider this is a high-risk issue.\n\nFeePoolV0.sol#L55-L62(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L55-L62)\n\nPlease refer to yDai Incident(https://peckshield.medium.com/the-ydai-incident-analysis-forced-investment-2b8ac6058eb5) to check the severity of a harvest function without slippage control.\n\nPlease refer to Mushrooms-finance-theft(https://medium.com/immunefi/mushrooms-finance-theft-of-yield-bug-fix-postmortem-16bd6961388f) to check how likely this kind of attack might happen.\n\n",
                "Repair": "If the dev wants to make this a permissionless control, the contract should calculate a min return based on TWAP and check the slippage.\n\n\n### Comments:\nryuheimat (Mochi) disputed(https://github.com/code-423n4/2021-10-mochi-findings/issues/65#issuecomment-953031170):\n  I think this is same case as https://github.com/code-423n4/2021-10-mochi-findings/issues/60\n\nghoul-sol (judge) commented(https://github.com/code-423n4/2021-10-mochi-findings/issues/65#issuecomment-957027904):\n  The same attack, different part of the code. I'll keep them both.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IReferralFeePool.sol\";\n\ncontract ReferralFeePoolV0 is IReferralFeePool {\n    IMochiEngine public immutable engine;\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    uint256 public rewards;\n\n    mapping(address => uint256) public reward;\n\n    constructor(address _engine, address _uniswap) {\n        engine = IMochiEngine(_engine);\n        uniswapRouter = IUniswapV2Router02(_uniswap);\n    }\n\n    function addReward(address _recipient) external override {\n        uint256 newReward = engine.usdm().balanceOf(address(this)) - rewards;\n        reward[_recipient] += newReward;\n        rewards += newReward;\n    }\n\n    function claimRewardAsMochi() external {\n        IUSDM usdm = engine.usdm();\n        address[] memory path = new address[](2);\n        path[0] = address(usdm);\n        path[1] = uniswapRouter.WETH();\n        path[2] = address(engine.mochi());\n        usdm.approve(address(uniswapRouter), reward[msg.sender]);\n        // we are going to ingore the slippages here\n        uniswapRouter.swapExactTokensForTokens(\n            reward[msg.sender],\n            1,\n            path,\n            address(this),\n            type(uint256).max\n        );\n        engine.mochi().transfer(\n            msg.sender,\n            engine.mochi().balanceOf(address(this))\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/IFeePool.sol\";\nimport \"../interfaces/IUSDM.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract FeePoolV0 is IFeePool {\n    IMochiEngine public immutable engine;\n\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    address public crvVoterRewardPool;\n\n    uint256 public treasuryRatio;\n\n    uint256 public vMochiRatio;\n\n    uint256 public mochiShare;\n\n    uint256 public treasuryShare;\n\n    constructor(address _engine, address _uniswap) {\n        engine = IMochiEngine(_engine);\n        uniswapRouter = IUniswapV2Router02(_uniswap);\n        treasuryRatio = 20e16;\n        vMochiRatio = 80e16;\n    }\n\n    function updateReserve() external override {\n        uint256 newReserve = engine.usdm().balanceOf(address(this)) -\n            mochiShare -\n            treasuryShare;\n        treasuryShare += (newReserve * treasuryRatio) / 1e18;\n        mochiShare = engine.usdm().balanceOf(address(this)) - treasuryShare;\n    }\n\n    function changecrvVoterRewardPool(address _pool) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        crvVoterRewardPool = _pool;\n    }\n\n    function changeTreasuryRatio(uint256 _ratio) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        treasuryRatio = _ratio;\n    }\n\n    function changevMochiRatio(uint256 _ratio) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        vMochiRatio = _ratio;\n    }\n\n    // this will open up arb oppertunity for Mochi\n    // so we will not reward the caller, caller can benefit from flashbot\n    // should decide which market we should use UniV2?V3? BalancerV2?\n    function distributeMochi() external {\n        // buy Mochi with mochiShare\n        _buyMochi();\n        _shareMochi();\n    }\n\n    function _buyMochi() internal {\n        IUSDM usdm = engine.usdm();\n        address[] memory path = new address[](2);\n        path[0] = address(usdm);\n        path[1] = address(engine.mochi());\n        usdm.approve(address(uniswapRouter), mochiShare);\n        uniswapRouter.swapExactTokensForTokens(\n            mochiShare,\n            1,\n            path,\n            address(this),\n            type(uint256).max\n        );\n    }\n\n    function _shareMochi() internal {\n        IMochi mochi = engine.mochi();\n        uint256 mochiBalance = mochi.balanceOf(address(this));\n        // send Mochi to vMochi Vault\n        mochi.transfer(\n            address(engine.vMochi()),\n            (mochiBalance * vMochiRatio) / 1e18\n        );\n        // send Mochi to veCRV Holders\n        mochi.transfer(\n            crvVoterRewardPool,\n            (mochiBalance * (1e18 - vMochiRatio)) / 1e18\n        );\n        // flush mochiShare\n        mochiShare = 0;\n        treasuryShare = 0;\n    }\n\n    function sendToTreasury() external {\n        engine.usdm().transfer(engine.treasury(), treasuryShare);\n        treasuryShare = 0;\n    }\n}\n\n\n",
        "CodeNames": [
            "ReferralFeePoolV0.sol",
            "FeePoolV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nfunction claimRewardAsMochi() external {\n    IUSDM usdm = engine.usdm();\n    address[] memory path = new address[(2);\n    path[0] = address(usdm);\n    path[1] = uniswapRouter.WETH();\n    path[2] = address(engine.mochi());\n    usdm.approve(address(uniswapRouter), reward[msg.sender]);\n    // we are going to ingore the slippages here\n    uniswapRouter.swapExactTokensForTokens(\n        reward[msg.sender],\n        1,\n        path,\n        address(this),\n        type(uint256).max\n    );\n"
                ],
                "Type": "  ReferralFeePoolV0.sol#claimRewardAsMochi()  Array out of bound exception",
                "Description": "\nReferralFeePoolV0.sol#L28 L42(https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L42)\n\nsolidity\nfunction claimRewardAsMochi() external {\n    IUSDM usdm = engine.usdm();\n    address[] memory path = new address[(2);\n    path[0] = address(usdm);\n    path[1] = uniswapRouter.WETH();\n    path[2] = address(engine.mochi());\n    usdm.approve(address(uniswapRouter), reward[msg.sender]);\n    // we are going to ingore the slippages here\n    uniswapRouter.swapExactTokensForTokens(\n        reward[msg.sender],\n        1,\n        path,\n        address(this),\n        type(uint256).max\n    );\n\n\nIn ReferralFeePoolV0.sol#claimRewardAsMochi(), path is defined as an array of length 2 while it should be length 3.\n\nAs a result, at L33, an out-of-bound exception will be thrown and revert the transaction.\n\nclaimRewardAsMochi() will not work as expected so that all the referral fees cannot be claimed but stuck in the contract.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/97)\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@mochifi/library/contracts/Float.sol\";\n\nenum AssetClass {\n    Invalid,\n    Stable,\n    Alpha,\n    Gamma,\n    Delta,\n    Zeta,\n    Sigma,\n    Revoked\n}\n\ninterface IMochiProfile {\n    function assetClass(address _asset) external view returns (AssetClass);\n\n    function liquidityRequirement() external view returns (uint256);\n\n    function minimumDebt() external view returns (uint256);\n\n    function changeAssetClass(\n        address[] calldata _asset,\n        AssetClass[] calldata _class\n    ) external;\n\n    function changeLiquidityRequirement(uint256 _requirement) external;\n\n    function changeMinimumDebt(uint256 _debt) external;\n\n    function calculateFeeIndex(\n        address _asset,\n        uint256 _currentIndex,\n        uint256 _lastAccrued\n    ) external view returns (uint256);\n\n    function creditCap(address _asset) external view returns (uint256);\n\n    function delay() external view returns (uint256);\n\n    function liquidationFactor(address _asset)\n        external\n        view\n        returns (float memory);\n\n    function maxCollateralFactor(address _asset)\n        external\n        view\n        returns (float memory);\n\n    function stabilityFee(address _asset) external view returns (float memory);\n\n    function liquidationFee(address _asset)\n        external\n        view\n        returns (float memory);\n\n    function keeperFee(address _asset) external view returns (float memory);\n\n    function utilizationRatio(address _asset)\n        external\n        view\n        returns (float memory);\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMochiProfile.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\n///@notice this is where policies including some math is registered will be able to swap the profile when current profile is not suitable\n///@dev this profile is built with https://docs.google.com/spreadsheets/d/1T2WKpwj5QmueR7O8R9AXNbnHLc-rJ_-8DLdRI2eJZqA\ncontract MochiProfileV0 is IMochiProfile {\n    using Float for float;\n    using Float for uint256;\n    IMochiEngine public immutable engine;\n\n    uint256 public override liquidityRequirement;\n\n    uint256 public override minimumDebt;\n\n    mapping(address => AssetClass) internal _assetClass;\n\n    mapping(address => uint256) public override creditCap;\n\n    uint256 public immutable secPerYear;\n\n    uint256 public override delay;\n\n    constructor(address _engine) {\n        secPerYear = 31536000;\n        engine = IMochiEngine(_engine);\n\n        liquidityRequirement = 1000000e18; // 1million dollar\n        minimumDebt = 1000e18;\n        delay = 3 minutes;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == engine.governance(), \"!gov\");\n        _;\n    }\n\n    function assetClass(address _asset)\n        public\n        view\n        override\n        returns (AssetClass)\n    {\n        return _assetClass[_asset];\n    }\n\n    function changeLiquidityRequirement(uint256 _requirement)\n        external\n        override\n        onlyGov\n    {\n        liquidityRequirement = _requirement;\n    }\n\n    function registerAsset(address _asset) external {\n        uint256 liq = engine.cssr().getLiquidity(_asset);\n        require(liq >= liquidityRequirement, \"<liquidity\");\n        _register(_asset, AssetClass.Sigma);\n    }\n\n    function registerAssetByGov(\n        address[] calldata _asset,\n        AssetClass[] calldata _classes\n    ) external onlyGov {\n        for (uint256 i = 0; i < _asset.length; i++) {\n            _register(_asset[i], _classes[i]);\n            engine.vaultFactory().deployVault(_asset[i]);\n        }\n    }\n\n    function _register(address _asset, AssetClass _class) internal {\n        _assetClass[_asset] = _class;\n    }\n\n    function changeMinimumDebt(uint256 _debt) external override onlyGov {\n        minimumDebt = _debt;\n    }\n\n    function changeAssetClass(\n        address[] calldata _assets,\n        AssetClass[] calldata _classes\n    ) external override onlyGov {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _assetClass[_assets[i]] = _classes[i];\n        }\n    }\n\n    function changeCreditCap(\n        address[] calldata _assets,\n        uint256[] calldata _caps\n    ) external onlyGov {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            creditCap[_assets[i]] = _caps[i];\n        }\n    }\n\n    function setDelay(uint256 _delay) external onlyGov {\n        delay = _delay;\n    }\n\n    ///@notice The Collateral Factor at which the users vault will be liquidated\n    function liquidationFactor(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 95, denominator: 100});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 85, denominator: 100});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 80, denominator: 100});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 75, denominator: 100});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 65, denominator: 100});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 40, denominator: 100});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function riskFactor(address _asset) public view returns (uint256) {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return 1;\n        } else if (class == AssetClass.Alpha) {\n            return 2;\n        } else if (class == AssetClass.Gamma) {\n            return 3;\n        } else if (class == AssetClass.Delta) {\n            return 4;\n        } else if (class == AssetClass.Zeta) {\n            return 5;\n        } else if (class == AssetClass.Sigma) {\n            return 6;\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function maxCollateralFactor(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 90, denominator: 100});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 80, denominator: 100});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 75, denominator: 100});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 65, denominator: 100});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 55, denominator: 100});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 45, denominator: 100});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function baseFee() public pure returns (float memory) {\n        return float({numerator: 5, denominator: 1000});\n    }\n\n    function liquidationFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 45, denominator: 1000});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 100, denominator: 1000});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 125, denominator: 1000});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 150, denominator: 1000});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 175, denominator: 1000});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 200, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function keeperFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 5, denominator: 1000});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 10, denominator: 1000});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 15, denominator: 1000});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 20, denominator: 1000});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 25, denominator: 1000});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 30, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function maxFee(AssetClass _class) public pure returns (float memory) {\n        if (_class == AssetClass.Stable) {\n            return float({numerator: 10, denominator: 1000});\n        } else if (_class == AssetClass.Alpha) {\n            return float({numerator: 15, denominator: 1000});\n        } else if (_class == AssetClass.Gamma) {\n            return float({numerator: 20, denominator: 1000});\n        } else if (_class == AssetClass.Delta) {\n            return float({numerator: 21, denominator: 1000});\n        } else if (_class == AssetClass.Zeta) {\n            return float({numerator: 22, denominator: 1000});\n        } else if (_class == AssetClass.Sigma) {\n            return float({numerator: 23, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function stabilityFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        float memory base = baseFee();\n        AssetClass class = assetClass(_asset);\n        float memory max = maxFee(class);\n        float memory u = utilizationRatio(_asset);\n        if (u.gt(float({numerator: 1, denominator: 1}))) {\n            return max;\n        }\n        return base.add(max.sub(base).mul(u));\n    }\n\n    function calculateFeeIndex(\n        address _asset,\n        uint256 _currentIndex,\n        uint256 _lastAccrued\n    ) external view override returns (uint256) {\n        float memory feePerYear = stabilityFee(_asset);\n        uint256 timePassed = block.timestamp - _lastAccrued;\n        float memory feeAccumulated = feePerYear.mul(\n            float({numerator: timePassed, denominator: secPerYear})\n        );\n        return _currentIndex + _currentIndex.multiply(feeAccumulated);\n    }\n\n    ///@dev returns utilization ratio scaled with 1e18\n    function utilizationRatio(address _asset)\n        public\n        view\n        override\n        returns (float memory ratio)\n    {\n        IMochiVault vault = engine.vaultFactory().getVault(_asset);\n        uint256 debts = vault.debts();\n        uint256 cap = creditCap[_asset];\n        return float({numerator: debts, denominator: cap});\n    }\n}\n\n\n",
        "CodeNames": [
            "IMochiProfile.sol",
            "MochiProfileV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "keeperFee()",
                    "liquidationFee()",
                    "riskFactor()",
                    "maxCollateralFactor()",
                    "maxFee()",
                    "registerAsset()",
                    "liquidationFactor()"
                ],
                "Type": "  registerAsset()  can  overwrite _assetClass  value",
                "Description": "\nEveryone can call the function registerAsset() of MochiProfileV0.sol\nAssuming the liquidity for the asset is sufficient, registerAsset() will reset the _assetClass of an already registered asset to AssetClass.Sigma.\n\nWhen the _assetClass is changed to AssetClass.Sigma then liquidationFactor(), riskFactor(), maxCollateralFactor(), liquidationFee() keeperFee() maxFee() will also return a different value.\nThen the entire vault will behave differently.\nThe threshold for liquidation will also be different, possibly leading to a liquidation that isn't supposed to happen.\n\n",
                "Repair": "Add the following in function registerAsset():\nsolidity\nrequire(_assetClass[_asset] ==0,\"Already exists\");\n\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/20)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nstruct Detail {\n    Status status;\n    uint256 collateral;\n    uint256 debt;\n    uint256 debtIndex;\n    address referrer;\n}\n\nenum Status {\n    Invalid, // not minted\n    Idle, // debt = 0, collateral = 0\n    Collaterized, // debt = 0, collateral > 0\n    Active, // debt > 0, collateral > 0\n    Liquidated\n}\n\ninterface IMochiVault {\n    function liveDebtIndex() external view returns (uint256);\n\n    function details(uint256 _nftId)\n        external\n        view\n        returns (\n            Status,\n            uint256 collateral,\n            uint256 debt,\n            uint256 debtIndexe,\n            address refferer\n        );\n\n    function status(uint256 _nftId) external view returns (Status);\n\n    function asset() external view returns (IERC20);\n\n    function deposits() external view returns (uint256);\n\n    function debts() external view returns (uint256);\n\n    function claimable() external view returns (int256);\n\n    function currentDebt(uint256 _nftId) external view returns (uint256);\n\n    function initialize(address _asset) external;\n\n    function deposit(uint256 _nftId, uint256 _amount) external;\n\n    function withdraw(\n        uint256 _nftId,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n\n    function borrow(\n        uint256 _nftId,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n\n    function repay(uint256 _nftId, uint256 _amount) external;\n\n    function liquidate(\n        uint256 _nftId,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external;\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n\n\n// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    /// storage variables\n    uint256 public override deposits;\n    uint256 public override debts;\n    int256 public override claimable;\n\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\n    ///E.g. If the stability fees are 10% for a year\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\n\n    /// result\n    uint256 public liquidated;\n\n    mapping(uint256 => Detail) public override details;\n    mapping(uint256 => uint256) public lastDeposit;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n\n    modifier wait(uint256 _id) {\n        require(\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\n            \"!wait\"\n        );\n        accrueDebt(_id);\n        _;\n    }\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function initialize(address _asset) external override initializer {\n        asset = IERC20(_asset);\n        debtIndex = 1e18;\n        lastAccrued = block.timestamp;\n    }\n\n    function liveDebtIndex() public view override returns (uint256 index) {\n        return\n            engine.mochiProfile().calculateFeeIndex(\n                address(asset),\n                debtIndex,\n                lastAccrued\n            );\n    }\n\n    function status(uint256 _id) public view override returns (Status) {\n        return details[_id].status;\n    }\n\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        require(details[_id].status != Status.Invalid, \"invalid\");\n        uint256 newIndex = liveDebtIndex();\n        return (details[_id].debt * newIndex) / details[_id].debtIndex;\n    }\n\n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function increase(\n        uint256 _id,\n        uint256 _deposits,\n        uint256 _borrows,\n        address _referrer,\n        bytes memory _data\n    ) external {\n        if (_id == type(uint256).max) {\n            // mint if _id is -1\n            _id = mint(msg.sender, _referrer);\n        }\n        if (_deposits > 0) {\n            deposit(_id, _deposits);\n        }\n        if (_borrows > 0) {\n            borrow(_id, _borrows, _data);\n        }\n    }\n\n    function decrease(\n        uint256 _id,\n        uint256 _withdraws,\n        uint256 _repays,\n        bytes memory _data\n    ) external {\n        if (_repays > 0) {\n            repay(_id, _repays);\n        }\n        if (_withdraws > 0) {\n            withdraw(_id, _withdraws, _data);\n        }\n    }\n\n    function mint(address _recipient, address _referrer)\n        public\n        returns (uint256 id)\n    {\n        id = engine.nft().mint(address(asset), _recipient);\n        details[id].debtIndex = liveDebtIndex();\n        details[id].status = Status.Idle;\n        details[id].referrer = _referrer;\n    }\n\n    /// anyone can deposit collateral to given id\n    /// it will even allow depositing to liquidated vault so becareful when depositing\n    function deposit(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        // should it be able to deposit if invalid?\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        require(\n            details[_id].status == Status.Idle ||\n                details[_id].status == Status.Collaterized ||\n                details[_id].status == Status.Active,\n            \"!depositable\"\n        );\n        lastDeposit[_id] = block.timestamp;\n        deposits += _amount;\n        details[_id].collateral += _amount;\n        if (details[_id].status == Status.Idle) {\n            details[_id].status = Status.Collaterized;\n        }\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// should only be able to withdraw if status is not liquidatable\n    function withdraw(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override wait(_id) {\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        require(\n            !_liquidatable(\n                details[_id].collateral - _amount,\n                price,\n                details[_id].debt\n            ),\n            \"!healthy\"\n        );\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = (details[_id].collateral - _amount)\n            .multiply(cf)\n            .multiply(price);\n        require(details[_id].debt <= maxMinted, \">cf\");\n        deposits -= _amount;\n        details[_id].collateral -= _amount;\n        if (details[_id].collateral == 0) {\n            details[_id].status = Status.Idle;\n        }\n        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n\n    /// someone sends usdm to this address and repays the debt\n    /// will payback the leftover usdm\n    function repay(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        if (_amount > details[_id].debt) {\n            _amount = details[_id].debt;\n        }\n        require(_amount > 0, \"zero\");\n        if (debts < _amount) {\n            // safe gaurd to some underflows\n            debts = 0;\n        } else {\n            debts -= _amount;\n        }\n        details[_id].debt -= _amount;\n        if (details[_id].debt == 0) {\n            details[_id].status = Status.Collaterized;\n        }\n        engine.usdm().transferFrom(msg.sender, address(this), _amount);\n        engine.usdm().burn(_amount);\n    }\n\n    function liquidate(\n        uint256 _id,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external override updateDebt(_id) {\n        require(msg.sender == address(engine.liquidator()), \"!liquidator\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        float memory price = engine.cssr().getPrice(address(asset));\n        require(\n            _liquidatable(details[_id].collateral, price, currentDebt(_id)),\n            \"healthy\"\n        );\n\n        debts -= _usdm;\n\n        details[_id].collateral -= _collateral;\n        details[_id].debt -= _usdm;\n\n        asset.cheapTransfer(msg.sender, _collateral);\n    }\n\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\n    /// @notice should return false if _collateral * liquidationLimit < _debt\n    function _liquidatable(\n        uint256 _collateral,\n        float memory _price,\n        uint256 _debt\n    ) internal view returns (bool) {\n        float memory lf = engine.mochiProfile().liquidationFactor(\n            address(asset)\n        );\n        // when debt is lower than liquidation value, it can be liquidated\n        return _collateral.multiply(lf) < _debt.divide(_price);\n    }\n\n    function liquidatable(uint256 _id) external view returns (bool) {\n        float memory price = engine.cssr().getPrice(address(asset));\n        return _liquidatable(details[_id].collateral, price, currentDebt(_id));\n    }\n\n    function claim() external updateDebt(type(uint256).max) {\n        require(claimable > 0, \"!claimable\");\n        // reserving 25% to prevent potential risks\n        uint256 toClaim = (uint256(claimable) * 75) / 100;\n        mintFeeToPool(toClaim, address(0));\n    }\n\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\n        claimable -= int256(_amount);\n        if (address(0) != _referrer) {\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\n            engine.referralFeePool().addReward(_referrer);\n        } else {\n            engine.minter().mint(address(engine.treasury()), _amount);\n        }\n    }\n\n    // Flash Loan\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(asset), \"!supported\");\n        return asset.balanceOf(address(this));\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(asset), \"!supported\");\n        return (_amount * 1337) / 1000000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(asset), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        asset.cheapTransfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        asset.cheapTransferFrom(address(_receiver), address(this), _amount);\n        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMochiProfile.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\n///@notice this is where policies including some math is registered will be able to swap the profile when current profile is not suitable\n///@dev this profile is built with https://docs.google.com/spreadsheets/d/1T2WKpwj5QmueR7O8R9AXNbnHLc-rJ_-8DLdRI2eJZqA\ncontract MochiProfileV0 is IMochiProfile {\n    using Float for float;\n    using Float for uint256;\n    IMochiEngine public immutable engine;\n\n    uint256 public override liquidityRequirement;\n\n    uint256 public override minimumDebt;\n\n    mapping(address => AssetClass) internal _assetClass;\n\n    mapping(address => uint256) public override creditCap;\n\n    uint256 public immutable secPerYear;\n\n    uint256 public override delay;\n\n    constructor(address _engine) {\n        secPerYear = 31536000;\n        engine = IMochiEngine(_engine);\n\n        liquidityRequirement = 1000000e18; // 1million dollar\n        minimumDebt = 1000e18;\n        delay = 3 minutes;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == engine.governance(), \"!gov\");\n        _;\n    }\n\n    function assetClass(address _asset)\n        public\n        view\n        override\n        returns (AssetClass)\n    {\n        return _assetClass[_asset];\n    }\n\n    function changeLiquidityRequirement(uint256 _requirement)\n        external\n        override\n        onlyGov\n    {\n        liquidityRequirement = _requirement;\n    }\n\n    function registerAsset(address _asset) external {\n        uint256 liq = engine.cssr().getLiquidity(_asset);\n        require(liq >= liquidityRequirement, \"<liquidity\");\n        _register(_asset, AssetClass.Sigma);\n    }\n\n    function registerAssetByGov(\n        address[] calldata _asset,\n        AssetClass[] calldata _classes\n    ) external onlyGov {\n        for (uint256 i = 0; i < _asset.length; i++) {\n            _register(_asset[i], _classes[i]);\n            engine.vaultFactory().deployVault(_asset[i]);\n        }\n    }\n\n    function _register(address _asset, AssetClass _class) internal {\n        _assetClass[_asset] = _class;\n    }\n\n    function changeMinimumDebt(uint256 _debt) external override onlyGov {\n        minimumDebt = _debt;\n    }\n\n    function changeAssetClass(\n        address[] calldata _assets,\n        AssetClass[] calldata _classes\n    ) external override onlyGov {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _assetClass[_assets[i]] = _classes[i];\n        }\n    }\n\n    function changeCreditCap(\n        address[] calldata _assets,\n        uint256[] calldata _caps\n    ) external onlyGov {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            creditCap[_assets[i]] = _caps[i];\n        }\n    }\n\n    function setDelay(uint256 _delay) external onlyGov {\n        delay = _delay;\n    }\n\n    ///@notice The Collateral Factor at which the users vault will be liquidated\n    function liquidationFactor(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 95, denominator: 100});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 85, denominator: 100});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 80, denominator: 100});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 75, denominator: 100});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 65, denominator: 100});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 40, denominator: 100});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function riskFactor(address _asset) public view returns (uint256) {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return 1;\n        } else if (class == AssetClass.Alpha) {\n            return 2;\n        } else if (class == AssetClass.Gamma) {\n            return 3;\n        } else if (class == AssetClass.Delta) {\n            return 4;\n        } else if (class == AssetClass.Zeta) {\n            return 5;\n        } else if (class == AssetClass.Sigma) {\n            return 6;\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function maxCollateralFactor(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 90, denominator: 100});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 80, denominator: 100});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 75, denominator: 100});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 65, denominator: 100});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 55, denominator: 100});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 45, denominator: 100});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function baseFee() public pure returns (float memory) {\n        return float({numerator: 5, denominator: 1000});\n    }\n\n    function liquidationFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 45, denominator: 1000});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 100, denominator: 1000});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 125, denominator: 1000});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 150, denominator: 1000});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 175, denominator: 1000});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 200, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function keeperFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 5, denominator: 1000});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 10, denominator: 1000});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 15, denominator: 1000});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 20, denominator: 1000});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 25, denominator: 1000});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 30, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function maxFee(AssetClass _class) public pure returns (float memory) {\n        if (_class == AssetClass.Stable) {\n            return float({numerator: 10, denominator: 1000});\n        } else if (_class == AssetClass.Alpha) {\n            return float({numerator: 15, denominator: 1000});\n        } else if (_class == AssetClass.Gamma) {\n            return float({numerator: 20, denominator: 1000});\n        } else if (_class == AssetClass.Delta) {\n            return float({numerator: 21, denominator: 1000});\n        } else if (_class == AssetClass.Zeta) {\n            return float({numerator: 22, denominator: 1000});\n        } else if (_class == AssetClass.Sigma) {\n            return float({numerator: 23, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function stabilityFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        float memory base = baseFee();\n        AssetClass class = assetClass(_asset);\n        float memory max = maxFee(class);\n        float memory u = utilizationRatio(_asset);\n        if (u.gt(float({numerator: 1, denominator: 1}))) {\n            return max;\n        }\n        return base.add(max.sub(base).mul(u));\n    }\n\n    function calculateFeeIndex(\n        address _asset,\n        uint256 _currentIndex,\n        uint256 _lastAccrued\n    ) external view override returns (uint256) {\n        float memory feePerYear = stabilityFee(_asset);\n        uint256 timePassed = block.timestamp - _lastAccrued;\n        float memory feeAccumulated = feePerYear.mul(\n            float({numerator: timePassed, denominator: secPerYear})\n        );\n        return _currentIndex + _currentIndex.multiply(feeAccumulated);\n    }\n\n    ///@dev returns utilization ratio scaled with 1e18\n    function utilizationRatio(address _asset)\n        public\n        view\n        override\n        returns (float memory ratio)\n    {\n        IMochiVault vault = engine.vaultFactory().getVault(_asset);\n        uint256 debts = vault.debts();\n        uint256 cap = creditCap[_asset];\n        return float({numerator: debts, denominator: cap});\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@mochifi/library/contracts/Float.sol\";\n\nenum AssetClass {\n    Invalid,\n    Stable,\n    Alpha,\n    Gamma,\n    Delta,\n    Zeta,\n    Sigma,\n    Revoked\n}\n\ninterface IMochiProfile {\n    function assetClass(address _asset) external view returns (AssetClass);\n\n    function liquidityRequirement() external view returns (uint256);\n\n    function minimumDebt() external view returns (uint256);\n\n    function changeAssetClass(\n        address[] calldata _asset,\n        AssetClass[] calldata _class\n    ) external;\n\n    function changeLiquidityRequirement(uint256 _requirement) external;\n\n    function changeMinimumDebt(uint256 _debt) external;\n\n    function calculateFeeIndex(\n        address _asset,\n        uint256 _currentIndex,\n        uint256 _lastAccrued\n    ) external view returns (uint256);\n\n    function creditCap(address _asset) external view returns (uint256);\n\n    function delay() external view returns (uint256);\n\n    function liquidationFactor(address _asset)\n        external\n        view\n        returns (float memory);\n\n    function maxCollateralFactor(address _asset)\n        external\n        view\n        returns (float memory);\n\n    function stabilityFee(address _asset) external view returns (float memory);\n\n    function liquidationFee(address _asset)\n        external\n        view\n        returns (float memory);\n\n    function keeperFee(address _asset) external view returns (float memory);\n\n    function utilizationRatio(address _asset)\n        external\n        view\n        returns (float memory);\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n\n\n",
        "CodeNames": [
            "IMochiVault.sol",
            "IERC3156FlashLender.sol",
            "MochiVault.sol",
            "MochiProfileV0.sol",
            "IMochiProfile.sol",
            "IERC3156FlashBorrower.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\nfunction borrow(..)\ndetails[_id].debt = totalDebt; // includes the fee\ndebts += _amount;     // excludes the fee\n\nfunction repay(..)\ndebts -= _amount;\ndetails[_id].debt -= _amount;\n\nfunction liquidate(..)\ndebts -= _usdm;\ndetails[_id].debt -= _usdm;\n"
                ],
                "Type": "  debts  calculation is not accurate",
                "Description": "\nThe value of the global variable debts in the contract MochiVault.sol is calculated in an inconsistent way.\n\nIn the function borrow() the variable debts is increased with a value excluding the fee.\nHowever in repay() and liquidate() it is decreased with the same value as details[_id].debt is decreased, which is including the fee.\n\nThis would mean that debts will end up in a negative value when all debts are repay-ed. Luckily the function repay() prevents this from happening.\n\nIn the meantime the value of debts isn't accurate.\nThis value is used directly or indirectly in:\nutilizationRatio(), stabilityFee() calculateFeeIndex() of MochiProfileV0.sol\nliveDebtIndex(), accrueDebt(), currentDebt() of MochiVault.sol\n\nThis means the entire debt and claimable calculations are slightly off.\n\nvault/MochiVault sol(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol)\n\nsolidity\nfunction borrow(..)\ndetails[_id].debt = totalDebt; // includes the fee\ndebts += _amount;     // excludes the fee\n\nfunction repay(..)\ndebts -= _amount;\ndetails[_id].debt -= _amount;\n\nfunction liquidate(..)\ndebts -= _usdm;\ndetails[_id].debt -= _usdm;\n\n\nsee issue page(https://github.com/code-423n4/2021-10-mochi-findings/issues/25) for referenced code.\n\n",
                "Repair": "In function borrow():\nreplace\ndebts += _amount;\nwith\ndebts += totalDebt\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/25)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IReferralFeePool.sol\";\n\ncontract ReferralFeePoolV0 is IReferralFeePool {\n    IMochiEngine public immutable engine;\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    uint256 public rewards;\n\n    mapping(address => uint256) public reward;\n\n    constructor(address _engine, address _uniswap) {\n        engine = IMochiEngine(_engine);\n        uniswapRouter = IUniswapV2Router02(_uniswap);\n    }\n\n    function addReward(address _recipient) external override {\n        uint256 newReward = engine.usdm().balanceOf(address(this)) - rewards;\n        reward[_recipient] += newReward;\n        rewards += newReward;\n    }\n\n    function claimRewardAsMochi() external {\n        IUSDM usdm = engine.usdm();\n        address[] memory path = new address[](2);\n        path[0] = address(usdm);\n        path[1] = uniswapRouter.WETH();\n        path[2] = address(engine.mochi());\n        usdm.approve(address(uniswapRouter), reward[msg.sender]);\n        // we are going to ingore the slippages here\n        uniswapRouter.swapExactTokensForTokens(\n            reward[msg.sender],\n            1,\n            path,\n            address(this),\n            type(uint256).max\n        );\n        engine.mochi().transfer(\n            msg.sender,\n            engine.mochi().balanceOf(address(this))\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "ReferralFeePoolV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "ReferralFeePoolV",
                    "claimRewardAsMochi"
                ],
                "Type": " Referrer can drain  ReferralFeePoolV0 ",
                "Description": "\nfunction claimRewardAsMochi in ReferralFeePoolV0.sol did not reduce user reward balance, allowing referrer to claim the same reward repeatedly and thus draining the fee pool.\n\nDid not reduce user reward balance at L28-47 in ReferralFeePoolV0.sol(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol)\n\n",
                "Repair": "Add the following lines\n\n rewards -= reward[msg.sender];\n reward[msg.sender] = 0;\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/55)\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "claimRewardAsMochi"
                ],
                "Type": "  regerralFeePool  is vulnerable to MEV searcher",
                "Description": "\nclaimRewardAsMochi in the ReferralFeePoolV0 ignores slippage. This is not a desirable design. There are a lot of MEV searchers in the current network. Swapping assets with no slippage control would get rekted. Please refer to <https://github.com/flashbots/pm.\n\nGiven the current state of the Ethereum network, users would likely be sandwiched. I consider this is a high-risk issue.\n\nReferralFeePoolV0.sol#L28-L48(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L48)\nPlease refer to  Mushrooms Finance Theft of Yield Bug Fix Postmortem | by Immunefi | Immunefi | Medium(https://medium.com/immunefi/mushrooms-finance-theft-of-yield-bug-fix-postmortem-16bd6961388f) to see a possible attack pattern.\n\n",
                "Repair": "I recommend adding minReceivedAmount as a parameter.\n\nsolidity\nfunction claimRewardAsMochi(uint256 _minReceivedAmount) external {\n    // original logic here\n    require(engine.mochi().balanceOf(address(this))  _minReceivedAmount, \"!min\");\n    engine.mochi().transfer(\n        msg.sender,\n        engine.mochi().balanceOf(address(this))\n    );\n}\n\n\nAlso, the front-end should calculate the min amount with the current price.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/62)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\ninterface ILiquidator {\n    event Triggered(uint256 _auctionId, uint256 _price);\n    event Settled(uint256 _auctionId, uint256 _price);\n\n    function triggerLiquidation(address _asset, uint256 _nftId) external;\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@mochifi/library/contracts/Float.sol\";\nimport \"@mochifi/library/contracts/BeaconProxyDeployer.sol\";\nimport \"../interfaces/ILiquidator.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract DutchAuctionLiquidator is ILiquidator {\n    using Float for uint256;\n    IMochiEngine public immutable engine;\n\n    uint256 public constant DURATION = 2 days / 15;\n\n    struct Auction {\n        uint256 nftId;\n        address vault;\n        uint256 startedAt;\n        uint256 boughtAt;\n        uint256 collateral;\n        uint256 debt;\n    }\n\n    mapping(uint256 => Auction) public auctions;\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function auctionId(address asset, uint256 nftId)\n        public\n        pure\n        returns (uint256)\n    {\n        return uint256(keccak256(abi.encodePacked(asset, nftId)));\n    }\n\n    function price(uint256 _auctionId) external view returns (uint256) {\n        Auction memory auction = auctions[_auctionId];\n        return auction.debt + currentLiquidationFee(_auctionId);\n    }\n\n    function currentLiquidationFee(uint256 _auctionId)\n        public\n        view\n        returns (uint256 liquidationFee)\n    {\n        Auction memory auction = auctions[_auctionId];\n        liquidationFee = auction\n            .debt\n            .multiply(\n                engine.mochiProfile().liquidationFee(\n                    address(IMochiVault(auction.vault).asset())\n                )\n            )\n            .multiply(\n                float({\n                    numerator: auction.startedAt + DURATION > block.number\n                        ? auction.startedAt + DURATION - block.number\n                        : 0,\n                    denominator: DURATION\n                })\n            );\n    }\n\n    function triggerLiquidation(address _asset, uint256 _nftId)\n        external\n        override\n    {\n        IMochiVault vault = engine.vaultFactory().getVault(_asset);\n        Auction storage auction = auctions[auctionId(_asset, _nftId)];\n        require(auction.startedAt == 0 || auction.boughtAt != 0, \"on going\");\n        uint256 debt = vault.currentDebt(_nftId);\n        (, uint256 collateral, , , ) = vault.details(_nftId);\n\n        vault.liquidate(_nftId, collateral, debt);\n\n        auction.nftId = _nftId;\n        auction.vault = address(vault);\n        auction.startedAt = block.number;\n        auction.boughtAt = 0;\n        auction.collateral = collateral;\n        auction.debt = debt;\n\n        uint256 liquidationFee = debt.multiply(\n            engine.mochiProfile().liquidationFee(address(_asset))\n        );\n        emit Triggered(auctionId(_asset, _nftId), debt + liquidationFee);\n    }\n\n    function settleLiquidation(\n        uint256 _auctionId,\n        uint256 _collateral,\n        uint256 _repaid\n    ) internal {\n        Auction storage auction = auctions[_auctionId];\n        require(auction.boughtAt == 0, \"liquidated\");\n        IMochiVault vault = IMochiVault(auction.vault);\n        //repay the debt first\n        engine.usdm().transferFrom(msg.sender, address(this), _repaid);\n        engine.usdm().burn(_repaid);\n        IERC20 asset = vault.asset();\n        auction.boughtAt = block.number;\n        asset.transfer(msg.sender, _collateral);\n        //transfer liquidation fee to feePool\n        uint256 liquidationFee = currentLiquidationFee(_auctionId);\n        engine.usdm().transferFrom(\n            msg.sender,\n            address(engine.feePool()),\n            liquidationFee\n        );\n\n        emit Settled(_auctionId, _repaid + liquidationFee);\n    }\n\n    function buy(uint256 _auctionId) external {\n        Auction memory auction = auctions[_auctionId];\n        require(auction.startedAt != 0 && auction.boughtAt == 0, \"!on going\");\n        settleLiquidation(_auctionId, auction.collateral, auction.debt);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nstruct Detail {\n    Status status;\n    uint256 collateral;\n    uint256 debt;\n    uint256 debtIndex;\n    address referrer;\n}\n\nenum Status {\n    Invalid, // not minted\n    Idle, // debt = 0, collateral = 0\n    Collaterized, // debt = 0, collateral > 0\n    Active, // debt > 0, collateral > 0\n    Liquidated\n}\n\ninterface IMochiVault {\n    function liveDebtIndex() external view returns (uint256);\n\n    function details(uint256 _nftId)\n        external\n        view\n        returns (\n            Status,\n            uint256 collateral,\n            uint256 debt,\n            uint256 debtIndexe,\n            address refferer\n        );\n\n    function status(uint256 _nftId) external view returns (Status);\n\n    function asset() external view returns (IERC20);\n\n    function deposits() external view returns (uint256);\n\n    function debts() external view returns (uint256);\n\n    function claimable() external view returns (int256);\n\n    function currentDebt(uint256 _nftId) external view returns (uint256);\n\n    function initialize(address _asset) external;\n\n    function deposit(uint256 _nftId, uint256 _amount) external;\n\n    function withdraw(\n        uint256 _nftId,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n\n    function borrow(\n        uint256 _nftId,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n\n    function repay(uint256 _nftId, uint256 _amount) external;\n\n    function liquidate(\n        uint256 _nftId,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external;\n}\n\n\n// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    /// storage variables\n    uint256 public override deposits;\n    uint256 public override debts;\n    int256 public override claimable;\n\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\n    ///E.g. If the stability fees are 10% for a year\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\n\n    /// result\n    uint256 public liquidated;\n\n    mapping(uint256 => Detail) public override details;\n    mapping(uint256 => uint256) public lastDeposit;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n\n    modifier wait(uint256 _id) {\n        require(\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\n            \"!wait\"\n        );\n        accrueDebt(_id);\n        _;\n    }\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function initialize(address _asset) external override initializer {\n        asset = IERC20(_asset);\n        debtIndex = 1e18;\n        lastAccrued = block.timestamp;\n    }\n\n    function liveDebtIndex() public view override returns (uint256 index) {\n        return\n            engine.mochiProfile().calculateFeeIndex(\n                address(asset),\n                debtIndex,\n                lastAccrued\n            );\n    }\n\n    function status(uint256 _id) public view override returns (Status) {\n        return details[_id].status;\n    }\n\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        require(details[_id].status != Status.Invalid, \"invalid\");\n        uint256 newIndex = liveDebtIndex();\n        return (details[_id].debt * newIndex) / details[_id].debtIndex;\n    }\n\n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function increase(\n        uint256 _id,\n        uint256 _deposits,\n        uint256 _borrows,\n        address _referrer,\n        bytes memory _data\n    ) external {\n        if (_id == type(uint256).max) {\n            // mint if _id is -1\n            _id = mint(msg.sender, _referrer);\n        }\n        if (_deposits > 0) {\n            deposit(_id, _deposits);\n        }\n        if (_borrows > 0) {\n            borrow(_id, _borrows, _data);\n        }\n    }\n\n    function decrease(\n        uint256 _id,\n        uint256 _withdraws,\n        uint256 _repays,\n        bytes memory _data\n    ) external {\n        if (_repays > 0) {\n            repay(_id, _repays);\n        }\n        if (_withdraws > 0) {\n            withdraw(_id, _withdraws, _data);\n        }\n    }\n\n    function mint(address _recipient, address _referrer)\n        public\n        returns (uint256 id)\n    {\n        id = engine.nft().mint(address(asset), _recipient);\n        details[id].debtIndex = liveDebtIndex();\n        details[id].status = Status.Idle;\n        details[id].referrer = _referrer;\n    }\n\n    /// anyone can deposit collateral to given id\n    /// it will even allow depositing to liquidated vault so becareful when depositing\n    function deposit(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        // should it be able to deposit if invalid?\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        require(\n            details[_id].status == Status.Idle ||\n                details[_id].status == Status.Collaterized ||\n                details[_id].status == Status.Active,\n            \"!depositable\"\n        );\n        lastDeposit[_id] = block.timestamp;\n        deposits += _amount;\n        details[_id].collateral += _amount;\n        if (details[_id].status == Status.Idle) {\n            details[_id].status = Status.Collaterized;\n        }\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// should only be able to withdraw if status is not liquidatable\n    function withdraw(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override wait(_id) {\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        require(\n            !_liquidatable(\n                details[_id].collateral - _amount,\n                price,\n                details[_id].debt\n            ),\n            \"!healthy\"\n        );\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = (details[_id].collateral - _amount)\n            .multiply(cf)\n            .multiply(price);\n        require(details[_id].debt <= maxMinted, \">cf\");\n        deposits -= _amount;\n        details[_id].collateral -= _amount;\n        if (details[_id].collateral == 0) {\n            details[_id].status = Status.Idle;\n        }\n        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n\n    /// someone sends usdm to this address and repays the debt\n    /// will payback the leftover usdm\n    function repay(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        if (_amount > details[_id].debt) {\n            _amount = details[_id].debt;\n        }\n        require(_amount > 0, \"zero\");\n        if (debts < _amount) {\n            // safe gaurd to some underflows\n            debts = 0;\n        } else {\n            debts -= _amount;\n        }\n        details[_id].debt -= _amount;\n        if (details[_id].debt == 0) {\n            details[_id].status = Status.Collaterized;\n        }\n        engine.usdm().transferFrom(msg.sender, address(this), _amount);\n        engine.usdm().burn(_amount);\n    }\n\n    function liquidate(\n        uint256 _id,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external override updateDebt(_id) {\n        require(msg.sender == address(engine.liquidator()), \"!liquidator\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        float memory price = engine.cssr().getPrice(address(asset));\n        require(\n            _liquidatable(details[_id].collateral, price, currentDebt(_id)),\n            \"healthy\"\n        );\n\n        debts -= _usdm;\n\n        details[_id].collateral -= _collateral;\n        details[_id].debt -= _usdm;\n\n        asset.cheapTransfer(msg.sender, _collateral);\n    }\n\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\n    /// @notice should return false if _collateral * liquidationLimit < _debt\n    function _liquidatable(\n        uint256 _collateral,\n        float memory _price,\n        uint256 _debt\n    ) internal view returns (bool) {\n        float memory lf = engine.mochiProfile().liquidationFactor(\n            address(asset)\n        );\n        // when debt is lower than liquidation value, it can be liquidated\n        return _collateral.multiply(lf) < _debt.divide(_price);\n    }\n\n    function liquidatable(uint256 _id) external view returns (bool) {\n        float memory price = engine.cssr().getPrice(address(asset));\n        return _liquidatable(details[_id].collateral, price, currentDebt(_id));\n    }\n\n    function claim() external updateDebt(type(uint256).max) {\n        require(claimable > 0, \"!claimable\");\n        // reserving 25% to prevent potential risks\n        uint256 toClaim = (uint256(claimable) * 75) / 100;\n        mintFeeToPool(toClaim, address(0));\n    }\n\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\n        claimable -= int256(_amount);\n        if (address(0) != _referrer) {\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\n            engine.referralFeePool().addReward(_referrer);\n        } else {\n            engine.minter().mint(address(engine.treasury()), _amount);\n        }\n    }\n\n    // Flash Loan\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(asset), \"!supported\");\n        return asset.balanceOf(address(this));\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(asset), \"!supported\");\n        return (_amount * 1337) / 1000000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(asset), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        asset.cheapTransfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        asset.cheapTransferFrom(address(_receiver), address(this), _amount);\n        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./vault/MochiVaultFactory.sol\";\nimport \"./assets/usdm.sol\";\nimport \"./interfaces/IMochiEngine.sol\";\n\ncontract MochiEngine is IMochiEngine {\n    // immutable values\n    IMochiVaultFactory public immutable override vaultFactory;\n    // mutable values\n    IMochi public override mochi;\n    IVMochi public override vMochi;\n    address public override governance;\n    address public override treasury;\n    address public override operationWallet;\n    IUSDM public override usdm;\n    IMinter public override minter;\n    ICSSRRouter public override cssr;\n    IMochiProfile public override mochiProfile;\n    IDiscountProfile public override discountProfile;\n    ILiquidator public override liquidator;\n    IFeePool public override feePool;\n    IReferralFeePool public override referralFeePool;\n    IMochiNFT public override nft;\n\n    constructor(address _governance) {\n        governance = _governance;\n        vaultFactory = IMochiVaultFactory(new MochiVaultFactory(address(this)));\n        operationWallet = msg.sender;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == governance, \"!gov\");\n        _;\n    }\n\n    function changeMochi(address _mochi) external onlyGov {\n        mochi = IMochi(_mochi);\n    }\n\n    function changeVMochi(address _vmochi) external onlyGov {\n        vMochi = IVMochi(_vmochi);\n    }\n\n    function changeUSDM(address _usdm) external onlyGov {\n        usdm = IUSDM(_usdm);\n    }\n\n    function changeMinter(address _minter) external onlyGov {\n        minter = IMinter(_minter);\n    }\n\n    function changeGovernance(address _governance) external onlyGov {\n        governance = _governance;\n    }\n\n    function changeTreasury(address _treasury) external onlyGov {\n        treasury = _treasury;\n    }\n\n    function changeOperationWallet(address _operation) external onlyGov {\n        operationWallet = _operation;\n    }\n\n    function changeCSSR(address _cssr) external onlyGov {\n        cssr = ICSSRRouter(_cssr);\n    }\n\n    function changeProfile(address _profile) external onlyGov {\n        mochiProfile = IMochiProfile(_profile);\n    }\n\n    function changeDiscountProfile(address _profile) external onlyGov {\n        discountProfile = IDiscountProfile(_profile);\n    }\n\n    function changeLiquidator(address _liquidator) external onlyGov {\n        liquidator = ILiquidator(_liquidator);\n    }\n\n    function changeFeePool(address _feePool) external onlyGov {\n        feePool = IFeePool(_feePool);\n    }\n\n    function changeReferralFeePool(address _referralFeePool) external onlyGov {\n        referralFeePool = IReferralFeePool(_referralFeePool);\n    }\n\n    function changeNFT(address _nft) external onlyGov {\n        nft = IMochiNFT(_nft);\n    }\n}\n\n\n",
        "CodeNames": [
            "ILiquidator.sol",
            "DutchAuctionLiquidator.sol",
            "IMochiVault.sol",
            "MochiVault.sol",
            "MochiEngine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "//solidity\ndetails[_id].debt -= _usdm;\n"
                ],
                "Type": " Liquidation will never work with non-zero discounts",
                "Description": "\nRight now, there is only one discount profile in the github repo: the \"NoDiscountProfile\" which does not discount the debt at all. This specific discount profile works correctly, but I claim that any other discount profile will result in liquidation never working.\n\nSuppose that we instead have a discount profile where discount() returns any value strictly larger than 0. Now, suppose someone wants to trigger a liquidation on a position. First, triggerLiquidation will be called (within DutchAuctionLiquidator.sol). The variable \"debt\" is initialized as equal to vault.currentDebt(_nftId). Notice that currentDebt(_ndfId) (within MochiVault.sol) simply scales the current debt of the position using the liveDebtIndex() function, but there is no discounting being done within the function this will be important.\n\nBack within the triggerLiquidation function, the variable \"collateral\" is  simply calculated as the total collateral of the position. Then, the function calls vault.liquidate(_nftId, collateral, debt), and I claim that this will never work due to underflow.  Indeed, the liquidate function will first update the debt of the position (due to the updateDebt(_id) modifier). The debt of the position is thus updated using lines 99-107 in MochiVault.sol. We can see that the details[_id].debt is updated in the exact same way as the calculations for currentDebt(_nftId), however, there is the extra subtraction of the discountedDebt on line 107.\n\nEventually we will reach line 293 in MochiVault.sol. However, since we discounted the debt in the calculation of details[_id].debt, but we did not discount the debt for the passed in parameter _usdm (and thus is strictly larger in value), line 293 will always error due to an underflow. In summary, any discount profile that actually discounts the debt of the position will result in all liquidations erroring out due to this underflow. Since no positions will be liquidatable, this represents a major flaw in the contract as then no collateral can be liquidated so the entire functionality of the contract is compromised.\n\nLiquidate function in MochiVault.sol(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#:~:text=function-,liquidate,-)\ntriggerLiquidation function in DutchAuctionLiquidator.sol(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#:~:text=function-,triggerLiquidation,-address%20_asset%2C%20uint256)\n\nRetracing the steps as I have described above, we can see that any call to triggerLiquidation will result in:\n\nsolidity\ndetails[_id].debt -= _usdm;\n\n\nthrowing an error since _usdm will be larger than details[_id].debt.\n\n",
                "Repair": "An easy fix is to simply change:\n\ndetails[_id].debt -= _usdm;\n\nto be:\n\ndetails[_id].debt = 0;\n\nas liquidating a position should probably just be equivalent to repaying all of the debt in the position.\n\nSide Note: If there are no other discount profiles planned to be added other than \"NoDiscountProfile\", then I would recommend deleting all of the discount logic entirely, since NoDiscountProfile doesn't actually do anything.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/66)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    /// storage variables\n    uint256 public override deposits;\n    uint256 public override debts;\n    int256 public override claimable;\n\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\n    ///E.g. If the stability fees are 10% for a year\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\n\n    /// result\n    uint256 public liquidated;\n\n    mapping(uint256 => Detail) public override details;\n    mapping(uint256 => uint256) public lastDeposit;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n\n    modifier wait(uint256 _id) {\n        require(\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\n            \"!wait\"\n        );\n        accrueDebt(_id);\n        _;\n    }\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function initialize(address _asset) external override initializer {\n        asset = IERC20(_asset);\n        debtIndex = 1e18;\n        lastAccrued = block.timestamp;\n    }\n\n    function liveDebtIndex() public view override returns (uint256 index) {\n        return\n            engine.mochiProfile().calculateFeeIndex(\n                address(asset),\n                debtIndex,\n                lastAccrued\n            );\n    }\n\n    function status(uint256 _id) public view override returns (Status) {\n        return details[_id].status;\n    }\n\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        require(details[_id].status != Status.Invalid, \"invalid\");\n        uint256 newIndex = liveDebtIndex();\n        return (details[_id].debt * newIndex) / details[_id].debtIndex;\n    }\n\n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function increase(\n        uint256 _id,\n        uint256 _deposits,\n        uint256 _borrows,\n        address _referrer,\n        bytes memory _data\n    ) external {\n        if (_id == type(uint256).max) {\n            // mint if _id is -1\n            _id = mint(msg.sender, _referrer);\n        }\n        if (_deposits > 0) {\n            deposit(_id, _deposits);\n        }\n        if (_borrows > 0) {\n            borrow(_id, _borrows, _data);\n        }\n    }\n\n    function decrease(\n        uint256 _id,\n        uint256 _withdraws,\n        uint256 _repays,\n        bytes memory _data\n    ) external {\n        if (_repays > 0) {\n            repay(_id, _repays);\n        }\n        if (_withdraws > 0) {\n            withdraw(_id, _withdraws, _data);\n        }\n    }\n\n    function mint(address _recipient, address _referrer)\n        public\n        returns (uint256 id)\n    {\n        id = engine.nft().mint(address(asset), _recipient);\n        details[id].debtIndex = liveDebtIndex();\n        details[id].status = Status.Idle;\n        details[id].referrer = _referrer;\n    }\n\n    /// anyone can deposit collateral to given id\n    /// it will even allow depositing to liquidated vault so becareful when depositing\n    function deposit(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        // should it be able to deposit if invalid?\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        require(\n            details[_id].status == Status.Idle ||\n                details[_id].status == Status.Collaterized ||\n                details[_id].status == Status.Active,\n            \"!depositable\"\n        );\n        lastDeposit[_id] = block.timestamp;\n        deposits += _amount;\n        details[_id].collateral += _amount;\n        if (details[_id].status == Status.Idle) {\n            details[_id].status = Status.Collaterized;\n        }\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// should only be able to withdraw if status is not liquidatable\n    function withdraw(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override wait(_id) {\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        require(\n            !_liquidatable(\n                details[_id].collateral - _amount,\n                price,\n                details[_id].debt\n            ),\n            \"!healthy\"\n        );\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = (details[_id].collateral - _amount)\n            .multiply(cf)\n            .multiply(price);\n        require(details[_id].debt <= maxMinted, \">cf\");\n        deposits -= _amount;\n        details[_id].collateral -= _amount;\n        if (details[_id].collateral == 0) {\n            details[_id].status = Status.Idle;\n        }\n        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n\n    /// someone sends usdm to this address and repays the debt\n    /// will payback the leftover usdm\n    function repay(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        if (_amount > details[_id].debt) {\n            _amount = details[_id].debt;\n        }\n        require(_amount > 0, \"zero\");\n        if (debts < _amount) {\n            // safe gaurd to some underflows\n            debts = 0;\n        } else {\n            debts -= _amount;\n        }\n        details[_id].debt -= _amount;\n        if (details[_id].debt == 0) {\n            details[_id].status = Status.Collaterized;\n        }\n        engine.usdm().transferFrom(msg.sender, address(this), _amount);\n        engine.usdm().burn(_amount);\n    }\n\n    function liquidate(\n        uint256 _id,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external override updateDebt(_id) {\n        require(msg.sender == address(engine.liquidator()), \"!liquidator\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        float memory price = engine.cssr().getPrice(address(asset));\n        require(\n            _liquidatable(details[_id].collateral, price, currentDebt(_id)),\n            \"healthy\"\n        );\n\n        debts -= _usdm;\n\n        details[_id].collateral -= _collateral;\n        details[_id].debt -= _usdm;\n\n        asset.cheapTransfer(msg.sender, _collateral);\n    }\n\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\n    /// @notice should return false if _collateral * liquidationLimit < _debt\n    function _liquidatable(\n        uint256 _collateral,\n        float memory _price,\n        uint256 _debt\n    ) internal view returns (bool) {\n        float memory lf = engine.mochiProfile().liquidationFactor(\n            address(asset)\n        );\n        // when debt is lower than liquidation value, it can be liquidated\n        return _collateral.multiply(lf) < _debt.divide(_price);\n    }\n\n    function liquidatable(uint256 _id) external view returns (bool) {\n        float memory price = engine.cssr().getPrice(address(asset));\n        return _liquidatable(details[_id].collateral, price, currentDebt(_id));\n    }\n\n    function claim() external updateDebt(type(uint256).max) {\n        require(claimable > 0, \"!claimable\");\n        // reserving 25% to prevent potential risks\n        uint256 toClaim = (uint256(claimable) * 75) / 100;\n        mintFeeToPool(toClaim, address(0));\n    }\n\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\n        claimable -= int256(_amount);\n        if (address(0) != _referrer) {\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\n            engine.referralFeePool().addReward(_referrer);\n        } else {\n            engine.minter().mint(address(engine.treasury()), _amount);\n        }\n    }\n\n    // Flash Loan\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(asset), \"!supported\");\n        return asset.balanceOf(address(this));\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(asset), \"!supported\");\n        return (_amount * 1337) / 1000000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(asset), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        asset.cheapTransfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        asset.cheapTransferFrom(address(_receiver), address(this), _amount);\n        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMochi.sol\";\nimport \"@mochifi/vmochi/contracts/interfaces/IVMochi.sol\";\n\ncontract VestedRewardPool {\n    IMochi public immutable mochi;\n    IVMochi public immutable vMochi;\n\n    uint256 public mochiUnderManagement;\n\n    mapping(address => Vesting) public vesting;\n\n    struct Vesting {\n        uint256 vested;\n        uint256 ends;\n        uint256 claimable;\n    }\n\n    modifier checkClaimable(address recipient) {\n        if (vesting[recipient].ends < block.timestamp) {\n            vesting[recipient].claimable += vesting[recipient].vested;\n            vesting[recipient].vested = 0;\n            vesting[recipient].ends = 0;\n        }\n        _;\n    }\n\n    constructor(address _mochi, address _vmochi) {\n        mochi = IMochi(_mochi);\n        vMochi = IVMochi(_vmochi);\n    }\n\n    function vest(address _recipient) external checkClaimable(_recipient) {\n        uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;\n        uint256 weightedEnd = (vesting[_recipient].vested *\n            vesting[_recipient].ends +\n            amount *\n            (block.timestamp + 90 days)) /\n            (vesting[_recipient].vested + amount);\n        vesting[_recipient].vested += amount;\n        vesting[_recipient].ends = weightedEnd;\n        mochiUnderManagement += amount;\n    }\n\n    function claim() external checkClaimable(msg.sender) {\n        mochi.transfer(msg.sender, vesting[msg.sender].claimable);\n        mochiUnderManagement -= vesting[msg.sender].claimable;\n        vesting[msg.sender].claimable = 0;\n    }\n\n    function lock(uint256 _amount) external checkClaimable(msg.sender) {\n        mochi.approve(address(vMochi), _amount);\n        (, uint256 end) = vMochi.locked(msg.sender);\n        if (end >= block.timestamp + 90 days) {\n            vMochi.depositFor(msg.sender, _amount);\n        } else {\n            revert(\"lock should be longer than 90 days\");\n        }\n        vesting[msg.sender].vested -= _amount;\n        mochiUnderManagement -= _amount;\n    }\n\n    function forceClaim(uint256 _amount) external checkClaimable(msg.sender) {\n        mochi.transfer(msg.sender, _amount / 2);\n        mochi.transfer(address(vMochi), _amount / 2);\n        vesting[msg.sender].vested -= _amount;\n        mochiUnderManagement -= _amount;\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiVault.sol",
            "VestedRewardPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-08",
                "Location": [
                    "lastDeposit[_id]",
                    "deposit"
                ],
                "Type": " Anyone can extend withdraw wait period by depositing zero collateral",
                "Description": "\nIn MochiVault.sol, the deposit function allows anyone to deposit collateral into any position. A malicious user can call this function with amount = 0, which would reset the amount of time the owner has to wait before they can withdraw their collateral from their position. This is especially troublesome with longer delays, as a malicious user would only have to spend a little gas to lock out all other users from being able to withdraw from their positions, compromising the functionality of the contract altogether.\n\n\nthe deposit function here(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#:~:text=function-,deposit,-uint256%20_id%2C%20uint256)\n\nNotice that calling this function with amount = 0 is not disallowed. This overwrites lastDeposit[_id], extending the wait period before a withdraw is allowed.\n\n",
                "Repair": "I would recommend adding:\n\nrequire(amount  0, \"zero\")\n\nat the start of the function, as depositing zero collateral does not seem to be a necessary use case to support.\n\nIt may also be worthwhile to consider only allowing the owner of a position to deposit collateral.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/69)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/ICurveVotingEscrow.sol\";\n\ncontract MochiTreasuryV0 {\n    IMochiEngine public immutable engine;\n\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    IERC20 public immutable crv;\n    ICurveVotingEscrow public immutable veCrv;\n    bool public lockCrv;\n    uint256 public operationShare;\n    uint256 public veCRVShare;\n\n    constructor(\n        address _engine,\n        address _uniswap,\n        address _crv,\n        address _veCrv\n    ) {\n        engine = IMochiEngine(_engine);\n        uniswapRouter = IUniswapV2Router02(_uniswap);\n        crv = IERC20(_crv);\n        veCrv = ICurveVotingEscrow(_veCrv);\n        lockCrv = false;\n    }\n\n    receive() external payable {}\n\n    function withdrawCRV() external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        crv.transfer(msg.sender, crv.balanceOf(address(this)));\n    }\n\n    function withdrawLock() external {\n        veCrv.withdraw();\n    }\n\n    function veCRVInitialize() external {\n        require(lockCrv, \"!lock\");\n        updateFee();\n        _buyCRV();\n        veCrv.create_lock(\n            crv.balanceOf(address(this)),\n            block.timestamp + 90 days\n        );\n    }\n\n    function toggleLocking() external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        lockCrv = !lockCrv;\n    }\n\n    function updateFee() public {\n        uint256 updatedFee = engine.usdm().balanceOf(address(this)) -\n            operationShare -\n            veCRVShare;\n        operationShare += updatedFee / 2;\n        veCRVShare += updatedFee / 2;\n    }\n\n    function claimOperationCost() external {\n        updateFee();\n        engine.usdm().transfer(engine.operationWallet(), operationShare);\n        operationShare = 0;\n    }\n\n    function veCRVlock() external {\n        require(lockCrv, \"!lock\");\n        updateFee();\n        _buyCRV();\n        _lockCRV();\n        veCRVShare = 0;\n    }\n\n    function _buyCRV() internal {\n        IUSDM usdm = engine.usdm();\n        address[] memory path = new address[](2);\n        path[0] = address(usdm);\n        path[1] = address(crv);\n        usdm.approve(address(uniswapRouter), veCRVShare);\n        uniswapRouter.swapExactTokensForTokens(\n            veCRVShare,\n            1,\n            path,\n            address(this),\n            type(uint256).max\n        );\n    }\n\n    function _lockCRV() internal {\n        crv.approve(address(veCrv), crv.balanceOf(address(this)));\n        veCrv.increase_amount(crv.balanceOf(address(this)));\n        veCrv.increase_unlock_time(block.timestamp + 90 days);\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiTreasuryV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "veCRVlock",
                    "veCRVlock()",
                    "MochiTreasury"
                ],
                "Type": " treasury is vulnerable to sandwich attack",
                "Description": "\nThere's a permissionless function veCRVlock in MochiTreasury. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds.\nMochiTreasuryV0.sol#L73-L94(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)\n\nAttackers can possibly steal all the funds in the treasury. I consider this is a high-risk issue.\n\nMochiTreasuryV0.sol#L73-L94(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)\n\nHere's an exploit pattern\n\n1.  Flashloan and buy CRV the uniswap pool\n2.  Trigger veCRVlock()\n3.  The treasury buys CRV at a very high price.\n4.  Sell CRV and pay back the loan.\n\n",
                "Repair": "Recommend to add onlyOwner modifier.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/60)\n\n\n"
            },
            {
                "Name": "M-14",
                "Location": [
                    "MochiTreasuryV",
                    "withdrawLock()"
                ],
                "Type": "  MochiTreasuryV0.withdrawLock()  Is Callable When Locking Has Been Toggled",
                "Description": "\nwithdrawLock() does not prevent users from calling this function when locking has been toggled. As a result, withdraws may be made unexpectedly.\n\nMochiTreasuryV0.sol#L40 L42(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L40-L42)\n\nManual code review\n\n",
                "Repair": "Consider adding require(lockCrv, \"!lock\"); to withdrawLock() to ensure this function is not called unexpectedly. Alternatively if this is intended behaviour, it should be rather checked that the lock has not been toggled, otherwise users could maliciously relock tokens.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/161)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./vault/MochiVaultFactory.sol\";\nimport \"./assets/usdm.sol\";\nimport \"./interfaces/IMochiEngine.sol\";\n\ncontract MochiEngine is IMochiEngine {\n    // immutable values\n    IMochiVaultFactory public immutable override vaultFactory;\n    // mutable values\n    IMochi public override mochi;\n    IVMochi public override vMochi;\n    address public override governance;\n    address public override treasury;\n    address public override operationWallet;\n    IUSDM public override usdm;\n    IMinter public override minter;\n    ICSSRRouter public override cssr;\n    IMochiProfile public override mochiProfile;\n    IDiscountProfile public override discountProfile;\n    ILiquidator public override liquidator;\n    IFeePool public override feePool;\n    IReferralFeePool public override referralFeePool;\n    IMochiNFT public override nft;\n\n    constructor(address _governance) {\n        governance = _governance;\n        vaultFactory = IMochiVaultFactory(new MochiVaultFactory(address(this)));\n        operationWallet = msg.sender;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == governance, \"!gov\");\n        _;\n    }\n\n    function changeMochi(address _mochi) external onlyGov {\n        mochi = IMochi(_mochi);\n    }\n\n    function changeVMochi(address _vmochi) external onlyGov {\n        vMochi = IVMochi(_vmochi);\n    }\n\n    function changeUSDM(address _usdm) external onlyGov {\n        usdm = IUSDM(_usdm);\n    }\n\n    function changeMinter(address _minter) external onlyGov {\n        minter = IMinter(_minter);\n    }\n\n    function changeGovernance(address _governance) external onlyGov {\n        governance = _governance;\n    }\n\n    function changeTreasury(address _treasury) external onlyGov {\n        treasury = _treasury;\n    }\n\n    function changeOperationWallet(address _operation) external onlyGov {\n        operationWallet = _operation;\n    }\n\n    function changeCSSR(address _cssr) external onlyGov {\n        cssr = ICSSRRouter(_cssr);\n    }\n\n    function changeProfile(address _profile) external onlyGov {\n        mochiProfile = IMochiProfile(_profile);\n    }\n\n    function changeDiscountProfile(address _profile) external onlyGov {\n        discountProfile = IDiscountProfile(_profile);\n    }\n\n    function changeLiquidator(address _liquidator) external onlyGov {\n        liquidator = ILiquidator(_liquidator);\n    }\n\n    function changeFeePool(address _feePool) external onlyGov {\n        feePool = IFeePool(_feePool);\n    }\n\n    function changeReferralFeePool(address _referralFeePool) external onlyGov {\n        referralFeePool = IReferralFeePool(_referralFeePool);\n    }\n\n    function changeNFT(address _nft) external onlyGov {\n        nft = IMochiNFT(_nft);\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiEngine.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-10",
                "Location": [],
                "Type": " Changing NFT contract in the  MochiEngine  would break the protocol",
                "Description": "\nMochiEngine allows the operator to change the NFT contract in MochiEngine.sol#L91-L93(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93)\n\nAll the vaults would point to a different NFT address. As a result, users would not be access their positions. The entire protocol would be broken.\n\nIMHO, A function that would break the entire protocol shouldn't exist.\n\nI consider this is a high-risk issue.\n\nMochiEngine.sol#L91-L93(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93)\n\n",
                "Repair": "Remove the function.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/63)\n\n\n"
            },
            {
                "Name": "M-12",
                "Location": [
                    "py\nvault_factory.functions.deployVault(usdt.address).transact()\n## this tx would be reverted\nprofile.functions.registerAssetByGov([usdt.address], 3]).transact()\n"
                ],
                "Type": " anyone can create a vault by directly calling the factory",
                "Description": "\nIn MochiVaultFactory.sol#L26-L37(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVaultFactory.sol#L26-L37), there's no permission control in the vaultFactory. Anyone can create a vault. The transaction would be reverted when the government tries to deploy such an asset.\n\nAs the protocol checks whether the vault is a valid vault by comparing the contract's address with the computed address, the protocol would recognize the random vault as a valid one.\n\nI consider this is a medium-risk issue.\n\nHere's a web3.py script to trigger the bug.\n\npy\nvault_factory.functions.deployVault(usdt.address).transact()\n## this tx would be reverted\nprofile.functions.registerAssetByGov([usdt.address], 3]).transact()\n\n\n",
                "Repair": "Recommend to add a check.\n\nsolidity\nrequire(msg.sender == engine, \"!engine\");\n\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/80)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./vault/MochiVaultFactory.sol\";\nimport \"./assets/usdm.sol\";\nimport \"./interfaces/IMochiEngine.sol\";\n\ncontract MochiEngine is IMochiEngine {\n    // immutable values\n    IMochiVaultFactory public immutable override vaultFactory;\n    // mutable values\n    IMochi public override mochi;\n    IVMochi public override vMochi;\n    address public override governance;\n    address public override treasury;\n    address public override operationWallet;\n    IUSDM public override usdm;\n    IMinter public override minter;\n    ICSSRRouter public override cssr;\n    IMochiProfile public override mochiProfile;\n    IDiscountProfile public override discountProfile;\n    ILiquidator public override liquidator;\n    IFeePool public override feePool;\n    IReferralFeePool public override referralFeePool;\n    IMochiNFT public override nft;\n\n    constructor(address _governance) {\n        governance = _governance;\n        vaultFactory = IMochiVaultFactory(new MochiVaultFactory(address(this)));\n        operationWallet = msg.sender;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == governance, \"!gov\");\n        _;\n    }\n\n    function changeMochi(address _mochi) external onlyGov {\n        mochi = IMochi(_mochi);\n    }\n\n    function changeVMochi(address _vmochi) external onlyGov {\n        vMochi = IVMochi(_vmochi);\n    }\n\n    function changeUSDM(address _usdm) external onlyGov {\n        usdm = IUSDM(_usdm);\n    }\n\n    function changeMinter(address _minter) external onlyGov {\n        minter = IMinter(_minter);\n    }\n\n    function changeGovernance(address _governance) external onlyGov {\n        governance = _governance;\n    }\n\n    function changeTreasury(address _treasury) external onlyGov {\n        treasury = _treasury;\n    }\n\n    function changeOperationWallet(address _operation) external onlyGov {\n        operationWallet = _operation;\n    }\n\n    function changeCSSR(address _cssr) external onlyGov {\n        cssr = ICSSRRouter(_cssr);\n    }\n\n    function changeProfile(address _profile) external onlyGov {\n        mochiProfile = IMochiProfile(_profile);\n    }\n\n    function changeDiscountProfile(address _profile) external onlyGov {\n        discountProfile = IDiscountProfile(_profile);\n    }\n\n    function changeLiquidator(address _liquidator) external onlyGov {\n        liquidator = ILiquidator(_liquidator);\n    }\n\n    function changeFeePool(address _feePool) external onlyGov {\n        feePool = IFeePool(_feePool);\n    }\n\n    function changeReferralFeePool(address _referralFeePool) external onlyGov {\n        referralFeePool = IReferralFeePool(_referralFeePool);\n    }\n\n    function changeNFT(address _nft) external onlyGov {\n        nft = IMochiNFT(_nft);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/IFeePool.sol\";\nimport \"../interfaces/IUSDM.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract FeePoolV0 is IFeePool {\n    IMochiEngine public immutable engine;\n\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    address public crvVoterRewardPool;\n\n    uint256 public treasuryRatio;\n\n    uint256 public vMochiRatio;\n\n    uint256 public mochiShare;\n\n    uint256 public treasuryShare;\n\n    constructor(address _engine, address _uniswap) {\n        engine = IMochiEngine(_engine);\n        uniswapRouter = IUniswapV2Router02(_uniswap);\n        treasuryRatio = 20e16;\n        vMochiRatio = 80e16;\n    }\n\n    function updateReserve() external override {\n        uint256 newReserve = engine.usdm().balanceOf(address(this)) -\n            mochiShare -\n            treasuryShare;\n        treasuryShare += (newReserve * treasuryRatio) / 1e18;\n        mochiShare = engine.usdm().balanceOf(address(this)) - treasuryShare;\n    }\n\n    function changecrvVoterRewardPool(address _pool) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        crvVoterRewardPool = _pool;\n    }\n\n    function changeTreasuryRatio(uint256 _ratio) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        treasuryRatio = _ratio;\n    }\n\n    function changevMochiRatio(uint256 _ratio) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        vMochiRatio = _ratio;\n    }\n\n    // this will open up arb oppertunity for Mochi\n    // so we will not reward the caller, caller can benefit from flashbot\n    // should decide which market we should use UniV2?V3? BalancerV2?\n    function distributeMochi() external {\n        // buy Mochi with mochiShare\n        _buyMochi();\n        _shareMochi();\n    }\n\n    function _buyMochi() internal {\n        IUSDM usdm = engine.usdm();\n        address[] memory path = new address[](2);\n        path[0] = address(usdm);\n        path[1] = address(engine.mochi());\n        usdm.approve(address(uniswapRouter), mochiShare);\n        uniswapRouter.swapExactTokensForTokens(\n            mochiShare,\n            1,\n            path,\n            address(this),\n            type(uint256).max\n        );\n    }\n\n    function _shareMochi() internal {\n        IMochi mochi = engine.mochi();\n        uint256 mochiBalance = mochi.balanceOf(address(this));\n        // send Mochi to vMochi Vault\n        mochi.transfer(\n            address(engine.vMochi()),\n            (mochiBalance * vMochiRatio) / 1e18\n        );\n        // send Mochi to veCRV Holders\n        mochi.transfer(\n            crvVoterRewardPool,\n            (mochiBalance * (1e18 - vMochiRatio)) / 1e18\n        );\n        // flush mochiShare\n        mochiShare = 0;\n        treasuryShare = 0;\n    }\n\n    function sendToTreasury() external {\n        engine.usdm().transfer(engine.treasury(), treasuryShare);\n        treasuryShare = 0;\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiEngine.sol",
            "FeePoolV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-11",
                "Location": [
                    "vMochi",
                    "updateReserve()",
                    "FeePoolV",
                    "mochiShare",
                    "sendToTreasury()",
                    "distributeMochi()",
                    "veCRV",
                    "mochi",
                    "treasuryShare"
                ],
                "Type": "  treasuryShare  is Overwritten in  FeePoolV0._shareMochi() ",
                "Description": "\nThe FeePoolV0.sol contract accrues fees upon the liquidation of undercollaterised positions. These fees are split between treasury and vMochi contracts. However, when distributeMochi() is called to distribute mochi tokens to veCRV holders, both mochiShare and treasuryShare is flushed from the contract when there are still usdm tokens in the contract.\n\nConsider the following scenario:\n\n*   The FeePoolV0.sol contract contains 100 usdm tokens at an exchange rate of 1:1 with mochi tokens.\n*   updateReserve() is called to set the split of usdm tokens such that treasuryShare has claim on 20 usdm tokens and mochiShare has claim on the other 80 tokens.\n*   A veCRV holder seeks to increase their earnings by calling distributeMochi() before sendToTreasury() has been called.\n*   As a result, 80 usdm tokens are converted to mochi tokens and  locked in a curve rewards pool.\n*   Consequently, mochiShare and treasuryShare is set to 0 (aka flushed).\n*   The same user calls updateReserve() to split the leftover 20 usdm tokens between treasuryShare and mochiShare.\n*   mochiShare is now set to 16 usdm tokens.\n*   The above process is repeated to distribute mochi tokens to veCRV holders again and again.\n*   The end result is that veCRV holders have been able to receive all tokens that were intended to be distributed to the treasury.\n\n\nFeePoolV0.sol L94(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L94)\n\nManual code review\nDiscussions with the Mochi team.\n\n",
                "Repair": "Consider removing the line in FeePoolV0.sol (mentioned above), where treasuryShare is flushed.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/89)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./vault/MochiVaultFactory.sol\";\nimport \"./assets/usdm.sol\";\nimport \"./interfaces/IMochiEngine.sol\";\n\ncontract MochiEngine is IMochiEngine {\n    // immutable values\n    IMochiVaultFactory public immutable override vaultFactory;\n    // mutable values\n    IMochi public override mochi;\n    IVMochi public override vMochi;\n    address public override governance;\n    address public override treasury;\n    address public override operationWallet;\n    IUSDM public override usdm;\n    IMinter public override minter;\n    ICSSRRouter public override cssr;\n    IMochiProfile public override mochiProfile;\n    IDiscountProfile public override discountProfile;\n    ILiquidator public override liquidator;\n    IFeePool public override feePool;\n    IReferralFeePool public override referralFeePool;\n    IMochiNFT public override nft;\n\n    constructor(address _governance) {\n        governance = _governance;\n        vaultFactory = IMochiVaultFactory(new MochiVaultFactory(address(this)));\n        operationWallet = msg.sender;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == governance, \"!gov\");\n        _;\n    }\n\n    function changeMochi(address _mochi) external onlyGov {\n        mochi = IMochi(_mochi);\n    }\n\n    function changeVMochi(address _vmochi) external onlyGov {\n        vMochi = IVMochi(_vmochi);\n    }\n\n    function changeUSDM(address _usdm) external onlyGov {\n        usdm = IUSDM(_usdm);\n    }\n\n    function changeMinter(address _minter) external onlyGov {\n        minter = IMinter(_minter);\n    }\n\n    function changeGovernance(address _governance) external onlyGov {\n        governance = _governance;\n    }\n\n    function changeTreasury(address _treasury) external onlyGov {\n        treasury = _treasury;\n    }\n\n    function changeOperationWallet(address _operation) external onlyGov {\n        operationWallet = _operation;\n    }\n\n    function changeCSSR(address _cssr) external onlyGov {\n        cssr = ICSSRRouter(_cssr);\n    }\n\n    function changeProfile(address _profile) external onlyGov {\n        mochiProfile = IMochiProfile(_profile);\n    }\n\n    function changeDiscountProfile(address _profile) external onlyGov {\n        discountProfile = IDiscountProfile(_profile);\n    }\n\n    function changeLiquidator(address _liquidator) external onlyGov {\n        liquidator = ILiquidator(_liquidator);\n    }\n\n    function changeFeePool(address _feePool) external onlyGov {\n        feePool = IFeePool(_feePool);\n    }\n\n    function changeReferralFeePool(address _referralFeePool) external onlyGov {\n        referralFeePool = IReferralFeePool(_referralFeePool);\n    }\n\n    function changeNFT(address _nft) external onlyGov {\n        nft = IMochiNFT(_nft);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMochi.sol\";\nimport \"@mochifi/vmochi/contracts/interfaces/IVMochi.sol\";\n\ncontract VestedRewardPool {\n    IMochi public immutable mochi;\n    IVMochi public immutable vMochi;\n\n    uint256 public mochiUnderManagement;\n\n    mapping(address => Vesting) public vesting;\n\n    struct Vesting {\n        uint256 vested;\n        uint256 ends;\n        uint256 claimable;\n    }\n\n    modifier checkClaimable(address recipient) {\n        if (vesting[recipient].ends < block.timestamp) {\n            vesting[recipient].claimable += vesting[recipient].vested;\n            vesting[recipient].vested = 0;\n            vesting[recipient].ends = 0;\n        }\n        _;\n    }\n\n    constructor(address _mochi, address _vmochi) {\n        mochi = IMochi(_mochi);\n        vMochi = IVMochi(_vmochi);\n    }\n\n    function vest(address _recipient) external checkClaimable(_recipient) {\n        uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;\n        uint256 weightedEnd = (vesting[_recipient].vested *\n            vesting[_recipient].ends +\n            amount *\n            (block.timestamp + 90 days)) /\n            (vesting[_recipient].vested + amount);\n        vesting[_recipient].vested += amount;\n        vesting[_recipient].ends = weightedEnd;\n        mochiUnderManagement += amount;\n    }\n\n    function claim() external checkClaimable(msg.sender) {\n        mochi.transfer(msg.sender, vesting[msg.sender].claimable);\n        mochiUnderManagement -= vesting[msg.sender].claimable;\n        vesting[msg.sender].claimable = 0;\n    }\n\n    function lock(uint256 _amount) external checkClaimable(msg.sender) {\n        mochi.approve(address(vMochi), _amount);\n        (, uint256 end) = vMochi.locked(msg.sender);\n        if (end >= block.timestamp + 90 days) {\n            vMochi.depositFor(msg.sender, _amount);\n        } else {\n            revert(\"lock should be longer than 90 days\");\n        }\n        vesting[msg.sender].vested -= _amount;\n        mochiUnderManagement -= _amount;\n    }\n\n    function forceClaim(uint256 _amount) external checkClaimable(msg.sender) {\n        mochi.transfer(msg.sender, _amount / 2);\n        mochi.transfer(address(vMochi), _amount / 2);\n        vesting[msg.sender].vested -= _amount;\n        mochiUnderManagement -= _amount;\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiEngine.sol",
            "VestedRewardPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-13",
                "Location": [
                    "mochi",
                    "lock()",
                    "vest()"
                ],
                "Type": " Tokens Can Be Stolen By Frontrunning  VestedRewardPool.vest()  and  VestedRewardPool.lock() ",
                "Description": "\nThe VestedRewardPool.sol contract is a public facing contract aimed at vesting tokens for a minimum of 90 days before allowing the recipient to withdraw their mochi. The vest() function does not utilise safeTransferFrom() to ensure that vested tokens are correctly allocated to the recipient. As a result, it is possible to frontrun a call to vest() and effectively steal a recipient's vested tokens. The same issue applies to the lock() function.\n\nVestedRewardPool.sol#L36 L46(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46)\nVestedRewardPool.sol#L54 L64(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L54-L64)\n\nManual code review\nDiscussions with the Mochi team\n\n",
                "Repair": "Ensure that users understand that this function should not be interacted directly as this could result in lost mochi tokens. Additionally, it might be worthwhile creating a single externally facing function which calls safeTransferFrom(), vest() and lock() in a single transaction.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/92)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMochiProfile.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\n///@notice this is where policies including some math is registered will be able to swap the profile when current profile is not suitable\n///@dev this profile is built with https://docs.google.com/spreadsheets/d/1T2WKpwj5QmueR7O8R9AXNbnHLc-rJ_-8DLdRI2eJZqA\ncontract MochiProfileV0 is IMochiProfile {\n    using Float for float;\n    using Float for uint256;\n    IMochiEngine public immutable engine;\n\n    uint256 public override liquidityRequirement;\n\n    uint256 public override minimumDebt;\n\n    mapping(address => AssetClass) internal _assetClass;\n\n    mapping(address => uint256) public override creditCap;\n\n    uint256 public immutable secPerYear;\n\n    uint256 public override delay;\n\n    constructor(address _engine) {\n        secPerYear = 31536000;\n        engine = IMochiEngine(_engine);\n\n        liquidityRequirement = 1000000e18; // 1million dollar\n        minimumDebt = 1000e18;\n        delay = 3 minutes;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == engine.governance(), \"!gov\");\n        _;\n    }\n\n    function assetClass(address _asset)\n        public\n        view\n        override\n        returns (AssetClass)\n    {\n        return _assetClass[_asset];\n    }\n\n    function changeLiquidityRequirement(uint256 _requirement)\n        external\n        override\n        onlyGov\n    {\n        liquidityRequirement = _requirement;\n    }\n\n    function registerAsset(address _asset) external {\n        uint256 liq = engine.cssr().getLiquidity(_asset);\n        require(liq >= liquidityRequirement, \"<liquidity\");\n        _register(_asset, AssetClass.Sigma);\n    }\n\n    function registerAssetByGov(\n        address[] calldata _asset,\n        AssetClass[] calldata _classes\n    ) external onlyGov {\n        for (uint256 i = 0; i < _asset.length; i++) {\n            _register(_asset[i], _classes[i]);\n            engine.vaultFactory().deployVault(_asset[i]);\n        }\n    }\n\n    function _register(address _asset, AssetClass _class) internal {\n        _assetClass[_asset] = _class;\n    }\n\n    function changeMinimumDebt(uint256 _debt) external override onlyGov {\n        minimumDebt = _debt;\n    }\n\n    function changeAssetClass(\n        address[] calldata _assets,\n        AssetClass[] calldata _classes\n    ) external override onlyGov {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _assetClass[_assets[i]] = _classes[i];\n        }\n    }\n\n    function changeCreditCap(\n        address[] calldata _assets,\n        uint256[] calldata _caps\n    ) external onlyGov {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            creditCap[_assets[i]] = _caps[i];\n        }\n    }\n\n    function setDelay(uint256 _delay) external onlyGov {\n        delay = _delay;\n    }\n\n    ///@notice The Collateral Factor at which the users vault will be liquidated\n    function liquidationFactor(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 95, denominator: 100});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 85, denominator: 100});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 80, denominator: 100});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 75, denominator: 100});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 65, denominator: 100});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 40, denominator: 100});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function riskFactor(address _asset) public view returns (uint256) {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return 1;\n        } else if (class == AssetClass.Alpha) {\n            return 2;\n        } else if (class == AssetClass.Gamma) {\n            return 3;\n        } else if (class == AssetClass.Delta) {\n            return 4;\n        } else if (class == AssetClass.Zeta) {\n            return 5;\n        } else if (class == AssetClass.Sigma) {\n            return 6;\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function maxCollateralFactor(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 90, denominator: 100});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 80, denominator: 100});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 75, denominator: 100});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 65, denominator: 100});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 55, denominator: 100});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 45, denominator: 100});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function baseFee() public pure returns (float memory) {\n        return float({numerator: 5, denominator: 1000});\n    }\n\n    function liquidationFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 45, denominator: 1000});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 100, denominator: 1000});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 125, denominator: 1000});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 150, denominator: 1000});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 175, denominator: 1000});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 200, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function keeperFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 5, denominator: 1000});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 10, denominator: 1000});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 15, denominator: 1000});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 20, denominator: 1000});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 25, denominator: 1000});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 30, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function maxFee(AssetClass _class) public pure returns (float memory) {\n        if (_class == AssetClass.Stable) {\n            return float({numerator: 10, denominator: 1000});\n        } else if (_class == AssetClass.Alpha) {\n            return float({numerator: 15, denominator: 1000});\n        } else if (_class == AssetClass.Gamma) {\n            return float({numerator: 20, denominator: 1000});\n        } else if (_class == AssetClass.Delta) {\n            return float({numerator: 21, denominator: 1000});\n        } else if (_class == AssetClass.Zeta) {\n            return float({numerator: 22, denominator: 1000});\n        } else if (_class == AssetClass.Sigma) {\n            return float({numerator: 23, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function stabilityFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        float memory base = baseFee();\n        AssetClass class = assetClass(_asset);\n        float memory max = maxFee(class);\n        float memory u = utilizationRatio(_asset);\n        if (u.gt(float({numerator: 1, denominator: 1}))) {\n            return max;\n        }\n        return base.add(max.sub(base).mul(u));\n    }\n\n    function calculateFeeIndex(\n        address _asset,\n        uint256 _currentIndex,\n        uint256 _lastAccrued\n    ) external view override returns (uint256) {\n        float memory feePerYear = stabilityFee(_asset);\n        uint256 timePassed = block.timestamp - _lastAccrued;\n        float memory feeAccumulated = feePerYear.mul(\n            float({numerator: timePassed, denominator: secPerYear})\n        );\n        return _currentIndex + _currentIndex.multiply(feeAccumulated);\n    }\n\n    ///@dev returns utilization ratio scaled with 1e18\n    function utilizationRatio(address _asset)\n        public\n        view\n        override\n        returns (float memory ratio)\n    {\n        IMochiVault vault = engine.vaultFactory().getVault(_asset);\n        uint256 debts = vault.debts();\n        uint256 cap = creditCap[_asset];\n        return float({numerator: debts, denominator: cap});\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiProfileV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\nfunction liquidationFactor(address _asset)\n    public\n    view\n    override\n    returns (float memory)\n{\n    AssetClass class = assetClass(_asset);\n    if (class == AssetClass.Sigma) { // } else if (class == AssetClass.Sigma) {\n        return float({numerator: 40, denominator: 100});\n    }\n}\n\nfunction maxCollateralFactor(address _asset)\n    public\n    view\n    override\n    returns (float memory)\n{\n    AssetClass class = assetClass(_asset);\n    if (class == AssetClass.Sigma) {\n        return float({numerator: 45, denominator: 100});\n    }\n}\n"
                ],
                "Type": " liquidation factor < collateral factor for Sigma type",
                "Description": "\nThe MochiProfileV0 defines liquidation and collateral factors for different asset types.\nFor the AssetClass.Sigma type, the liquidation factor is *less* than the collateral factor:\n\nsolidity\nfunction liquidationFactor(address _asset)\n    public\n    view\n    override\n    returns (float memory)\n{\n    AssetClass class = assetClass(_asset);\n    if (class == AssetClass.Sigma) { // } else if (class == AssetClass.Sigma) {\n        return float({numerator: 40, denominator: 100});\n    }\n}\n\nfunction maxCollateralFactor(address _asset)\n    public\n    view\n    override\n    returns (float memory)\n{\n    AssetClass class = assetClass(_asset);\n    if (class == AssetClass.Sigma) {\n        return float({numerator: 45, denominator: 100});\n    }\n}\n\n\nThis means that one can take a loan of up to 45% of their collateral but then immediately gets liquidated as the liquidation factor is only 40%.\nThere should always be a buffer between these such that taking the max loan does not immediately lead to liquidations:\n\n A safety buffer is maintained between max CF and LF to protect users against liquidations due to normal volatility. Docs(https://hackmd.io/@az-/mochi-whitepaper#Collateral-Factor-CF)\n\n",
                "Repair": "The max collateral factor for the Sigma type should be higher than its liquidation factor.\n\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/126)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    /// storage variables\n    uint256 public override deposits;\n    uint256 public override debts;\n    int256 public override claimable;\n\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\n    ///E.g. If the stability fees are 10% for a year\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\n\n    /// result\n    uint256 public liquidated;\n\n    mapping(uint256 => Detail) public override details;\n    mapping(uint256 => uint256) public lastDeposit;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n\n    modifier wait(uint256 _id) {\n        require(\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\n            \"!wait\"\n        );\n        accrueDebt(_id);\n        _;\n    }\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function initialize(address _asset) external override initializer {\n        asset = IERC20(_asset);\n        debtIndex = 1e18;\n        lastAccrued = block.timestamp;\n    }\n\n    function liveDebtIndex() public view override returns (uint256 index) {\n        return\n            engine.mochiProfile().calculateFeeIndex(\n                address(asset),\n                debtIndex,\n                lastAccrued\n            );\n    }\n\n    function status(uint256 _id) public view override returns (Status) {\n        return details[_id].status;\n    }\n\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        require(details[_id].status != Status.Invalid, \"invalid\");\n        uint256 newIndex = liveDebtIndex();\n        return (details[_id].debt * newIndex) / details[_id].debtIndex;\n    }\n\n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function increase(\n        uint256 _id,\n        uint256 _deposits,\n        uint256 _borrows,\n        address _referrer,\n        bytes memory _data\n    ) external {\n        if (_id == type(uint256).max) {\n            // mint if _id is -1\n            _id = mint(msg.sender, _referrer);\n        }\n        if (_deposits > 0) {\n            deposit(_id, _deposits);\n        }\n        if (_borrows > 0) {\n            borrow(_id, _borrows, _data);\n        }\n    }\n\n    function decrease(\n        uint256 _id,\n        uint256 _withdraws,\n        uint256 _repays,\n        bytes memory _data\n    ) external {\n        if (_repays > 0) {\n            repay(_id, _repays);\n        }\n        if (_withdraws > 0) {\n            withdraw(_id, _withdraws, _data);\n        }\n    }\n\n    function mint(address _recipient, address _referrer)\n        public\n        returns (uint256 id)\n    {\n        id = engine.nft().mint(address(asset), _recipient);\n        details[id].debtIndex = liveDebtIndex();\n        details[id].status = Status.Idle;\n        details[id].referrer = _referrer;\n    }\n\n    /// anyone can deposit collateral to given id\n    /// it will even allow depositing to liquidated vault so becareful when depositing\n    function deposit(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        // should it be able to deposit if invalid?\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        require(\n            details[_id].status == Status.Idle ||\n                details[_id].status == Status.Collaterized ||\n                details[_id].status == Status.Active,\n            \"!depositable\"\n        );\n        lastDeposit[_id] = block.timestamp;\n        deposits += _amount;\n        details[_id].collateral += _amount;\n        if (details[_id].status == Status.Idle) {\n            details[_id].status = Status.Collaterized;\n        }\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// should only be able to withdraw if status is not liquidatable\n    function withdraw(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override wait(_id) {\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        require(\n            !_liquidatable(\n                details[_id].collateral - _amount,\n                price,\n                details[_id].debt\n            ),\n            \"!healthy\"\n        );\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = (details[_id].collateral - _amount)\n            .multiply(cf)\n            .multiply(price);\n        require(details[_id].debt <= maxMinted, \">cf\");\n        deposits -= _amount;\n        details[_id].collateral -= _amount;\n        if (details[_id].collateral == 0) {\n            details[_id].status = Status.Idle;\n        }\n        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n\n    /// someone sends usdm to this address and repays the debt\n    /// will payback the leftover usdm\n    function repay(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        if (_amount > details[_id].debt) {\n            _amount = details[_id].debt;\n        }\n        require(_amount > 0, \"zero\");\n        if (debts < _amount) {\n            // safe gaurd to some underflows\n            debts = 0;\n        } else {\n            debts -= _amount;\n        }\n        details[_id].debt -= _amount;\n        if (details[_id].debt == 0) {\n            details[_id].status = Status.Collaterized;\n        }\n        engine.usdm().transferFrom(msg.sender, address(this), _amount);\n        engine.usdm().burn(_amount);\n    }\n\n    function liquidate(\n        uint256 _id,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external override updateDebt(_id) {\n        require(msg.sender == address(engine.liquidator()), \"!liquidator\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        float memory price = engine.cssr().getPrice(address(asset));\n        require(\n            _liquidatable(details[_id].collateral, price, currentDebt(_id)),\n            \"healthy\"\n        );\n\n        debts -= _usdm;\n\n        details[_id].collateral -= _collateral;\n        details[_id].debt -= _usdm;\n\n        asset.cheapTransfer(msg.sender, _collateral);\n    }\n\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\n    /// @notice should return false if _collateral * liquidationLimit < _debt\n    function _liquidatable(\n        uint256 _collateral,\n        float memory _price,\n        uint256 _debt\n    ) internal view returns (bool) {\n        float memory lf = engine.mochiProfile().liquidationFactor(\n            address(asset)\n        );\n        // when debt is lower than liquidation value, it can be liquidated\n        return _collateral.multiply(lf) < _debt.divide(_price);\n    }\n\n    function liquidatable(uint256 _id) external view returns (bool) {\n        float memory price = engine.cssr().getPrice(address(asset));\n        return _liquidatable(details[_id].collateral, price, currentDebt(_id));\n    }\n\n    function claim() external updateDebt(type(uint256).max) {\n        require(claimable > 0, \"!claimable\");\n        // reserving 25% to prevent potential risks\n        uint256 toClaim = (uint256(claimable) * 75) / 100;\n        mintFeeToPool(toClaim, address(0));\n    }\n\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\n        claimable -= int256(_amount);\n        if (address(0) != _referrer) {\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\n            engine.referralFeePool().addReward(_referrer);\n        } else {\n            engine.minter().mint(address(engine.treasury()), _amount);\n        }\n    }\n\n    // Flash Loan\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(asset), \"!supported\");\n        return asset.balanceOf(address(this));\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(asset), \"!supported\");\n        return (_amount * 1337) / 1000000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(asset), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        asset.cheapTransfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        asset.cheapTransferFrom(address(_receiver), address(this), _amount);\n        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\ninterface ILiquidator {\n    event Triggered(uint256 _auctionId, uint256 _price);\n    event Settled(uint256 _auctionId, uint256 _price);\n\n    function triggerLiquidation(address _asset, uint256 _nftId) external;\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@mochifi/library/contracts/Float.sol\";\nimport \"@mochifi/library/contracts/BeaconProxyDeployer.sol\";\nimport \"../interfaces/ILiquidator.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract DutchAuctionLiquidator is ILiquidator {\n    using Float for uint256;\n    IMochiEngine public immutable engine;\n\n    uint256 public constant DURATION = 2 days / 15;\n\n    struct Auction {\n        uint256 nftId;\n        address vault;\n        uint256 startedAt;\n        uint256 boughtAt;\n        uint256 collateral;\n        uint256 debt;\n    }\n\n    mapping(uint256 => Auction) public auctions;\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function auctionId(address asset, uint256 nftId)\n        public\n        pure\n        returns (uint256)\n    {\n        return uint256(keccak256(abi.encodePacked(asset, nftId)));\n    }\n\n    function price(uint256 _auctionId) external view returns (uint256) {\n        Auction memory auction = auctions[_auctionId];\n        return auction.debt + currentLiquidationFee(_auctionId);\n    }\n\n    function currentLiquidationFee(uint256 _auctionId)\n        public\n        view\n        returns (uint256 liquidationFee)\n    {\n        Auction memory auction = auctions[_auctionId];\n        liquidationFee = auction\n            .debt\n            .multiply(\n                engine.mochiProfile().liquidationFee(\n                    address(IMochiVault(auction.vault).asset())\n                )\n            )\n            .multiply(\n                float({\n                    numerator: auction.startedAt + DURATION > block.number\n                        ? auction.startedAt + DURATION - block.number\n                        : 0,\n                    denominator: DURATION\n                })\n            );\n    }\n\n    function triggerLiquidation(address _asset, uint256 _nftId)\n        external\n        override\n    {\n        IMochiVault vault = engine.vaultFactory().getVault(_asset);\n        Auction storage auction = auctions[auctionId(_asset, _nftId)];\n        require(auction.startedAt == 0 || auction.boughtAt != 0, \"on going\");\n        uint256 debt = vault.currentDebt(_nftId);\n        (, uint256 collateral, , , ) = vault.details(_nftId);\n\n        vault.liquidate(_nftId, collateral, debt);\n\n        auction.nftId = _nftId;\n        auction.vault = address(vault);\n        auction.startedAt = block.number;\n        auction.boughtAt = 0;\n        auction.collateral = collateral;\n        auction.debt = debt;\n\n        uint256 liquidationFee = debt.multiply(\n            engine.mochiProfile().liquidationFee(address(_asset))\n        );\n        emit Triggered(auctionId(_asset, _nftId), debt + liquidationFee);\n    }\n\n    function settleLiquidation(\n        uint256 _auctionId,\n        uint256 _collateral,\n        uint256 _repaid\n    ) internal {\n        Auction storage auction = auctions[_auctionId];\n        require(auction.boughtAt == 0, \"liquidated\");\n        IMochiVault vault = IMochiVault(auction.vault);\n        //repay the debt first\n        engine.usdm().transferFrom(msg.sender, address(this), _repaid);\n        engine.usdm().burn(_repaid);\n        IERC20 asset = vault.asset();\n        auction.boughtAt = block.number;\n        asset.transfer(msg.sender, _collateral);\n        //transfer liquidation fee to feePool\n        uint256 liquidationFee = currentLiquidationFee(_auctionId);\n        engine.usdm().transferFrom(\n            msg.sender,\n            address(engine.feePool()),\n            liquidationFee\n        );\n\n        emit Settled(_auctionId, _repaid + liquidationFee);\n    }\n\n    function buy(uint256 _auctionId) external {\n        Auction memory auction = auctions[_auctionId];\n        require(auction.startedAt != 0 && auction.boughtAt == 0, \"!on going\");\n        settleLiquidation(_auctionId, auction.collateral, auction.debt);\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiVault.sol",
            "ILiquidator.sol",
            "DutchAuctionLiquidator.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "triggerLiquidation()",
                    "liquidatable",
                    "settleLiquidation"
                ],
                "Type": " A malicious user can potentially escape liquidation by creating a dust amount position and trigger the liquidation by themself",
                "Description": "\nIn the current implementation, a liquidated position can be used for depositing and borrowing again.\n\nHowever, if there is a liquidation auction ongoing, even if the position is now liquidatable, the call of triggerLiquidation() will still fail.\n\nThe liquidator must settleLiquidation first.\n\nIf the current auction is not profitable for the liquidator, say the value of the collateral can not even cover the gas cost, the liquidator may be tricked and not liquidate the new loan at all.\n\nConsidering if the liquidator bot is not as small to handle this situation (take the profit of the new liquidation and the gas cost loss of the current auction into consideration), a malicious user can create a dust amount position trigger the liquidation by themself.\n\nSince the collateral of this position is so small that it can not even cover the gas cost, liquidators will most certainly ignore this auction.\n\nThe malicious user will then deposit borrow the actual loan.\n\nWhen this loan becomes liquidatable, liquidators may:\n\n1.  confuse the current dust auction with the liquidatable position;\n2.  unable to proceed with such a complex liquidation.\n\nAs a result, the malicious user can potentially escape liquidation.\n\n",
                "Repair": "Consider making liquidated positions unable to be used (for depositing and borrowing) again.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/127)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@mochifi/library/contracts/Float.sol\";\nimport \"@mochifi/library/contracts/BeaconProxyDeployer.sol\";\nimport \"../interfaces/ILiquidator.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract DutchAuctionLiquidator is ILiquidator {\n    using Float for uint256;\n    IMochiEngine public immutable engine;\n\n    uint256 public constant DURATION = 2 days / 15;\n\n    struct Auction {\n        uint256 nftId;\n        address vault;\n        uint256 startedAt;\n        uint256 boughtAt;\n        uint256 collateral;\n        uint256 debt;\n    }\n\n    mapping(uint256 => Auction) public auctions;\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function auctionId(address asset, uint256 nftId)\n        public\n        pure\n        returns (uint256)\n    {\n        return uint256(keccak256(abi.encodePacked(asset, nftId)));\n    }\n\n    function price(uint256 _auctionId) external view returns (uint256) {\n        Auction memory auction = auctions[_auctionId];\n        return auction.debt + currentLiquidationFee(_auctionId);\n    }\n\n    function currentLiquidationFee(uint256 _auctionId)\n        public\n        view\n        returns (uint256 liquidationFee)\n    {\n        Auction memory auction = auctions[_auctionId];\n        liquidationFee = auction\n            .debt\n            .multiply(\n                engine.mochiProfile().liquidationFee(\n                    address(IMochiVault(auction.vault).asset())\n                )\n            )\n            .multiply(\n                float({\n                    numerator: auction.startedAt + DURATION > block.number\n                        ? auction.startedAt + DURATION - block.number\n                        : 0,\n                    denominator: DURATION\n                })\n            );\n    }\n\n    function triggerLiquidation(address _asset, uint256 _nftId)\n        external\n        override\n    {\n        IMochiVault vault = engine.vaultFactory().getVault(_asset);\n        Auction storage auction = auctions[auctionId(_asset, _nftId)];\n        require(auction.startedAt == 0 || auction.boughtAt != 0, \"on going\");\n        uint256 debt = vault.currentDebt(_nftId);\n        (, uint256 collateral, , , ) = vault.details(_nftId);\n\n        vault.liquidate(_nftId, collateral, debt);\n\n        auction.nftId = _nftId;\n        auction.vault = address(vault);\n        auction.startedAt = block.number;\n        auction.boughtAt = 0;\n        auction.collateral = collateral;\n        auction.debt = debt;\n\n        uint256 liquidationFee = debt.multiply(\n            engine.mochiProfile().liquidationFee(address(_asset))\n        );\n        emit Triggered(auctionId(_asset, _nftId), debt + liquidationFee);\n    }\n\n    function settleLiquidation(\n        uint256 _auctionId,\n        uint256 _collateral,\n        uint256 _repaid\n    ) internal {\n        Auction storage auction = auctions[_auctionId];\n        require(auction.boughtAt == 0, \"liquidated\");\n        IMochiVault vault = IMochiVault(auction.vault);\n        //repay the debt first\n        engine.usdm().transferFrom(msg.sender, address(this), _repaid);\n        engine.usdm().burn(_repaid);\n        IERC20 asset = vault.asset();\n        auction.boughtAt = block.number;\n        asset.transfer(msg.sender, _collateral);\n        //transfer liquidation fee to feePool\n        uint256 liquidationFee = currentLiquidationFee(_auctionId);\n        engine.usdm().transferFrom(\n            msg.sender,\n            address(engine.feePool()),\n            liquidationFee\n        );\n\n        emit Settled(_auctionId, _repaid + liquidationFee);\n    }\n\n    function buy(uint256 _auctionId) external {\n        Auction memory auction = auctions[_auctionId];\n        require(auction.startedAt != 0 && auction.boughtAt == 0, \"!on going\");\n        settleLiquidation(_auctionId, auction.collateral, auction.debt);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./vault/MochiVaultFactory.sol\";\nimport \"./assets/usdm.sol\";\nimport \"./interfaces/IMochiEngine.sol\";\n\ncontract MochiEngine is IMochiEngine {\n    // immutable values\n    IMochiVaultFactory public immutable override vaultFactory;\n    // mutable values\n    IMochi public override mochi;\n    IVMochi public override vMochi;\n    address public override governance;\n    address public override treasury;\n    address public override operationWallet;\n    IUSDM public override usdm;\n    IMinter public override minter;\n    ICSSRRouter public override cssr;\n    IMochiProfile public override mochiProfile;\n    IDiscountProfile public override discountProfile;\n    ILiquidator public override liquidator;\n    IFeePool public override feePool;\n    IReferralFeePool public override referralFeePool;\n    IMochiNFT public override nft;\n\n    constructor(address _governance) {\n        governance = _governance;\n        vaultFactory = IMochiVaultFactory(new MochiVaultFactory(address(this)));\n        operationWallet = msg.sender;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == governance, \"!gov\");\n        _;\n    }\n\n    function changeMochi(address _mochi) external onlyGov {\n        mochi = IMochi(_mochi);\n    }\n\n    function changeVMochi(address _vmochi) external onlyGov {\n        vMochi = IVMochi(_vmochi);\n    }\n\n    function changeUSDM(address _usdm) external onlyGov {\n        usdm = IUSDM(_usdm);\n    }\n\n    function changeMinter(address _minter) external onlyGov {\n        minter = IMinter(_minter);\n    }\n\n    function changeGovernance(address _governance) external onlyGov {\n        governance = _governance;\n    }\n\n    function changeTreasury(address _treasury) external onlyGov {\n        treasury = _treasury;\n    }\n\n    function changeOperationWallet(address _operation) external onlyGov {\n        operationWallet = _operation;\n    }\n\n    function changeCSSR(address _cssr) external onlyGov {\n        cssr = ICSSRRouter(_cssr);\n    }\n\n    function changeProfile(address _profile) external onlyGov {\n        mochiProfile = IMochiProfile(_profile);\n    }\n\n    function changeDiscountProfile(address _profile) external onlyGov {\n        discountProfile = IDiscountProfile(_profile);\n    }\n\n    function changeLiquidator(address _liquidator) external onlyGov {\n        liquidator = ILiquidator(_liquidator);\n    }\n\n    function changeFeePool(address _feePool) external onlyGov {\n        feePool = IFeePool(_feePool);\n    }\n\n    function changeReferralFeePool(address _referralFeePool) external onlyGov {\n        referralFeePool = IReferralFeePool(_referralFeePool);\n    }\n\n    function changeNFT(address _nft) external onlyGov {\n        nft = IMochiNFT(_nft);\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\n\ncontract USDM is ERC20, IUSDM {\n    IMochiEngine public immutable engine;\n\n    uint256 private constant SCALE = 1e18;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    constructor(address _engine) ERC20(\"USDM\", \"USDM\") {\n        engine = IMochiEngine(_engine);\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == address(engine.minter()), \"!minter\");\n        _;\n    }\n\n    function mint(address _recipient, uint256 _amount)\n        external\n        override\n        onlyMinter\n    {\n        _mint(_recipient, _amount);\n    }\n\n    function burn(uint256 _amount) external override {\n        _burn(msg.sender, _amount);\n    }\n\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(this), \"!this\");\n        return type(uint256).max - totalSupply();\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(this), \"!supported\");\n        return (_amount * ((1337 * SCALE) / 1000000)) / SCALE;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(this), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        _mint(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        _burn(address(_receiver), _amount);\n        _transfer(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\ncontract Create2BeaconMaker {\n    constructor(address beacon, bytes memory initializationCalldata)\n        payable\n    {\n        (, bytes memory returnData) = beacon.staticcall(\"\");\n        address template = abi.decode(returnData, (address));\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = template.delegatecall(initializationCalldata);\n        if (!success) {\n            // pass along failure message from delegatecall and revert.\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // place eip-1167 runtime code in memory.\n        bytes memory runtimeCode =\n            abi.encodePacked(\n                bytes6(0x3d3d3d3d3d73),\n                beacon,\n                bytes32(0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd),\n                bytes2(0x5bf3)\n            );\n\n        // return Beacon Minimal Proxy code to write it to spawned contract runtime.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            return(add(0x20, runtimeCode), 60) // Beacon Minimal Proxy runtime code, length\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract MinterV0 is IMinter {\n    IMochiEngine public immutable engine;\n\n    mapping(address => bool) public isMinter;\n\n    address[] public factories;\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    modifier onlyPermission() {\n        require(hasPermission(msg.sender), \"!permission\");\n        _;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == engine.governance(), \"!gov\");\n        _;\n    }\n\n    function addMinter(address _minter) external onlyGov {\n        isMinter[_minter] = true;\n    }\n\n    function removeMinter(address _minter) external onlyGov {\n        isMinter[_minter] = false;\n    }\n\n    function mint(address _to, uint256 _amount)\n        external\n        override\n        onlyPermission\n    {\n        engine.usdm().mint(_to, _amount);\n    }\n\n    function hasPermission(address _user) public view override returns (bool) {\n        return isMinter[_user] || isVault(_user);\n    }\n\n    function isVault(address _vault) public view override returns (bool) {\n        return\n            address(\n                engine.vaultFactory().getVault(\n                    address(IMochiVault(_vault).asset())\n                )\n            ) == _vault;\n    }\n}\n\n\n",
        "CodeNames": [
            "DutchAuctionLiquidator.sol",
            "MochiEngine.sol",
            "usdm.sol",
            "Create2BeaconMaker.sol",
            "UsdmMinter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "transferFrom",
                    "void",
                    "true",
                    "asset.transfer(msg.sender, _collateral);",
                    "false",
                    "asset",
                    "transfer"
                ],
                "Type": " Unchecked ERC20 transfer calls",
                "Description": "\nERC20 transfer and transferFrom calls normally return true on a succesful transfer. In DutchAuctionLiquidator the call asset.transfer(msg.sender, _collateral); is made. asset refers to whichever ERC20 asset is used for the vault of that auction. If asset is an ERC20 token which does not comply with the EIP-20 standard it might return false on a failed transaction rather than revert. In this case it would count as a valid transaction even though it is not. If a vault would be making use of USDT the transfer call would always revert as USDT returns void on transfers.\n\nThere are a few more transfer(From) calls which are unchecked, these are however all on a predetermined asset (mochi, usdM and crv) and unlikely to cause problems.\n\nSee issue page(https://github.com/code-423n4/reports/blob/mochi/mochi/2021-10-mochi-findings-DRAFT.md) for referenced code.\n\n\nSlither\n\n",
                "Repair": "In other contracts the functions cheapTransfer and cheapTransferFrom are used which are part of the mochifi cheapERC20 library. These functions do check for a return value and could be used rather than transfer and transferFrom.\n\n### Comments:\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/75#issuecomment-952083361):\n  transferFrom and transfer functions are used for mochi and usdm tokens which are standard EIP-20 tokens.\n\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@mochifi/library/contracts/Float.sol\";\nimport \"../interfaces/IGovernanceOwned.sol\";\nimport \"../interfaces/ICSSRAdapter.sol\";\n\ncontract ChainlinkAdapterEth is ICSSRAdapter {\n    IGovernanceOwned public immutable owned;\n\n    mapping(address => AggregatorV3Interface) public feed;\n\n    modifier onlyGov() {\n        require(msg.sender == owned.governance(), \"!gov\");\n        _;\n    }\n\n    constructor(address _owned) {\n        owned = IGovernanceOwned(_owned);\n    }\n\n    function update(address _asset, bytes calldata _data)\n        external\n        override\n        returns (float memory)\n    {\n        return getPrice(_asset);\n    }\n\n    function setFeed(address[] calldata _assets, address[] calldata _feeds) external onlyGov {\n        for(uint256 i = 0; i<_assets.length; i++) {\n            feed[_assets[i]] = AggregatorV3Interface(_feeds[i]);\n        }\n    }\n\n    function support(address _asset) external view override returns (bool) {\n        return address(feed[_asset]) != address(0);\n    }\n\n    function getPrice(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        (, int256 price, , , ) = feed[_asset].latestRoundData();\n        uint256 decimalSum = feed[_asset].decimals() +\n            IERC20Metadata(_asset).decimals();\n        if (decimalSum > 18) {\n            return\n                float({\n                    numerator: uint256(price),\n                    denominator: 10**(decimalSum - 18)\n                });\n        } else {\n            return\n                float({\n                    numerator: uint256(price) * 10**(18 - decimalSum),\n                    denominator: 1\n                });\n        }\n    }\n\n    function getLiquidity(address _asset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        revert(\"chainlink adapter does not support liquidity\");\n    }\n}\n\n\n",
        "CodeNames": [
            "ChainlinkAdapter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "latestRoundData()",
                    "latestRoundData"
                ],
                "Type": " Chainlink's  latestRoundData  might return stale or incorrect results",
                "Description": "\nChainlinkAdapter.sol L49(https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/ChainlinkAdapter.sol#L49)\n\nThe ChainlinkAdapter calls out to a Chainlink oracle receiving the latestRoundData(). If there is a problem with Chainlink starting a new round and finding consensus on the new value for the oracle (e.g. Chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale or incorrect data (if oracles are unable to submit no new round is started).\n\n",
                "Repair": "Recommend adding the following checks:\nsolidity\n    ( roundId, rawPrice, , updateTime, answeredInRound ) = AggregatorV3Interface(XXXXX).latestRoundData();\n    require(rawPrice  0, \"Chainlink price <= 0\");\n    require(updateTime != 0, \"Incomplete round\");\n    require(answeredInRound = roundId, \"Stale price\");\n\n#### References\n*   <https://consensys.net/diligence/audits/2021/09/fei-protocol-v2-phase-1/#chainlinkoraclewrapper-latestrounddata-might-return-stale-results\n*   <https://github.com/code-423n4/2021-05-fairside-findings/issues/70\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/87)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@mochifi/library/contracts/Float.sol\";\n\nenum AssetClass {\n    Invalid,\n    Stable,\n    Alpha,\n    Gamma,\n    Delta,\n    Zeta,\n    Sigma,\n    Revoked\n}\n\ninterface IMochiProfile {\n    function assetClass(address _asset) external view returns (AssetClass);\n\n    function liquidityRequirement() external view returns (uint256);\n\n    function minimumDebt() external view returns (uint256);\n\n    function changeAssetClass(\n        address[] calldata _asset,\n        AssetClass[] calldata _class\n    ) external;\n\n    function changeLiquidityRequirement(uint256 _requirement) external;\n\n    function changeMinimumDebt(uint256 _debt) external;\n\n    function calculateFeeIndex(\n        address _asset,\n        uint256 _currentIndex,\n        uint256 _lastAccrued\n    ) external view returns (uint256);\n\n    function creditCap(address _asset) external view returns (uint256);\n\n    function delay() external view returns (uint256);\n\n    function liquidationFactor(address _asset)\n        external\n        view\n        returns (float memory);\n\n    function maxCollateralFactor(address _asset)\n        external\n        view\n        returns (float memory);\n\n    function stabilityFee(address _asset) external view returns (float memory);\n\n    function liquidationFee(address _asset)\n        external\n        view\n        returns (float memory);\n\n    function keeperFee(address _asset) external view returns (float memory);\n\n    function utilizationRatio(address _asset)\n        external\n        view\n        returns (float memory);\n}\n\n\n// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    /// storage variables\n    uint256 public override deposits;\n    uint256 public override debts;\n    int256 public override claimable;\n\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\n    ///E.g. If the stability fees are 10% for a year\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\n\n    /// result\n    uint256 public liquidated;\n\n    mapping(uint256 => Detail) public override details;\n    mapping(uint256 => uint256) public lastDeposit;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n\n    modifier wait(uint256 _id) {\n        require(\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\n            \"!wait\"\n        );\n        accrueDebt(_id);\n        _;\n    }\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function initialize(address _asset) external override initializer {\n        asset = IERC20(_asset);\n        debtIndex = 1e18;\n        lastAccrued = block.timestamp;\n    }\n\n    function liveDebtIndex() public view override returns (uint256 index) {\n        return\n            engine.mochiProfile().calculateFeeIndex(\n                address(asset),\n                debtIndex,\n                lastAccrued\n            );\n    }\n\n    function status(uint256 _id) public view override returns (Status) {\n        return details[_id].status;\n    }\n\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        require(details[_id].status != Status.Invalid, \"invalid\");\n        uint256 newIndex = liveDebtIndex();\n        return (details[_id].debt * newIndex) / details[_id].debtIndex;\n    }\n\n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function increase(\n        uint256 _id,\n        uint256 _deposits,\n        uint256 _borrows,\n        address _referrer,\n        bytes memory _data\n    ) external {\n        if (_id == type(uint256).max) {\n            // mint if _id is -1\n            _id = mint(msg.sender, _referrer);\n        }\n        if (_deposits > 0) {\n            deposit(_id, _deposits);\n        }\n        if (_borrows > 0) {\n            borrow(_id, _borrows, _data);\n        }\n    }\n\n    function decrease(\n        uint256 _id,\n        uint256 _withdraws,\n        uint256 _repays,\n        bytes memory _data\n    ) external {\n        if (_repays > 0) {\n            repay(_id, _repays);\n        }\n        if (_withdraws > 0) {\n            withdraw(_id, _withdraws, _data);\n        }\n    }\n\n    function mint(address _recipient, address _referrer)\n        public\n        returns (uint256 id)\n    {\n        id = engine.nft().mint(address(asset), _recipient);\n        details[id].debtIndex = liveDebtIndex();\n        details[id].status = Status.Idle;\n        details[id].referrer = _referrer;\n    }\n\n    /// anyone can deposit collateral to given id\n    /// it will even allow depositing to liquidated vault so becareful when depositing\n    function deposit(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        // should it be able to deposit if invalid?\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        require(\n            details[_id].status == Status.Idle ||\n                details[_id].status == Status.Collaterized ||\n                details[_id].status == Status.Active,\n            \"!depositable\"\n        );\n        lastDeposit[_id] = block.timestamp;\n        deposits += _amount;\n        details[_id].collateral += _amount;\n        if (details[_id].status == Status.Idle) {\n            details[_id].status = Status.Collaterized;\n        }\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// should only be able to withdraw if status is not liquidatable\n    function withdraw(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override wait(_id) {\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        require(\n            !_liquidatable(\n                details[_id].collateral - _amount,\n                price,\n                details[_id].debt\n            ),\n            \"!healthy\"\n        );\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = (details[_id].collateral - _amount)\n            .multiply(cf)\n            .multiply(price);\n        require(details[_id].debt <= maxMinted, \">cf\");\n        deposits -= _amount;\n        details[_id].collateral -= _amount;\n        if (details[_id].collateral == 0) {\n            details[_id].status = Status.Idle;\n        }\n        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n\n    /// someone sends usdm to this address and repays the debt\n    /// will payback the leftover usdm\n    function repay(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        if (_amount > details[_id].debt) {\n            _amount = details[_id].debt;\n        }\n        require(_amount > 0, \"zero\");\n        if (debts < _amount) {\n            // safe gaurd to some underflows\n            debts = 0;\n        } else {\n            debts -= _amount;\n        }\n        details[_id].debt -= _amount;\n        if (details[_id].debt == 0) {\n            details[_id].status = Status.Collaterized;\n        }\n        engine.usdm().transferFrom(msg.sender, address(this), _amount);\n        engine.usdm().burn(_amount);\n    }\n\n    function liquidate(\n        uint256 _id,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external override updateDebt(_id) {\n        require(msg.sender == address(engine.liquidator()), \"!liquidator\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        float memory price = engine.cssr().getPrice(address(asset));\n        require(\n            _liquidatable(details[_id].collateral, price, currentDebt(_id)),\n            \"healthy\"\n        );\n\n        debts -= _usdm;\n\n        details[_id].collateral -= _collateral;\n        details[_id].debt -= _usdm;\n\n        asset.cheapTransfer(msg.sender, _collateral);\n    }\n\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\n    /// @notice should return false if _collateral * liquidationLimit < _debt\n    function _liquidatable(\n        uint256 _collateral,\n        float memory _price,\n        uint256 _debt\n    ) internal view returns (bool) {\n        float memory lf = engine.mochiProfile().liquidationFactor(\n            address(asset)\n        );\n        // when debt is lower than liquidation value, it can be liquidated\n        return _collateral.multiply(lf) < _debt.divide(_price);\n    }\n\n    function liquidatable(uint256 _id) external view returns (bool) {\n        float memory price = engine.cssr().getPrice(address(asset));\n        return _liquidatable(details[_id].collateral, price, currentDebt(_id));\n    }\n\n    function claim() external updateDebt(type(uint256).max) {\n        require(claimable > 0, \"!claimable\");\n        // reserving 25% to prevent potential risks\n        uint256 toClaim = (uint256(claimable) * 75) / 100;\n        mintFeeToPool(toClaim, address(0));\n    }\n\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\n        claimable -= int256(_amount);\n        if (address(0) != _referrer) {\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\n            engine.referralFeePool().addReward(_referrer);\n        } else {\n            engine.minter().mint(address(engine.treasury()), _amount);\n        }\n    }\n\n    // Flash Loan\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(asset), \"!supported\");\n        return asset.balanceOf(address(this));\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(asset), \"!supported\");\n        return (_amount * 1337) / 1000000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(asset), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        asset.cheapTransfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        asset.cheapTransferFrom(address(_receiver), address(this), _amount);\n        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMochiProfile.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\n///@notice this is where policies including some math is registered will be able to swap the profile when current profile is not suitable\n///@dev this profile is built with https://docs.google.com/spreadsheets/d/1T2WKpwj5QmueR7O8R9AXNbnHLc-rJ_-8DLdRI2eJZqA\ncontract MochiProfileV0 is IMochiProfile {\n    using Float for float;\n    using Float for uint256;\n    IMochiEngine public immutable engine;\n\n    uint256 public override liquidityRequirement;\n\n    uint256 public override minimumDebt;\n\n    mapping(address => AssetClass) internal _assetClass;\n\n    mapping(address => uint256) public override creditCap;\n\n    uint256 public immutable secPerYear;\n\n    uint256 public override delay;\n\n    constructor(address _engine) {\n        secPerYear = 31536000;\n        engine = IMochiEngine(_engine);\n\n        liquidityRequirement = 1000000e18; // 1million dollar\n        minimumDebt = 1000e18;\n        delay = 3 minutes;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == engine.governance(), \"!gov\");\n        _;\n    }\n\n    function assetClass(address _asset)\n        public\n        view\n        override\n        returns (AssetClass)\n    {\n        return _assetClass[_asset];\n    }\n\n    function changeLiquidityRequirement(uint256 _requirement)\n        external\n        override\n        onlyGov\n    {\n        liquidityRequirement = _requirement;\n    }\n\n    function registerAsset(address _asset) external {\n        uint256 liq = engine.cssr().getLiquidity(_asset);\n        require(liq >= liquidityRequirement, \"<liquidity\");\n        _register(_asset, AssetClass.Sigma);\n    }\n\n    function registerAssetByGov(\n        address[] calldata _asset,\n        AssetClass[] calldata _classes\n    ) external onlyGov {\n        for (uint256 i = 0; i < _asset.length; i++) {\n            _register(_asset[i], _classes[i]);\n            engine.vaultFactory().deployVault(_asset[i]);\n        }\n    }\n\n    function _register(address _asset, AssetClass _class) internal {\n        _assetClass[_asset] = _class;\n    }\n\n    function changeMinimumDebt(uint256 _debt) external override onlyGov {\n        minimumDebt = _debt;\n    }\n\n    function changeAssetClass(\n        address[] calldata _assets,\n        AssetClass[] calldata _classes\n    ) external override onlyGov {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _assetClass[_assets[i]] = _classes[i];\n        }\n    }\n\n    function changeCreditCap(\n        address[] calldata _assets,\n        uint256[] calldata _caps\n    ) external onlyGov {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            creditCap[_assets[i]] = _caps[i];\n        }\n    }\n\n    function setDelay(uint256 _delay) external onlyGov {\n        delay = _delay;\n    }\n\n    ///@notice The Collateral Factor at which the users vault will be liquidated\n    function liquidationFactor(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 95, denominator: 100});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 85, denominator: 100});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 80, denominator: 100});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 75, denominator: 100});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 65, denominator: 100});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 40, denominator: 100});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function riskFactor(address _asset) public view returns (uint256) {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return 1;\n        } else if (class == AssetClass.Alpha) {\n            return 2;\n        } else if (class == AssetClass.Gamma) {\n            return 3;\n        } else if (class == AssetClass.Delta) {\n            return 4;\n        } else if (class == AssetClass.Zeta) {\n            return 5;\n        } else if (class == AssetClass.Sigma) {\n            return 6;\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function maxCollateralFactor(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 90, denominator: 100});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 80, denominator: 100});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 75, denominator: 100});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 65, denominator: 100});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 55, denominator: 100});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 45, denominator: 100});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function baseFee() public pure returns (float memory) {\n        return float({numerator: 5, denominator: 1000});\n    }\n\n    function liquidationFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 45, denominator: 1000});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 100, denominator: 1000});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 125, denominator: 1000});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 150, denominator: 1000});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 175, denominator: 1000});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 200, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function keeperFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 5, denominator: 1000});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 10, denominator: 1000});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 15, denominator: 1000});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 20, denominator: 1000});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 25, denominator: 1000});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 30, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function maxFee(AssetClass _class) public pure returns (float memory) {\n        if (_class == AssetClass.Stable) {\n            return float({numerator: 10, denominator: 1000});\n        } else if (_class == AssetClass.Alpha) {\n            return float({numerator: 15, denominator: 1000});\n        } else if (_class == AssetClass.Gamma) {\n            return float({numerator: 20, denominator: 1000});\n        } else if (_class == AssetClass.Delta) {\n            return float({numerator: 21, denominator: 1000});\n        } else if (_class == AssetClass.Zeta) {\n            return float({numerator: 22, denominator: 1000});\n        } else if (_class == AssetClass.Sigma) {\n            return float({numerator: 23, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function stabilityFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        float memory base = baseFee();\n        AssetClass class = assetClass(_asset);\n        float memory max = maxFee(class);\n        float memory u = utilizationRatio(_asset);\n        if (u.gt(float({numerator: 1, denominator: 1}))) {\n            return max;\n        }\n        return base.add(max.sub(base).mul(u));\n    }\n\n    function calculateFeeIndex(\n        address _asset,\n        uint256 _currentIndex,\n        uint256 _lastAccrued\n    ) external view override returns (uint256) {\n        float memory feePerYear = stabilityFee(_asset);\n        uint256 timePassed = block.timestamp - _lastAccrued;\n        float memory feeAccumulated = feePerYear.mul(\n            float({numerator: timePassed, denominator: secPerYear})\n        );\n        return _currentIndex + _currentIndex.multiply(feeAccumulated);\n    }\n\n    ///@dev returns utilization ratio scaled with 1e18\n    function utilizationRatio(address _asset)\n        public\n        view\n        override\n        returns (float memory ratio)\n    {\n        IMochiVault vault = engine.vaultFactory().getVault(_asset);\n        uint256 debts = vault.debts();\n        uint256 cap = creditCap[_asset];\n        return float({numerator: debts, denominator: cap});\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nstruct Detail {\n    Status status;\n    uint256 collateral;\n    uint256 debt;\n    uint256 debtIndex;\n    address referrer;\n}\n\nenum Status {\n    Invalid, // not minted\n    Idle, // debt = 0, collateral = 0\n    Collaterized, // debt = 0, collateral > 0\n    Active, // debt > 0, collateral > 0\n    Liquidated\n}\n\ninterface IMochiVault {\n    function liveDebtIndex() external view returns (uint256);\n\n    function details(uint256 _nftId)\n        external\n        view\n        returns (\n            Status,\n            uint256 collateral,\n            uint256 debt,\n            uint256 debtIndexe,\n            address refferer\n        );\n\n    function status(uint256 _nftId) external view returns (Status);\n\n    function asset() external view returns (IERC20);\n\n    function deposits() external view returns (uint256);\n\n    function debts() external view returns (uint256);\n\n    function claimable() external view returns (int256);\n\n    function currentDebt(uint256 _nftId) external view returns (uint256);\n\n    function initialize(address _asset) external;\n\n    function deposit(uint256 _nftId, uint256 _amount) external;\n\n    function withdraw(\n        uint256 _nftId,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n\n    function borrow(\n        uint256 _nftId,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n\n    function repay(uint256 _nftId, uint256 _amount) external;\n\n    function liquidate(\n        uint256 _nftId,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external;\n}\n\n\n",
        "CodeNames": [
            "IMochiProfile.sol",
            "MochiVault.sol",
            "MochiProfileV0.sol",
            "IMochiVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "increased =",
                    "accrueDebt",
                    "discountedDebt =",
                    "debts",
                    "debts =",
                    "increasedDebt =",
                    "debt",
                    "debtIndex ="
                ],
                "Type": " Debt accrual is path-dependant and inaccurate",
                "Description": "\nThe total debt in MochiVault.accrueDebt increases by the current debt times the debt index growth.\nThis is correct but the total debt is then *reduced* again by the calling *user's* discounted debt, meaning, the total debt depends on which specific user performs the debt accrual.\n\nThis should not be the case.\n\nAssume we have a total debt of 2000, two users A and B, where A has a debt of 1000, and B has a debt of 100.\nThe (previous) debtIndex = 1.0 and accruing it now would increase it to 1.1.\n\nThere's a difference if user A or B first does the accrual.\n\nUser A calls accrueDebt: increased = 2000 * 1.1/1.0 2000 = 200. Thus debts is first set to 2200. The user's increasedDebt = 1000 * 1.1 / 1.0 1000 = 100 and assume a discount of 10%, thus discountedDebt = 100 * 10% = 10.\nThen debts = 2200 10 = 2190.\n\nThe next accrual will work with a total debt of 2190.\n\nUser B calls accrueDebt: increased = 2000 * 1.1/1.0 2000 = 200. Thus debts is first set to 2200. The user's increasedDebt = 100 * 1.1 / 1.0 100 = 10 and assume a discount of 10%, thus discountedDebt = 10 * 10% = 1.\nThen debts = 2200 1 = 2199.\n\nThe next accrual will work with a total debt of 2199, leading to more debt overall.\n\nThe total debt of a system depends on who performs the accruals which should ideally not be the case.\nThe discrepancy compounds and can grow quite large if a whale always does the accrual compared to someone with almost no debt or no discount.\n\n",
                "Repair": "Don't use the discounts or track the weighted average discount across all users that is subtracted from the increased total debt each time, i.e., reduce it by the discount of all users (instead of current caller only) when accruing to correctly track the debt.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/129)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    /// storage variables\n    uint256 public override deposits;\n    uint256 public override debts;\n    int256 public override claimable;\n\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\n    ///E.g. If the stability fees are 10% for a year\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\n\n    /// result\n    uint256 public liquidated;\n\n    mapping(uint256 => Detail) public override details;\n    mapping(uint256 => uint256) public lastDeposit;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n\n    modifier wait(uint256 _id) {\n        require(\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\n            \"!wait\"\n        );\n        accrueDebt(_id);\n        _;\n    }\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function initialize(address _asset) external override initializer {\n        asset = IERC20(_asset);\n        debtIndex = 1e18;\n        lastAccrued = block.timestamp;\n    }\n\n    function liveDebtIndex() public view override returns (uint256 index) {\n        return\n            engine.mochiProfile().calculateFeeIndex(\n                address(asset),\n                debtIndex,\n                lastAccrued\n            );\n    }\n\n    function status(uint256 _id) public view override returns (Status) {\n        return details[_id].status;\n    }\n\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        require(details[_id].status != Status.Invalid, \"invalid\");\n        uint256 newIndex = liveDebtIndex();\n        return (details[_id].debt * newIndex) / details[_id].debtIndex;\n    }\n\n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function increase(\n        uint256 _id,\n        uint256 _deposits,\n        uint256 _borrows,\n        address _referrer,\n        bytes memory _data\n    ) external {\n        if (_id == type(uint256).max) {\n            // mint if _id is -1\n            _id = mint(msg.sender, _referrer);\n        }\n        if (_deposits > 0) {\n            deposit(_id, _deposits);\n        }\n        if (_borrows > 0) {\n            borrow(_id, _borrows, _data);\n        }\n    }\n\n    function decrease(\n        uint256 _id,\n        uint256 _withdraws,\n        uint256 _repays,\n        bytes memory _data\n    ) external {\n        if (_repays > 0) {\n            repay(_id, _repays);\n        }\n        if (_withdraws > 0) {\n            withdraw(_id, _withdraws, _data);\n        }\n    }\n\n    function mint(address _recipient, address _referrer)\n        public\n        returns (uint256 id)\n    {\n        id = engine.nft().mint(address(asset), _recipient);\n        details[id].debtIndex = liveDebtIndex();\n        details[id].status = Status.Idle;\n        details[id].referrer = _referrer;\n    }\n\n    /// anyone can deposit collateral to given id\n    /// it will even allow depositing to liquidated vault so becareful when depositing\n    function deposit(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        // should it be able to deposit if invalid?\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        require(\n            details[_id].status == Status.Idle ||\n                details[_id].status == Status.Collaterized ||\n                details[_id].status == Status.Active,\n            \"!depositable\"\n        );\n        lastDeposit[_id] = block.timestamp;\n        deposits += _amount;\n        details[_id].collateral += _amount;\n        if (details[_id].status == Status.Idle) {\n            details[_id].status = Status.Collaterized;\n        }\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// should only be able to withdraw if status is not liquidatable\n    function withdraw(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override wait(_id) {\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        require(\n            !_liquidatable(\n                details[_id].collateral - _amount,\n                price,\n                details[_id].debt\n            ),\n            \"!healthy\"\n        );\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = (details[_id].collateral - _amount)\n            .multiply(cf)\n            .multiply(price);\n        require(details[_id].debt <= maxMinted, \">cf\");\n        deposits -= _amount;\n        details[_id].collateral -= _amount;\n        if (details[_id].collateral == 0) {\n            details[_id].status = Status.Idle;\n        }\n        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n\n    /// someone sends usdm to this address and repays the debt\n    /// will payback the leftover usdm\n    function repay(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        if (_amount > details[_id].debt) {\n            _amount = details[_id].debt;\n        }\n        require(_amount > 0, \"zero\");\n        if (debts < _amount) {\n            // safe gaurd to some underflows\n            debts = 0;\n        } else {\n            debts -= _amount;\n        }\n        details[_id].debt -= _amount;\n        if (details[_id].debt == 0) {\n            details[_id].status = Status.Collaterized;\n        }\n        engine.usdm().transferFrom(msg.sender, address(this), _amount);\n        engine.usdm().burn(_amount);\n    }\n\n    function liquidate(\n        uint256 _id,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external override updateDebt(_id) {\n        require(msg.sender == address(engine.liquidator()), \"!liquidator\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        float memory price = engine.cssr().getPrice(address(asset));\n        require(\n            _liquidatable(details[_id].collateral, price, currentDebt(_id)),\n            \"healthy\"\n        );\n\n        debts -= _usdm;\n\n        details[_id].collateral -= _collateral;\n        details[_id].debt -= _usdm;\n\n        asset.cheapTransfer(msg.sender, _collateral);\n    }\n\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\n    /// @notice should return false if _collateral * liquidationLimit < _debt\n    function _liquidatable(\n        uint256 _collateral,\n        float memory _price,\n        uint256 _debt\n    ) internal view returns (bool) {\n        float memory lf = engine.mochiProfile().liquidationFactor(\n            address(asset)\n        );\n        // when debt is lower than liquidation value, it can be liquidated\n        return _collateral.multiply(lf) < _debt.divide(_price);\n    }\n\n    function liquidatable(uint256 _id) external view returns (bool) {\n        float memory price = engine.cssr().getPrice(address(asset));\n        return _liquidatable(details[_id].collateral, price, currentDebt(_id));\n    }\n\n    function claim() external updateDebt(type(uint256).max) {\n        require(claimable > 0, \"!claimable\");\n        // reserving 25% to prevent potential risks\n        uint256 toClaim = (uint256(claimable) * 75) / 100;\n        mintFeeToPool(toClaim, address(0));\n    }\n\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\n        claimable -= int256(_amount);\n        if (address(0) != _referrer) {\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\n            engine.referralFeePool().addReward(_referrer);\n        } else {\n            engine.minter().mint(address(engine.treasury()), _amount);\n        }\n    }\n\n    // Flash Loan\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(asset), \"!supported\");\n        return asset.balanceOf(address(this));\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(asset), \"!supported\");\n        return (_amount * 1337) / 1000000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(asset), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        asset.cheapTransfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        asset.cheapTransferFrom(address(_receiver), address(this), _amount);\n        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nstruct Detail {\n    Status status;\n    uint256 collateral;\n    uint256 debt;\n    uint256 debtIndex;\n    address referrer;\n}\n\nenum Status {\n    Invalid, // not minted\n    Idle, // debt = 0, collateral = 0\n    Collaterized, // debt = 0, collateral > 0\n    Active, // debt > 0, collateral > 0\n    Liquidated\n}\n\ninterface IMochiVault {\n    function liveDebtIndex() external view returns (uint256);\n\n    function details(uint256 _nftId)\n        external\n        view\n        returns (\n            Status,\n            uint256 collateral,\n            uint256 debt,\n            uint256 debtIndexe,\n            address refferer\n        );\n\n    function status(uint256 _nftId) external view returns (Status);\n\n    function asset() external view returns (IERC20);\n\n    function deposits() external view returns (uint256);\n\n    function debts() external view returns (uint256);\n\n    function claimable() external view returns (int256);\n\n    function currentDebt(uint256 _nftId) external view returns (uint256);\n\n    function initialize(address _asset) external;\n\n    function deposit(uint256 _nftId, uint256 _amount) external;\n\n    function withdraw(\n        uint256 _nftId,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n\n    function borrow(\n        uint256 _nftId,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n\n    function repay(uint256 _nftId, uint256 _amount) external;\n\n    function liquidate(\n        uint256 _nftId,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external;\n}\n\n\n",
        "CodeNames": [
            "MochiVault.sol",
            "IMochiVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "Idle",
                    "mint"
                ],
                "Type": " Changing engine.nft contract breaks vaults",
                "Description": "\nGovernance can change the engine.nft address which is used by vaults to represent collateralized debt positions (CDP).\nWhen minting a vault using MochiVault.mint the address returned ID will be used and overwrite the state of an existing debt position and set its status to Idle.\n\nChanging the NFT address will allow overwriting existing CDPs.\n\n",
                "Repair": "Disallow setting a new NFT address. or ensure that the new NFT's IDs start at the old NFT's IDs.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/130)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport { SushiswapV2Library } from \"@mochifi/library/contracts/SushiswapV2Library.sol\";\nimport \"../interfaces/ICSSRAdapter.sol\";\nimport \"../interfaces/ICSSRRouter.sol\";\nimport \"../interfaces/IUniswapV2CSSR.sol\";\ncontract SushiswapV2LPAdapter is ICSSRAdapter {\n    using Float for float;\n\n    ICSSRRouter public immutable router;\n    IUniswapV2CSSR public immutable cssr;\n    address public immutable weth;\n    address public immutable factory;\n    //using uint256 since we don't need 224 for this\n    uint256 public constant Q112 = 2**112;\n\n    constructor(address _weth, address _factory, address _router, address _cssr) {\n        weth = _weth;\n        router = ICSSRRouter(_router);\n        cssr = IUniswapV2CSSR(_cssr);\n        factory = _factory;\n    }\n\n    function support(address _asset) external view override returns(bool) {\n        address underlying = getUnderlyingAsset(IUniswapV2Pair(_asset));\n        address calculatedAddress = SushiswapV2Library.pairFor(factory, underlying, weth);\n        return _asset == calculatedAddress;\n    }\n\n    function update(address _asset, bytes memory _proof) external override returns(float memory price) {\n        address underlying = getUnderlyingAsset(IUniswapV2Pair(_asset));\n        router.update(_asset, _proof);\n        return _getPrice(IUniswapV2Pair(_asset), underlying);\n    }\n\n    function getUnderlyingAsset(IUniswapV2Pair _pair) public view returns(address underlyingAsset) {\n        if (_pair.token0() == weth) {\n            underlyingAsset = _pair.token1();\n        } else if (_pair.token1() == weth) {\n            underlyingAsset = _pair.token0();\n        } else {\n            revert(\"!eth paired\");\n        }\n    }\n\n    function getPrice(address _asset) external view override returns(float memory price){\n        IUniswapV2Pair pair = IUniswapV2Pair(_asset);\n        address underlying = getUnderlyingAsset(pair);\n        return _getPrice(pair, underlying);\n    }\n\n    function _getPrice(IUniswapV2Pair _pair, address _underlying) internal view returns(float memory price) {\n        uint256 eAvg = cssr.getExchangeRatio(_underlying, weth);\n        (uint112 _reserve0, uint112 _reserve1,) = _pair.getReserves();\n        uint256 aPool; // current asset pool\n        uint256 ePool; // current weth pool\n        if (_pair.token0() == _underlying) {\n            aPool = uint(_reserve0);\n            ePool = uint(_reserve1);\n        } else {\n            aPool = uint(_reserve1);\n            ePool = uint(_reserve0);\n        }\n\n        uint256 eCurr = ePool * Q112 / aPool; // current price of 1 token in weth\n        uint256 ePoolCalc; // calculated weth pool\n\n        if (eCurr < eAvg) {\n            // flashloan buying weth\n            uint256 sqrtd = ePool * (\n                (ePool * 9)\n                +(aPool * 3988000 * eAvg / Q112)\n            );\n            uint256 eChange = (sqrt(sqrtd) - (ePool * 1997)) / 2000;\n            ePoolCalc = ePool + eChange;\n        } else {\n            // flashloan selling weth\n            uint256 a = aPool * eAvg;\n            uint256 b = a * 9 / Q112;\n            uint256 c = ePool * 3988000;\n            uint256 sqRoot = sqrt( (a / Q112) * (b + c));\n            uint256 d = a * 3 / Q112;\n            uint256 eChange = ePool - ((d + sqRoot) / 2000);\n            ePoolCalc = ePool - eChange;\n        }\n\n        uint256 num = ePoolCalc * 2;\n        uint256 priceInEth;\n        if (num > Q112) {\n            priceInEth = (num / _pair.totalSupply()) * Q112;\n        } else {\n            priceInEth = num * Q112 / _pair.totalSupply();\n        }\n\n        return float({numerator:priceInEth, denominator: Q112}).mul(router.getPrice(weth));\n    }\n\n    function getLiquidity(address _asset) external view override returns(uint256) {\n        address underlying = getUnderlyingAsset(IUniswapV2Pair(_asset));\n        return router.getLiquidity(underlying);\n    }\n\n    function sqrt(uint x) internal pure returns (uint y) {\n        if (x > 3) {\n            uint z = x / 2 + 1;\n            y = x;\n            while (z < y) {\n                y = z;\n                z = (x / z + z) / 2;\n            }\n        } else if (x != 0) {\n            y = 1;\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/IFeePool.sol\";\nimport \"../interfaces/IUSDM.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract FeePoolV0 is IFeePool {\n    IMochiEngine public immutable engine;\n\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    address public crvVoterRewardPool;\n\n    uint256 public treasuryRatio;\n\n    uint256 public vMochiRatio;\n\n    uint256 public mochiShare;\n\n    uint256 public treasuryShare;\n\n    constructor(address _engine, address _uniswap) {\n        engine = IMochiEngine(_engine);\n        uniswapRouter = IUniswapV2Router02(_uniswap);\n        treasuryRatio = 20e16;\n        vMochiRatio = 80e16;\n    }\n\n    function updateReserve() external override {\n        uint256 newReserve = engine.usdm().balanceOf(address(this)) -\n            mochiShare -\n            treasuryShare;\n        treasuryShare += (newReserve * treasuryRatio) / 1e18;\n        mochiShare = engine.usdm().balanceOf(address(this)) - treasuryShare;\n    }\n\n    function changecrvVoterRewardPool(address _pool) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        crvVoterRewardPool = _pool;\n    }\n\n    function changeTreasuryRatio(uint256 _ratio) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        treasuryRatio = _ratio;\n    }\n\n    function changevMochiRatio(uint256 _ratio) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        vMochiRatio = _ratio;\n    }\n\n    // this will open up arb oppertunity for Mochi\n    // so we will not reward the caller, caller can benefit from flashbot\n    // should decide which market we should use UniV2?V3? BalancerV2?\n    function distributeMochi() external {\n        // buy Mochi with mochiShare\n        _buyMochi();\n        _shareMochi();\n    }\n\n    function _buyMochi() internal {\n        IUSDM usdm = engine.usdm();\n        address[] memory path = new address[](2);\n        path[0] = address(usdm);\n        path[1] = address(engine.mochi());\n        usdm.approve(address(uniswapRouter), mochiShare);\n        uniswapRouter.swapExactTokensForTokens(\n            mochiShare,\n            1,\n            path,\n            address(this),\n            type(uint256).max\n        );\n    }\n\n    function _shareMochi() internal {\n        IMochi mochi = engine.mochi();\n        uint256 mochiBalance = mochi.balanceOf(address(this));\n        // send Mochi to vMochi Vault\n        mochi.transfer(\n            address(engine.vMochi()),\n            (mochiBalance * vMochiRatio) / 1e18\n        );\n        // send Mochi to veCRV Holders\n        mochi.transfer(\n            crvVoterRewardPool,\n            (mochiBalance * (1e18 - vMochiRatio)) / 1e18\n        );\n        // flush mochiShare\n        mochiShare = 0;\n        treasuryShare = 0;\n    }\n\n    function sendToTreasury() external {\n        engine.usdm().transfer(engine.treasury(), treasuryShare);\n        treasuryShare = 0;\n    }\n}\n\n\n",
        "CodeNames": [
            "SushiswapV2LPAdapter.sol",
            "FeePoolV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-08",
                "Location": [
                    "router.update(_asset, _proof)",
                    "underlying",
                    "UniswapV"
                ],
                "Type": "  UniswapV2/SushiwapLPAdapter  update the wrong token",
                "Description": "\nThe UniswapV2LPAdapter/SushiswapV2LPAdapter.update function retrieves the underlying from the LP token pair (_asset) but then calls router.update(_asset, _proof) which is the LP token itself again.\nThis will end up with the router calling this function again recursively.\n\nThis function fails as there's an infinite recursion and eventually runs out of gas.\n\n",
                "Repair": "The idea was most likely to update the underlying price which is used in _getPrice as uint256 eAvg = cssr.getExchangeRatio(_underlying, weth);.\n\nCall router.update(underlying, _proof) instead. Note that the _proof does not necessarily update the underlying < WETH pair, it could be any underlying < keyAsset pair.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/134)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@mochifi/cssr/contracts/interfaces/ICSSRRouter.sol\";\nimport \"@mochifi/cssr/contracts/interfaces/IUniswapV2CSSR.sol\";\nimport \"@mochifi/cssr/contracts/mocks/MockEngine.sol\";\nimport \"@mochifi/cssr/contracts/MochiCSSRv0.sol\";\nimport \"@mochifi/cssr/contracts/cssr/UniswapV2CSSR.sol\";\nimport \"@mochifi/cssr/contracts/cssr/SushiswapV2CSSR.sol\";\nimport \"@mochifi/cssr/contracts/adapter/ChainlinkAdapter.sol\";\nimport \"@mochifi/cssr/contracts/adapter/UniswapV2TokenAdapter.sol\";\nimport \"@mochifi/cssr/contracts/adapter/UniswapV2LPAdapter.sol\";\nimport \"@mochifi/cssr/contracts/adapter/SushiswapV2LPAdapter.sol\";\n\ncontract MockCssrRouter is ICSSRRouter {\n    mapping(address => uint256) public numerator;\n\n    function setPrice(address _asset, uint256 _newPrice) external {\n        numerator[_asset] = _newPrice;\n    }\n\n    function update(address _asset, bytes memory _data)\n        external\n        override\n        returns (float memory)\n    {\n        return getPrice(_asset);\n    }\n\n    function getPrice(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        // always 1 dollar\n        if (numerator[_asset] == 0) {\n            return float({numerator: 1e18, denominator: 1e18});\n        } else {\n            return float({numerator: numerator[_asset], denominator: 1e18});\n        }\n    }\n\n    function getLiquidity(address _asset)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return 1_000_000_000_000e18;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract MinterV0 is IMinter {\n    IMochiEngine public immutable engine;\n\n    mapping(address => bool) public isMinter;\n\n    address[] public factories;\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    modifier onlyPermission() {\n        require(hasPermission(msg.sender), \"!permission\");\n        _;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == engine.governance(), \"!gov\");\n        _;\n    }\n\n    function addMinter(address _minter) external onlyGov {\n        isMinter[_minter] = true;\n    }\n\n    function removeMinter(address _minter) external onlyGov {\n        isMinter[_minter] = false;\n    }\n\n    function mint(address _to, uint256 _amount)\n        external\n        override\n        onlyPermission\n    {\n        engine.usdm().mint(_to, _amount);\n    }\n\n    function hasPermission(address _user) public view override returns (bool) {\n        return isMinter[_user] || isVault(_user);\n    }\n\n    function isVault(address _vault) public view override returns (bool) {\n        return\n            address(\n                engine.vaultFactory().getVault(\n                    address(IMochiVault(_vault).asset())\n                )\n            ) == _vault;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/IFeePool.sol\";\nimport \"../interfaces/IUSDM.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract FeePoolV0 is IFeePool {\n    IMochiEngine public immutable engine;\n\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    address public crvVoterRewardPool;\n\n    uint256 public treasuryRatio;\n\n    uint256 public vMochiRatio;\n\n    uint256 public mochiShare;\n\n    uint256 public treasuryShare;\n\n    constructor(address _engine, address _uniswap) {\n        engine = IMochiEngine(_engine);\n        uniswapRouter = IUniswapV2Router02(_uniswap);\n        treasuryRatio = 20e16;\n        vMochiRatio = 80e16;\n    }\n\n    function updateReserve() external override {\n        uint256 newReserve = engine.usdm().balanceOf(address(this)) -\n            mochiShare -\n            treasuryShare;\n        treasuryShare += (newReserve * treasuryRatio) / 1e18;\n        mochiShare = engine.usdm().balanceOf(address(this)) - treasuryShare;\n    }\n\n    function changecrvVoterRewardPool(address _pool) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        crvVoterRewardPool = _pool;\n    }\n\n    function changeTreasuryRatio(uint256 _ratio) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        treasuryRatio = _ratio;\n    }\n\n    function changevMochiRatio(uint256 _ratio) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        vMochiRatio = _ratio;\n    }\n\n    // this will open up arb oppertunity for Mochi\n    // so we will not reward the caller, caller can benefit from flashbot\n    // should decide which market we should use UniV2?V3? BalancerV2?\n    function distributeMochi() external {\n        // buy Mochi with mochiShare\n        _buyMochi();\n        _shareMochi();\n    }\n\n    function _buyMochi() internal {\n        IUSDM usdm = engine.usdm();\n        address[] memory path = new address[](2);\n        path[0] = address(usdm);\n        path[1] = address(engine.mochi());\n        usdm.approve(address(uniswapRouter), mochiShare);\n        uniswapRouter.swapExactTokensForTokens(\n            mochiShare,\n            1,\n            path,\n            address(this),\n            type(uint256).max\n        );\n    }\n\n    function _shareMochi() internal {\n        IMochi mochi = engine.mochi();\n        uint256 mochiBalance = mochi.balanceOf(address(this));\n        // send Mochi to vMochi Vault\n        mochi.transfer(\n            address(engine.vMochi()),\n            (mochiBalance * vMochiRatio) / 1e18\n        );\n        // send Mochi to veCRV Holders\n        mochi.transfer(\n            crvVoterRewardPool,\n            (mochiBalance * (1e18 - vMochiRatio)) / 1e18\n        );\n        // flush mochiShare\n        mochiShare = 0;\n        treasuryShare = 0;\n    }\n\n    function sendToTreasury() external {\n        engine.usdm().transfer(engine.treasury(), treasuryShare);\n        treasuryShare = 0;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@mochifi/library/contracts/UniswapV2Library.sol\";\nimport \"@mochifi/library/contracts/SushiswapV2Library.sol\";\nimport \"../interfaces/ICSSRRouter.sol\";\nimport \"../interfaces/ICSSRAdapter.sol\";\nimport \"../interfaces/IUniswapV2CSSR.sol\";\nimport \"../interfaces/IGovernanceOwned.sol\";\n\ncontract UniswapV2TokenAdapter is ICSSRAdapter {\n    IGovernanceOwned public immutable owned;\n    ICSSRRouter public immutable cssrRouter;\n    IUniswapV2CSSR public immutable uniswapCSSR;\n    IUniswapV2CSSR public immutable sushiCSSR;\n\n    address[] public keyCurrency;\n    uint256 public minimumLiquidity;\n    mapping(address => bool) public isKeyCurrency;\n\n    modifier onlyGov() {\n        require(msg.sender == owned.governance(), \"!gov\");\n        _;\n    }\n\n    constructor(\n        address _owned,\n        address _router,\n        address _uniCSSR,\n        address _sushiCSSR\n    ) {\n        owned = IGovernanceOwned(_owned);\n        cssrRouter = ICSSRRouter(_router);\n        uniswapCSSR = IUniswapV2CSSR(_uniCSSR);\n        sushiCSSR = IUniswapV2CSSR(_sushiCSSR);\n    }\n\n    function addKeyCurrency(address _currency) external onlyGov {\n        keyCurrency.push(_currency);\n        isKeyCurrency[_currency] = true;\n    }\n\n    function removeKeyCurrency(uint256 _idx, address _currency)\n        external\n        onlyGov\n    {\n        require(keyCurrency[_idx] == _currency, \"!match\");\n        keyCurrency[_idx] = keyCurrency[keyCurrency.length - 1];\n        keyCurrency.pop();\n        isKeyCurrency[_currency] = false;\n    }\n\n    function setMinimumLiquidity(uint256 _liquidity)\n        external\n        onlyGov\n    {\n        minimumLiquidity = _liquidity;\n    }\n\n    function support(address _asset) external view override returns (bool) {\n        // check if liquidity passes the minimum\n        for (uint256 i = 0; i < keyCurrency.length; i++) {\n            if (aboveLiquidity(_asset, keyCurrency[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function update(address _asset, bytes memory _data)\n        external\n        override\n        returns (float memory)\n    {\n        (uint256 cssrType, bytes memory data) = abi.decode(_data, (uint256, bytes));\n        if(cssrType == 0){\n            (\n                address p,\n                bytes memory bd,\n                bytes memory ap,\n                bytes memory rp,\n                bytes memory pp0,\n                bytes memory pp1\n            ) = abi.decode(data, (address, bytes, bytes, bytes, bytes, bytes));\n            require(isKeyCurrency[p], \"!keyCurrency\");\n            (, uint256 bn, ) = uniswapCSSR.saveState(bd);\n            address pair = UniswapV2Library.pairFor(\n                uniswapCSSR.uniswapFactory(),\n                _asset,\n                p\n            );\n            uniswapCSSR.saveReserve(bn, pair, ap, rp, pp0, pp1);\n        } else if(cssrType == 1){\n            (\n                address p,\n                bytes memory bd,\n                bytes memory ap,\n                bytes memory rp,\n                bytes memory pp0,\n                bytes memory pp1\n            ) = abi.decode(data, (address, bytes, bytes, bytes, bytes, bytes));\n            require(isKeyCurrency[p], \"!keyCurrency\");\n            (, uint256 bn, ) = sushiCSSR.saveState(bd);\n            address pair = SushiswapV2Library.pairFor(\n                sushiCSSR.uniswapFactory(),\n                _asset,\n                p\n            );\n            sushiCSSR.saveReserve(bn, pair, ap, rp, pp0, pp1);\n        } else {\n            revert(\"!supported type\");\n        }\n        return getPrice(_asset);\n    }\n\n    function getPriceRaw(address _asset)\n        public\n        view\n        returns (uint256 sumPrice, uint256 sumLiquidity)\n    {\n        for (uint256 i = 0; i < keyCurrency.length; i++) {\n            address key = keyCurrency[i];\n            float memory currencyPrice = cssrRouter.getPrice(key);\n            if (_asset == key) {\n                continue;\n            }\n            try uniswapCSSR.getLiquidity(_asset, key) returns (uint256 liq) {\n                uint256 liquidityValue = convertToValue(liq, currencyPrice);\n                if (liquidityValue >= minimumLiquidity) {\n                    sumLiquidity += liquidityValue;\n                    sumPrice +=\n                        convertToValue(\n                            uniswapCSSR.getExchangeRatio(_asset, key),\n                            currencyPrice\n                        ) *\n                        liquidityValue;\n                }\n            } catch {\n            }\n            try sushiCSSR.getLiquidity(_asset, key) returns (uint256 liq) {\n                uint256 liq = sushiCSSR.getLiquidity(_asset,key);\n                uint256 liquidityValue = convertToValue(liq, currencyPrice);\n                if (liquidityValue >= minimumLiquidity) {\n                    sumLiquidity += liquidityValue;\n                    sumPrice +=\n                        convertToValue(\n                            sushiCSSR.getExchangeRatio(_asset, key),\n                            currencyPrice\n                        ) *\n                        liquidityValue;\n                }\n            } catch {\n            }\n        }\n    }\n\n    function getPrice(address _asset)\n        public\n        view\n        override\n        returns (float memory price)\n    {\n        (uint256 sumPrice, uint256 sumLiquidity) = getPriceRaw(_asset);\n        require(sumLiquidity > 0, \"!updated\");\n        return float({numerator: sumPrice / 2**112, denominator: sumLiquidity});\n    }\n\n    function getLiquidity(address _asset)\n        external\n        view\n        override\n        returns (uint256 sum)\n    {\n        for (uint256 i = 0; i < keyCurrency.length; i++) {\n            address key = keyCurrency[i];\n            float memory currencyPrice = cssrRouter.getPrice(key);\n            if (_asset == key) {\n                continue;\n            }\n            try uniswapCSSR.getLiquidity(_asset, key) returns (uint256 liq) {\n                uint256 liquidityValue = convertToValue(liq, currencyPrice);\n                if (liquidityValue >= minimumLiquidity) {\n                    sum += liquidityValue;\n                }\n            } catch {\n            }\n            try sushiCSSR.getLiquidity(_asset, key) returns (uint256 liq) {\n                uint256 liquidityValue = convertToValue(liq, currencyPrice);\n                if (liquidityValue >= minimumLiquidity) {\n                    sum += liquidityValue;\n                }\n            } catch {\n            }\n        }\n    }\n\n    function aboveLiquidity(address _asset, address _pairedWith)\n        public\n        view\n        returns (bool)\n    {\n        try uniswapCSSR.getLiquidity(_asset, _pairedWith) returns (\n            uint256 liq\n        ) {\n            float memory price = cssrRouter.getPrice(_pairedWith);\n            return convertToValue(liq, price) >= minimumLiquidity;\n        } catch {\n            try sushiCSSR.getLiquidity(_asset, _pairedWith) returns (\n                uint256 liq\n            ) {\n                float memory price = cssrRouter.getPrice(_pairedWith);\n                return convertToValue(liq, price) >= minimumLiquidity;\n            } catch {\n                return false;\n            }\n        }\n    }\n\n    function convertToValue(uint256 _amount, float memory _price)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (_amount * _price.numerator) / _price.denominator;\n    }\n}\n\n\n",
        "CodeNames": [
            "MockCssrRouter.sol",
            "UsdmMinter.sol",
            "FeePoolV0.sol",
            "UniswapV2TokenAdapter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-09",
                "Location": [
                    "//solidity\ntry uniswapCSSR.getLiquidity(_asset, _pairedWith) returns (\n            uint256 liq\n        ) {\n    float memory price = cssrRouter.getPrice(_pairedWith);\n    // @audit this returns early. if it's false it should check sushiswap first\n    return convertToValue(liq, price) = minimumLiquidity;\n} catch {\n    try sushiCSSR.getLiquidity(_asset, _pairedWith) returns (\n        uint256 liq\n    ) {\n        float memory price = cssrRouter.getPrice(_pairedWith);\n        return convertToValue(liq, price) = minimumLiquidity;\n    } catch {\n        return false;\n    }\n}\n"
                ],
                "Type": "  UniswapV2TokenAdapter  does not support Sushiswap-only assets",
                "Description": "\nThe UniswapV2TokenAdapter.supports function calls its aboveLiquidity function which returns the UniswapV2 liquidity if the pair exists.\nIf this is below minimumLiquidity, the supports function will return false.\n\nHowever, it could be that the Sushiswap pair has lots of liquidity and could be used.\n\nsolidity\ntry uniswapCSSR.getLiquidity(_asset, _pairedWith) returns (\n            uint256 liq\n        ) {\n    float memory price = cssrRouter.getPrice(_pairedWith);\n    // @audit this returns early. if it's false it should check sushiswap first\n    return convertToValue(liq, price) = minimumLiquidity;\n} catch {\n    try sushiCSSR.getLiquidity(_asset, _pairedWith) returns (\n        uint256 liq\n    ) {\n        float memory price = cssrRouter.getPrice(_pairedWith);\n        return convertToValue(liq, price) = minimumLiquidity;\n    } catch {\n        return false;\n    }\n}\n\n\nSuppose the UniswapV2TokenAdapter wants to be used as an adapter for a Sushiswap pool.\nAn attacker creates a UniswapV2 pool for the same pair and does not provide liquidity.\nThe Router.setPriceSource calls UniswapV2TokenAdapter.supports and returns false as the Uniswap liquidity is too low, without checking the Sushiswap liquidity.\n\n",
                "Repair": "In aboveLiquidity, if the UniswapV2 liquidity is *less* than the minimum liquidity, instead of returning, compare the Sushiswap liquidity against this threshold.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/135)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@mochifi/library/contracts/Float.sol\";\n\nenum AssetClass {\n    Invalid,\n    Stable,\n    Alpha,\n    Gamma,\n    Delta,\n    Zeta,\n    Sigma,\n    Revoked\n}\n\ninterface IMochiProfile {\n    function assetClass(address _asset) external view returns (AssetClass);\n\n    function liquidityRequirement() external view returns (uint256);\n\n    function minimumDebt() external view returns (uint256);\n\n    function changeAssetClass(\n        address[] calldata _asset,\n        AssetClass[] calldata _class\n    ) external;\n\n    function changeLiquidityRequirement(uint256 _requirement) external;\n\n    function changeMinimumDebt(uint256 _debt) external;\n\n    function calculateFeeIndex(\n        address _asset,\n        uint256 _currentIndex,\n        uint256 _lastAccrued\n    ) external view returns (uint256);\n\n    function creditCap(address _asset) external view returns (uint256);\n\n    function delay() external view returns (uint256);\n\n    function liquidationFactor(address _asset)\n        external\n        view\n        returns (float memory);\n\n    function maxCollateralFactor(address _asset)\n        external\n        view\n        returns (float memory);\n\n    function stabilityFee(address _asset) external view returns (float memory);\n\n    function liquidationFee(address _asset)\n        external\n        view\n        returns (float memory);\n\n    function keeperFee(address _asset) external view returns (float memory);\n\n    function utilizationRatio(address _asset)\n        external\n        view\n        returns (float memory);\n}\n\n\n// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    /// storage variables\n    uint256 public override deposits;\n    uint256 public override debts;\n    int256 public override claimable;\n\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\n    ///E.g. If the stability fees are 10% for a year\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\n\n    /// result\n    uint256 public liquidated;\n\n    mapping(uint256 => Detail) public override details;\n    mapping(uint256 => uint256) public lastDeposit;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n\n    modifier wait(uint256 _id) {\n        require(\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\n            \"!wait\"\n        );\n        accrueDebt(_id);\n        _;\n    }\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function initialize(address _asset) external override initializer {\n        asset = IERC20(_asset);\n        debtIndex = 1e18;\n        lastAccrued = block.timestamp;\n    }\n\n    function liveDebtIndex() public view override returns (uint256 index) {\n        return\n            engine.mochiProfile().calculateFeeIndex(\n                address(asset),\n                debtIndex,\n                lastAccrued\n            );\n    }\n\n    function status(uint256 _id) public view override returns (Status) {\n        return details[_id].status;\n    }\n\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        require(details[_id].status != Status.Invalid, \"invalid\");\n        uint256 newIndex = liveDebtIndex();\n        return (details[_id].debt * newIndex) / details[_id].debtIndex;\n    }\n\n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function increase(\n        uint256 _id,\n        uint256 _deposits,\n        uint256 _borrows,\n        address _referrer,\n        bytes memory _data\n    ) external {\n        if (_id == type(uint256).max) {\n            // mint if _id is -1\n            _id = mint(msg.sender, _referrer);\n        }\n        if (_deposits > 0) {\n            deposit(_id, _deposits);\n        }\n        if (_borrows > 0) {\n            borrow(_id, _borrows, _data);\n        }\n    }\n\n    function decrease(\n        uint256 _id,\n        uint256 _withdraws,\n        uint256 _repays,\n        bytes memory _data\n    ) external {\n        if (_repays > 0) {\n            repay(_id, _repays);\n        }\n        if (_withdraws > 0) {\n            withdraw(_id, _withdraws, _data);\n        }\n    }\n\n    function mint(address _recipient, address _referrer)\n        public\n        returns (uint256 id)\n    {\n        id = engine.nft().mint(address(asset), _recipient);\n        details[id].debtIndex = liveDebtIndex();\n        details[id].status = Status.Idle;\n        details[id].referrer = _referrer;\n    }\n\n    /// anyone can deposit collateral to given id\n    /// it will even allow depositing to liquidated vault so becareful when depositing\n    function deposit(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        // should it be able to deposit if invalid?\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        require(\n            details[_id].status == Status.Idle ||\n                details[_id].status == Status.Collaterized ||\n                details[_id].status == Status.Active,\n            \"!depositable\"\n        );\n        lastDeposit[_id] = block.timestamp;\n        deposits += _amount;\n        details[_id].collateral += _amount;\n        if (details[_id].status == Status.Idle) {\n            details[_id].status = Status.Collaterized;\n        }\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// should only be able to withdraw if status is not liquidatable\n    function withdraw(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override wait(_id) {\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        require(\n            !_liquidatable(\n                details[_id].collateral - _amount,\n                price,\n                details[_id].debt\n            ),\n            \"!healthy\"\n        );\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = (details[_id].collateral - _amount)\n            .multiply(cf)\n            .multiply(price);\n        require(details[_id].debt <= maxMinted, \">cf\");\n        deposits -= _amount;\n        details[_id].collateral -= _amount;\n        if (details[_id].collateral == 0) {\n            details[_id].status = Status.Idle;\n        }\n        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n\n    /// someone sends usdm to this address and repays the debt\n    /// will payback the leftover usdm\n    function repay(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        if (_amount > details[_id].debt) {\n            _amount = details[_id].debt;\n        }\n        require(_amount > 0, \"zero\");\n        if (debts < _amount) {\n            // safe gaurd to some underflows\n            debts = 0;\n        } else {\n            debts -= _amount;\n        }\n        details[_id].debt -= _amount;\n        if (details[_id].debt == 0) {\n            details[_id].status = Status.Collaterized;\n        }\n        engine.usdm().transferFrom(msg.sender, address(this), _amount);\n        engine.usdm().burn(_amount);\n    }\n\n    function liquidate(\n        uint256 _id,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external override updateDebt(_id) {\n        require(msg.sender == address(engine.liquidator()), \"!liquidator\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        float memory price = engine.cssr().getPrice(address(asset));\n        require(\n            _liquidatable(details[_id].collateral, price, currentDebt(_id)),\n            \"healthy\"\n        );\n\n        debts -= _usdm;\n\n        details[_id].collateral -= _collateral;\n        details[_id].debt -= _usdm;\n\n        asset.cheapTransfer(msg.sender, _collateral);\n    }\n\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\n    /// @notice should return false if _collateral * liquidationLimit < _debt\n    function _liquidatable(\n        uint256 _collateral,\n        float memory _price,\n        uint256 _debt\n    ) internal view returns (bool) {\n        float memory lf = engine.mochiProfile().liquidationFactor(\n            address(asset)\n        );\n        // when debt is lower than liquidation value, it can be liquidated\n        return _collateral.multiply(lf) < _debt.divide(_price);\n    }\n\n    function liquidatable(uint256 _id) external view returns (bool) {\n        float memory price = engine.cssr().getPrice(address(asset));\n        return _liquidatable(details[_id].collateral, price, currentDebt(_id));\n    }\n\n    function claim() external updateDebt(type(uint256).max) {\n        require(claimable > 0, \"!claimable\");\n        // reserving 25% to prevent potential risks\n        uint256 toClaim = (uint256(claimable) * 75) / 100;\n        mintFeeToPool(toClaim, address(0));\n    }\n\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\n        claimable -= int256(_amount);\n        if (address(0) != _referrer) {\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\n            engine.referralFeePool().addReward(_referrer);\n        } else {\n            engine.minter().mint(address(engine.treasury()), _amount);\n        }\n    }\n\n    // Flash Loan\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(asset), \"!supported\");\n        return asset.balanceOf(address(this));\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(asset), \"!supported\");\n        return (_amount * 1337) / 1000000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(asset), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        asset.cheapTransfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        asset.cheapTransferFrom(address(_receiver), address(this), _amount);\n        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IFeePool.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\ncontract NoMochiFeePool is IFeePool {\n    IMochiEngine public immutable engine;\n    address public withdrawer;\n\n    constructor(address _withdrawer, address _engine) {\n        engine = IMochiEngine(_engine);\n        withdrawer = _withdrawer;\n    }\n\n    function updateReserve() external override {\n        // no-op\n    }\n\n    function withdraw() external {\n        engine.usdm().transfer(\n            withdrawer,\n            engine.usdm().balanceOf(address(this))\n        );\n    }\n\n    function changeWithdrawer(address _withdrawer) external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        withdrawer = _withdrawer;\n    }\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IMochi.sol\";\nimport \"@mochifi/vmochi/contracts/interfaces/IVMochi.sol\";\n\ncontract VestedRewardPool {\n    IMochi public immutable mochi;\n    IVMochi public immutable vMochi;\n\n    uint256 public mochiUnderManagement;\n\n    mapping(address => Vesting) public vesting;\n\n    struct Vesting {\n        uint256 vested;\n        uint256 ends;\n        uint256 claimable;\n    }\n\n    modifier checkClaimable(address recipient) {\n        if (vesting[recipient].ends < block.timestamp) {\n            vesting[recipient].claimable += vesting[recipient].vested;\n            vesting[recipient].vested = 0;\n            vesting[recipient].ends = 0;\n        }\n        _;\n    }\n\n    constructor(address _mochi, address _vmochi) {\n        mochi = IMochi(_mochi);\n        vMochi = IVMochi(_vmochi);\n    }\n\n    function vest(address _recipient) external checkClaimable(_recipient) {\n        uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;\n        uint256 weightedEnd = (vesting[_recipient].vested *\n            vesting[_recipient].ends +\n            amount *\n            (block.timestamp + 90 days)) /\n            (vesting[_recipient].vested + amount);\n        vesting[_recipient].vested += amount;\n        vesting[_recipient].ends = weightedEnd;\n        mochiUnderManagement += amount;\n    }\n\n    function claim() external checkClaimable(msg.sender) {\n        mochi.transfer(msg.sender, vesting[msg.sender].claimable);\n        mochiUnderManagement -= vesting[msg.sender].claimable;\n        vesting[msg.sender].claimable = 0;\n    }\n\n    function lock(uint256 _amount) external checkClaimable(msg.sender) {\n        mochi.approve(address(vMochi), _amount);\n        (, uint256 end) = vMochi.locked(msg.sender);\n        if (end >= block.timestamp + 90 days) {\n            vMochi.depositFor(msg.sender, _amount);\n        } else {\n            revert(\"lock should be longer than 90 days\");\n        }\n        vesting[msg.sender].vested -= _amount;\n        mochiUnderManagement -= _amount;\n    }\n\n    function forceClaim(uint256 _amount) external checkClaimable(msg.sender) {\n        mochi.transfer(msg.sender, _amount / 2);\n        mochi.transfer(address(vMochi), _amount / 2);\n        vesting[msg.sender].vested -= _amount;\n        mochiUnderManagement -= _amount;\n    }\n}\n\n\n",
        "CodeNames": [
            "IMochiProfile.sol",
            "MochiVault.sol",
            "NoMochiFeePool.sol",
            "VestedRewardPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-10",
                "Location": [
                    "delay()",
                    "deposit()",
                    "wait()",
                    "withdraw()"
                ],
                "Type": " griefing attack to block withdraws",
                "Description": "\nEvery time you deposit some assets in the vault (via deposit() of MochiVault.sol) then \"lastDeposit[_id]\" is set to block.timestamp.\nThe modifier wait() checks this value and makes sure you cannot withdraw for \"delay()\" blocks.\nThe default value for delay() is 3 minutes.\n\nKnowing this delay you can do a griefing attack:\nOn chains with low gas fees: every 3 minutes deposit a tiny amount for a specific NFT-id (which has a large amount of assets).\nOn chains with high gas fees: monitor the mempool for a withdraw() transaction and frontrun it with a deposit()\n\nThis way the owner of the NFT-id can never withdraw the funds.\n\nMochiVault.sol#L47 L54(https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L47-L54)\nvault/MochiVault.sol L171(https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L171)\nprofile/MochiProfileV0.sol L33(https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L33)\n\n",
                "Repair": "Create a mechanism where you only block the withdraw of recently deposited funds\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/21#issuecomment-952886314):\n  Will update deposit function to allow only NFT owner to deposit\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    /// storage variables\n    uint256 public override deposits;\n    uint256 public override debts;\n    int256 public override claimable;\n\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\n    ///E.g. If the stability fees are 10% for a year\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\n\n    /// result\n    uint256 public liquidated;\n\n    mapping(uint256 => Detail) public override details;\n    mapping(uint256 => uint256) public lastDeposit;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n\n    modifier wait(uint256 _id) {\n        require(\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\n            \"!wait\"\n        );\n        accrueDebt(_id);\n        _;\n    }\n\n    constructor(address _engine) {\n        engine = IMochiEngine(_engine);\n    }\n\n    function initialize(address _asset) external override initializer {\n        asset = IERC20(_asset);\n        debtIndex = 1e18;\n        lastAccrued = block.timestamp;\n    }\n\n    function liveDebtIndex() public view override returns (uint256 index) {\n        return\n            engine.mochiProfile().calculateFeeIndex(\n                address(asset),\n                debtIndex,\n                lastAccrued\n            );\n    }\n\n    function status(uint256 _id) public view override returns (Status) {\n        return details[_id].status;\n    }\n\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        require(details[_id].status != Status.Invalid, \"invalid\");\n        uint256 newIndex = liveDebtIndex();\n        return (details[_id].debt * newIndex) / details[_id].debtIndex;\n    }\n\n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function increase(\n        uint256 _id,\n        uint256 _deposits,\n        uint256 _borrows,\n        address _referrer,\n        bytes memory _data\n    ) external {\n        if (_id == type(uint256).max) {\n            // mint if _id is -1\n            _id = mint(msg.sender, _referrer);\n        }\n        if (_deposits > 0) {\n            deposit(_id, _deposits);\n        }\n        if (_borrows > 0) {\n            borrow(_id, _borrows, _data);\n        }\n    }\n\n    function decrease(\n        uint256 _id,\n        uint256 _withdraws,\n        uint256 _repays,\n        bytes memory _data\n    ) external {\n        if (_repays > 0) {\n            repay(_id, _repays);\n        }\n        if (_withdraws > 0) {\n            withdraw(_id, _withdraws, _data);\n        }\n    }\n\n    function mint(address _recipient, address _referrer)\n        public\n        returns (uint256 id)\n    {\n        id = engine.nft().mint(address(asset), _recipient);\n        details[id].debtIndex = liveDebtIndex();\n        details[id].status = Status.Idle;\n        details[id].referrer = _referrer;\n    }\n\n    /// anyone can deposit collateral to given id\n    /// it will even allow depositing to liquidated vault so becareful when depositing\n    function deposit(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        // should it be able to deposit if invalid?\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        require(\n            details[_id].status == Status.Idle ||\n                details[_id].status == Status.Collaterized ||\n                details[_id].status == Status.Active,\n            \"!depositable\"\n        );\n        lastDeposit[_id] = block.timestamp;\n        deposits += _amount;\n        details[_id].collateral += _amount;\n        if (details[_id].status == Status.Idle) {\n            details[_id].status = Status.Collaterized;\n        }\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// should only be able to withdraw if status is not liquidatable\n    function withdraw(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override wait(_id) {\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        require(\n            !_liquidatable(\n                details[_id].collateral - _amount,\n                price,\n                details[_id].debt\n            ),\n            \"!healthy\"\n        );\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = (details[_id].collateral - _amount)\n            .multiply(cf)\n            .multiply(price);\n        require(details[_id].debt <= maxMinted, \">cf\");\n        deposits -= _amount;\n        details[_id].collateral -= _amount;\n        if (details[_id].collateral == 0) {\n            details[_id].status = Status.Idle;\n        }\n        asset.cheapTransfer(engine.nft().ownerOf(_id), _amount);\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n\n    /// someone sends usdm to this address and repays the debt\n    /// will payback the leftover usdm\n    function repay(uint256 _id, uint256 _amount)\n        public\n        override\n        updateDebt(_id)\n    {\n        if (_amount > details[_id].debt) {\n            _amount = details[_id].debt;\n        }\n        require(_amount > 0, \"zero\");\n        if (debts < _amount) {\n            // safe gaurd to some underflows\n            debts = 0;\n        } else {\n            debts -= _amount;\n        }\n        details[_id].debt -= _amount;\n        if (details[_id].debt == 0) {\n            details[_id].status = Status.Collaterized;\n        }\n        engine.usdm().transferFrom(msg.sender, address(this), _amount);\n        engine.usdm().burn(_amount);\n    }\n\n    function liquidate(\n        uint256 _id,\n        uint256 _collateral,\n        uint256 _usdm\n    ) external override updateDebt(_id) {\n        require(msg.sender == address(engine.liquidator()), \"!liquidator\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        float memory price = engine.cssr().getPrice(address(asset));\n        require(\n            _liquidatable(details[_id].collateral, price, currentDebt(_id)),\n            \"healthy\"\n        );\n\n        debts -= _usdm;\n\n        details[_id].collateral -= _collateral;\n        details[_id].debt -= _usdm;\n\n        asset.cheapTransfer(msg.sender, _collateral);\n    }\n\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\n    /// @notice should return false if _collateral * liquidationLimit < _debt\n    function _liquidatable(\n        uint256 _collateral,\n        float memory _price,\n        uint256 _debt\n    ) internal view returns (bool) {\n        float memory lf = engine.mochiProfile().liquidationFactor(\n            address(asset)\n        );\n        // when debt is lower than liquidation value, it can be liquidated\n        return _collateral.multiply(lf) < _debt.divide(_price);\n    }\n\n    function liquidatable(uint256 _id) external view returns (bool) {\n        float memory price = engine.cssr().getPrice(address(asset));\n        return _liquidatable(details[_id].collateral, price, currentDebt(_id));\n    }\n\n    function claim() external updateDebt(type(uint256).max) {\n        require(claimable > 0, \"!claimable\");\n        // reserving 25% to prevent potential risks\n        uint256 toClaim = (uint256(claimable) * 75) / 100;\n        mintFeeToPool(toClaim, address(0));\n    }\n\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\n        claimable -= int256(_amount);\n        if (address(0) != _referrer) {\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\n            engine.referralFeePool().addReward(_referrer);\n        } else {\n            engine.minter().mint(address(engine.treasury()), _amount);\n        }\n    }\n\n    // Flash Loan\n    function maxFlashLoan(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(_token == address(asset), \"!supported\");\n        return asset.balanceOf(address(this));\n    }\n\n    function flashFee(address _token, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        //should return 0.1337% * _amount;\n        require(_token == address(asset), \"!supported\");\n        return (_amount * 1337) / 1000000;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower _receiver,\n        address _token,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override returns (bool) {\n        require(_token == address(asset), \"!supported\");\n        uint256 fee = flashFee(_token, _amount);\n        asset.cheapTransfer(address(_receiver), _amount);\n        require(\n            _receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) ==\n                CALLBACK_SUCCESS,\n            \"!callback\"\n        );\n        asset.cheapTransferFrom(address(_receiver), address(this), _amount);\n        asset.cheapTransferFrom(address(_receiver), engine.treasury(), fee);\n        return true;\n    }\n}\n\n\n",
        "CodeNames": [
            "MochiVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-11",
                "Location": [],
                "Type": " borrow function will borrow max cf when trying to borrow > cf",
                "Description": "\nBorrow function in MochiVault will borrow to max cf when trying to borrow  cf instead of revert with \"cf\" as specified in the supplied test. The difference in behavior may cause user to borrow at dangerous collateral level, and receive less than the amount requested.\n\n* MochiVault sol(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol)\n\n",
                "Repair": "Revert if details[_id].debt + _amount  maxMinted with \"cf\"\n\n\nryuheimat (Mochi) conirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/45)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"./Create2BeaconMaker.sol\";\nlibrary BeaconProxyDeployer {\n    function deploy(address beacon, bytes memory initializationCalldata)\n        internal\n        returns (address result)\n    {\n        bytes memory createCode =\n            abi.encodePacked(\n                type(Create2BeaconMaker).creationCode,\n                abi.encode(address(beacon), initializationCalldata)\n            );\n        bytes32 salt = bytes32(0);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, createCode) // load initialization code.\n            let encoded_size := mload(createCode) // load the init code's length.\n            result := create2(\n                // call `CREATE2` w/ 4 arguments.\n                0, // forward any supplied endowment.\n                encoded_data, // pass in initialization code.\n                encoded_size, // pass in init code's length.\n                salt // pass in the salt value.\n            )\n\n            // pass along failure message from failed contract deployment and revert.\n            if iszero(result) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    function calculateAddress(\n        address deployer,\n        address beacon,\n        bytes memory initializationCalldata\n    ) internal view returns (address addr) {\n        bytes memory createCode =\n            abi.encodePacked(\n                type(Create2BeaconMaker).creationCode,\n                abi.encode(address(beacon), initializationCalldata)\n            );\n\n        bytes32 salt = bytes32(0);\n        // get the keccak256 hash of the init code for address derivation.\n        bytes32 initCodeHash = keccak256(createCode);\n        addr = address( // derive the target deployment address.\n            uint160( // downcast to match the address type.\n                uint256( // cast to uint to truncate upper digits.\n                    keccak256( // compute CREATE2 hash using 4 inputs.\n                        abi.encodePacked( // pack all inputs to the hash together.\n                            bytes1(0xff), // pass in the control character.\n                            deployer, // pass in the address of this contract.\n                            salt, // pass in the salt from above.\n                            initCodeHash // pass in hash of contract creation code.\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n\n\n",
        "CodeNames": [
            "BeaconProxyDeployer.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-13",
                "Location": [
                    "create2",
                    "deploy()"
                ],
                "Type": " Improper Validation Of  create2  Return Value",
                "Description": "\nThe BeaconProxyDeployer.deploy() function is used to deploy lightweight proxy contracts that act as each asset's vault. The function does not revert properly if there is a failed contract deployment or revert from the create2 opcode as it does not properly check the returned address for bytecode. The create2 opcode returns the expected address which will never be the zero address (as is what is currently checked).\n\nBeaconProxyDeployer.sol L31(https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-library/contracts/BeaconProxyDeployer.sol#L31)\n\nManual code review\nDiscussions with the Mochi team\nDiscussions with library dev\n\n",
                "Repair": "The recommended mitigation was to update iszero(result) to iszero(extcodesize(result)) in the line mentioned above. This change has already been made in the corresponding library which can be found here(https://github.com/Nipol/bean-contracts/pull/13), however, this needs to also be reflected in Mochi's contracts.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/155)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\ninterface ICurveVotingEscrow {\n    function create_lock(uint256, uint256) external;\n\n    function increase_amount(uint256) external;\n\n    function increase_unlock_time(uint256) external;\n\n    function withdraw() external;\n\n    function smart_wallet_checker() external view returns (address);\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/ICurveVotingEscrow.sol\";\n\ncontract MochiTreasuryV0 {\n    IMochiEngine public immutable engine;\n\n    IUniswapV2Router02 public immutable uniswapRouter;\n\n    IERC20 public immutable crv;\n    ICurveVotingEscrow public immutable veCrv;\n    bool public lockCrv;\n    uint256 public operationShare;\n    uint256 public veCRVShare;\n\n    constructor(\n        address _engine,\n        address _uniswap,\n        address _crv,\n        address _veCrv\n    ) {\n        engine = IMochiEngine(_engine);\n        uniswapRouter = IUniswapV2Router02(_uniswap);\n        crv = IERC20(_crv);\n        veCrv = ICurveVotingEscrow(_veCrv);\n        lockCrv = false;\n    }\n\n    receive() external payable {}\n\n    function withdrawCRV() external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        crv.transfer(msg.sender, crv.balanceOf(address(this)));\n    }\n\n    function withdrawLock() external {\n        veCrv.withdraw();\n    }\n\n    function veCRVInitialize() external {\n        require(lockCrv, \"!lock\");\n        updateFee();\n        _buyCRV();\n        veCrv.create_lock(\n            crv.balanceOf(address(this)),\n            block.timestamp + 90 days\n        );\n    }\n\n    function toggleLocking() external {\n        require(msg.sender == engine.governance(), \"!gov\");\n        lockCrv = !lockCrv;\n    }\n\n    function updateFee() public {\n        uint256 updatedFee = engine.usdm().balanceOf(address(this)) -\n            operationShare -\n            veCRVShare;\n        operationShare += updatedFee / 2;\n        veCRVShare += updatedFee / 2;\n    }\n\n    function claimOperationCost() external {\n        updateFee();\n        engine.usdm().transfer(engine.operationWallet(), operationShare);\n        operationShare = 0;\n    }\n\n    function veCRVlock() external {\n        require(lockCrv, \"!lock\");\n        updateFee();\n        _buyCRV();\n        _lockCRV();\n        veCRVShare = 0;\n    }\n\n    function _buyCRV() internal {\n        IUSDM usdm = engine.usdm();\n        address[] memory path = new address[](2);\n        path[0] = address(usdm);\n        path[1] = address(crv);\n        usdm.approve(address(uniswapRouter), veCRVShare);\n        uniswapRouter.swapExactTokensForTokens(\n            veCRVShare,\n            1,\n            path,\n            address(this),\n            type(uint256).max\n        );\n    }\n\n    function _lockCRV() internal {\n        crv.approve(address(veCrv), crv.balanceOf(address(this)));\n        veCrv.increase_amount(crv.balanceOf(address(this)));\n        veCrv.increase_unlock_time(block.timestamp + 90 days);\n    }\n}\n\n\n",
        "CodeNames": [
            "ICurveVotingEscrow.sol",
            "MochiTreasuryV0.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-15",
                "Location": [
                    "increase_unlock_time()",
                    "MochiTreasuryV",
                    "create_lock()",
                    "increase_amount()"
                ],
                "Type": "  MochiTreasuryV0.sol  Is Unusable In Its Current State",
                "Description": "\nMochiTreasuryV0.sol interacts with Curve's voting escrow contract to lock tokens for 90 days, where it can be later withdrawn by the governance role. However, VotingEscrow.vy does not allow contracts to call the following functions; create_lock(), increase_amount() and increase_unlock_time(). For these functions, msg.sender must be an EOA account or an approved smart wallet. As a result, any attempt to lock tokens will fail in MochiTreasuryV0.sol.\n\nVotingEscrow.vy L418(https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L418)\nVotingEscrow.vy L438(https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L438)\nVotingEscrow.vy L455(https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L455)\n\n\nManual code review\nDiscussions with the Mochi team\n\n",
                "Repair": "Consider updating this contract to potentially use another escrow service that enables msg.sender to be a contract. Alternatively, this escrow functionality can be replaced with an internal contract which holds usdm tokens instead, removing the need to convert half of the tokens to Curve tokens. Holding Curve tokens for a minimum of 90 days may overly expose the Mochi treasury to Curve token price fluctuations.\n\nryuheimat (Mochi) confirmed(https://github.com/code-423n4/2021-10-mochi-findings/issues/168)\n\n\n"
            }
        ]
    }
]