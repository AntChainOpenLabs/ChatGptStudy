[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\nfunction makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {\n    // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.\n    require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:MP:TRANSFER_FROM_FAILED\");\n\n    ( principal_, interest_ ) = _makePayment();\n\n    emit PaymentMade(principal_, interest_);\n}\n"
                ],
                "Type": "  makePayment()  Lack of access control allows malicious  lender  to retrieve a large portion of the funds earlier, making the borrower suffer fund loss",
                "Description": "\nMapleLoan.sol L86-L93(https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoan.sol#L86-L93)\n\nsolidity\nfunction makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {\n    // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.\n    require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:MP:TRANSFER_FROM_FAILED\");\n\n    ( principal_, interest_ ) = _makePayment();\n\n    emit PaymentMade(principal_, interest_);\n}\n\n\nThe current implementation allows anyone to call makePayment() and repay the loan with _drawableFunds.\n\nThis makes it possible for a malicious lender to call makePayment() multiple times right after fundLoan() and retrieve most of the funds back immediately, while then borrower must continue to make payments or lose the collateral.\n\n\nGiven:\n\n*   _collateralRequired = 1 BTC\n*   _principalRequested = 12,000 USDC\n*   _paymentInterval = 30 day\n*   _paymentsRemaining = 12\n*   _gracePeriod = 1 day\n*   interestRate_ = 2e17\n\n1.  The borrower calls postCollateral() and added 1 BTC as _collateralAsset;\n2.  The lender calls fundLoan() and added 12,000 USDC as  _fundsAsset;\n3.  The lender calls makePayment() 11 times, then:\n\n*   _drawableFunds = 96\n*   _claimableFunds = 11903\n*   _principal = 1553\n\n4.  The lender calls _claimFunds() get 11,903 USDC of _fundsAsset back;\n\nNow, for the borrower 1,579 USDC is due, but only 96 USDC can be used. The borrower is now forced to pay the interests for the funds that never be used or lose the collateral.\n\n",
                "Repair": "\nChange to:\n\nsolidity\nfunction makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {\n    // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.\n    require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:MP:TRANSFER_FROM_FAILED\");\n\n    require(msg.sender == _borrower, \"ML:DF:NOT_BORROWER\");\n\n    ( principal_, interest_ ) = _makePayment();\n\n    emit PaymentMade(principal_, interest_);\n}\n\n\ndeluca-mike (Maple) confirmed(https://github.com/code-423n4/2021-12-maple-findings/issues/56#issuecomment-989565363):\n  Good catch. However, we do want accounts other than the borrower to make payments (this is actually functionality that our current borrowers use), so instead of this fix, we may enforce that a payment can only be made some window of time before it is due, to prevent anyone from prematurely paying it down.\n\npauliax (judge) commented(https://github.com/code-423n4/2021-12-maple-findings/issues/56#issuecomment-997433285):\n  Great find, with a POC, deserves a severity of high as it may incur in funds lost for the borrower. The sponsor has acknowledged and mitigated the issue.\n\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\nfunction closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {\n    // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.\n    require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:CL:TRANSFER_FROM_FAILED\");\n\n    ( principal_, interest_ ) = _closeLoan();\n\n    emit LoanClosed(principal_, interest_);\n}\n"
                ],
                "Type": " Anyone can call  closeLoan()  to close the loan",
                "Description": "\nMapleLoan.sol L56-L63(https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoan.sol#L56-L63)\n\nsolidity\nfunction closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {\n    // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.\n    require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:CL:TRANSFER_FROM_FAILED\");\n\n    ( principal_, interest_ ) = _closeLoan();\n\n    emit LoanClosed(principal_, interest_);\n}\n\n\nBased on the context, we believe that the closeLoan() should only be called by the borrower. However, the current implementation allows anyone to call closeLoan() anytime after fundLoan().\n\nIf there is no earlyFee, this enables a griefing attack, causing the borrower and lender to abandon this contract and redo everything which costs more gas.\n\nIf a platform fee exits, the lender will also suffer fund loss from the platform fee charged in fundLoan().\n\n",
                "Repair": "\nChange to:\n\nsolidity\nfunction closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {\n    // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.\n    require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:CL:TRANSFER_FROM_FAILED\");\n\n    require(msg.sender == _borrower, \"ML:DF:NOT_BORROWER\");\n\n    ( principal_, interest_ ) = _closeLoan();\n\n    emit LoanClosed(principal_, interest_);\n}\n\n\ndeluca-mike (Maple) confirmed(https://github.com/code-423n4/2021-12-maple-findings/issues/46#issuecomment-989556034):\n\npauliax (judge) commented(https://github.com/code-423n4/2021-12-maple-findings/issues/46#issuecomment-997429287):\n  Great find, missing authorization.\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nuint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);\n\n// Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.\nuint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);\n\n// Drawable funds is the amount funded, minus any fees.\n_drawableFunds = fundsLent_ treasuryFee delegateFee;\n\nrequire(\n    treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),\n    \"MLI:FL:T_TRANSFER_FAILED\"\n);\n\nrequire(\n    delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),\n    \"MLI:FL:PD_TRANSFER_FAILED\"\n    );\n"
                ],
                "Type": " Unsafe implementation of  fundLoan()  allows attacker to steal collateral from an unfunded loan",
                "Description": "\nMapleLoanInternals.sol L257-L273(https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoanInternals.sol#L257-L273)\n\nsolidity\nuint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);\n\n// Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.\nuint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);\n\n// Drawable funds is the amount funded, minus any fees.\n_drawableFunds = fundsLent_ treasuryFee delegateFee;\n\nrequire(\n    treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),\n    \"MLI:FL:T_TRANSFER_FAILED\"\n);\n\nrequire(\n    delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),\n    \"MLI:FL:PD_TRANSFER_FAILED\"\n    );\n\n\nIn the current implementation, mapleTreasury, poolDelegate and treasuryFee are taken from user input lender_, which can be faked by setting up a contract with ILenderLike interfaces.\n\nThis allows the attacker to set very high fees, making _drawableFunds near 0.\n\nSince mapleTreasury and poolDelegate are also read from lender_, treasuryFee and investorFee can be retrieved back to the attacker.\n\nAs a result, the borrower won't get any _drawableFunds while also being unable to remove collateral.\n\n\nGiven:\n\n*   _collateralRequired = 10 BTC\n*   _principalRequested = 1,000,000 USDC\n*   _paymentInterval = 1 day\n*   _paymentsRemaining = 10\n*   _gracePeriod = 1 day\n\n1.  Alice (borrower) calls postCollateral() and added 10 BTC as _collateralAsset;\n2.  The attacker calls fundLoan() by taking 1,000,000 USDC of flashloan and using a fake lendercontract;\n3.  Alice calls drawdownFunds() with any amount  0 will fail;\n4.  Alice calls removeCollateral() with any amount  0 will get \"MLI:DF:INSUFFICIENT_COLLATERAL\" error;\n5.  Unless Alice make payment (which is meaningless), after 2 day, the attacker can call repossess() and get 10 BTC.\n\n",
                "Repair": "\nConsider reading treasuryFee, investorFee, mapleTreasury, poolDelegate from an authoritative source instead.\n\nlucas-manuel (Maple) confirmed and disagreed with severity(https://github.com/code-423n4/2021-12-maple-findings/issues/47#issuecomment-989304172):\n  We would consider this medium risk, since a borrower would never post collateral before a loan is funded. We can enforce this on the smart contracts level though by adding a require to the postCollateral function to assert that the principal amount is greater than zero.\n\npauliax (judge) commented(https://github.com/code-423n4/2021-12-maple-findings/issues/47#issuecomment-997435819):\n  Great find. As per the sponsor's recommendation, this scenario is not very likely, so I am marking this issue as of medium severity.\n\n\n"
            }
        ]
    }
]