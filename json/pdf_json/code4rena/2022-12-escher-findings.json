[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// store nextId and remainingSupply, where nextId increases and remainingSupply decreases to 0\n    /// avoids strict equality of current == final\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint96 price;\n        address payable saleReceiver;\n        // slot 3\n        uint96 startTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(0, 0, address(0), type(uint96).max, payable(0), type(uint96).max);\n    }\n\n    /// @notice Owner can cancel current sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        Sale memory sale_ = sale;\n        IEscher721 nft = IEscher721(sale_.edition);\n        require(block.timestamp >= sale_.startTime, \"TOO SOON\");\n        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n        uint48 newId = uint48(_amount) + sale_.currentId;\n        require(newId <= sale_.finalId, \"TOO MANY\");\n\n        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, _amount, msg.value, sale);\n\n        if (newId == sale_.finalId) _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(_sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice cancel a fixed price sale\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    /// @notice Owner can cancel current sale\n    /// @param _sale the sale info\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        selfdestruct(_sale.saleReceiver);\n    }\n}\n\n\n",
        "CodeNames": [
            "FixedPrice.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "selfdestruct()"
                ],
                "Type": " selfdestruct may cause the funds to be lost",
                "Description": "*Submitted by bin2chen(https://github.com/code-423n4/2022-12-escher-findings/issues/296), also found by pauliax(https://github.com/code-423n4/2022-12-escher-findings/issues/311)*\n\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/FixedPrice.sol#L110\n\n<https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/OpenEdition.sol#L122\n\n\nAfter the contract is destroyed, the subsequent execution of the contract's #buy() will always succede, the msg.value will be locked in this address.\n\n\nWhen FixedPrice.sol and OpenEdition.sol are finished, selfdestruct() will be executed to destroy the contract.\n\nBut there is a problem with this:\n\nSuppose when Alice and Bob execute the purchase transaction at the same time, the transaction is in the memory pool (or Alice executes the transaction, but Bob is still operating the purchase in the UI, the UI does not know that the contract has been destroyed)\n\nIf Alice meets the finalId, the contract is destroyed after her transaction ends.\n\nNote: \"When there is no code at the address, the transaction will succeed, and the msg.value will be stored in the contract. Although no code is executed.\"\n\nAfter that, Bob's transaction will be executed.\n\nThis way the msg.value passed by Bob is lost and locked forever in the address of this empty code.\n\nSuggestion: don't use selfdestruct, use modified state to represent that the contract has completed the sale.\n\n",
                "Repair": "\nsolidity\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n...\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n      selfdestruct(_sale.saleReceiver); \n+       sale.finalId = sale.currentId\n+       sale.saleReceiver.transfer(address(this).balance);     \n\n    }\n\n\nberndartmueller (judge) commented(https://github.com/code-423n4/2022-12-escher-findings/issues/296#issuecomment-1345628524):\n  The warden demonstrates an issue that leads to loss of user funds in case the contract is destroyed with selfdestruct.\n \n This clearly differentiates from the other submissions outlining the deprecated use of selfdestruct due to EIP-4758(https://eips.ethereum.org/EIPS/eip-4758).\n\nstevennevins (Escher) disputed and commented(https://github.com/code-423n4/2022-12-escher-findings/issues/296#issuecomment-1362962068):\n  \n // SPDX-License-Identifier: MIT\n pragma solidity ^0.8.17;\n \n import \"forge-std/Test.sol\";\n import {EscherTest, FixedPrice, FixedPriceFactory} from \"test/FixedPrice.t.sol\";\n \n contract Issue296Test is EscherTest {\n     FixedPrice.Sale public fixedSale;\n     FixedPriceFactory public fixedSales;\n \n     FixedPrice public sale;\n \n     function setUp() public virtual override {\n         super.setUp();\n         fixedSales = new FixedPriceFactory();\n         fixedSale = FixedPrice.Sale({\n             currentId: uint48(0),\n             finalId: uint48(10),\n             edition: address(edition),\n             price: uint96(uint256(1 ether)),\n             saleReceiver: payable(address(69)),\n             startTime: uint96(block.timestamp)\n         });\n         sale = FixedPrice(fixedSales.createFixedSale(fixedSale));\n         edition.grantRole(edition.MINTER_ROLE(), address(sale));\n         sale.buy{value: 10 ether}(10);\n     }\n \n     function test_RevertsWhenAfterSelfDestruct_Buy() public {\n         vm.expectRevert();\n         sale.buy{value: 1 ether}(1);\n     }\n }\n \n \n Any purchases after the selfdestruct would revert as shown above.  In order to accurately mock this in Foundry, you can't perform the destruction within a test function since everything would be one large transaction and the code would still exist as far as Foundry is concerned because it's all in the same call context. So you have to move the purchase that selfdestructs the contract into the setup function to demonstrate the behavior.\n\nberndartmueller (judge) commented(https://github.com/code-423n4/2022-12-escher-findings/issues/296#issuecomment-1370711821):\n  @stevennevins You're right with your Foundry example. However, there are subtle nuances to this that make this finding valid.\n \n In your Foundry test, the Solidity function call via sale.buy{value: 1 ether}(1) at the end, uses the extcodesize opcode to check that the contract that is about to be called actually exists and causes an exception if it does not.\n \n However, in the above demonstrated PoC, if a transaction gets executed _after_ the contract got destroyed (due to buying the final token id), the transaction does not revert and any value sent along with the transaction will be stored in the contract.\n \n I was able to reproduce this behavior with a minimal example contract on Goerli via Remix:\n \n solidity\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity 0.8.7;\n \n contract Sale  {\n     function buy() external payable {\n         _end();\n     }\n \n     function _end() internal {\n         selfdestruct(payable(msg.sender));\n     }\n }\n \n \n Calling the Sale.buy() function in Remix twice, once with a value of 1337 wei and once with 333 wei:\n \n 1) https://goerli.etherscan.io/tx/0x138d2c061ed547ec5bfd4d7d9b03b519f92b5f63a74b73c45a1af6efe202727c\n 2) https://goerli.etherscan.io/tx/0x7ca9032cf79f0a8e29da17061e7eeafb46edfddff96633dc9bbf5957f1aff142\n \n As you can see, the first transaction will destroy the contract, 1337 wei is sent to the beneficiary (caller). The second transaction succeeds as well. However, the value of 333 wei is kept at the address of the destroyed contract.\n \n After many considerations, I consider High to be the appropriate severity. Multiple parallel transactions (e.g. front-runners) will likely try to buy the last NFT IDs, whereas all transactions executed after the last successful buy will render the sent msg.value locked in the destroyed contract. Those users lost funds while not receiving any NFTs.\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface ISale {\n    function buy(uint256) external payable;\n\n    function getPrice() external view returns (uint256);\n\n    function startTime() external view returns (uint256);\n\n    function available() external view returns (uint256);\n\n    function editionContract() external view returns (address);\n}\n\n\n",
        "CodeNames": [
            "ISale.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nfunction getPrice() public view returns (uint256) {\n    Sale memory temp = sale;\n    (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n    if (block.timestamp < start) return type(uint256).max;\n    if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n    uint256 timeElapsed = end  block.timestamp ? block.timestamp start : end start;\n    return temp.startPrice (temp.dropPerSecond * timeElapsed);\n}\n",
                    "//solidity\n// SPDX-License-Identifier: MIT\npragma //solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {FixedPriceFactory} from \"src/minters/FixedPriceFactory.sol\";\nimport {FixedPrice} from \"src/minters/FixedPrice.sol\";\nimport {OpenEditionFactory} from \"src/minters/OpenEditionFactory.sol\";\nimport {OpenEdition} from \"src/minters/OpenEdition.sol\";\nimport {LPDAFactory} from \"src/minters/LPDAFactory.sol\";\nimport {LPDA} from \"src/minters/LPDA.sol\";\nimport {Escher721} from \"src/Escher721.sol\";\n\ncontract AuditTest is Test {\n    address deployer;\n    address creator;\n    address buyer;\n\n    FixedPriceFactory fixedPriceFactory;\n    OpenEditionFactory openEditionFactory;\n    LPDAFactory lpdaFactory;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        creator = makeAddr(\"creator\");\n        buyer = makeAddr(\"buyer\");\n\n        vm.deal(buyer, 1e18);\n\n        vm.startPrank(deployer);\n\n        fixedPriceFactory = new FixedPriceFactory();\n        openEditionFactory = new OpenEditionFactory();\n        lpdaFactory = new LPDAFactory();\n\n        vm.stopPrank();\n    }\n    \n    function test_LPDA_getPrice_NegativePrice() public {\n        // Setup NFT and create sale\n        vm.startPrank(creator);\n\n        Escher721 nft = new Escher721();\n        nft.initialize(creator, address(0), \"Test NFT\", \"TNFT\");\n\n        // Duration is 1 hour (3600 seconds), with a start price of 1500 and a drop of 1, getPrice will revert and brick the contract at about 40% of the elapsed duration\n        uint48 startId = 0;\n        uint48 finalId = 1;\n        uint80 startPrice = 1500;\n        uint80 dropPerSecond = 1;\n        uint96 startTime = uint96(block.timestamp);\n        uint96 endTime = uint96(block.timestamp + 1 hours);\n\n        LPDA.Sale memory sale = LPDA.Sale(\n            startId, // uint48 currentId;\n            finalId, // uint48 finalId;\n            address(nft), // address edition;\n            startPrice, // uint80 startPrice;\n            0, // uint80 finalPrice;\n            dropPerSecond, // uint80 dropPerSecond;\n            endTime, // uint96 endTime;\n            payable(creator), // address payable saleReceiver;\n            startTime // uint96 startTime;\n        );\n        LPDA lpdaSale = LPDA(lpdaFactory.createLPDASale(sale));\n\n        nft.grantRole(nft.MINTER_ROLE(), address(lpdaSale));\n\n        vm.stopPrank();\n\n        // simulate we are in the middle of the sale duration\n        vm.warp(startTime + 0.5 hours);\n\n        vm.startPrank(buyer);\n\n        // getPrice will revert due to the overflow caused by the price becoming negative\n        vm.expectRevert();\n        lpdaSale.getPrice();\n\n        // This will also cause the contract to be bricked, since buy needs getPrice to check that the buyer is sending the correct amount\n        uint256 amount = 1;\n        uint256 price = 1234;\n        vm.expectRevert();\n        lpdaSale.buy{value: price * amount}(amount);\n\n        vm.stopPrank();\n    }\n}\n"
                ],
                "Type": "  LPDA  price can underflow the price due to bad settings and potentially brick the contract",
                "Description": "*Submitted by adriro(https://github.com/code-423n4/2022-12-escher-findings/issues/392), also found by Aymen0909(https://github.com/code-423n4/2022-12-escher-findings/issues/534), Franfran(https://github.com/code-423n4/2022-12-escher-findings/issues/514), kiki_dev(https://github.com/code-423n4/2022-12-escher-findings/issues/501), Ch_301(https://github.com/code-423n4/2022-12-escher-findings/issues/497), Chom(https://github.com/code-423n4/2022-12-escher-findings/issues/486), slvDev(https://github.com/code-423n4/2022-12-escher-findings/issues/485), lukris02(https://github.com/code-423n4/2022-12-escher-findings/issues/472), 0xRobocop(https://github.com/code-423n4/2022-12-escher-findings/issues/470), minhquanym(https://github.com/code-423n4/2022-12-escher-findings/issues/462), immeas(https://github.com/code-423n4/2022-12-escher-findings/issues/442), nameruse(https://github.com/code-423n4/2022-12-escher-findings/issues/437), 0xDecorativePineapple(https://github.com/code-423n4/2022-12-escher-findings/issues/432), carrotsmuggler(https://github.com/code-423n4/2022-12-escher-findings/issues/429), kaliberpoziomka8552(https://github.com/code-423n4/2022-12-escher-findings/issues/428), jonatascm(https://github.com/code-423n4/2022-12-escher-findings/issues/427), minhtrng(https://github.com/code-423n4/2022-12-escher-findings/issues/397), imare(https://github.com/code-423n4/2022-12-escher-findings/issues/388), neumo(https://github.com/code-423n4/2022-12-escher-findings/issues/381), ladboy233(https://github.com/code-423n4/2022-12-escher-findings/issues/375), Tricko(https://github.com/code-423n4/2022-12-escher-findings/issues/371), mahdikarimi(https://github.com/code-423n4/2022-12-escher-findings/issues/346), sorrynotsorry(https://github.com/code-423n4/2022-12-escher-findings/issues/333), kree-dotcom(https://github.com/code-423n4/2022-12-escher-findings/issues/327), pauliax(https://github.com/code-423n4/2022-12-escher-findings/issues/316), poirots(https://github.com/code-423n4/2022-12-escher-findings/issues/305), bin2chen(https://github.com/code-423n4/2022-12-escher-findings/issues/298), jayphbee(https://github.com/code-423n4/2022-12-escher-findings/issues/297), 0xDave(https://github.com/code-423n4/2022-12-escher-findings/issues/244), jadezti(https://github.com/code-423n4/2022-12-escher-findings/issues/234), evan(https://github.com/code-423n4/2022-12-escher-findings/issues/231), reassor(https://github.com/code-423n4/2022-12-escher-findings/issues/229), gz627(https://github.com/code-423n4/2022-12-escher-findings/issues/209), 0xbepresent(https://github.com/code-423n4/2022-12-escher-findings/issues/205), 0xA5DF(https://github.com/code-423n4/2022-12-escher-findings/issues/201), hihen(https://github.com/code-423n4/2022-12-escher-findings/issues/196), chaduke(https://github.com/code-423n4/2022-12-escher-findings/issues/186), hansfriese(https://github.com/code-423n4/2022-12-escher-findings/issues/180), yixxas(https://github.com/code-423n4/2022-12-escher-findings/issues/167), Madalad(https://github.com/code-423n4/2022-12-escher-findings/issues/165), HollaDieWaldfee(https://github.com/code-423n4/2022-12-escher-findings/issues/157), Parth(https://github.com/code-423n4/2022-12-escher-findings/issues/143), 0x446576(https://github.com/code-423n4/2022-12-escher-findings/issues/118), lumoswiz(https://github.com/code-423n4/2022-12-escher-findings/issues/108), danyams(https://github.com/code-423n4/2022-12-escher-findings/issues/98), obront(https://github.com/code-423n4/2022-12-escher-findings/issues/94), zapaz(https://github.com/code-423n4/2022-12-escher-findings/issues/62), rvierdiiev(https://github.com/code-423n4/2022-12-escher-findings/issues/49), 8olidity(https://github.com/code-423n4/2022-12-escher-findings/issues/39), and Ruhum(https://github.com/code-423n4/2022-12-escher-findings/issues/31)*\n\nThe dutch auction in the LPDA contract is implemented by configuring a start price and price drop per second.\n\nA bad set of settings can cause an issue where the elapsed duration of the sale multiplied by the drop per second gets bigger than the start price and underflows the current price calculation.\n\n<https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L117\n\nsolidity\nfunction getPrice() public view returns (uint256) {\n    Sale memory temp = sale;\n    (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n    if (block.timestamp < start) return type(uint256).max;\n    if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n    uint256 timeElapsed = end  block.timestamp ? block.timestamp start : end start;\n    return temp.startPrice (temp.dropPerSecond * timeElapsed);\n}\n\n\nThis means that if temp.dropPerSecond * timeElapsed  temp.startPrice then the unsigned integer result will become negative and underflow, leading to potentially bricking the contract and an eventual loss of funds.\n\n\nDue to Solidity 0.8 default checked math, the subtraction of the start price and the drop will cause a negative value that will generate an underflow in the unsigned integer type and lead to a transaction revert.\n\nCalls to getPrice will revert, and since this function is used in the buy to calculate the current NFT price it will also cause the buy process to fail. The price drop will continue to increase as time passes, making it impossible to recover from this situation and effectively bricking the contract.\n\nThis will eventually lead to a loss of funds because currently the only way to end a sale and transfer funds to the sale and fee receiver is to buy the complete set of NFTs in the sale (i.e. buy everything up to the sale.finalId) which will be impossible if the buy function is bricked.\n\n\nIn the following test, the start price is 1500 and the duration is 1 hour (3600 seconds) with a drop of 1 per second. At about ~40% of the elapsed time the price drop will start underflowing the price, reverting the calls to both getPrice and buy.\n\nsolidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport {FixedPriceFactory} from \"src/minters/FixedPriceFactory.sol\";\nimport {FixedPrice} from \"src/minters/FixedPrice.sol\";\nimport {OpenEditionFactory} from \"src/minters/OpenEditionFactory.sol\";\nimport {OpenEdition} from \"src/minters/OpenEdition.sol\";\nimport {LPDAFactory} from \"src/minters/LPDAFactory.sol\";\nimport {LPDA} from \"src/minters/LPDA.sol\";\nimport {Escher721} from \"src/Escher721.sol\";\n\ncontract AuditTest is Test {\n    address deployer;\n    address creator;\n    address buyer;\n\n    FixedPriceFactory fixedPriceFactory;\n    OpenEditionFactory openEditionFactory;\n    LPDAFactory lpdaFactory;\n\n    function setUp() public {\n        deployer = makeAddr(\"deployer\");\n        creator = makeAddr(\"creator\");\n        buyer = makeAddr(\"buyer\");\n\n        vm.deal(buyer, 1e18);\n\n        vm.startPrank(deployer);\n\n        fixedPriceFactory = new FixedPriceFactory();\n        openEditionFactory = new OpenEditionFactory();\n        lpdaFactory = new LPDAFactory();\n\n        vm.stopPrank();\n    }\n    \n    function test_LPDA_getPrice_NegativePrice() public {\n        // Setup NFT and create sale\n        vm.startPrank(creator);\n\n        Escher721 nft = new Escher721();\n        nft.initialize(creator, address(0), \"Test NFT\", \"TNFT\");\n\n        // Duration is 1 hour (3600 seconds), with a start price of 1500 and a drop of 1, getPrice will revert and brick the contract at about 40% of the elapsed duration\n        uint48 startId = 0;\n        uint48 finalId = 1;\n        uint80 startPrice = 1500;\n        uint80 dropPerSecond = 1;\n        uint96 startTime = uint96(block.timestamp);\n        uint96 endTime = uint96(block.timestamp + 1 hours);\n\n        LPDA.Sale memory sale = LPDA.Sale(\n            startId, // uint48 currentId;\n            finalId, // uint48 finalId;\n            address(nft), // address edition;\n            startPrice, // uint80 startPrice;\n            0, // uint80 finalPrice;\n            dropPerSecond, // uint80 dropPerSecond;\n            endTime, // uint96 endTime;\n            payable(creator), // address payable saleReceiver;\n            startTime // uint96 startTime;\n        );\n        LPDA lpdaSale = LPDA(lpdaFactory.createLPDASale(sale));\n\n        nft.grantRole(nft.MINTER_ROLE(), address(lpdaSale));\n\n        vm.stopPrank();\n\n        // simulate we are in the middle of the sale duration\n        vm.warp(startTime + 0.5 hours);\n\n        vm.startPrank(buyer);\n\n        // getPrice will revert due to the overflow caused by the price becoming negative\n        vm.expectRevert();\n        lpdaSale.getPrice();\n\n        // This will also cause the contract to be bricked, since buy needs getPrice to check that the buyer is sending the correct amount\n        uint256 amount = 1;\n        uint256 price = 1234;\n        vm.expectRevert();\n        lpdaSale.buy{value: price * amount}(amount);\n\n        vm.stopPrank();\n    }\n}\n\n\n",
                "Repair": "\nAdd a validation in the LPDAFactory.createLPDASale function to ensure that the given duration and drop per second settings can't underflow the price.\n\nsolidity\nrequire((sale.endTime sale.startTime) * sale.dropPerSecond <= sale.startPrice, \"MAX DROP IS GREATER THAN START PRICE\");\n\n\nstevennevins (Escher) confirmed(https://github.com/code-423n4/2022-12-escher-findings/issues/392)\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface ISaleFactory {\n    function feeReceiver() external view returns (address payable);\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract LPDA is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// we use different uints and some weird ordering to pack variables into 32 bytes\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint80 startPrice;\n        uint80 finalPrice;\n        uint80 dropPerSecond;\n        // slot 3\n        uint96 endTime;\n        address payable saleReceiver;\n        // slot 4\n        uint96 startTime;\n    }\n\n    struct Receipt {\n        uint48 amount;\n        uint80 balance;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n    uint48 public amountSold = 0;\n\n    /// @notice tracked the amount paid by people during the LPDA\n    mapping(address => Receipt) public receipts;\n\n    event Start(Sale _saleInfo);\n    event End(Sale _saleInfo);\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        uint48 x = type(uint48).max;\n        uint80 y = type(uint80).max;\n        uint96 z = type(uint96).max;\n        address payable i = payable(address(0));\n        sale = LPDA.Sale(x, x, i, y, y, y, z, i, z);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        uint48 amount = uint48(_amount);\n        Sale memory temp = sale;\n        IEscher721 nft = IEscher721(temp.edition);\n        require(block.timestamp >= temp.startTime, \"TOO SOON\");\n        uint256 price = getPrice();\n        require(msg.value >= amount * price, \"WRONG PRICE\");\n\n        amountSold += amount;\n        uint48 newId = amount + temp.currentId;\n        require(newId <= temp.finalId, \"TOO MANY\");\n\n        receipts[msg.sender].amount += amount;\n        receipts[msg.sender].balance += uint80(msg.value);\n\n        for (uint256 x = temp.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, amount, msg.value, temp);\n\n        if (newId == temp.finalId) {\n            sale.finalPrice = uint80(price);\n            uint256 totalSale = price * amountSold;\n            uint256 fee = totalSale / 20;\n            ISaleFactory(factory).feeReceiver().transfer(fee);\n            temp.saleReceiver.transfer(totalSale - fee);\n            _end();\n        }\n    }\n\n    /// @notice cancel a fixed price sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        sale.finalId = sale.currentId;\n        _end();\n    }\n\n    /// @notice allow a buyer to get a refund on the current price difference\n    function refund() public {\n        Receipt memory r = receipts[msg.sender];\n        uint80 price = uint80(getPrice()) * r.amount;\n        uint80 owed = r.balance - price;\n        require(owed > 0, \"NOTHING TO REFUND\");\n        receipts[msg.sender].balance = price;\n        payable(msg.sender).transfer(owed);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale calldata _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        Sale memory temp = sale;\n        (uint256 start, uint256 end) = (temp.startTime, temp.endTime);\n        if (block.timestamp < start) return type(uint256).max;\n        if (temp.currentId == temp.finalId) return temp.finalPrice;\n\n        uint256 timeElapsed = end > block.timestamp ? block.timestamp - start : end - start;\n        return temp.startPrice - (temp.dropPerSecond * timeElapsed);\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    function lowestPrice() public view returns (uint256) {\n        return sale.startPrice - (sale.dropPerSecond * (sale.endTime - sale.startTime));\n    }\n\n    function _end() internal {\n        emit End(sale);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ISale} from \"../interfaces/ISale.sol\";\nimport {ISaleFactory} from \"../interfaces/ISaleFactory.sol\";\nimport {IEscher721} from \"../interfaces/IEscher721.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract FixedPrice is Initializable, OwnableUpgradeable, ISale {\n    address public immutable factory;\n    /// store nextId and remainingSupply, where nextId increases and remainingSupply decreases to 0\n    /// avoids strict equality of current == final\n    struct Sale {\n        // slot 1\n        uint48 currentId;\n        uint48 finalId;\n        address edition;\n        // slot 2\n        uint96 price;\n        address payable saleReceiver;\n        // slot 3\n        uint96 startTime;\n    }\n\n    /// @notice sale info for this fixed price edition\n    Sale public sale;\n\n    /// @notice Event emitted when sale created\n    /// @param _saleInfo the sale info for the edition\n    event Start(Sale _saleInfo);\n    /// @notice Event emitted when sale ends\n    /// @param _saleInfo the sale info for the edition\n    event End(Sale _saleInfo);\n    /// @notice Event emitted when a user buys an edition\n    /// @param _buyer the address of the buyer\n    /// @param _amount the amount of editions bought\n    /// @param _value the total value of the purchase\n    /// @param _saleInfo the sale info for the edition\n    event Buy(address indexed _buyer, uint256 _amount, uint256 _value, Sale _saleInfo);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        factory = msg.sender;\n        _disableInitializers();\n        sale = Sale(0, 0, address(0), type(uint96).max, payable(0), type(uint96).max);\n    }\n\n    /// @notice Owner can cancel current sale\n    function cancel() external onlyOwner {\n        require(block.timestamp < sale.startTime, \"TOO LATE\");\n        _end(sale);\n    }\n\n    /// @notice buy from a fixed price sale after the sale starts\n    /// @param _amount the amount of editions to buy\n    function buy(uint256 _amount) external payable {\n        Sale memory sale_ = sale;\n        IEscher721 nft = IEscher721(sale_.edition);\n        require(block.timestamp >= sale_.startTime, \"TOO SOON\");\n        require(_amount * sale_.price == msg.value, \"WRONG PRICE\");\n        uint48 newId = uint48(_amount) + sale_.currentId;\n        require(newId <= sale_.finalId, \"TOO MANY\");\n\n        for (uint48 x = sale_.currentId + 1; x <= newId; x++) {\n            nft.mint(msg.sender, x);\n        }\n\n        sale.currentId = newId;\n\n        emit Buy(msg.sender, _amount, msg.value, sale);\n\n        if (newId == sale_.finalId) _end(sale);\n    }\n\n    /// @notice initialize the proxy sale contract\n    /// @param _sale the sale info\n    function initialize(Sale memory _sale) public initializer {\n        sale = _sale;\n        _transferOwnership(_sale.saleReceiver);\n        emit Start(_sale);\n    }\n\n    /// @notice cancel a fixed price sale\n    /// @notice the price of the sale\n    function getPrice() public view returns (uint256) {\n        return sale.price;\n    }\n\n    /// @notice the start time of the sale\n    function startTime() public view returns (uint256) {\n        return sale.startTime;\n    }\n\n    /// @notice the edition contract having the sale\n    function editionContract() public view returns (address) {\n        return sale.edition;\n    }\n\n    /// @notice the number of NFTs still available\n    function available() public view returns (uint256) {\n        return sale.finalId - sale.currentId;\n    }\n\n    /// @notice Owner can cancel current sale\n    /// @param _sale the sale info\n    function _end(Sale memory _sale) internal {\n        emit End(_sale);\n        ISaleFactory(factory).feeReceiver().transfer(address(this).balance / 20);\n        selfdestruct(_sale.saleReceiver);\n    }\n}\n\n\n",
        "CodeNames": [
            "ISaleFactory.sol",
            "LPDA.sol",
            "FixedPrice.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "javascript\n81:        if (newId == temp.finalId) {\n82:            sale.finalPrice = uint80(price);\n83:            uint256 totalSale = price * amountSold;\n84:            uint256 fee = totalSale / 20;\n85:            ISaleFactory(factory).feeReceiver().transfer(fee);\n86:            temp.saleReceiver.transfer(totalSale fee);\n87:            _end();\n88:        }\n",
                    "javascript\n67:        uint48 newId = amount + temp.currentId;\n68:        require(newId <= temp.finalId, \"TOO MANY\");\n",
                    "javascript\n    function test_BuyStealRefund() public {\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        \n        // buy most nfts at a higher price\n        sale.buy{value: 9 ether}(9);\n\n        // warp to when price is lowest\n        vm.warp(block.timestamp + 1 days);\n        uint256 price = sale.getPrice(); // 0.9 eth\n\n        // buy last nft at lowest possible price\n        sale.buy{value: price}(1);\n\n        uint256 contractBalanceAfterEnd = address(sale).balance;\n        uint256 receiverBalanceAfterEnd = address(69).balance;\n        console.log(\"Sale end\");\n        console.log(\"LPDA contract\",contractBalanceAfterEnd); // ~ 0.9 eth\n        console.log(\"saleReceiver \",receiverBalanceAfterEnd); // ~9 fee eth\n\n        // buy 0 nfts for the totalSales price current balance\n        // totalSales: 9 eth contract balance 0.9 eth = ~8.1 eth\n        uint256 totalSale = price * 10;\n        uint256 delta = totalSale contractBalanceAfterEnd;\n        sale.buy{value: delta}(0);\n\n        console.log(\"after steal\");\n        console.log(\"LPDA contract\",address(sale).balance);\n        console.log(\"saleReceiver \",address(69).balance receiverBalanceAfterEnd delta); // ~0.45 eth stolen by receiver, 0.45 eth to fees\n\n        // buyer supposed to get back the ~0.9 eth\n        vm.expectRevert(); // EvmError: OutOfFund\n        sale.refund(); // nothing to refund\n    }\n"
                ],
                "Type": "  saleReceiver  and  feeReceiver  can steal refunds after sale has ended",
                "Description": "*Submitted by immeas(https://github.com/code-423n4/2022-12-escher-findings/issues/441), also found by AkshaySrivastav(https://github.com/code-423n4/2022-12-escher-findings/issues/510), cryptonue(https://github.com/code-423n4/2022-12-escher-findings/issues/490), saian(https://github.com/code-423n4/2022-12-escher-findings/issues/463), minhquanym(https://github.com/code-423n4/2022-12-escher-findings/issues/457), 0xDecorativePineapple(https://github.com/code-423n4/2022-12-escher-findings/issues/440), gzeon(https://github.com/code-423n4/2022-12-escher-findings/issues/431), ey88(https://github.com/code-423n4/2022-12-escher-findings/issues/426), wait(https://github.com/code-423n4/2022-12-escher-findings/issues/411), pauliax(https://github.com/code-423n4/2022-12-escher-findings/issues/313), HollaDieWaldfee(https://github.com/code-423n4/2022-12-escher-findings/issues/293), jayphbee(https://github.com/code-423n4/2022-12-escher-findings/issues/291), bin2chen(https://github.com/code-423n4/2022-12-escher-findings/issues/289), evan(https://github.com/code-423n4/2022-12-escher-findings/issues/227), reassor(https://github.com/code-423n4/2022-12-escher-findings/issues/225), fs0c(https://github.com/code-423n4/2022-12-escher-findings/issues/198), hihen(https://github.com/code-423n4/2022-12-escher-findings/issues/189), hansfriese(https://github.com/code-423n4/2022-12-escher-findings/issues/174), 0x52(https://github.com/code-423n4/2022-12-escher-findings/issues/35), and aviggiano(https://github.com/code-423n4/2022-12-escher-findings/issues/16)*\n\n<https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L67-L68\n\n<https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L81-L88\n\nFirst, lets go over how a buy happens.\n\nA buyer can buy NFTs at a higher price and then once the auction ends they can use refund() to return the over payments. The effect is that they bought the NFTs at the lowest price (Lowest Price Dutch Auction).\n\nNow, let's move on to what happens when the sale ends:\n\nThe sale is considered ended when the last NFT is sold which triggers the payout to the seller and fee collector:\n\njavascript\n81:        if (newId == temp.finalId) {\n82:            sale.finalPrice = uint80(price);\n83:            uint256 totalSale = price * amountSold;\n84:            uint256 fee = totalSale / 20;\n85:            ISaleFactory(factory).feeReceiver().transfer(fee);\n86:            temp.saleReceiver.transfer(totalSale fee);\n87:            _end();\n88:        }\n\n\nEarlier there's also a check that you cannot continue buying once the currentId has reached finalId:\n\njavascript\n67:        uint48 newId = amount + temp.currentId;\n68:        require(newId <= temp.finalId, \"TOO MANY\");\n\n\nHowever, it is still possible to buy 0 NFTs for whichever price you want even after the sale has ended. Triggering the \"end of sale\" snippet again, since newId will still equal temp.finalId.\n\nThe attacker, saleReceiver (or feeReceiver), buys 0 NFTs for the delta between totalSale and the balance still in the contract (the over payments by buyers). If there is more balance in the contract than totalSales this can be iterated until the contract is empty.\n\nThe attacker has then stolen the over payments from the buyers.\n\nA buyer can mitigate this by continuously calling refund() as the price lowers but that would incur a high gas cost.\n\n\nsaleReceiver or feeReceiver can steal buyers over payments after the sale has ended. Who gains the most depends on circumstances in the auction.\n\n\nPoC test in test/LPDA.t.sol:\n\njavascript\n    function test_BuyStealRefund() public {\n        sale = LPDA(lpdaSales.createLPDASale(lpdaSale));\n        edition.grantRole(edition.MINTER_ROLE(), address(sale));\n        \n        // buy most nfts at a higher price\n        sale.buy{value: 9 ether}(9);\n\n        // warp to when price is lowest\n        vm.warp(block.timestamp + 1 days);\n        uint256 price = sale.getPrice(); // 0.9 eth\n\n        // buy last nft at lowest possible price\n        sale.buy{value: price}(1);\n\n        uint256 contractBalanceAfterEnd = address(sale).balance;\n        uint256 receiverBalanceAfterEnd = address(69).balance;\n        console.log(\"Sale end\");\n        console.log(\"LPDA contract\",contractBalanceAfterEnd); // ~ 0.9 eth\n        console.log(\"saleReceiver \",receiverBalanceAfterEnd); // ~9 fee eth\n\n        // buy 0 nfts for the totalSales price current balance\n        // totalSales: 9 eth contract balance 0.9 eth = ~8.1 eth\n        uint256 totalSale = price * 10;\n        uint256 delta = totalSale contractBalanceAfterEnd;\n        sale.buy{value: delta}(0);\n\n        console.log(\"after steal\");\n        console.log(\"LPDA contract\",address(sale).balance);\n        console.log(\"saleReceiver \",address(69).balance receiverBalanceAfterEnd delta); // ~0.45 eth stolen by receiver, 0.45 eth to fees\n\n        // buyer supposed to get back the ~0.9 eth\n        vm.expectRevert(); // EvmError: OutOfFund\n        sale.refund(); // nothing to refund\n    }\n\n\n\nVS Code, Forge\n\n",
                "Repair": "\nI can think of different options of how to mitigate this:\n\n*   Don't allow buying 0 NFTs\n*   Don't allow buying if newId == finalId since the sale has ended\n\nmehtaculous (Escher) disagreed with severity(https://github.com/code-423n4/2022-12-escher-findings/issues/16) \n\n*\n\n \n\n"
            }
        ]
    }
]