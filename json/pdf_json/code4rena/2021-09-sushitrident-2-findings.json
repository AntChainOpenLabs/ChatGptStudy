[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n(uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));\n"
                ],
                "Type": " Unsafe cast in  ConcentratedLiquidityPool.burn  leads to attack",
                "Description": "\nThe ConcentratedLiquidityPool.burn function performs an unsafe cast of a uint128 type to a *signed* integer.\n\nsolidity\n(uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));\n\n\nNote that amount is chosen by the caller and when choosing amount = 2128 1, this is interpreted as 0xFFFFFFFFF... = -1 as a signed integer. Thus -(-1)=1 adds 1 liquidity unit to the position\n\nThis allows an attacker to not only mint LP tokens for free but as this is the burn function it also redeems token0/1 amounts according to the unmodified uint128 amount which is an extremely large value.\n\n\nI created this POC that implements a hardhat test and shows how to steal the pool tokens.\n\nChoosing the correct amount of liquidity to burn and lower, upper ticks is not straight-forward because of two competing constraints:\n\n1.  the -int128(amount) must be less than MAX_TICK_LIQUIDITY (see _updatePosition). This drives the the amount up to its max value (as the max uint128 value is -1 = -(-1)=1 is very low)\n2.  The redeemed amount0, amount1 values must be less than the current pool balance as the transfers would otherwise fail. This drives the amount down. However, by choosing a smart lower and upper tick range we can redeem fewer tokens for the same liquidity.\n\nThis example(https://gist.github.com/MrToph/1731dd6947073343cf6f942985d556a6) shows how to steal 99% of the token0 pool reserves:\n\n\nAn attacker can steal the pool tokens.\n\n",
                "Repair": "\nEven though Solidity 0.8.x is used, type casts do not throw an error.\nA SafeCast library(https://docs.openzeppelin.com/contracts/4.x/api/utils#SafeCast) must be used everywhere a typecast is done.\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/50)\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nIncentive memory incentive = incentives[pool][positionId];\n"
                ],
                "Type": " Wrong usage of  positionId  in  ConcentratedLiquidityPoolManager ",
                "Description": "\nIn the subscribe function of ConcentratedLiquidityPoolManager, the incentive to subscribed is determined as follows:\n\nsolidity\nIncentive memory incentive = incentives[pool][positionId];\n\n\nHowever, positionId should be incentiveId, a counter that increases by one whenever a new incentive is added to the pool. The usage of positionId could cause the wrong incentive to be used, and in general, the incentive is not found, and the transaction reverts (the condition block.timestamp < incentive.endTime is not met). The getReward and claimReward functions have the bug of misusing positionId as the index of incentives.\n\nReferenced code:\nConcentratedLiquidityPoolManager.sol#L68(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L68)\nConcentratedLiquidityPoolManager.sol#L87(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L87)\nConcentratedLiquidityPoolManager.sol#L105(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L105)\n\n",
                "Repair": "Change positionId to incentiveId in the referenced lines of code.\n\nsarangparikh22 (Sushi) confirmed but disagreed with severity(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/86#issuecomment-940846279)\n\n\n"
            },
            {
                "Name": "H-03",
                "Location": [],
                "Type": "  ConcentratedLiquidityPoolManager 's incentives can be stolen",
                "Description": "\nThe ConcentratedLiquidityPoolManager keeps all tokens for all incentives in the same contract. The reclaimIncentive function does not reduce the incentive.rewardsUnclaimed field and thus one can reclaim tokens several times.\nThis allows anyone to steal all tokens from all incentives by creating an incentive themself, and once it's expired, repeatedly claim the unclaimed rewards until the token balance is empty.\n\n*   Attacker creates an incentive for a non-existent pool using a random address for pool (This is done such that no other user can claim rewards as we need a non-zero rewardsUnclaimed balance for expiry). They choose the incentive.token to be the token they want to steal from other incentives. (for example, WETH, USDC, or SUSHI) They choose the startTime, endTime, expiry such that the checks pass, i.e., starting and ending in a few seconds from now, expiring in 5 weeks. Then they choose a non-zero rewardsUnclaimed and transfer the incentive.token to the PoolManager.\n*   Attacker waits for 5 weeks until the incentive is expired\n*   Attacker can now call reclaimIncentive(pool, incentiveId, amount=incentive.rewardsUnclaimed, attacker, false) to withdraw incentive.rewardsUnclaimed of incentive.token from the pool manager.\n*   As the incentive.rewardsUnclaimed variable has not been decreased, they can keep calling reclaimIncentive until the pool is drained.\n\nAn attacker can steal all tokens in the PoolManager.\n\n",
                "Repair": "In reclaimIncentive, reduce incentive.rewardsUnclaimed by the withdrawn amount.\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/37)\n\n\n"
            },
            {
                "Name": "H-04",
                "Location": [
                    "//solidity\nmintParams.lower = 100000\nmintParams.upper = 500000\nmintParams.amount1Desired = (1 << 128) 47541305835 # a carefully chosen number\nmintParams.amount0Desired = 0\n",
                    "//solidity\n_liquidity = mintParams.amount1Desired * (1 << 96) // (priceUpper priceLower)\n    = 4731732988155153573010127839\n",
                    "//solidity\namount0Actual = 0\namount1Actual = uint128(DyDxMath.getDy(_liquidity, priceLower, priceUpper, true))\n    = uint128(_liquidity * (priceUpper priceLower) // (1 << 96)) # round up\n    = uint128(340282366920938463463374607384226905622)\n    = 340282366920938463463374607384226905622\n    = (1 << 128) 47541305834\n"
                ],
                "Type": " Overflow in the  mint  function of  ConcentratedLiquidityPool  causes LPs' funds to be stolen",
                "Description": "\nSimilar to a previous finding in the IndexPool contract, the mint function of ConcentratedLiquidityPool allows integer overflows when checking the balance is larger or equal to the received amount of token plus the reserve. As a result, the attacker could get a large amount of liquidity but only provide a small number of tokens to the pool, effectively stealing other LPs' funds when burning his liquidity.\n\nNotice that this bug is independent of another bug of incorrect casting uint256 type to uint128 in the _getAmountsForLiquidity function. Even if the previously mentioned bug does not exist, the attacker could still steal the funds in the pool by exploiting this bug.\n\n1.  Suppose that the current price is at the tick 500000, an attacker calls the mint function with the following parameters:\n\nsolidity\nmintParams.lower = 100000\nmintParams.upper = 500000\nmintParams.amount1Desired = (1 << 128) 47541305835 # a carefully chosen number\nmintParams.amount0Desired = 0\n\n2.  Since the current price is equal to the upper price, we have\n\nsolidity\n_liquidity = mintParams.amount1Desired * (1 << 96) // (priceUpper priceLower)\n    = 4731732988155153573010127839\n\n3.  The amounts of token0 and token1 that the attacker has to pay is\n\nsolidity\namount0Actual = 0\namount1Actual = uint128(DyDxMath.getDy(_liquidity, priceLower, priceUpper, true))\n    = uint128(_liquidity * (priceUpper priceLower) // (1 << 96)) # round up\n    = uint128(340282366920938463463374607384226905622)\n    = 340282366920938463463374607384226905622\n    = (1 << 128) 47541305834\n\n4.  As long as reserve1 is greater than 47541305834, the addition amount1Actual + reserve1 overflows to a small number, causing the attacker to pass the balance check.\n\nReferenced code:\nConcentratedLiquidityPool.sol#L204(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L204)\nConcentratedLiquidityPool.sol#L209(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L209)\n\n",
                "Repair": "Consider removing the unchecked statement to check for integer overflow or casting both amount1Actual and reserve1 to type uint256 before adding them and comparing to the _balance(token).\n\nsarangparikh22 (Sushi) disputed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/84#issuecomment-954231077):\n  The example is wrong, you can't add use upper tick as odd, correct the example and resubmit please.\n\n\n"
            },
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\nmintParams.lower = 100000\nmintParams.upper = 500000\nmintParams.amount1Desired = (1 << 128) + 71914955423 # a carefully chosen number\nmintParams.amount0Desired = 0\n",
                    "//solidity\n_liquidity = mintParams.amount1Desired * (1 << 96) // (priceUpper priceLower)\n    = 4731732988155153573010127840\n",
                    "//solidity\namount0Actual = 0\namount1Actual = uint128(DyDxMath.getDy(_liquidity, priceLower, priceUpper, true))\n    = uint128(_liquidity * (priceUpper priceLower) // (1 << 96)) # round up\n    = uint128(340282366920938463463374607456141861046)             # exceed the max\n    = 24373649590                                                  # truncated\n"
                ],
                "Type": " Incorrect usage of typecasting in  _getAmountsForLiquidity  lets an attacker steal funds from the pool",
                "Description": "\nThe _getAmountsForLiquidity function of ConcentratedLiquidityPool explicitly converts the result of DyDxMath.getDy and DyDxMath.getDx from type uint256 to type uint128. The explicit casting without checking whether the integer exceeds the maximum number (i.e., type(uint128).max) could cause incorrect results being used. Specifically, an attacker could exploit this bug to mint a large amount of liquidity but only pay a little of token0 or token1 to the pool and effectively steal other's funds when burning his liquidity.\n\n1.  Suppose that the current price is at the tick 500000, an attacker calls the mint function with the following parameters:\n\nsolidity\nmintParams.lower = 100000\nmintParams.upper = 500000\nmintParams.amount1Desired = (1 << 128) + 71914955423 # a carefully chosen number\nmintParams.amount0Desired = 0\n\n2.  Since the current price is equal to the upper price, we have\n\nsolidity\n_liquidity = mintParams.amount1Desired * (1 << 96) // (priceUpper priceLower)\n    = 4731732988155153573010127840\n\n3.  The amounts of token0 and token1 that the attacker has to pay is\n\nsolidity\namount0Actual = 0\namount1Actual = uint128(DyDxMath.getDy(_liquidity, priceLower, priceUpper, true))\n    = uint128(_liquidity * (priceUpper priceLower) // (1 << 96)) # round up\n    = uint128(340282366920938463463374607456141861046)             # exceed the max\n    = 24373649590                                                  # truncated\n\n4.  The attacker only pays 24373649590 of token1 to get 4731732988155153573010127840 of the liquidity, which he could burn to get more token1. As a result, the attacker is stealing the funds from the pool and could potentially drain it.\n\nReferenced code:\nConcentratedLiquidityPool.sol#L480(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L480)\nconcentratedPool/DyDxMath.sol#L15(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/DyDxMath.sol#L15)\nconcentratedPool/DyDxMath.sol#L30(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/DyDxMath.sol#L30)\n\n",
                "Repair": "Check whether the result of DyDxMath.getDy or DyDxMath.getDx exceeds type(uint128).max or not. If so, then revert the transaction. Or consider using the SafeCast library(https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast) from OpenZeppelin instead.\n\nsarangparikh22 (Sushi) disputed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/83#issuecomment-954233068):\n  The example is wrong, you can't add use upper tick as odd, correct the example and resubmit please.\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/83#issuecomment-967016368):\n  @sarangparikh22 (Sushi), could you confirm whether the casting to uint128 is known to be safe? Are you unconvinced of the issue?\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/83#issuecomment-970807633):\n  @alcueca (judge) I can confirm casting to uint128 is not safe, and will lead to overflow. However, the example mentioned is wrong.\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/83#issuecomment-972587273):\n  Understood. I will uphold the severity 3 because the overflow happens in a critical function for the management of funds and an incorrect execution will likely lead to loss of funds.\n\n\n"
            },
            {
                "Name": "H-06",
                "Location": [],
                "Type": "  ConcentratedLiquidityPosition.sol#collect()  Users may get double the amount of yield when they call  collect()  before  burn() ",
                "Description": "\nWhen a user calls ConcentratedLiquidityPosition.sol#collect() to collect their yield, it calcuates the yield based on position.pool.rangeFeeGrowth() and position.feeGrowthInside0, position.feeGrowthInside1:\n\nConcentratedLiquidityPosition.sol#L75 L101(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L75-L101)\n\nWhen there are enough tokens in bento.balanceOf, it will not call position.pool.collect() to collect fees from the pool.\n\nThis makes the user who collect() their yield when there is enough balance to get double yield when they call burn() to remove liquidity. Because burn() will automatically collect fees on the pool contract.\n\nThe yield belongs to other users will be diluted.\n\n",
                "Repair": "Consider making ConcentratedLiquidityPosition.sol#burn() call position.pool.collect() before position.pool.burn(). User will need to call ConcentratedLiquidityPosition.sol#collect() to collect unclaimed fees after burn().\n\nOr ConcentratedLiquidityPosition.sol#collect() can be changed into a public method and ConcentratedLiquidityPosition.sol#burn() can call it after position.pool.burn().\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/53)\n\n\n"
            },
            {
                "Name": "H-07",
                "Location": [],
                "Type": "  ConcentratedLiquidityPosition.sol#burn()  Wrong implementation allows attackers to steal yield",
                "Description": "\nWhen a user calls ConcentratedLiquidityPosition.sol#burn() to burn their liquidity, it calls ConcentratedLiquidityPool.sol#burn() - _updatePosition():\n\nConcentratedLiquidityPool.sol#L525 L553(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L525-L553)\n\nThe _updatePosition() function will return amount0fees and amount1fees of the whole position with the lower and upper tick and send them to the recipient alongside the burned liquidity amounts.\n\n1.  Alice minted $10000 worth of liquidity with lower and upper tick set to 99 and 199;\n2.  Alice accumulated $1000 worth of fee in token0 and token1;\n3.  The attacker can mint a small amount ($1 worth) of liquidity using the same lower and upper tick;\n4.  The attacker calls ConcentratedLiquidityPosition.sol#burn() to steal all the unclaimed yield with the ticks of (99, 199) include the $1000 worth of yield from Alice.\n\n",
                "Repair": "Consider making ConcentratedLiquidityPosition.sol#burn() always use address(this) as recipient in:\n\nsolidity\nposition.pool.burn(abi.encode(position.lower, position.upper, amount, recipient, unwrapBento));\n\n\nand transfer proper amounts to the user.\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/52)\n\n\n"
            },
            {
                "Name": "H-08",
                "Location": [],
                "Type": " Wrong inequality when adding/removing liquidity in current price range",
                "Description": "\nThe ConcentratedLiquidityPool.mint/burn functions add/remove liquidity when (priceLower < currentPrice && currentPrice < priceUpper).\nShouldn't it also be changed if priceLower == currentPrice?\n\nPools that mint/burn liquidity at a time where the currentPrice is right at the lower price range do not work correctly and will lead to wrong swap amounts.\n\n",
                "Repair": "Change the inequalities to if (priceLower <= currentPrice && currentPrice < priceUpper).\n\nsarangparikh22 (Sushi) disputed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/34#issuecomment-942790793):\n  You shouldn't be able to reach this, can you produce a POC?\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/34#issuecomment-967792671):\n  @sarangparikh22 (Sushi), could you please elaborate on why this is not reachable?\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/34#issuecomment-970749777):\n  I confused this with another similar issue, my apologies, took a look at this, and this a valid issue, we should probably even bump the severity to Sev 3, not sure if I am allowed to do so haha, I created a PoC in which users can actually loose funds, when they add liquidity in that specific range. @alcueca (judge)\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/34#issuecomment-972590913):\n  Sponsors are allowed to bump up severity, and I've done it myself in my past as a sponsor as well.\n\n\n"
            },
            {
                "Name": "H-09",
                "Location": [
                    "//solidity\n    feeGrowthInside0 = _feeGrowthGlobal0 feeGrowthBelow0 feeGrowthAbove0;\n    feeGrowthInside1 = _feeGrowthGlobal1 feeGrowthBelow1 feeGrowthAbove1;\n",
                    "python\n    # This is the wrapper.\n    # def add_liquidity(pool, amount, lower, upper)\n    # def swap(pool, buy, amount)\n\n    add_liquidity(pool, deposit_amount, -800, 500)\n    add_liquidity(pool, deposit_amount, 400, 700)\n    # We cross the tick here to trigger the bug.\n\n    swap(pool, False, deposit_amount)\n    # Only tick 700's feeGrowthOutside1 is updated\n\n    swap(pool, True, deposit_amount)\n    # Only tick 500's feeGrowthOutside0 is updated\n\n    # current tick at -800\n\n    # this would revert\n    # feeGrowthBelow1 = feeGrowthGlobal1\n    # feeGrowthGlobal1 feeGrowthBelow1 feeGrowthAbove1 would revert\n    # user would not be able to mint/withdraw/cross this tick. The pool is broken\n    add_liquidity(pool, deposit_amount, 400, 700)\n"
                ],
                "Type": " range fee growth underflow",
                "Description": "\nThe function RangeFeeGrowth ([ConcentratedLiquidityPool.sol#L601-L633(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L601-L633)) would revert the transaction in some cases.\n\nWhen a pool cross a tick, it only updates either feeGrowthOutside0 or feeGrowthOutside1. Ticks.sol#L23-L53(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/Ticks.sol#L23-L53)\n\nRangeFeeGrowth calculates the fee as follow:\n\nsolidity\n    feeGrowthInside0 = _feeGrowthGlobal0 feeGrowthBelow0 feeGrowthAbove0;\n    feeGrowthInside1 = _feeGrowthGlobal1 feeGrowthBelow1 feeGrowthAbove1;\n\n\nfeeGrowthBelow + feeGrowthAbove is not necessary smaller than _feeGrowthGlobal. Please see POC.\n\nUsers can not provide liquidity or burn liquidity. Fund will get stocked in the contract. I consider this is a high-risk issue.\n\npython\n    # This is the wrapper.\n    # def add_liquidity(pool, amount, lower, upper)\n    # def swap(pool, buy, amount)\n\n    add_liquidity(pool, deposit_amount, -800, 500)\n    add_liquidity(pool, deposit_amount, 400, 700)\n    # We cross the tick here to trigger the bug.\n\n    swap(pool, False, deposit_amount)\n    # Only tick 700's feeGrowthOutside1 is updated\n\n    swap(pool, True, deposit_amount)\n    # Only tick 500's feeGrowthOutside0 is updated\n\n    # current tick at -800\n\n    # this would revert\n    # feeGrowthBelow1 = feeGrowthGlobal1\n    # feeGrowthGlobal1 feeGrowthBelow1 feeGrowthAbove1 would revert\n    # user would not be able to mint/withdraw/cross this tick. The pool is broken\n    add_liquidity(pool, deposit_amount, 400, 700)\n\n\nHardhat\n\n",
                "Repair": "It's either modify the tick's algo or RangeFeeGrowth. The quick-fix I come up with is to deal with the fee in RangeFeeGrowth. However, I recommend the team to go through tick's logic again.\n\nsarangparikh22 (Sushi) disputed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/25#issuecomment-942800266):\n  The example is wrong, you can't add use upper tick as odd, correct the example and resubmit please.\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/25#issuecomment-967128882):\n  @sarangparikh22 (Sushi), is the example invalid, or the whole issue? Is this something that you would consider fixing?\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/25#issuecomment-972242461):\n  @alcueca (judge) The example is invalid, but the issue is valid, the fix is to swap the condition of feeGrowthGlobal\n\n\n"
            },
            {
                "Name": "H-10",
                "Location": [],
                "Type": "  ConcentratedLiquidityPool.burn()  Wrong implementation",
                "Description": "\nThe reserves should be updated once LP tokens are burned to match the actual total bento shares hold by the pool.\n\nHowever, the current implementation only updated reserves with the fees subtracted.\n\nMakes the reserve0 and reserve1 smaller than the current balance0 and balance1.\n\nAs a result, many essential features of the contract will malfunction, includes swap() and mint().\n\n",
                "Repair": "\nConcentratedLiquidityPool.sol#L263 L267(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L263-L267)\nChange:\n\nsolidity\nunchecked {\n    reserve0 -= uint128(amount0fees);\n    reserve1 -= uint128(amount1fees);\n}\n\n\n\nto:\nsolidity\nunchecked {\n    reserve0 -= uint128(amount0);\n    reserve1 -= uint128(amount1);\n}\n\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/24)\n\n\n"
            },
            {
                "Name": "H-11",
                "Location": [
                    "jsx\nif (zeroForOne) {\n\t...\n\tticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal ticks[nextTickToCross].feeGrowthOutside0;\n} else {\n\t...\n\tticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal ticks[nextTickToCross].feeGrowthOutside1;\n}\n"
                ],
                "Type": " ConcentratedLiquidityPool: incorrect  feeGrowthGlobal  accounting when crossing ticks",
                "Description": "\nSwap fees are taken from the output. Hence, if swapping token0 for token1 (zeroForOne is true), then fees are taken in token1. We see this to be the case in the initialization of feeGrowthGlobal in the swap cache\n\nfeeGrowthGlobal = zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0;\n\nand in _updateFees().\n\nHowever, looking at Ticks.cross(), the logic is the reverse, which causes wrong fee accounting.\n\njsx\nif (zeroForOne) {\n\t...\n\tticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal ticks[nextTickToCross].feeGrowthOutside0;\n} else {\n\t...\n\tticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal ticks[nextTickToCross].feeGrowthOutside1;\n}\n\n\n",
                "Repair": "Switch the 0 and 1 in Ticks.cross().\n\njsx\nif (zeroForOne) {\n\t...\n\t// feeGrowthGlobal = feeGrowthGlobal1\n\tticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal ticks[nextTickToCross].feeGrowthOutside1;\n} else {\n\t...\n\t// feeGrowthGlobal = feeGrowthGlobal0\n\tticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal ticks[nextTickToCross].feeGrowthOutside0;\n}\n\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/16)\n\n\n"
            },
            {
                "Name": "H-12",
                "Location": [],
                "Type": "  ConcentratedLiquidityPool :  secondsPerLiquidity  should be modified whenever pool liquidity changes",
                "Description": "\nsecondsPerLiquidity is updated as such: secondsPerLiquidity += uint160((diff << 128) / liquidity); where diff = timestamp uint256(lastObservation). Hence, whenever liquidity changes, secondsPerLiquidity should be updated prior to the change.\n\nIn particular, this affects the mint() and burn() functions, in the case where liquidity changes when lowerTick <= currentTick < upperTick.\n\nIn fact, the latest secondsPerLiquidity value should be calculated and used in Ticks.insert(). For comparison, notice how UniswapV3 fetches the latest value by calling observations.observeSingle() in its _updatePosition() function.\n\n",
                "Repair": "The secondsPerLiquidity increment logic should be applied prior to liquidity addition in mint() and removal in burn().\n\njsx\n// insert logic before these lines in mint()\nunchecked {\n  if (priceLower < currentPrice && currentPrice < priceUpper) liquidity += uint128(_liquidity);\n}\n\nnearestTick = Ticks.insert(\nticks,\nfeeGrowthGlobal0,\nfeeGrowthGlobal1,\nsecondsPerLiquidity, // should calculate and use latest secondsPerLiquidity value\n    ...\n);\n\n// insert logic before before these lines in burn()\nunchecked {\n  if (priceLower < currentPrice && currentPrice < priceUpper) liquidity -= amount;\n}\n\n\nsarangparikh22 (Sushi) disputed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/15#issuecomment-954274917):\n  The secondsPerLiquidity is same, changing the order of that will not affect anything, since it is not getting calculated at the mint or burn function.\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/15#issuecomment-967159284):\n  @sarangparikh22 (Sushi), could you please elaborate on why this isn't an issue?\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/15#issuecomment-970862817):\n  @alcueca (judge) my apologies, this is an issue. I could confirm this.\n\n\n"
            },
            {
                "Name": "H-13",
                "Location": [
                    "//solidity\nunchecked {\n    // @audit decreases by fees only, not by amount0/amount1\n    reserve0 -= uint128(amount0fees);\n    reserve1 -= uint128(amount1fees);\n}\n"
                ],
                "Type": " Burning does not update reserves",
                "Description": "\nThe ConcentratedLiquidityPool.burn function sends out amount0/amount1 tokens but only updates the reserves by decreasing it by the fees of these amounts.\n\nsolidity\nunchecked {\n    // @audit decreases by fees only, not by amount0/amount1\n    reserve0 -= uint128(amount0fees);\n    reserve1 -= uint128(amount1fees);\n}\n\n\nThis leads to the pool having wrong reserves after any burn action.\nThe pool's balance will be much lower than the reserve variables.\n\nAs the pool's actual balance will be much lower than the reserve variables, minting and swaping will not work correctly either.\nThis is because of the amount0Actual + reserve0 <= _balance(token0) check in mint using a much higher reserve0 amount than the actual balance (already including the transferred assets from the user). An LP provider will have to make up for the missing reserve decrease from burn and pay more tokens.\n\nThe same holds true for swap which performs the same check in _updateReserves.\n\nThe pool essentially becomes unusable after a burn as LPs / traders need to pay more tokens.\n\n",
                "Repair": "The reserve should be decreased by what is transferred out. In burn's case this is amount0 / amount1.\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/51)\n\n\n"
            },
            {
                "Name": "H-14",
                "Location": [],
                "Type": "  ConcentratedLiquidityPool :  rangeFeeGrowth  and  secondsPerLiquidity  math needs to be unchecked",
                "Description": "\nThe fee growth mechanism, and by extension, secondsPerLiquidity mechanism of Uniswap V3 has the ability to underflow. It is therefore a necessity for the math to (ironically) be unsafe / unchecked.\n\n\nAssume the following scenario and initial conditions:\n\n*   Price at parity (nearestTick is 0)\n*   tickSpacing of 10\n*   Swaps only increase the price (nearestTick moves up only)\n*   feeGrowthGlobal initializes with 0, increases by 1 for every tick moved for simplicity\n*   Existing positions that provide enough liquidity and enable nearestTick to be set to values in the example\n*   Every tick initialized in the example is \u2264 nearestTick, so that its feeGrowthOutside = feeGrowthGlobal\n\n1.  When nearestTick is at 40, Alice creates a position for uninitialised ticks [-20, 30]. The ticks are initialized, resulting in their feeGrowthOutside values to be set to 40.\n2.  nearestTick moves to 50. Bob creates a position with ticks [20, 30] (tick 20 is uninitialised, 30 was initialized from Alice's mint). tick 20 will therefore have a feeGrowthOutside of 50.\n3.  Let us calculate rangeFeeGrowth(20,30).\n    *   lowerTick = 20, upperTick = 30\n    *   feeGrowthBelow = 50 (lowerTick's feeGrowthOutside) since lowerTick < currentTick\n    *   feeGrowthAbove = 50 40 = 10 (feeGrowthGlobal upperTick's feeGrowthOutside) since upperTick < currentTick\n    *   feeGrowthInside\n\n        = feeGrowthGlobal feeGrowthBelow feeGrowthAbove\n\n        = 50 50 10\n\n        = -10\n\nWe therefore have negative feeGrowthInside.\n\nThis behaviour is actually acceptable, because the important thing about this mechanism is the relative values to each other, not the absolute values themselves.\n\n",
                "Repair": "rangeFeeGrowth() and rangeSecondsInside() has to be unchecked. In addition, the subtraction of feeGrowthInside values should also be unchecked in _updatePosition() and ConcentratedLiquidityPosition#collect().\n\nThe same also applies for the subtraction of pool.rangeSecondsInside and stake.secondsInsideLast in claimReward() and getReward() of the ConcentratedLiquidityPoolManager contract.\n\nsarangparikh22 (Sushi) disputed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/13#issuecomment-962142019):\n  Can you give more elaborate example.\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/13#issuecomment-967134083):\n  @sarangparikh22 (Sushi), I find the example quite elaborate. It shows an specific example in which underflow is desired, by comparing with other platform using similar mechanics. It explains that with your current implementation you can't have negative feeGrowthInside, which is a possible and acceptable scenario. Could you please elaborate on what your grounds are for disputing this finding?\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/13#issuecomment-972200918):\n  @alcueca (judge) Yes this a valid issue.\n\n\n"
            },
            {
                "Name": "H-15",
                "Location": [],
                "Type": "  ConcentratedLiquidityPool :  initialPrice  should be checked to be within allowable range",
                "Description": "\nNo check is performed for the initial price. This means that it can be set to be below the MIN_SQRT_RATIO or above MAX_SQRT_RATIO (Eg. zero value), which will prevent the usability of all other functions (minting, swapping, burning).\n\nFor example, Ticks.insert() would fail when attempting to calculate actualNearestTick = TickMath.getTickAtSqrtRatio(currentPrice);, which means no one will be able to mint positions.\n\n",
                "Repair": "Check the initialPrice is within the acceptable range, ie. MIN_SQRT_RATIO <= initialPrice <= MAX_SQRT_RATIO\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/11)\n\n\n"
            },
            {
                "Name": "H-16",
                "Location": [],
                "Type": " Possible attacks on Seconds * Liquidity calculation",
                "Description": "\nThis is a possible line of attack on the staking contract, in particular the claimReward() function: ConcentratedLiquidityPoolManager.sol#L90 L94(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L90-L94)\n\n1.  A user with some spare capital mints a liquidity position with a very tight range (1-2 ticks wide) at the current price. Because the range is so small, his position.liquidity on his NFT is large (DyDxMath.sol).\n\n2.  The user then sets up a bot to frontrun any price changes that someone else tries to do, burning his position after claiming rewards. He then mints a new liquidity position at the new price after the other persons trades go through.\n\n3.  Rinse and repeat this process. If done correctly, no funds are at risk from the bot owner, he doesn't pay any fees for burning/minting either.\n\nSo what you have left is a sequence of positions with high position.liquidity and in the correct price range all the time, without taking on any risk. Thereby stealing incentive funds.\n\nThe lines below reward the bot owner with a large amount of the token:\n\nConcentratedLiquidityPoolManager.sol#L90 L94(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L90-L94)\n",
                "Repair": "Recommendation:\n\nLock the positions during a set time while they are staked.\n\nsarangparikh22 (Sushi) disputed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/8#issuecomment-954283114):\n  This seems very unlikely to happen and does not affect the pool, it's equivalent to just re balancing your position.\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/8#issuecomment-967138536):\n  @sarangparikh22 (Sushi), Isn't the warden describing a Just In Time liquidity pattern?\n\nsarangparikh22 (Sushi) acknowledged(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/8#issuecomment-970872759):\n  @alcueca (judge) yes exactly, even done right, the bot would still face huge IL. We don't intend to solve this.\n\n\n"
            },
            {
                "Name": "H-17",
                "Location": [
                    "jsx\n// <--------------------------------------------------------------------------\n// MIN_TICK                                                               MAX_TICK\n",
                    "jsx\n// CASE 1\n// <--------------------|--------------------|\n// MIN_TICK         INIT_TICK            POOL_TICK\n// <-----------------------------------------|\n// MIN_TICK                        INIT_TICK = POOL_TICK\n\n// CASE 2\n//                                           |--------------------|----------------\n//                                       POOL_TICK           INIT_TICK          MAX_TICK\n",
                    "jsx\n    // ---------------------|---------------------|-----------------|-----------------\n    //                  POOL_TICK            LOWER_TICK          UPPER_TICK\n    // <---------------------------feeGrowthGlobal --------------------------------\n    //       LOWER_TICK.feeGrowthOutside (CASE 2) |----------------------------------\n    //                         UPPER_TICK.feeGrowthOutside (CASE 2) |----------------\n\n    // we want the range between LOWER_TICK and UPPER_TICK\n    // = LOWER_TICK.feeGrowthOutside UPPER_TICK.feeGrowthOutside\n\n    // alternatively, following the general formula, it is\n    // = feeGrowthGLobal fee growth below LOWER_TICK fee growth above UPPER_TICK\n    // = feeGrowthGlobal (feeGrowthGlobal LOWER_TICK.feeGrowthOutside) UPPER_TICK.feeGrowthOtuside\n    // = LOWER_TICK.feeGrowthOutside UPPER_TICK.feeGrowthOutside\n    ",
                    "jsx\n    // ---------------------|---------------------|-----------------|-----------------\n    //                  LOWER_TICK            POOL_TICK        UPPER_TICK\n    // <---------------------------feeGrowthGlobal --------------------------------\n    // <--------------------| LOWER_TICK's feeGrowthOutside (CASE 1)\n    //                       UPPER_TICK's feeGrowthOutside (CASE 2) |----------------\n\n    // we want the range between LOWER_TICK and UPPER_TICK\n    // = feeGrowthGLobal fee growth below LOWER_TICK fee growth above UPPER_TICK\n    // = feeGrowthGLobal LOWER_TICK.feeGrowthOutside UPPER_TICK.feeGrowthOutside\n    ",
                    "jsx\n    // ---------------------|---------------------|-----------------|-----------------\n    //                  LOWER_TICK            POOL_TICK        UPPER_TICK\n    // <---------------------------feeGrowthGlobal --------------------------------\n    // <--------------------| LOWER_TICK's feeGrowthOutside (CASE 1)\n    // <------------------------------------------------------------| UPPER_TICK's feeGrowthOutside (CASE 1)\n\n    // we want the range between LOWER_TICK and UPPER_TICK\n    // = UPPER_TICK.feeGrowthOutside LOWER_TICK.feeGrowthOutside\n\n    // alternatively, following the general formula, it is\n    // = feeGrowthGLobal fee growth below LOWER_TICK fee growth above UPPER_TICK\n    // = feeGrowthGLobal LOWER_TICK.feeGrowthOutside (feeGrowthGlobal UPPER_TICK.feeGrowthOutside)\n    // = UPPER_TICK.feeGrowthOutside LOWER_TICK.feeGrowthOutside\n    "
                ],
                "Type": " Understanding the fee growth mechanism (why  nearestTick  is unsuitable)",
                "Description": "\nUniswap V3's whitepaper describes the fee growth mechanism, but the intuition behind it is not explained well (IMO). I've not been able to find any material that tries to describe it, so allow me the luxury of doing so. It is crucial to understand how it works, so that other issues regarding the fee growth variables (and by extension, secondsPerLiquidity) raised by fellow wardens / auditors are better understood by readers.\n\nWe want a way to accurately track the fees accumulated by a position. Fees should only be given to the position it is active (the current tick / price is within the lower and upper ticks of the position).\n\n\nDefined as the total amount of fees that would have been earned by 1 unit of unbounded liquidity that was deposited when the contract was first initialized. For simplicity, we can take this to be the range between MIN_TICK and MAX_TICK. We represent it visually like this:\n\njsx\n// <--------------------------------------------------------------------------\n// MIN_TICK                                                               MAX_TICK\n\n\n\nThe fee growth per unit of liquidity on the *other* side of this tick (relative to the current tick). What does this mean?\n\nAs defined, it is the fee growth relative to the current tick. Based on the convention, we define 2 cases:\n\n*   Case 1: initialized tick \u2264 pool tick\n*   Case 2: Initialized tick  pool tick\n\nVisually, the feeGrowthOutside will look like this:\n\njsx\n// CASE 1\n// <--------------------|--------------------|\n// MIN_TICK         INIT_TICK            POOL_TICK\n// <-----------------------------------------|\n// MIN_TICK                        INIT_TICK = POOL_TICK\n\n// CASE 2\n//                                           |--------------------|----------------\n//                                       POOL_TICK           INIT_TICK          MAX_TICK\n\n\nHence, regardless of whether the tick to initialize is either a lower or upper tick of a position, the feeGrowthOutside value that it is referring to is relatve to the pool tick.\n\nIn other words, if initialized tick \u2264 pool tick, then its feeGrowthOutside is towards MIN_TICK. Otherwise, its feeGrowthOutside is towards MAX_TICK.\n\n\nBy convention, when a tick is initialized, all fee growth is assumed to happen below it. Hence, the feeGrowthOutside is initialized to the following values:\n\n*   Case 1: tick's feeGrowthOutside = feeGrowthGlobal\n*   Case 2: tick's feeGrowthOtuside = 0\n\n\nOne should now understand why the feeGrowthOutside value is being flipped when crossing a tick, ie. tick.feeGrowthOutside = feeGrowthGlobal tick.feeGrowthOutside in Tick.cross(), because it needs to follow the definition. (Case 1 becomes case 2 and vice versa).\n\nIt should hopefully become clear why using nearestTick as the reference point for fee growth calculations instead of the pool tick might not a wise choice. (Case 1 and 2 becomes rather ambiguous).\n\n\nGoing back to our objective of calculating the fee growth accumulated for a position, we can break it down into 3 cases (take caution with the boundary cases), and understand how their values are calculated. In general, we take it to be feeGrowthGlobal fee growth below lower tick fee growth above upper tick (see illustrations), although it can be simplified further.\n\n1.  pool tick < lower tick\n\n    jsx\n    // ---------------------|---------------------|-----------------|-----------------\n    //                  POOL_TICK            LOWER_TICK          UPPER_TICK\n    // <---------------------------feeGrowthGlobal --------------------------------\n    //       LOWER_TICK.feeGrowthOutside (CASE 2) |----------------------------------\n    //                         UPPER_TICK.feeGrowthOutside (CASE 2) |----------------\n\n    // we want the range between LOWER_TICK and UPPER_TICK\n    // = LOWER_TICK.feeGrowthOutside UPPER_TICK.feeGrowthOutside\n\n    // alternatively, following the general formula, it is\n    // = feeGrowthGLobal fee growth below LOWER_TICK fee growth above UPPER_TICK\n    // = feeGrowthGlobal (feeGrowthGlobal LOWER_TICK.feeGrowthOutside) UPPER_TICK.feeGrowthOtuside\n    // = LOWER_TICK.feeGrowthOutside UPPER_TICK.feeGrowthOutside\n    \n\n2.  lower tick \u2264 pool tick < upper tick\n\n    jsx\n    // ---------------------|---------------------|-----------------|-----------------\n    //                  LOWER_TICK            POOL_TICK        UPPER_TICK\n    // <---------------------------feeGrowthGlobal --------------------------------\n    // <--------------------| LOWER_TICK's feeGrowthOutside (CASE 1)\n    //                       UPPER_TICK's feeGrowthOutside (CASE 2) |----------------\n\n    // we want the range between LOWER_TICK and UPPER_TICK\n    // = feeGrowthGLobal fee growth below LOWER_TICK fee growth above UPPER_TICK\n    // = feeGrowthGLobal LOWER_TICK.feeGrowthOutside UPPER_TICK.feeGrowthOutside\n    \n\n3.  upper tick \u2264 pool tick\n\n    jsx\n    // ---------------------|---------------------|-----------------|-----------------\n    //                  LOWER_TICK            POOL_TICK        UPPER_TICK\n    // <---------------------------feeGrowthGlobal --------------------------------\n    // <--------------------| LOWER_TICK's feeGrowthOutside (CASE 1)\n    // <------------------------------------------------------------| UPPER_TICK's feeGrowthOutside (CASE 1)\n\n    // we want the range between LOWER_TICK and UPPER_TICK\n    // = UPPER_TICK.feeGrowthOutside LOWER_TICK.feeGrowthOutside\n\n    // alternatively, following the general formula, it is\n    // = feeGrowthGLobal fee growth below LOWER_TICK fee growth above UPPER_TICK\n    // = feeGrowthGLobal LOWER_TICK.feeGrowthOutside (feeGrowthGlobal UPPER_TICK.feeGrowthOutside)\n    // = UPPER_TICK.feeGrowthOutside LOWER_TICK.feeGrowthOutside\n    \n\n\nAn under appreciated, but very critical line of Uniswap V3's pool contract is the following:\n\nstate.tick = zeroForOne ? step.tickNext 1 : step.tickNext;\n\nIt serves a dual purpose:\n\n1.  Because of how Tick Bitmap works, the tick needs to be manually decremented by 1 so that the next tick to be found is in the next word.\n2.  More importantly, it handles the boundary case, where zeroForOne is true (pool tick goes down). In this scenario, case 1 becomes case 2 when the tick is crossed. However, should the poolTick after the swap be equal to step.tickNext, then when calculating fee growth inside a position that so happens to have step.tickNext as one of its ticks, it will be treated as case 1 (poolTick = lowerTick / upperTick) when it is required to be treated as case 2.\n\nHopefully, this writeup helps readers understand the fee growth mechanism and its workings. More importantly, I hope it helps the team to understand why using nearestTick as the reference point for fee growth mechanism is unsuitable. Specifically, we have 2 high severity issues:\n\n*   Wrong initialization value of feeGrowthOutside in the case either the lower or upper tick becomes the nearestTick upon insertion of a new tick.\n    *   You are (in a sense) crossing the old nearestTick, so its secondsPerLiquidityOutside has to be flipped\n    *   The lower / upper tick's feeGrowthOutside is incorrectly initialized to be 0 when it should be feeGrowthOutside\n*   Case 1 and 2 becomes ambiguous. When a position is modified with either tick being nearestTick, it is treated to be case 1 when in fact there are times it should be treated as case 2.\n\n",
                "Repair": "Having a pool tick counter that closely matches the current pool price is rather critical for fee growth and seconds per liquidity initializations / calculations.\n\nWhere relevant, the nearestTick should be replaced by poolTick.\n\nsarangparikh22 (Sushi) acknowledged(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/1)\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [],
                "Type": " Incentive should check that it hasn't started yet",
                "Description": "\nThe ConcentratedLiquidityPoolManager.addIncentive function can add an incentive that already has a non-zero incentive.secondsClaimed.\n\nRewards will be wrong.\n\n",
                "Repair": "Add a check: require(incentive.secondsClaimed == 0, \"!secondsClaimed\").\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/42)\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/42#issuecomment-966994095):\n  Assets are at risk after a wrong governance action. Severity 2.\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [],
                "Type": " Cannot claim reward",
                "Description": "\nThe ConcentratedLiquidityPoolManager.claimReward requires stake.initialized but it is never set.\nIt also performs a strange computation as 128 incentive.secondsClaimed which will almost always underflow and revert the transaction.\n\nOne cannot claim rewards.\n\n",
                "Repair": "Rethink how claiming rewards should work.\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/41)\n\n\n"
            },
            {
                "Name": "M-03",
                "Location": [],
                "Type": "  ConcentratedLiquidityPoolHelper :  getTickState()  might run out of gas",
                "Description": "\ngetTickState() attempts to fetch the state of all inserted ticks (including MIN_TICK and MAX_TICK) of a pool. Depending on the tick spacing, this function may run out of gas.\n\n",
                "Repair": "Have a starting index parameter to start the iteration from. Also, tickCount can be made use of more meaningfully to limit the number of iterations performed.\n\njsx\nfunction getTickState(\n\tIConcentratedLiquidityPool pool,\n\tint24 startIndex,\n\tuint24 tickCount\n) external view returns (SimpleTick[] memory) {\n  SimpleTick[] memory ticks = new SimpleTick[(tickCount);\n\n  IConcentratedLiquidityPool.Tick memory tick;\n\tint24 current = startIndex;\n\n\tfor (uint24 i; i < tickCount; i++) {\n\t\ttick = pool.ticks(current);\n\t\tticks[i] = SimpleTick({index: current, liquidity: tick.liquidity});\n\t\t// reached end of linked list, exit loop\n\t\tif (current == TickMath.MAX_TICK) break;\n\t\t// else, continue with next iteration\n\t\tcurrent = tick.nextTick;\n\t}\n\n  return ticks;\n}\n\n\nsarangparikh22 (Sushi) acknowledged(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/17)\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/17#issuecomment-967004172):\n  Functionality is affected, severity 2.\n\n\n"
            },
            {
                "Name": "M-04",
                "Location": [],
                "Type": " Users cannot receive rewards from  ConcentratedLiquidityPoolManager  if their liquidity is too large",
                "Description": "\nThere could be an integer underflow error when the reward of an incentive is claimed, forcing users to wait for a sufficient period or reduce their liquidity to claim the rewards.\n\nThe unclaimed reward that a user could claim is proportional to the secondsInside, which is, in fact, proportional to the position's liquidity. It is possible that the liquidity is too large and causes secondsInside to be larger than secondsUnclaimed. As a result, the rewards that the user wants to claim exceed the incentive.rewardsUnclaimed and causes an integer underflow error, which prevents him from getting the rewards.\n\nReferenced code:\nConcentratedLiquidityPoolManager.sol#L94-L95(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L94-L95)\n\n",
                "Repair": "Check whether the rewards exceeds the incentive.rewardsUnclaimed. If so, then send only incentive.rewardsUnclaimed amount of rewards to the user.\n\nsarangparikh22 (Sushi) acknowledged(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/88#issuecomment-942705593):\n  The problem seems very unlikely to happen, would be great to see a POC.\n\n\n"
            },
            {
                "Name": "M-05",
                "Location": [],
                "Type": "  TridentNFT.permit  should always check  recoveredAddress != 0 ",
                "Description": "\nThe TridentNFT.permit function ignores the recoveredAddress != 0 check if isApprovedForAll[owner][recoveredAddress] is true.\n\nIf a user accidentally set the zero address as the operator, tokens can be stolen by anyone as a wrong signature yield recoveredAddress == 0.\n\n",
                "Repair": "Change the require logic to recoveredAddress != address(0) && (recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress]).\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/44)\n\nalcueca (judge) commented(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/44#issuecomment-966992097):\n  Assets are not at direct risk, but they are at risk. It wouldn't be obvious to anyone that setting the zero address to the operator would lead to loss of assets. Severity 2.\n\n\n"
            },
            {
                "Name": "M-06",
                "Location": [
                    "//solidity\nuint256 balance0 = bento.balanceOf(token0, address(this));\nuint256 balance1 = bento.balanceOf(token1, address(this));\nif (balance0 < token0amount || balance1 < token1amount) {\n    (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);\n\n    uint256 newBalance0 = amount0fees + balance0;\n    uint256 newBalance1 = amount1fees + balance1;\n\n    /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw\n    if (token0amount  newBalance0) token0amount = newBalance0;\n    if (token1amount  newBalance1) token1amount = newBalance1;\n}\n_transfer(token0, address(this), recipient, token0amount, unwrapBento);\n_transfer(token1, address(this), recipient, token1amount, unwrapBento);\n\n",
                    "//solidity\nfunction claimReward(\n    uint256 positionId,\n    uint256 incentiveId,\n    address recipient,\n    bool unwrapBento\n) public {\n    require(ownerOf[positionId] == msg.sender, \"OWNER\");\n    Position memory position = positions[positionId];\n    IConcentratedLiquidityPool pool = position.pool;\n    Incentive storage incentive = incentives[position.pool][positionId];\n    Stake storage stake = stakes[positionId][incentiveId];\n    require(stake.initialized, \"UNINITIALIZED\");\n    uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) stake.secondsInsideLast;\n    uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;\n    uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n    uint256 secondsUnclaimed = (maxTime incentive.startTime) << (128 incentive.secondsClaimed);\n    uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n    incentive.rewardsUnclaimed -= rewards;\n    incentive.secondsClaimed += uint160(secondsInside);\n    stake.secondsInsideLast += uint160(secondsPerLiquidityInside);\n    _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);\n    emit ClaimReward(positionId, incentiveId, recipient);\n}\n",
                    "//solidity\nfunction reclaimIncentive(\n    IConcentratedLiquidityPool pool,\n    uint256 incentiveId,\n    uint256 amount,\n    address receiver,\n    bool unwrapBento\n) public {\n    Incentive storage incentive = incentives[pool][incentiveId];\n    require(incentive.owner == msg.sender, \"NOT_OWNER\");\n    require(incentive.expiry < block.timestamp, \"EXPIRED\");\n    require(incentive.rewardsUnclaimed = amount, \"ALREADY_CLAIMED\");\n    _transfer(incentive.token, address(this), receiver, amount, unwrapBento);\n    emit ReclaimIncentive(pool, incentiveId);\n}\n"
                ],
                "Type": " ConcentratedLiquidityPoolManager.sol  claimReward()  and  reclaimIncentive()  will fail when  incentive.token  is  token0  or  token1 ",
                "Description": "\nIn ConcentratedLiquidityPosition.collect(), balances of token0 and token1 in bento will be used to pay the fees.\n\nConcentratedLiquidityPosition.sol#L103 L116(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L103-L116)\n\nsolidity\nuint256 balance0 = bento.balanceOf(token0, address(this));\nuint256 balance1 = bento.balanceOf(token1, address(this));\nif (balance0 < token0amount || balance1 < token1amount) {\n    (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);\n\n    uint256 newBalance0 = amount0fees + balance0;\n    uint256 newBalance1 = amount1fees + balance1;\n\n    /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw\n    if (token0amount  newBalance0) token0amount = newBalance0;\n    if (token1amount  newBalance1) token1amount = newBalance1;\n}\n_transfer(token0, address(this), recipient, token0amount, unwrapBento);\n_transfer(token1, address(this), recipient, token1amount, unwrapBento);\n\n\n\nIn the case of someone add an incentive with token0 or token1, the incentive in the balance of bento will be used to pay fees until the balance is completely consumed.\n\nAs a result, when a user calls claimReward(), the contract may not have enough balance to pay (it supposed to have it), cause the transaction to fail.\n\nConcentratedLiquidityPoolManager.sol#L78 L100(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L78-L100)\nsolidity\nfunction claimReward(\n    uint256 positionId,\n    uint256 incentiveId,\n    address recipient,\n    bool unwrapBento\n) public {\n    require(ownerOf[positionId] == msg.sender, \"OWNER\");\n    Position memory position = positions[positionId];\n    IConcentratedLiquidityPool pool = position.pool;\n    Incentive storage incentive = incentives[position.pool][positionId];\n    Stake storage stake = stakes[positionId][incentiveId];\n    require(stake.initialized, \"UNINITIALIZED\");\n    uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) stake.secondsInsideLast;\n    uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;\n    uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;\n    uint256 secondsUnclaimed = (maxTime incentive.startTime) << (128 incentive.secondsClaimed);\n    uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n    incentive.rewardsUnclaimed -= rewards;\n    incentive.secondsClaimed += uint160(secondsInside);\n    stake.secondsInsideLast += uint160(secondsPerLiquidityInside);\n    _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);\n    emit ClaimReward(positionId, incentiveId, recipient);\n}\n\nThe same issue applies to reclaimIncentive() as well.\nConcentratedLiquidityPoolManager.sol L49 L62(https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L49-L62)\n\nsolidity\nfunction reclaimIncentive(\n    IConcentratedLiquidityPool pool,\n    uint256 incentiveId,\n    uint256 amount,\n    address receiver,\n    bool unwrapBento\n) public {\n    Incentive storage incentive = incentives[pool][incentiveId];\n    require(incentive.owner == msg.sender, \"NOT_OWNER\");\n    require(incentive.expiry < block.timestamp, \"EXPIRED\");\n    require(incentive.rewardsUnclaimed = amount, \"ALREADY_CLAIMED\");\n    _transfer(incentive.token, address(this), receiver, amount, unwrapBento);\n    emit ReclaimIncentive(pool, incentiveId);\n}\n\n\n",
                "Repair": "Consider making adding token0 or token1 as incentives disallowed, or keep a record of total remaining incentive amounts for the incentive tokens and avoid consuming these revered balances when collect().\n\nsarangparikh22 (Sushi) confirmed(https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/23)\n\n\n"
            }
        ]
    }
]