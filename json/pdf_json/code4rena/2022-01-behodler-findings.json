[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./ERC677/ERC677.sol\";\nimport \"../contracts/DAO/Governable.sol\";\n\n///@author Justin Goro\n///@title Flan\n/**\n *@notice The reward token for Limbo. Flan can be minted without limit and is intended to converge on the price of DAI via various external incentives\n */\ncontract Flan is ERC677(\"Flan\", \"FLN\"), Governable {\n    event burnOnTransferFeeAdjusted(uint8 oldFee, uint8 newFee);\n    mapping(address => uint256) public mintAllowance; //type(uint).max == whitelist\n\n    uint8 public burnOnTransferFee = 0; //% between 1 and 100, recipient pays\n\n    constructor(address dao) Governable(dao) {}\n\n    /**\n    * @param fee - % between 1 and 100, recipient pays\n     */\n    function setBurnOnTransferFee(uint8 fee) public onlySuccessfulProposal {\n        _setBurnOnTransferFee(fee);\n    }\n\n    ///@notice flash governance technique for FOT change.\n    function incrementBurnOnTransferFee(int8 change)\n        public\n        governanceApproved(false)\n    {\n        uint8 newFee = uint8(int8(burnOnTransferFee) + change);\n        flashGoverner.enforceTolerance(newFee, burnOnTransferFee);\n        _setBurnOnTransferFee(newFee);\n    }\n\n    function _setBurnOnTransferFee(uint8 fee) internal {\n        uint8 priorFee = burnOnTransferFee;\n        burnOnTransferFee = fee > 100 ? 100 : fee;\n        emit burnOnTransferFeeAdjusted(priorFee, burnOnTransferFee);\n    }\n\n    ///@notice grants unlimited minting power to a contract\n    ///@param minter contract to be given unlimited minting power\n    ///@param enabled minting power enabled or disabled\n    function whiteListMinting(address minter, bool enabled)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = enabled ? type(uint256).max : 0;\n    }\n\n    ///@notice metered minting power. Useful for once off minting\n    function increaseMintAllowance(address minter, uint256 _allowance)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = mintAllowance[minter] + _allowance;\n    }\n\n    ///@notice minting of flan open to approved minters and LimboDAO\n    ///@param recipient address to receive flan\n    ///@param amount amount of flan to be minted \n    function mint(address recipient, uint256 amount) public returns (bool) {\n        uint256 allowance = mintAllowance[_msgSender()];\n        require(\n            _msgSender() == owner() || allowance >= amount,\n            \"Flan: Mint allowance exceeded\"\n        );\n        approvedMint(recipient, amount, _msgSender(), allowance);\n        return true;\n    }\n\n    function approvedMint(\n        address recipient,\n        uint256 amount,\n        address minter,\n        uint256 allowance\n    ) internal {\n        _mint(recipient, amount);\n        if (allowance < type(uint256).max && minter != owner()) {\n            mintAllowance[minter] = mintAllowance[minter] - amount;\n        }\n    }\n\n    function safeTransfer(address _to, uint256 _amount) external {\n        uint256 flanBal = balanceOf(address(this));\n        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;\n        _transfer(_msgSender(), _to, flanToTransfer);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 fee = (burnOnTransferFee * amount) / 100;\n\n        _totalSupply = _totalSupply - fee;\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount - fee;\n\n        emit Transfer(sender, recipient, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./facades/UniPairLike.sol\";\nimport \"./facades/BehodlerLike.sol\";\nimport \"./DAO/Governable.sol\";\n// import \"hardhat/console.sol\";\nimport \"./ERC677/ERC20Burnable.sol\";\nimport \"./facades/FlanLike.sol\";\nimport \"./testing/realUniswap/interfaces/IUniswapV2Factory.sol\";\nimport \"./facades/AMMHelper.sol\";\n\ncontract BlackHole {}\n\n///@Title Uniswap V2 helper for managing Flan liquidity on Uniswap V2, Sushiswap and any other compatible AMM\n///@author Justin Goro\n/**@notice Flan liquidity is boosted on Uniswap (or Sushiswap) via open market operations at the point of a token migration.\n  * UniswapHelper handles all the mechanics as well managing a just-in-time (Justin Time?) oracle\n */\ncontract UniswapHelper is Governable, AMMHelper {\n  address limbo;\n\n  struct UniVARS {\n    UniPairLike Flan_SCX_tokenPair;\n    address behodler;\n    address blackHole;\n    address flan;\n    uint256 divergenceTolerance;\n    uint256 minQuoteWaitDuration;\n    address DAI;\n    uint8 precision; // behodler uses a binary search. The higher this number, the more precise\n    IUniswapV2Factory factory;\n    uint8 priceBoostOvershoot; //percentage (0-100) for which the price must be overcorrected when strengthened to account for other AMMs\n  }\n\n  struct FlanQuote {\n    uint256 DaiScxSpotPrice;\n    uint256 DaiBalanceOnBehodler;\n    uint256 blockProduced;\n  }\n\n  /**@dev the Dai SCX price and the Dai balance on Behodler are both sampled twice before a migration can occur. \n  * The two samples have to be spaced a minimum duration and have to be the same values (within an error threshold). The objective here is to make price manipulation untenably expensive for an attacker\n  * so that the mining power expended (or the opportunity cost of eth staked) far exceeds the benefit to manipulating Limbo.\n  * The assumption of price stability isn't a bug because migrations aren't required to happen frequently. Instead if natural price drift occurs for non malicious reasons,\n  * the migration can be reattempted until a period of sufficient calm allows for migration. If a malicious actor injects volatility in order to prevent migration, by the principle\n  * of antifragility, they're doing the entire Ethereum ecosystem a service at their own expense.\n  */\n  FlanQuote[2] public latestFlanQuotes; //0 is latest\n\n  UniVARS VARS;\n\n  //not sure why codebases don't use keyword ether but I'm reluctant to entirely part with that tradition for now.\n  uint256 constant EXA = 1e18;\n\n  //needs to be updated for future Martian, Lunar and Venusian blockchains although I suspect Lunar colonies will be very Terracentric because of low time lag.\n  uint256 constant year = (1 days * 365);\n\n  /*\n    instead of relying on oracles, we simply require snapshots of important \n    prices to be taken at intervals far enough apart.\n    If an attacker wishes to overstate or understate a price through market manipulation,\n    they'd have to keep it out of equilibrium over the span of the two snapshots or they'd\n    have to time the manipulation to happen as the snapshots occur. As a miner,\n    they could do this through transaction ordering but they'd have to win two blocks at precise moments\n    which is statistically highly unlikely. \n    The snapshot enforcement can be hindered by false negatives. Natural price variation, for instance, but the cost\n    of this is just having to snapshot again when the market is calmer. Since migration is not not time sensitive,\n    this is a cost worth bearing.\n    */\n  modifier ensurePriceStability() {\n    _ensurePriceStability();\n    _;\n  }\n\n  modifier onlyLimbo() {\n    require(msg.sender == limbo);\n    _;\n  }\n\n  constructor(address _limbo, address limboDAO) Governable(limboDAO) {\n    limbo = _limbo;\n    VARS.blackHole = address(new BlackHole());\n    VARS.factory = IUniswapV2Factory(address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f));\n    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n  }\n\n  ///@notice LP tokens minted during migration are discarded.\n  function blackHole() public view returns (address) {\n    return VARS.blackHole;\n  }\n\n  ///@notice Uniswap factory contract\n  function setFactory(address factory) public {\n    require(block.chainid != 1, \"Uniswap factory hardcoded on mainnet\");\n    VARS.factory = IUniswapV2Factory(factory);\n  }\n\n  ///@dev Only for testing: On mainnet Dai has a fixed address.\n  function setDAI(address dai) public {\n    require(block.chainid != 1, \"DAI hardcoded on mainnet\");\n    VARS.DAI = dai;\n  }\n\n  ///@notice main configuration function.\n  ///@dev We prefer to use configuration functions rather than a constructor for a number of reasons.\n  ///@param _limbo Limbo contract\n  ///@param FlanSCXPair The Uniswap flan/SCX pair\n  ///@param behodler Behodler AMM\n  ///@param flan The flan token\n  ///@param divergenceTolerance The amount of price difference between the two quotes that is tolerated before a migration is attempted \n  ///@param minQuoteWaitDuration The minimum duration between the sampling of oracle data used for migration\n  ///@param precision In order to query the tokens redeemed by a quantity of SCX, Behodler performs a binary search. Precision refers to the max iterations of the search.\n  ///@param priceBoostOvershoot Flan targets parity with Dai. If we set Flan to equal Dai then between migrations, it will always be below Dai. Overshoot gives us some runway by intentionally \"overshooting\" the price\n  function configure(\n    address _limbo,\n    address FlanSCXPair,\n    address behodler,\n    address flan,\n    uint256 divergenceTolerance,\n    uint256 minQuoteWaitDuration,\n    uint8 precision,\n    uint8 priceBoostOvershoot\n  ) public onlySuccessfulProposal {\n    limbo = _limbo;\n    VARS.Flan_SCX_tokenPair = UniPairLike(FlanSCXPair);\n    VARS.behodler = behodler;\n    VARS.flan = flan;\n    require(divergenceTolerance >= 100, \"Divergence of 100 is parity\");\n    VARS.divergenceTolerance = divergenceTolerance;\n    VARS.minQuoteWaitDuration = minQuoteWaitDuration;\n    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    VARS.precision = precision == 0 ? precision : precision;\n    require(priceBoostOvershoot < 100, \"Set overshoot to number between 1 and 100.\");\n    VARS.priceBoostOvershoot = priceBoostOvershoot;\n  }\n\n  ///@notice Samples the two values required for migration. Must be called twice before migration can occur.\n  function generateFLNQuote() public override {\n    latestFlanQuotes[1] = latestFlanQuotes[0];\n    (\n      latestFlanQuotes[0].DaiScxSpotPrice,\n      latestFlanQuotes[0].DaiBalanceOnBehodler\n    ) = getLatestFLNQuote();\n    latestFlanQuotes[0].blockProduced = block.number;\n  }\n\n  function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {\n    uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(\n      VARS.DAI,\n      10000,\n      1 ether,\n      VARS.precision\n    );\n    dai_scx = (daiToRelease * EXA) / (1 ether);\n\n    daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);\n  }\n\n  ///@notice When tokens are migrated to Behodler, SCX is generated. This SCX is used to boost Flan liquidity and nudge the price of Flan back to parity with Dai\n  ///@param rectangleOfFairness refers to the quantity of SCX held back to be used for open market Flan stabilizing operations\n  ///@dev makes use of price tilting. Be sure to understand the concept of price tilting before trying to understand the final if statement.\n  function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {\n    uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));\n\n    //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.\n    //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes\n    require((localSCXBalance * 100) / rectangleOfFairness == 98, \"EM\");\n    rectangleOfFairness = localSCXBalance;\n\n    //get DAI per scx\n    uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));\n    uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;\n\n    //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.\n    uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);\n    address pair = address(VARS.Flan_SCX_tokenPair);\n    uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);\n\n    if (existingFlanOnLP < DesiredFinalFlanOnLP) {\n      uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;\n\n      flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;\n      FlanLike(VARS.flan).mint(pair, flanToMint);\n      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);\n      {\n        lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);\n      }\n    } else {\n      uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();\n\n      FlanLike(VARS.flan).mint(pair, minFlan + 2);\n      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);\n      lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);\n    }\n    //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.\n    _zeroOutQuotes();\n  }\n\n  ///@notice helper function for converting a desired APY into a flan per second (FPS) statistic\n  ///@param minAPY Here APY refers to the dollar value of flan relative to the dollar value of the threshold\n  ///@param daiThreshold The DAI value of the target threshold to list on Behodler. Threshold is an approximation of the AVB on Behodler\n  function minAPY_to_FPS(\n    uint256 minAPY, //divide by 10000 to get percentage\n    uint256 daiThreshold\n  ) public override view ensurePriceStability returns (uint256 fps) {\n    daiThreshold = daiThreshold == 0 ? latestFlanQuotes[0].DaiBalanceOnBehodler : daiThreshold;\n    // console.log(\"DAI threshold %s\", daiThreshold);\n    uint256 returnOnThreshold = (minAPY * daiThreshold) / 1e4;\n    fps = returnOnThreshold / (year);\n  }\n\n  ///@notice Buys Flan with a specified token, apportions 1% of the purchased Flan to the caller and burns the rest.\n  ///@param inputToken The token used to buy Flan\n  ///@param amount amount of input token used to buy Flan\n  ///@param recipient receives 1% of Flan purchased as an incentive to call this function regularly\n  ///@dev Assumes a pair for Flan/InputToken exists on Uniswap\n  function buyFlanAndBurn(\n    address inputToken,\n    uint256 amount,\n    address recipient\n  ) public override {\n    address pair = VARS.factory.getPair(inputToken, VARS.flan);\n\n    uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);\n    uint256 inputBalance = IERC20(inputToken).balanceOf(pair);\n\n    uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);\n    uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;\n    uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;\n    IERC20(inputToken).transfer(pair, amount);\n    UniPairLike(pair).swap(amount0Out, amount1Out, address(this), \"\");\n    uint256 reward = (amountOut / 100);\n    ERC20Burnable(VARS.flan).transfer(recipient, reward);\n    ERC20Burnable(VARS.flan).burn(amountOut - reward);\n  }\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountOut) {\n    uint256 amountInWithFee = amountIn * 997;\n    uint256 numerator = amountInWithFee * reserveOut;\n    uint256 denominator = reserveIn * 1000 + amountInWithFee;\n    amountOut = numerator / denominator;\n  }\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountIn) {\n    uint256 numerator = reserveIn * amountOut * 1000;\n    uint256 denominator = (reserveOut - amountOut) * 997;\n    amountIn = (numerator / denominator) + 1;\n  }\n\n  function _zeroOutQuotes() internal {\n    delete latestFlanQuotes[0];\n    delete latestFlanQuotes[1];\n  }\n\n  //the purpose of the divergence code is to bring the robustness of a good oracle without requiring an oracle\n  function _ensurePriceStability() internal view {\n    FlanQuote[2] memory localFlanQuotes; //save gas\n    localFlanQuotes[0] = latestFlanQuotes[0];\n    localFlanQuotes[1] = latestFlanQuotes[1];\n\n    uint256 daiSCXSpotPriceDivergence = localFlanQuotes[0].DaiScxSpotPrice > localFlanQuotes[1].DaiScxSpotPrice\n      ? (localFlanQuotes[0].DaiScxSpotPrice * 100) / localFlanQuotes[1].DaiScxSpotPrice\n      : (localFlanQuotes[1].DaiScxSpotPrice * 100) / localFlanQuotes[0].DaiScxSpotPrice;\n\n    uint256 daiBalanceDivergence = localFlanQuotes[0].DaiBalanceOnBehodler > localFlanQuotes[1].DaiBalanceOnBehodler\n      ? (localFlanQuotes[0].DaiBalanceOnBehodler * 100) / localFlanQuotes[1].DaiBalanceOnBehodler\n      : (localFlanQuotes[1].DaiBalanceOnBehodler * 100) / localFlanQuotes[0].DaiBalanceOnBehodler;\n\n    // console.log(\"dai balance divergence %s\", daiBalanceDivergence);\n    require(\n      daiSCXSpotPriceDivergence < VARS.divergenceTolerance && daiBalanceDivergence < VARS.divergenceTolerance,\n      \"EG\"\n    );\n\n    require(\n      localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration &&\n        localFlanQuotes[1].blockProduced > 0,\n      \"EH\"\n    );\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./Governable.sol\";\nimport \"hardhat/console.sol\";\nimport \"../facades/Burnable.sol\";\n\n///@title Flash Governance Arbiter\n///@author Justin Goro\n/**@notice LimboDAO offers two forms of governance: flash and proposal. Proposals are contracts that have authorization to execute guarded functions on contracts that implement the Governable abstract contract.\n * Proposals require Fate to be put forward for voting and Fate is the spendable voting token.\n * Flash governance occurs in the duration of one transaction and is more appropriate for variable tweaking such as changing the Flan per Second or Threshold of a pool.\n * Flash governance requires an asset be deposited into an adjudication contract. The community can then vote, through a proposal, whether the decision was legitimate. If not, the deposit can be slashed\n * By default, the asset is EYE.\n */\ncontract FlashGovernanceArbiter is Governable {\n  /**\n   * @param actor user making flash governance decision\n   * @param deposit_asset is the asset type put up as decision collateral. Must be burnable.\n   * @param amount is the amount of the deposit_asset to be put up as decision collateral.\n   * @param target is the contract that will be affected by the flash governance decision.\n   */\n  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);\n\n  mapping(address => bool) enforceLimitsActive;\n\n  constructor(address dao) Governable(dao) {}\n\n  struct FlashGovernanceConfig {\n    address asset;\n    uint256 amount;\n    uint256 unlockTime;\n    bool assetBurnable;\n  }\n\n  //Note: epoch settings prevent DOS attacks. Change tolerance curtails the damage of bad flash governance.\n  struct SecurityParameters {\n    uint8 maxGovernanceChangePerEpoch; //prevents flash governance from wrecking the incentives.\n    uint256 epochSize; //only one flash governance action can happen per epoch to prevent governance DOS\n    uint256 lastFlashGovernanceAct;\n    uint8 changeTolerance; //1-100 maximum percentage any numeric variable can be changed through flash gov\n  }\n\n  //the current parameters determining the rules of flash governance\n  FlashGovernanceConfig public flashGovernanceConfig;\n  SecurityParameters public security;\n\n  /*For every decision, we record the config at the time of the decision. This allows governance to change the rules\n   *without undermining the terms under which pending decisions were made.\n   */\n  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; //contract->user->config\n\n  /**\n   *@notice An attempt is made to withdraw the current deposit requirement.\n   * For a given user, flash governance decisions can only happen one at a time\n   *@param sender is the user making the flash governance decision\n   *@param target is the contract that will be affected by the flash governance decision.\n   *@param emergency flash governance decisions are restricted in frequency per epoch but some decisions are too important. These can be marked emergency.\n   *@dev be very careful about setting emergency to true. Only decisions which preclude the execution of other flash governance decisions should be considered candidtes for emergency.\n   */\n  function assertGovernanceApproved(\n    address sender,\n    address target,\n    bool emergency\n  ) public {\n    if (\n      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&\n      pendingFlashDecision[target][sender].unlockTime < block.timestamp\n    ) {\n      require(\n        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),\n        \"Limbo: flash governance disabled for rest of epoch\"\n      );\n      pendingFlashDecision[target][sender] = flashGovernanceConfig;\n      pendingFlashDecision[target][sender].unlockTime += block.timestamp;\n\n      security.lastFlashGovernanceAct = block.timestamp;\n      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);\n    } else {\n      revert(\"LIMBO: governance decision rejected.\");\n    }\n  }\n\n  /**\n   *@param asset is the asset type put up as decision collateral. Must be burnable.\n   *@param amount is the amount of the deposit_asset to be put up as decision collateral.\n   *@param unlockTime is the duration for which the deposit collateral must be locked in order to give the community time to weigh up the decision\n   *@param assetBurnable is a technical parameter to determined the manner in which burning should occur. Non burnable assets are just no longer accounted for and accumulate within this contract.\n   */\n  function configureFlashGovernance(\n    address asset,\n    uint256 amount,\n    uint256 unlockTime,\n    bool assetBurnable\n  ) public virtual onlySuccessfulProposal {\n    flashGovernanceConfig.asset = asset;\n    flashGovernanceConfig.amount = amount;\n    flashGovernanceConfig.unlockTime = unlockTime;\n    flashGovernanceConfig.assetBurnable = assetBurnable;\n  }\n\n  /**\n    @param maxGovernanceChangePerEpoch max number of flash governance decisions per epoch to prevent DOS\n    @param epochSize is the duration of a flash governance epoch and reflects proposal deliberation durations\n    @param changeTolerance is the amount by which a variable can be changed through flash governance.\n    */\n  function configureSecurityParameters(\n    uint8 maxGovernanceChangePerEpoch,\n    uint256 epochSize,\n    uint8 changeTolerance\n  ) public virtual onlySuccessfulProposal {\n    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;\n    security.epochSize = epochSize;\n    require(security.changeTolerance < 100, \"Limbo: % between 0 and 100\");\n    security.changeTolerance = changeTolerance;\n  }\n\n  /**\n    @notice LimboDAO proposals for burning flash governance collateral act through this function\n    @param targetContract is the contract that is affected by the flash governance decision.\n    @param user is the user who made the flash governance decision\n    @param asset is the collateral asset to be burnt\n    @param amount is the amount of the collateral to be burnt\n    */\n  function burnFlashGovernanceAsset(\n    address targetContract,\n    address user,\n    address asset,\n    uint256 amount\n  ) public virtual onlySuccessfulProposal {\n    if (pendingFlashDecision[targetContract][user].assetBurnable) {\n      Burnable(asset).burn(amount);\n    }\n\n    pendingFlashDecision[targetContract][user] = flashGovernanceConfig;\n  }\n\n  /**\n   *@notice Assuming a flash governance decision was not rejected during the lock window, the user is free to withdraw their asset\n   *@param targetContract is the contract that is affected by the flash governance decision.\n   *@param asset is the collateral asset to be withdrawn\n   */\n  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {\n    require(\n      pendingFlashDecision[targetContract][msg.sender].asset == asset &&\n        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&\n        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,\n      \"Limbo: Flashgovernance decision pending.\"\n    );\n    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(\n      msg.sender,\n      pendingFlashDecision[targetContract][msg.sender].amount\n    );\n    delete pendingFlashDecision[targetContract][msg.sender];\n  }\n\n  /**\n   *@notice when a governance function is executed, it can enforce change limits on variables in the event that the execution is through flash governance\n   * However, a proposal is subject to the full deliberation of the DAO and such limits may thwart good governance.\n   * @param enforce for the given context, set whether variable movement limits are enforced or not.\n   */\n  function setEnforcement(bool enforce) public {\n    enforceLimitsActive[msg.sender] = enforce;\n  }\n\n  ///@dev for negative values, relative comparisons need to be calculated correctly.\n  function enforceToleranceInt(int256 v1, int256 v2) public view {\n    if (!configured) return;\n    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);\n    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);\n    enforceTolerance(uv1, uv2);\n  }\n\n  ///@notice Allows functions to enforce maximum limits on a per variable basis\n  ///@dev the 100 factor is just to allow for simple percentage comparisons without worrying about enormous precision.\n  function enforceTolerance(uint256 v1, uint256 v2) public view {\n    if (!configured || !enforceLimitsActive[msg.sender]) return;\n    //bonus points for readability\n    if (v1 > v2) {\n      if (v2 == 0) require(v1 <= 1, \"FE1\");\n      else require(((v1 - v2) * 100) < security.changeTolerance * v1, \"FE1\");\n    } else {\n      if (v1 == 0) require(v2 <= 1, \"FE1\");\n      else require(((v2 - v1) * 100) < security.changeTolerance * v1, \"FE1\");\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "Flan.sol",
            "UniswapHelper.sol",
            "FlashGovernanceArbiter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "target",
                    "approve",
                    "true",
                    "emergency",
                    "sender",
                    "assertGovernanceApproved"
                ],
                "Type": " Lack of access control on  assertGovernanceApproved  can cause funds to be locked",
                "Description": "\nLack of access control on the assertGovernanceApproved function of FlashGovernanceArbiter allows anyone to lock other users' funds in the contract as long as the users have approved the contract to transfer flashGovernanceConfig.amount of flashGovernanceConfig.asset from them.\n\n\n1.  Alice wants to execute a flash governance decision (e.g., disable to the protocol), so she first calls approve on the flashGovernanceConfig.asset to allow FlashGovernanceArbiter to transfer flashGovernanceConfig.amount of assets from her.\n2.  An attacker Bob, who listens to the mempool, notices Alice's approve transaction and decides to front-run it. He calls assertGovernanceApproved with sender being Alice, target being any address, and emergency being true.\n3.  As a result, Alice cannot execute her flash governance decision, and her funds are locked in the contract for the flashGovernanceConfig.unlockTime period.\n\nReferenced code:\nDAO/FlashGovernanceArbiter.sol#L60-L81(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60-L81)\n\n",
                "Repair": "\nOnly allow certain addresses to call the assertGovernanceApproved function on FlashGovernanceArbiter.\n\ngititGoro (Behodler) confirmed, but disagreed with High severity and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/300#issuecomment-1056104445):\n  The reason I stuck with medium risk is because the user's funds can't be lost in this scenario. Only temporarily locked. If the user unapproves FlashGovernanceArbiter on EYE then they simply have to wait until the unlock period has passed and can withdraw again.\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/300#issuecomment-1056190654):\n Agreed. This should be somewhere in between Med and High. If it's just the users' deposits being temporarily locked, then it's definitely a Med. But this one is taking probably all the funds from users' wallets and locking them against their will, easy to pull off by anyone, all at once for all potential victims.\n \n I tend to make it a High so that the future wardens and probably by extent the devs can be more careful with allowances. We have seen so many incidents caused by improper handling of users' allowances.\n \n A transferFrom() with from not being hard-coded as msg.sender is evil.\n \n My fellow wardens, if you are reading this, do not go easy on a transferFrom() that takes an argument as from.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./facades/FlanLike.sol\";\nimport \"./facades/PyroTokenLike.sol\";\nimport \"./DAO/Governable.sol\";\nimport \"./ERC677/ERC20Burnable.sol\";\nimport \"./facades/UniPairLike.sol\";\nimport \"hardhat/console.sol\";\n\n///@title FlanBackstop (placeholder name)\n///@author Justin Goro\n/**\n * @notice Initially Flan's liquidity may be fairly low, limiting Limbo's ability to reward souls. Flan backstop accepts stablecoins in return for minting Pyroflan.\n *Under the hood a smaller quantity of Flan is minted and paired with the stablecoin in Uniswap in order to tilt the price of Flan higher while incresaing liquidity.\n * The same operation is performed with PyroFlan\n * The calling user then receives PyroFlan equal in value to the intial amount sent in but at the new price. A small premium is added.\n * The incentives facing the user: mint $X of PyroFlan with <$X of stablecoin, stake PyroFlan in Limbo for high APY, do not immediately dump because PyroFlan increases in value and because of 2% exit fee.\n * The incentives should be enough to encourage a gradual increase in pooled Flan and stablecoins, creating some minting runway for Limbo to accelerate.\n * In the future when Flan and Limbo are thriving and Flan is listed on Curve, we can create a version of this for Curve and Uniswap V3 in order to concentrate Flan liquidity and further cement stablecoin status.\n * Note: in this version, LP tokens generated are cast into the void. The argument of keeping them for fee revenue is negated by the impact on Flan. It would just be taking from Peter to give to Paul. \n */\n///@dev This contract uses Pyrotokens3. At the time of authoring, Pyrotokens3 implementation is incomplete and not fully tested but the interface (ABI) is locked.\ncontract FlanBackstop is Governable {\n  /**\n   *@param dao LimboDAO\n   *@param flan Flan address\n   *@param pyroFlan PyroFlan address\n   */\n  constructor(\n    address dao,\n    address flan,\n    address pyroFlan\n  ) Governable(dao) {\n    config.pyroFlan = pyroFlan;\n    config.flan = flan;\n    IERC20(flan).approve(pyroFlan, 2**256 - 1);\n  }\n\n  struct ConfigVars {\n    address flan;\n    address pyroFlan;\n    mapping(address => address) flanLPs;\n    mapping(address => address) pyroFlanLPs;\n    mapping(address => uint256) acceptableHighestPrice; //Highest tolerated Flan per stable\n    mapping(address => uint8) decimalPlaces; //USDC and USDT have 6 decimal places because large stablecoin transfers are exactly where you'd like to find accidental bugs\n  }\n\n  ConfigVars public config;\n\n  /**\n   *@param stablecoin One of the popular stablecoins such as USDC, USDT, MIM, OUSD etc.\n   *@param flanLP Uniswap V2 (or a fork such as Sushi) flan/Stablecoin LP\n   *@param pyroFlanLP Uniswap V2 (or a fork such as Sushi) pyroFlan/Stablecoin LP\n   *@param acceptableHighestPrice Since the prices are being read from balances, not oracles, the opportunity for price manipulation through flash loans exists. The community can put a circuit breaker in place to prevent such an exploit.\n   *@param decimalPlaces USDT and USDC do not conform to common ERC20 practice. \n   */\n  function setBacker(\n    address stablecoin,\n    address flanLP,\n    address pyroFlanLP,\n    uint256 acceptableHighestPrice,\n    uint8 decimalPlaces\n  ) external onlySuccessfulProposal {\n    config.flanLPs[stablecoin] = flanLP;\n    config.pyroFlanLPs[stablecoin] = pyroFlanLP;\n    config.acceptableHighestPrice[stablecoin] = acceptableHighestPrice;\n    config.decimalPlaces[stablecoin] = decimalPlaces;\n  }\n\n  /**\n  *@notice takes in a stablecoin, mints flan and pyroFlan and pairs with stablecoin in a Uniswap Pair to generate liquidity\n   *@param stablecoin Stablecoin with which to purchase\n   *@param amount amount in stablecoin wei units.\n   */\n  function purchasePyroFlan(address stablecoin, uint256 amount) external {\n    uint normalizedAmount = normalize(stablecoin, amount);\n    address flanLP = config.flanLPs[stablecoin];\n    address pyroFlanLP = config.pyroFlanLPs[stablecoin];\n    require(flanLP != address(0) && pyroFlanLP != address(0), \"BACKSTOP: configure stablecoin\");\n\n    uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);\n    uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);\n    uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;\n\n    //Price tilt pairs and mint liquidity\n    FlanLike(config.flan).mint(address(this), normalizedAmount / 2);\n    IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);\n    IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);\n\n    UniPairLike(flanLP).mint(address(this));\n    uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\n    PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);\n    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\n    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\n    IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);\n    UniPairLike(pyroFlanLP).mint(address(this));\n\n    uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);\n    uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);\n\n    uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;\n    require(tiltedPrice < config.acceptableHighestPrice[stablecoin], \"BACKSTOP: potential price manipulation\");\n    uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;\n\n    uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);\n\n    //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return\n    uint256 premium = (flanToMint * (growth / 2)) / 100;\n\n    FlanLike(config.flan).mint(address(this), flanToMint + premium);\n    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\n    PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);\n    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\n  }\n\n  function getMagnitude(address token) internal view returns (uint256) {\n    uint256 places = config.decimalPlaces[token];\n    return 10**places;\n  }\n\n  function normalize(address token, uint256 amount) internal view returns (uint256) {\n    uint256 places = config.decimalPlaces[token];\n    uint256 bump = 10**(18 - places);\n    return amount * bump;\n  }\n}\n\n\n",
        "CodeNames": [
            "FlanBackstop.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "//solidity\nuint256 proxy = (baseBalance * ONE) / _redeemRate;\n",
                    "//solidity\nuint256 proxy = (amount * ONE) / _redeemRate;\n"
                ],
                "Type": " wrong minting amount",
                "Description": "\n<https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/TokenProxies/RebaseProxy.sol#L36\n\nsolidity\nuint256 proxy = (baseBalance * ONE) / _redeemRate;\n\n\nshould be:\nsolidity\nuint256 proxy = (amount * ONE) / _redeemRate;\n\n\ngititGoro (Behodler) confirmed, but disagreed with High severity and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/297#issuecomment-1030508474):\n  Should be a balanceBefore and balanceAfter calculation with the diff being wrapped.\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/297#issuecomment-1041248898):\n  Valid high. The issue description can be more comprehensive though.\n\n\n\n*\n\n\n",
                "Repair": ""
            },
            {
                "Name": "H-05",
                "Location": [
                    "//solidity\nuint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;\nuint256 growth = ((priceBefore tiltedPrice) * 100) / priceBefore;\nuint256 premium = (flanToMint * (growth / 2)) / 100;\n"
                ],
                "Type": " Flash loan price manipulation in  purchasePyroFlan() ",
                "Description": "\nThe comment on line 54(https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/FlanBackstop.sol#L54) of FlanBackstop.sol states \"the opportunity for price manipulation through flash loans exists\", and I agree that this is a serious risk. While the acceptableHighestPrice variable attempts to limit the maximum price change of the flan-stablecoin LP, a flashloan sandwich attack can still occur within this limit and make up for the limitation with larger volumes or multiple flashloan attacks. Flashloan price manipulation is the cause for many major hacks, including bZx(https://bzx.network/blog/postmortem-ethdenver), Harvest(https://rekt.news/harvest-finance-rekt/), and others.\n\n\nLine 83(https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/FlanBackstop.sol#L83) of FlanBackstop.sol calculates the price of flan to stablecoin in the Uniswap pool based on the balances at a single point in time. Pool balances at a single point in time can be manipulated with flash loans, which can skew the numbers to the extreme. The single data point of LP balances is used to calculate the growth variable in line 103(https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/FlanBackstop.sol#L103), and the growth variable influences the quantity of pyroflan a user receives in the premium calculation on line 108(https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/FlanBackstop.sol#L108).\n\nsolidity\nuint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;\nuint256 growth = ((priceBefore tiltedPrice) * 100) / priceBefore;\nuint256 premium = (flanToMint * (growth / 2)) / 100;\n\n\nProblems can occur when the volumes that the purchasePyroFlan() function sends to the Uniswap pool are large compared to the pool's liquidity volume, or if the Uniswap pool price is temporarily tilted with a flashloan (or a whale). Because this function purposefully changes the exchange rate of the LP, by transferring tokens to the LP in a 2-to-1 ratio, a large volume could caught a large price impact in the LP. The code attempts to protect against this manipulation in line 102(https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/FlanBackstop.sol#L102) with a require statement, but this can be worked around by reducing the volume per flashloan and repeating the attack multiple times. A user can manipulate the LP, especially when the LP is new with low liquidity, in order to achieve large amounts of flan and pyroflan.\n\n",
                "Repair": "\nUse a TWAP instead of the pool price at a single point in time to increase the cost of performing a flashloan sandwich attack. See the Uniswap v2 price oracle solution (https://docs.uniswap.org/protocol/V2/concepts/core-concepts/oracles)documentation for more explanations on how Uniswap designed an approach to providing asset prices while reducing the change of manipulation.\n\ngititGoro (Behodler) acknowledged and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/231#issuecomment-1030498476):\n  This is a very well constructed report and if Flan was not intended to target a 1:1 with stablecoins, I'd accept it but since we know Flan shouldn't diverge far from 1:1, we don't run very large risks. Essentially, if the flan price crashes dramatically, backstop no longer works so the purpose of this contract is to just boost liquidity for Flan when Flan is operating under normal ish conditions. It's not intended to be black swan proof.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-10",
                "Location": [
                    "stake"
                ],
                "Type": " user won't be able to get his rewards in case of staking with amount = 0",
                "Description": "\n\nIf a user has a pending reward and he calls the stake function with amount = 0, he won't be able to get his reward (he won't get the reward, and the reward debt will cover the reward)\n\nThat's happening because the reward calculation is done only if the staked amount (given as a parameter) is greater than 0, and it updates the reward debt also if the amount is 0, so the reward debt will be updated without the user will be able to get his reward\n\ngititGoro (Behodler) confirmed and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/146#issuecomment-1029415967):\n  Good catch! I'd be interested in your mitigation step being provided. \n \n To me, it looks like the simplest solution is just to remove that if statement. Users who stake zero will pay unnecessary gas costs but the contract shouldn't have to optimise gas consumption for undesired behaviour.\n\nJack the Pug (judge) increased severity from Low to Medium and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/146#issuecomment-1053338078):\n  Upgraded to Med as users can lose their rewards.\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./ERC677/ERC677.sol\";\nimport \"../contracts/DAO/Governable.sol\";\n\n///@author Justin Goro\n///@title Flan\n/**\n *@notice The reward token for Limbo. Flan can be minted without limit and is intended to converge on the price of DAI via various external incentives\n */\ncontract Flan is ERC677(\"Flan\", \"FLN\"), Governable {\n    event burnOnTransferFeeAdjusted(uint8 oldFee, uint8 newFee);\n    mapping(address => uint256) public mintAllowance; //type(uint).max == whitelist\n\n    uint8 public burnOnTransferFee = 0; //% between 1 and 100, recipient pays\n\n    constructor(address dao) Governable(dao) {}\n\n    /**\n    * @param fee - % between 1 and 100, recipient pays\n     */\n    function setBurnOnTransferFee(uint8 fee) public onlySuccessfulProposal {\n        _setBurnOnTransferFee(fee);\n    }\n\n    ///@notice flash governance technique for FOT change.\n    function incrementBurnOnTransferFee(int8 change)\n        public\n        governanceApproved(false)\n    {\n        uint8 newFee = uint8(int8(burnOnTransferFee) + change);\n        flashGoverner.enforceTolerance(newFee, burnOnTransferFee);\n        _setBurnOnTransferFee(newFee);\n    }\n\n    function _setBurnOnTransferFee(uint8 fee) internal {\n        uint8 priorFee = burnOnTransferFee;\n        burnOnTransferFee = fee > 100 ? 100 : fee;\n        emit burnOnTransferFeeAdjusted(priorFee, burnOnTransferFee);\n    }\n\n    ///@notice grants unlimited minting power to a contract\n    ///@param minter contract to be given unlimited minting power\n    ///@param enabled minting power enabled or disabled\n    function whiteListMinting(address minter, bool enabled)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = enabled ? type(uint256).max : 0;\n    }\n\n    ///@notice metered minting power. Useful for once off minting\n    function increaseMintAllowance(address minter, uint256 _allowance)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = mintAllowance[minter] + _allowance;\n    }\n\n    ///@notice minting of flan open to approved minters and LimboDAO\n    ///@param recipient address to receive flan\n    ///@param amount amount of flan to be minted \n    function mint(address recipient, uint256 amount) public returns (bool) {\n        uint256 allowance = mintAllowance[_msgSender()];\n        require(\n            _msgSender() == owner() || allowance >= amount,\n            \"Flan: Mint allowance exceeded\"\n        );\n        approvedMint(recipient, amount, _msgSender(), allowance);\n        return true;\n    }\n\n    function approvedMint(\n        address recipient,\n        uint256 amount,\n        address minter,\n        uint256 allowance\n    ) internal {\n        _mint(recipient, amount);\n        if (allowance < type(uint256).max && minter != owner()) {\n            mintAllowance[minter] = mintAllowance[minter] - amount;\n        }\n    }\n\n    function safeTransfer(address _to, uint256 _amount) external {\n        uint256 flanBal = balanceOf(address(this));\n        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;\n        _transfer(_msgSender(), _to, flanToTransfer);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 fee = (burnOnTransferFee * amount) / 100;\n\n        _totalSupply = _totalSupply - fee;\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount - fee;\n\n        emit Transfer(sender, recipient, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./ERC20Burnable.sol\";\nimport \"./IERC677Receiver.sol\";\n\n/*\nAll tokens in Limbo comply with the ERC677 standard. In addition they are ownable, alow burning\nand can whitelist addresses with finite or infinite minting power\n*/\n\ncontract ERC677 is ERC20Burnable, Ownable {\n   \n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n\n    }\n\n    /**\n     * @dev transfer token to a contract address with additional data if the recipient is a contact.\n     * @param _to The address to transfer to.\n     * @param _value The amount to be transferred.\n     * @param _data The extra data to be passed to the receiving contract.\n     */\n    function transferAndCall(\n        address _to,\n        uint256 _value,\n        bytes memory _data\n    ) public returns (bool success) {\n        super.transfer(_to, _value);\n        _transfer(msg.sender, _to, _value);\n        if (isContract(_to)) {\n            contractFallback(_to, _value, _data);\n        }\n        return true;\n    }\n\n    function contractFallback(\n        address _to,\n        uint256 _value,\n        bytes memory _data\n    ) private {\n        IERC677Receiver receiver = IERC677Receiver(_to);\n        receiver.onTokenTransfer(msg.sender, _value, _data);\n    }\n\n    function isContract(address _addr) private view returns (bool hasCode) {\n        uint256 length;\n        assembly {\n            length := extcodesize(_addr)\n        }\n        return length > 0;\n    }\n}\n\n\n",
        "CodeNames": [
            "Flan.sol",
            "ERC677.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-03",
                "Location": [
                    "//solidity\nfunction transferAndCall(\n  address _to,\n  uint256 _value,\n  bytes memory _data\n) public returns (bool success) {\n  super.transfer(_to, _value);\n  _transfer(msg.sender, _to, _value);\n  if (isContract(_to)) {\n      contractFallback(_to, _value, _data);\n  }\n  return true;\n}\n"
                ],
                "Type": " Double transfer in the  transferAndCall  function of  ERC677 ",
                "Description": "\nThe implementation of the transferAndCall function in ERC677 is incorrect. It transfers the _value amount of tokens twice instead of once. Since the Flan contract inherits ERC667, anyone calling the transferAndCall function on Flan is affected by this double-transfer bug.\n\n\nBelow is the implementation of transferAndCall:\nsolidity\nfunction transferAndCall(\n  address _to,\n  uint256 _value,\n  bytes memory _data\n) public returns (bool success) {\n  super.transfer(_to, _value);\n  _transfer(msg.sender, _to, _value);\n  if (isContract(_to)) {\n      contractFallback(_to, _value, _data);\n  }\n  return true;\n}\n\n\nWe can see that super.transfer(_to, _value); and _transfer(msg.sender, _to, _value); are doing the same thing transfering _value of tokens from msg.sender to _to.\n\nReferenced code:\nERC677/ERC677.sol#L28-L29(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/ERC677/ERC677.sol#L28-L29)\n\n",
                "Repair": "\nRemove _transfer(msg.sender, _to, _value); in the transferAndCall function.\n\ngititGoro (Behodler) confirmed and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/302):\n  Fix\n Behodler/limbo#3(https://github.com/Behodler/limbo/pull/3)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./Governable.sol\";\nimport \"hardhat/console.sol\";\nimport \"../facades/Burnable.sol\";\n\n///@title Flash Governance Arbiter\n///@author Justin Goro\n/**@notice LimboDAO offers two forms of governance: flash and proposal. Proposals are contracts that have authorization to execute guarded functions on contracts that implement the Governable abstract contract.\n * Proposals require Fate to be put forward for voting and Fate is the spendable voting token.\n * Flash governance occurs in the duration of one transaction and is more appropriate for variable tweaking such as changing the Flan per Second or Threshold of a pool.\n * Flash governance requires an asset be deposited into an adjudication contract. The community can then vote, through a proposal, whether the decision was legitimate. If not, the deposit can be slashed\n * By default, the asset is EYE.\n */\ncontract FlashGovernanceArbiter is Governable {\n  /**\n   * @param actor user making flash governance decision\n   * @param deposit_asset is the asset type put up as decision collateral. Must be burnable.\n   * @param amount is the amount of the deposit_asset to be put up as decision collateral.\n   * @param target is the contract that will be affected by the flash governance decision.\n   */\n  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);\n\n  mapping(address => bool) enforceLimitsActive;\n\n  constructor(address dao) Governable(dao) {}\n\n  struct FlashGovernanceConfig {\n    address asset;\n    uint256 amount;\n    uint256 unlockTime;\n    bool assetBurnable;\n  }\n\n  //Note: epoch settings prevent DOS attacks. Change tolerance curtails the damage of bad flash governance.\n  struct SecurityParameters {\n    uint8 maxGovernanceChangePerEpoch; //prevents flash governance from wrecking the incentives.\n    uint256 epochSize; //only one flash governance action can happen per epoch to prevent governance DOS\n    uint256 lastFlashGovernanceAct;\n    uint8 changeTolerance; //1-100 maximum percentage any numeric variable can be changed through flash gov\n  }\n\n  //the current parameters determining the rules of flash governance\n  FlashGovernanceConfig public flashGovernanceConfig;\n  SecurityParameters public security;\n\n  /*For every decision, we record the config at the time of the decision. This allows governance to change the rules\n   *without undermining the terms under which pending decisions were made.\n   */\n  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; //contract->user->config\n\n  /**\n   *@notice An attempt is made to withdraw the current deposit requirement.\n   * For a given user, flash governance decisions can only happen one at a time\n   *@param sender is the user making the flash governance decision\n   *@param target is the contract that will be affected by the flash governance decision.\n   *@param emergency flash governance decisions are restricted in frequency per epoch but some decisions are too important. These can be marked emergency.\n   *@dev be very careful about setting emergency to true. Only decisions which preclude the execution of other flash governance decisions should be considered candidtes for emergency.\n   */\n  function assertGovernanceApproved(\n    address sender,\n    address target,\n    bool emergency\n  ) public {\n    if (\n      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&\n      pendingFlashDecision[target][sender].unlockTime < block.timestamp\n    ) {\n      require(\n        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),\n        \"Limbo: flash governance disabled for rest of epoch\"\n      );\n      pendingFlashDecision[target][sender] = flashGovernanceConfig;\n      pendingFlashDecision[target][sender].unlockTime += block.timestamp;\n\n      security.lastFlashGovernanceAct = block.timestamp;\n      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);\n    } else {\n      revert(\"LIMBO: governance decision rejected.\");\n    }\n  }\n\n  /**\n   *@param asset is the asset type put up as decision collateral. Must be burnable.\n   *@param amount is the amount of the deposit_asset to be put up as decision collateral.\n   *@param unlockTime is the duration for which the deposit collateral must be locked in order to give the community time to weigh up the decision\n   *@param assetBurnable is a technical parameter to determined the manner in which burning should occur. Non burnable assets are just no longer accounted for and accumulate within this contract.\n   */\n  function configureFlashGovernance(\n    address asset,\n    uint256 amount,\n    uint256 unlockTime,\n    bool assetBurnable\n  ) public virtual onlySuccessfulProposal {\n    flashGovernanceConfig.asset = asset;\n    flashGovernanceConfig.amount = amount;\n    flashGovernanceConfig.unlockTime = unlockTime;\n    flashGovernanceConfig.assetBurnable = assetBurnable;\n  }\n\n  /**\n    @param maxGovernanceChangePerEpoch max number of flash governance decisions per epoch to prevent DOS\n    @param epochSize is the duration of a flash governance epoch and reflects proposal deliberation durations\n    @param changeTolerance is the amount by which a variable can be changed through flash governance.\n    */\n  function configureSecurityParameters(\n    uint8 maxGovernanceChangePerEpoch,\n    uint256 epochSize,\n    uint8 changeTolerance\n  ) public virtual onlySuccessfulProposal {\n    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;\n    security.epochSize = epochSize;\n    require(security.changeTolerance < 100, \"Limbo: % between 0 and 100\");\n    security.changeTolerance = changeTolerance;\n  }\n\n  /**\n    @notice LimboDAO proposals for burning flash governance collateral act through this function\n    @param targetContract is the contract that is affected by the flash governance decision.\n    @param user is the user who made the flash governance decision\n    @param asset is the collateral asset to be burnt\n    @param amount is the amount of the collateral to be burnt\n    */\n  function burnFlashGovernanceAsset(\n    address targetContract,\n    address user,\n    address asset,\n    uint256 amount\n  ) public virtual onlySuccessfulProposal {\n    if (pendingFlashDecision[targetContract][user].assetBurnable) {\n      Burnable(asset).burn(amount);\n    }\n\n    pendingFlashDecision[targetContract][user] = flashGovernanceConfig;\n  }\n\n  /**\n   *@notice Assuming a flash governance decision was not rejected during the lock window, the user is free to withdraw their asset\n   *@param targetContract is the contract that is affected by the flash governance decision.\n   *@param asset is the collateral asset to be withdrawn\n   */\n  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {\n    require(\n      pendingFlashDecision[targetContract][msg.sender].asset == asset &&\n        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&\n        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,\n      \"Limbo: Flashgovernance decision pending.\"\n    );\n    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(\n      msg.sender,\n      pendingFlashDecision[targetContract][msg.sender].amount\n    );\n    delete pendingFlashDecision[targetContract][msg.sender];\n  }\n\n  /**\n   *@notice when a governance function is executed, it can enforce change limits on variables in the event that the execution is through flash governance\n   * However, a proposal is subject to the full deliberation of the DAO and such limits may thwart good governance.\n   * @param enforce for the given context, set whether variable movement limits are enforced or not.\n   */\n  function setEnforcement(bool enforce) public {\n    enforceLimitsActive[msg.sender] = enforce;\n  }\n\n  ///@dev for negative values, relative comparisons need to be calculated correctly.\n  function enforceToleranceInt(int256 v1, int256 v2) public view {\n    if (!configured) return;\n    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);\n    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);\n    enforceTolerance(uv1, uv2);\n  }\n\n  ///@notice Allows functions to enforce maximum limits on a per variable basis\n  ///@dev the 100 factor is just to allow for simple percentage comparisons without worrying about enormous precision.\n  function enforceTolerance(uint256 v1, uint256 v2) public view {\n    if (!configured || !enforceLimitsActive[msg.sender]) return;\n    //bonus points for readability\n    if (v1 > v2) {\n      if (v2 == 0) require(v1 <= 1, \"FE1\");\n      else require(((v1 - v2) * 100) < security.changeTolerance * v1, \"FE1\");\n    } else {\n      if (v1 == 0) require(v2 <= 1, \"FE1\");\n      else require(((v2 - v1) * 100) < security.changeTolerance * v1, \"FE1\");\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "FlashGovernanceArbiter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-04",
                "Location": [
                    "burnFlashGovernanceAsset",
                    "pendingFlashDecision",
                    "withdrawGovernanceAsset",
                    "unlockTime < block.timestamp"
                ],
                "Type": " Logic error in  burnFlashGovernanceAsset  can cause locked assets to be stolen",
                "Description": "\nA logic error in the burnFlashGovernanceAsset function that resets a user's pendingFlashDecision allows that user to steal other user's assets locked in future flash governance decisions. As a result, attackers can get their funds back even if they execute a malicious flash decision and the community burns their assets.\n\n\n1.  An attacker Alice executes a malicious flash governance decision, and her assets are locked in the FlashGovernanceArbiter contract.\n2.  The community disagrees with Alice's flash governance decision and calls burnFlashGovernanceAsset to burn her locked assets. However, the burnFlashGovernanceAsset function resets Alice's pendingFlashDecision to the default config (see line 134).\n3.  A benign user, Bob executes another flash governance decision, and his assets are locked in the contract.\n4.  Now, Alice calls withdrawGovernanceAsset to withdraw Bob's locked asset, effectively the same as stealing Bob's assets. Since Alice's pendingFlashDecision is reset to the default, the unlockTime < block.timestamp condition is fulfilled, and the withdrawal succeeds.\n\nReferenced code:\nDAO/FlashGovernanceArbiter.sol#L134(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L134)\nDAO/FlashGovernanceArbiter.sol#L146(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L146)\n\n",
                "Repair": "\nChange line 134 to delete pendingFlashDecision[targetContract][user] instead of setting the pendingFlashDecision to the default.\n\ngititGoro (Behodler) confirmed(https://github.com/code-423n4/2022-01-behodler-findings/issues/305)\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-01",
                "Location": [
                    "//solidity\nfunction assertGovernanceApproved(\n    address sender,\n    address target,\n    bool emergency\n  ) public {\n...\npendingFlashDecision[target][sender].unlockTime += block.timestamp;\n...\n}\n",
                    "//solidity\npendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10000+100=10100\n",
                    "//solidity\npendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10100+10500=20600\n"
                ],
                "Type": " Incorrect  unlockTime  can DOS  withdrawGovernanceAsset ",
                "Description": "\nunlockTime is set incorrectly.\n\n\n1.  Navigate to contract at <https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol\n\n2.  Observe the assertGovernanceApproved function\n\nsolidity\nfunction assertGovernanceApproved(\n    address sender,\n    address target,\n    bool emergency\n  ) public {\n...\npendingFlashDecision[target][sender].unlockTime += block.timestamp;\n...\n}\n\n3.  Assume assertGovernanceApproved is called with sender x and target y and pendingFlashDecision[target][sender].unlockTime is 100 and block.timestamp is 10000 then\n\nsolidity\npendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10000+100=10100\n\n\n4.  Again assertGovernanceApproved is called with same argument after timestamp 10100. This time unlockTime is set to very high value  (assume block.timestamp is 10500). This is incorrect\n\nsolidity\npendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10100+10500=20600\n\n\n",
                "Repair": "\nUnlock time should be calculated like below:\nsolidity\nconstant public CONSTANT_UNLOCK_TIME = 1 days; // example\npendingFlashDecision[target][sender].unlockTime = CONSTANT_UNLOCK_TIME +  block.timestamp;\n\n\ngititGoro (Behodler) confirmed and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/228#issuecomment-1030494067):\n  Well spotted. This is a variant of a previously reported issue where the recommendation was to not allow flash governing a contract until stake has been withdrawn which is a safer fix.\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/228#issuecomment-1053393533):\n  I'm keeping this as Med instead of marking it as a duplicate of #156 as it did not illustrate the severe impact that it can cause.\n\n\n\n*\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\nfunction withdrawGovernanceAsset(address targetContract, address asset) public virtual {\n  require(\n    pendingFlashDecision[targetContract][msg.sender].asset == asset &&\n      pendingFlashDecision[targetContract][msg.sender].amount  0 &&\n      pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,\n    \"Limbo: Flashgovernance decision pending.\"\n  );\n  IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(\n    msg.sender,\n    pendingFlashDecision[targetContract][msg.sender].amount\n  );\n  delete pendingFlashDecision[targetContract][msg.sender];\n}\n"
                ],
                "Type": " Reentrancy on Flash Governance Proposal Withdrawal",
                "Description": "\nThe function withdrawGovernanceAsset()(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L142) is vulnerable to reentrancy, which would allow the attacker to drain the balance of the flashGoverananceConfig.asset.\n\nNote: this attack assumes the attacker may gain control of the execution flow in asset.tranfer() which is the case for many ERC20 tokens such as those that implement ERC777 but will depend on which asset is chosen in the configuration.\n\n\nwithdrawGovernanceAsset()(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L142) does not follow the check-effects-interactions pattern as seen from the following code snippet, where an external call is made before state modifications.\n\nsolidity\nfunction withdrawGovernanceAsset(address targetContract, address asset) public virtual {\n  require(\n    pendingFlashDecision[targetContract][msg.sender].asset == asset &&\n      pendingFlashDecision[targetContract][msg.sender].amount  0 &&\n      pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,\n    \"Limbo: Flashgovernance decision pending.\"\n  );\n  IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(\n    msg.sender,\n    pendingFlashDecision[targetContract][msg.sender].amount\n  );\n  delete pendingFlashDecision[targetContract][msg.sender];\n}\n\n\nThe attacker can exploit this vulnerability through the following steps:\n\n1.  assertGovernanceApproved(userA, target, false)\n2.  wait for unlockTime seconds to pass\n3.  withdrawGovernanceAsset(target, asset)  and gain control of the execution during asset.transfer()\n4.  repeat step 3) until there balance of FlashGovernanceArbiter is less than pendingFlashDecision[target][msg.sender].amount\n\n",
                "Repair": "\nThere are two possible mitigations, the first is to implement the check-effects-interactions patter. This involves doing as checks and state changes before making external calls. To implement this in the current context delete the pendingFlashDecision before making the external call as follows.\nsolidity\nfunction withdrawGovernanceAsset(address targetContract, address asset) public virtual {\n  require(\n    pendingFlashDecision[targetContract][msg.sender].asset == asset &&\n      pendingFlashDecision[targetContract][msg.sender].amount  0 &&\n      pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,\n    \"Limbo: Flashgovernance decision pending.\"\n  );\n  uint256 amount = pendingFlashDecision[targetContract][msg.sender].amount;\n  IERC20 asset = IERC20(pendingFlashDecision[targetContract][msg.sender].asset);\n  delete pendingFlashDecision[targetContract][msg.sender];\n  asset.transfer(msg.sender, amount);\n}\n\n\ngititGoro (Behodler) acknowledged and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/154#issuecomment-1029448627):\n  I do mention in the documentation that the only eligible assets are EYE and EYE LPs but that rule isn't enforced on a contract level which is why I'm acknowledging this rather than disputing it.\n Nonetheless it's not relevant to the context of Limbo\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./ERC677/ERC677.sol\";\nimport \"../contracts/DAO/Governable.sol\";\n\n///@author Justin Goro\n///@title Flan\n/**\n *@notice The reward token for Limbo. Flan can be minted without limit and is intended to converge on the price of DAI via various external incentives\n */\ncontract Flan is ERC677(\"Flan\", \"FLN\"), Governable {\n    event burnOnTransferFeeAdjusted(uint8 oldFee, uint8 newFee);\n    mapping(address => uint256) public mintAllowance; //type(uint).max == whitelist\n\n    uint8 public burnOnTransferFee = 0; //% between 1 and 100, recipient pays\n\n    constructor(address dao) Governable(dao) {}\n\n    /**\n    * @param fee - % between 1 and 100, recipient pays\n     */\n    function setBurnOnTransferFee(uint8 fee) public onlySuccessfulProposal {\n        _setBurnOnTransferFee(fee);\n    }\n\n    ///@notice flash governance technique for FOT change.\n    function incrementBurnOnTransferFee(int8 change)\n        public\n        governanceApproved(false)\n    {\n        uint8 newFee = uint8(int8(burnOnTransferFee) + change);\n        flashGoverner.enforceTolerance(newFee, burnOnTransferFee);\n        _setBurnOnTransferFee(newFee);\n    }\n\n    function _setBurnOnTransferFee(uint8 fee) internal {\n        uint8 priorFee = burnOnTransferFee;\n        burnOnTransferFee = fee > 100 ? 100 : fee;\n        emit burnOnTransferFeeAdjusted(priorFee, burnOnTransferFee);\n    }\n\n    ///@notice grants unlimited minting power to a contract\n    ///@param minter contract to be given unlimited minting power\n    ///@param enabled minting power enabled or disabled\n    function whiteListMinting(address minter, bool enabled)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = enabled ? type(uint256).max : 0;\n    }\n\n    ///@notice metered minting power. Useful for once off minting\n    function increaseMintAllowance(address minter, uint256 _allowance)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = mintAllowance[minter] + _allowance;\n    }\n\n    ///@notice minting of flan open to approved minters and LimboDAO\n    ///@param recipient address to receive flan\n    ///@param amount amount of flan to be minted \n    function mint(address recipient, uint256 amount) public returns (bool) {\n        uint256 allowance = mintAllowance[_msgSender()];\n        require(\n            _msgSender() == owner() || allowance >= amount,\n            \"Flan: Mint allowance exceeded\"\n        );\n        approvedMint(recipient, amount, _msgSender(), allowance);\n        return true;\n    }\n\n    function approvedMint(\n        address recipient,\n        uint256 amount,\n        address minter,\n        uint256 allowance\n    ) internal {\n        _mint(recipient, amount);\n        if (allowance < type(uint256).max && minter != owner()) {\n            mintAllowance[minter] = mintAllowance[minter] - amount;\n        }\n    }\n\n    function safeTransfer(address _to, uint256 _amount) external {\n        uint256 flanBal = balanceOf(address(this));\n        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;\n        _transfer(_msgSender(), _to, flanToTransfer);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 fee = (burnOnTransferFee * amount) / 100;\n\n        _totalSupply = _totalSupply - fee;\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount - fee;\n\n        emit Transfer(sender, recipient, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./facades/UniPairLike.sol\";\nimport \"./facades/BehodlerLike.sol\";\nimport \"./DAO/Governable.sol\";\n// import \"hardhat/console.sol\";\nimport \"./ERC677/ERC20Burnable.sol\";\nimport \"./facades/FlanLike.sol\";\nimport \"./testing/realUniswap/interfaces/IUniswapV2Factory.sol\";\nimport \"./facades/AMMHelper.sol\";\n\ncontract BlackHole {}\n\n///@Title Uniswap V2 helper for managing Flan liquidity on Uniswap V2, Sushiswap and any other compatible AMM\n///@author Justin Goro\n/**@notice Flan liquidity is boosted on Uniswap (or Sushiswap) via open market operations at the point of a token migration.\n  * UniswapHelper handles all the mechanics as well managing a just-in-time (Justin Time?) oracle\n */\ncontract UniswapHelper is Governable, AMMHelper {\n  address limbo;\n\n  struct UniVARS {\n    UniPairLike Flan_SCX_tokenPair;\n    address behodler;\n    address blackHole;\n    address flan;\n    uint256 divergenceTolerance;\n    uint256 minQuoteWaitDuration;\n    address DAI;\n    uint8 precision; // behodler uses a binary search. The higher this number, the more precise\n    IUniswapV2Factory factory;\n    uint8 priceBoostOvershoot; //percentage (0-100) for which the price must be overcorrected when strengthened to account for other AMMs\n  }\n\n  struct FlanQuote {\n    uint256 DaiScxSpotPrice;\n    uint256 DaiBalanceOnBehodler;\n    uint256 blockProduced;\n  }\n\n  /**@dev the Dai SCX price and the Dai balance on Behodler are both sampled twice before a migration can occur. \n  * The two samples have to be spaced a minimum duration and have to be the same values (within an error threshold). The objective here is to make price manipulation untenably expensive for an attacker\n  * so that the mining power expended (or the opportunity cost of eth staked) far exceeds the benefit to manipulating Limbo.\n  * The assumption of price stability isn't a bug because migrations aren't required to happen frequently. Instead if natural price drift occurs for non malicious reasons,\n  * the migration can be reattempted until a period of sufficient calm allows for migration. If a malicious actor injects volatility in order to prevent migration, by the principle\n  * of antifragility, they're doing the entire Ethereum ecosystem a service at their own expense.\n  */\n  FlanQuote[2] public latestFlanQuotes; //0 is latest\n\n  UniVARS VARS;\n\n  //not sure why codebases don't use keyword ether but I'm reluctant to entirely part with that tradition for now.\n  uint256 constant EXA = 1e18;\n\n  //needs to be updated for future Martian, Lunar and Venusian blockchains although I suspect Lunar colonies will be very Terracentric because of low time lag.\n  uint256 constant year = (1 days * 365);\n\n  /*\n    instead of relying on oracles, we simply require snapshots of important \n    prices to be taken at intervals far enough apart.\n    If an attacker wishes to overstate or understate a price through market manipulation,\n    they'd have to keep it out of equilibrium over the span of the two snapshots or they'd\n    have to time the manipulation to happen as the snapshots occur. As a miner,\n    they could do this through transaction ordering but they'd have to win two blocks at precise moments\n    which is statistically highly unlikely. \n    The snapshot enforcement can be hindered by false negatives. Natural price variation, for instance, but the cost\n    of this is just having to snapshot again when the market is calmer. Since migration is not not time sensitive,\n    this is a cost worth bearing.\n    */\n  modifier ensurePriceStability() {\n    _ensurePriceStability();\n    _;\n  }\n\n  modifier onlyLimbo() {\n    require(msg.sender == limbo);\n    _;\n  }\n\n  constructor(address _limbo, address limboDAO) Governable(limboDAO) {\n    limbo = _limbo;\n    VARS.blackHole = address(new BlackHole());\n    VARS.factory = IUniswapV2Factory(address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f));\n    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n  }\n\n  ///@notice LP tokens minted during migration are discarded.\n  function blackHole() public view returns (address) {\n    return VARS.blackHole;\n  }\n\n  ///@notice Uniswap factory contract\n  function setFactory(address factory) public {\n    require(block.chainid != 1, \"Uniswap factory hardcoded on mainnet\");\n    VARS.factory = IUniswapV2Factory(factory);\n  }\n\n  ///@dev Only for testing: On mainnet Dai has a fixed address.\n  function setDAI(address dai) public {\n    require(block.chainid != 1, \"DAI hardcoded on mainnet\");\n    VARS.DAI = dai;\n  }\n\n  ///@notice main configuration function.\n  ///@dev We prefer to use configuration functions rather than a constructor for a number of reasons.\n  ///@param _limbo Limbo contract\n  ///@param FlanSCXPair The Uniswap flan/SCX pair\n  ///@param behodler Behodler AMM\n  ///@param flan The flan token\n  ///@param divergenceTolerance The amount of price difference between the two quotes that is tolerated before a migration is attempted \n  ///@param minQuoteWaitDuration The minimum duration between the sampling of oracle data used for migration\n  ///@param precision In order to query the tokens redeemed by a quantity of SCX, Behodler performs a binary search. Precision refers to the max iterations of the search.\n  ///@param priceBoostOvershoot Flan targets parity with Dai. If we set Flan to equal Dai then between migrations, it will always be below Dai. Overshoot gives us some runway by intentionally \"overshooting\" the price\n  function configure(\n    address _limbo,\n    address FlanSCXPair,\n    address behodler,\n    address flan,\n    uint256 divergenceTolerance,\n    uint256 minQuoteWaitDuration,\n    uint8 precision,\n    uint8 priceBoostOvershoot\n  ) public onlySuccessfulProposal {\n    limbo = _limbo;\n    VARS.Flan_SCX_tokenPair = UniPairLike(FlanSCXPair);\n    VARS.behodler = behodler;\n    VARS.flan = flan;\n    require(divergenceTolerance >= 100, \"Divergence of 100 is parity\");\n    VARS.divergenceTolerance = divergenceTolerance;\n    VARS.minQuoteWaitDuration = minQuoteWaitDuration;\n    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    VARS.precision = precision == 0 ? precision : precision;\n    require(priceBoostOvershoot < 100, \"Set overshoot to number between 1 and 100.\");\n    VARS.priceBoostOvershoot = priceBoostOvershoot;\n  }\n\n  ///@notice Samples the two values required for migration. Must be called twice before migration can occur.\n  function generateFLNQuote() public override {\n    latestFlanQuotes[1] = latestFlanQuotes[0];\n    (\n      latestFlanQuotes[0].DaiScxSpotPrice,\n      latestFlanQuotes[0].DaiBalanceOnBehodler\n    ) = getLatestFLNQuote();\n    latestFlanQuotes[0].blockProduced = block.number;\n  }\n\n  function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {\n    uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(\n      VARS.DAI,\n      10000,\n      1 ether,\n      VARS.precision\n    );\n    dai_scx = (daiToRelease * EXA) / (1 ether);\n\n    daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);\n  }\n\n  ///@notice When tokens are migrated to Behodler, SCX is generated. This SCX is used to boost Flan liquidity and nudge the price of Flan back to parity with Dai\n  ///@param rectangleOfFairness refers to the quantity of SCX held back to be used for open market Flan stabilizing operations\n  ///@dev makes use of price tilting. Be sure to understand the concept of price tilting before trying to understand the final if statement.\n  function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {\n    uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));\n\n    //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.\n    //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes\n    require((localSCXBalance * 100) / rectangleOfFairness == 98, \"EM\");\n    rectangleOfFairness = localSCXBalance;\n\n    //get DAI per scx\n    uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));\n    uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;\n\n    //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.\n    uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);\n    address pair = address(VARS.Flan_SCX_tokenPair);\n    uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);\n\n    if (existingFlanOnLP < DesiredFinalFlanOnLP) {\n      uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;\n\n      flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;\n      FlanLike(VARS.flan).mint(pair, flanToMint);\n      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);\n      {\n        lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);\n      }\n    } else {\n      uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();\n\n      FlanLike(VARS.flan).mint(pair, minFlan + 2);\n      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);\n      lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);\n    }\n    //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.\n    _zeroOutQuotes();\n  }\n\n  ///@notice helper function for converting a desired APY into a flan per second (FPS) statistic\n  ///@param minAPY Here APY refers to the dollar value of flan relative to the dollar value of the threshold\n  ///@param daiThreshold The DAI value of the target threshold to list on Behodler. Threshold is an approximation of the AVB on Behodler\n  function minAPY_to_FPS(\n    uint256 minAPY, //divide by 10000 to get percentage\n    uint256 daiThreshold\n  ) public override view ensurePriceStability returns (uint256 fps) {\n    daiThreshold = daiThreshold == 0 ? latestFlanQuotes[0].DaiBalanceOnBehodler : daiThreshold;\n    // console.log(\"DAI threshold %s\", daiThreshold);\n    uint256 returnOnThreshold = (minAPY * daiThreshold) / 1e4;\n    fps = returnOnThreshold / (year);\n  }\n\n  ///@notice Buys Flan with a specified token, apportions 1% of the purchased Flan to the caller and burns the rest.\n  ///@param inputToken The token used to buy Flan\n  ///@param amount amount of input token used to buy Flan\n  ///@param recipient receives 1% of Flan purchased as an incentive to call this function regularly\n  ///@dev Assumes a pair for Flan/InputToken exists on Uniswap\n  function buyFlanAndBurn(\n    address inputToken,\n    uint256 amount,\n    address recipient\n  ) public override {\n    address pair = VARS.factory.getPair(inputToken, VARS.flan);\n\n    uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);\n    uint256 inputBalance = IERC20(inputToken).balanceOf(pair);\n\n    uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);\n    uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;\n    uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;\n    IERC20(inputToken).transfer(pair, amount);\n    UniPairLike(pair).swap(amount0Out, amount1Out, address(this), \"\");\n    uint256 reward = (amountOut / 100);\n    ERC20Burnable(VARS.flan).transfer(recipient, reward);\n    ERC20Burnable(VARS.flan).burn(amountOut - reward);\n  }\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountOut) {\n    uint256 amountInWithFee = amountIn * 997;\n    uint256 numerator = amountInWithFee * reserveOut;\n    uint256 denominator = reserveIn * 1000 + amountInWithFee;\n    amountOut = numerator / denominator;\n  }\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountIn) {\n    uint256 numerator = reserveIn * amountOut * 1000;\n    uint256 denominator = (reserveOut - amountOut) * 997;\n    amountIn = (numerator / denominator) + 1;\n  }\n\n  function _zeroOutQuotes() internal {\n    delete latestFlanQuotes[0];\n    delete latestFlanQuotes[1];\n  }\n\n  //the purpose of the divergence code is to bring the robustness of a good oracle without requiring an oracle\n  function _ensurePriceStability() internal view {\n    FlanQuote[2] memory localFlanQuotes; //save gas\n    localFlanQuotes[0] = latestFlanQuotes[0];\n    localFlanQuotes[1] = latestFlanQuotes[1];\n\n    uint256 daiSCXSpotPriceDivergence = localFlanQuotes[0].DaiScxSpotPrice > localFlanQuotes[1].DaiScxSpotPrice\n      ? (localFlanQuotes[0].DaiScxSpotPrice * 100) / localFlanQuotes[1].DaiScxSpotPrice\n      : (localFlanQuotes[1].DaiScxSpotPrice * 100) / localFlanQuotes[0].DaiScxSpotPrice;\n\n    uint256 daiBalanceDivergence = localFlanQuotes[0].DaiBalanceOnBehodler > localFlanQuotes[1].DaiBalanceOnBehodler\n      ? (localFlanQuotes[0].DaiBalanceOnBehodler * 100) / localFlanQuotes[1].DaiBalanceOnBehodler\n      : (localFlanQuotes[1].DaiBalanceOnBehodler * 100) / localFlanQuotes[0].DaiBalanceOnBehodler;\n\n    // console.log(\"dai balance divergence %s\", daiBalanceDivergence);\n    require(\n      daiSCXSpotPriceDivergence < VARS.divergenceTolerance && daiBalanceDivergence < VARS.divergenceTolerance,\n      \"EG\"\n    );\n\n    require(\n      localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration &&\n        localFlanQuotes[1].blockProduced > 0,\n      \"EH\"\n    );\n  }\n}\n\n\n",
        "CodeNames": [
            "Flan.sol",
            "UniswapHelper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-06",
                "Location": [
                    "//solidity\nfunction assertGovernanceApproved(\n  address sender,\n  address target,\n  bool emergency\n) public {\n  if (\n    IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&\n    pendingFlashDecision[target][sender].unlockTime < block.timestamp\n  ) {\n    require(\n      emergency || (block.timestamp security.lastFlashGovernanceAct  security.epochSize),\n      \"Limbo: flash governance disabled for rest of epoch\"\n    );\n    pendingFlashDecision[target][sender] = flashGovernanceConfig;\n    pendingFlashDecision[target][sender].unlockTime += block.timestamp;\n\n    security.lastFlashGovernanceAct = block.timestamp;\n    emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);\n  } else {\n    revert(\"LIMBO: governance decision rejected.\");\n  }\n}\n"
                ],
                "Type": " Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request",
                "Description": "\nUsers who have not called withdrawGovernanceAsset()(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L142)  after  they have locked their tokens from a previous proposal (i.e. assertGovernanceApproved(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60)), will lose their tokens if assertGovernanceApproved()(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) is called again with the same target and sender.\n\nThe sender will lose pendingFlashDecision[target][sender].amount tokens and the tokens will become unaccounted for and locked in the contract. Since the new amount is not added to the previous amount, instead the previous amount is overwritten with the new amount.\n\nThe impact of this is worsened by another vulnerability, that is assertGovernanceApproved()(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) is a public function and may be called by any arbitrary user so long as the sender field has called approve() for FlashGovernanceArbiter on the ERC20 token. This would allow an attacker to make these tokens inaccessible for any arbitrary sender.\n\n\nIn assertGovernanceApproved()(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) as seen below, the linependingFlashDecision[target][sender] = flashGovernanceConfig will overwrite the previous contents. Thereby, making any previous rewards unaccounted for and inaccessible to anyone.\n\nNote that we must wait pendingFlashDecision[target][sender].unlockTime between calls.\nsolidity\nfunction assertGovernanceApproved(\n  address sender,\n  address target,\n  bool emergency\n) public {\n  if (\n    IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&\n    pendingFlashDecision[target][sender].unlockTime < block.timestamp\n  ) {\n    require(\n      emergency || (block.timestamp security.lastFlashGovernanceAct  security.epochSize),\n      \"Limbo: flash governance disabled for rest of epoch\"\n    );\n    pendingFlashDecision[target][sender] = flashGovernanceConfig;\n    pendingFlashDecision[target][sender].unlockTime += block.timestamp;\n\n    security.lastFlashGovernanceAct = block.timestamp;\n    emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);\n  } else {\n    revert(\"LIMBO: governance decision rejected.\");\n  }\n}\n\n",
                "Repair": "\nConsider updating the initial if statement to ensure the pendingFlashDecision for that target and sender is empty, that is:\nsolidity\nfunction assertGovernanceApproved(\n  address sender,\n  address target,\n  bool emergency\n) public {\n  if (\n    IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&\n    pendingFlashDecision[target][sender].unlockTime == 0\n  ) {\n...\n\nNote we cannot simply add the new amount to the previous amount incase the underlying asset has been changed.\n\ngititGoro (Behodler) confirmed and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/156#issuecomment-1029451025):\n  Excellent find! Thank you.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../ERC677/ERC677.sol\";\nimport \"../Flan.sol\";\nimport \"./ProposalFactory.sol\";\nimport \"../facades/SwapFactoryLike.sol\";\nimport \"../facades/UniPairLike.sol\";\nimport \"./Governable.sol\";\n\n// import \"hardhat/console.sol\";\n\nlibrary TransferHelper {\n  function ERC20NetTransfer(\n    address token,\n    address from,\n    address to,\n    int256 amount\n  ) public {\n    if (amount > 0) {\n      require(IERC20(token).transferFrom(from, to, uint256(amount)), \"LimboDAO: ERC20 transfer from failed.\");\n    } else {\n      require(IERC20(token).transfer(from, uint256(amount * (-1))), \"LimboDAO: ERC20 transfer failed.\");\n    }\n  }\n}\n\nenum FateGrowthStrategy {\n  straight,\n  directRoot,\n  indirectTwoRootEye\n}\n\nenum ProposalDecision {\n  voting,\n  approved,\n  rejected\n}\n\n///@title Limbo DAO\n///@author Justin Goro\n/**@notice\n *This is the first MicroDAO associated with MorgothDAO. A MicroDAO manages parameterization of running dapps without having\n *control over existential functionality. This is not to say that some of the decisions taken are not critical but that the domain\n *of influence is confined to the local Dapp - Limbo in this case.\n * LimboDAO has two forms of decision making: proposals and flash governance. For proposals, voting power is required. Voting power in LimboDAO is measured\n * by a points system called Fate. Staking EYE or an EYE based LP earns Fate at a quadratic rate. Fate can be used to list a proposal for voting or to vote.\n * Using Fate to make a governance decisions spens it out of existince. So Fate reflects the opportunity cost of staking.\n * Flash governance is for instant decision making that cannot wait for voting to occur. Best used for small tweaks to parameters or emergencies.\n * Flash governance requires a governance asset (EYE) be staked at the time of the execution. The asset cannot be withdrawn for a certain period of time,\n * allowing for Fate holders to vote on the legitimacy of the decision. If the decision is considered malicious, the staked EYE is burnt.\n */\n///@dev Contracts subject to LimboDAO must inherit the Governable abstract contract.\ncontract LimboDAO is Ownable {\n  event daoKilled(address newOwner);\n  event proposalLodged(address proposal, address proposer);\n  event voteCast(address voter, address proposal, int256 fateCast);\n  event assetApproval(address asset, bool appoved);\n  event proposalExecuted(address proposal, bool approved);\n  event assetBurnt(address burner, address asset, uint256 fateCreated);\n\n  using TransferHelper for address;\n  uint256 constant ONE = 1 ether;\n  uint256 precision = 1e9;\n\n  struct DomainConfig {\n    address limbo;\n    address flan;\n    address eye;\n    address fate;\n    bool live;\n    address flashGoverner;\n    address sushiFactory;\n    address uniFactory;\n  }\n\n  struct ProposalConfig {\n    uint256 votingDuration;\n    uint256 requiredFateStake;\n    address proposalFactory; //check this for creating proposals\n  }\n\n  struct ProposalState {\n    int256 fate;\n    ProposalDecision decision;\n    address proposer;\n    uint256 start;\n    Proposal proposal;\n  }\n\n  //rateCrate\n  struct FateState {\n    uint256 fatePerDay;\n    uint256 fateBalance;\n    uint256 lastDamnAdjustment;\n  }\n\n  struct AssetClout {\n    uint256 fateWeight;\n    uint256 balance;\n  }\n\n  DomainConfig public domainConfig;\n  ProposalConfig public proposalConfig;\n\n  /**@notice for staking EYE, we simply take the square root of staked amount.\n   * For LP tokens, only half the value of the token is EYE so it's tempting to take the square root for the EYE balance. However this punishes the holder by ignoring the cost incurred by supplying the other asset. Since the other asset at rest is equal in value to the EYE balance, we just multiply the calculation by 2.\n   */\n  mapping(address => FateGrowthStrategy) public fateGrowthStrategy;\n  mapping(address => bool) public assetApproved;\n  mapping(address => FateState) public fateState; //lateDate\n\n  //Fate is earned per day. Keeping track of relative staked values, we can increment user balance\n  mapping(address => mapping(address => AssetClout)) public stakedUserAssetWeight; //user->asset->weight\n\n  ProposalState public currentProposalState;\n  ProposalState public previousProposalState;\n\n  // Since staking EYE precludes it from earning Flan on Limbo, fateToFlan can optionally be set to a non zero number to allow fat holders to spend their fate for Flan.\n  uint256 public fateToFlan;\n\n  modifier isLive() {\n    require(domainConfig.live, \"LimboDAO: DAO is not live.\");\n    _;\n  }\n\n  function nextProposal() internal {\n    previousProposalState = currentProposalState;\n    currentProposalState.proposal = Proposal(address(0));\n    currentProposalState.fate = 0;\n    currentProposalState.decision = ProposalDecision.voting;\n    currentProposalState.proposer = address(0);\n    currentProposalState.start = 0;\n  }\n\n  modifier onlySuccessfulProposal() {\n    // console.log('onlySuccessfulProposal');\n    require(successfulProposal(msg.sender), \"LimboDAO: approve proposal\");\n    _;\n    //nextProposal();\n  }\n\n  ///@notice has a proposal successfully been approved?\n  function successfulProposal(address proposal) public view returns (bool) {\n    return\n      currentProposalState.decision == ProposalDecision.approved && proposal == address(currentProposalState.proposal);\n  }\n\n  modifier updateCurrentProposal() {\n    incrementFateFor(_msgSender());\n    if (address(currentProposalState.proposal) != address(0)) {\n      uint256 durationSinceStart = block.timestamp - currentProposalState.start;\n      if (\n        durationSinceStart >= proposalConfig.votingDuration && currentProposalState.decision == ProposalDecision.voting\n      ) {\n        if (currentProposalState.fate > 0) {\n          currentProposalState.decision = ProposalDecision.approved;\n          currentProposalState.proposal.orchestrateExecute();\n          fateState[currentProposalState.proposer].fateBalance += proposalConfig.requiredFateStake;\n        } else {\n          currentProposalState.decision = ProposalDecision.rejected;\n        }\n        emit proposalExecuted(\n          address(currentProposalState.proposal),\n          currentProposalState.decision == ProposalDecision.approved\n        );\n        nextProposal();\n      }\n    }\n    _;\n  }\n\n  modifier incrementFate() {\n    incrementFateFor(_msgSender());\n    _;\n  }\n\n  function incrementFateFor(address user) public {\n    FateState storage state = fateState[user];\n    state.fateBalance += (state.fatePerDay * (block.timestamp - state.lastDamnAdjustment)) / (1 days);\n    state.lastDamnAdjustment = block.timestamp;\n  }\n\n  ///@param limbo address of Limbo\n  ///@param flan address of Flan\n  ///@param eye address of EYE token\n  ///@param proposalFactory authenticates and instantiates valid proposals for voting\n  ///@param sushiFactory is the SushiSwap Factory contract\n  ///@param uniFactory is the UniSwapV2 Factory contract\n  ///@param flashGoverner oversees flash governance cryptoeconomics\n  ///@param precisionOrderOfMagnitude when comparing fractional values, it's not necessary to get every last digit right\n  ///@param sushiLPs valid EYE containing LP tokens elligible for earning Fate through staking\n  ///@param uniLPs valid EYE containing LP tokens elligible for earning Fate through staking\n  function seed(\n    address limbo,\n    address flan,\n    address eye,\n    address proposalFactory,\n    address sushiFactory,\n    address uniFactory,\n    address flashGoverner,\n    uint256 precisionOrderOfMagnitude,\n    address[] memory sushiLPs,\n    address[] memory uniLPs\n  ) public onlyOwner {\n    _seed(limbo, flan, eye, sushiFactory, uniFactory, flashGoverner);\n    proposalConfig.votingDuration = 2 days;\n    proposalConfig.requiredFateStake = 223 * ONE; //50000 EYE for 24 hours\n    proposalConfig.proposalFactory = proposalFactory;\n    precision = 10**precisionOrderOfMagnitude;\n    for (uint256 i = 0; i < sushiLPs.length; i++) {\n      require(UniPairLike(sushiLPs[i]).factory() == sushiFactory, \"LimboDAO: invalid Sushi LP\");\n      if (IERC20(eye).balanceOf(sushiLPs[i]) > 1000) assetApproved[sushiLPs[i]] = true;\n      fateGrowthStrategy[sushiLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;\n    }\n    for (uint256 i = 0; i < uniLPs.length; i++) {\n      require(UniPairLike(uniLPs[i]).factory() == uniFactory, \"LimboDAO: invalid Sushi LP\");\n      if (IERC20(eye).balanceOf(uniLPs[i]) > 1000) assetApproved[uniLPs[i]] = true;\n      fateGrowthStrategy[uniLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;\n    }\n  }\n\n  ///@notice allows Limbo to be governed by a new DAO\n  ///@dev functions marked by onlyOwner are governed by MorgothDAO\n  function killDAO(address newOwner) public onlyOwner isLive {\n    domainConfig.live = false;\n    Governable(domainConfig.flan).setDAO(newOwner);\n    Governable(domainConfig.limbo).setDAO(newOwner);\n    emit daoKilled(newOwner);\n  }\n\n  ///@notice optional conversion rate of Fate to Flan\n  function setFateToFlan(uint256 rate) public onlySuccessfulProposal {\n    fateToFlan = rate;\n  }\n\n  ///@notice caller spends their Fate to earn Flan\n  function convertFateToFlan(uint256 fate) public returns (uint256 flan) {\n    require(fateToFlan > 0, \"LimboDAO: Fate conversion to Flan disabled.\");\n    fateState[msg.sender].fateBalance -= fate;\n    flan = (fateToFlan * fate) / ONE;\n    Flan(domainConfig.flan).mint(msg.sender, flan);\n  }\n\n  /**@notice handles proposal lodging logic. A deposit of Fate is removed from the user. If the decision is a success, half the fate is returned.\n   *  This is to encourage only lodging of proposals that are likely to succeed.\n   *  @dev not for external calling. Use the proposalFactory to lodge a proposal instead.\n   */\n  function makeProposal(address proposal, address proposer) public updateCurrentProposal {\n    address sender = _msgSender();\n    require(sender == proposalConfig.proposalFactory, \"LimboDAO: only Proposal Factory\");\n    require(address(currentProposalState.proposal) == address(0), \"LimboDAO: active proposal.\");\n\n    fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2;\n    currentProposalState.proposal = Proposal(proposal);\n    currentProposalState.decision = ProposalDecision.voting;\n    currentProposalState.fate = 0;\n    currentProposalState.proposer = proposer;\n    currentProposalState.start = block.timestamp;\n    emit proposalLodged(proposal, proposer);\n  }\n\n  ///@notice handles proposal voting logic.\n  ///@param proposal contract to be voted on\n  ///@param fate positive is YES, negative is NO. Absolute value is deducted from caller.\n  function vote(address proposal, int256 fate) public incrementFate isLive {\n    require(\n      proposal == address(currentProposalState.proposal), //this is just to protect users with out of sync UIs\n      \"LimboDAO: stated proposal does not match current proposal\"\n    );\n    require(currentProposalState.decision == ProposalDecision.voting, \"LimboDAO: voting on proposal closed\");\n    if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration - 1 hours) {\n      int256 currentFate = currentProposalState.fate;\n      //check if voting has ended\n      if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) {\n        revert(\"LimboDAO: voting for current proposal has ended.\");\n      } else if (\n        //The following if statement checks if the vote is flipped by fate\n        fate * currentFate < 0 && //sign different\n        (fate + currentFate) * fate > 0 //fate flipped current fate onto the same side of zero as fate\n      ) {\n        //extend voting duration when vote flips decision. Suggestion made by community member\n        currentProposalState.start = currentProposalState.start + 2 hours;\n      }\n    }\n    uint256 cost = fate > 0 ? uint256(fate) : uint256(-fate);\n    fateState[_msgSender()].fateBalance = fateState[_msgSender()].fateBalance - cost;\n\n    currentProposalState.fate += fate;\n    emit voteCast(_msgSender(), proposal, fate);\n  }\n\n  ///@notice pushes the decision to execute a successful proposal. For convenience only\n  function executeCurrentProposal() public updateCurrentProposal {}\n\n  ///@notice parameterizes the voting\n  ///@param requiredFateStake the amount of Fate required to lodge a proposal\n  ///@param votingDuration the duration of voting in seconds\n  ///@param proposalFactory the address of the proposal factory\n  function setProposalConfig(\n    uint256 votingDuration,\n    uint256 requiredFateStake,\n    address proposalFactory\n  ) public onlySuccessfulProposal {\n    proposalConfig.votingDuration = votingDuration;\n    proposalConfig.requiredFateStake = requiredFateStake;\n    proposalConfig.proposalFactory = proposalFactory;\n  }\n\n  ///@notice Assets approved for earning Fate\n  function setApprovedAsset(address asset, bool approved) public onlySuccessfulProposal {\n    assetApproved[asset] = approved;\n    fateGrowthStrategy[asset] = FateGrowthStrategy.indirectTwoRootEye;\n    emit assetApproval(asset, approved);\n  }\n\n  ///@notice handles staking logic for EYE and EYE based assets so that correct rate of fate is earned.\n  ///@param finalAssetBalance after staking, what is the final user balance on LimboDAO of the asset in question\n  ///@param finalEYEBalance if EYE is being staked, this value is the same as finalAssetBalance but for LPs it's about half\n  ///@param rootEYE offload high gas arithmetic to the client. Cheap to verify. Square root in fixed point requires Babylonian algorithm\n  ///@param asset the asset being staked\n  function setEYEBasedAssetStake(\n    uint256 finalAssetBalance,\n    uint256 finalEYEBalance,\n    uint256 rootEYE,\n    address asset\n  ) public isLive incrementFate {\n    require(assetApproved[asset], \"LimboDAO: illegal asset\");\n    address sender = _msgSender();\n    FateGrowthStrategy strategy = fateGrowthStrategy[asset];\n\n    //verifying that rootEYE value is accurate within precision.\n    uint256 rootEYESquared = rootEYE * rootEYE;\n    uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);\n    require(\n      rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,\n      \"LimboDAO: Stake EYE invariant.\"\n    );\n    AssetClout storage clout = stakedUserAssetWeight[sender][asset];\n    fateState[sender].fatePerDay -= clout.fateWeight;\n    uint256 initialBalance = clout.balance;\n    //EYE\n    if (strategy == FateGrowthStrategy.directRoot) {\n      require(finalAssetBalance == finalEYEBalance, \"LimboDAO: staking eye invariant.\");\n      require(asset == domainConfig.eye);\n\n      clout.fateWeight = rootEYE;\n      clout.balance = finalAssetBalance;\n      fateState[sender].fatePerDay += rootEYE;\n    } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {\n      //LP\n      clout.fateWeight = 2 * rootEYE;\n      fateState[sender].fatePerDay += clout.fateWeight;\n\n      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\n      require(actualEyeBalance > 0, \"LimboDAO: No EYE\");\n      uint256 totalSupply = IERC20(asset).totalSupply();\n      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;\n      uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);\n      finalEYEBalance /= precision;\n      require(\n        finalEYEBalance == impliedEye, //precision cap\n        \"LimboDAO: stake invariant check 2.\"\n      );\n      clout.balance = finalAssetBalance;\n    } else {\n      revert(\"LimboDAO: asset growth strategy not accounted for\");\n    }\n    int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);\n    asset.ERC20NetTransfer(sender, address(this), netBalance);\n  }\n\n  /**\n   *@notice Acquiring enough fate to either influence a decision or to lodge a proposal can take very long.\n   * If a very important decision has to be acted on via a proposal, the option exists to buy large quantities for fate instantly by burning an EYE based asset\n   * This may be necessary if a vote is nearly complete by the looming outcome is considered unacceptable.\n   * While Fate accumulation is quadratic for staking, burning is linear and subject to a factor of 10. This gives whales effective veto power but at the cost of a permanent\n   * loss of EYE.\n   *@param asset the asset to burn and can be EYE or EYE based assets\n   *@param amount the amount of asset to burn\n   */\n  function burnAsset(address asset, uint256 amount) public isLive incrementFate {\n    require(assetApproved[asset], \"LimboDAO: illegal asset\");\n    address sender = _msgSender();\n    require(ERC677(asset).transferFrom(sender, address(this), amount), \"LimboDAO: transferFailed\");\n    uint256 fateCreated = fateState[_msgSender()].fateBalance;\n    if (asset == domainConfig.eye) {\n      fateCreated = amount * 10;\n      ERC677(domainConfig.eye).burn(amount);\n    } else {\n      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\n      require(actualEyeBalance > 0, \"LimboDAO: No EYE\");\n      uint256 totalSupply = IERC20(asset).totalSupply();\n      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;\n      uint256 impliedEye = (eyePerUnit * amount) / ONE;\n      fateCreated = impliedEye * 20;\n    }\n    fateState[_msgSender()].fateBalance += fateCreated;\n    emit assetBurnt(_msgSender(), asset, fateCreated);\n  }\n\n  ///@notice grants unlimited Flan minting power to an address.\n  function approveFlanMintingPower(address minter, bool enabled) public onlySuccessfulProposal isLive {\n    Flan(domainConfig.flan).increaseMintAllowance(minter, enabled ? type(uint256).max : 0);\n  }\n\n  ///@notice call this after initial config is complete.\n  function makeLive() public onlyOwner {\n    require(\n      Governable(domainConfig.limbo).DAO() == address(this) && Governable(domainConfig.flan).DAO() == address(this),\n      \"LimboDAO: transfer ownership of limbo and flan.\"\n    );\n    domainConfig.live = true;\n  }\n\n  ///@notice if the DAO is being dismantled, it's necessary to transfer any owned items\n  function transferOwnershipOfThing(address thing, address destination) public onlySuccessfulProposal {\n    Ownable(thing).transferOwnership(destination);\n  }\n\n  function timeRemainingOnProposal() public view returns (uint256) {\n    require(currentProposalState.decision == ProposalDecision.voting, \"LimboDAO: proposal finished.\");\n    uint256 elapsed = block.timestamp - currentProposalState.start;\n    if (elapsed > proposalConfig.votingDuration) return 0;\n    return proposalConfig.votingDuration - elapsed;\n  }\n\n  /**@notice seed is a goro idiom for initialize that you tend to find in all the dapps I've written.\n   * I prefer initialization funcitons to parameterized solidity constructors for reasons beyond the scope of this comment.\n   */\n  function _seed(\n    address limbo,\n    address flan,\n    address eye,\n    address sushiFactory,\n    address uniFactory,\n    address flashGoverner\n  ) internal {\n    domainConfig.limbo = limbo;\n    domainConfig.flan = flan;\n    domainConfig.eye = eye;\n    domainConfig.uniFactory = uniFactory;\n    domainConfig.sushiFactory = sushiFactory;\n    domainConfig.flashGoverner = flashGoverner;\n    assetApproved[eye] = true;\n    fateGrowthStrategy[eye] = FateGrowthStrategy.directRoot;\n  }\n\n  function getFlashGoverner() external view returns (address) {\n    return domainConfig.flashGoverner;\n  }\n}\n\n\n",
        "CodeNames": [
            "LimboDAO.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-07",
                "Location": [
                    "fate",
                    "burnAsset",
                    "setEYEBasedAssetStake"
                ],
                "Type": " LP pricing formula is vulnerable to flashloan manipulation",
                "Description": "\nThe LP pricing formula used in the burnAsset function of LimboDAO is vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get more fate than he is supposed to with a relatively low cost.\n\nWith the large portion of fate he gets, he has more voting power to influence the system's decisions, or even he can convert his fate to Flan tokens for a direct profit.\n\n\nBelow is an example of how the attack works:\n\n1.  Suppose that there are 1000 EYE and 1000 LINK tokens in the UniswapV2 LINK-EYE pool. The pool's total supply is 1000, and the attacker has 100 LP tokens.\n2.  If the attacker burns his LP tokens, he earns 1000 * 100/1000 * 20 = 2000 amount of fate.\n3.  Instead, the attacker swaps in 1000 EYE and gets 500 LINK from the pool (according to x * y = k, ignoring fees for simplicity). Now the pool contains 2000 EYE and 500 LINK tokens.\n4.  After the manipulation, he burns his LP tokens and gets 2000 * 100/1000 * 20 = 4000 amount of fate.\n5.  Lastly, he swaps 500 LINK into the pool to get back his 1000 EYE.\n6.  Compared to Step 2, the attacker earns a double amount of fate by only paying the swapping fees to the pool. The more EYE tokens he swaps into the pool, the more fate he can get. This attack is practically possible by leveraging flashloans or flashswaps from other pools containing EYE tokens.\n\nThe setEYEBasedAssetStake function has the same issue of using a manipulatable LP pricing formula. For more detailed explanations, please refer to the analysis of the Cheese Bank attack(https://peckshield.medium.com/cheese-bank-incident-root-cause-analysis-d076bf87a1e7) and the Warp Finance attack(https://peckshield.medium.com/warpfinance-incident-root-cause-analysis-581a4869ee00).\n\nReferenced code:\nDAO/LimboDAO.sol#L356(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L356)\nDAO/LimboDAO.sol#L392(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L392)\n\n",
                "Repair": "\nUse a fair pricing formula for the LP tokens, for example, the one proposed by Alpha Finance(https://blog.alphafinance.io/fair-lp-token-pricing/).\n\ngititGoro (Behodler) confirmed and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/304#issuecomment-1035844748):\n  This is actually a good fate inflation vector especially when combined with the fateToFlan conversion\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/304#issuecomment-1053304725):\n  Good catch! A valid economic attack vector can potentially be exploited using flashloans.\n\n\n\n*\n\n \n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./ERC677/ERC677.sol\";\nimport \"../contracts/DAO/Governable.sol\";\n\n///@author Justin Goro\n///@title Flan\n/**\n *@notice The reward token for Limbo. Flan can be minted without limit and is intended to converge on the price of DAI via various external incentives\n */\ncontract Flan is ERC677(\"Flan\", \"FLN\"), Governable {\n    event burnOnTransferFeeAdjusted(uint8 oldFee, uint8 newFee);\n    mapping(address => uint256) public mintAllowance; //type(uint).max == whitelist\n\n    uint8 public burnOnTransferFee = 0; //% between 1 and 100, recipient pays\n\n    constructor(address dao) Governable(dao) {}\n\n    /**\n    * @param fee - % between 1 and 100, recipient pays\n     */\n    function setBurnOnTransferFee(uint8 fee) public onlySuccessfulProposal {\n        _setBurnOnTransferFee(fee);\n    }\n\n    ///@notice flash governance technique for FOT change.\n    function incrementBurnOnTransferFee(int8 change)\n        public\n        governanceApproved(false)\n    {\n        uint8 newFee = uint8(int8(burnOnTransferFee) + change);\n        flashGoverner.enforceTolerance(newFee, burnOnTransferFee);\n        _setBurnOnTransferFee(newFee);\n    }\n\n    function _setBurnOnTransferFee(uint8 fee) internal {\n        uint8 priorFee = burnOnTransferFee;\n        burnOnTransferFee = fee > 100 ? 100 : fee;\n        emit burnOnTransferFeeAdjusted(priorFee, burnOnTransferFee);\n    }\n\n    ///@notice grants unlimited minting power to a contract\n    ///@param minter contract to be given unlimited minting power\n    ///@param enabled minting power enabled or disabled\n    function whiteListMinting(address minter, bool enabled)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = enabled ? type(uint256).max : 0;\n    }\n\n    ///@notice metered minting power. Useful for once off minting\n    function increaseMintAllowance(address minter, uint256 _allowance)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = mintAllowance[minter] + _allowance;\n    }\n\n    ///@notice minting of flan open to approved minters and LimboDAO\n    ///@param recipient address to receive flan\n    ///@param amount amount of flan to be minted \n    function mint(address recipient, uint256 amount) public returns (bool) {\n        uint256 allowance = mintAllowance[_msgSender()];\n        require(\n            _msgSender() == owner() || allowance >= amount,\n            \"Flan: Mint allowance exceeded\"\n        );\n        approvedMint(recipient, amount, _msgSender(), allowance);\n        return true;\n    }\n\n    function approvedMint(\n        address recipient,\n        uint256 amount,\n        address minter,\n        uint256 allowance\n    ) internal {\n        _mint(recipient, amount);\n        if (allowance < type(uint256).max && minter != owner()) {\n            mintAllowance[minter] = mintAllowance[minter] - amount;\n        }\n    }\n\n    function safeTransfer(address _to, uint256 _amount) external {\n        uint256 flanBal = balanceOf(address(this));\n        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;\n        _transfer(_msgSender(), _to, flanToTransfer);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 fee = (burnOnTransferFee * amount) / 100;\n\n        _totalSupply = _totalSupply - fee;\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount - fee;\n\n        emit Transfer(sender, recipient, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./Governable.sol\";\nimport \"hardhat/console.sol\";\nimport \"../facades/Burnable.sol\";\n\n///@title Flash Governance Arbiter\n///@author Justin Goro\n/**@notice LimboDAO offers two forms of governance: flash and proposal. Proposals are contracts that have authorization to execute guarded functions on contracts that implement the Governable abstract contract.\n * Proposals require Fate to be put forward for voting and Fate is the spendable voting token.\n * Flash governance occurs in the duration of one transaction and is more appropriate for variable tweaking such as changing the Flan per Second or Threshold of a pool.\n * Flash governance requires an asset be deposited into an adjudication contract. The community can then vote, through a proposal, whether the decision was legitimate. If not, the deposit can be slashed\n * By default, the asset is EYE.\n */\ncontract FlashGovernanceArbiter is Governable {\n  /**\n   * @param actor user making flash governance decision\n   * @param deposit_asset is the asset type put up as decision collateral. Must be burnable.\n   * @param amount is the amount of the deposit_asset to be put up as decision collateral.\n   * @param target is the contract that will be affected by the flash governance decision.\n   */\n  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);\n\n  mapping(address => bool) enforceLimitsActive;\n\n  constructor(address dao) Governable(dao) {}\n\n  struct FlashGovernanceConfig {\n    address asset;\n    uint256 amount;\n    uint256 unlockTime;\n    bool assetBurnable;\n  }\n\n  //Note: epoch settings prevent DOS attacks. Change tolerance curtails the damage of bad flash governance.\n  struct SecurityParameters {\n    uint8 maxGovernanceChangePerEpoch; //prevents flash governance from wrecking the incentives.\n    uint256 epochSize; //only one flash governance action can happen per epoch to prevent governance DOS\n    uint256 lastFlashGovernanceAct;\n    uint8 changeTolerance; //1-100 maximum percentage any numeric variable can be changed through flash gov\n  }\n\n  //the current parameters determining the rules of flash governance\n  FlashGovernanceConfig public flashGovernanceConfig;\n  SecurityParameters public security;\n\n  /*For every decision, we record the config at the time of the decision. This allows governance to change the rules\n   *without undermining the terms under which pending decisions were made.\n   */\n  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; //contract->user->config\n\n  /**\n   *@notice An attempt is made to withdraw the current deposit requirement.\n   * For a given user, flash governance decisions can only happen one at a time\n   *@param sender is the user making the flash governance decision\n   *@param target is the contract that will be affected by the flash governance decision.\n   *@param emergency flash governance decisions are restricted in frequency per epoch but some decisions are too important. These can be marked emergency.\n   *@dev be very careful about setting emergency to true. Only decisions which preclude the execution of other flash governance decisions should be considered candidtes for emergency.\n   */\n  function assertGovernanceApproved(\n    address sender,\n    address target,\n    bool emergency\n  ) public {\n    if (\n      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&\n      pendingFlashDecision[target][sender].unlockTime < block.timestamp\n    ) {\n      require(\n        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),\n        \"Limbo: flash governance disabled for rest of epoch\"\n      );\n      pendingFlashDecision[target][sender] = flashGovernanceConfig;\n      pendingFlashDecision[target][sender].unlockTime += block.timestamp;\n\n      security.lastFlashGovernanceAct = block.timestamp;\n      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);\n    } else {\n      revert(\"LIMBO: governance decision rejected.\");\n    }\n  }\n\n  /**\n   *@param asset is the asset type put up as decision collateral. Must be burnable.\n   *@param amount is the amount of the deposit_asset to be put up as decision collateral.\n   *@param unlockTime is the duration for which the deposit collateral must be locked in order to give the community time to weigh up the decision\n   *@param assetBurnable is a technical parameter to determined the manner in which burning should occur. Non burnable assets are just no longer accounted for and accumulate within this contract.\n   */\n  function configureFlashGovernance(\n    address asset,\n    uint256 amount,\n    uint256 unlockTime,\n    bool assetBurnable\n  ) public virtual onlySuccessfulProposal {\n    flashGovernanceConfig.asset = asset;\n    flashGovernanceConfig.amount = amount;\n    flashGovernanceConfig.unlockTime = unlockTime;\n    flashGovernanceConfig.assetBurnable = assetBurnable;\n  }\n\n  /**\n    @param maxGovernanceChangePerEpoch max number of flash governance decisions per epoch to prevent DOS\n    @param epochSize is the duration of a flash governance epoch and reflects proposal deliberation durations\n    @param changeTolerance is the amount by which a variable can be changed through flash governance.\n    */\n  function configureSecurityParameters(\n    uint8 maxGovernanceChangePerEpoch,\n    uint256 epochSize,\n    uint8 changeTolerance\n  ) public virtual onlySuccessfulProposal {\n    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;\n    security.epochSize = epochSize;\n    require(security.changeTolerance < 100, \"Limbo: % between 0 and 100\");\n    security.changeTolerance = changeTolerance;\n  }\n\n  /**\n    @notice LimboDAO proposals for burning flash governance collateral act through this function\n    @param targetContract is the contract that is affected by the flash governance decision.\n    @param user is the user who made the flash governance decision\n    @param asset is the collateral asset to be burnt\n    @param amount is the amount of the collateral to be burnt\n    */\n  function burnFlashGovernanceAsset(\n    address targetContract,\n    address user,\n    address asset,\n    uint256 amount\n  ) public virtual onlySuccessfulProposal {\n    if (pendingFlashDecision[targetContract][user].assetBurnable) {\n      Burnable(asset).burn(amount);\n    }\n\n    pendingFlashDecision[targetContract][user] = flashGovernanceConfig;\n  }\n\n  /**\n   *@notice Assuming a flash governance decision was not rejected during the lock window, the user is free to withdraw their asset\n   *@param targetContract is the contract that is affected by the flash governance decision.\n   *@param asset is the collateral asset to be withdrawn\n   */\n  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {\n    require(\n      pendingFlashDecision[targetContract][msg.sender].asset == asset &&\n        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&\n        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,\n      \"Limbo: Flashgovernance decision pending.\"\n    );\n    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(\n      msg.sender,\n      pendingFlashDecision[targetContract][msg.sender].amount\n    );\n    delete pendingFlashDecision[targetContract][msg.sender];\n  }\n\n  /**\n   *@notice when a governance function is executed, it can enforce change limits on variables in the event that the execution is through flash governance\n   * However, a proposal is subject to the full deliberation of the DAO and such limits may thwart good governance.\n   * @param enforce for the given context, set whether variable movement limits are enforced or not.\n   */\n  function setEnforcement(bool enforce) public {\n    enforceLimitsActive[msg.sender] = enforce;\n  }\n\n  ///@dev for negative values, relative comparisons need to be calculated correctly.\n  function enforceToleranceInt(int256 v1, int256 v2) public view {\n    if (!configured) return;\n    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);\n    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);\n    enforceTolerance(uv1, uv2);\n  }\n\n  ///@notice Allows functions to enforce maximum limits on a per variable basis\n  ///@dev the 100 factor is just to allow for simple percentage comparisons without worrying about enormous precision.\n  function enforceTolerance(uint256 v1, uint256 v2) public view {\n    if (!configured || !enforceLimitsActive[msg.sender]) return;\n    //bonus points for readability\n    if (v1 > v2) {\n      if (v2 == 0) require(v1 <= 1, \"FE1\");\n      else require(((v1 - v2) * 100) < security.changeTolerance * v1, \"FE1\");\n    } else {\n      if (v1 == 0) require(v2 <= 1, \"FE1\");\n      else require(((v2 - v1) * 100) < security.changeTolerance * v1, \"FE1\");\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "Flan.sol",
            "FlashGovernanceArbiter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nfunction burnFlashGovernanceAsset(\n  address targetContract,\n  address user,\n  address asset,\n  uint256 amount\n) public virtual onlySuccessfulProposal {\n  if (pendingFlashDecision[targetContract][user].assetBurnable) {\n    Burnable(asset).burn(amount);\n  }\n\n  pendingFlashDecision[targetContract][user] = flashGovernanceConfig;\n}\n"
                ],
                "Type": " Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance",
                "Description": "\nThe proposal to burn a user's tokens for a flash governance proposal does not result in the user losing any funds and may in fact unlock their funds sooner.\n\n\nThe function burnFlashGovernanceAsset()(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L124)  will simply overwrite the user's state with pendingFlashDecision[targetContract][user] = flashGovernanceConfig; as seen below.\nsolidity\nfunction burnFlashGovernanceAsset(\n  address targetContract,\n  address user,\n  address asset,\n  uint256 amount\n) public virtual onlySuccessfulProposal {\n  if (pendingFlashDecision[targetContract][user].assetBurnable) {\n    Burnable(asset).burn(amount);\n  }\n\n  pendingFlashDecision[targetContract][user] = flashGovernanceConfig;\n}\n\nSince flashGovernanceConfig is not modified in BurnFlashStakeDeposit.execute()(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/BurnFlashStakeDeposit.sol#L39) the user will have amount set to the current config amount which is likely what they originally transferred in {assertGovernanceApproved()](<https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60).\n\nFurthermore, unlockTime will be set to the config unlock time.  The config unlock time is the length of time in seconds that proposal should lock tokens for not the future timestamp. That is unlock time may be say 7 days rather than now + 7 days. As a result the check in withdrawGovernanceAsset()(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L146)  pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp, will always pass unless there is a significant misconfiguration.\n\n",
                "Repair": "\nConsider deleting the user's data (i.e. delete pendingFlashDecision[targetContract][user]) rather than setting it to the config. This would ensure the user cannot withraw any funds afterwards.\n\nAlternatively, only update pendingFlashDecision[targetContract][user].amount to subtract the amount sent as a function parameter and leave the remaining fields untouched.\n\ngititGoro (Behodler) confirmed(https://github.com/code-423n4/2022-01-behodler-findings/issues/157)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./facades/FlanLike.sol\";\nimport \"./facades/PyroTokenLike.sol\";\nimport \"./DAO/Governable.sol\";\nimport \"./ERC677/ERC20Burnable.sol\";\nimport \"./facades/UniPairLike.sol\";\nimport \"hardhat/console.sol\";\n\n///@title FlanBackstop (placeholder name)\n///@author Justin Goro\n/**\n * @notice Initially Flan's liquidity may be fairly low, limiting Limbo's ability to reward souls. Flan backstop accepts stablecoins in return for minting Pyroflan.\n *Under the hood a smaller quantity of Flan is minted and paired with the stablecoin in Uniswap in order to tilt the price of Flan higher while incresaing liquidity.\n * The same operation is performed with PyroFlan\n * The calling user then receives PyroFlan equal in value to the intial amount sent in but at the new price. A small premium is added.\n * The incentives facing the user: mint $X of PyroFlan with <$X of stablecoin, stake PyroFlan in Limbo for high APY, do not immediately dump because PyroFlan increases in value and because of 2% exit fee.\n * The incentives should be enough to encourage a gradual increase in pooled Flan and stablecoins, creating some minting runway for Limbo to accelerate.\n * In the future when Flan and Limbo are thriving and Flan is listed on Curve, we can create a version of this for Curve and Uniswap V3 in order to concentrate Flan liquidity and further cement stablecoin status.\n * Note: in this version, LP tokens generated are cast into the void. The argument of keeping them for fee revenue is negated by the impact on Flan. It would just be taking from Peter to give to Paul. \n */\n///@dev This contract uses Pyrotokens3. At the time of authoring, Pyrotokens3 implementation is incomplete and not fully tested but the interface (ABI) is locked.\ncontract FlanBackstop is Governable {\n  /**\n   *@param dao LimboDAO\n   *@param flan Flan address\n   *@param pyroFlan PyroFlan address\n   */\n  constructor(\n    address dao,\n    address flan,\n    address pyroFlan\n  ) Governable(dao) {\n    config.pyroFlan = pyroFlan;\n    config.flan = flan;\n    IERC20(flan).approve(pyroFlan, 2**256 - 1);\n  }\n\n  struct ConfigVars {\n    address flan;\n    address pyroFlan;\n    mapping(address => address) flanLPs;\n    mapping(address => address) pyroFlanLPs;\n    mapping(address => uint256) acceptableHighestPrice; //Highest tolerated Flan per stable\n    mapping(address => uint8) decimalPlaces; //USDC and USDT have 6 decimal places because large stablecoin transfers are exactly where you'd like to find accidental bugs\n  }\n\n  ConfigVars public config;\n\n  /**\n   *@param stablecoin One of the popular stablecoins such as USDC, USDT, MIM, OUSD etc.\n   *@param flanLP Uniswap V2 (or a fork such as Sushi) flan/Stablecoin LP\n   *@param pyroFlanLP Uniswap V2 (or a fork such as Sushi) pyroFlan/Stablecoin LP\n   *@param acceptableHighestPrice Since the prices are being read from balances, not oracles, the opportunity for price manipulation through flash loans exists. The community can put a circuit breaker in place to prevent such an exploit.\n   *@param decimalPlaces USDT and USDC do not conform to common ERC20 practice. \n   */\n  function setBacker(\n    address stablecoin,\n    address flanLP,\n    address pyroFlanLP,\n    uint256 acceptableHighestPrice,\n    uint8 decimalPlaces\n  ) external onlySuccessfulProposal {\n    config.flanLPs[stablecoin] = flanLP;\n    config.pyroFlanLPs[stablecoin] = pyroFlanLP;\n    config.acceptableHighestPrice[stablecoin] = acceptableHighestPrice;\n    config.decimalPlaces[stablecoin] = decimalPlaces;\n  }\n\n  /**\n  *@notice takes in a stablecoin, mints flan and pyroFlan and pairs with stablecoin in a Uniswap Pair to generate liquidity\n   *@param stablecoin Stablecoin with which to purchase\n   *@param amount amount in stablecoin wei units.\n   */\n  function purchasePyroFlan(address stablecoin, uint256 amount) external {\n    uint normalizedAmount = normalize(stablecoin, amount);\n    address flanLP = config.flanLPs[stablecoin];\n    address pyroFlanLP = config.pyroFlanLPs[stablecoin];\n    require(flanLP != address(0) && pyroFlanLP != address(0), \"BACKSTOP: configure stablecoin\");\n\n    uint256 balanceOfFlanBefore = IERC20(config.flan).balanceOf(flanLP);\n    uint256 balanceOfStableBefore = IERC20(stablecoin).balanceOf(flanLP);\n    uint256 priceBefore = (balanceOfFlanBefore * getMagnitude(stablecoin)) / balanceOfStableBefore;\n\n    //Price tilt pairs and mint liquidity\n    FlanLike(config.flan).mint(address(this), normalizedAmount / 2);\n    IERC20(config.flan).transfer(flanLP, normalizedAmount / 4);\n    IERC20(stablecoin).transferFrom(msg.sender, flanLP, amount / 2);\n\n    UniPairLike(flanLP).mint(address(this));\n    uint256 redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\n    PyroTokenLike(config.pyroFlan).mint(pyroFlanLP, normalizedAmount / 4);\n    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\n    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\n    IERC20(stablecoin).transferFrom(msg.sender, pyroFlanLP, amount / 2);\n    UniPairLike(pyroFlanLP).mint(address(this));\n\n    uint256 balanceOfFlan = IERC20(config.flan).balanceOf(flanLP);\n    uint256 balanceOfStable = IERC20(stablecoin).balanceOf(flanLP);\n\n    uint256 tiltedPrice = (balanceOfFlan * getMagnitude(stablecoin)) / balanceOfStable;\n    require(tiltedPrice < config.acceptableHighestPrice[stablecoin], \"BACKSTOP: potential price manipulation\");\n    uint256 growth = ((priceBefore - tiltedPrice) * 100) / priceBefore;\n\n    uint256 flanToMint = (tiltedPrice * normalizedAmount) / (1 ether);\n\n    //share some price tilting with the user to incentivize minting: The larger the purchase, the better the return\n    uint256 premium = (flanToMint * (growth / 2)) / 100;\n\n    FlanLike(config.flan).mint(address(this), flanToMint + premium);\n    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\n    PyroTokenLike(config.pyroFlan).mint(msg.sender, flanToMint + premium);\n    redeemRate = PyroTokenLike(config.pyroFlan).redeemRate();\n  }\n\n  function getMagnitude(address token) internal view returns (uint256) {\n    uint256 places = config.decimalPlaces[token];\n    return 10**places;\n  }\n\n  function normalize(address token, uint256 amount) internal view returns (uint256) {\n    uint256 places = config.decimalPlaces[token];\n    uint256 bump = 10**(18 - places);\n    return amount * bump;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../ERC677/ERC677.sol\";\nimport \"../Flan.sol\";\nimport \"./ProposalFactory.sol\";\nimport \"../facades/SwapFactoryLike.sol\";\nimport \"../facades/UniPairLike.sol\";\nimport \"./Governable.sol\";\n\n// import \"hardhat/console.sol\";\n\nlibrary TransferHelper {\n  function ERC20NetTransfer(\n    address token,\n    address from,\n    address to,\n    int256 amount\n  ) public {\n    if (amount > 0) {\n      require(IERC20(token).transferFrom(from, to, uint256(amount)), \"LimboDAO: ERC20 transfer from failed.\");\n    } else {\n      require(IERC20(token).transfer(from, uint256(amount * (-1))), \"LimboDAO: ERC20 transfer failed.\");\n    }\n  }\n}\n\nenum FateGrowthStrategy {\n  straight,\n  directRoot,\n  indirectTwoRootEye\n}\n\nenum ProposalDecision {\n  voting,\n  approved,\n  rejected\n}\n\n///@title Limbo DAO\n///@author Justin Goro\n/**@notice\n *This is the first MicroDAO associated with MorgothDAO. A MicroDAO manages parameterization of running dapps without having\n *control over existential functionality. This is not to say that some of the decisions taken are not critical but that the domain\n *of influence is confined to the local Dapp - Limbo in this case.\n * LimboDAO has two forms of decision making: proposals and flash governance. For proposals, voting power is required. Voting power in LimboDAO is measured\n * by a points system called Fate. Staking EYE or an EYE based LP earns Fate at a quadratic rate. Fate can be used to list a proposal for voting or to vote.\n * Using Fate to make a governance decisions spens it out of existince. So Fate reflects the opportunity cost of staking.\n * Flash governance is for instant decision making that cannot wait for voting to occur. Best used for small tweaks to parameters or emergencies.\n * Flash governance requires a governance asset (EYE) be staked at the time of the execution. The asset cannot be withdrawn for a certain period of time,\n * allowing for Fate holders to vote on the legitimacy of the decision. If the decision is considered malicious, the staked EYE is burnt.\n */\n///@dev Contracts subject to LimboDAO must inherit the Governable abstract contract.\ncontract LimboDAO is Ownable {\n  event daoKilled(address newOwner);\n  event proposalLodged(address proposal, address proposer);\n  event voteCast(address voter, address proposal, int256 fateCast);\n  event assetApproval(address asset, bool appoved);\n  event proposalExecuted(address proposal, bool approved);\n  event assetBurnt(address burner, address asset, uint256 fateCreated);\n\n  using TransferHelper for address;\n  uint256 constant ONE = 1 ether;\n  uint256 precision = 1e9;\n\n  struct DomainConfig {\n    address limbo;\n    address flan;\n    address eye;\n    address fate;\n    bool live;\n    address flashGoverner;\n    address sushiFactory;\n    address uniFactory;\n  }\n\n  struct ProposalConfig {\n    uint256 votingDuration;\n    uint256 requiredFateStake;\n    address proposalFactory; //check this for creating proposals\n  }\n\n  struct ProposalState {\n    int256 fate;\n    ProposalDecision decision;\n    address proposer;\n    uint256 start;\n    Proposal proposal;\n  }\n\n  //rateCrate\n  struct FateState {\n    uint256 fatePerDay;\n    uint256 fateBalance;\n    uint256 lastDamnAdjustment;\n  }\n\n  struct AssetClout {\n    uint256 fateWeight;\n    uint256 balance;\n  }\n\n  DomainConfig public domainConfig;\n  ProposalConfig public proposalConfig;\n\n  /**@notice for staking EYE, we simply take the square root of staked amount.\n   * For LP tokens, only half the value of the token is EYE so it's tempting to take the square root for the EYE balance. However this punishes the holder by ignoring the cost incurred by supplying the other asset. Since the other asset at rest is equal in value to the EYE balance, we just multiply the calculation by 2.\n   */\n  mapping(address => FateGrowthStrategy) public fateGrowthStrategy;\n  mapping(address => bool) public assetApproved;\n  mapping(address => FateState) public fateState; //lateDate\n\n  //Fate is earned per day. Keeping track of relative staked values, we can increment user balance\n  mapping(address => mapping(address => AssetClout)) public stakedUserAssetWeight; //user->asset->weight\n\n  ProposalState public currentProposalState;\n  ProposalState public previousProposalState;\n\n  // Since staking EYE precludes it from earning Flan on Limbo, fateToFlan can optionally be set to a non zero number to allow fat holders to spend their fate for Flan.\n  uint256 public fateToFlan;\n\n  modifier isLive() {\n    require(domainConfig.live, \"LimboDAO: DAO is not live.\");\n    _;\n  }\n\n  function nextProposal() internal {\n    previousProposalState = currentProposalState;\n    currentProposalState.proposal = Proposal(address(0));\n    currentProposalState.fate = 0;\n    currentProposalState.decision = ProposalDecision.voting;\n    currentProposalState.proposer = address(0);\n    currentProposalState.start = 0;\n  }\n\n  modifier onlySuccessfulProposal() {\n    // console.log('onlySuccessfulProposal');\n    require(successfulProposal(msg.sender), \"LimboDAO: approve proposal\");\n    _;\n    //nextProposal();\n  }\n\n  ///@notice has a proposal successfully been approved?\n  function successfulProposal(address proposal) public view returns (bool) {\n    return\n      currentProposalState.decision == ProposalDecision.approved && proposal == address(currentProposalState.proposal);\n  }\n\n  modifier updateCurrentProposal() {\n    incrementFateFor(_msgSender());\n    if (address(currentProposalState.proposal) != address(0)) {\n      uint256 durationSinceStart = block.timestamp - currentProposalState.start;\n      if (\n        durationSinceStart >= proposalConfig.votingDuration && currentProposalState.decision == ProposalDecision.voting\n      ) {\n        if (currentProposalState.fate > 0) {\n          currentProposalState.decision = ProposalDecision.approved;\n          currentProposalState.proposal.orchestrateExecute();\n          fateState[currentProposalState.proposer].fateBalance += proposalConfig.requiredFateStake;\n        } else {\n          currentProposalState.decision = ProposalDecision.rejected;\n        }\n        emit proposalExecuted(\n          address(currentProposalState.proposal),\n          currentProposalState.decision == ProposalDecision.approved\n        );\n        nextProposal();\n      }\n    }\n    _;\n  }\n\n  modifier incrementFate() {\n    incrementFateFor(_msgSender());\n    _;\n  }\n\n  function incrementFateFor(address user) public {\n    FateState storage state = fateState[user];\n    state.fateBalance += (state.fatePerDay * (block.timestamp - state.lastDamnAdjustment)) / (1 days);\n    state.lastDamnAdjustment = block.timestamp;\n  }\n\n  ///@param limbo address of Limbo\n  ///@param flan address of Flan\n  ///@param eye address of EYE token\n  ///@param proposalFactory authenticates and instantiates valid proposals for voting\n  ///@param sushiFactory is the SushiSwap Factory contract\n  ///@param uniFactory is the UniSwapV2 Factory contract\n  ///@param flashGoverner oversees flash governance cryptoeconomics\n  ///@param precisionOrderOfMagnitude when comparing fractional values, it's not necessary to get every last digit right\n  ///@param sushiLPs valid EYE containing LP tokens elligible for earning Fate through staking\n  ///@param uniLPs valid EYE containing LP tokens elligible for earning Fate through staking\n  function seed(\n    address limbo,\n    address flan,\n    address eye,\n    address proposalFactory,\n    address sushiFactory,\n    address uniFactory,\n    address flashGoverner,\n    uint256 precisionOrderOfMagnitude,\n    address[] memory sushiLPs,\n    address[] memory uniLPs\n  ) public onlyOwner {\n    _seed(limbo, flan, eye, sushiFactory, uniFactory, flashGoverner);\n    proposalConfig.votingDuration = 2 days;\n    proposalConfig.requiredFateStake = 223 * ONE; //50000 EYE for 24 hours\n    proposalConfig.proposalFactory = proposalFactory;\n    precision = 10**precisionOrderOfMagnitude;\n    for (uint256 i = 0; i < sushiLPs.length; i++) {\n      require(UniPairLike(sushiLPs[i]).factory() == sushiFactory, \"LimboDAO: invalid Sushi LP\");\n      if (IERC20(eye).balanceOf(sushiLPs[i]) > 1000) assetApproved[sushiLPs[i]] = true;\n      fateGrowthStrategy[sushiLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;\n    }\n    for (uint256 i = 0; i < uniLPs.length; i++) {\n      require(UniPairLike(uniLPs[i]).factory() == uniFactory, \"LimboDAO: invalid Sushi LP\");\n      if (IERC20(eye).balanceOf(uniLPs[i]) > 1000) assetApproved[uniLPs[i]] = true;\n      fateGrowthStrategy[uniLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;\n    }\n  }\n\n  ///@notice allows Limbo to be governed by a new DAO\n  ///@dev functions marked by onlyOwner are governed by MorgothDAO\n  function killDAO(address newOwner) public onlyOwner isLive {\n    domainConfig.live = false;\n    Governable(domainConfig.flan).setDAO(newOwner);\n    Governable(domainConfig.limbo).setDAO(newOwner);\n    emit daoKilled(newOwner);\n  }\n\n  ///@notice optional conversion rate of Fate to Flan\n  function setFateToFlan(uint256 rate) public onlySuccessfulProposal {\n    fateToFlan = rate;\n  }\n\n  ///@notice caller spends their Fate to earn Flan\n  function convertFateToFlan(uint256 fate) public returns (uint256 flan) {\n    require(fateToFlan > 0, \"LimboDAO: Fate conversion to Flan disabled.\");\n    fateState[msg.sender].fateBalance -= fate;\n    flan = (fateToFlan * fate) / ONE;\n    Flan(domainConfig.flan).mint(msg.sender, flan);\n  }\n\n  /**@notice handles proposal lodging logic. A deposit of Fate is removed from the user. If the decision is a success, half the fate is returned.\n   *  This is to encourage only lodging of proposals that are likely to succeed.\n   *  @dev not for external calling. Use the proposalFactory to lodge a proposal instead.\n   */\n  function makeProposal(address proposal, address proposer) public updateCurrentProposal {\n    address sender = _msgSender();\n    require(sender == proposalConfig.proposalFactory, \"LimboDAO: only Proposal Factory\");\n    require(address(currentProposalState.proposal) == address(0), \"LimboDAO: active proposal.\");\n\n    fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2;\n    currentProposalState.proposal = Proposal(proposal);\n    currentProposalState.decision = ProposalDecision.voting;\n    currentProposalState.fate = 0;\n    currentProposalState.proposer = proposer;\n    currentProposalState.start = block.timestamp;\n    emit proposalLodged(proposal, proposer);\n  }\n\n  ///@notice handles proposal voting logic.\n  ///@param proposal contract to be voted on\n  ///@param fate positive is YES, negative is NO. Absolute value is deducted from caller.\n  function vote(address proposal, int256 fate) public incrementFate isLive {\n    require(\n      proposal == address(currentProposalState.proposal), //this is just to protect users with out of sync UIs\n      \"LimboDAO: stated proposal does not match current proposal\"\n    );\n    require(currentProposalState.decision == ProposalDecision.voting, \"LimboDAO: voting on proposal closed\");\n    if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration - 1 hours) {\n      int256 currentFate = currentProposalState.fate;\n      //check if voting has ended\n      if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) {\n        revert(\"LimboDAO: voting for current proposal has ended.\");\n      } else if (\n        //The following if statement checks if the vote is flipped by fate\n        fate * currentFate < 0 && //sign different\n        (fate + currentFate) * fate > 0 //fate flipped current fate onto the same side of zero as fate\n      ) {\n        //extend voting duration when vote flips decision. Suggestion made by community member\n        currentProposalState.start = currentProposalState.start + 2 hours;\n      }\n    }\n    uint256 cost = fate > 0 ? uint256(fate) : uint256(-fate);\n    fateState[_msgSender()].fateBalance = fateState[_msgSender()].fateBalance - cost;\n\n    currentProposalState.fate += fate;\n    emit voteCast(_msgSender(), proposal, fate);\n  }\n\n  ///@notice pushes the decision to execute a successful proposal. For convenience only\n  function executeCurrentProposal() public updateCurrentProposal {}\n\n  ///@notice parameterizes the voting\n  ///@param requiredFateStake the amount of Fate required to lodge a proposal\n  ///@param votingDuration the duration of voting in seconds\n  ///@param proposalFactory the address of the proposal factory\n  function setProposalConfig(\n    uint256 votingDuration,\n    uint256 requiredFateStake,\n    address proposalFactory\n  ) public onlySuccessfulProposal {\n    proposalConfig.votingDuration = votingDuration;\n    proposalConfig.requiredFateStake = requiredFateStake;\n    proposalConfig.proposalFactory = proposalFactory;\n  }\n\n  ///@notice Assets approved for earning Fate\n  function setApprovedAsset(address asset, bool approved) public onlySuccessfulProposal {\n    assetApproved[asset] = approved;\n    fateGrowthStrategy[asset] = FateGrowthStrategy.indirectTwoRootEye;\n    emit assetApproval(asset, approved);\n  }\n\n  ///@notice handles staking logic for EYE and EYE based assets so that correct rate of fate is earned.\n  ///@param finalAssetBalance after staking, what is the final user balance on LimboDAO of the asset in question\n  ///@param finalEYEBalance if EYE is being staked, this value is the same as finalAssetBalance but for LPs it's about half\n  ///@param rootEYE offload high gas arithmetic to the client. Cheap to verify. Square root in fixed point requires Babylonian algorithm\n  ///@param asset the asset being staked\n  function setEYEBasedAssetStake(\n    uint256 finalAssetBalance,\n    uint256 finalEYEBalance,\n    uint256 rootEYE,\n    address asset\n  ) public isLive incrementFate {\n    require(assetApproved[asset], \"LimboDAO: illegal asset\");\n    address sender = _msgSender();\n    FateGrowthStrategy strategy = fateGrowthStrategy[asset];\n\n    //verifying that rootEYE value is accurate within precision.\n    uint256 rootEYESquared = rootEYE * rootEYE;\n    uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);\n    require(\n      rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,\n      \"LimboDAO: Stake EYE invariant.\"\n    );\n    AssetClout storage clout = stakedUserAssetWeight[sender][asset];\n    fateState[sender].fatePerDay -= clout.fateWeight;\n    uint256 initialBalance = clout.balance;\n    //EYE\n    if (strategy == FateGrowthStrategy.directRoot) {\n      require(finalAssetBalance == finalEYEBalance, \"LimboDAO: staking eye invariant.\");\n      require(asset == domainConfig.eye);\n\n      clout.fateWeight = rootEYE;\n      clout.balance = finalAssetBalance;\n      fateState[sender].fatePerDay += rootEYE;\n    } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {\n      //LP\n      clout.fateWeight = 2 * rootEYE;\n      fateState[sender].fatePerDay += clout.fateWeight;\n\n      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\n      require(actualEyeBalance > 0, \"LimboDAO: No EYE\");\n      uint256 totalSupply = IERC20(asset).totalSupply();\n      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;\n      uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);\n      finalEYEBalance /= precision;\n      require(\n        finalEYEBalance == impliedEye, //precision cap\n        \"LimboDAO: stake invariant check 2.\"\n      );\n      clout.balance = finalAssetBalance;\n    } else {\n      revert(\"LimboDAO: asset growth strategy not accounted for\");\n    }\n    int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);\n    asset.ERC20NetTransfer(sender, address(this), netBalance);\n  }\n\n  /**\n   *@notice Acquiring enough fate to either influence a decision or to lodge a proposal can take very long.\n   * If a very important decision has to be acted on via a proposal, the option exists to buy large quantities for fate instantly by burning an EYE based asset\n   * This may be necessary if a vote is nearly complete by the looming outcome is considered unacceptable.\n   * While Fate accumulation is quadratic for staking, burning is linear and subject to a factor of 10. This gives whales effective veto power but at the cost of a permanent\n   * loss of EYE.\n   *@param asset the asset to burn and can be EYE or EYE based assets\n   *@param amount the amount of asset to burn\n   */\n  function burnAsset(address asset, uint256 amount) public isLive incrementFate {\n    require(assetApproved[asset], \"LimboDAO: illegal asset\");\n    address sender = _msgSender();\n    require(ERC677(asset).transferFrom(sender, address(this), amount), \"LimboDAO: transferFailed\");\n    uint256 fateCreated = fateState[_msgSender()].fateBalance;\n    if (asset == domainConfig.eye) {\n      fateCreated = amount * 10;\n      ERC677(domainConfig.eye).burn(amount);\n    } else {\n      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\n      require(actualEyeBalance > 0, \"LimboDAO: No EYE\");\n      uint256 totalSupply = IERC20(asset).totalSupply();\n      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;\n      uint256 impliedEye = (eyePerUnit * amount) / ONE;\n      fateCreated = impliedEye * 20;\n    }\n    fateState[_msgSender()].fateBalance += fateCreated;\n    emit assetBurnt(_msgSender(), asset, fateCreated);\n  }\n\n  ///@notice grants unlimited Flan minting power to an address.\n  function approveFlanMintingPower(address minter, bool enabled) public onlySuccessfulProposal isLive {\n    Flan(domainConfig.flan).increaseMintAllowance(minter, enabled ? type(uint256).max : 0);\n  }\n\n  ///@notice call this after initial config is complete.\n  function makeLive() public onlyOwner {\n    require(\n      Governable(domainConfig.limbo).DAO() == address(this) && Governable(domainConfig.flan).DAO() == address(this),\n      \"LimboDAO: transfer ownership of limbo and flan.\"\n    );\n    domainConfig.live = true;\n  }\n\n  ///@notice if the DAO is being dismantled, it's necessary to transfer any owned items\n  function transferOwnershipOfThing(address thing, address destination) public onlySuccessfulProposal {\n    Ownable(thing).transferOwnership(destination);\n  }\n\n  function timeRemainingOnProposal() public view returns (uint256) {\n    require(currentProposalState.decision == ProposalDecision.voting, \"LimboDAO: proposal finished.\");\n    uint256 elapsed = block.timestamp - currentProposalState.start;\n    if (elapsed > proposalConfig.votingDuration) return 0;\n    return proposalConfig.votingDuration - elapsed;\n  }\n\n  /**@notice seed is a goro idiom for initialize that you tend to find in all the dapps I've written.\n   * I prefer initialization funcitons to parameterized solidity constructors for reasons beyond the scope of this comment.\n   */\n  function _seed(\n    address limbo,\n    address flan,\n    address eye,\n    address sushiFactory,\n    address uniFactory,\n    address flashGoverner\n  ) internal {\n    domainConfig.limbo = limbo;\n    domainConfig.flan = flan;\n    domainConfig.eye = eye;\n    domainConfig.uniFactory = uniFactory;\n    domainConfig.sushiFactory = sushiFactory;\n    domainConfig.flashGoverner = flashGoverner;\n    assetApproved[eye] = true;\n    fateGrowthStrategy[eye] = FateGrowthStrategy.directRoot;\n  }\n\n  function getFlashGoverner() external view returns (address) {\n    return domainConfig.flashGoverner;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// import \"hardhat/console.sol\";\nimport \"./facades/LimboDAOLike.sol\";\nimport \"./facades/Burnable.sol\";\nimport \"./facades/BehodlerLike.sol\";\nimport \"./facades/FlanLike.sol\";\nimport \"./facades/UniPairLike.sol\";\nimport \"./facades/MigratorLike.sol\";\nimport \"./facades/AMMHelper.sol\";\nimport \"./facades/AngbandLike.sol\";\nimport \"./facades/LimboAddTokenToBehodlerPowerLike.sol\";\nimport \"./DAO/Governable.sol\";\nimport \"./facades/FlashGovernanceArbiterLike.sol\";\n\n/*\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can't unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don't want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n*/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/*\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n*/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted <= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), \"E8\");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), \"E9\");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress->index->stakingInfo\n  mapping(address => mapping(uint256 => Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address => uint256) public latestIndex;\n\n  ///@dev tokenAddress->userAddress->soulIndex->Userinfo\n  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;\n  ///@dev token->index->data\n  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul->owner->unstaker->amount\n  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, \"EF\");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, \"EI\");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, \"E1\");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance > 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor <= 10000, \"E6\");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.\n   */\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, \"E2\");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount > 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending > 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, \"E2\");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount >= amount, \"E4\");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending > 0 && amount > 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending > 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, \"E2\");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, \"E5\");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, \"E6\");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken > 0, \"ED\");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  */\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, \"E7\");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   */\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, \"EB\");\n    require(soul.state == SoulState.waitingToCross, \"E2\");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >\n        crossingConfig.crossingMigrationDelay,\n      \"EC\"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./Governable.sol\";\nimport \"hardhat/console.sol\";\nimport \"../facades/Burnable.sol\";\n\n///@title Flash Governance Arbiter\n///@author Justin Goro\n/**@notice LimboDAO offers two forms of governance: flash and proposal. Proposals are contracts that have authorization to execute guarded functions on contracts that implement the Governable abstract contract.\n * Proposals require Fate to be put forward for voting and Fate is the spendable voting token.\n * Flash governance occurs in the duration of one transaction and is more appropriate for variable tweaking such as changing the Flan per Second or Threshold of a pool.\n * Flash governance requires an asset be deposited into an adjudication contract. The community can then vote, through a proposal, whether the decision was legitimate. If not, the deposit can be slashed\n * By default, the asset is EYE.\n */\ncontract FlashGovernanceArbiter is Governable {\n  /**\n   * @param actor user making flash governance decision\n   * @param deposit_asset is the asset type put up as decision collateral. Must be burnable.\n   * @param amount is the amount of the deposit_asset to be put up as decision collateral.\n   * @param target is the contract that will be affected by the flash governance decision.\n   */\n  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);\n\n  mapping(address => bool) enforceLimitsActive;\n\n  constructor(address dao) Governable(dao) {}\n\n  struct FlashGovernanceConfig {\n    address asset;\n    uint256 amount;\n    uint256 unlockTime;\n    bool assetBurnable;\n  }\n\n  //Note: epoch settings prevent DOS attacks. Change tolerance curtails the damage of bad flash governance.\n  struct SecurityParameters {\n    uint8 maxGovernanceChangePerEpoch; //prevents flash governance from wrecking the incentives.\n    uint256 epochSize; //only one flash governance action can happen per epoch to prevent governance DOS\n    uint256 lastFlashGovernanceAct;\n    uint8 changeTolerance; //1-100 maximum percentage any numeric variable can be changed through flash gov\n  }\n\n  //the current parameters determining the rules of flash governance\n  FlashGovernanceConfig public flashGovernanceConfig;\n  SecurityParameters public security;\n\n  /*For every decision, we record the config at the time of the decision. This allows governance to change the rules\n   *without undermining the terms under which pending decisions were made.\n   */\n  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; //contract->user->config\n\n  /**\n   *@notice An attempt is made to withdraw the current deposit requirement.\n   * For a given user, flash governance decisions can only happen one at a time\n   *@param sender is the user making the flash governance decision\n   *@param target is the contract that will be affected by the flash governance decision.\n   *@param emergency flash governance decisions are restricted in frequency per epoch but some decisions are too important. These can be marked emergency.\n   *@dev be very careful about setting emergency to true. Only decisions which preclude the execution of other flash governance decisions should be considered candidtes for emergency.\n   */\n  function assertGovernanceApproved(\n    address sender,\n    address target,\n    bool emergency\n  ) public {\n    if (\n      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&\n      pendingFlashDecision[target][sender].unlockTime < block.timestamp\n    ) {\n      require(\n        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),\n        \"Limbo: flash governance disabled for rest of epoch\"\n      );\n      pendingFlashDecision[target][sender] = flashGovernanceConfig;\n      pendingFlashDecision[target][sender].unlockTime += block.timestamp;\n\n      security.lastFlashGovernanceAct = block.timestamp;\n      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);\n    } else {\n      revert(\"LIMBO: governance decision rejected.\");\n    }\n  }\n\n  /**\n   *@param asset is the asset type put up as decision collateral. Must be burnable.\n   *@param amount is the amount of the deposit_asset to be put up as decision collateral.\n   *@param unlockTime is the duration for which the deposit collateral must be locked in order to give the community time to weigh up the decision\n   *@param assetBurnable is a technical parameter to determined the manner in which burning should occur. Non burnable assets are just no longer accounted for and accumulate within this contract.\n   */\n  function configureFlashGovernance(\n    address asset,\n    uint256 amount,\n    uint256 unlockTime,\n    bool assetBurnable\n  ) public virtual onlySuccessfulProposal {\n    flashGovernanceConfig.asset = asset;\n    flashGovernanceConfig.amount = amount;\n    flashGovernanceConfig.unlockTime = unlockTime;\n    flashGovernanceConfig.assetBurnable = assetBurnable;\n  }\n\n  /**\n    @param maxGovernanceChangePerEpoch max number of flash governance decisions per epoch to prevent DOS\n    @param epochSize is the duration of a flash governance epoch and reflects proposal deliberation durations\n    @param changeTolerance is the amount by which a variable can be changed through flash governance.\n    */\n  function configureSecurityParameters(\n    uint8 maxGovernanceChangePerEpoch,\n    uint256 epochSize,\n    uint8 changeTolerance\n  ) public virtual onlySuccessfulProposal {\n    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;\n    security.epochSize = epochSize;\n    require(security.changeTolerance < 100, \"Limbo: % between 0 and 100\");\n    security.changeTolerance = changeTolerance;\n  }\n\n  /**\n    @notice LimboDAO proposals for burning flash governance collateral act through this function\n    @param targetContract is the contract that is affected by the flash governance decision.\n    @param user is the user who made the flash governance decision\n    @param asset is the collateral asset to be burnt\n    @param amount is the amount of the collateral to be burnt\n    */\n  function burnFlashGovernanceAsset(\n    address targetContract,\n    address user,\n    address asset,\n    uint256 amount\n  ) public virtual onlySuccessfulProposal {\n    if (pendingFlashDecision[targetContract][user].assetBurnable) {\n      Burnable(asset).burn(amount);\n    }\n\n    pendingFlashDecision[targetContract][user] = flashGovernanceConfig;\n  }\n\n  /**\n   *@notice Assuming a flash governance decision was not rejected during the lock window, the user is free to withdraw their asset\n   *@param targetContract is the contract that is affected by the flash governance decision.\n   *@param asset is the collateral asset to be withdrawn\n   */\n  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {\n    require(\n      pendingFlashDecision[targetContract][msg.sender].asset == asset &&\n        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&\n        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,\n      \"Limbo: Flashgovernance decision pending.\"\n    );\n    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(\n      msg.sender,\n      pendingFlashDecision[targetContract][msg.sender].amount\n    );\n    delete pendingFlashDecision[targetContract][msg.sender];\n  }\n\n  /**\n   *@notice when a governance function is executed, it can enforce change limits on variables in the event that the execution is through flash governance\n   * However, a proposal is subject to the full deliberation of the DAO and such limits may thwart good governance.\n   * @param enforce for the given context, set whether variable movement limits are enforced or not.\n   */\n  function setEnforcement(bool enforce) public {\n    enforceLimitsActive[msg.sender] = enforce;\n  }\n\n  ///@dev for negative values, relative comparisons need to be calculated correctly.\n  function enforceToleranceInt(int256 v1, int256 v2) public view {\n    if (!configured) return;\n    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);\n    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);\n    enforceTolerance(uv1, uv2);\n  }\n\n  ///@notice Allows functions to enforce maximum limits on a per variable basis\n  ///@dev the 100 factor is just to allow for simple percentage comparisons without worrying about enormous precision.\n  function enforceTolerance(uint256 v1, uint256 v2) public view {\n    if (!configured || !enforceLimitsActive[msg.sender]) return;\n    //bonus points for readability\n    if (v1 > v2) {\n      if (v2 == 0) require(v1 <= 1, \"FE1\");\n      else require(((v1 - v2) * 100) < security.changeTolerance * v1, \"FE1\");\n    } else {\n      if (v1 == 0) require(v2 <= 1, \"FE1\");\n      else require(((v2 - v1) * 100) < security.changeTolerance * v1, \"FE1\");\n    }\n  }\n}\n\n\n",
        "CodeNames": [
            "FlanBackstop.sol",
            "LimboDAO.sol",
            "Limbo.sol",
            "FlashGovernanceArbiter.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-04",
                "Location": [
                    "voting",
                    "execute",
                    "vote",
                    "makeProposal()",
                    "updateCurrentProposal()",
                    "executeCurrentProposal()",
                    "High"
                ],
                "Type": " The system can get to a \"stuck\" state if a bad proposal (proposal that can't be executed) is accepted",
                "Description": "\n\nThe LimboDAO contract has a variable that indicates the current proposal every time there can be only one proposal. The only way a proposal can be done and a new proposal can be registered is to finish the previous proposal by either accepting it and executing it or by rejecting it. If a proposal that can't succeed, like for example an UpdateMultipleSoulConfigProposal proposal that has too much tokens and not enough gas, will stuck the system if it will be accepted. Thats because its time will pass the users won't be able to vote anymore (because the vote function will revert), and the proposal can't be executed the execute function will revert. So the proposal won't be able to be done and the system will be stuck because new proposal won't be able to be registered.\n\nWhen trying to call the executeCurrentProposal() function that activates the updateCurrentProposal() modifier, the modifier will check the balance of fate, it will see that it's positive and will call currentProposalState.proposal.orchestrateExecute() to execute the proposal. the proposal will revert and cancel it all (leaving the proposal as the current proposal with voting state).\n\nWhen trying to call makeProposal() function to make a new proposal it will revert because the current proposal is not equal to address(0).\n\nTo sum up, the system can get to a \"stuck\" state if a bad proposal (proposal that can't be executed) is accepted.\n\ngititGoro (Behodler) confirmed and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/153#issuecomment-1029445460):\n  I'm so glad someone finally noticed this. So many issues logged skirted around this issue. A lot of issues were logged about adding too may token to the updateMultipleSoulProposal but the crux of the matter is that the proposal.execute() should be replaced with a call that returns a success boolean so that the DAO doesn't get stuck on broken proposals. Congratulations on spotting this.\n\nJack the Pug (judge) decreased severity from High to Medium and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/153#issuecomment-1041459074):\n  This is a good one, but I'm still going to downgrade this to medium as there is no fund at risk afaics.\n\ngititGoro (Behodler) commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/153#issuecomment-1056128991):\n  @jack-the-pug  There is a funds risk. Limbo can be paused via flash governance. When paused, funds can't be withdrawn. The only way to unpause is with a proposal. If the DAO gets jammed up with a broken proposal contract then an attacker can pause Limbo and all staked funds will be locked permanently.\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/153#issuecomment-1056154599):\n  Yeah, I agree that funds can be at risk indirectly, like the vector you described above, but only when the warden made a clear and persuasive presentation about how the funds can be at risk, then it can be a High.\n \n Furthermore, this attack vector requires the community to misbehave or at least be imprudent, to pass a malicious proposal, which already lowers the severity of it.\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./ERC677/ERC677.sol\";\nimport \"../contracts/DAO/Governable.sol\";\n\n///@author Justin Goro\n///@title Flan\n/**\n *@notice The reward token for Limbo. Flan can be minted without limit and is intended to converge on the price of DAI via various external incentives\n */\ncontract Flan is ERC677(\"Flan\", \"FLN\"), Governable {\n    event burnOnTransferFeeAdjusted(uint8 oldFee, uint8 newFee);\n    mapping(address => uint256) public mintAllowance; //type(uint).max == whitelist\n\n    uint8 public burnOnTransferFee = 0; //% between 1 and 100, recipient pays\n\n    constructor(address dao) Governable(dao) {}\n\n    /**\n    * @param fee - % between 1 and 100, recipient pays\n     */\n    function setBurnOnTransferFee(uint8 fee) public onlySuccessfulProposal {\n        _setBurnOnTransferFee(fee);\n    }\n\n    ///@notice flash governance technique for FOT change.\n    function incrementBurnOnTransferFee(int8 change)\n        public\n        governanceApproved(false)\n    {\n        uint8 newFee = uint8(int8(burnOnTransferFee) + change);\n        flashGoverner.enforceTolerance(newFee, burnOnTransferFee);\n        _setBurnOnTransferFee(newFee);\n    }\n\n    function _setBurnOnTransferFee(uint8 fee) internal {\n        uint8 priorFee = burnOnTransferFee;\n        burnOnTransferFee = fee > 100 ? 100 : fee;\n        emit burnOnTransferFeeAdjusted(priorFee, burnOnTransferFee);\n    }\n\n    ///@notice grants unlimited minting power to a contract\n    ///@param minter contract to be given unlimited minting power\n    ///@param enabled minting power enabled or disabled\n    function whiteListMinting(address minter, bool enabled)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = enabled ? type(uint256).max : 0;\n    }\n\n    ///@notice metered minting power. Useful for once off minting\n    function increaseMintAllowance(address minter, uint256 _allowance)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = mintAllowance[minter] + _allowance;\n    }\n\n    ///@notice minting of flan open to approved minters and LimboDAO\n    ///@param recipient address to receive flan\n    ///@param amount amount of flan to be minted \n    function mint(address recipient, uint256 amount) public returns (bool) {\n        uint256 allowance = mintAllowance[_msgSender()];\n        require(\n            _msgSender() == owner() || allowance >= amount,\n            \"Flan: Mint allowance exceeded\"\n        );\n        approvedMint(recipient, amount, _msgSender(), allowance);\n        return true;\n    }\n\n    function approvedMint(\n        address recipient,\n        uint256 amount,\n        address minter,\n        uint256 allowance\n    ) internal {\n        _mint(recipient, amount);\n        if (allowance < type(uint256).max && minter != owner()) {\n            mintAllowance[minter] = mintAllowance[minter] - amount;\n        }\n    }\n\n    function safeTransfer(address _to, uint256 _amount) external {\n        uint256 flanBal = balanceOf(address(this));\n        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;\n        _transfer(_msgSender(), _to, flanToTransfer);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 fee = (burnOnTransferFee * amount) / 100;\n\n        _totalSupply = _totalSupply - fee;\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount - fee;\n\n        emit Transfer(sender, recipient, amount);\n    }\n}\n\n\n",
        "CodeNames": [
            "Flan.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-05",
                "Location": [
                    "//solidity\nfunction safeTransfer(address _to, uint256 _amount) external {\n  uint256 flanBal = balanceOf(address(this)); // the problem is in this line\n  uint256 flanToTransfer = _amount  flanBal ? flanBal : _amount;\n  _transfer(_msgSender(), _to, flanToTransfer);\n}\n"
                ],
                "Type": " flan can't be transferred unless the flan contract has flan balance greater than the amount we want to transfer",
                "Description": "\n\nThe flan contract must have balance (and must have more flan then we want to transfer) in order to allow flan transfers. If it doesn't have any balance, the safeTransfer, which is the only way to transfer flan, will call _transfer() function with amount = 0. It should check address(msg.sender)'s balance instead of address(this)'s balance.\n\nsolidity\nfunction safeTransfer(address _to, uint256 _amount) external {\n  uint256 flanBal = balanceOf(address(this)); // the problem is in this line\n  uint256 flanToTransfer = _amount  flanBal ? flanBal : _amount;\n  _transfer(_msgSender(), _to, flanToTransfer);\n}\n\n\ngititGoro (Behodler) confirmed but disagreed with High severity(https://github.com/code-423n4/2022-01-behodler-findings/issues/160)\n\nJack the Pug (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/160#issuecomment-1041461515):\n  Downgrade to medium as there is no fund at risk.\n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-06",
                "Location": [
                    "js\nFile: LimboDAO.sol\n383:   function burnAsset(address asset, uint256 amount) public isLive incrementFate {\n384:     require(assetApproved[asset], \"LimboDAO: illegal asset\");\n385:     address sender = _msgSender();\n386:     require(ERC677(asset).transferFrom(sender, address(this), amount), \"LimboDAO: transferFailed\"); //@audit-info FOT not taken into account\n387:     uint256 fateCreated = fateState[_msgSender()].fateBalance;\n388:     if (asset == domainConfig.eye) {\n389:       fateCreated = amount * 10; //@audit-info wrong amount due to lack of FOT calculation\n390:       ERC677(domainConfig.eye).burn(amount);//@audit-info wrong amount due to lack of FOT calculation\n391:     } else {\n392:       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\n393:       require(actualEyeBalance  0, \"LimboDAO: No EYE\");\n394:       uint256 totalSupply = IERC20(asset).totalSupply();\n395:       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;\n396:       uint256 impliedEye = (eyePerUnit * amount) / ONE;//@audit-info wrong amount due to lack of FOT calculation\n397:       fateCreated = impliedEye * 20;\n398:     }\n399:     fateState[_msgSender()].fateBalance += fateCreated; //@audit-info potentially wrong fateCreated as fateCreated can be equal to amount * 10;  \n400:     emit assetBurnt(_msgSender(), asset, fateCreated);//@audit-info potentially wrong fateCreated emitted\n401:   }\n"
                ],
                "Type": " Consistently check account balance before and after transfers for Fee-On-Transfer discrepencies",
                "Description": "\nWrong fateBalance bookkeeping for a user.\nWrong fateCreated value emitted.\n\n\nTaking into account the FOT is done almost everywhere important in the solution already. That's a known practice in the solution.\n\nHowever, it's missing here (see @audit-info tags):\njs\nFile: LimboDAO.sol\n383:   function burnAsset(address asset, uint256 amount) public isLive incrementFate {\n384:     require(assetApproved[asset], \"LimboDAO: illegal asset\");\n385:     address sender = _msgSender();\n386:     require(ERC677(asset).transferFrom(sender, address(this), amount), \"LimboDAO: transferFailed\"); //@audit-info FOT not taken into account\n387:     uint256 fateCreated = fateState[_msgSender()].fateBalance;\n388:     if (asset == domainConfig.eye) {\n389:       fateCreated = amount * 10; //@audit-info wrong amount due to lack of FOT calculation\n390:       ERC677(domainConfig.eye).burn(amount);//@audit-info wrong amount due to lack of FOT calculation\n391:     } else {\n392:       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\n393:       require(actualEyeBalance  0, \"LimboDAO: No EYE\");\n394:       uint256 totalSupply = IERC20(asset).totalSupply();\n395:       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;\n396:       uint256 impliedEye = (eyePerUnit * amount) / ONE;//@audit-info wrong amount due to lack of FOT calculation\n397:       fateCreated = impliedEye * 20;\n398:     }\n399:     fateState[_msgSender()].fateBalance += fateCreated; //@audit-info potentially wrong fateCreated as fateCreated can be equal to amount * 10;  \n400:     emit assetBurnt(_msgSender(), asset, fateCreated);//@audit-info potentially wrong fateCreated emitted\n401:   }\n\n\nVS Code\n\n",
                "Repair": "\nCheck the balance before and after the transfer to take into account the Fees-On-Transfer.\n\ngititGoro (Behodler) confirmed but disagreed with High severity and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/237#issuecomment-1030499258):\n  Nice catch! It's not a level 3 bug, though. \n\nJack the Pug (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/237#issuecomment-1053291744):\n  Downgrade to Med as the assets need to be whitelisted.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// import \"hardhat/console.sol\";\nimport \"./facades/LimboDAOLike.sol\";\nimport \"./facades/Burnable.sol\";\nimport \"./facades/BehodlerLike.sol\";\nimport \"./facades/FlanLike.sol\";\nimport \"./facades/UniPairLike.sol\";\nimport \"./facades/MigratorLike.sol\";\nimport \"./facades/AMMHelper.sol\";\nimport \"./facades/AngbandLike.sol\";\nimport \"./facades/LimboAddTokenToBehodlerPowerLike.sol\";\nimport \"./DAO/Governable.sol\";\nimport \"./facades/FlashGovernanceArbiterLike.sol\";\n\n/*\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can't unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don't want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n*/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/*\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n*/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted <= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), \"E8\");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), \"E9\");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress->index->stakingInfo\n  mapping(address => mapping(uint256 => Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address => uint256) public latestIndex;\n\n  ///@dev tokenAddress->userAddress->soulIndex->Userinfo\n  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;\n  ///@dev token->index->data\n  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul->owner->unstaker->amount\n  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, \"EF\");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, \"EI\");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, \"E1\");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance > 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor <= 10000, \"E6\");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.\n   */\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, \"E2\");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount > 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending > 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, \"E2\");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount >= amount, \"E4\");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending > 0 && amount > 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending > 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, \"E2\");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, \"E5\");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, \"E6\");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken > 0, \"ED\");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  */\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, \"E7\");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   */\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, \"EB\");\n    require(soul.state == SoulState.waitingToCross, \"E2\");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >\n        crossingConfig.crossingMigrationDelay,\n      \"EC\"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./ERC677/ERC677.sol\";\nimport \"../contracts/DAO/Governable.sol\";\n\n///@author Justin Goro\n///@title Flan\n/**\n *@notice The reward token for Limbo. Flan can be minted without limit and is intended to converge on the price of DAI via various external incentives\n */\ncontract Flan is ERC677(\"Flan\", \"FLN\"), Governable {\n    event burnOnTransferFeeAdjusted(uint8 oldFee, uint8 newFee);\n    mapping(address => uint256) public mintAllowance; //type(uint).max == whitelist\n\n    uint8 public burnOnTransferFee = 0; //% between 1 and 100, recipient pays\n\n    constructor(address dao) Governable(dao) {}\n\n    /**\n    * @param fee - % between 1 and 100, recipient pays\n     */\n    function setBurnOnTransferFee(uint8 fee) public onlySuccessfulProposal {\n        _setBurnOnTransferFee(fee);\n    }\n\n    ///@notice flash governance technique for FOT change.\n    function incrementBurnOnTransferFee(int8 change)\n        public\n        governanceApproved(false)\n    {\n        uint8 newFee = uint8(int8(burnOnTransferFee) + change);\n        flashGoverner.enforceTolerance(newFee, burnOnTransferFee);\n        _setBurnOnTransferFee(newFee);\n    }\n\n    function _setBurnOnTransferFee(uint8 fee) internal {\n        uint8 priorFee = burnOnTransferFee;\n        burnOnTransferFee = fee > 100 ? 100 : fee;\n        emit burnOnTransferFeeAdjusted(priorFee, burnOnTransferFee);\n    }\n\n    ///@notice grants unlimited minting power to a contract\n    ///@param minter contract to be given unlimited minting power\n    ///@param enabled minting power enabled or disabled\n    function whiteListMinting(address minter, bool enabled)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = enabled ? type(uint256).max : 0;\n    }\n\n    ///@notice metered minting power. Useful for once off minting\n    function increaseMintAllowance(address minter, uint256 _allowance)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = mintAllowance[minter] + _allowance;\n    }\n\n    ///@notice minting of flan open to approved minters and LimboDAO\n    ///@param recipient address to receive flan\n    ///@param amount amount of flan to be minted \n    function mint(address recipient, uint256 amount) public returns (bool) {\n        uint256 allowance = mintAllowance[_msgSender()];\n        require(\n            _msgSender() == owner() || allowance >= amount,\n            \"Flan: Mint allowance exceeded\"\n        );\n        approvedMint(recipient, amount, _msgSender(), allowance);\n        return true;\n    }\n\n    function approvedMint(\n        address recipient,\n        uint256 amount,\n        address minter,\n        uint256 allowance\n    ) internal {\n        _mint(recipient, amount);\n        if (allowance < type(uint256).max && minter != owner()) {\n            mintAllowance[minter] = mintAllowance[minter] - amount;\n        }\n    }\n\n    function safeTransfer(address _to, uint256 _amount) external {\n        uint256 flanBal = balanceOf(address(this));\n        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;\n        _transfer(_msgSender(), _to, flanToTransfer);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 fee = (burnOnTransferFee * amount) / 100;\n\n        _totalSupply = _totalSupply - fee;\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount - fee;\n\n        emit Transfer(sender, recipient, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./facades/UniPairLike.sol\";\nimport \"./facades/BehodlerLike.sol\";\nimport \"./DAO/Governable.sol\";\n// import \"hardhat/console.sol\";\nimport \"./ERC677/ERC20Burnable.sol\";\nimport \"./facades/FlanLike.sol\";\nimport \"./testing/realUniswap/interfaces/IUniswapV2Factory.sol\";\nimport \"./facades/AMMHelper.sol\";\n\ncontract BlackHole {}\n\n///@Title Uniswap V2 helper for managing Flan liquidity on Uniswap V2, Sushiswap and any other compatible AMM\n///@author Justin Goro\n/**@notice Flan liquidity is boosted on Uniswap (or Sushiswap) via open market operations at the point of a token migration.\n  * UniswapHelper handles all the mechanics as well managing a just-in-time (Justin Time?) oracle\n */\ncontract UniswapHelper is Governable, AMMHelper {\n  address limbo;\n\n  struct UniVARS {\n    UniPairLike Flan_SCX_tokenPair;\n    address behodler;\n    address blackHole;\n    address flan;\n    uint256 divergenceTolerance;\n    uint256 minQuoteWaitDuration;\n    address DAI;\n    uint8 precision; // behodler uses a binary search. The higher this number, the more precise\n    IUniswapV2Factory factory;\n    uint8 priceBoostOvershoot; //percentage (0-100) for which the price must be overcorrected when strengthened to account for other AMMs\n  }\n\n  struct FlanQuote {\n    uint256 DaiScxSpotPrice;\n    uint256 DaiBalanceOnBehodler;\n    uint256 blockProduced;\n  }\n\n  /**@dev the Dai SCX price and the Dai balance on Behodler are both sampled twice before a migration can occur. \n  * The two samples have to be spaced a minimum duration and have to be the same values (within an error threshold). The objective here is to make price manipulation untenably expensive for an attacker\n  * so that the mining power expended (or the opportunity cost of eth staked) far exceeds the benefit to manipulating Limbo.\n  * The assumption of price stability isn't a bug because migrations aren't required to happen frequently. Instead if natural price drift occurs for non malicious reasons,\n  * the migration can be reattempted until a period of sufficient calm allows for migration. If a malicious actor injects volatility in order to prevent migration, by the principle\n  * of antifragility, they're doing the entire Ethereum ecosystem a service at their own expense.\n  */\n  FlanQuote[2] public latestFlanQuotes; //0 is latest\n\n  UniVARS VARS;\n\n  //not sure why codebases don't use keyword ether but I'm reluctant to entirely part with that tradition for now.\n  uint256 constant EXA = 1e18;\n\n  //needs to be updated for future Martian, Lunar and Venusian blockchains although I suspect Lunar colonies will be very Terracentric because of low time lag.\n  uint256 constant year = (1 days * 365);\n\n  /*\n    instead of relying on oracles, we simply require snapshots of important \n    prices to be taken at intervals far enough apart.\n    If an attacker wishes to overstate or understate a price through market manipulation,\n    they'd have to keep it out of equilibrium over the span of the two snapshots or they'd\n    have to time the manipulation to happen as the snapshots occur. As a miner,\n    they could do this through transaction ordering but they'd have to win two blocks at precise moments\n    which is statistically highly unlikely. \n    The snapshot enforcement can be hindered by false negatives. Natural price variation, for instance, but the cost\n    of this is just having to snapshot again when the market is calmer. Since migration is not not time sensitive,\n    this is a cost worth bearing.\n    */\n  modifier ensurePriceStability() {\n    _ensurePriceStability();\n    _;\n  }\n\n  modifier onlyLimbo() {\n    require(msg.sender == limbo);\n    _;\n  }\n\n  constructor(address _limbo, address limboDAO) Governable(limboDAO) {\n    limbo = _limbo;\n    VARS.blackHole = address(new BlackHole());\n    VARS.factory = IUniswapV2Factory(address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f));\n    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n  }\n\n  ///@notice LP tokens minted during migration are discarded.\n  function blackHole() public view returns (address) {\n    return VARS.blackHole;\n  }\n\n  ///@notice Uniswap factory contract\n  function setFactory(address factory) public {\n    require(block.chainid != 1, \"Uniswap factory hardcoded on mainnet\");\n    VARS.factory = IUniswapV2Factory(factory);\n  }\n\n  ///@dev Only for testing: On mainnet Dai has a fixed address.\n  function setDAI(address dai) public {\n    require(block.chainid != 1, \"DAI hardcoded on mainnet\");\n    VARS.DAI = dai;\n  }\n\n  ///@notice main configuration function.\n  ///@dev We prefer to use configuration functions rather than a constructor for a number of reasons.\n  ///@param _limbo Limbo contract\n  ///@param FlanSCXPair The Uniswap flan/SCX pair\n  ///@param behodler Behodler AMM\n  ///@param flan The flan token\n  ///@param divergenceTolerance The amount of price difference between the two quotes that is tolerated before a migration is attempted \n  ///@param minQuoteWaitDuration The minimum duration between the sampling of oracle data used for migration\n  ///@param precision In order to query the tokens redeemed by a quantity of SCX, Behodler performs a binary search. Precision refers to the max iterations of the search.\n  ///@param priceBoostOvershoot Flan targets parity with Dai. If we set Flan to equal Dai then between migrations, it will always be below Dai. Overshoot gives us some runway by intentionally \"overshooting\" the price\n  function configure(\n    address _limbo,\n    address FlanSCXPair,\n    address behodler,\n    address flan,\n    uint256 divergenceTolerance,\n    uint256 minQuoteWaitDuration,\n    uint8 precision,\n    uint8 priceBoostOvershoot\n  ) public onlySuccessfulProposal {\n    limbo = _limbo;\n    VARS.Flan_SCX_tokenPair = UniPairLike(FlanSCXPair);\n    VARS.behodler = behodler;\n    VARS.flan = flan;\n    require(divergenceTolerance >= 100, \"Divergence of 100 is parity\");\n    VARS.divergenceTolerance = divergenceTolerance;\n    VARS.minQuoteWaitDuration = minQuoteWaitDuration;\n    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    VARS.precision = precision == 0 ? precision : precision;\n    require(priceBoostOvershoot < 100, \"Set overshoot to number between 1 and 100.\");\n    VARS.priceBoostOvershoot = priceBoostOvershoot;\n  }\n\n  ///@notice Samples the two values required for migration. Must be called twice before migration can occur.\n  function generateFLNQuote() public override {\n    latestFlanQuotes[1] = latestFlanQuotes[0];\n    (\n      latestFlanQuotes[0].DaiScxSpotPrice,\n      latestFlanQuotes[0].DaiBalanceOnBehodler\n    ) = getLatestFLNQuote();\n    latestFlanQuotes[0].blockProduced = block.number;\n  }\n\n  function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {\n    uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(\n      VARS.DAI,\n      10000,\n      1 ether,\n      VARS.precision\n    );\n    dai_scx = (daiToRelease * EXA) / (1 ether);\n\n    daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);\n  }\n\n  ///@notice When tokens are migrated to Behodler, SCX is generated. This SCX is used to boost Flan liquidity and nudge the price of Flan back to parity with Dai\n  ///@param rectangleOfFairness refers to the quantity of SCX held back to be used for open market Flan stabilizing operations\n  ///@dev makes use of price tilting. Be sure to understand the concept of price tilting before trying to understand the final if statement.\n  function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {\n    uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));\n\n    //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.\n    //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes\n    require((localSCXBalance * 100) / rectangleOfFairness == 98, \"EM\");\n    rectangleOfFairness = localSCXBalance;\n\n    //get DAI per scx\n    uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));\n    uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;\n\n    //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.\n    uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);\n    address pair = address(VARS.Flan_SCX_tokenPair);\n    uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);\n\n    if (existingFlanOnLP < DesiredFinalFlanOnLP) {\n      uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;\n\n      flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;\n      FlanLike(VARS.flan).mint(pair, flanToMint);\n      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);\n      {\n        lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);\n      }\n    } else {\n      uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();\n\n      FlanLike(VARS.flan).mint(pair, minFlan + 2);\n      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);\n      lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);\n    }\n    //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.\n    _zeroOutQuotes();\n  }\n\n  ///@notice helper function for converting a desired APY into a flan per second (FPS) statistic\n  ///@param minAPY Here APY refers to the dollar value of flan relative to the dollar value of the threshold\n  ///@param daiThreshold The DAI value of the target threshold to list on Behodler. Threshold is an approximation of the AVB on Behodler\n  function minAPY_to_FPS(\n    uint256 minAPY, //divide by 10000 to get percentage\n    uint256 daiThreshold\n  ) public override view ensurePriceStability returns (uint256 fps) {\n    daiThreshold = daiThreshold == 0 ? latestFlanQuotes[0].DaiBalanceOnBehodler : daiThreshold;\n    // console.log(\"DAI threshold %s\", daiThreshold);\n    uint256 returnOnThreshold = (minAPY * daiThreshold) / 1e4;\n    fps = returnOnThreshold / (year);\n  }\n\n  ///@notice Buys Flan with a specified token, apportions 1% of the purchased Flan to the caller and burns the rest.\n  ///@param inputToken The token used to buy Flan\n  ///@param amount amount of input token used to buy Flan\n  ///@param recipient receives 1% of Flan purchased as an incentive to call this function regularly\n  ///@dev Assumes a pair for Flan/InputToken exists on Uniswap\n  function buyFlanAndBurn(\n    address inputToken,\n    uint256 amount,\n    address recipient\n  ) public override {\n    address pair = VARS.factory.getPair(inputToken, VARS.flan);\n\n    uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);\n    uint256 inputBalance = IERC20(inputToken).balanceOf(pair);\n\n    uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);\n    uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;\n    uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;\n    IERC20(inputToken).transfer(pair, amount);\n    UniPairLike(pair).swap(amount0Out, amount1Out, address(this), \"\");\n    uint256 reward = (amountOut / 100);\n    ERC20Burnable(VARS.flan).transfer(recipient, reward);\n    ERC20Burnable(VARS.flan).burn(amountOut - reward);\n  }\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountOut) {\n    uint256 amountInWithFee = amountIn * 997;\n    uint256 numerator = amountInWithFee * reserveOut;\n    uint256 denominator = reserveIn * 1000 + amountInWithFee;\n    amountOut = numerator / denominator;\n  }\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountIn) {\n    uint256 numerator = reserveIn * amountOut * 1000;\n    uint256 denominator = (reserveOut - amountOut) * 997;\n    amountIn = (numerator / denominator) + 1;\n  }\n\n  function _zeroOutQuotes() internal {\n    delete latestFlanQuotes[0];\n    delete latestFlanQuotes[1];\n  }\n\n  //the purpose of the divergence code is to bring the robustness of a good oracle without requiring an oracle\n  function _ensurePriceStability() internal view {\n    FlanQuote[2] memory localFlanQuotes; //save gas\n    localFlanQuotes[0] = latestFlanQuotes[0];\n    localFlanQuotes[1] = latestFlanQuotes[1];\n\n    uint256 daiSCXSpotPriceDivergence = localFlanQuotes[0].DaiScxSpotPrice > localFlanQuotes[1].DaiScxSpotPrice\n      ? (localFlanQuotes[0].DaiScxSpotPrice * 100) / localFlanQuotes[1].DaiScxSpotPrice\n      : (localFlanQuotes[1].DaiScxSpotPrice * 100) / localFlanQuotes[0].DaiScxSpotPrice;\n\n    uint256 daiBalanceDivergence = localFlanQuotes[0].DaiBalanceOnBehodler > localFlanQuotes[1].DaiBalanceOnBehodler\n      ? (localFlanQuotes[0].DaiBalanceOnBehodler * 100) / localFlanQuotes[1].DaiBalanceOnBehodler\n      : (localFlanQuotes[1].DaiBalanceOnBehodler * 100) / localFlanQuotes[0].DaiBalanceOnBehodler;\n\n    // console.log(\"dai balance divergence %s\", daiBalanceDivergence);\n    require(\n      daiSCXSpotPriceDivergence < VARS.divergenceTolerance && daiBalanceDivergence < VARS.divergenceTolerance,\n      \"EG\"\n    );\n\n    require(\n      localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration &&\n        localFlanQuotes[1].blockProduced > 0,\n      \"EH\"\n    );\n  }\n}\n\n\n",
        "CodeNames": [
            "Limbo.sol",
            "Flan.sol",
            "UniswapHelper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-07",
                "Location": [
                    "//solidity\nlocalFlanQuotes[0].blockProduced localFlanQuotes[1].blockProduced  VARS.minQuoteWaitDuration\n",
                    "//solidity\nlocalFlanQuotes[0].blockProduced localFlanQuotes[1].blockProduced  0\n"
                ],
                "Type": " Calling  generateFLNQuote  twice in every block prevents any migration",
                "Description": "\n<https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L138\nIn the Uniswap helper, generateFLNQuote is public, so any user can generate the latest quote. If you call this twice in any block, then the two latest flan quotes will have a blockProduced value of the current block's number.\n\nThese quotes are used in the _ensurePriceStability function. The last require statement here is key:\n<https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L283-L285\n\nThis function will revert if this statement is false:\nsolidity\nlocalFlanQuotes[0].blockProduced localFlanQuotes[1].blockProduced  VARS.minQuoteWaitDuration\n\n\nSince VARS.minQuoteWaitDuration is a uint256, it is at least 0\nsolidity\nlocalFlanQuotes[0].blockProduced localFlanQuotes[1].blockProduced  0\n\n\nBut, as we've shown above, we can create a transaction in every block that will make localFlanQuotes[0].blockProduced localFlanQuotes[1].blockProduced == 0. In any block we can make any call to _ensurePriceStability revert.\n\n_ensurePriceStability is called in the ensurePriceStability modifier:\n<https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L70\n\nThis modifier is used in stabilizeFlan:\n<https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L162\n\nLastly, stabilizeFlan is used in migrate in Limbo.sol\n<https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/Limbo.sol#L234\n\nTherefore, we can grief a migration in any block. In reality, the minQuoteWaitDuration would be set to a much higher value than 0, making this even easier to grief for people (you only need to call generateFLNQuote every minQuoteWaitDuration 1 blocks to be safe).\n\n\nMitigation is to just use a time weighted oracle for uniswap.\n\ngititGoro (Behodler) acknowledged and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/102#issuecomment-1027503228):\n  I appreciate the write up. You're not technically incorrect on the problem. The solution isn't ideal because Uniswap can't tell us what's happening on Behodler. \n \n UniswapHelper can be replaced without much trouble. So if the oracle functionality does fail, we can deploy a better one. But for now, I doubt that the incentive exists to perpetually grief migrations on Limbo. If someone does start to grief, we can add flash governance to the flan quote generation and then burn the EYE belonging to griefers but I was reluctant to call on the big guns right from the start.\n\ngititGoro (Behodler) changed to confirmed and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/102#issuecomment-1029344158):\n  I've changed this to confirmed because a cryptoeconomic layer should be added. Flash governance for sampling an oracle is too extreme and adding a require to force the duration can still be griefed.\n \n Instead I think the solution is to force the caller to pay EYE if the interval is below the min required. The EYE is then burnt.\n So the idea is that if you wish to grief migrations, it's going to cost you more than just gas and the community will benefit from your griefing. \n\n\n\n*\n\n\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./ERC677/ERC677.sol\";\nimport \"../contracts/DAO/Governable.sol\";\n\n///@author Justin Goro\n///@title Flan\n/**\n *@notice The reward token for Limbo. Flan can be minted without limit and is intended to converge on the price of DAI via various external incentives\n */\ncontract Flan is ERC677(\"Flan\", \"FLN\"), Governable {\n    event burnOnTransferFeeAdjusted(uint8 oldFee, uint8 newFee);\n    mapping(address => uint256) public mintAllowance; //type(uint).max == whitelist\n\n    uint8 public burnOnTransferFee = 0; //% between 1 and 100, recipient pays\n\n    constructor(address dao) Governable(dao) {}\n\n    /**\n    * @param fee - % between 1 and 100, recipient pays\n     */\n    function setBurnOnTransferFee(uint8 fee) public onlySuccessfulProposal {\n        _setBurnOnTransferFee(fee);\n    }\n\n    ///@notice flash governance technique for FOT change.\n    function incrementBurnOnTransferFee(int8 change)\n        public\n        governanceApproved(false)\n    {\n        uint8 newFee = uint8(int8(burnOnTransferFee) + change);\n        flashGoverner.enforceTolerance(newFee, burnOnTransferFee);\n        _setBurnOnTransferFee(newFee);\n    }\n\n    function _setBurnOnTransferFee(uint8 fee) internal {\n        uint8 priorFee = burnOnTransferFee;\n        burnOnTransferFee = fee > 100 ? 100 : fee;\n        emit burnOnTransferFeeAdjusted(priorFee, burnOnTransferFee);\n    }\n\n    ///@notice grants unlimited minting power to a contract\n    ///@param minter contract to be given unlimited minting power\n    ///@param enabled minting power enabled or disabled\n    function whiteListMinting(address minter, bool enabled)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = enabled ? type(uint256).max : 0;\n    }\n\n    ///@notice metered minting power. Useful for once off minting\n    function increaseMintAllowance(address minter, uint256 _allowance)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = mintAllowance[minter] + _allowance;\n    }\n\n    ///@notice minting of flan open to approved minters and LimboDAO\n    ///@param recipient address to receive flan\n    ///@param amount amount of flan to be minted \n    function mint(address recipient, uint256 amount) public returns (bool) {\n        uint256 allowance = mintAllowance[_msgSender()];\n        require(\n            _msgSender() == owner() || allowance >= amount,\n            \"Flan: Mint allowance exceeded\"\n        );\n        approvedMint(recipient, amount, _msgSender(), allowance);\n        return true;\n    }\n\n    function approvedMint(\n        address recipient,\n        uint256 amount,\n        address minter,\n        uint256 allowance\n    ) internal {\n        _mint(recipient, amount);\n        if (allowance < type(uint256).max && minter != owner()) {\n            mintAllowance[minter] = mintAllowance[minter] - amount;\n        }\n    }\n\n    function safeTransfer(address _to, uint256 _amount) external {\n        uint256 flanBal = balanceOf(address(this));\n        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;\n        _transfer(_msgSender(), _to, flanToTransfer);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 fee = (burnOnTransferFee * amount) / 100;\n\n        _totalSupply = _totalSupply - fee;\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount - fee;\n\n        emit Transfer(sender, recipient, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// import \"hardhat/console.sol\";\nimport \"./facades/LimboDAOLike.sol\";\nimport \"./facades/Burnable.sol\";\nimport \"./facades/BehodlerLike.sol\";\nimport \"./facades/FlanLike.sol\";\nimport \"./facades/UniPairLike.sol\";\nimport \"./facades/MigratorLike.sol\";\nimport \"./facades/AMMHelper.sol\";\nimport \"./facades/AngbandLike.sol\";\nimport \"./facades/LimboAddTokenToBehodlerPowerLike.sol\";\nimport \"./DAO/Governable.sol\";\nimport \"./facades/FlashGovernanceArbiterLike.sol\";\n\n/*\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can't unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don't want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n*/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/*\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n*/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted <= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), \"E8\");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), \"E9\");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress->index->stakingInfo\n  mapping(address => mapping(uint256 => Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address => uint256) public latestIndex;\n\n  ///@dev tokenAddress->userAddress->soulIndex->Userinfo\n  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;\n  ///@dev token->index->data\n  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul->owner->unstaker->amount\n  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, \"EF\");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, \"EI\");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, \"E1\");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance > 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor <= 10000, \"E6\");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.\n   */\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, \"E2\");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount > 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending > 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, \"E2\");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount >= amount, \"E4\");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending > 0 && amount > 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending > 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, \"E2\");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, \"E5\");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, \"E6\");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken > 0, \"ED\");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  */\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, \"E7\");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   */\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, \"EB\");\n    require(soul.state == SoulState.waitingToCross, \"E2\");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >\n        crossingConfig.crossingMigrationDelay,\n      \"EC\"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n\n\n",
        "CodeNames": [
            "Flan.sol",
            "Limbo.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-08",
                "Location": [
                    "adjustSoul",
                    "governanceApproved",
                    "claimReward",
                    "fps"
                ],
                "Type": " Tolerance is not enforced during a flash governance decision",
                "Description": "\nMost of the functions with a governanceApproved modifier call flashGoverner.enforceTolerance to ensure the provided parameters are restricted to some range of their original values. However, in the governanceApproved modifier, flashGoverner.setEnforcement(true); is called after the function body is executed, and thus the changed values are not restricted during the function execution.\n\nAn attacker can exploit this bug to change some critical parameters to arbitrary values by flash governance decisions. The effect will last until the community executes another proposal to correct the values. In the meanwhile, the attacker may make use of the corrupted values to launch an attack.\n\n\n1.  An attacker executes a flash governance decision, for example, the adjustSoul function of Limbo, and sets the fps of a soul to an extremely large value.\n2.  During the flash governance decision, some of his assets, for example, EYE, are locked in the FlashGovernanceArbiter contract.\n3.  He calls claimReward to get his rewards on the corresponding soul (assume that he has staked some number of the token before). Because of the manipulated fps, he gets a large number of Flan tokens as the reward.\n4.  Surely, he will lose his EYE tokens because of the malicious flash governance decision. However, as long as the attacker gets large enough Flan tokens, he is incentivized to launch such an attack.\n\nReferenced code:\nDAO/Governable.sol#L46-L57(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Governable.sol#L46-L57)\nLimbo.sol#L380-L381(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L380-L381)\nLimbo.sol#L327-L329(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L327-L329)\nLimbo.sol#L530(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L530)\nLimbo.sol#L628-L630(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L628-L630)\n\n",
                "Repair": "\nRewrite the _governanceApproved function and the governanceApproved modifier as follows:\nsolidity\nfunction _governanceApproved(bool emergency) internal {\n  bool successfulProposal = LimboDAOLike(DAO).successfulProposal(msg.sender);\n  if (successfulProposal) {\n    flashGoverner.setEnforcement(false);\n  } else if (configured) {\n    flashGoverner.setEnforcement(true);\n    flashGoverner.assertGovernanceApproved(msg.sender, address(this), emergency);\n  }\n}\n\nmodifier governanceApproved(bool emergency) {\n  _governanceApproved(emergency);\n  _;\n}\n\n\ngititGoro (Behodler) confirmed but disagreed with High severity and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/306#issuecomment-1030510740):\n  So this is a vulnerability for the very first execution of flashgovernance decision on a contract, after which it's safe. This is the type of thing that won't be acted upon because it will have gone away by the time the public interacts with Limbo. However, it is technically true so I'm confirming the issue.\n\nJack the Pug (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/306#issuecomment-1053333307):\n  Valid finding, but the conditions are quite strict, downgraded to Med.\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// import \"hardhat/console.sol\";\nimport \"./facades/LimboDAOLike.sol\";\nimport \"./facades/Burnable.sol\";\nimport \"./facades/BehodlerLike.sol\";\nimport \"./facades/FlanLike.sol\";\nimport \"./facades/UniPairLike.sol\";\nimport \"./facades/MigratorLike.sol\";\nimport \"./facades/AMMHelper.sol\";\nimport \"./facades/AngbandLike.sol\";\nimport \"./facades/LimboAddTokenToBehodlerPowerLike.sol\";\nimport \"./DAO/Governable.sol\";\nimport \"./facades/FlashGovernanceArbiterLike.sol\";\n\n/*\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can't unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don't want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n*/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/*\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n*/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted <= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), \"E8\");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), \"E9\");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress->index->stakingInfo\n  mapping(address => mapping(uint256 => Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address => uint256) public latestIndex;\n\n  ///@dev tokenAddress->userAddress->soulIndex->Userinfo\n  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;\n  ///@dev token->index->data\n  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul->owner->unstaker->amount\n  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, \"EF\");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, \"EI\");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, \"E1\");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance > 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor <= 10000, \"E6\");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.\n   */\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, \"E2\");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount > 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending > 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, \"E2\");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount >= amount, \"E4\");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending > 0 && amount > 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending > 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, \"E2\");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, \"E5\");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, \"E6\");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken > 0, \"ED\");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  */\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, \"E7\");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   */\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, \"EB\");\n    require(soul.state == SoulState.waitingToCross, \"E2\");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >\n        crossingConfig.crossingMigrationDelay,\n      \"EC\"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./facades/UniPairLike.sol\";\nimport \"./facades/BehodlerLike.sol\";\nimport \"./DAO/Governable.sol\";\n// import \"hardhat/console.sol\";\nimport \"./ERC677/ERC20Burnable.sol\";\nimport \"./facades/FlanLike.sol\";\nimport \"./testing/realUniswap/interfaces/IUniswapV2Factory.sol\";\nimport \"./facades/AMMHelper.sol\";\n\ncontract BlackHole {}\n\n///@Title Uniswap V2 helper for managing Flan liquidity on Uniswap V2, Sushiswap and any other compatible AMM\n///@author Justin Goro\n/**@notice Flan liquidity is boosted on Uniswap (or Sushiswap) via open market operations at the point of a token migration.\n  * UniswapHelper handles all the mechanics as well managing a just-in-time (Justin Time?) oracle\n */\ncontract UniswapHelper is Governable, AMMHelper {\n  address limbo;\n\n  struct UniVARS {\n    UniPairLike Flan_SCX_tokenPair;\n    address behodler;\n    address blackHole;\n    address flan;\n    uint256 divergenceTolerance;\n    uint256 minQuoteWaitDuration;\n    address DAI;\n    uint8 precision; // behodler uses a binary search. The higher this number, the more precise\n    IUniswapV2Factory factory;\n    uint8 priceBoostOvershoot; //percentage (0-100) for which the price must be overcorrected when strengthened to account for other AMMs\n  }\n\n  struct FlanQuote {\n    uint256 DaiScxSpotPrice;\n    uint256 DaiBalanceOnBehodler;\n    uint256 blockProduced;\n  }\n\n  /**@dev the Dai SCX price and the Dai balance on Behodler are both sampled twice before a migration can occur. \n  * The two samples have to be spaced a minimum duration and have to be the same values (within an error threshold). The objective here is to make price manipulation untenably expensive for an attacker\n  * so that the mining power expended (or the opportunity cost of eth staked) far exceeds the benefit to manipulating Limbo.\n  * The assumption of price stability isn't a bug because migrations aren't required to happen frequently. Instead if natural price drift occurs for non malicious reasons,\n  * the migration can be reattempted until a period of sufficient calm allows for migration. If a malicious actor injects volatility in order to prevent migration, by the principle\n  * of antifragility, they're doing the entire Ethereum ecosystem a service at their own expense.\n  */\n  FlanQuote[2] public latestFlanQuotes; //0 is latest\n\n  UniVARS VARS;\n\n  //not sure why codebases don't use keyword ether but I'm reluctant to entirely part with that tradition for now.\n  uint256 constant EXA = 1e18;\n\n  //needs to be updated for future Martian, Lunar and Venusian blockchains although I suspect Lunar colonies will be very Terracentric because of low time lag.\n  uint256 constant year = (1 days * 365);\n\n  /*\n    instead of relying on oracles, we simply require snapshots of important \n    prices to be taken at intervals far enough apart.\n    If an attacker wishes to overstate or understate a price through market manipulation,\n    they'd have to keep it out of equilibrium over the span of the two snapshots or they'd\n    have to time the manipulation to happen as the snapshots occur. As a miner,\n    they could do this through transaction ordering but they'd have to win two blocks at precise moments\n    which is statistically highly unlikely. \n    The snapshot enforcement can be hindered by false negatives. Natural price variation, for instance, but the cost\n    of this is just having to snapshot again when the market is calmer. Since migration is not not time sensitive,\n    this is a cost worth bearing.\n    */\n  modifier ensurePriceStability() {\n    _ensurePriceStability();\n    _;\n  }\n\n  modifier onlyLimbo() {\n    require(msg.sender == limbo);\n    _;\n  }\n\n  constructor(address _limbo, address limboDAO) Governable(limboDAO) {\n    limbo = _limbo;\n    VARS.blackHole = address(new BlackHole());\n    VARS.factory = IUniswapV2Factory(address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f));\n    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n  }\n\n  ///@notice LP tokens minted during migration are discarded.\n  function blackHole() public view returns (address) {\n    return VARS.blackHole;\n  }\n\n  ///@notice Uniswap factory contract\n  function setFactory(address factory) public {\n    require(block.chainid != 1, \"Uniswap factory hardcoded on mainnet\");\n    VARS.factory = IUniswapV2Factory(factory);\n  }\n\n  ///@dev Only for testing: On mainnet Dai has a fixed address.\n  function setDAI(address dai) public {\n    require(block.chainid != 1, \"DAI hardcoded on mainnet\");\n    VARS.DAI = dai;\n  }\n\n  ///@notice main configuration function.\n  ///@dev We prefer to use configuration functions rather than a constructor for a number of reasons.\n  ///@param _limbo Limbo contract\n  ///@param FlanSCXPair The Uniswap flan/SCX pair\n  ///@param behodler Behodler AMM\n  ///@param flan The flan token\n  ///@param divergenceTolerance The amount of price difference between the two quotes that is tolerated before a migration is attempted \n  ///@param minQuoteWaitDuration The minimum duration between the sampling of oracle data used for migration\n  ///@param precision In order to query the tokens redeemed by a quantity of SCX, Behodler performs a binary search. Precision refers to the max iterations of the search.\n  ///@param priceBoostOvershoot Flan targets parity with Dai. If we set Flan to equal Dai then between migrations, it will always be below Dai. Overshoot gives us some runway by intentionally \"overshooting\" the price\n  function configure(\n    address _limbo,\n    address FlanSCXPair,\n    address behodler,\n    address flan,\n    uint256 divergenceTolerance,\n    uint256 minQuoteWaitDuration,\n    uint8 precision,\n    uint8 priceBoostOvershoot\n  ) public onlySuccessfulProposal {\n    limbo = _limbo;\n    VARS.Flan_SCX_tokenPair = UniPairLike(FlanSCXPair);\n    VARS.behodler = behodler;\n    VARS.flan = flan;\n    require(divergenceTolerance >= 100, \"Divergence of 100 is parity\");\n    VARS.divergenceTolerance = divergenceTolerance;\n    VARS.minQuoteWaitDuration = minQuoteWaitDuration;\n    VARS.DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    VARS.precision = precision == 0 ? precision : precision;\n    require(priceBoostOvershoot < 100, \"Set overshoot to number between 1 and 100.\");\n    VARS.priceBoostOvershoot = priceBoostOvershoot;\n  }\n\n  ///@notice Samples the two values required for migration. Must be called twice before migration can occur.\n  function generateFLNQuote() public override {\n    latestFlanQuotes[1] = latestFlanQuotes[0];\n    (\n      latestFlanQuotes[0].DaiScxSpotPrice,\n      latestFlanQuotes[0].DaiBalanceOnBehodler\n    ) = getLatestFLNQuote();\n    latestFlanQuotes[0].blockProduced = block.number;\n  }\n\n  function getLatestFLNQuote() internal view returns (uint256 dai_scx, uint256 daiBalanceOnBehodler) {\n    uint256 daiToRelease = BehodlerLike(VARS.behodler).withdrawLiquidityFindSCX(\n      VARS.DAI,\n      10000,\n      1 ether,\n      VARS.precision\n    );\n    dai_scx = (daiToRelease * EXA) / (1 ether);\n\n    daiBalanceOnBehodler = IERC20(VARS.DAI).balanceOf(VARS.behodler);\n  }\n\n  ///@notice When tokens are migrated to Behodler, SCX is generated. This SCX is used to boost Flan liquidity and nudge the price of Flan back to parity with Dai\n  ///@param rectangleOfFairness refers to the quantity of SCX held back to be used for open market Flan stabilizing operations\n  ///@dev makes use of price tilting. Be sure to understand the concept of price tilting before trying to understand the final if statement.\n  function stabilizeFlan(uint256 rectangleOfFairness) public override onlyLimbo ensurePriceStability returns (uint256 lpMinted) {\n    uint256 localSCXBalance = IERC20(VARS.behodler).balanceOf(address(this));\n\n    //SCX transfers incur a 2% fee. Checking that SCX balance === rectangleOfFairness must take this into account.\n    //Note that for hardcoded values, this contract can be upgraded through governance so we're not ignoring potential Behodler configuration changes\n    require((localSCXBalance * 100) / rectangleOfFairness == 98, \"EM\");\n    rectangleOfFairness = localSCXBalance;\n\n    //get DAI per scx\n    uint256 existingSCXBalanceOnLP = IERC20(VARS.behodler).balanceOf(address(VARS.Flan_SCX_tokenPair));\n    uint256 finalSCXBalanceOnLP = existingSCXBalanceOnLP + rectangleOfFairness;\n\n    //the DAI value of SCX is the final quantity of Flan because we want Flan to hit parity with Dai.\n    uint256 DesiredFinalFlanOnLP = ((finalSCXBalanceOnLP * latestFlanQuotes[0].DaiScxSpotPrice) / EXA);\n    address pair = address(VARS.Flan_SCX_tokenPair);\n    uint256 existingFlanOnLP = IERC20(VARS.flan).balanceOf(pair);\n\n    if (existingFlanOnLP < DesiredFinalFlanOnLP) {\n      uint256 flanToMint = ((DesiredFinalFlanOnLP - existingFlanOnLP) * (100 - VARS.priceBoostOvershoot)) / 100;\n\n      flanToMint = flanToMint == 0 ? DesiredFinalFlanOnLP - existingFlanOnLP : flanToMint;\n      FlanLike(VARS.flan).mint(pair, flanToMint);\n      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);\n      {\n        lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);\n      }\n    } else {\n      uint256 minFlan = existingFlanOnLP / VARS.Flan_SCX_tokenPair.totalSupply();\n\n      FlanLike(VARS.flan).mint(pair, minFlan + 2);\n      IERC20(VARS.behodler).transfer(pair, rectangleOfFairness);\n      lpMinted = VARS.Flan_SCX_tokenPair.mint(VARS.blackHole);\n    }\n    //Don't allow future migrations to piggy back off the data collected by recent migrations. Forces attackers to face the same cryptoeconomic barriers each time.\n    _zeroOutQuotes();\n  }\n\n  ///@notice helper function for converting a desired APY into a flan per second (FPS) statistic\n  ///@param minAPY Here APY refers to the dollar value of flan relative to the dollar value of the threshold\n  ///@param daiThreshold The DAI value of the target threshold to list on Behodler. Threshold is an approximation of the AVB on Behodler\n  function minAPY_to_FPS(\n    uint256 minAPY, //divide by 10000 to get percentage\n    uint256 daiThreshold\n  ) public override view ensurePriceStability returns (uint256 fps) {\n    daiThreshold = daiThreshold == 0 ? latestFlanQuotes[0].DaiBalanceOnBehodler : daiThreshold;\n    // console.log(\"DAI threshold %s\", daiThreshold);\n    uint256 returnOnThreshold = (minAPY * daiThreshold) / 1e4;\n    fps = returnOnThreshold / (year);\n  }\n\n  ///@notice Buys Flan with a specified token, apportions 1% of the purchased Flan to the caller and burns the rest.\n  ///@param inputToken The token used to buy Flan\n  ///@param amount amount of input token used to buy Flan\n  ///@param recipient receives 1% of Flan purchased as an incentive to call this function regularly\n  ///@dev Assumes a pair for Flan/InputToken exists on Uniswap\n  function buyFlanAndBurn(\n    address inputToken,\n    uint256 amount,\n    address recipient\n  ) public override {\n    address pair = VARS.factory.getPair(inputToken, VARS.flan);\n\n    uint256 flanBalance = IERC20(VARS.flan).balanceOf(pair);\n    uint256 inputBalance = IERC20(inputToken).balanceOf(pair);\n\n    uint256 amountOut = getAmountOut(amount, inputBalance, flanBalance);\n    uint256 amount0Out = inputToken < VARS.flan ? 0 : amountOut;\n    uint256 amount1Out = inputToken < VARS.flan ? amountOut : 0;\n    IERC20(inputToken).transfer(pair, amount);\n    UniPairLike(pair).swap(amount0Out, amount1Out, address(this), \"\");\n    uint256 reward = (amountOut / 100);\n    ERC20Burnable(VARS.flan).transfer(recipient, reward);\n    ERC20Burnable(VARS.flan).burn(amountOut - reward);\n  }\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountOut) {\n    uint256 amountInWithFee = amountIn * 997;\n    uint256 numerator = amountInWithFee * reserveOut;\n    uint256 denominator = reserveIn * 1000 + amountInWithFee;\n    amountOut = numerator / denominator;\n  }\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountIn) {\n    uint256 numerator = reserveIn * amountOut * 1000;\n    uint256 denominator = (reserveOut - amountOut) * 997;\n    amountIn = (numerator / denominator) + 1;\n  }\n\n  function _zeroOutQuotes() internal {\n    delete latestFlanQuotes[0];\n    delete latestFlanQuotes[1];\n  }\n\n  //the purpose of the divergence code is to bring the robustness of a good oracle without requiring an oracle\n  function _ensurePriceStability() internal view {\n    FlanQuote[2] memory localFlanQuotes; //save gas\n    localFlanQuotes[0] = latestFlanQuotes[0];\n    localFlanQuotes[1] = latestFlanQuotes[1];\n\n    uint256 daiSCXSpotPriceDivergence = localFlanQuotes[0].DaiScxSpotPrice > localFlanQuotes[1].DaiScxSpotPrice\n      ? (localFlanQuotes[0].DaiScxSpotPrice * 100) / localFlanQuotes[1].DaiScxSpotPrice\n      : (localFlanQuotes[1].DaiScxSpotPrice * 100) / localFlanQuotes[0].DaiScxSpotPrice;\n\n    uint256 daiBalanceDivergence = localFlanQuotes[0].DaiBalanceOnBehodler > localFlanQuotes[1].DaiBalanceOnBehodler\n      ? (localFlanQuotes[0].DaiBalanceOnBehodler * 100) / localFlanQuotes[1].DaiBalanceOnBehodler\n      : (localFlanQuotes[1].DaiBalanceOnBehodler * 100) / localFlanQuotes[0].DaiBalanceOnBehodler;\n\n    // console.log(\"dai balance divergence %s\", daiBalanceDivergence);\n    require(\n      daiSCXSpotPriceDivergence < VARS.divergenceTolerance && daiBalanceDivergence < VARS.divergenceTolerance,\n      \"EG\"\n    );\n\n    require(\n      localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration &&\n        localFlanQuotes[1].blockProduced > 0,\n      \"EH\"\n    );\n  }\n}\n\n\n",
        "CodeNames": [
            "Limbo.sol",
            "UniswapHelper.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-11",
                "Location": [
                    "rectangleOfFairness",
                    "localSCXBalance",
                    "buyFlanAndBurn"
                ],
                "Type": " You can grief migrations by sending SCX to the UniswapHelper",
                "Description": "\nThe attack here allows the attacker to prevent migrations.\n\nThe attack here is recoverable because we can just call buyFlanAndBurn (f it worked as expected) with SCX as the input token to buy Flan with the extra SCX, then run the migration again.\n\n\nThe attack here is simple:\n\n1.  Get some SCX\n2.  Send it to the UniswapHelper contract\n3.  Any migration called will revert\n\nMy proof of concept test. You should be able to use this directly in the thig\n<https://gist.github.com/CamdenClark/b6841ac7a63e868d90eff7d9a40e3e0a\n\n<https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/UniswapHelper.sol#L167\n\nlocalSCXBalance is the SCX balance of the uniswap helper. <https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/UniswapHelper.sol#L163\n\nBut, the caller of stablizeFlan assumes that the rectangleOfFairness parameter is going to be equal to the amount of SCX that was sent\n<https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/Limbo.sol#L234\n\n",
                "Repair": "\nThe mitigation could be to do = instead of == so sending tokens can't grief this.\n\nBeyond this though, why do you need to pass in rectangleOfFairness if we're requiring it to be a function of the localSCXBalance anyways? <https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/UniswapHelper.sol#L167\n\ngititGoro (Behodler) acknowledged and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/105#issuecomment-1027518632):\n  It's interesting to think about this issue because it's the type of tight rope walk between incentives and code enforcement. In this scenario, the net results of the griefing will be both a higher flan and scx price. So in exchange for a timely migration, we get a boost to flan and scx (which is precisely the goal of a migration from Limbo's perspective).  Eventually we get the migration we wanted but only after some price assist from a griefer.\n For this cryptoeconomic reason, I've marked it as acknowledged rather than confirmed. \n \n Still I appreciate the depth with which you've thought about this and I hope the Behodler community sees more of you after this audit.\n\nJack the Pug (judge) commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/105#issuecomment-1053361876):\n  Good catch! Thank you for creating the proof of concept test script. The Code4rena community needs more wardens like you!\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./ERC677/ERC677.sol\";\nimport \"../contracts/DAO/Governable.sol\";\n\n///@author Justin Goro\n///@title Flan\n/**\n *@notice The reward token for Limbo. Flan can be minted without limit and is intended to converge on the price of DAI via various external incentives\n */\ncontract Flan is ERC677(\"Flan\", \"FLN\"), Governable {\n    event burnOnTransferFeeAdjusted(uint8 oldFee, uint8 newFee);\n    mapping(address => uint256) public mintAllowance; //type(uint).max == whitelist\n\n    uint8 public burnOnTransferFee = 0; //% between 1 and 100, recipient pays\n\n    constructor(address dao) Governable(dao) {}\n\n    /**\n    * @param fee - % between 1 and 100, recipient pays\n     */\n    function setBurnOnTransferFee(uint8 fee) public onlySuccessfulProposal {\n        _setBurnOnTransferFee(fee);\n    }\n\n    ///@notice flash governance technique for FOT change.\n    function incrementBurnOnTransferFee(int8 change)\n        public\n        governanceApproved(false)\n    {\n        uint8 newFee = uint8(int8(burnOnTransferFee) + change);\n        flashGoverner.enforceTolerance(newFee, burnOnTransferFee);\n        _setBurnOnTransferFee(newFee);\n    }\n\n    function _setBurnOnTransferFee(uint8 fee) internal {\n        uint8 priorFee = burnOnTransferFee;\n        burnOnTransferFee = fee > 100 ? 100 : fee;\n        emit burnOnTransferFeeAdjusted(priorFee, burnOnTransferFee);\n    }\n\n    ///@notice grants unlimited minting power to a contract\n    ///@param minter contract to be given unlimited minting power\n    ///@param enabled minting power enabled or disabled\n    function whiteListMinting(address minter, bool enabled)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = enabled ? type(uint256).max : 0;\n    }\n\n    ///@notice metered minting power. Useful for once off minting\n    function increaseMintAllowance(address minter, uint256 _allowance)\n        public\n        onlySuccessfulProposal\n    {\n        mintAllowance[minter] = mintAllowance[minter] + _allowance;\n    }\n\n    ///@notice minting of flan open to approved minters and LimboDAO\n    ///@param recipient address to receive flan\n    ///@param amount amount of flan to be minted \n    function mint(address recipient, uint256 amount) public returns (bool) {\n        uint256 allowance = mintAllowance[_msgSender()];\n        require(\n            _msgSender() == owner() || allowance >= amount,\n            \"Flan: Mint allowance exceeded\"\n        );\n        approvedMint(recipient, amount, _msgSender(), allowance);\n        return true;\n    }\n\n    function approvedMint(\n        address recipient,\n        uint256 amount,\n        address minter,\n        uint256 allowance\n    ) internal {\n        _mint(recipient, amount);\n        if (allowance < type(uint256).max && minter != owner()) {\n            mintAllowance[minter] = mintAllowance[minter] - amount;\n        }\n    }\n\n    function safeTransfer(address _to, uint256 _amount) external {\n        uint256 flanBal = balanceOf(address(this));\n        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;\n        _transfer(_msgSender(), _to, flanToTransfer);\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal override {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 fee = (burnOnTransferFee * amount) / 100;\n\n        _totalSupply = _totalSupply - fee;\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount - fee;\n\n        emit Transfer(sender, recipient, amount);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../ERC677/ERC677.sol\";\nimport \"../Flan.sol\";\nimport \"./ProposalFactory.sol\";\nimport \"../facades/SwapFactoryLike.sol\";\nimport \"../facades/UniPairLike.sol\";\nimport \"./Governable.sol\";\n\n// import \"hardhat/console.sol\";\n\nlibrary TransferHelper {\n  function ERC20NetTransfer(\n    address token,\n    address from,\n    address to,\n    int256 amount\n  ) public {\n    if (amount > 0) {\n      require(IERC20(token).transferFrom(from, to, uint256(amount)), \"LimboDAO: ERC20 transfer from failed.\");\n    } else {\n      require(IERC20(token).transfer(from, uint256(amount * (-1))), \"LimboDAO: ERC20 transfer failed.\");\n    }\n  }\n}\n\nenum FateGrowthStrategy {\n  straight,\n  directRoot,\n  indirectTwoRootEye\n}\n\nenum ProposalDecision {\n  voting,\n  approved,\n  rejected\n}\n\n///@title Limbo DAO\n///@author Justin Goro\n/**@notice\n *This is the first MicroDAO associated with MorgothDAO. A MicroDAO manages parameterization of running dapps without having\n *control over existential functionality. This is not to say that some of the decisions taken are not critical but that the domain\n *of influence is confined to the local Dapp - Limbo in this case.\n * LimboDAO has two forms of decision making: proposals and flash governance. For proposals, voting power is required. Voting power in LimboDAO is measured\n * by a points system called Fate. Staking EYE or an EYE based LP earns Fate at a quadratic rate. Fate can be used to list a proposal for voting or to vote.\n * Using Fate to make a governance decisions spens it out of existince. So Fate reflects the opportunity cost of staking.\n * Flash governance is for instant decision making that cannot wait for voting to occur. Best used for small tweaks to parameters or emergencies.\n * Flash governance requires a governance asset (EYE) be staked at the time of the execution. The asset cannot be withdrawn for a certain period of time,\n * allowing for Fate holders to vote on the legitimacy of the decision. If the decision is considered malicious, the staked EYE is burnt.\n */\n///@dev Contracts subject to LimboDAO must inherit the Governable abstract contract.\ncontract LimboDAO is Ownable {\n  event daoKilled(address newOwner);\n  event proposalLodged(address proposal, address proposer);\n  event voteCast(address voter, address proposal, int256 fateCast);\n  event assetApproval(address asset, bool appoved);\n  event proposalExecuted(address proposal, bool approved);\n  event assetBurnt(address burner, address asset, uint256 fateCreated);\n\n  using TransferHelper for address;\n  uint256 constant ONE = 1 ether;\n  uint256 precision = 1e9;\n\n  struct DomainConfig {\n    address limbo;\n    address flan;\n    address eye;\n    address fate;\n    bool live;\n    address flashGoverner;\n    address sushiFactory;\n    address uniFactory;\n  }\n\n  struct ProposalConfig {\n    uint256 votingDuration;\n    uint256 requiredFateStake;\n    address proposalFactory; //check this for creating proposals\n  }\n\n  struct ProposalState {\n    int256 fate;\n    ProposalDecision decision;\n    address proposer;\n    uint256 start;\n    Proposal proposal;\n  }\n\n  //rateCrate\n  struct FateState {\n    uint256 fatePerDay;\n    uint256 fateBalance;\n    uint256 lastDamnAdjustment;\n  }\n\n  struct AssetClout {\n    uint256 fateWeight;\n    uint256 balance;\n  }\n\n  DomainConfig public domainConfig;\n  ProposalConfig public proposalConfig;\n\n  /**@notice for staking EYE, we simply take the square root of staked amount.\n   * For LP tokens, only half the value of the token is EYE so it's tempting to take the square root for the EYE balance. However this punishes the holder by ignoring the cost incurred by supplying the other asset. Since the other asset at rest is equal in value to the EYE balance, we just multiply the calculation by 2.\n   */\n  mapping(address => FateGrowthStrategy) public fateGrowthStrategy;\n  mapping(address => bool) public assetApproved;\n  mapping(address => FateState) public fateState; //lateDate\n\n  //Fate is earned per day. Keeping track of relative staked values, we can increment user balance\n  mapping(address => mapping(address => AssetClout)) public stakedUserAssetWeight; //user->asset->weight\n\n  ProposalState public currentProposalState;\n  ProposalState public previousProposalState;\n\n  // Since staking EYE precludes it from earning Flan on Limbo, fateToFlan can optionally be set to a non zero number to allow fat holders to spend their fate for Flan.\n  uint256 public fateToFlan;\n\n  modifier isLive() {\n    require(domainConfig.live, \"LimboDAO: DAO is not live.\");\n    _;\n  }\n\n  function nextProposal() internal {\n    previousProposalState = currentProposalState;\n    currentProposalState.proposal = Proposal(address(0));\n    currentProposalState.fate = 0;\n    currentProposalState.decision = ProposalDecision.voting;\n    currentProposalState.proposer = address(0);\n    currentProposalState.start = 0;\n  }\n\n  modifier onlySuccessfulProposal() {\n    // console.log('onlySuccessfulProposal');\n    require(successfulProposal(msg.sender), \"LimboDAO: approve proposal\");\n    _;\n    //nextProposal();\n  }\n\n  ///@notice has a proposal successfully been approved?\n  function successfulProposal(address proposal) public view returns (bool) {\n    return\n      currentProposalState.decision == ProposalDecision.approved && proposal == address(currentProposalState.proposal);\n  }\n\n  modifier updateCurrentProposal() {\n    incrementFateFor(_msgSender());\n    if (address(currentProposalState.proposal) != address(0)) {\n      uint256 durationSinceStart = block.timestamp - currentProposalState.start;\n      if (\n        durationSinceStart >= proposalConfig.votingDuration && currentProposalState.decision == ProposalDecision.voting\n      ) {\n        if (currentProposalState.fate > 0) {\n          currentProposalState.decision = ProposalDecision.approved;\n          currentProposalState.proposal.orchestrateExecute();\n          fateState[currentProposalState.proposer].fateBalance += proposalConfig.requiredFateStake;\n        } else {\n          currentProposalState.decision = ProposalDecision.rejected;\n        }\n        emit proposalExecuted(\n          address(currentProposalState.proposal),\n          currentProposalState.decision == ProposalDecision.approved\n        );\n        nextProposal();\n      }\n    }\n    _;\n  }\n\n  modifier incrementFate() {\n    incrementFateFor(_msgSender());\n    _;\n  }\n\n  function incrementFateFor(address user) public {\n    FateState storage state = fateState[user];\n    state.fateBalance += (state.fatePerDay * (block.timestamp - state.lastDamnAdjustment)) / (1 days);\n    state.lastDamnAdjustment = block.timestamp;\n  }\n\n  ///@param limbo address of Limbo\n  ///@param flan address of Flan\n  ///@param eye address of EYE token\n  ///@param proposalFactory authenticates and instantiates valid proposals for voting\n  ///@param sushiFactory is the SushiSwap Factory contract\n  ///@param uniFactory is the UniSwapV2 Factory contract\n  ///@param flashGoverner oversees flash governance cryptoeconomics\n  ///@param precisionOrderOfMagnitude when comparing fractional values, it's not necessary to get every last digit right\n  ///@param sushiLPs valid EYE containing LP tokens elligible for earning Fate through staking\n  ///@param uniLPs valid EYE containing LP tokens elligible for earning Fate through staking\n  function seed(\n    address limbo,\n    address flan,\n    address eye,\n    address proposalFactory,\n    address sushiFactory,\n    address uniFactory,\n    address flashGoverner,\n    uint256 precisionOrderOfMagnitude,\n    address[] memory sushiLPs,\n    address[] memory uniLPs\n  ) public onlyOwner {\n    _seed(limbo, flan, eye, sushiFactory, uniFactory, flashGoverner);\n    proposalConfig.votingDuration = 2 days;\n    proposalConfig.requiredFateStake = 223 * ONE; //50000 EYE for 24 hours\n    proposalConfig.proposalFactory = proposalFactory;\n    precision = 10**precisionOrderOfMagnitude;\n    for (uint256 i = 0; i < sushiLPs.length; i++) {\n      require(UniPairLike(sushiLPs[i]).factory() == sushiFactory, \"LimboDAO: invalid Sushi LP\");\n      if (IERC20(eye).balanceOf(sushiLPs[i]) > 1000) assetApproved[sushiLPs[i]] = true;\n      fateGrowthStrategy[sushiLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;\n    }\n    for (uint256 i = 0; i < uniLPs.length; i++) {\n      require(UniPairLike(uniLPs[i]).factory() == uniFactory, \"LimboDAO: invalid Sushi LP\");\n      if (IERC20(eye).balanceOf(uniLPs[i]) > 1000) assetApproved[uniLPs[i]] = true;\n      fateGrowthStrategy[uniLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;\n    }\n  }\n\n  ///@notice allows Limbo to be governed by a new DAO\n  ///@dev functions marked by onlyOwner are governed by MorgothDAO\n  function killDAO(address newOwner) public onlyOwner isLive {\n    domainConfig.live = false;\n    Governable(domainConfig.flan).setDAO(newOwner);\n    Governable(domainConfig.limbo).setDAO(newOwner);\n    emit daoKilled(newOwner);\n  }\n\n  ///@notice optional conversion rate of Fate to Flan\n  function setFateToFlan(uint256 rate) public onlySuccessfulProposal {\n    fateToFlan = rate;\n  }\n\n  ///@notice caller spends their Fate to earn Flan\n  function convertFateToFlan(uint256 fate) public returns (uint256 flan) {\n    require(fateToFlan > 0, \"LimboDAO: Fate conversion to Flan disabled.\");\n    fateState[msg.sender].fateBalance -= fate;\n    flan = (fateToFlan * fate) / ONE;\n    Flan(domainConfig.flan).mint(msg.sender, flan);\n  }\n\n  /**@notice handles proposal lodging logic. A deposit of Fate is removed from the user. If the decision is a success, half the fate is returned.\n   *  This is to encourage only lodging of proposals that are likely to succeed.\n   *  @dev not for external calling. Use the proposalFactory to lodge a proposal instead.\n   */\n  function makeProposal(address proposal, address proposer) public updateCurrentProposal {\n    address sender = _msgSender();\n    require(sender == proposalConfig.proposalFactory, \"LimboDAO: only Proposal Factory\");\n    require(address(currentProposalState.proposal) == address(0), \"LimboDAO: active proposal.\");\n\n    fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2;\n    currentProposalState.proposal = Proposal(proposal);\n    currentProposalState.decision = ProposalDecision.voting;\n    currentProposalState.fate = 0;\n    currentProposalState.proposer = proposer;\n    currentProposalState.start = block.timestamp;\n    emit proposalLodged(proposal, proposer);\n  }\n\n  ///@notice handles proposal voting logic.\n  ///@param proposal contract to be voted on\n  ///@param fate positive is YES, negative is NO. Absolute value is deducted from caller.\n  function vote(address proposal, int256 fate) public incrementFate isLive {\n    require(\n      proposal == address(currentProposalState.proposal), //this is just to protect users with out of sync UIs\n      \"LimboDAO: stated proposal does not match current proposal\"\n    );\n    require(currentProposalState.decision == ProposalDecision.voting, \"LimboDAO: voting on proposal closed\");\n    if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration - 1 hours) {\n      int256 currentFate = currentProposalState.fate;\n      //check if voting has ended\n      if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) {\n        revert(\"LimboDAO: voting for current proposal has ended.\");\n      } else if (\n        //The following if statement checks if the vote is flipped by fate\n        fate * currentFate < 0 && //sign different\n        (fate + currentFate) * fate > 0 //fate flipped current fate onto the same side of zero as fate\n      ) {\n        //extend voting duration when vote flips decision. Suggestion made by community member\n        currentProposalState.start = currentProposalState.start + 2 hours;\n      }\n    }\n    uint256 cost = fate > 0 ? uint256(fate) : uint256(-fate);\n    fateState[_msgSender()].fateBalance = fateState[_msgSender()].fateBalance - cost;\n\n    currentProposalState.fate += fate;\n    emit voteCast(_msgSender(), proposal, fate);\n  }\n\n  ///@notice pushes the decision to execute a successful proposal. For convenience only\n  function executeCurrentProposal() public updateCurrentProposal {}\n\n  ///@notice parameterizes the voting\n  ///@param requiredFateStake the amount of Fate required to lodge a proposal\n  ///@param votingDuration the duration of voting in seconds\n  ///@param proposalFactory the address of the proposal factory\n  function setProposalConfig(\n    uint256 votingDuration,\n    uint256 requiredFateStake,\n    address proposalFactory\n  ) public onlySuccessfulProposal {\n    proposalConfig.votingDuration = votingDuration;\n    proposalConfig.requiredFateStake = requiredFateStake;\n    proposalConfig.proposalFactory = proposalFactory;\n  }\n\n  ///@notice Assets approved for earning Fate\n  function setApprovedAsset(address asset, bool approved) public onlySuccessfulProposal {\n    assetApproved[asset] = approved;\n    fateGrowthStrategy[asset] = FateGrowthStrategy.indirectTwoRootEye;\n    emit assetApproval(asset, approved);\n  }\n\n  ///@notice handles staking logic for EYE and EYE based assets so that correct rate of fate is earned.\n  ///@param finalAssetBalance after staking, what is the final user balance on LimboDAO of the asset in question\n  ///@param finalEYEBalance if EYE is being staked, this value is the same as finalAssetBalance but for LPs it's about half\n  ///@param rootEYE offload high gas arithmetic to the client. Cheap to verify. Square root in fixed point requires Babylonian algorithm\n  ///@param asset the asset being staked\n  function setEYEBasedAssetStake(\n    uint256 finalAssetBalance,\n    uint256 finalEYEBalance,\n    uint256 rootEYE,\n    address asset\n  ) public isLive incrementFate {\n    require(assetApproved[asset], \"LimboDAO: illegal asset\");\n    address sender = _msgSender();\n    FateGrowthStrategy strategy = fateGrowthStrategy[asset];\n\n    //verifying that rootEYE value is accurate within precision.\n    uint256 rootEYESquared = rootEYE * rootEYE;\n    uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);\n    require(\n      rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,\n      \"LimboDAO: Stake EYE invariant.\"\n    );\n    AssetClout storage clout = stakedUserAssetWeight[sender][asset];\n    fateState[sender].fatePerDay -= clout.fateWeight;\n    uint256 initialBalance = clout.balance;\n    //EYE\n    if (strategy == FateGrowthStrategy.directRoot) {\n      require(finalAssetBalance == finalEYEBalance, \"LimboDAO: staking eye invariant.\");\n      require(asset == domainConfig.eye);\n\n      clout.fateWeight = rootEYE;\n      clout.balance = finalAssetBalance;\n      fateState[sender].fatePerDay += rootEYE;\n    } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {\n      //LP\n      clout.fateWeight = 2 * rootEYE;\n      fateState[sender].fatePerDay += clout.fateWeight;\n\n      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\n      require(actualEyeBalance > 0, \"LimboDAO: No EYE\");\n      uint256 totalSupply = IERC20(asset).totalSupply();\n      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;\n      uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);\n      finalEYEBalance /= precision;\n      require(\n        finalEYEBalance == impliedEye, //precision cap\n        \"LimboDAO: stake invariant check 2.\"\n      );\n      clout.balance = finalAssetBalance;\n    } else {\n      revert(\"LimboDAO: asset growth strategy not accounted for\");\n    }\n    int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);\n    asset.ERC20NetTransfer(sender, address(this), netBalance);\n  }\n\n  /**\n   *@notice Acquiring enough fate to either influence a decision or to lodge a proposal can take very long.\n   * If a very important decision has to be acted on via a proposal, the option exists to buy large quantities for fate instantly by burning an EYE based asset\n   * This may be necessary if a vote is nearly complete by the looming outcome is considered unacceptable.\n   * While Fate accumulation is quadratic for staking, burning is linear and subject to a factor of 10. This gives whales effective veto power but at the cost of a permanent\n   * loss of EYE.\n   *@param asset the asset to burn and can be EYE or EYE based assets\n   *@param amount the amount of asset to burn\n   */\n  function burnAsset(address asset, uint256 amount) public isLive incrementFate {\n    require(assetApproved[asset], \"LimboDAO: illegal asset\");\n    address sender = _msgSender();\n    require(ERC677(asset).transferFrom(sender, address(this), amount), \"LimboDAO: transferFailed\");\n    uint256 fateCreated = fateState[_msgSender()].fateBalance;\n    if (asset == domainConfig.eye) {\n      fateCreated = amount * 10;\n      ERC677(domainConfig.eye).burn(amount);\n    } else {\n      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\n      require(actualEyeBalance > 0, \"LimboDAO: No EYE\");\n      uint256 totalSupply = IERC20(asset).totalSupply();\n      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;\n      uint256 impliedEye = (eyePerUnit * amount) / ONE;\n      fateCreated = impliedEye * 20;\n    }\n    fateState[_msgSender()].fateBalance += fateCreated;\n    emit assetBurnt(_msgSender(), asset, fateCreated);\n  }\n\n  ///@notice grants unlimited Flan minting power to an address.\n  function approveFlanMintingPower(address minter, bool enabled) public onlySuccessfulProposal isLive {\n    Flan(domainConfig.flan).increaseMintAllowance(minter, enabled ? type(uint256).max : 0);\n  }\n\n  ///@notice call this after initial config is complete.\n  function makeLive() public onlyOwner {\n    require(\n      Governable(domainConfig.limbo).DAO() == address(this) && Governable(domainConfig.flan).DAO() == address(this),\n      \"LimboDAO: transfer ownership of limbo and flan.\"\n    );\n    domainConfig.live = true;\n  }\n\n  ///@notice if the DAO is being dismantled, it's necessary to transfer any owned items\n  function transferOwnershipOfThing(address thing, address destination) public onlySuccessfulProposal {\n    Ownable(thing).transferOwnership(destination);\n  }\n\n  function timeRemainingOnProposal() public view returns (uint256) {\n    require(currentProposalState.decision == ProposalDecision.voting, \"LimboDAO: proposal finished.\");\n    uint256 elapsed = block.timestamp - currentProposalState.start;\n    if (elapsed > proposalConfig.votingDuration) return 0;\n    return proposalConfig.votingDuration - elapsed;\n  }\n\n  /**@notice seed is a goro idiom for initialize that you tend to find in all the dapps I've written.\n   * I prefer initialization funcitons to parameterized solidity constructors for reasons beyond the scope of this comment.\n   */\n  function _seed(\n    address limbo,\n    address flan,\n    address eye,\n    address sushiFactory,\n    address uniFactory,\n    address flashGoverner\n  ) internal {\n    domainConfig.limbo = limbo;\n    domainConfig.flan = flan;\n    domainConfig.eye = eye;\n    domainConfig.uniFactory = uniFactory;\n    domainConfig.sushiFactory = sushiFactory;\n    domainConfig.flashGoverner = flashGoverner;\n    assetApproved[eye] = true;\n    fateGrowthStrategy[eye] = FateGrowthStrategy.directRoot;\n  }\n\n  function getFlashGoverner() external view returns (address) {\n    return domainConfig.flashGoverner;\n  }\n}\n\n\n",
        "CodeNames": [
            "Flan.sol",
            "LimboDAO.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-12",
                "Location": [
                    "currentFate",
                    "(fate + currentFate) * fate == 0"
                ],
                "Type": " You can flip governance decisions without extending vote duration",
                "Description": "\nThe impact here is that a user can, right at the end of the voting period, flip the decision without triggering the logic to extend the vote duration. The user doesn't even have to be very sophisticated: they can just send one vote in one transaction to go to 0, then in a subsequent transaction send enough to flip the vote.\n\n\n<https://github.com/code-423n4/2022-01-behodler/blob/608cec2e297867e4d954a63fecd720e80c1d5ae8/contracts/DAO/LimboDAO.sol#L281\nYou can send exactly enough fate to send the fate amount to 0, then send fate to change the vote. You'll never trigger this logic.\n\nOn the first call, to send the currentProposalState.fate to 0, (fate + currentFate) * fate == 0, so we won't extend the proposal state.\n\nThen, on the second call, to actually change the vote, fate * currentFate == 0 because currentFate is 0.\n\n",
                "Repair": "\nMake sure that going to 0 is equivalent to a flip, but going away from 0 isn't a flip.\n\ngititGoro (Behodler) confirmed and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/106#issuecomment-1027529133):\n  Changing the logic to include this edge case can get a little convoluted. One thing I thought of is to change the condition to \n currentFate*fate<0 && currrentFate*currentFatefate*fate but then moving from 0 to positive won't flip the vote.\n What about requiring the square of your vote to not equal the currentFate and reverting if not? In other words, your vote needs to either have no flipping impact or clearly be intended to flip, not just to cancel out all other votes.\n\ngititGoro (Behodler) commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/106#issuecomment-1036954286):\n  After some consideration, I'm going to implement the square of votes != currentVote rule as a tie makes no sense in the context of whether to execute. \n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// import \"hardhat/console.sol\";\nimport \"./facades/LimboDAOLike.sol\";\nimport \"./facades/Burnable.sol\";\nimport \"./facades/BehodlerLike.sol\";\nimport \"./facades/FlanLike.sol\";\nimport \"./facades/UniPairLike.sol\";\nimport \"./facades/MigratorLike.sol\";\nimport \"./facades/AMMHelper.sol\";\nimport \"./facades/AngbandLike.sol\";\nimport \"./facades/LimboAddTokenToBehodlerPowerLike.sol\";\nimport \"./DAO/Governable.sol\";\nimport \"./facades/FlashGovernanceArbiterLike.sol\";\n\n/*\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can't unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don't want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n*/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/*\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n*/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted <= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), \"E8\");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), \"E9\");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress->index->stakingInfo\n  mapping(address => mapping(uint256 => Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address => uint256) public latestIndex;\n\n  ///@dev tokenAddress->userAddress->soulIndex->Userinfo\n  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;\n  ///@dev token->index->data\n  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul->owner->unstaker->amount\n  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, \"EF\");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, \"EI\");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, \"E1\");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance > 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor <= 10000, \"E6\");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.\n   */\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, \"E2\");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount > 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending > 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, \"E2\");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount >= amount, \"E4\");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending > 0 && amount > 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending > 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, \"E2\");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, \"E5\");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, \"E6\");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken > 0, \"ED\");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  */\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, \"E7\");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   */\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, \"EB\");\n    require(soul.state == SoulState.waitingToCross, \"E2\");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >\n        crossingConfig.crossingMigrationDelay,\n      \"EC\"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../facades/LimboDAOLike.sol\";\nimport \"./Governable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n///@title Proposal\n///@author Justin Goro\n///@notice suggested base contract for proposals on Limbo. Not strictly enforced but strongly recommended\nabstract contract Proposal {\n  string public description;\n  LimboDAOLike DAO;\n\n  constructor(address dao, string memory _description) {\n    DAO = LimboDAOLike(dao);\n    description = _description;\n  }\n\n  modifier onlyDAO() {\n    address dao = address(DAO);\n    require(dao != address(0), \"PROPOSAL: DAO not set\");\n    require(msg.sender == dao, \"PROPOSAL: only DAO can invoke\");\n    _;\n  }\n\n  //Use this modifier on a parameterize funtion. This allows the proposal to lock itself into a readonly state during voting.\n  modifier notCurrent() {\n    (, , , , address proposal) = DAO.currentProposalState();\n    require(proposal != address(this), \"LimboDAO: proposal locked\");\n    _;\n  }\n\n  function orchestrateExecute() public onlyDAO {\n    require(execute(), \"LimboDAO: execution of proposal failed\");\n  }\n\n  //override this function with all proposal logic. Only instructions included in this function will be executed if the proposal is a success.\n  function execute() internal virtual returns (bool);\n}\n\n///@title Proposal Factory\n///@author Justin Goro\n///@notice authenticates and gatekeeps proposals up for vote on LimboDAO.\n///@dev constructors are prefered to initializers when an imporant base contract exists.\ncontract ProposalFactory is Governable, Ownable {\n  mapping(address => bool) public whitelistedProposalContracts;\n  address public soulUpdateProposal;\n\n  constructor(\n    address _dao,\n    address whitelistingProposal,\n    address _soulUpdateProposal\n  ) Governable(_dao) {\n    //in order for proposals to be white listed, an initial whitelisting proposal needs to be whitelisted at deployment\n    whitelistedProposalContracts[whitelistingProposal] = true;\n    whitelistedProposalContracts[_soulUpdateProposal] = true;\n    soulUpdateProposal = _soulUpdateProposal;\n  }\n\n  ///@notice SoulUpdateProposal is one of the most important proposals and governs the creation of new staking souls.\n  ///@dev onlyOwner denotes that this important function is overseen by MorgothDAO.\n  ///@param newProposal new update soul\n  function changeSoulUpdateProposal(address newProposal) public onlyOwner {\n    soulUpdateProposal = newProposal;\n  }\n\n  ///@notice there is no formal onchain enforcement of proposal structure and compliance. Proposal contracts must first be white listed for usage\n  function toggleWhitelistProposal(address proposal) public onlySuccessfulProposal {\n    whitelistedProposalContracts[proposal] = !whitelistedProposalContracts[proposal];\n  }\n\n  ///@notice user facing function to vote on a new proposal. Note that the proposal contract must first be whitelisted for usage\n  ///@param proposal whitelisted popular contract\n  function lodgeProposal(address proposal) public {\n    require(whitelistedProposalContracts[proposal], \"LimboDAO: invalid proposal\");\n    LimboDAOLike(DAO).makeProposal(proposal, msg.sender);\n  }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../ERC677/ERC677.sol\";\nimport \"../Flan.sol\";\nimport \"./ProposalFactory.sol\";\nimport \"../facades/SwapFactoryLike.sol\";\nimport \"../facades/UniPairLike.sol\";\nimport \"./Governable.sol\";\n\n// import \"hardhat/console.sol\";\n\nlibrary TransferHelper {\n  function ERC20NetTransfer(\n    address token,\n    address from,\n    address to,\n    int256 amount\n  ) public {\n    if (amount > 0) {\n      require(IERC20(token).transferFrom(from, to, uint256(amount)), \"LimboDAO: ERC20 transfer from failed.\");\n    } else {\n      require(IERC20(token).transfer(from, uint256(amount * (-1))), \"LimboDAO: ERC20 transfer failed.\");\n    }\n  }\n}\n\nenum FateGrowthStrategy {\n  straight,\n  directRoot,\n  indirectTwoRootEye\n}\n\nenum ProposalDecision {\n  voting,\n  approved,\n  rejected\n}\n\n///@title Limbo DAO\n///@author Justin Goro\n/**@notice\n *This is the first MicroDAO associated with MorgothDAO. A MicroDAO manages parameterization of running dapps without having\n *control over existential functionality. This is not to say that some of the decisions taken are not critical but that the domain\n *of influence is confined to the local Dapp - Limbo in this case.\n * LimboDAO has two forms of decision making: proposals and flash governance. For proposals, voting power is required. Voting power in LimboDAO is measured\n * by a points system called Fate. Staking EYE or an EYE based LP earns Fate at a quadratic rate. Fate can be used to list a proposal for voting or to vote.\n * Using Fate to make a governance decisions spens it out of existince. So Fate reflects the opportunity cost of staking.\n * Flash governance is for instant decision making that cannot wait for voting to occur. Best used for small tweaks to parameters or emergencies.\n * Flash governance requires a governance asset (EYE) be staked at the time of the execution. The asset cannot be withdrawn for a certain period of time,\n * allowing for Fate holders to vote on the legitimacy of the decision. If the decision is considered malicious, the staked EYE is burnt.\n */\n///@dev Contracts subject to LimboDAO must inherit the Governable abstract contract.\ncontract LimboDAO is Ownable {\n  event daoKilled(address newOwner);\n  event proposalLodged(address proposal, address proposer);\n  event voteCast(address voter, address proposal, int256 fateCast);\n  event assetApproval(address asset, bool appoved);\n  event proposalExecuted(address proposal, bool approved);\n  event assetBurnt(address burner, address asset, uint256 fateCreated);\n\n  using TransferHelper for address;\n  uint256 constant ONE = 1 ether;\n  uint256 precision = 1e9;\n\n  struct DomainConfig {\n    address limbo;\n    address flan;\n    address eye;\n    address fate;\n    bool live;\n    address flashGoverner;\n    address sushiFactory;\n    address uniFactory;\n  }\n\n  struct ProposalConfig {\n    uint256 votingDuration;\n    uint256 requiredFateStake;\n    address proposalFactory; //check this for creating proposals\n  }\n\n  struct ProposalState {\n    int256 fate;\n    ProposalDecision decision;\n    address proposer;\n    uint256 start;\n    Proposal proposal;\n  }\n\n  //rateCrate\n  struct FateState {\n    uint256 fatePerDay;\n    uint256 fateBalance;\n    uint256 lastDamnAdjustment;\n  }\n\n  struct AssetClout {\n    uint256 fateWeight;\n    uint256 balance;\n  }\n\n  DomainConfig public domainConfig;\n  ProposalConfig public proposalConfig;\n\n  /**@notice for staking EYE, we simply take the square root of staked amount.\n   * For LP tokens, only half the value of the token is EYE so it's tempting to take the square root for the EYE balance. However this punishes the holder by ignoring the cost incurred by supplying the other asset. Since the other asset at rest is equal in value to the EYE balance, we just multiply the calculation by 2.\n   */\n  mapping(address => FateGrowthStrategy) public fateGrowthStrategy;\n  mapping(address => bool) public assetApproved;\n  mapping(address => FateState) public fateState; //lateDate\n\n  //Fate is earned per day. Keeping track of relative staked values, we can increment user balance\n  mapping(address => mapping(address => AssetClout)) public stakedUserAssetWeight; //user->asset->weight\n\n  ProposalState public currentProposalState;\n  ProposalState public previousProposalState;\n\n  // Since staking EYE precludes it from earning Flan on Limbo, fateToFlan can optionally be set to a non zero number to allow fat holders to spend their fate for Flan.\n  uint256 public fateToFlan;\n\n  modifier isLive() {\n    require(domainConfig.live, \"LimboDAO: DAO is not live.\");\n    _;\n  }\n\n  function nextProposal() internal {\n    previousProposalState = currentProposalState;\n    currentProposalState.proposal = Proposal(address(0));\n    currentProposalState.fate = 0;\n    currentProposalState.decision = ProposalDecision.voting;\n    currentProposalState.proposer = address(0);\n    currentProposalState.start = 0;\n  }\n\n  modifier onlySuccessfulProposal() {\n    // console.log('onlySuccessfulProposal');\n    require(successfulProposal(msg.sender), \"LimboDAO: approve proposal\");\n    _;\n    //nextProposal();\n  }\n\n  ///@notice has a proposal successfully been approved?\n  function successfulProposal(address proposal) public view returns (bool) {\n    return\n      currentProposalState.decision == ProposalDecision.approved && proposal == address(currentProposalState.proposal);\n  }\n\n  modifier updateCurrentProposal() {\n    incrementFateFor(_msgSender());\n    if (address(currentProposalState.proposal) != address(0)) {\n      uint256 durationSinceStart = block.timestamp - currentProposalState.start;\n      if (\n        durationSinceStart >= proposalConfig.votingDuration && currentProposalState.decision == ProposalDecision.voting\n      ) {\n        if (currentProposalState.fate > 0) {\n          currentProposalState.decision = ProposalDecision.approved;\n          currentProposalState.proposal.orchestrateExecute();\n          fateState[currentProposalState.proposer].fateBalance += proposalConfig.requiredFateStake;\n        } else {\n          currentProposalState.decision = ProposalDecision.rejected;\n        }\n        emit proposalExecuted(\n          address(currentProposalState.proposal),\n          currentProposalState.decision == ProposalDecision.approved\n        );\n        nextProposal();\n      }\n    }\n    _;\n  }\n\n  modifier incrementFate() {\n    incrementFateFor(_msgSender());\n    _;\n  }\n\n  function incrementFateFor(address user) public {\n    FateState storage state = fateState[user];\n    state.fateBalance += (state.fatePerDay * (block.timestamp - state.lastDamnAdjustment)) / (1 days);\n    state.lastDamnAdjustment = block.timestamp;\n  }\n\n  ///@param limbo address of Limbo\n  ///@param flan address of Flan\n  ///@param eye address of EYE token\n  ///@param proposalFactory authenticates and instantiates valid proposals for voting\n  ///@param sushiFactory is the SushiSwap Factory contract\n  ///@param uniFactory is the UniSwapV2 Factory contract\n  ///@param flashGoverner oversees flash governance cryptoeconomics\n  ///@param precisionOrderOfMagnitude when comparing fractional values, it's not necessary to get every last digit right\n  ///@param sushiLPs valid EYE containing LP tokens elligible for earning Fate through staking\n  ///@param uniLPs valid EYE containing LP tokens elligible for earning Fate through staking\n  function seed(\n    address limbo,\n    address flan,\n    address eye,\n    address proposalFactory,\n    address sushiFactory,\n    address uniFactory,\n    address flashGoverner,\n    uint256 precisionOrderOfMagnitude,\n    address[] memory sushiLPs,\n    address[] memory uniLPs\n  ) public onlyOwner {\n    _seed(limbo, flan, eye, sushiFactory, uniFactory, flashGoverner);\n    proposalConfig.votingDuration = 2 days;\n    proposalConfig.requiredFateStake = 223 * ONE; //50000 EYE for 24 hours\n    proposalConfig.proposalFactory = proposalFactory;\n    precision = 10**precisionOrderOfMagnitude;\n    for (uint256 i = 0; i < sushiLPs.length; i++) {\n      require(UniPairLike(sushiLPs[i]).factory() == sushiFactory, \"LimboDAO: invalid Sushi LP\");\n      if (IERC20(eye).balanceOf(sushiLPs[i]) > 1000) assetApproved[sushiLPs[i]] = true;\n      fateGrowthStrategy[sushiLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;\n    }\n    for (uint256 i = 0; i < uniLPs.length; i++) {\n      require(UniPairLike(uniLPs[i]).factory() == uniFactory, \"LimboDAO: invalid Sushi LP\");\n      if (IERC20(eye).balanceOf(uniLPs[i]) > 1000) assetApproved[uniLPs[i]] = true;\n      fateGrowthStrategy[uniLPs[i]] = FateGrowthStrategy.indirectTwoRootEye;\n    }\n  }\n\n  ///@notice allows Limbo to be governed by a new DAO\n  ///@dev functions marked by onlyOwner are governed by MorgothDAO\n  function killDAO(address newOwner) public onlyOwner isLive {\n    domainConfig.live = false;\n    Governable(domainConfig.flan).setDAO(newOwner);\n    Governable(domainConfig.limbo).setDAO(newOwner);\n    emit daoKilled(newOwner);\n  }\n\n  ///@notice optional conversion rate of Fate to Flan\n  function setFateToFlan(uint256 rate) public onlySuccessfulProposal {\n    fateToFlan = rate;\n  }\n\n  ///@notice caller spends their Fate to earn Flan\n  function convertFateToFlan(uint256 fate) public returns (uint256 flan) {\n    require(fateToFlan > 0, \"LimboDAO: Fate conversion to Flan disabled.\");\n    fateState[msg.sender].fateBalance -= fate;\n    flan = (fateToFlan * fate) / ONE;\n    Flan(domainConfig.flan).mint(msg.sender, flan);\n  }\n\n  /**@notice handles proposal lodging logic. A deposit of Fate is removed from the user. If the decision is a success, half the fate is returned.\n   *  This is to encourage only lodging of proposals that are likely to succeed.\n   *  @dev not for external calling. Use the proposalFactory to lodge a proposal instead.\n   */\n  function makeProposal(address proposal, address proposer) public updateCurrentProposal {\n    address sender = _msgSender();\n    require(sender == proposalConfig.proposalFactory, \"LimboDAO: only Proposal Factory\");\n    require(address(currentProposalState.proposal) == address(0), \"LimboDAO: active proposal.\");\n\n    fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2;\n    currentProposalState.proposal = Proposal(proposal);\n    currentProposalState.decision = ProposalDecision.voting;\n    currentProposalState.fate = 0;\n    currentProposalState.proposer = proposer;\n    currentProposalState.start = block.timestamp;\n    emit proposalLodged(proposal, proposer);\n  }\n\n  ///@notice handles proposal voting logic.\n  ///@param proposal contract to be voted on\n  ///@param fate positive is YES, negative is NO. Absolute value is deducted from caller.\n  function vote(address proposal, int256 fate) public incrementFate isLive {\n    require(\n      proposal == address(currentProposalState.proposal), //this is just to protect users with out of sync UIs\n      \"LimboDAO: stated proposal does not match current proposal\"\n    );\n    require(currentProposalState.decision == ProposalDecision.voting, \"LimboDAO: voting on proposal closed\");\n    if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration - 1 hours) {\n      int256 currentFate = currentProposalState.fate;\n      //check if voting has ended\n      if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) {\n        revert(\"LimboDAO: voting for current proposal has ended.\");\n      } else if (\n        //The following if statement checks if the vote is flipped by fate\n        fate * currentFate < 0 && //sign different\n        (fate + currentFate) * fate > 0 //fate flipped current fate onto the same side of zero as fate\n      ) {\n        //extend voting duration when vote flips decision. Suggestion made by community member\n        currentProposalState.start = currentProposalState.start + 2 hours;\n      }\n    }\n    uint256 cost = fate > 0 ? uint256(fate) : uint256(-fate);\n    fateState[_msgSender()].fateBalance = fateState[_msgSender()].fateBalance - cost;\n\n    currentProposalState.fate += fate;\n    emit voteCast(_msgSender(), proposal, fate);\n  }\n\n  ///@notice pushes the decision to execute a successful proposal. For convenience only\n  function executeCurrentProposal() public updateCurrentProposal {}\n\n  ///@notice parameterizes the voting\n  ///@param requiredFateStake the amount of Fate required to lodge a proposal\n  ///@param votingDuration the duration of voting in seconds\n  ///@param proposalFactory the address of the proposal factory\n  function setProposalConfig(\n    uint256 votingDuration,\n    uint256 requiredFateStake,\n    address proposalFactory\n  ) public onlySuccessfulProposal {\n    proposalConfig.votingDuration = votingDuration;\n    proposalConfig.requiredFateStake = requiredFateStake;\n    proposalConfig.proposalFactory = proposalFactory;\n  }\n\n  ///@notice Assets approved for earning Fate\n  function setApprovedAsset(address asset, bool approved) public onlySuccessfulProposal {\n    assetApproved[asset] = approved;\n    fateGrowthStrategy[asset] = FateGrowthStrategy.indirectTwoRootEye;\n    emit assetApproval(asset, approved);\n  }\n\n  ///@notice handles staking logic for EYE and EYE based assets so that correct rate of fate is earned.\n  ///@param finalAssetBalance after staking, what is the final user balance on LimboDAO of the asset in question\n  ///@param finalEYEBalance if EYE is being staked, this value is the same as finalAssetBalance but for LPs it's about half\n  ///@param rootEYE offload high gas arithmetic to the client. Cheap to verify. Square root in fixed point requires Babylonian algorithm\n  ///@param asset the asset being staked\n  function setEYEBasedAssetStake(\n    uint256 finalAssetBalance,\n    uint256 finalEYEBalance,\n    uint256 rootEYE,\n    address asset\n  ) public isLive incrementFate {\n    require(assetApproved[asset], \"LimboDAO: illegal asset\");\n    address sender = _msgSender();\n    FateGrowthStrategy strategy = fateGrowthStrategy[asset];\n\n    //verifying that rootEYE value is accurate within precision.\n    uint256 rootEYESquared = rootEYE * rootEYE;\n    uint256 rootEYEPlusOneSquared = (rootEYE + 1) * (rootEYE + 1);\n    require(\n      rootEYESquared <= finalEYEBalance && rootEYEPlusOneSquared > finalEYEBalance,\n      \"LimboDAO: Stake EYE invariant.\"\n    );\n    AssetClout storage clout = stakedUserAssetWeight[sender][asset];\n    fateState[sender].fatePerDay -= clout.fateWeight;\n    uint256 initialBalance = clout.balance;\n    //EYE\n    if (strategy == FateGrowthStrategy.directRoot) {\n      require(finalAssetBalance == finalEYEBalance, \"LimboDAO: staking eye invariant.\");\n      require(asset == domainConfig.eye);\n\n      clout.fateWeight = rootEYE;\n      clout.balance = finalAssetBalance;\n      fateState[sender].fatePerDay += rootEYE;\n    } else if (strategy == FateGrowthStrategy.indirectTwoRootEye) {\n      //LP\n      clout.fateWeight = 2 * rootEYE;\n      fateState[sender].fatePerDay += clout.fateWeight;\n\n      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\n      require(actualEyeBalance > 0, \"LimboDAO: No EYE\");\n      uint256 totalSupply = IERC20(asset).totalSupply();\n      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;\n      uint256 impliedEye = (eyePerUnit * finalAssetBalance) / (ONE * precision);\n      finalEYEBalance /= precision;\n      require(\n        finalEYEBalance == impliedEye, //precision cap\n        \"LimboDAO: stake invariant check 2.\"\n      );\n      clout.balance = finalAssetBalance;\n    } else {\n      revert(\"LimboDAO: asset growth strategy not accounted for\");\n    }\n    int256 netBalance = int256(finalAssetBalance) - int256(initialBalance);\n    asset.ERC20NetTransfer(sender, address(this), netBalance);\n  }\n\n  /**\n   *@notice Acquiring enough fate to either influence a decision or to lodge a proposal can take very long.\n   * If a very important decision has to be acted on via a proposal, the option exists to buy large quantities for fate instantly by burning an EYE based asset\n   * This may be necessary if a vote is nearly complete by the looming outcome is considered unacceptable.\n   * While Fate accumulation is quadratic for staking, burning is linear and subject to a factor of 10. This gives whales effective veto power but at the cost of a permanent\n   * loss of EYE.\n   *@param asset the asset to burn and can be EYE or EYE based assets\n   *@param amount the amount of asset to burn\n   */\n  function burnAsset(address asset, uint256 amount) public isLive incrementFate {\n    require(assetApproved[asset], \"LimboDAO: illegal asset\");\n    address sender = _msgSender();\n    require(ERC677(asset).transferFrom(sender, address(this), amount), \"LimboDAO: transferFailed\");\n    uint256 fateCreated = fateState[_msgSender()].fateBalance;\n    if (asset == domainConfig.eye) {\n      fateCreated = amount * 10;\n      ERC677(domainConfig.eye).burn(amount);\n    } else {\n      uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset);\n      require(actualEyeBalance > 0, \"LimboDAO: No EYE\");\n      uint256 totalSupply = IERC20(asset).totalSupply();\n      uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply;\n      uint256 impliedEye = (eyePerUnit * amount) / ONE;\n      fateCreated = impliedEye * 20;\n    }\n    fateState[_msgSender()].fateBalance += fateCreated;\n    emit assetBurnt(_msgSender(), asset, fateCreated);\n  }\n\n  ///@notice grants unlimited Flan minting power to an address.\n  function approveFlanMintingPower(address minter, bool enabled) public onlySuccessfulProposal isLive {\n    Flan(domainConfig.flan).increaseMintAllowance(minter, enabled ? type(uint256).max : 0);\n  }\n\n  ///@notice call this after initial config is complete.\n  function makeLive() public onlyOwner {\n    require(\n      Governable(domainConfig.limbo).DAO() == address(this) && Governable(domainConfig.flan).DAO() == address(this),\n      \"LimboDAO: transfer ownership of limbo and flan.\"\n    );\n    domainConfig.live = true;\n  }\n\n  ///@notice if the DAO is being dismantled, it's necessary to transfer any owned items\n  function transferOwnershipOfThing(address thing, address destination) public onlySuccessfulProposal {\n    Ownable(thing).transferOwnership(destination);\n  }\n\n  function timeRemainingOnProposal() public view returns (uint256) {\n    require(currentProposalState.decision == ProposalDecision.voting, \"LimboDAO: proposal finished.\");\n    uint256 elapsed = block.timestamp - currentProposalState.start;\n    if (elapsed > proposalConfig.votingDuration) return 0;\n    return proposalConfig.votingDuration - elapsed;\n  }\n\n  /**@notice seed is a goro idiom for initialize that you tend to find in all the dapps I've written.\n   * I prefer initialization funcitons to parameterized solidity constructors for reasons beyond the scope of this comment.\n   */\n  function _seed(\n    address limbo,\n    address flan,\n    address eye,\n    address sushiFactory,\n    address uniFactory,\n    address flashGoverner\n  ) internal {\n    domainConfig.limbo = limbo;\n    domainConfig.flan = flan;\n    domainConfig.eye = eye;\n    domainConfig.uniFactory = uniFactory;\n    domainConfig.sushiFactory = sushiFactory;\n    domainConfig.flashGoverner = flashGoverner;\n    assetApproved[eye] = true;\n    fateGrowthStrategy[eye] = FateGrowthStrategy.directRoot;\n  }\n\n  function getFlashGoverner() external view returns (address) {\n    return domainConfig.flashGoverner;\n  }\n}\n\n\n",
        "CodeNames": [
            "Limbo.sol",
            "ProposalFactory.sol",
            "LimboDAO.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-13",
                "Location": [
                    "fate",
                    "parameterize",
                    "notCurrent",
                    "lodgeProposal"
                ],
                "Type": " Lack of access control in the  parameterize  function of proposal contracts",
                "Description": "\nMost of the proposal contracts have a parameterize function for setting the proposal parameters, and these functions are protected only by the notCurrent modifier. When the proposal is proposed through a lodgeProposal transaction, an attacker can front-run it, modify the proposal parameters, and let the community vote it down. As a result, the person proposing loses his fate deposit.\n\n\n1.  A benign user Alice wants to make a proposal, so she deploys one of the proposal contracts and sets the intended parameters. Her proposal is approved by the ProposalFactory and is ready to be proposed.\n2.  Alice calls the lodgeProposal function of ProposalFactory to propose her proposal.\n3.  An attacker Bob, who listens to the mempool, notices Alice's transaction and front-runs it. He calls the parameterize function to change the parameters to undesirable ones.\n4.  Alice's proposal becomes the current proposal. However, the community rejects the proposal because of the changed parameters, causing Alice to lose her deposit.\n\nReferenced code:\nDAO/Proposals/BurnFlashStakeDeposit.sol#L25-L37(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/BurnFlashStakeDeposit.sol#L25-L37)\nDAO/Proposals/SetAssetApprovalProposal.sol#L21-L24(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/SetAssetApprovalProposal.sol#L21-L24)\nDAO/Proposals/ToggleWhitelistProposalProposal.sol#L22-L28(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/ToggleWhitelistProposalProposal.sol#L22-L28)\nDAO/Proposals/UpdateMultipleSoulConfigProposal.sol#L40-L61(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/UpdateMultipleSoulConfigProposal.sol#L40-L61)\nDAO/Proposals/WithdrawERC20Proposal.sol#L26-L32(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/WithdrawERC20Proposal.sol#L26-L32)\nDAO/ProposalFactory.sol#L74-L78(https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/ProposalFactory.sol#L74-L78)\n\n",
                "Repair": "\nOnly allow the creator of the proposal to modify the parameters.\n\ngititGoro (Behodler) acknowledged(https://github.com/code-423n4/2022-01-behodler-findings/issues/296)\n\n\n\n*\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// import \"hardhat/console.sol\";\nimport \"./facades/LimboDAOLike.sol\";\nimport \"./facades/Burnable.sol\";\nimport \"./facades/BehodlerLike.sol\";\nimport \"./facades/FlanLike.sol\";\nimport \"./facades/UniPairLike.sol\";\nimport \"./facades/MigratorLike.sol\";\nimport \"./facades/AMMHelper.sol\";\nimport \"./facades/AngbandLike.sol\";\nimport \"./facades/LimboAddTokenToBehodlerPowerLike.sol\";\nimport \"./DAO/Governable.sol\";\nimport \"./facades/FlashGovernanceArbiterLike.sol\";\n\n/*\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can't unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don't want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n*/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/*\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n*/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted <= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), \"E8\");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), \"E9\");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress->index->stakingInfo\n  mapping(address => mapping(uint256 => Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address => uint256) public latestIndex;\n\n  ///@dev tokenAddress->userAddress->soulIndex->Userinfo\n  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;\n  ///@dev token->index->data\n  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul->owner->unstaker->amount\n  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, \"EF\");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, \"EI\");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, \"E1\");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance > 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor <= 10000, \"E6\");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.\n   */\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, \"E2\");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount > 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending > 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, \"E2\");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount >= amount, \"E4\");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending > 0 && amount > 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending > 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, \"E2\");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, \"E5\");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, \"E6\");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken > 0, \"ED\");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  */\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, \"E7\");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   */\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, \"EB\");\n    require(soul.state == SoulState.waitingToCross, \"E2\");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >\n        crossingConfig.crossingMigrationDelay,\n      \"EC\"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n\n\n",
        "CodeNames": [
            "Limbo.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-14",
                "Location": [
                    "buyFlanAndBurn"
                ],
                "Type": " UniswapHelper.buyFlanAndBurn is a subject to sandwich attacks",
                "Description": "\nTrades can happen at a manipulated price and end up receiving fewer Flan to be bought than current market price dictates.\n\nFor example, at the time a user decides to call buyFlanAndBurn Flan trades at 0.8 in the input token terms at the corresponding DEX pool. If the input token holdings are big enough to compensate for pool manipulation costs, the following can happen: Flan buy order will be seen by a malicious bot, that buys Flan, pushing it to 0.9 before UniswapHelper's order comes through, and selling it back right afterwards. This way, given a cumulative impact of the trades on Flan's market price, the input token will be overspent.\n\nThis yields direct loss for the system as input token market operations have lesser effect than expected at the expense of contract holdings.\n\n\nbuyFlanAndBurn doesn't control for swap results, executing swaps with exchange pool provided amounts, which can be manipulated:\n\n<https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/UniswapHelper.sol#L231\n\n",
                "Repair": "\nConsider adding the minimum accepted price as a function argument so a user can limit the effective slippage, and check that actually received amount is above this accepted minimum.\n\nAlso, in the future it will prudent to add a relative version of the parameter to control percentage based slippage with TWAP Oracle price as a benchmark.\n\ngititGoro (Behodler) acknowledged and commented(https://github.com/code-423n4/2022-01-behodler-findings/issues/230#issuecomment-1030495237):\n  You're not wrong but remember that the tokens that can be called here are specifically those that are not listed on Limbo and likely never will be BUT that also have Flan pools. It's unlikely that these pools will ever be significantly large as no incentives are provided for their maintenance.\n\n\n\n*\n\n\n"
            }
        ]
    }
]