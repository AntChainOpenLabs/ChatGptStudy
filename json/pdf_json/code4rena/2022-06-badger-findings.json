[
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [],
                "Type": " Attacker can call sweepRewardToken() when  bribesProcessor==0  and reward funds will be lost because there is no check in sweepRewardToken() and _handleRewardTransfer() and _sendTokenToBribesProcessor()",
                "Description": "\n<https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L107-L113\n\n<https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L405-L413\n\n<https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L421-L425\n\n\nIf the value of bribesProcessor was 0x0 (the default is 0x0 and governance()  can set to 0x0) then attacker can call sweepRewardToken() make contract to send his total balance in attacker specified token to 0x0 address.\n\n\nThe default value of bribesProcessor is 0x0 and governance can set the value to 0x0 at any time. Rewards are stacking in contract address and they are supposed to send to bribesProcessor.\n\nThis is sweepRewardToken() and _handleRewardTransfer() and _sendTokenToBribesProcessor() code:\n\n      /// @dev Function to move rewards that are not protected\n      /// @notice Only not protected, moves the whole amount using _handleRewardTransfer\n      /// @notice because token paths are hardcoded, this function is safe to be called by anyone\n      /// @notice Will not notify the BRIBES_PROCESSOR as this could be triggered outside bribes\n      function sweepRewardToken(address token) public nonReentrant {\n          _onlyGovernanceOrStrategist();\n          _onlyNotProtectedTokens(token);\n\n          uint256 toSend = IERC20Upgradeable(token).balanceOf(address(this));\n          _handleRewardTransfer(token, toSend);\n      }\n\n      function _handleRewardTransfer(address token, uint256 amount) internal {\n          // NOTE: BADGER is emitted through the tree\n          if (token == BADGER) {\n              _sendBadgerToTree(amount);\n          } else {\n              // NOTE: All other tokens are sent to bribes processor\n              _sendTokenToBribesProcessor(token, amount);\n          }\n      }\n\n      function _sendTokenToBribesProcessor(address token, uint256 amount) internal {\n          // TODO: Too many SLOADs\n          IERC20Upgradeable(token).safeTransfer(address(bribesProcessor), amount);\n          emit RewardsCollected(token, amount);\n      }\n\nAs you can see calling sweepRewardToken() eventually (sweepRewardToken() - _handleRewardTransfer() - _sendTokenToBribesProcessor()) would transfer reward funds to bribesProcessor and there is no check that bribesProcessor!=0x0 in execution follow. so attacker can call sweepRewardToken() when bribesProcessor is 0x0 and contract will lose all reward tokens.\n\n\nVIM\n\n",
                "Repair": "\nCheck the value of bribesProcessor in _sendTokenToBribesProcessor().\n\nAlex the Entreprenerd (BadgerDAO) confirmed and commented(https://github.com/code-423n4/2022-06-badger-findings/issues/18#issuecomment-1159182358):\n  A transfer to address 0 would cause a loss, we should have a check or add a safe default (governance for example).\n\n  Mitigated by adding a 0 check.\n\njack-the-pug (judge) validated(https://github.com/code-423n4/2022-06-badger-findings/issues/18)\n\n*\n\n\n"
            },
            {
                "Name": "H-02",
                "Location": [],
                "Type": " auraBAL can be stuck into the Strategy contract",
                "Description": "\n<https://github.com/Badger-Finance/vested-aura/blob/v0.0.2/contracts/MyStrategy.sol#L220-L228\n\n<https://github.com/Badger-Finance/vested-aura/blob/v0.0.2/contracts/MyStrategy.sol#L288\n\n\nThe internal _harvest() function defined is responsible to claim auraBAL from the aura locker and within the function it swaps them to auraBAL - BAL/ETH BPT - WETH - AURA, finally it locks AURA to the locker to increase the position. For claiming auraBAL it calls LOCKER.getReward(address(this)) and it calculates the tokes earned, checking the balance before and after the claiming.\n\nThe function to get the rewards is public and any address can call it for the strategy address, and it will transfer all rewards tokens to the strategy, but in this scenario the auraBAL will remain in stuck into the contract, because they won't be counted as auraBAL earned during the next _harvest(). Also they could not sweep because auraBAL is a protected token.\n\nAlso, the aura Locker will be able to add other token as reward apart of auraBAL, but the harvest function won't be able to manage them, so they will need to be sweep every time.\n\nThe same scenario can happen during the claimBribesFromHiddenHand() call, the IRewardDistributor.Claim[] calldata _claims pass as input parameters could be frontrunned, and another address can call the hiddenHandDistributor.claim(_claims) (except for ETH rewards) for the strategy address, and like during the _harvest() only the tokens received during the call will be counted as earned. However every token, except auraBAL can be sweep, but the _notifyBribesProcessor() may never be called.\n\n\nAt every _harvest() it checks the balance before the claim and after, to calculate the auraBAL earned, so every auraBAL transferred to the strategy address not during this call, won't be swapped to AURA.\n\n",
                "Repair": "\nInstead of calculating the balance before and after the claim, for both  harvest\u2260 and  claimBribesFromHiddenHand(), the whole balance could be taken, directly after the claim.\n\nAlex the Entreprenerd (BadgerDAO) confirmed and commented(https://github.com/code-423n4/2022-06-badger-findings/issues/129#issuecomment-1183744227):\n  Mitigated by refactoring from a delta of balance to absolute balances\n\n\n\n*\n\n \n\n"
            }
        ]
    }
]