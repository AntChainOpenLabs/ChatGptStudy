[
    {
        "Code": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport './Ecosystem.sol';\nimport './EternalModel.sol';\nimport '../libraries/SafeMath.sol';\nimport '../services/ReentryProtection.sol';\n\n/**\n * @author ElasticDAO - https://ElasticDAO.org\n * @notice This contract is used for storing core DAO data\n * @dev ElasticDAO network contracts can read/write from this contract\n */\ncontract DAO is EternalModel, ReentryProtection {\n  struct Instance {\n    address uuid;\n    address[] summoners;\n    bool summoned;\n    string name;\n    uint256 maxVotingLambda;\n    uint256 numberOfSummoners;\n    Ecosystem.Instance ecosystem;\n  }\n\n  event Serialized(address indexed uuid);\n\n  /**\n   * @dev deserializes Instance struct\n   * @param _uuid - address of the unique user ID\n   * @return record Instance\n   */\n  function deserialize(address _uuid, Ecosystem.Instance memory _ecosystem)\n    external\n    view\n    returns (Instance memory record)\n  {\n    record.uuid = _uuid;\n    record.ecosystem = _ecosystem;\n\n    if (_exists(_uuid)) {\n      record.maxVotingLambda = getUint(keccak256(abi.encode(_uuid, 'maxVotingLambda')));\n      record.name = getString(keccak256(abi.encode(_uuid, 'name')));\n      record.numberOfSummoners = getUint(keccak256(abi.encode(_uuid, 'numberOfSummoners')));\n      record.summoned = getBool(keccak256(abi.encode(_uuid, 'summoned')));\n    }\n\n    return record;\n  }\n\n  /**\n   * @dev checks if @param _uuid exists\n   * @param _uuid - address of the unique user ID\n   * @return recordExists bool\n   */\n  function exists(address _uuid, Ecosystem.Instance memory) external view returns (bool) {\n    return _exists(_uuid);\n  }\n\n  function getSummoner(Instance memory _dao, uint256 _index) external view returns (address) {\n    return getAddress(keccak256(abi.encode(_dao.uuid, 'summoners', _index)));\n  }\n\n  /**\n   * @dev checks if @param _uuid where _uuid is msg.sender - is a Summoner\n   * @param _dao DAO.Instance\n   * @param _summonerAddress address\n   * @return bool\n   */\n  function isSummoner(Instance memory _dao, address _summonerAddress) external view returns (bool) {\n    return getBool(keccak256(abi.encode(_dao.uuid, 'summoner', _summonerAddress)));\n  }\n\n  /**\n   * @dev serializes Instance struct\n   * @param _record Instance\n   */\n  function serialize(Instance memory _record) external preventReentry {\n    require(\n      msg.sender == _record.uuid || msg.sender == _record.ecosystem.configuratorAddress,\n      'ElasticDAO: Unauthorized'\n    );\n\n    setUint(keccak256(abi.encode(_record.uuid, 'maxVotingLambda')), _record.maxVotingLambda);\n    setString(keccak256(abi.encode(_record.uuid, 'name')), _record.name);\n    setBool(keccak256(abi.encode(_record.uuid, 'summoned')), _record.summoned);\n\n    if (_record.summoners.length > 0) {\n      _record.numberOfSummoners = _record.summoners.length;\n      setUint(keccak256(abi.encode(_record.uuid, 'numberOfSummoners')), _record.numberOfSummoners);\n      for (uint256 i = 0; i < _record.numberOfSummoners; i += 1) {\n        setBool(keccak256(abi.encode(_record.uuid, 'summoner', _record.summoners[i])), true);\n        setAddress(keccak256(abi.encode(_record.uuid, 'summoners', i)), _record.summoners[i]);\n      }\n    }\n\n    setBool(keccak256(abi.encode(_record.uuid, 'exists')), true);\n\n    emit Serialized(_record.uuid);\n  }\n\n  function _exists(address _uuid) internal view returns (bool) {\n    return getBool(keccak256(abi.encode(_uuid, 'exists')));\n  }\n}\n\n\n",
        "CodeNames": [
            "DAO.sol",
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_H-01",
                "Location": [
                    "models/DAO"
                ],
                "Type": " Infinite minting of tokens by exploiting eternal storage pattern on DAO.sol",
                "Description": " Attackers can overwrite metadata in the models/DAO.sol eternal storage contract by using the serialize call to change the expected configurator address to the attacker\u2019s address.   This allows the attacker to change the DAO data and potentially mint infinite tokens for themselves. We consider this risk high severity because it would disrupt the economics of the DAO in a manner that would prevent the system from performing.   ElasticDAO: Confirmed and resolved in PR #43 .   ",
                "Repair": ""
            },
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_H-03",
                "Location": [
                    "models/Token"
                ],
                "Type": " Infinite minting of tokens by exploiting eternal storage pattern on Token.sol",
                "Description": " An attacker can change the expected DAO address to their own address in the models/Token.sol contract. The attacker can change the token parameters so that they receive much more ETH for their shares when exiting from the DAO. Attackers could also steal all funds from the DAO, effectively breaking ElasticDAO\u2019s model.   ElasticDAO: Confirmed and resolved in PR #43     code423n4.com  https://github.com/elasticdao/contracts/pull/43 https://github.com/elasticdao/contracts/pull/43 https://github.com/elasticdao/contracts/pull/43 https://code423n4.com/      ",
                "Repair": ""
            },
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_M-05",
                "Location": [
                    "ofETH"
                ],
                "Type": " Malicious actors can avoid penalty",
                "Description": "A DAO member may be able to predict when they will be penalized if they monitor the mempoolfor events related to the penalize function on the contract. This member can then avoidpenalization by transferring their balance to another address and sending it back to the originalaccount after the next block.Since the penalty transaction will revert if the amount is greater than the balance, an attackercould potentially frontrun the penalty by calling the exit function with a miniscule amount ofETH. They could also exit the DAO completely. This loophole provides potential incentive formalicious actors to exploit the DAO.ElasticDAO: Confirmed and resolved in PR #44",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport '../libraries/ElasticMath.sol';\nimport '../libraries/SafeMath.sol';\n\nimport '../models/DAO.sol';\nimport '../models/Ecosystem.sol';\nimport '../models/Token.sol';\n\nimport '../services/Configurator.sol';\nimport '../services/ReentryProtection.sol';\n\nimport '@pie-dao/proxy/contracts/PProxy.sol';\n\n/**\n * @dev The ElasticDAO contract outlines and defines all the functionality\n * such as initialize, Join, exit, etc for an elasticDAO.\n *\n * It also serves as the vault for ElasticDAO.\n */\ncontract ElasticDAO is ReentryProtection {\n  address public deployer;\n  address public ecosystemModelAddress;\n  address public controller;\n  address[] public summoners;\n  bool public initialized;\n\n  event ElasticGovernanceTokenDeployed(address indexed tokenAddress);\n  event MaxVotingLambdaChanged(address indexed daoAddress, bytes32 settingName, uint256 value);\n  event ControllerChanged(address indexed daoAddress, bytes32 settingName, address value);\n  event ExitDAO(\n    address indexed daoAddress,\n    address indexed memberAddress,\n    uint256 shareAmount,\n    uint256 ethAmount\n  );\n  event JoinDAO(\n    address indexed daoAddress,\n    address indexed memberAddress,\n    uint256 shareAmount,\n    uint256 ethAmount\n  );\n  event SeedDAO(address indexed daoAddress, address indexed summonerAddress, uint256 amount);\n  event SummonedDAO(address indexed daoAddress, address indexed summonedBy);\n\n  modifier onlyAfterSummoning() {\n    DAO.Instance memory dao = _getDAO();\n    require(dao.summoned, 'ElasticDAO: DAO must be summoned');\n    _;\n  }\n  modifier onlyAfterTokenInitialized() {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    bool tokenInitialized =\n      Token(_getEcosystem().tokenModelAddress).exists(ecosystem.governanceTokenAddress, ecosystem);\n    require(tokenInitialized, 'ElasticDAO: Please call initializeToken first');\n    _;\n  }\n  modifier onlyBeforeSummoning() {\n    DAO.Instance memory dao = _getDAO();\n    require(dao.summoned == false, 'ElasticDAO: DAO must not be summoned');\n    _;\n  }\n  modifier onlyController() {\n    require(msg.sender == controller, 'ElasticDAO: Only controller');\n    _;\n  }\n  modifier onlyDeployer() {\n    require(msg.sender == deployer, 'ElasticDAO: Only deployer');\n    _;\n  }\n  modifier onlySummoners() {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    DAO daoContract = DAO(ecosystem.daoModelAddress);\n    DAO.Instance memory dao = daoContract.deserialize(address(this), ecosystem);\n    bool summonerCheck = daoContract.isSummoner(dao, msg.sender);\n\n    require(summonerCheck, 'ElasticDAO: Only summoners');\n    _;\n  }\n  modifier onlyWhenOpen() {\n    require(address(this).balance > 0, 'ElasticDAO: This DAO is closed');\n    _;\n  }\n\n  /**\n   * @notice Initializes and builds the ElasticDAO struct by passing and initializing\n   * all the required parameters into the configurator\n   *\n   * @param _ecosystemModelAddress - the address of the ecosystem model\n   * @param _controller the address which can control the core DAO functions\n   * @param _summoners - an array containing the addresses of the summoners\n   * @param _name - the name of the DAO\n   * @param _maxVotingLambda - the maximum amount of lambda that can be used to vote in the DAO\n   *\n   * @dev\n   * Requirements:\n   * - The DAO cannot already be initialized\n   * - The ecosystem model address cannot be the zero address\n   * - The DAO must have atleast one summoner to summon the DAO\n   * - The configurator should be able to successfully build the DAO\n   */\n  function initialize(\n    address _ecosystemModelAddress,\n    address _controller,\n    address[] memory _summoners,\n    string memory _name,\n    uint256 _maxVotingLambda\n  ) external preventReentry {\n    require(initialized == false, 'ElasticDAO: Already initialized');\n    require(\n      _ecosystemModelAddress != address(0) || _controller != address(0),\n      'ElasticDAO: Address Zero'\n    );\n    require(_summoners.length > 0, 'ElasticDAO: At least 1 summoner required');\n\n    Ecosystem.Instance memory defaults = Ecosystem(_ecosystemModelAddress).deserialize(address(0));\n    Configurator configurator = Configurator(defaults.configuratorAddress);\n    Ecosystem.Instance memory ecosystem = configurator.buildEcosystem(controller, defaults);\n    ecosystemModelAddress = ecosystem.ecosystemModelAddress;\n\n    controller = _controller;\n    deployer = msg.sender;\n    summoners = _summoners;\n\n    bool success = configurator.buildDAO(_summoners, _name, _maxVotingLambda, ecosystem);\n    initialized = true;\n    require(success, 'ElasticDAO: Build DAO Failed');\n  }\n\n  /**\n   * @notice initializes the token of the DAO, using the Configurator\n   *\n   * @param _name - name of the token\n   * @param _symbol - symbol of the token\n   * @param _eByL -the amount of lambda a summoner gets(per ETH) during the seeding phase of the DAO\n   * @param _elasticity the value by which the cost of entering the  DAO increases ( on every join )\n   * @param _k - is the constant token multiplier\n   * it increases the number of tokens that each member of the DAO has with respect to their lambda\n   * @param _maxLambdaPurchase - is the maximum amount of lambda that can be purchased per wallet\n   *\n   * @dev refer https://docs.openzeppelin.com/cli/2.8/deploying-with-create2#create2\n   * for further understanding of Create2 and salt\n   * @dev emits ElasticGovernanceTokenDeployed event\n   * @dev\n   * Requirements:\n   * - Only the deployer of the DAO can initialize the Token\n   * - The controller of the DAO should successfully be set as the burner of the tokens of the DAO\n   * - The controller of the DAO should successfully be set as the minter of the tokens of the DAO\n   */\n  function initializeToken(\n    string memory _name,\n    string memory _symbol,\n    uint256 _eByL,\n    uint256 _elasticity,\n    uint256 _k,\n    uint256 _maxLambdaPurchase\n  ) external onlyBeforeSummoning onlyDeployer preventReentry {\n    require(msg.sender == deployer, 'ElasticDAO: Only deployer can initialize the Token');\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n\n    Token.Instance memory token =\n      Configurator(ecosystem.configuratorAddress).buildToken(\n        controller,\n        _name,\n        _symbol,\n        _eByL,\n        _elasticity,\n        _k,\n        _maxLambdaPurchase,\n        ecosystem\n      );\n\n    emit ElasticGovernanceTokenDeployed(token.uuid);\n  }\n\n  /**\n   * @notice this function is to be used for exiting the DAO\n   * for the underlying ETH value of  _deltaLambda\n   *\n   * The eth value of _deltaLambda is calculated using:\n   *\n   * eth to be transfered = ( deltaLambda/lambda ) * totalEthInTheDAO\n   *\n   * @param _deltaLambda - the amount of lambda the address exits with\n   *\n   * Requirement:\n   * - Should be able to successfully exit the DAO\n   * @dev emits ExitDAO event\n   */\n  function exit(uint256 _deltaLambda) external onlyAfterSummoning preventReentry {\n    // burn the shares\n    Token.Instance memory token = _getToken();\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(token.uuid);\n\n    // eth to be transfered = ( deltaLambda/lambda ) * totalEthInTheDAO\n    uint256 ratioOfShares = ElasticMath.wdiv(_deltaLambda, token.lambda);\n    uint256 ethToBeTransfered = ElasticMath.wmul(ratioOfShares, address(this).balance);\n    // transfer the eth\n    tokenContract.burnShares(msg.sender, _deltaLambda);\n    (bool success, ) = msg.sender.call{ value: ethToBeTransfered }('');\n    require(success, 'ElasticDAO: Exit Failed');\n    emit ExitDAO(address(this), msg.sender, _deltaLambda, ethToBeTransfered);\n  }\n\n  /**\n   * @notice this function is used to join the DAO after it has been summoned\n   * Joining the DAO is syntactically equal to minting _deltaLambda for the function caller.\n   *\n   * Based on the current state of the DAO, capitalDelta, deltaE, mDash are calulated,\n   * after which  _deltaLambda is minted for the address calling the function.\n   *\n   * @param _deltaLambda - the amount of lambda the address joins with\n   *\n   * @dev documentation and further math regarding capitalDelta, deltaE,\n   * mDash can be found at ../libraries/ElasticMath.sol\n   * @dev emits the JoinDAO event\n   *\n   * @dev Requirements:\n   * The amount of shares being purchased has to be lower than maxLambdaPurchase\n   * (The value of maxLambdaPurchase is set during the initialzing of the DAO)\n   * The correct value of ETH, calculated via deltaE,\n   * must be sent in the transaction by the calling address\n   * The token contract should be successfully be able to mint  _deltaLambda\n   */\n  function join(uint256 _deltaLambda)\n    external\n    payable\n    onlyAfterSummoning\n    onlyWhenOpen\n    preventReentry\n  {\n    Token.Instance memory token = _getToken();\n\n    require(\n      _deltaLambda <= token.maxLambdaPurchase,\n      'ElasticDAO: Cannot purchase those many lambda at once'\n    );\n\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(token.uuid);\n    uint256 capitalDelta =\n      ElasticMath.capitalDelta(\n        // the current totalBalance of the DAO is inclusive of msg.value,\n        // capitalDelta is to be calculated without the msg.value\n        address(this).balance - msg.value,\n        tokenContract.totalSupply()\n      );\n    uint256 deltaE =\n      ElasticMath.deltaE(\n        _deltaLambda,\n        capitalDelta,\n        token.k,\n        token.elasticity,\n        token.lambda,\n        token.m\n      );\n\n    if (deltaE != msg.value) {\n      revert('ElasticDAO: Incorrect ETH amount');\n    }\n\n    // mdash\n    uint256 lambdaDash = SafeMath.add(_deltaLambda, token.lambda);\n    uint256 mDash = ElasticMath.mDash(lambdaDash, token.lambda, token.m);\n\n    // serialize the token\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    Token tokenStorage = Token(ecosystem.tokenModelAddress);\n    token.m = mDash;\n    tokenStorage.serialize(token);\n\n    // tokencontract mint shares\n    bool success = tokenContract.mintShares(msg.sender, _deltaLambda);\n    require(success, 'ElasticDAO: Mint Shares Failed during Join');\n    emit JoinDAO(address(this), msg.sender, _deltaLambda, msg.value);\n  }\n\n  /**\n   * @notice penalizes @param _addresess with @param _amounts respectively\n   *\n   * @param _addresses - an array of addresses\n   * @param _amounts - an array containing the amounts each address has to be penalized respectively\n   *\n   * @dev Requirement:\n   * - Each address must have a corresponding amount to be penalized with\n   */\n  function penalize(address[] memory _addresses, uint256[] memory _amounts)\n    external\n    onlyController\n    preventReentry\n  {\n    require(\n      _addresses.length == _amounts.length,\n      'ElasticDAO: An amount is required for each address'\n    );\n\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(_getToken().uuid);\n\n    for (uint256 i = 0; i < _addresses.length; i += 1) {\n      tokenContract.burnShares(_addresses[i], _amounts[i]);\n    }\n  }\n\n  /**\n   * @notice rewards @param _addresess with @param _amounts respectively\n   *\n   * @param _addresses - an array of addresses\n   * @param _amounts - an array containing the amounts each address has to be rewarded respectively\n   *\n   * @dev Requirement:\n   * - Each address must have a corresponding amount to be rewarded with\n   */\n  function reward(address[] memory _addresses, uint256[] memory _amounts)\n    external\n    onlyController\n    preventReentry\n  {\n    require(\n      _addresses.length == _amounts.length,\n      'ElasticDAO: An amount is required for each address'\n    );\n\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(_getToken().uuid);\n\n    for (uint256 i = 0; i < _addresses.length; i += 1) {\n      tokenContract.mintShares(_addresses[i], _amounts[i]);\n    }\n  }\n\n  /**\n   * @notice sets the controller of the DAO,\n   * The controller of the DAO handles various responsibilities of the DAO,\n   * such as burning and minting tokens on behalf of the DAO\n   *\n   * @param _controller - the new address of the controller of the DAO\n   *\n   * @dev emits ControllerChanged event\n   * @dev Requirements:\n   * - The controller must not be the 0 address\n   * - The controller of the DAO should successfully be set as the burner of the tokens of the DAO\n   * - The controller of the DAO should successfully be set as the minter of the tokens of the DAO\n   */\n  function setController(address _controller) external onlyController preventReentry {\n    require(_controller != address(0), 'ElasticDAO: Address Zero');\n\n    controller = _controller;\n\n    // Update minter / burner\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(_getToken().uuid);\n    bool success = tokenContract.setBurner(controller);\n    require(success, 'ElasticDAO: Set Burner failed during setController');\n    success = tokenContract.setMinter(controller);\n    require(success, 'ElasticDAO: Set Minter failed during setController');\n\n    emit ControllerChanged(address(this), 'setController', controller);\n  }\n\n  /**\n   * @notice sets the max voting lambda value for the DAO\n   * @param _maxVotingLambda - the value of the maximum amount of lambda that can be used for voting\n   * @dev emits MaxVotingLambda event\n   */\n  function setMaxVotingLambda(uint256 _maxVotingLambda) external onlyController preventReentry {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    DAO daoStorage = DAO(ecosystem.daoModelAddress);\n    DAO.Instance memory dao = daoStorage.deserialize(address(this), ecosystem);\n    dao.maxVotingLambda = _maxVotingLambda;\n    daoStorage.serialize(dao);\n\n    emit MaxVotingLambdaChanged(address(this), 'setMaxVotingLambda', _maxVotingLambda);\n  }\n\n  /**\n   * @notice seeds the DAO,\n   * Essentially transferring of ETH by a summoner address, in return for lambda is seeding the DAO,\n   * The lambda receieved is given by:\n   * Lambda = Eth  / eByL\n   *\n   * @dev seeding of the DAO occurs after the DAO has been initialized,\n   * and before the DAO has been summoned\n   * @dev emits the SeedDAO event\n   */\n  function seedSummoning()\n    external\n    payable\n    onlyBeforeSummoning\n    onlySummoners\n    onlyAfterTokenInitialized\n    preventReentry\n  {\n    Token.Instance memory token = _getToken();\n\n    uint256 deltaE = msg.value;\n    uint256 deltaLambda = ElasticMath.wdiv(deltaE, token.eByL);\n    ElasticGovernanceToken(token.uuid).mintShares(msg.sender, deltaLambda);\n\n    emit SeedDAO(address(this), msg.sender, deltaLambda);\n  }\n\n  /**\n   * @notice summons the DAO,\n   * Summoning the DAO results in all summoners getting _deltaLambda\n   * after which people can enter the DAO using the join function\n   *\n   * @param _deltaLambda - the amount of lambda each summoner address receieves\n   *\n   * @dev emits SummonedDAO event\n   * @dev Requirement:\n   * The DAO must be seeded with ETH during the seeding phase\n   * (This is to facilitate capitalDelta calculations after the DAO has been summoned).\n   *\n   * @dev documentation and further math regarding capitalDelta\n   * can be found at ../libraries/ElasticMath.sol\n   */\n  function summon(uint256 _deltaLambda) external onlyBeforeSummoning onlySummoners preventReentry {\n    require(address(this).balance > 0, 'ElasticDAO: Please seed DAO with ETH to set ETH:EGT ratio');\n\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    DAO daoContract = DAO(ecosystem.daoModelAddress);\n    DAO.Instance memory dao = daoContract.deserialize(address(this), ecosystem);\n    Token.Instance memory token =\n      Token(ecosystem.tokenModelAddress).deserialize(ecosystem.governanceTokenAddress, ecosystem);\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(token.uuid);\n\n    // number of summoners can not grow unboundly. it is fixed limit.\n    for (uint256 i = 0; i < dao.numberOfSummoners; i += 1) {\n      tokenContract.mintShares(daoContract.getSummoner(dao, i), _deltaLambda);\n    }\n    dao.summoned = true;\n    daoContract.serialize(dao);\n\n    emit SummonedDAO(address(this), msg.sender);\n  }\n\n  // Getters\n\n  function getDAO() external view returns (DAO.Instance memory) {\n    return _getDAO();\n  }\n\n  function getEcosystem() external view returns (Ecosystem.Instance memory) {\n    return _getEcosystem();\n  }\n\n  // Private\n\n  function _getDAO() internal view returns (DAO.Instance memory) {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    return DAO(ecosystem.daoModelAddress).deserialize(address(this), ecosystem);\n  }\n\n  function _getEcosystem() internal view returns (Ecosystem.Instance memory) {\n    return Ecosystem(ecosystemModelAddress).deserialize(address(this));\n  }\n\n  function _getToken() internal view returns (Token.Instance memory) {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    return\n      Token(ecosystem.tokenModelAddress).deserialize(ecosystem.governanceTokenAddress, ecosystem);\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {}\n}\n\n\n// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport './Ecosystem.sol';\nimport './EternalModel.sol';\nimport '../libraries/SafeMath.sol';\nimport '../services/ReentryProtection.sol';\n\n/**\n * @author ElasticDAO - https://ElasticDAO.org\n * @notice This contract is used for storing core DAO data\n * @dev ElasticDAO network contracts can read/write from this contract\n */\ncontract DAO is EternalModel, ReentryProtection {\n  struct Instance {\n    address uuid;\n    address[] summoners;\n    bool summoned;\n    string name;\n    uint256 maxVotingLambda;\n    uint256 numberOfSummoners;\n    Ecosystem.Instance ecosystem;\n  }\n\n  event Serialized(address indexed uuid);\n\n  /**\n   * @dev deserializes Instance struct\n   * @param _uuid - address of the unique user ID\n   * @return record Instance\n   */\n  function deserialize(address _uuid, Ecosystem.Instance memory _ecosystem)\n    external\n    view\n    returns (Instance memory record)\n  {\n    record.uuid = _uuid;\n    record.ecosystem = _ecosystem;\n\n    if (_exists(_uuid)) {\n      record.maxVotingLambda = getUint(keccak256(abi.encode(_uuid, 'maxVotingLambda')));\n      record.name = getString(keccak256(abi.encode(_uuid, 'name')));\n      record.numberOfSummoners = getUint(keccak256(abi.encode(_uuid, 'numberOfSummoners')));\n      record.summoned = getBool(keccak256(abi.encode(_uuid, 'summoned')));\n    }\n\n    return record;\n  }\n\n  /**\n   * @dev checks if @param _uuid exists\n   * @param _uuid - address of the unique user ID\n   * @return recordExists bool\n   */\n  function exists(address _uuid, Ecosystem.Instance memory) external view returns (bool) {\n    return _exists(_uuid);\n  }\n\n  function getSummoner(Instance memory _dao, uint256 _index) external view returns (address) {\n    return getAddress(keccak256(abi.encode(_dao.uuid, 'summoners', _index)));\n  }\n\n  /**\n   * @dev checks if @param _uuid where _uuid is msg.sender - is a Summoner\n   * @param _dao DAO.Instance\n   * @param _summonerAddress address\n   * @return bool\n   */\n  function isSummoner(Instance memory _dao, address _summonerAddress) external view returns (bool) {\n    return getBool(keccak256(abi.encode(_dao.uuid, 'summoner', _summonerAddress)));\n  }\n\n  /**\n   * @dev serializes Instance struct\n   * @param _record Instance\n   */\n  function serialize(Instance memory _record) external preventReentry {\n    require(\n      msg.sender == _record.uuid || msg.sender == _record.ecosystem.configuratorAddress,\n      'ElasticDAO: Unauthorized'\n    );\n\n    setUint(keccak256(abi.encode(_record.uuid, 'maxVotingLambda')), _record.maxVotingLambda);\n    setString(keccak256(abi.encode(_record.uuid, 'name')), _record.name);\n    setBool(keccak256(abi.encode(_record.uuid, 'summoned')), _record.summoned);\n\n    if (_record.summoners.length > 0) {\n      _record.numberOfSummoners = _record.summoners.length;\n      setUint(keccak256(abi.encode(_record.uuid, 'numberOfSummoners')), _record.numberOfSummoners);\n      for (uint256 i = 0; i < _record.numberOfSummoners; i += 1) {\n        setBool(keccak256(abi.encode(_record.uuid, 'summoner', _record.summoners[i])), true);\n        setAddress(keccak256(abi.encode(_record.uuid, 'summoners', i)), _record.summoners[i]);\n      }\n    }\n\n    setBool(keccak256(abi.encode(_record.uuid, 'exists')), true);\n\n    emit Serialized(_record.uuid);\n  }\n\n  function _exists(address _uuid) internal view returns (bool) {\n    return getBool(keccak256(abi.encode(_uuid, 'exists')));\n  }\n}\n\n\n",
        "CodeNames": [
            "ElasticDAO.sol",
            "DAO.sol",
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_H-02",
                "Location": [
                    "daoModelAddress",
                    "models/Ecosystem"
                ],
                "Type": " Infinite minting of tokens by exploiting eternal storage pattern on Ecosystem.sol",
                "Description": " A similar exploit is possible because of the models/Ecosystem.sol eternal storage contract. Attackers can change the expected address to their own address while bypassing the authorization check for this function. This allows the attacker to change the DAO ecosystem data.   Gaining full access to the DAO ecosystem data is also possible by changing the daoModelAddress field to an attacker-controlled proxy contract. This attack vector allows attackers to mint infinite tokens for themselves and potentially break all DAOs created by the ElasticDAO system.   ElasticDAO: Confirmed and resolved in PR #43   ",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport './Ecosystem.sol';\nimport './EternalModel.sol';\nimport '../libraries/SafeMath.sol';\nimport '../services/ReentryProtection.sol';\n\n/**\n * @author ElasticDAO - https://ElasticDAO.org\n * @notice This contract is used for storing core DAO data\n * @dev ElasticDAO network contracts can read/write from this contract\n */\ncontract DAO is EternalModel, ReentryProtection {\n  struct Instance {\n    address uuid;\n    address[] summoners;\n    bool summoned;\n    string name;\n    uint256 maxVotingLambda;\n    uint256 numberOfSummoners;\n    Ecosystem.Instance ecosystem;\n  }\n\n  event Serialized(address indexed uuid);\n\n  /**\n   * @dev deserializes Instance struct\n   * @param _uuid - address of the unique user ID\n   * @return record Instance\n   */\n  function deserialize(address _uuid, Ecosystem.Instance memory _ecosystem)\n    external\n    view\n    returns (Instance memory record)\n  {\n    record.uuid = _uuid;\n    record.ecosystem = _ecosystem;\n\n    if (_exists(_uuid)) {\n      record.maxVotingLambda = getUint(keccak256(abi.encode(_uuid, 'maxVotingLambda')));\n      record.name = getString(keccak256(abi.encode(_uuid, 'name')));\n      record.numberOfSummoners = getUint(keccak256(abi.encode(_uuid, 'numberOfSummoners')));\n      record.summoned = getBool(keccak256(abi.encode(_uuid, 'summoned')));\n    }\n\n    return record;\n  }\n\n  /**\n   * @dev checks if @param _uuid exists\n   * @param _uuid - address of the unique user ID\n   * @return recordExists bool\n   */\n  function exists(address _uuid, Ecosystem.Instance memory) external view returns (bool) {\n    return _exists(_uuid);\n  }\n\n  function getSummoner(Instance memory _dao, uint256 _index) external view returns (address) {\n    return getAddress(keccak256(abi.encode(_dao.uuid, 'summoners', _index)));\n  }\n\n  /**\n   * @dev checks if @param _uuid where _uuid is msg.sender - is a Summoner\n   * @param _dao DAO.Instance\n   * @param _summonerAddress address\n   * @return bool\n   */\n  function isSummoner(Instance memory _dao, address _summonerAddress) external view returns (bool) {\n    return getBool(keccak256(abi.encode(_dao.uuid, 'summoner', _summonerAddress)));\n  }\n\n  /**\n   * @dev serializes Instance struct\n   * @param _record Instance\n   */\n  function serialize(Instance memory _record) external preventReentry {\n    require(\n      msg.sender == _record.uuid || msg.sender == _record.ecosystem.configuratorAddress,\n      'ElasticDAO: Unauthorized'\n    );\n\n    setUint(keccak256(abi.encode(_record.uuid, 'maxVotingLambda')), _record.maxVotingLambda);\n    setString(keccak256(abi.encode(_record.uuid, 'name')), _record.name);\n    setBool(keccak256(abi.encode(_record.uuid, 'summoned')), _record.summoned);\n\n    if (_record.summoners.length > 0) {\n      _record.numberOfSummoners = _record.summoners.length;\n      setUint(keccak256(abi.encode(_record.uuid, 'numberOfSummoners')), _record.numberOfSummoners);\n      for (uint256 i = 0; i < _record.numberOfSummoners; i += 1) {\n        setBool(keccak256(abi.encode(_record.uuid, 'summoner', _record.summoners[i])), true);\n        setAddress(keccak256(abi.encode(_record.uuid, 'summoners', i)), _record.summoners[i]);\n      }\n    }\n\n    setBool(keccak256(abi.encode(_record.uuid, 'exists')), true);\n\n    emit Serialized(_record.uuid);\n  }\n\n  function _exists(address _uuid) internal view returns (bool) {\n    return getBool(keccak256(abi.encode(_uuid, 'exists')));\n  }\n}\n\n\n// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport './EternalModel.sol';\nimport '../libraries/SafeMath.sol';\nimport '../services/ReentryProtection.sol';\n\n/**\n * @title ElasticDAO ecosystem\n * @author ElasticDAO - https://ElasticDAO.org\n * @notice This contract is used for storing core dao data\n * @dev ElasticDAO network contracts can read/write from this contract\n * @dev Serialize - Translation of data from the concerned struct to key-value pairs\n * @dev Deserialize - Translation of data from the key-value pairs to a struct\n */\ncontract Ecosystem is EternalModel, ReentryProtection {\n  struct Instance {\n    address daoAddress;\n    // Models\n    address daoModelAddress;\n    address ecosystemModelAddress;\n    address tokenHolderModelAddress;\n    address tokenModelAddress;\n    // Services\n    address configuratorAddress;\n    // Tokens\n    address governanceTokenAddress;\n  }\n\n  event Serialized(address indexed _daoAddress);\n\n  /**\n   * @dev deserializes Instance struct\n   * @param _daoAddress - address of the unique user ID\n   * @return record Instance\n   */\n  function deserialize(address _daoAddress) external view returns (Instance memory record) {\n    if (_exists(_daoAddress)) {\n      record.daoAddress = _daoAddress;\n      record.configuratorAddress = getAddress(\n        keccak256(abi.encode(record.daoAddress, 'configuratorAddress'))\n      );\n      record.daoModelAddress = getAddress(\n        keccak256(abi.encode(record.daoAddress, 'daoModelAddress'))\n      );\n      record.ecosystemModelAddress = address(this);\n      record.governanceTokenAddress = getAddress(\n        keccak256(abi.encode(record.daoAddress, 'governanceTokenAddress'))\n      );\n      record.tokenHolderModelAddress = getAddress(\n        keccak256(abi.encode(record.daoAddress, 'tokenHolderModelAddress'))\n      );\n      record.tokenModelAddress = getAddress(\n        keccak256(abi.encode(record.daoAddress, 'tokenModelAddress'))\n      );\n    }\n\n    return record;\n  }\n\n  /**\n   * @dev checks if @param _daoAddress\n   * @param _daoAddress - address of the unique user ID\n   * @return recordExists bool\n   */\n  function exists(address _daoAddress) external view returns (bool recordExists) {\n    return _exists(_daoAddress);\n  }\n\n  /**\n   * @dev serializes Instance struct\n   * @param _record Instance\n   */\n  function serialize(Instance memory _record) external preventReentry {\n    bool recordExists = _exists(_record.daoAddress);\n\n    require(\n      msg.sender == _record.daoAddress ||\n        msg.sender == _record.configuratorAddress ||\n        (_record.daoAddress == address(0) && !recordExists),\n      'ElasticDAO: Unauthorized'\n    );\n\n    setAddress(\n      keccak256(abi.encode(_record.daoAddress, 'configuratorAddress')),\n      _record.configuratorAddress\n    );\n    setAddress(\n      keccak256(abi.encode(_record.daoAddress, 'daoModelAddress')),\n      _record.daoModelAddress\n    );\n    setAddress(\n      keccak256(abi.encode(_record.daoAddress, 'governanceTokenAddress')),\n      _record.governanceTokenAddress\n    );\n    setAddress(\n      keccak256(abi.encode(_record.daoAddress, 'tokenHolderModelAddress')),\n      _record.tokenHolderModelAddress\n    );\n    setAddress(\n      keccak256(abi.encode(_record.daoAddress, 'tokenModelAddress')),\n      _record.tokenModelAddress\n    );\n\n    setBool(keccak256(abi.encode(_record.daoAddress, 'exists')), true);\n\n    emit Serialized(_record.daoAddress);\n  }\n\n  function _exists(address _daoAddress) internal view returns (bool recordExists) {\n    return getBool(keccak256(abi.encode(_daoAddress, 'exists')));\n  }\n}\n\n\n// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport '../models/DAO.sol';\nimport '../models/Ecosystem.sol';\nimport '../models/Token.sol';\n\nimport '../tokens/ElasticGovernanceToken.sol';\n\nimport '@pie-dao/proxy/contracts/PProxy.sol';\n\n/**\n * @notice This contract is used for configuring ElasticDAOs\n * @dev The main reason for having this is to decrease the size of ElasticDAO.sol\n */\ncontract Configurator {\n  /**\n   * @dev creates DAO.Instance record\n   * @param _summoners addresses of the summoners\n   * @param _name name of the DAO\n   * @param _ecosystem instance of Ecosystem the DAO uses\n   * @param _maxVotingLambda - the maximum amount of lambda that can be used to vote in the DAO\n   * @return bool true\n   */\n  function buildDAO(\n    address[] memory _summoners,\n    string memory _name,\n    uint256 _maxVotingLambda,\n    Ecosystem.Instance memory _ecosystem\n  ) external returns (bool) {\n    DAO daoStorage = DAO(_ecosystem.daoModelAddress);\n    DAO.Instance memory dao;\n\n    dao.uuid = msg.sender;\n    dao.ecosystem = _ecosystem;\n    dao.maxVotingLambda = _maxVotingLambda;\n    dao.name = _name;\n    dao.summoned = false;\n    dao.summoners = _summoners;\n    daoStorage.serialize(dao);\n\n    return true;\n  }\n\n  /**\n   * @dev duplicates the ecosystem contract address defaults so that each\n   * deployed DAO has it's own ecosystem configuration\n   * @param _controller the address which can control the core DAO functions\n   * @param _defaults instance of Ecosystem with the implementation addresses\n   * @return ecosystem Ecosystem.Instance\n   */\n  function buildEcosystem(address _controller, Ecosystem.Instance memory _defaults)\n    external\n    returns (Ecosystem.Instance memory ecosystem)\n  {\n    ecosystem.configuratorAddress = _defaults.configuratorAddress;\n    ecosystem.daoAddress = msg.sender;\n    ecosystem.daoModelAddress = _deployProxy(_defaults.daoModelAddress, _controller);\n    ecosystem.ecosystemModelAddress = _deployProxy(_defaults.ecosystemModelAddress, _controller);\n    ecosystem.governanceTokenAddress = _deployProxy(_defaults.governanceTokenAddress, _controller);\n    ecosystem.tokenHolderModelAddress = _deployProxy(\n      _defaults.tokenHolderModelAddress,\n      _controller\n    );\n    ecosystem.tokenModelAddress = _deployProxy(_defaults.tokenModelAddress, _controller);\n\n    Ecosystem(ecosystem.ecosystemModelAddress).serialize(ecosystem);\n    return ecosystem;\n  }\n\n  /**\n   * @dev creates a governance token proxy and Token instance (storage)\n   * @param _controller the address which can control the core DAO functions\n   * @param _name name of the token\n   * @param _symbol symbol of the token\n   * @param _eByL initial ETH/token ratio\n   * @param _elasticity the percentage by which capitalDelta should increase\n   * @param _k a constant, initially set by the DAO\n   * @param _maxLambdaPurchase maximum amount of lambda (shares) that can be\n   * minted on each call to the join function in ElasticDAO.sol\n   * @param _ecosystem the DAO's ecosystem instance\n   * @return token Token.Instance\n   */\n  function buildToken(\n    address _controller,\n    string memory _name,\n    string memory _symbol,\n    uint256 _eByL,\n    uint256 _elasticity,\n    uint256 _k,\n    uint256 _maxLambdaPurchase,\n    Ecosystem.Instance memory _ecosystem\n  ) external returns (Token.Instance memory token) {\n    Token tokenStorage = Token(_ecosystem.tokenModelAddress);\n    token.eByL = _eByL;\n    token.ecosystem = _ecosystem;\n    token.elasticity = _elasticity;\n    token.k = _k;\n    token.lambda = 0;\n    token.m = 1000000000000000000;\n    token.maxLambdaPurchase = _maxLambdaPurchase;\n    token.name = _name;\n    token.symbol = _symbol;\n    token.uuid = _ecosystem.governanceTokenAddress;\n\n    // initialize the token within the ecosystem\n    ElasticGovernanceToken(token.uuid).initialize(\n      _controller,\n      _ecosystem.daoAddress,\n      _ecosystem.ecosystemModelAddress,\n      _controller\n    );\n\n    // serialize ecosystem and token\n    Ecosystem(_ecosystem.ecosystemModelAddress).serialize(_ecosystem);\n    tokenStorage.serialize(token);\n\n    return token;\n  }\n\n  function _deployProxy(address _implementationAddress, address _owner) internal returns (address) {\n    PProxy proxy = new PProxy();\n    proxy.setImplementation(_implementationAddress);\n    proxy.setProxyOwner(_owner);\n    return address(proxy);\n  }\n}\n\n\n",
        "CodeNames": [
            "DAO.sol",
            "Ecosystem.sol",
            "Configurator.sol",
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_H-04",
                "Location": [
                    "buildToken",
                    "services/Configurator"
                ],
                "Type": " Configurator contract allows infinite minting of tokens",
                "Description": " Even if a configurator address is hard-coded in the Ecosystem.sol contract, attackers can call the buildToken function on the services/Configurator.sol contract and change nearly all of the parameters to be attacker-controlled. The attacker bypasses the authorization check and gains write access to fields of the DAO ecosystem.   ElasticDAO: Confirmed and resolved in PR #43   ",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport './Ecosystem.sol';\nimport './EternalModel.sol';\nimport '../libraries/SafeMath.sol';\nimport '../services/ReentryProtection.sol';\n\n/**\n * @author ElasticDAO - https://ElasticDAO.org\n * @notice This contract is used for storing core DAO data\n * @dev ElasticDAO network contracts can read/write from this contract\n */\ncontract DAO is EternalModel, ReentryProtection {\n  struct Instance {\n    address uuid;\n    address[] summoners;\n    bool summoned;\n    string name;\n    uint256 maxVotingLambda;\n    uint256 numberOfSummoners;\n    Ecosystem.Instance ecosystem;\n  }\n\n  event Serialized(address indexed uuid);\n\n  /**\n   * @dev deserializes Instance struct\n   * @param _uuid - address of the unique user ID\n   * @return record Instance\n   */\n  function deserialize(address _uuid, Ecosystem.Instance memory _ecosystem)\n    external\n    view\n    returns (Instance memory record)\n  {\n    record.uuid = _uuid;\n    record.ecosystem = _ecosystem;\n\n    if (_exists(_uuid)) {\n      record.maxVotingLambda = getUint(keccak256(abi.encode(_uuid, 'maxVotingLambda')));\n      record.name = getString(keccak256(abi.encode(_uuid, 'name')));\n      record.numberOfSummoners = getUint(keccak256(abi.encode(_uuid, 'numberOfSummoners')));\n      record.summoned = getBool(keccak256(abi.encode(_uuid, 'summoned')));\n    }\n\n    return record;\n  }\n\n  /**\n   * @dev checks if @param _uuid exists\n   * @param _uuid - address of the unique user ID\n   * @return recordExists bool\n   */\n  function exists(address _uuid, Ecosystem.Instance memory) external view returns (bool) {\n    return _exists(_uuid);\n  }\n\n  function getSummoner(Instance memory _dao, uint256 _index) external view returns (address) {\n    return getAddress(keccak256(abi.encode(_dao.uuid, 'summoners', _index)));\n  }\n\n  /**\n   * @dev checks if @param _uuid where _uuid is msg.sender - is a Summoner\n   * @param _dao DAO.Instance\n   * @param _summonerAddress address\n   * @return bool\n   */\n  function isSummoner(Instance memory _dao, address _summonerAddress) external view returns (bool) {\n    return getBool(keccak256(abi.encode(_dao.uuid, 'summoner', _summonerAddress)));\n  }\n\n  /**\n   * @dev serializes Instance struct\n   * @param _record Instance\n   */\n  function serialize(Instance memory _record) external preventReentry {\n    require(\n      msg.sender == _record.uuid || msg.sender == _record.ecosystem.configuratorAddress,\n      'ElasticDAO: Unauthorized'\n    );\n\n    setUint(keccak256(abi.encode(_record.uuid, 'maxVotingLambda')), _record.maxVotingLambda);\n    setString(keccak256(abi.encode(_record.uuid, 'name')), _record.name);\n    setBool(keccak256(abi.encode(_record.uuid, 'summoned')), _record.summoned);\n\n    if (_record.summoners.length > 0) {\n      _record.numberOfSummoners = _record.summoners.length;\n      setUint(keccak256(abi.encode(_record.uuid, 'numberOfSummoners')), _record.numberOfSummoners);\n      for (uint256 i = 0; i < _record.numberOfSummoners; i += 1) {\n        setBool(keccak256(abi.encode(_record.uuid, 'summoner', _record.summoners[i])), true);\n        setAddress(keccak256(abi.encode(_record.uuid, 'summoners', i)), _record.summoners[i]);\n      }\n    }\n\n    setBool(keccak256(abi.encode(_record.uuid, 'exists')), true);\n\n    emit Serialized(_record.uuid);\n  }\n\n  function _exists(address _uuid) internal view returns (bool) {\n    return getBool(keccak256(abi.encode(_uuid, 'exists')));\n  }\n}\n\n\n// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport './Ecosystem.sol';\nimport './EternalModel.sol';\nimport '../libraries/SafeMath.sol';\nimport '../services/ReentryProtection.sol';\nimport '../tokens/ElasticGovernanceToken.sol';\n\n/**\n * @title A data storage for EGT (Elastic Governance Token)\n * @notice More info about EGT could be found in ./tokens/ElasticGovernanceToken.sol\n * @notice This contract is used for storing token data\n * @dev ElasticDAO network contracts can read/write from this contract\n * Serialize - Translation of data from the concerned struct to key-value pairs\n * Deserialize - Translation of data from the key-value pairs to a struct\n */\ncontract Token is EternalModel, ReentryProtection {\n  struct Instance {\n    address uuid;\n    string name;\n    string symbol;\n    uint256 eByL;\n    uint256 elasticity;\n    uint256 k;\n    uint256 lambda;\n    uint256 m;\n    uint256 maxLambdaPurchase;\n    uint256 numberOfTokenHolders;\n    Ecosystem.Instance ecosystem;\n  }\n\n  event Serialized(address indexed uuid);\n\n  /**\n   * @dev deserializes Instance struct\n   * @param _uuid - address of the unique user ID\n   * @return record Instance\n   */\n  function deserialize(address _uuid, Ecosystem.Instance memory _ecosystem)\n    external\n    view\n    returns (Instance memory record)\n  {\n    record.uuid = _uuid;\n    record.ecosystem = _ecosystem;\n\n    if (_exists(_uuid)) {\n      record.eByL = getUint(keccak256(abi.encode(_uuid, 'eByL')));\n      record.elasticity = getUint(keccak256(abi.encode(_uuid, 'elasticity')));\n      record.k = getUint(keccak256(abi.encode(_uuid, 'k')));\n      record.lambda = getUint(keccak256(abi.encode(_uuid, 'lambda')));\n      record.m = getUint(keccak256(abi.encode(_uuid, 'm')));\n      record.maxLambdaPurchase = getUint(keccak256(abi.encode(_uuid, 'maxLambdaPurchase')));\n      record.name = getString(keccak256(abi.encode(_uuid, 'name')));\n      record.numberOfTokenHolders = getUint(keccak256(abi.encode(_uuid, 'numberOfTokenHolders')));\n      record.symbol = getString(keccak256(abi.encode(_uuid, 'symbol')));\n    }\n\n    return record;\n  }\n\n  function exists(address _uuid, Ecosystem.Instance memory) external view returns (bool) {\n    return _exists(_uuid);\n  }\n\n  /**\n   * @dev serializes Instance struct\n   * @param _record Instance\n   */\n  function serialize(Instance memory _record) external preventReentry {\n    require(\n      msg.sender == _record.uuid ||\n        msg.sender == _record.ecosystem.daoAddress ||\n        (msg.sender == _record.ecosystem.configuratorAddress && !_exists(_record.uuid)),\n      'ElasticDAO: Unauthorized'\n    );\n\n    setString(keccak256(abi.encode(_record.uuid, 'name')), _record.name);\n    setString(keccak256(abi.encode(_record.uuid, 'symbol')), _record.symbol);\n    setUint(keccak256(abi.encode(_record.uuid, 'eByL')), _record.eByL);\n    setUint(keccak256(abi.encode(_record.uuid, 'elasticity')), _record.elasticity);\n    setUint(keccak256(abi.encode(_record.uuid, 'k')), _record.k);\n    setUint(keccak256(abi.encode(_record.uuid, 'lambda')), _record.lambda);\n    setUint(keccak256(abi.encode(_record.uuid, 'm')), _record.m);\n    setUint(keccak256(abi.encode(_record.uuid, 'maxLambdaPurchase')), _record.maxLambdaPurchase);\n\n    setBool(keccak256(abi.encode(_record.uuid, 'exists')), true);\n\n    emit Serialized(_record.uuid);\n  }\n\n  function updateNumberOfTokenHolders(Instance memory _record, uint256 numberOfTokenHolders)\n    external\n    preventReentry\n  {\n    setUint(keccak256(abi.encode(_record.uuid, 'numberOfTokenHolders')), numberOfTokenHolders);\n  }\n\n  function _exists(address _uuid) internal view returns (bool) {\n    return getBool(keccak256(abi.encode(_uuid, 'exists')));\n  }\n}\n\n\n",
        "CodeNames": [
            "DAO.sol",
            "Token.sol",
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_H-05",
                "Location": [
                    "self-DOS"
                ],
                "Type": " New users can be blocked from joining",
                "Description": " The join function requires users to send an exact amount of ETH for the required shares. Attackers can survey the mempool for join transactions and send a tiny amount of wei to the DAO contract to change the required ETH value to a different value than the user submitted. This griefing attack would prevent new users from joining the DAO.   Malicious actors might use this attack to prevent new votes from derailing the outcome of a proposal. Normal DAO usage might also block new users from joining. Token curve parameters change as a result of new join transactions. During times of high demand, many transactions will fail and effectively result in a self-DOS.   ElasticDAO: Confirmed and resolved in PR #43 and PR #59   ",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport '../interfaces/IElasticToken.sol';\n\nimport '../libraries/SafeMath.sol';\nimport '../libraries/ElasticMath.sol';\n\nimport '../core/ElasticDAO.sol';\nimport '../models/DAO.sol';\nimport '../models/Ecosystem.sol';\nimport '../models/Token.sol';\nimport '../models/TokenHolder.sol';\n\nimport '../services/ReentryProtection.sol';\n\n/**\n * @dev ElasticGovernanceToken contract outlines and defines all the functionality\n * of an ElasticGovernanceToken and also serves as it's storage\n */\ncontract ElasticGovernanceToken is IElasticToken, ReentryProtection {\n  address public burner;\n  address public daoAddress;\n  address public ecosystemModelAddress;\n  address public minter;\n  bool public initialized;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  modifier onlyDAO() {\n    require(msg.sender == daoAddress || msg.sender == minter, 'ElasticDAO: Not authorized');\n    _;\n  }\n\n  modifier onlyDAOorBurner() {\n    require(msg.sender == daoAddress || msg.sender == burner, 'ElasticDAO: Not authorized');\n    _;\n  }\n\n  modifier onlyDAOorMinter() {\n    require(msg.sender == daoAddress || msg.sender == minter, 'ElasticDAO: Not authorized');\n    _;\n  }\n\n  /**\n   * @notice initializes the ElasticGovernanceToken\n   *\n   * @param _burner - the address which can burn tokens\n   * @param _daoAddress - the address of the deployed ElasticDAO\n   * @param _ecosystemModelAddress - the address of the ecosystem model\n   * @param _minter - the address which can mint tokens\n   *\n   * @dev Requirements:\n   * - The token should not already be initialized\n   * - The address of the burner cannot be zero\n   * - The address of the deployed ElasticDAO cannot be zero\n   * - The address of the ecosystemModelAddress cannot be zero\n   * - The address of the minter cannot be zero\n   *\n   * @return bool\n   */\n  function initialize(\n    address _burner,\n    address _daoAddress,\n    address _ecosystemModelAddress,\n    address _minter\n  ) external preventReentry returns (bool) {\n    require(initialized == false, 'ElasticDAO: Already initialized');\n    require(_burner != address(0), 'ElasticDAO: Address Zero');\n    require(_daoAddress != address(0), 'ElasticDAO: Address Zero');\n    require(_ecosystemModelAddress != address(0), 'ElasticDAO: Address Zero');\n    require(_minter != address(0), 'ElasticDAO: Address Zero');\n\n    initialized = true;\n    burner = _burner;\n    daoAddress = _daoAddress;\n    ecosystemModelAddress = _ecosystemModelAddress;\n    minter = _minter;\n\n    return true;\n  }\n\n  /**\n   * @notice Returns the remaining number of tokens that @param _spender will be\n   * allowed to spend on behalf of @param _owner through {transferFrom}. This is\n   * zero by default\n   *\n   * @param _spender - the address of the spender\n   * @param _owner - the address of the owner\n   *\n   * @dev This value changes when {approve} or {transferFrom} are called\n   *\n   * @return uint256\n   */\n  function allowance(address _owner, address _spender) external view override returns (uint256) {\n    return _allowances[_owner][_spender];\n  }\n\n  /**\n   * @notice Sets @param _amount as the allowance of @param _spender over the caller's tokens\n   *\n   * @param _spender - the address of the spender\n   *\n   * @dev\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * @dev Emits an {Approval} event\n   *\n   * @return bool\n   */\n  function approve(address _spender, uint256 _amount)\n    external\n    override\n    preventReentry\n    returns (bool)\n  {\n    _approve(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  /**\n   * @notice Returns the amount of tokens owned by @param _account using ElasticMath\n   *\n   * @param _account - address of the account\n   *\n   * @dev the number of tokens is given by:\n   * t = lambda * m * k\n   *\n   * t - number of tokens\n   * m - lambda modifier - it's value increases every time someone joins the DAO\n   * k - constant token multiplier - it increases the number of tokens\n   *  that each member of the DAO has with respect to their lambda\n   *\n   * Further math and documentaion of 't' can be found at ../libraries/ElasticMath.sol\n   *\n   * @return uint256\n   */\n  function balanceOf(address _account) external view override returns (uint256) {\n    Token.Instance memory token = _getToken();\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\n    uint256 t = ElasticMath.t(tokenHolder.lambda, token.k, token.m);\n\n    return t;\n  }\n\n  /**\n   * @notice Returns the amount of shares ( lambda ) owned by _account.\n   *\n   * @param _account - address of the account\n   *\n   * @return lambda uint256 - lambda is the number of shares\n   */\n  function balanceOfInShares(address _account) external view override returns (uint256) {\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\n    return tokenHolder.lambda;\n  }\n\n  /**\n   * @notice Returns the amount of tokens @param _account can vote with, using ElasticMath\n   *\n   * @param _account - the address of the account\n   *\n   * @dev checks if @param _account has more or less lambda than maxVotingLambda,\n   * based on which number of tokens (t) @param _account can vote with is calculated.\n   * Further math and documentaion of 't' can be found at ../libraries/ElasticMath.sol\n   *\n   * @return balance uint256 numberOfTokens (t)\n   */\n  function balanceOfVoting(address _account) external view returns (uint256 balance) {\n    Token.Instance memory token = _getToken();\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\n    uint256 maxVotingLambda = _getDAO().maxVotingLambda;\n\n    if (tokenHolder.lambda > maxVotingLambda) {\n      return ElasticMath.t(maxVotingLambda, token.k, token.m);\n    } else {\n      return ElasticMath.t(tokenHolder.lambda, token.k, token.m);\n    }\n  }\n\n  /**\n   * @notice Reduces the balance(tokens) of @param _account by  _amount\n   *\n   * @param _account address of the account\n   *\n   * @param _amount - the amount by which the number of tokens is to be reduced\n   *\n   * @return bool\n   */\n  function burn(address _account, uint256 _amount)\n    external\n    override\n    onlyDAOorBurner\n    preventReentry\n    returns (bool)\n  {\n    _burn(_account, _amount);\n    return true;\n  }\n\n  /**\n   * @notice Reduces the balance(lambda) of @param _account by  _amount\n   *\n   * @param _account - address of the account\n   *\n   * @param _amount - the amount by which the number of shares has to be reduced\n   *\n   * @return bool\n   */\n  function burnShares(address _account, uint256 _amount)\n    external\n    override\n    onlyDAOorBurner\n    preventReentry\n    returns (bool)\n  {\n    _burnShares(_account, _amount);\n    return true;\n  }\n\n  /**\n   * @notice returns the number of decimals\n   *\n   * @return 18\n   */\n  function decimals() external pure returns (uint256) {\n    return 18;\n  }\n\n  /**\n   * @notice decreases the allowance of @param _spender by _subtractedValue\n   *\n   * @param _spender - address of the spender\n   * @param _subtractedValue - the value the allowance has to be decreased by\n   *\n   * @dev Requirement:\n   * Allowance cannot be lower than 0\n   *\n   * @return bool\n   */\n  function decreaseAllowance(address _spender, uint256 _subtractedValue)\n    external\n    preventReentry\n    returns (bool)\n  {\n    uint256 newAllowance = SafeMath.sub(_allowances[msg.sender][_spender], _subtractedValue);\n\n    require(newAllowance > 0, 'ElasticDAO: Allowance decrease less than 0');\n\n    _approve(msg.sender, _spender, newAllowance);\n    return true;\n  }\n\n  /**\n   * @notice increases the allowance of @param _spender by _addedValue\n   *\n   * @param _spender - address of the spender\n   * @param _addedValue - the value the allowance has to be increased by\n   *\n   * @return bool\n   */\n  function increaseAllowance(address _spender, uint256 _addedValue)\n    external\n    preventReentry\n    returns (bool)\n  {\n    _approve(msg.sender, _spender, SafeMath.add(_allowances[msg.sender][_spender], _addedValue));\n    return true;\n  }\n\n  /**\n   * @dev mints @param _amount tokens for @param _account\n   * @param _amount - the amount of tokens to be minted\n   * @param _account - the address of the account for whom the token have to be minted to\n   * @return bool\n   */\n  function mint(address _account, uint256 _amount)\n    external\n    onlyDAOorMinter\n    preventReentry\n    returns (bool)\n  {\n    _mint(_account, _amount);\n\n    return true;\n  }\n\n  /**\n   * @dev mints @param _amount of shares for @param _account\n   * @param _account address of the account\n   * @param _amount - the amount of shares to be minted\n   * @return bool\n   */\n  function mintShares(address _account, uint256 _amount)\n    external\n    override\n    onlyDAOorMinter\n    preventReentry\n    returns (bool)\n  {\n    _mintShares(_account, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   * @return string - name of the token\n   */\n  function name() external view returns (string memory) {\n    return _getToken().name;\n  }\n\n  /**\n   * @notice Returns the number of token holders of ElasticGovernanceToken\n   *\n   * @return uint256 numberOfTokenHolders\n   */\n  function numberOfTokenHolders() external view override returns (uint256) {\n    return _getToken().numberOfTokenHolders;\n  }\n\n  /**\n   * @notice sets the burner of the ElasticGovernanceToken\n   * a Burner is an address that can burn tokens(reduce the amount of tokens in circulation)\n   *\n   * @param _burner - the address of the burner\n   *\n   * @dev Requirement:\n   * - Address of the burner cannot be zero address\n   *\n   * @return bool\n   */\n  function setBurner(address _burner) external onlyDAO preventReentry returns (bool) {\n    require(_burner != address(0), 'ElasticDAO: Address Zero');\n\n    burner = _burner;\n\n    return true;\n  }\n\n  /**\n   * @notice sets the minter of the ElasticGovernanceToken\n   * a Minter is an address that can mint tokens(increase the amount of tokens in circulation)\n   *\n   * @param _minter - address of the minter\n   *\n   * @dev Requirement:\n   * - Address of the minter cannot be zero address\n   *\n   * @return bool\n   */\n  function setMinter(address _minter) external onlyDAO preventReentry returns (bool) {\n    require(_minter != address(0), 'ElasticDAO: Address Zero');\n\n    minter = _minter;\n\n    return true;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   *\n   * @return string - the symbol of the token\n   */\n  function symbol() external view returns (string memory) {\n    return _getToken().symbol;\n  }\n\n  /**\n   * @notice returns the totalSupply of tokens in the DAO\n   *\n   * @dev\n   * t - the total number of tokens in the DAO\n   * lambda - the total number of shares outstanding in the DAO currently\n   * m - current value of the share modifier\n   * k - constant\n   * t = ( lambda * m * k )\n   * Further math and documentaion of 't' can be found at ../libraries/ElasticMath.sol\n   *\n   * @return uint256 - the value of t\n   */\n  function totalSupply() external view override returns (uint256) {\n    Token.Instance memory token = _getToken();\n    return ElasticMath.t(token.lambda, token.k, token.m);\n  }\n\n  /**\n   * @notice Returns the current lambda value\n   *\n   * @return uint256 lambda\n   */\n  function totalSupplyInShares() external view override returns (uint256) {\n    Token.Instance memory token = _getToken();\n    return token.lambda;\n  }\n\n  /**\n   * @dev Moves @param _amount tokens from the caller's account to @param _to address\n   *\n   * Returns a boolean value indicating whether the operation succeeded\n   *\n   * Emits a {Transfer} event\n   * @return bool\n   */\n  function transfer(address _to, uint256 _amount) external override preventReentry returns (bool) {\n    _transfer(msg.sender, _to, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Moves @param _amount tokens from @param _from to @param _to using the\n   * allowance mechanism. @param _amount is then deducted from the caller's\n   * allowance\n   *\n   * Returns a boolean value indicating whether the operation succeeded\n   *\n   * Emits a {Transfer} event\n   * @return bool\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external override preventReentry returns (bool) {\n    require(msg.sender == _from || _amount <= _allowances[_from][msg.sender], 'ERC20: Bad Caller');\n\n    if (msg.sender != _from && _allowances[_from][msg.sender] != uint256(-1)) {\n      _allowances[_from][msg.sender] = SafeMath.sub(_allowances[_from][msg.sender], _amount);\n      emit Approval(msg.sender, _to, _allowances[_from][msg.sender]);\n    }\n\n    _transfer(_from, _to, _amount);\n    return true;\n  }\n\n  // Private\n\n  function _approve(\n    address _owner,\n    address _spender,\n    uint256 _amount\n  ) internal {\n    require(_owner != address(0), 'ERC20: approve from the zero address');\n    require(_spender != address(0), 'ERC20: approve to the zero address');\n\n    _allowances[_owner][_spender] = _amount;\n\n    emit Approval(_owner, _spender, _amount);\n  }\n\n  function _burn(address _account, uint256 _deltaT) internal {\n    Token.Instance memory token = _getToken();\n    uint256 deltaLambda = ElasticMath.lambdaFromT(_deltaT, token.k, token.m);\n    _burnShares(_account, deltaLambda);\n  }\n\n  function _burnShares(address _account, uint256 _deltaLambda) internal {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    Token tokenStorage = Token(ecosystem.tokenModelAddress);\n    Token.Instance memory token = tokenStorage.deserialize(address(this), ecosystem);\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\n    bool alreadyTokenHolder = tokenHolder.lambda > 0;\n\n    tokenHolder = _updateBalance(tokenHolder, false, _deltaLambda);\n\n    token.lambda = SafeMath.sub(token.lambda, _deltaLambda);\n    tokenStorage.serialize(token);\n\n    TokenHolder tokenHolderStorage = TokenHolder(ecosystem.tokenHolderModelAddress);\n    tokenHolderStorage.serialize(tokenHolder);\n    _updateNumberOfTokenHolders(alreadyTokenHolder, token, tokenHolder, tokenStorage);\n    emit Transfer(_account, address(0), _deltaLambda);\n  }\n\n  function _mint(address _account, uint256 _deltaT) internal {\n    Token.Instance memory token = _getToken();\n    uint256 deltaLambda = ElasticMath.lambdaFromT(_deltaT, token.k, token.m);\n    _mintShares(_account, deltaLambda);\n  }\n\n  function _mintShares(address _account, uint256 _deltaLambda) internal {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    Token tokenStorage = Token(ecosystem.tokenModelAddress);\n    Token.Instance memory token = tokenStorage.deserialize(address(this), ecosystem);\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\n    bool alreadyTokenHolder = tokenHolder.lambda > 0;\n\n    uint256 deltaT = ElasticMath.t(_deltaLambda, token.k, token.m);\n\n    tokenHolder = _updateBalance(tokenHolder, true, _deltaLambda);\n\n    token.lambda = SafeMath.add(token.lambda, _deltaLambda);\n    tokenStorage.serialize(token);\n\n    TokenHolder tokenHolderStorage = TokenHolder(ecosystem.tokenHolderModelAddress);\n    tokenHolderStorage.serialize(tokenHolder);\n    _updateNumberOfTokenHolders(alreadyTokenHolder, token, tokenHolder, tokenStorage);\n\n    emit Transfer(address(0), _account, deltaT);\n  }\n\n  function _transfer(\n    address _from,\n    address _to,\n    uint256 _deltaT\n  ) internal {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    Token tokenStorage = Token(ecosystem.tokenModelAddress);\n    Token.Instance memory token = tokenStorage.deserialize(address(this), ecosystem);\n\n    TokenHolder.Instance memory fromTokenHolder = _getTokenHolder(_from);\n    TokenHolder.Instance memory toTokenHolder = _getTokenHolder(_to);\n    bool fromAlreadyTokenHolder = fromTokenHolder.lambda > 0;\n    bool toAlreadyTokenHolder = toTokenHolder.lambda > 0;\n\n    uint256 deltaLambda = ElasticMath.lambdaFromT(_deltaT, token.k, token.m);\n    uint256 deltaT = ElasticMath.t(deltaLambda, token.k, token.m);\n\n    fromTokenHolder = _updateBalance(fromTokenHolder, false, deltaLambda);\n    toTokenHolder = _updateBalance(toTokenHolder, true, deltaLambda);\n\n    TokenHolder tokenHolderStorage = TokenHolder(ecosystem.tokenHolderModelAddress);\n    tokenHolderStorage.serialize(fromTokenHolder);\n    tokenHolderStorage.serialize(toTokenHolder);\n    _updateNumberOfTokenHolders(fromAlreadyTokenHolder, token, fromTokenHolder, tokenStorage);\n    _updateNumberOfTokenHolders(toAlreadyTokenHolder, token, toTokenHolder, tokenStorage);\n\n    emit Transfer(_from, _to, deltaT);\n  }\n\n  function _updateBalance(\n    TokenHolder.Instance memory _tokenHolder,\n    bool _isIncreasing,\n    uint256 _deltaLambda\n  ) internal pure returns (TokenHolder.Instance memory) {\n    if (_isIncreasing) {\n      _tokenHolder.lambda = SafeMath.add(_tokenHolder.lambda, _deltaLambda);\n    } else {\n      _tokenHolder.lambda = SafeMath.sub(_tokenHolder.lambda, _deltaLambda);\n    }\n\n    return _tokenHolder;\n  }\n\n  function _updateNumberOfTokenHolders(\n    bool alreadyTokenHolder,\n    Token.Instance memory token,\n    TokenHolder.Instance memory tokenHolder,\n    Token tokenStorage\n  ) internal {\n    if (tokenHolder.lambda > 0 && alreadyTokenHolder == false) {\n      tokenStorage.updateNumberOfTokenHolders(token, SafeMath.add(token.numberOfTokenHolders, 1));\n    }\n\n    if (tokenHolder.lambda == 0 && alreadyTokenHolder) {\n      tokenStorage.updateNumberOfTokenHolders(token, SafeMath.sub(token.numberOfTokenHolders, 1));\n    }\n  }\n\n  // Private Getters\n\n  function _getDAO() internal view returns (DAO.Instance memory) {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    return DAO(ecosystem.daoModelAddress).deserialize(daoAddress, ecosystem);\n  }\n\n  function _getEcosystem() internal view returns (Ecosystem.Instance memory) {\n    return Ecosystem(ecosystemModelAddress).deserialize(daoAddress);\n  }\n\n  function _getTokenHolder(address _account) internal view returns (TokenHolder.Instance memory) {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    return\n      TokenHolder(ecosystem.tokenHolderModelAddress).deserialize(\n        _account,\n        ecosystem,\n        Token(ecosystem.tokenModelAddress).deserialize(address(this), ecosystem)\n      );\n  }\n\n  function _getToken() internal view returns (Token.Instance memory) {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    return Token(ecosystem.tokenModelAddress).deserialize(address(this), ecosystem);\n  }\n}\n\n\n",
        "CodeNames": [
            "ElasticGovernanceToken.sol",
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_H-06",
                "Location": [
                    "transferFrom",
                    "Approval(from, msg.sender, _allowances[_from][msg.sender])",
                    "Approval(msg.sender, _to, _allowances[_from][msg.sender])",
                    "emitApproval"
                ],
                "Type": " Incorrect event parameters in transferFrom function",
                "Description": " The emitApproval event should occur when the msg.sender is not equal to _from. The event should be emit Approval(from, msg.sender, _allowances[_from][msg.sender]); instead of emit Approval(msg.sender, _to, _allowances[_from][msg.sender]). This error may negatively impact off-chain tools that are monitoring critical transfer events of the governance token.   ElasticDAO: Confirmed and resolved in PR #77   ",
                "Repair": ""
            },
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_M-02",
                "Location": [
                    "timeupdateNumberOfTokenHolders",
                    "updateNumberOfTokenHolders",
                    "numberOfTokenHolders"
                ],
                "Type": " Anyone can update the number of token holders",
                "Description": "The updateNumberOfTokenHolders function in the ElasticGovernanceToken.sol doesnot verify the caller. Anyone could call this function and set the value to 0 . While this does notput funds at risk, an attacker could set the value of numberOfTokenHolders to MAX_UINT ,resulting in an overflow and a reverted transaction the next timeupdateNumberOfTokenHolders is called to to increment this number.ElasticDAO: Confirmed and resolved in PR #53",
                "Repair": ""
            },
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_M-06",
                "Location": [
                    "theincreaseAllowance",
                    "decreaseAllowance",
                    "approve()",
                    "theapprove()"
                ],
                "Type": " Double-spend allowance",
                "Description": "A malicious attacker can execute a double-spend attack on an allowance by front-running theexecution of an approve() function that alters the state of a balance. Since theincreaseAllowance and decreaseAllowance functions provide the same functionality, theapprove() function is an unnecessary attack vector that can present significant risk.ElasticDAO: This issue is present in most ERC20 tokens and very few choose to take therecommended mitigation step. We've chosen to go with expected behaviour instead ofremoving a function that is part of the spec.\u201d",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport '../interfaces/IElasticToken.sol';\n\nimport '../libraries/SafeMath.sol';\nimport '../libraries/ElasticMath.sol';\n\nimport '../core/ElasticDAO.sol';\nimport '../models/DAO.sol';\nimport '../models/Ecosystem.sol';\nimport '../models/Token.sol';\nimport '../models/TokenHolder.sol';\n\nimport '../services/ReentryProtection.sol';\n\n/**\n * @dev ElasticGovernanceToken contract outlines and defines all the functionality\n * of an ElasticGovernanceToken and also serves as it's storage\n */\ncontract ElasticGovernanceToken is IElasticToken, ReentryProtection {\n  address public burner;\n  address public daoAddress;\n  address public ecosystemModelAddress;\n  address public minter;\n  bool public initialized;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  modifier onlyDAO() {\n    require(msg.sender == daoAddress || msg.sender == minter, 'ElasticDAO: Not authorized');\n    _;\n  }\n\n  modifier onlyDAOorBurner() {\n    require(msg.sender == daoAddress || msg.sender == burner, 'ElasticDAO: Not authorized');\n    _;\n  }\n\n  modifier onlyDAOorMinter() {\n    require(msg.sender == daoAddress || msg.sender == minter, 'ElasticDAO: Not authorized');\n    _;\n  }\n\n  /**\n   * @notice initializes the ElasticGovernanceToken\n   *\n   * @param _burner - the address which can burn tokens\n   * @param _daoAddress - the address of the deployed ElasticDAO\n   * @param _ecosystemModelAddress - the address of the ecosystem model\n   * @param _minter - the address which can mint tokens\n   *\n   * @dev Requirements:\n   * - The token should not already be initialized\n   * - The address of the burner cannot be zero\n   * - The address of the deployed ElasticDAO cannot be zero\n   * - The address of the ecosystemModelAddress cannot be zero\n   * - The address of the minter cannot be zero\n   *\n   * @return bool\n   */\n  function initialize(\n    address _burner,\n    address _daoAddress,\n    address _ecosystemModelAddress,\n    address _minter\n  ) external preventReentry returns (bool) {\n    require(initialized == false, 'ElasticDAO: Already initialized');\n    require(_burner != address(0), 'ElasticDAO: Address Zero');\n    require(_daoAddress != address(0), 'ElasticDAO: Address Zero');\n    require(_ecosystemModelAddress != address(0), 'ElasticDAO: Address Zero');\n    require(_minter != address(0), 'ElasticDAO: Address Zero');\n\n    initialized = true;\n    burner = _burner;\n    daoAddress = _daoAddress;\n    ecosystemModelAddress = _ecosystemModelAddress;\n    minter = _minter;\n\n    return true;\n  }\n\n  /**\n   * @notice Returns the remaining number of tokens that @param _spender will be\n   * allowed to spend on behalf of @param _owner through {transferFrom}. This is\n   * zero by default\n   *\n   * @param _spender - the address of the spender\n   * @param _owner - the address of the owner\n   *\n   * @dev This value changes when {approve} or {transferFrom} are called\n   *\n   * @return uint256\n   */\n  function allowance(address _owner, address _spender) external view override returns (uint256) {\n    return _allowances[_owner][_spender];\n  }\n\n  /**\n   * @notice Sets @param _amount as the allowance of @param _spender over the caller's tokens\n   *\n   * @param _spender - the address of the spender\n   *\n   * @dev\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * @dev Emits an {Approval} event\n   *\n   * @return bool\n   */\n  function approve(address _spender, uint256 _amount)\n    external\n    override\n    preventReentry\n    returns (bool)\n  {\n    _approve(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  /**\n   * @notice Returns the amount of tokens owned by @param _account using ElasticMath\n   *\n   * @param _account - address of the account\n   *\n   * @dev the number of tokens is given by:\n   * t = lambda * m * k\n   *\n   * t - number of tokens\n   * m - lambda modifier - it's value increases every time someone joins the DAO\n   * k - constant token multiplier - it increases the number of tokens\n   *  that each member of the DAO has with respect to their lambda\n   *\n   * Further math and documentaion of 't' can be found at ../libraries/ElasticMath.sol\n   *\n   * @return uint256\n   */\n  function balanceOf(address _account) external view override returns (uint256) {\n    Token.Instance memory token = _getToken();\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\n    uint256 t = ElasticMath.t(tokenHolder.lambda, token.k, token.m);\n\n    return t;\n  }\n\n  /**\n   * @notice Returns the amount of shares ( lambda ) owned by _account.\n   *\n   * @param _account - address of the account\n   *\n   * @return lambda uint256 - lambda is the number of shares\n   */\n  function balanceOfInShares(address _account) external view override returns (uint256) {\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\n    return tokenHolder.lambda;\n  }\n\n  /**\n   * @notice Returns the amount of tokens @param _account can vote with, using ElasticMath\n   *\n   * @param _account - the address of the account\n   *\n   * @dev checks if @param _account has more or less lambda than maxVotingLambda,\n   * based on which number of tokens (t) @param _account can vote with is calculated.\n   * Further math and documentaion of 't' can be found at ../libraries/ElasticMath.sol\n   *\n   * @return balance uint256 numberOfTokens (t)\n   */\n  function balanceOfVoting(address _account) external view returns (uint256 balance) {\n    Token.Instance memory token = _getToken();\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\n    uint256 maxVotingLambda = _getDAO().maxVotingLambda;\n\n    if (tokenHolder.lambda > maxVotingLambda) {\n      return ElasticMath.t(maxVotingLambda, token.k, token.m);\n    } else {\n      return ElasticMath.t(tokenHolder.lambda, token.k, token.m);\n    }\n  }\n\n  /**\n   * @notice Reduces the balance(tokens) of @param _account by  _amount\n   *\n   * @param _account address of the account\n   *\n   * @param _amount - the amount by which the number of tokens is to be reduced\n   *\n   * @return bool\n   */\n  function burn(address _account, uint256 _amount)\n    external\n    override\n    onlyDAOorBurner\n    preventReentry\n    returns (bool)\n  {\n    _burn(_account, _amount);\n    return true;\n  }\n\n  /**\n   * @notice Reduces the balance(lambda) of @param _account by  _amount\n   *\n   * @param _account - address of the account\n   *\n   * @param _amount - the amount by which the number of shares has to be reduced\n   *\n   * @return bool\n   */\n  function burnShares(address _account, uint256 _amount)\n    external\n    override\n    onlyDAOorBurner\n    preventReentry\n    returns (bool)\n  {\n    _burnShares(_account, _amount);\n    return true;\n  }\n\n  /**\n   * @notice returns the number of decimals\n   *\n   * @return 18\n   */\n  function decimals() external pure returns (uint256) {\n    return 18;\n  }\n\n  /**\n   * @notice decreases the allowance of @param _spender by _subtractedValue\n   *\n   * @param _spender - address of the spender\n   * @param _subtractedValue - the value the allowance has to be decreased by\n   *\n   * @dev Requirement:\n   * Allowance cannot be lower than 0\n   *\n   * @return bool\n   */\n  function decreaseAllowance(address _spender, uint256 _subtractedValue)\n    external\n    preventReentry\n    returns (bool)\n  {\n    uint256 newAllowance = SafeMath.sub(_allowances[msg.sender][_spender], _subtractedValue);\n\n    require(newAllowance > 0, 'ElasticDAO: Allowance decrease less than 0');\n\n    _approve(msg.sender, _spender, newAllowance);\n    return true;\n  }\n\n  /**\n   * @notice increases the allowance of @param _spender by _addedValue\n   *\n   * @param _spender - address of the spender\n   * @param _addedValue - the value the allowance has to be increased by\n   *\n   * @return bool\n   */\n  function increaseAllowance(address _spender, uint256 _addedValue)\n    external\n    preventReentry\n    returns (bool)\n  {\n    _approve(msg.sender, _spender, SafeMath.add(_allowances[msg.sender][_spender], _addedValue));\n    return true;\n  }\n\n  /**\n   * @dev mints @param _amount tokens for @param _account\n   * @param _amount - the amount of tokens to be minted\n   * @param _account - the address of the account for whom the token have to be minted to\n   * @return bool\n   */\n  function mint(address _account, uint256 _amount)\n    external\n    onlyDAOorMinter\n    preventReentry\n    returns (bool)\n  {\n    _mint(_account, _amount);\n\n    return true;\n  }\n\n  /**\n   * @dev mints @param _amount of shares for @param _account\n   * @param _account address of the account\n   * @param _amount - the amount of shares to be minted\n   * @return bool\n   */\n  function mintShares(address _account, uint256 _amount)\n    external\n    override\n    onlyDAOorMinter\n    preventReentry\n    returns (bool)\n  {\n    _mintShares(_account, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   * @return string - name of the token\n   */\n  function name() external view returns (string memory) {\n    return _getToken().name;\n  }\n\n  /**\n   * @notice Returns the number of token holders of ElasticGovernanceToken\n   *\n   * @return uint256 numberOfTokenHolders\n   */\n  function numberOfTokenHolders() external view override returns (uint256) {\n    return _getToken().numberOfTokenHolders;\n  }\n\n  /**\n   * @notice sets the burner of the ElasticGovernanceToken\n   * a Burner is an address that can burn tokens(reduce the amount of tokens in circulation)\n   *\n   * @param _burner - the address of the burner\n   *\n   * @dev Requirement:\n   * - Address of the burner cannot be zero address\n   *\n   * @return bool\n   */\n  function setBurner(address _burner) external onlyDAO preventReentry returns (bool) {\n    require(_burner != address(0), 'ElasticDAO: Address Zero');\n\n    burner = _burner;\n\n    return true;\n  }\n\n  /**\n   * @notice sets the minter of the ElasticGovernanceToken\n   * a Minter is an address that can mint tokens(increase the amount of tokens in circulation)\n   *\n   * @param _minter - address of the minter\n   *\n   * @dev Requirement:\n   * - Address of the minter cannot be zero address\n   *\n   * @return bool\n   */\n  function setMinter(address _minter) external onlyDAO preventReentry returns (bool) {\n    require(_minter != address(0), 'ElasticDAO: Address Zero');\n\n    minter = _minter;\n\n    return true;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   *\n   * @return string - the symbol of the token\n   */\n  function symbol() external view returns (string memory) {\n    return _getToken().symbol;\n  }\n\n  /**\n   * @notice returns the totalSupply of tokens in the DAO\n   *\n   * @dev\n   * t - the total number of tokens in the DAO\n   * lambda - the total number of shares outstanding in the DAO currently\n   * m - current value of the share modifier\n   * k - constant\n   * t = ( lambda * m * k )\n   * Further math and documentaion of 't' can be found at ../libraries/ElasticMath.sol\n   *\n   * @return uint256 - the value of t\n   */\n  function totalSupply() external view override returns (uint256) {\n    Token.Instance memory token = _getToken();\n    return ElasticMath.t(token.lambda, token.k, token.m);\n  }\n\n  /**\n   * @notice Returns the current lambda value\n   *\n   * @return uint256 lambda\n   */\n  function totalSupplyInShares() external view override returns (uint256) {\n    Token.Instance memory token = _getToken();\n    return token.lambda;\n  }\n\n  /**\n   * @dev Moves @param _amount tokens from the caller's account to @param _to address\n   *\n   * Returns a boolean value indicating whether the operation succeeded\n   *\n   * Emits a {Transfer} event\n   * @return bool\n   */\n  function transfer(address _to, uint256 _amount) external override preventReentry returns (bool) {\n    _transfer(msg.sender, _to, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Moves @param _amount tokens from @param _from to @param _to using the\n   * allowance mechanism. @param _amount is then deducted from the caller's\n   * allowance\n   *\n   * Returns a boolean value indicating whether the operation succeeded\n   *\n   * Emits a {Transfer} event\n   * @return bool\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external override preventReentry returns (bool) {\n    require(msg.sender == _from || _amount <= _allowances[_from][msg.sender], 'ERC20: Bad Caller');\n\n    if (msg.sender != _from && _allowances[_from][msg.sender] != uint256(-1)) {\n      _allowances[_from][msg.sender] = SafeMath.sub(_allowances[_from][msg.sender], _amount);\n      emit Approval(msg.sender, _to, _allowances[_from][msg.sender]);\n    }\n\n    _transfer(_from, _to, _amount);\n    return true;\n  }\n\n  // Private\n\n  function _approve(\n    address _owner,\n    address _spender,\n    uint256 _amount\n  ) internal {\n    require(_owner != address(0), 'ERC20: approve from the zero address');\n    require(_spender != address(0), 'ERC20: approve to the zero address');\n\n    _allowances[_owner][_spender] = _amount;\n\n    emit Approval(_owner, _spender, _amount);\n  }\n\n  function _burn(address _account, uint256 _deltaT) internal {\n    Token.Instance memory token = _getToken();\n    uint256 deltaLambda = ElasticMath.lambdaFromT(_deltaT, token.k, token.m);\n    _burnShares(_account, deltaLambda);\n  }\n\n  function _burnShares(address _account, uint256 _deltaLambda) internal {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    Token tokenStorage = Token(ecosystem.tokenModelAddress);\n    Token.Instance memory token = tokenStorage.deserialize(address(this), ecosystem);\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\n    bool alreadyTokenHolder = tokenHolder.lambda > 0;\n\n    tokenHolder = _updateBalance(tokenHolder, false, _deltaLambda);\n\n    token.lambda = SafeMath.sub(token.lambda, _deltaLambda);\n    tokenStorage.serialize(token);\n\n    TokenHolder tokenHolderStorage = TokenHolder(ecosystem.tokenHolderModelAddress);\n    tokenHolderStorage.serialize(tokenHolder);\n    _updateNumberOfTokenHolders(alreadyTokenHolder, token, tokenHolder, tokenStorage);\n    emit Transfer(_account, address(0), _deltaLambda);\n  }\n\n  function _mint(address _account, uint256 _deltaT) internal {\n    Token.Instance memory token = _getToken();\n    uint256 deltaLambda = ElasticMath.lambdaFromT(_deltaT, token.k, token.m);\n    _mintShares(_account, deltaLambda);\n  }\n\n  function _mintShares(address _account, uint256 _deltaLambda) internal {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    Token tokenStorage = Token(ecosystem.tokenModelAddress);\n    Token.Instance memory token = tokenStorage.deserialize(address(this), ecosystem);\n    TokenHolder.Instance memory tokenHolder = _getTokenHolder(_account);\n    bool alreadyTokenHolder = tokenHolder.lambda > 0;\n\n    uint256 deltaT = ElasticMath.t(_deltaLambda, token.k, token.m);\n\n    tokenHolder = _updateBalance(tokenHolder, true, _deltaLambda);\n\n    token.lambda = SafeMath.add(token.lambda, _deltaLambda);\n    tokenStorage.serialize(token);\n\n    TokenHolder tokenHolderStorage = TokenHolder(ecosystem.tokenHolderModelAddress);\n    tokenHolderStorage.serialize(tokenHolder);\n    _updateNumberOfTokenHolders(alreadyTokenHolder, token, tokenHolder, tokenStorage);\n\n    emit Transfer(address(0), _account, deltaT);\n  }\n\n  function _transfer(\n    address _from,\n    address _to,\n    uint256 _deltaT\n  ) internal {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    Token tokenStorage = Token(ecosystem.tokenModelAddress);\n    Token.Instance memory token = tokenStorage.deserialize(address(this), ecosystem);\n\n    TokenHolder.Instance memory fromTokenHolder = _getTokenHolder(_from);\n    TokenHolder.Instance memory toTokenHolder = _getTokenHolder(_to);\n    bool fromAlreadyTokenHolder = fromTokenHolder.lambda > 0;\n    bool toAlreadyTokenHolder = toTokenHolder.lambda > 0;\n\n    uint256 deltaLambda = ElasticMath.lambdaFromT(_deltaT, token.k, token.m);\n    uint256 deltaT = ElasticMath.t(deltaLambda, token.k, token.m);\n\n    fromTokenHolder = _updateBalance(fromTokenHolder, false, deltaLambda);\n    toTokenHolder = _updateBalance(toTokenHolder, true, deltaLambda);\n\n    TokenHolder tokenHolderStorage = TokenHolder(ecosystem.tokenHolderModelAddress);\n    tokenHolderStorage.serialize(fromTokenHolder);\n    tokenHolderStorage.serialize(toTokenHolder);\n    _updateNumberOfTokenHolders(fromAlreadyTokenHolder, token, fromTokenHolder, tokenStorage);\n    _updateNumberOfTokenHolders(toAlreadyTokenHolder, token, toTokenHolder, tokenStorage);\n\n    emit Transfer(_from, _to, deltaT);\n  }\n\n  function _updateBalance(\n    TokenHolder.Instance memory _tokenHolder,\n    bool _isIncreasing,\n    uint256 _deltaLambda\n  ) internal pure returns (TokenHolder.Instance memory) {\n    if (_isIncreasing) {\n      _tokenHolder.lambda = SafeMath.add(_tokenHolder.lambda, _deltaLambda);\n    } else {\n      _tokenHolder.lambda = SafeMath.sub(_tokenHolder.lambda, _deltaLambda);\n    }\n\n    return _tokenHolder;\n  }\n\n  function _updateNumberOfTokenHolders(\n    bool alreadyTokenHolder,\n    Token.Instance memory token,\n    TokenHolder.Instance memory tokenHolder,\n    Token tokenStorage\n  ) internal {\n    if (tokenHolder.lambda > 0 && alreadyTokenHolder == false) {\n      tokenStorage.updateNumberOfTokenHolders(token, SafeMath.add(token.numberOfTokenHolders, 1));\n    }\n\n    if (tokenHolder.lambda == 0 && alreadyTokenHolder) {\n      tokenStorage.updateNumberOfTokenHolders(token, SafeMath.sub(token.numberOfTokenHolders, 1));\n    }\n  }\n\n  // Private Getters\n\n  function _getDAO() internal view returns (DAO.Instance memory) {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    return DAO(ecosystem.daoModelAddress).deserialize(daoAddress, ecosystem);\n  }\n\n  function _getEcosystem() internal view returns (Ecosystem.Instance memory) {\n    return Ecosystem(ecosystemModelAddress).deserialize(daoAddress);\n  }\n\n  function _getTokenHolder(address _account) internal view returns (TokenHolder.Instance memory) {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    return\n      TokenHolder(ecosystem.tokenHolderModelAddress).deserialize(\n        _account,\n        ecosystem,\n        Token(ecosystem.tokenModelAddress).deserialize(address(this), ecosystem)\n      );\n  }\n\n  function _getToken() internal view returns (Token.Instance memory) {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    return Token(ecosystem.tokenModelAddress).deserialize(address(this), ecosystem);\n  }\n}\n\n\n// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport './Ecosystem.sol';\nimport './EternalModel.sol';\nimport '../libraries/SafeMath.sol';\nimport '../services/ReentryProtection.sol';\n\n/**\n * @author ElasticDAO - https://ElasticDAO.org\n * @notice This contract is used for storing core DAO data\n * @dev ElasticDAO network contracts can read/write from this contract\n */\ncontract DAO is EternalModel, ReentryProtection {\n  struct Instance {\n    address uuid;\n    address[] summoners;\n    bool summoned;\n    string name;\n    uint256 maxVotingLambda;\n    uint256 numberOfSummoners;\n    Ecosystem.Instance ecosystem;\n  }\n\n  event Serialized(address indexed uuid);\n\n  /**\n   * @dev deserializes Instance struct\n   * @param _uuid - address of the unique user ID\n   * @return record Instance\n   */\n  function deserialize(address _uuid, Ecosystem.Instance memory _ecosystem)\n    external\n    view\n    returns (Instance memory record)\n  {\n    record.uuid = _uuid;\n    record.ecosystem = _ecosystem;\n\n    if (_exists(_uuid)) {\n      record.maxVotingLambda = getUint(keccak256(abi.encode(_uuid, 'maxVotingLambda')));\n      record.name = getString(keccak256(abi.encode(_uuid, 'name')));\n      record.numberOfSummoners = getUint(keccak256(abi.encode(_uuid, 'numberOfSummoners')));\n      record.summoned = getBool(keccak256(abi.encode(_uuid, 'summoned')));\n    }\n\n    return record;\n  }\n\n  /**\n   * @dev checks if @param _uuid exists\n   * @param _uuid - address of the unique user ID\n   * @return recordExists bool\n   */\n  function exists(address _uuid, Ecosystem.Instance memory) external view returns (bool) {\n    return _exists(_uuid);\n  }\n\n  function getSummoner(Instance memory _dao, uint256 _index) external view returns (address) {\n    return getAddress(keccak256(abi.encode(_dao.uuid, 'summoners', _index)));\n  }\n\n  /**\n   * @dev checks if @param _uuid where _uuid is msg.sender - is a Summoner\n   * @param _dao DAO.Instance\n   * @param _summonerAddress address\n   * @return bool\n   */\n  function isSummoner(Instance memory _dao, address _summonerAddress) external view returns (bool) {\n    return getBool(keccak256(abi.encode(_dao.uuid, 'summoner', _summonerAddress)));\n  }\n\n  /**\n   * @dev serializes Instance struct\n   * @param _record Instance\n   */\n  function serialize(Instance memory _record) external preventReentry {\n    require(\n      msg.sender == _record.uuid || msg.sender == _record.ecosystem.configuratorAddress,\n      'ElasticDAO: Unauthorized'\n    );\n\n    setUint(keccak256(abi.encode(_record.uuid, 'maxVotingLambda')), _record.maxVotingLambda);\n    setString(keccak256(abi.encode(_record.uuid, 'name')), _record.name);\n    setBool(keccak256(abi.encode(_record.uuid, 'summoned')), _record.summoned);\n\n    if (_record.summoners.length > 0) {\n      _record.numberOfSummoners = _record.summoners.length;\n      setUint(keccak256(abi.encode(_record.uuid, 'numberOfSummoners')), _record.numberOfSummoners);\n      for (uint256 i = 0; i < _record.numberOfSummoners; i += 1) {\n        setBool(keccak256(abi.encode(_record.uuid, 'summoner', _record.summoners[i])), true);\n        setAddress(keccak256(abi.encode(_record.uuid, 'summoners', i)), _record.summoners[i]);\n      }\n    }\n\n    setBool(keccak256(abi.encode(_record.uuid, 'exists')), true);\n\n    emit Serialized(_record.uuid);\n  }\n\n  function _exists(address _uuid) internal view returns (bool) {\n    return getBool(keccak256(abi.encode(_uuid, 'exists')));\n  }\n}\n\n\n",
        "CodeNames": [
            "ElasticGovernanceToken.sol",
            "DAO.sol",
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_H-07",
                "Location": [
                    "onlyDAO"
                ],
                "Type": " Minter can call functions reserved for DAO addresses",
                "Description": " In ElasticGovernanceToken.sol , the onlyDAO modifier is meant to only allow a DAO address to call functions like setBurner` and setMinter`. However, as currently written, this modifier allows the msg.sender to either be a DAO address or the minter address.   ElasticDAO: Confirmed and resolved in PR #54    code423n4.com  https://github.com/elasticdao/contracts/pull/43 https://github.com/elasticdao/contracts/pull/43 https://github.com/elasticdao/contracts/pull/59 https://github.com/elasticdao/contracts/pull/77 https://github.com/elasticdao/contracts/pull/54 https://code423n4.com/      ",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport './ElasticDAO.sol';\n\nimport '../models/Ecosystem.sol';\nimport '../services/ReentryProtection.sol';\n\nimport '@pie-dao/proxy/contracts/PProxy.sol';\n\n/**\n * @dev The factory contract for ElasticDAO\n * Deploys ElasticDAO's and also sets all the required parameters and permissions,\n * Collects a fee which is later used by ELasticDAO for further development of the project.\n */\ncontract ElasticDAOFactory is ReentryProtection {\n  address public ecosystemModelAddress;\n  address public elasticDAOImplementationAddress;\n  address public manager;\n  address payable feeAddress;\n  address[] public deployedDAOAddresses;\n  uint256 public deployedDAOCount;\n  uint256 public fee;\n  bool public initialized = false;\n\n  event DeployedDAO(address indexed daoAddress);\n  event ElasticDAOImplementationAddressUpdated(address indexed elasticDAOImplementationAddress);\n  event FeeAddressUpdated(address indexed feeReceiver);\n  event FeesCollected(address indexed feeAddress, uint256 amount);\n  event FeeUpdated(uint256 amount);\n  event ManagerUpdated(address indexed newManager);\n\n  modifier onlyManager() {\n    require(manager == msg.sender, 'ElasticDAO: Only manager');\n    _;\n  }\n\n  /**\n   * @notice Initializes the ElasticDAO factory\n   *\n   * @param _ecosystemModelAddress - the address of the ecosystem model\n   * @dev\n   * Requirements:\n   * - The factory cannot already be initialized\n   * - The ecosystem model address cannot be the zero address\n   */\n  function initialize(address _ecosystemModelAddress, address _elasticDAOImplementationAddress)\n    external\n    preventReentry\n  {\n    require(initialized == false, 'ElasticDAO: Factory already initialized');\n    require(\n      _ecosystemModelAddress != address(0) && _elasticDAOImplementationAddress != address(0),\n      'ElasticDAO: Address Zero'\n    );\n\n    deployedDAOCount = 0;\n    ecosystemModelAddress = _ecosystemModelAddress;\n    elasticDAOImplementationAddress = _elasticDAOImplementationAddress;\n    fee = 250000000000000000;\n    initialized = true;\n    manager = msg.sender;\n  }\n\n  /**\n   * @notice collects the fees sent to this contract\n   *\n   * @dev emits FeesCollected event\n   * Requirement:\n   * - The fee collection transaction should be successful\n   */\n  function collectFees() external preventReentry {\n    uint256 amount = address(this).balance;\n\n    (bool success, ) = feeAddress.call{ value: amount }('');\n    require(success, 'ElasticDAO: TransactionFailed');\n    emit FeesCollected(address(feeAddress), amount);\n  }\n\n  /**\n   * @notice deploys DAO and initializes token and stores the address of the deployed DAO\n   *\n   * @param _summoners - an array containing address of summoners\n   * @param _nameOfDAO - the name of the DAO\n   * @param _nameOfToken - the name of the token\n   * @param _eByL-the amount of lambda a summoner gets(per ETH) during the seeding phase of the DAO\n   * @param _elasticity-the value by which the cost of entering the  DAO increases ( on every join )\n   * @param _k - is the constant token multiplier,\n   * it increases the number of tokens that each member of the DAO has with respect to their lambda\n   * @param _maxLambdaPurchase - is the maximum amount of lambda that can be purchased per wallet\n   * @param _maxVotingLambda - is the maximum amount of lambda that can be used to vote\n   *\n   * @dev emits DeployedDAO event\n   * @dev\n   * Requirement:\n   * - The fee required should be sent in the call to the function\n   */\n  function deployDAOAndToken(\n    address[] memory _summoners,\n    string memory _nameOfDAO,\n    string memory _nameOfToken,\n    string memory _symbol,\n    uint256 _eByL,\n    uint256 _elasticity,\n    uint256 _k,\n    uint256 _maxLambdaPurchase,\n    uint256 _maxVotingLambda\n  ) external payable preventReentry {\n    require(fee == msg.value, 'ElasticDAO: A fee is required to deploy a DAO');\n\n    // Deploy the DAO behind PProxy\n    PProxy proxy = new PProxy();\n    proxy.setImplementation(elasticDAOImplementationAddress);\n    proxy.setProxyOwner(msg.sender);\n\n    address payable daoAddress = address(proxy);\n\n    // initialize the DAO\n    ElasticDAO(daoAddress).initialize(\n      ecosystemModelAddress,\n      msg.sender,\n      _summoners,\n      _nameOfDAO,\n      _maxVotingLambda\n    );\n\n    deployedDAOAddresses.push(daoAddress);\n    deployedDAOCount = SafeMath.add(deployedDAOCount, 1);\n\n    // initialize the token\n    ElasticDAO(daoAddress).initializeToken(\n      _nameOfToken,\n      _symbol,\n      _eByL,\n      _elasticity,\n      _k,\n      _maxLambdaPurchase\n    );\n    emit DeployedDAO(daoAddress);\n  }\n\n  /**\n   * @notice updates the address of the elasticDAO implementation\n   * @param _elasticDAOImplementationAddress - the new address\n   * @dev emits ElasticDAOImplementationAddressUpdated event\n   * @dev Requirement:\n   * - The elasticDAO implementation address cannot be zero address\n   */\n  function updateElasticDAOImplementationAddress(address _elasticDAOImplementationAddress)\n    external\n    onlyManager\n    preventReentry\n  {\n    require(_elasticDAOImplementationAddress != address(0), 'ElasticDAO: Address Zero');\n\n    elasticDAOImplementationAddress = _elasticDAOImplementationAddress;\n    emit ElasticDAOImplementationAddressUpdated(_elasticDAOImplementationAddress);\n  }\n\n  /**\n   * @notice updates the fee required to deploy a DAQ\n   *\n   * @param _amount - the new amount of the fees\n   *\n   * @dev emits FeeUpdated event\n   */\n  function updateFee(uint256 _amount) external onlyManager preventReentry {\n    fee = _amount;\n    emit FeeUpdated(fee);\n  }\n\n  /**\n   * @notice updates the address of the fee reciever\n   *\n   * @param _feeReceiver - the new address of the fee reciever\n   *\n   * @dev emits FeeUpdated event\n   * @dev\n   * Requirement:\n   * - The fee receiver address cannot be zero address\n   */\n  function updateFeeAddress(address _feeReceiver) external onlyManager preventReentry {\n    require(_feeReceiver != address(0), 'ElasticDAO: Address Zero');\n\n    feeAddress = payable(_feeReceiver);\n    emit FeeAddressUpdated(_feeReceiver);\n  }\n\n  /**\n   * @notice updates the manager address\n   *\n   * @param _newManager - the address of the new manager\n   *\n   * @dev Requirement\n   * - Address of the manager cannot be zero\n   * @dev emits ManagerUpdated event\n   */\n  function updateManager(address _newManager) external onlyManager preventReentry {\n    require(_newManager != address(0), 'ElasticDAO: Address Zero');\n\n    manager = _newManager;\n    emit ManagerUpdated(manager);\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {}\n}\n\n\n",
        "CodeNames": [
            "ElasticDAOFactory.sol",
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_M-01",
                "Location": [
                    "callcollectFees",
                    "feeAddress",
                    "collectFees"
                ],
                "Type": " No check to prevent fee burning",
                "Description": "The collectFees function sends fees to a feeAddress in storage, however, there is currentlyno check to validate whether or not feeAddress has been initialized. An attacker can callcollectFees to send the fees to the zero address, making recovery impossible. This attackcould be used against new DAOs to burn their main revenue besides the token market.ElasticDAO: Confirmed and resolved in PR #42",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "",
        "CodeNames": [
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_M-03",
                "Location": [],
                "Type": " The initialize function does not check for non-zero values",
                "Description": "The initialize function does not check if the summoners are all non-zero addresses. If allthe initialized summoners happen to be 0, the contract will have to be redeployed.ElasticDAO: Confirmed and resolved in PR #78",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPLv3\npragma solidity 0.7.2;\npragma experimental ABIEncoderV2;\n\nimport '../libraries/ElasticMath.sol';\nimport '../libraries/SafeMath.sol';\n\nimport '../models/DAO.sol';\nimport '../models/Ecosystem.sol';\nimport '../models/Token.sol';\n\nimport '../services/Configurator.sol';\nimport '../services/ReentryProtection.sol';\n\nimport '@pie-dao/proxy/contracts/PProxy.sol';\n\n/**\n * @dev The ElasticDAO contract outlines and defines all the functionality\n * such as initialize, Join, exit, etc for an elasticDAO.\n *\n * It also serves as the vault for ElasticDAO.\n */\ncontract ElasticDAO is ReentryProtection {\n  address public deployer;\n  address public ecosystemModelAddress;\n  address public controller;\n  address[] public summoners;\n  bool public initialized;\n\n  event ElasticGovernanceTokenDeployed(address indexed tokenAddress);\n  event MaxVotingLambdaChanged(address indexed daoAddress, bytes32 settingName, uint256 value);\n  event ControllerChanged(address indexed daoAddress, bytes32 settingName, address value);\n  event ExitDAO(\n    address indexed daoAddress,\n    address indexed memberAddress,\n    uint256 shareAmount,\n    uint256 ethAmount\n  );\n  event JoinDAO(\n    address indexed daoAddress,\n    address indexed memberAddress,\n    uint256 shareAmount,\n    uint256 ethAmount\n  );\n  event SeedDAO(address indexed daoAddress, address indexed summonerAddress, uint256 amount);\n  event SummonedDAO(address indexed daoAddress, address indexed summonedBy);\n\n  modifier onlyAfterSummoning() {\n    DAO.Instance memory dao = _getDAO();\n    require(dao.summoned, 'ElasticDAO: DAO must be summoned');\n    _;\n  }\n  modifier onlyAfterTokenInitialized() {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    bool tokenInitialized =\n      Token(_getEcosystem().tokenModelAddress).exists(ecosystem.governanceTokenAddress, ecosystem);\n    require(tokenInitialized, 'ElasticDAO: Please call initializeToken first');\n    _;\n  }\n  modifier onlyBeforeSummoning() {\n    DAO.Instance memory dao = _getDAO();\n    require(dao.summoned == false, 'ElasticDAO: DAO must not be summoned');\n    _;\n  }\n  modifier onlyController() {\n    require(msg.sender == controller, 'ElasticDAO: Only controller');\n    _;\n  }\n  modifier onlyDeployer() {\n    require(msg.sender == deployer, 'ElasticDAO: Only deployer');\n    _;\n  }\n  modifier onlySummoners() {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    DAO daoContract = DAO(ecosystem.daoModelAddress);\n    DAO.Instance memory dao = daoContract.deserialize(address(this), ecosystem);\n    bool summonerCheck = daoContract.isSummoner(dao, msg.sender);\n\n    require(summonerCheck, 'ElasticDAO: Only summoners');\n    _;\n  }\n  modifier onlyWhenOpen() {\n    require(address(this).balance > 0, 'ElasticDAO: This DAO is closed');\n    _;\n  }\n\n  /**\n   * @notice Initializes and builds the ElasticDAO struct by passing and initializing\n   * all the required parameters into the configurator\n   *\n   * @param _ecosystemModelAddress - the address of the ecosystem model\n   * @param _controller the address which can control the core DAO functions\n   * @param _summoners - an array containing the addresses of the summoners\n   * @param _name - the name of the DAO\n   * @param _maxVotingLambda - the maximum amount of lambda that can be used to vote in the DAO\n   *\n   * @dev\n   * Requirements:\n   * - The DAO cannot already be initialized\n   * - The ecosystem model address cannot be the zero address\n   * - The DAO must have atleast one summoner to summon the DAO\n   * - The configurator should be able to successfully build the DAO\n   */\n  function initialize(\n    address _ecosystemModelAddress,\n    address _controller,\n    address[] memory _summoners,\n    string memory _name,\n    uint256 _maxVotingLambda\n  ) external preventReentry {\n    require(initialized == false, 'ElasticDAO: Already initialized');\n    require(\n      _ecosystemModelAddress != address(0) || _controller != address(0),\n      'ElasticDAO: Address Zero'\n    );\n    require(_summoners.length > 0, 'ElasticDAO: At least 1 summoner required');\n\n    Ecosystem.Instance memory defaults = Ecosystem(_ecosystemModelAddress).deserialize(address(0));\n    Configurator configurator = Configurator(defaults.configuratorAddress);\n    Ecosystem.Instance memory ecosystem = configurator.buildEcosystem(controller, defaults);\n    ecosystemModelAddress = ecosystem.ecosystemModelAddress;\n\n    controller = _controller;\n    deployer = msg.sender;\n    summoners = _summoners;\n\n    bool success = configurator.buildDAO(_summoners, _name, _maxVotingLambda, ecosystem);\n    initialized = true;\n    require(success, 'ElasticDAO: Build DAO Failed');\n  }\n\n  /**\n   * @notice initializes the token of the DAO, using the Configurator\n   *\n   * @param _name - name of the token\n   * @param _symbol - symbol of the token\n   * @param _eByL -the amount of lambda a summoner gets(per ETH) during the seeding phase of the DAO\n   * @param _elasticity the value by which the cost of entering the  DAO increases ( on every join )\n   * @param _k - is the constant token multiplier\n   * it increases the number of tokens that each member of the DAO has with respect to their lambda\n   * @param _maxLambdaPurchase - is the maximum amount of lambda that can be purchased per wallet\n   *\n   * @dev refer https://docs.openzeppelin.com/cli/2.8/deploying-with-create2#create2\n   * for further understanding of Create2 and salt\n   * @dev emits ElasticGovernanceTokenDeployed event\n   * @dev\n   * Requirements:\n   * - Only the deployer of the DAO can initialize the Token\n   * - The controller of the DAO should successfully be set as the burner of the tokens of the DAO\n   * - The controller of the DAO should successfully be set as the minter of the tokens of the DAO\n   */\n  function initializeToken(\n    string memory _name,\n    string memory _symbol,\n    uint256 _eByL,\n    uint256 _elasticity,\n    uint256 _k,\n    uint256 _maxLambdaPurchase\n  ) external onlyBeforeSummoning onlyDeployer preventReentry {\n    require(msg.sender == deployer, 'ElasticDAO: Only deployer can initialize the Token');\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n\n    Token.Instance memory token =\n      Configurator(ecosystem.configuratorAddress).buildToken(\n        controller,\n        _name,\n        _symbol,\n        _eByL,\n        _elasticity,\n        _k,\n        _maxLambdaPurchase,\n        ecosystem\n      );\n\n    emit ElasticGovernanceTokenDeployed(token.uuid);\n  }\n\n  /**\n   * @notice this function is to be used for exiting the DAO\n   * for the underlying ETH value of  _deltaLambda\n   *\n   * The eth value of _deltaLambda is calculated using:\n   *\n   * eth to be transfered = ( deltaLambda/lambda ) * totalEthInTheDAO\n   *\n   * @param _deltaLambda - the amount of lambda the address exits with\n   *\n   * Requirement:\n   * - Should be able to successfully exit the DAO\n   * @dev emits ExitDAO event\n   */\n  function exit(uint256 _deltaLambda) external onlyAfterSummoning preventReentry {\n    // burn the shares\n    Token.Instance memory token = _getToken();\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(token.uuid);\n\n    // eth to be transfered = ( deltaLambda/lambda ) * totalEthInTheDAO\n    uint256 ratioOfShares = ElasticMath.wdiv(_deltaLambda, token.lambda);\n    uint256 ethToBeTransfered = ElasticMath.wmul(ratioOfShares, address(this).balance);\n    // transfer the eth\n    tokenContract.burnShares(msg.sender, _deltaLambda);\n    (bool success, ) = msg.sender.call{ value: ethToBeTransfered }('');\n    require(success, 'ElasticDAO: Exit Failed');\n    emit ExitDAO(address(this), msg.sender, _deltaLambda, ethToBeTransfered);\n  }\n\n  /**\n   * @notice this function is used to join the DAO after it has been summoned\n   * Joining the DAO is syntactically equal to minting _deltaLambda for the function caller.\n   *\n   * Based on the current state of the DAO, capitalDelta, deltaE, mDash are calulated,\n   * after which  _deltaLambda is minted for the address calling the function.\n   *\n   * @param _deltaLambda - the amount of lambda the address joins with\n   *\n   * @dev documentation and further math regarding capitalDelta, deltaE,\n   * mDash can be found at ../libraries/ElasticMath.sol\n   * @dev emits the JoinDAO event\n   *\n   * @dev Requirements:\n   * The amount of shares being purchased has to be lower than maxLambdaPurchase\n   * (The value of maxLambdaPurchase is set during the initialzing of the DAO)\n   * The correct value of ETH, calculated via deltaE,\n   * must be sent in the transaction by the calling address\n   * The token contract should be successfully be able to mint  _deltaLambda\n   */\n  function join(uint256 _deltaLambda)\n    external\n    payable\n    onlyAfterSummoning\n    onlyWhenOpen\n    preventReentry\n  {\n    Token.Instance memory token = _getToken();\n\n    require(\n      _deltaLambda <= token.maxLambdaPurchase,\n      'ElasticDAO: Cannot purchase those many lambda at once'\n    );\n\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(token.uuid);\n    uint256 capitalDelta =\n      ElasticMath.capitalDelta(\n        // the current totalBalance of the DAO is inclusive of msg.value,\n        // capitalDelta is to be calculated without the msg.value\n        address(this).balance - msg.value,\n        tokenContract.totalSupply()\n      );\n    uint256 deltaE =\n      ElasticMath.deltaE(\n        _deltaLambda,\n        capitalDelta,\n        token.k,\n        token.elasticity,\n        token.lambda,\n        token.m\n      );\n\n    if (deltaE != msg.value) {\n      revert('ElasticDAO: Incorrect ETH amount');\n    }\n\n    // mdash\n    uint256 lambdaDash = SafeMath.add(_deltaLambda, token.lambda);\n    uint256 mDash = ElasticMath.mDash(lambdaDash, token.lambda, token.m);\n\n    // serialize the token\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    Token tokenStorage = Token(ecosystem.tokenModelAddress);\n    token.m = mDash;\n    tokenStorage.serialize(token);\n\n    // tokencontract mint shares\n    bool success = tokenContract.mintShares(msg.sender, _deltaLambda);\n    require(success, 'ElasticDAO: Mint Shares Failed during Join');\n    emit JoinDAO(address(this), msg.sender, _deltaLambda, msg.value);\n  }\n\n  /**\n   * @notice penalizes @param _addresess with @param _amounts respectively\n   *\n   * @param _addresses - an array of addresses\n   * @param _amounts - an array containing the amounts each address has to be penalized respectively\n   *\n   * @dev Requirement:\n   * - Each address must have a corresponding amount to be penalized with\n   */\n  function penalize(address[] memory _addresses, uint256[] memory _amounts)\n    external\n    onlyController\n    preventReentry\n  {\n    require(\n      _addresses.length == _amounts.length,\n      'ElasticDAO: An amount is required for each address'\n    );\n\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(_getToken().uuid);\n\n    for (uint256 i = 0; i < _addresses.length; i += 1) {\n      tokenContract.burnShares(_addresses[i], _amounts[i]);\n    }\n  }\n\n  /**\n   * @notice rewards @param _addresess with @param _amounts respectively\n   *\n   * @param _addresses - an array of addresses\n   * @param _amounts - an array containing the amounts each address has to be rewarded respectively\n   *\n   * @dev Requirement:\n   * - Each address must have a corresponding amount to be rewarded with\n   */\n  function reward(address[] memory _addresses, uint256[] memory _amounts)\n    external\n    onlyController\n    preventReentry\n  {\n    require(\n      _addresses.length == _amounts.length,\n      'ElasticDAO: An amount is required for each address'\n    );\n\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(_getToken().uuid);\n\n    for (uint256 i = 0; i < _addresses.length; i += 1) {\n      tokenContract.mintShares(_addresses[i], _amounts[i]);\n    }\n  }\n\n  /**\n   * @notice sets the controller of the DAO,\n   * The controller of the DAO handles various responsibilities of the DAO,\n   * such as burning and minting tokens on behalf of the DAO\n   *\n   * @param _controller - the new address of the controller of the DAO\n   *\n   * @dev emits ControllerChanged event\n   * @dev Requirements:\n   * - The controller must not be the 0 address\n   * - The controller of the DAO should successfully be set as the burner of the tokens of the DAO\n   * - The controller of the DAO should successfully be set as the minter of the tokens of the DAO\n   */\n  function setController(address _controller) external onlyController preventReentry {\n    require(_controller != address(0), 'ElasticDAO: Address Zero');\n\n    controller = _controller;\n\n    // Update minter / burner\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(_getToken().uuid);\n    bool success = tokenContract.setBurner(controller);\n    require(success, 'ElasticDAO: Set Burner failed during setController');\n    success = tokenContract.setMinter(controller);\n    require(success, 'ElasticDAO: Set Minter failed during setController');\n\n    emit ControllerChanged(address(this), 'setController', controller);\n  }\n\n  /**\n   * @notice sets the max voting lambda value for the DAO\n   * @param _maxVotingLambda - the value of the maximum amount of lambda that can be used for voting\n   * @dev emits MaxVotingLambda event\n   */\n  function setMaxVotingLambda(uint256 _maxVotingLambda) external onlyController preventReentry {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    DAO daoStorage = DAO(ecosystem.daoModelAddress);\n    DAO.Instance memory dao = daoStorage.deserialize(address(this), ecosystem);\n    dao.maxVotingLambda = _maxVotingLambda;\n    daoStorage.serialize(dao);\n\n    emit MaxVotingLambdaChanged(address(this), 'setMaxVotingLambda', _maxVotingLambda);\n  }\n\n  /**\n   * @notice seeds the DAO,\n   * Essentially transferring of ETH by a summoner address, in return for lambda is seeding the DAO,\n   * The lambda receieved is given by:\n   * Lambda = Eth  / eByL\n   *\n   * @dev seeding of the DAO occurs after the DAO has been initialized,\n   * and before the DAO has been summoned\n   * @dev emits the SeedDAO event\n   */\n  function seedSummoning()\n    external\n    payable\n    onlyBeforeSummoning\n    onlySummoners\n    onlyAfterTokenInitialized\n    preventReentry\n  {\n    Token.Instance memory token = _getToken();\n\n    uint256 deltaE = msg.value;\n    uint256 deltaLambda = ElasticMath.wdiv(deltaE, token.eByL);\n    ElasticGovernanceToken(token.uuid).mintShares(msg.sender, deltaLambda);\n\n    emit SeedDAO(address(this), msg.sender, deltaLambda);\n  }\n\n  /**\n   * @notice summons the DAO,\n   * Summoning the DAO results in all summoners getting _deltaLambda\n   * after which people can enter the DAO using the join function\n   *\n   * @param _deltaLambda - the amount of lambda each summoner address receieves\n   *\n   * @dev emits SummonedDAO event\n   * @dev Requirement:\n   * The DAO must be seeded with ETH during the seeding phase\n   * (This is to facilitate capitalDelta calculations after the DAO has been summoned).\n   *\n   * @dev documentation and further math regarding capitalDelta\n   * can be found at ../libraries/ElasticMath.sol\n   */\n  function summon(uint256 _deltaLambda) external onlyBeforeSummoning onlySummoners preventReentry {\n    require(address(this).balance > 0, 'ElasticDAO: Please seed DAO with ETH to set ETH:EGT ratio');\n\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    DAO daoContract = DAO(ecosystem.daoModelAddress);\n    DAO.Instance memory dao = daoContract.deserialize(address(this), ecosystem);\n    Token.Instance memory token =\n      Token(ecosystem.tokenModelAddress).deserialize(ecosystem.governanceTokenAddress, ecosystem);\n    ElasticGovernanceToken tokenContract = ElasticGovernanceToken(token.uuid);\n\n    // number of summoners can not grow unboundly. it is fixed limit.\n    for (uint256 i = 0; i < dao.numberOfSummoners; i += 1) {\n      tokenContract.mintShares(daoContract.getSummoner(dao, i), _deltaLambda);\n    }\n    dao.summoned = true;\n    daoContract.serialize(dao);\n\n    emit SummonedDAO(address(this), msg.sender);\n  }\n\n  // Getters\n\n  function getDAO() external view returns (DAO.Instance memory) {\n    return _getDAO();\n  }\n\n  function getEcosystem() external view returns (Ecosystem.Instance memory) {\n    return _getEcosystem();\n  }\n\n  // Private\n\n  function _getDAO() internal view returns (DAO.Instance memory) {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    return DAO(ecosystem.daoModelAddress).deserialize(address(this), ecosystem);\n  }\n\n  function _getEcosystem() internal view returns (Ecosystem.Instance memory) {\n    return Ecosystem(ecosystemModelAddress).deserialize(address(this));\n  }\n\n  function _getToken() internal view returns (Token.Instance memory) {\n    Ecosystem.Instance memory ecosystem = _getEcosystem();\n    return\n      Token(ecosystem.tokenModelAddress).deserialize(ecosystem.governanceTokenAddress, ecosystem);\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {}\n}\n\n\n",
        "CodeNames": [
            "ElasticDAO.sol",
            ""
        ],
        "VulnerabilityDesc": [
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_M-04",
                "Location": [
                    "onlyController"
                ],
                "Type": " Potential for lock out of administrative access",
                "Description": "The setController` function in ElasticDAO.sol updates the controller address in one set-up. If thecontroller address is set incorrectly, administrative access is prevented because setController`includes an onlyController modifier. The contract would have to be redeployed if this mistake ismade.ElasticDAO: The vulnerability is correct, however, the impact is incorrect. Because wedeploy with proxies, in a worst case scenario, the proxy implementation could be upgradedto fix this issue.\u201dcode423n4.comhttps://github.com/elasticdao/contracts/pull/42https://github.com/elasticdao/contracts/pull/53https://github.com/elasticdao/contracts/pull/78https://code423n4.com/",
                "Repair": ""
            },
            {
                "Name": "Code 423n4 ElasticDAO Findings and Analysis.pdf_M-07",
                "Location": [
                    "onlyController"
                ],
                "Type": " Passing a zero address for controller will require redeployment of the contract",
                "Description": "Passing a zero address for the controller during initialization will require redeployment of thecontract because the onlyController modifier for critical contract functions cannot bechanged after initial deployment.ElasticDAO: Confirmed and resolved in PR #47code423n4.comhttps://github.com/elasticdao/contracts/pull/44https://github.com/elasticdao/contracts/pull/47/files#diff-b01d843824b5d557c2914b0f42fdf4ef84315a85723a9640b7040ec8c29f2cefR115https://code423n4.com/",
                "Repair": ""
            }
        ]
    }
]