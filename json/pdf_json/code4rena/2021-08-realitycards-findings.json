[
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\n\n/// @title Reality Cards Orderbook\n/// @author Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCOrderbook is NativeMetaTransaction, IRCOrderbook {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev a record of a users single bid.\n    /// @dev now declared in the interface, left here for reference\n    // struct Bid {\n    //     address market;\n    //     address next;\n    //     address prev;\n    //     uint64 card;\n    //     uint128 price;\n    //     uint64 timeHeldLimit;\n    // }\n\n    /// @dev maps a user address to an array of their bids\n    mapping(address => Bid[]) public user;\n    /// @dev index of a bid record in the user array, User|Market|Token->Index\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        public\n        override index;\n\n    /// @dev record of market specific variables\n    struct Market {\n        uint64 mode;\n        uint64 cardCount;\n        uint64 minimumPriceIncreasePercent;\n        uint64 minimumRentalDuration;\n    }\n    /// @dev map a market address to a market record\n    mapping(address => Market) public market;\n    /// @dev find the current owner of a card in a given market. Market -> Card -> Owner\n    mapping(address => mapping(uint256 => address)) public override ownerOf;\n    /// @dev store the oldOwner and oldPrice in the event we can't find a new owner\n    mapping(address => mapping(uint256 => address)) public oldOwner;\n    mapping(address => mapping(uint256 => uint256)) public oldPrice;\n    /// @dev an array of closed markets, used to reduce user bid rates\n    address[] public override closedMarkets;\n    /// @dev how far through the array a given user is, saves iterating the whole array every time.\n    mapping(address => uint256) public override userClosedMarketIndex;\n\n    ///// GOVERNANCE VARIABLES /////\n    /// @dev the current treasury\n    IRCTreasury public override treasury;\n    /// @dev max number of searches to place an order in the book\n    /// @dev current estimates place limit around 2000 but 1000 is sufficient\n    uint256 public override maxSearchIterations = 1000;\n    /// @dev max number of records to delete in one transaction\n    uint256 public override maxDeletions = 70;\n    /// @dev number of bids a user should clean when placing a new bid\n    uint256 public override cleaningLoops = 2;\n    /// @dev max number of market records to put into the waste pile in one go\n    uint256 public override marketCloseLimit = 70;\n    /// @dev nonce emitted with orderbook insertions, for frontend sorting\n    uint256 public override nonce;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant FACTORY = keccak256(\"FACTORY\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant WHITELIST = keccak256(\"WHITELIST\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          MODIFIERS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice only allow markets to call certain functions\n    modifier onlyMarkets() {\n        require(\n            treasury.checkPermission(MARKET, msgSender()),\n            \"Not authorised\"\n        );\n        _;\n    }\n\n    modifier onlyUberOwner() {\n        require(\n            treasury.checkPermission(UBER_OWNER, msgSender()),\n            \"Extremely Verboten\"\n        );\n        _;\n    }\n\n    modifier onlyFactory() {\n        require(\n            treasury.checkPermission(FACTORY, msgSender()),\n            \"Extremely Verboten\"\n        );\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev emitted every time an order is added to the orderbook\n    event LogAddToOrderbook(\n        address indexed newOwner,\n        uint256 indexed newPrice,\n        uint256 timeHeldLimit,\n        uint256 nonce,\n        uint256 indexed tokenId,\n        address market\n    );\n    /// @dev emitted when an order is removed from the orderbook\n    event LogRemoveFromOrderbook(\n        address indexed owner,\n        address indexed market,\n        uint256 indexed tokenId\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CONSTRUCTOR             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(IRCTreasury _treasury) {\n        treasury = _treasury;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         GOVERNANCE              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function setTreasuryAddress(address _newTreasury)\n        external\n        override\n        onlyUberOwner\n    {\n        require(_newTreasury != address(0));\n        treasury = IRCTreasury(_newTreasury);\n    }\n\n    function setDeletionLimit(uint256 _deletionLimit)\n        external\n        override\n        onlyUberOwner\n    {\n        maxDeletions = _deletionLimit;\n    }\n\n    function setCleaningLimit(uint256 _cleaningLimit)\n        external\n        override\n        onlyUberOwner\n    {\n        cleaningLoops = _cleaningLimit;\n    }\n\n    function setSearchLimit(uint256 _searchLimit)\n        external\n        override\n        onlyUberOwner\n    {\n        maxSearchIterations = _searchLimit;\n    }\n\n    function setMarketCloseLimit(uint256 _marketCloseLimit)\n        external\n        override\n        onlyUberOwner\n    {\n        marketCloseLimit = _marketCloseLimit;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             INSERTIONS              \u2551\n      \u2551 functions that add to the orderbook \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice adds a new market to the orderbook\n    function addMarket(\n        address _market,\n        uint256 _cardCount,\n        uint256 _minIncrease\n    ) internal {\n        market[_market].cardCount = SafeCast.toUint64(_cardCount);\n        market[_market].minimumPriceIncreasePercent = SafeCast.toUint64(\n            _minIncrease\n        );\n        market[_market].minimumRentalDuration = SafeCast.toUint64(\n            1 days / IRCMarket(_market).minRentalDayDivisor()\n        );\n        for (uint64 i = 0; i < _cardCount; i++) {\n            // create new record for each card that becomes the head&tail of the linked list\n            Bid memory _newBid;\n            _newBid.market = _market;\n            _newBid.card = i;\n            _newBid.prev = _market;\n            _newBid.next = _market;\n            _newBid.price = 0;\n            _newBid.timeHeldLimit = type(uint64).max;\n            index[_market][_market][i] = user[_market].length;\n            user[_market].push(_newBid);\n        }\n    }\n\n    /// @notice adds or updates a bid in the orderbook\n    /// @param _user the user placing the bid\n    /// @param _card the card to place the bid on\n    /// @param _price the price of the new bid\n    /// @param _timeHeldLimit an optional time limit for the bid\n    /// @param _prevUserAddress to help find where to insert the bid\n    function addBidToOrderbook(\n        address _user,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external override onlyMarkets {\n        address _market = msgSender();\n        if (!bidExists(_market, _market, _card)) {\n            uint256 _cardCount = IRCMarket(_market).numberOfCards();\n            uint256 _minIncrease = IRCMarket(_market)\n                .minimumPriceIncreasePercent();\n            addMarket(_market, _cardCount, _minIncrease);\n        }\n        // each new bid can help clean up some junk\n        cleanWastePile();\n\n        if (user[_user].length == 0) {\n            //users first bid, skip already closed markets\n            userClosedMarketIndex[_user] = closedMarkets.length;\n        }\n\n        if (_prevUserAddress == address(0)) {\n            _prevUserAddress = _market;\n        } else {\n            require(\n                user[_prevUserAddress][index[_prevUserAddress][_market][_card]]\n                    .price >= _price,\n                \"Location too low\"\n            );\n        }\n        require(\n            bidExists(_prevUserAddress, _market, _card),\n            \"Invalid starting location\"\n        );\n        Bid storage _prevUser = user[_prevUserAddress][\n            index[_prevUserAddress][_market][_card]\n        ];\n\n        if (bidExists(_user, _market, _card)) {\n            // old bid exists, update it\n            _updateBidInOrderbook(\n                _user,\n                _market,\n                _card,\n                _price,\n                _timeHeldLimit,\n                _prevUser\n            );\n        } else {\n            // new bid, add it\n            _newBidInOrderbook(\n                _user,\n                _market,\n                _card,\n                _price,\n                _timeHeldLimit,\n                _prevUser\n            );\n        }\n    }\n\n    /// @dev finds the correct location in the orderbook for a given bid\n    /// @dev returns an adjusted (lowered) bid price if necessary.\n    function _searchOrderbook(\n        Bid storage _prevUser,\n        address _market,\n        uint256 _card,\n        uint256 _price\n    ) internal view returns (Bid storage, uint256) {\n        uint256 _minIncrease = market[_market].minimumPriceIncreasePercent;\n        Bid storage _nextUser = user[_prevUser.next][\n            index[_prevUser.next][_market][_card]\n        ];\n        uint256 _requiredPrice = (_nextUser.price * (_minIncrease + (100))) /\n            (100);\n\n        uint256 i = 0;\n        while (\n            // break loop if match price above AND above price below (so if either is false, continue, hence OR )\n            // if match previous then must be greater than next to continue\n            (_price != _prevUser.price || _price <= _nextUser.price) &&\n            // break loop if price x% above below\n            _price < _requiredPrice &&\n            // break loop if hits max iterations\n            i < maxSearchIterations\n        ) {\n            _prevUser = _nextUser;\n            _nextUser = user[_prevUser.next][\n                index[_prevUser.next][_market][_card]\n            ];\n            _requiredPrice = (_nextUser.price * (_minIncrease + (100))) / (100);\n            i++;\n        }\n        require(i < maxSearchIterations, \"Position not found\");\n\n        // if previous price is zero it must be the market and this is a new owner\n        // .. then don't reduce their price, we already checked they are 10% higher\n        // .. than the previous owner.\n        if (_prevUser.price != 0 && _prevUser.price < _price) {\n            _price = _prevUser.price;\n        }\n        return (_prevUser, _price);\n    }\n\n    /// @dev add a new bid to the orderbook\n    function _newBidInOrderbook(\n        address _user,\n        address _market,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        Bid storage _prevUser\n    ) internal {\n        if (ownerOf[_market][_card] != _market) {\n            (_prevUser, _price) = _searchOrderbook(\n                _prevUser,\n                _market,\n                _card,\n                _price\n            );\n        }\n\n        Bid storage _nextUser = user[_prevUser.next][\n            index[_prevUser.next][_market][_card]\n        ];\n\n        // create new record\n        Bid memory _newBid;\n        _newBid.market = _market;\n        _newBid.card = SafeCast.toUint64(_card);\n        _newBid.prev = _nextUser.prev;\n        _newBid.next = _prevUser.next;\n        _newBid.price = SafeCast.toUint128(_price);\n        _newBid.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);\n\n        // insert in linked list\n        _nextUser.prev = _user; // next record update prev link\n        _prevUser.next = _user; // prev record update next link\n        user[_user].push(_newBid);\n\n        // update the index to help find the record later\n        index[_user][_market][_card] = user[_user].length - (1);\n\n        emit LogAddToOrderbook(\n            _user,\n            _price,\n            _timeHeldLimit,\n            nonce,\n            _card,\n            _market\n        );\n        nonce++;\n\n        // update treasury values and transfer ownership if required\n        treasury.increaseBidRate(_user, _price);\n        if (user[_user][index[_user][_market][_card]].prev == _market) {\n            address _oldOwner = user[_user][index[_user][_market][_card]].next;\n            transferCard(_market, _card, _oldOwner, _user, _price);\n            treasury.updateRentalRate(\n                _oldOwner,\n                _user,\n                user[_oldOwner][index[_oldOwner][_market][_card]].price,\n                _price,\n                block.timestamp\n            );\n        }\n    }\n\n    /// @dev updates a bid that is already in the orderbook\n    function _updateBidInOrderbook(\n        address _user,\n        address _market,\n        uint256 _card,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        Bid storage _prevUser\n    ) internal {\n        // TODO no need to unlink and relink if bid doesn't change position in orderbook\n        // unlink current bid\n        Bid storage _currUser = user[_user][index[_user][_market][_card]];\n        user[_currUser.next][index[_currUser.next][_market][_card]]\n            .prev = _currUser.prev;\n        user[_currUser.prev][index[_currUser.prev][_market][_card]]\n            .next = _currUser.next;\n        bool _wasOwner = _currUser.prev == _market;\n\n        // find new position\n        (_prevUser, _price) = _searchOrderbook(\n            _prevUser,\n            _market,\n            _card,\n            _price\n        );\n        Bid storage _nextUser = user[_prevUser.next][\n            index[_prevUser.next][_market][_card]\n        ];\n\n        // update price, save old price for rental rate adjustment later\n        (_currUser.price, _price) = (\n            SafeCast.toUint128(_price),\n            uint256(_currUser.price)\n        );\n        _currUser.timeHeldLimit = SafeCast.toUint64(_timeHeldLimit);\n\n        // relink bid\n        _currUser.next = _prevUser.next;\n        _currUser.prev = _nextUser.prev;\n        _nextUser.prev = _user; // next record update prev link\n        _prevUser.next = _user; // prev record update next link\n\n        emit LogAddToOrderbook(\n            _user,\n            _currUser.price,\n            _timeHeldLimit,\n            nonce,\n            _card,\n            _market\n        );\n        nonce++;\n\n        // update treasury values and transfer ownership if required\n        treasury.increaseBidRate(_user, _currUser.price);\n        treasury.decreaseBidRate(_user, _price);\n        if (_wasOwner && _currUser.prev == _market) {\n            // if owner before and after, update the price difference\n            transferCard(_market, _card, _user, _user, _currUser.price);\n            treasury.updateRentalRate(\n                _user,\n                _user,\n                _price,\n                _currUser.price,\n                block.timestamp\n            );\n        } else if (_wasOwner && _currUser.prev != _market) {\n            // if owner before and not after, remove the old price\n            address _newOwner = user[_market][index[_market][_market][_card]]\n                .next;\n            uint256 _newPrice = user[_newOwner][\n                index[_newOwner][_market][_card]\n            ].price;\n            treasury.updateRentalRate(\n                _user,\n                _newOwner,\n                _price,\n                _newPrice,\n                block.timestamp\n            );\n            transferCard(_market, _card, _user, _newOwner, _newPrice);\n        } else if (!_wasOwner && _currUser.prev == _market) {\n            // if not owner before but is owner after, add new price\n            address _oldOwner = _currUser.next;\n            uint256 _oldPrice = user[_oldOwner][\n                index[_oldOwner][_market][_card]\n            ].price;\n            treasury.updateRentalRate(\n                _oldOwner,\n                _user,\n                _oldPrice,\n                _currUser.price,\n                block.timestamp\n            );\n            transferCard(_market, _card, _oldOwner, _user, _currUser.price);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551                DELETIONS                 \u2551      \n      \u2551 functions that remove from the orderbook \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice removes a single bid from the orderbook - onlyMarkets\n    function removeBidFromOrderbook(address _user, uint256 _card)\n        external\n        override\n        onlyMarkets\n    {\n        address _market = msgSender();\n        assert(_user != ownerOf[_market][_card]);\n        _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);\n    }\n\n    /// @dev removes a single bid from the orderbook, doesn't update ownership\n    function _removeBidFromOrderbookIgnoreOwner(\n        address _user,\n        address _market,\n        uint256 _card\n    ) internal returns (uint256 _newPrice) {\n        Bid storage _currUser = user[_user][index[_user][_market][_card]];\n\n        // extract from linked list\n        address _tempNext = _currUser.next;\n        address _tempPrev = _currUser.prev;\n        user[_tempNext][index[_tempNext][_market][_card]].prev = _tempPrev;\n        user[_tempPrev][index[_tempPrev][_market][_card]].next = _tempNext;\n\n        // return next users price to check they're eligible later\n        _newPrice = user[_tempNext][index[_tempNext][_market][_card]].price;\n\n        // update rate\n        treasury.decreaseBidRate(_user, _currUser.price);\n\n        // overwrite array element\n        uint256 _index = index[_user][_market][_card];\n        uint256 _lastRecord = user[_user].length - 1;\n        // no point overwriting itself\n        if (_index != _lastRecord) {\n            user[_user][_index] = user[_user][_lastRecord];\n        }\n        user[_user].pop();\n\n        // update the index to help find the record later\n        index[_user][_market][_card] = 0;\n        if (user[_user].length != 0 && _index != _lastRecord) {\n            index[_user][user[_user][_index].market][\n                user[_user][_index].card\n            ] = _index;\n        }\n\n        assert(!bidExists(_user, _market, _card));\n        emit LogRemoveFromOrderbook(_user, _market, _card);\n    }\n\n    /// @notice find the next valid owner of a given card - onlyMarkets\n    /// @param _card the card to remove\n    /// @param _timeOwnershipChanged the timestamp, used to backdate ownership changes\n    function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)\n        external\n        override\n        onlyMarkets\n    {\n        address _newOwner = address(0);\n        address _market = msgSender();\n        // the market is the head of the list, the next bid is therefore the owner\n        Bid storage _head = user[_market][index[_market][_market][_card]];\n        address _oldOwner = address(0);\n        uint256 _oldPrice = 0;\n        if (oldOwner[_market][_card] != address(0)) {\n            _oldOwner = oldOwner[_market][_card];\n            _oldPrice = oldPrice[_market][_card];\n            oldOwner[_market][_card] = address(0);\n            oldPrice[_market][_card] = 0;\n        } else {\n            _oldOwner = ownerOf[_market][_card];\n            _oldPrice = user[_oldOwner][index[_oldOwner][_market][_card]].price;\n        }\n        uint256 minimumTimeToOwnTo = _timeOwnershipChanged +\n            market[_market].minimumRentalDuration;\n        uint256 _newPrice;\n        uint256 _loopCounter = 0;\n\n        // delete current owner\n        do {\n            _newPrice = _removeBidFromOrderbookIgnoreOwner(\n                _head.next,\n                _market,\n                _card\n            );\n            _loopCounter++;\n            // delete next bid if foreclosed\n        } while (\n            treasury.foreclosureTimeUser(\n                _head.next,\n                _newPrice,\n                _timeOwnershipChanged\n            ) <\n                minimumTimeToOwnTo &&\n                _loopCounter < maxDeletions\n        );\n\n        if (_loopCounter != maxDeletions) {\n            // the old owner is dead, long live the new owner\n            _newOwner = user[_market][index[_market][_market][_card]].next;\n            treasury.updateRentalRate(\n                _oldOwner,\n                _newOwner,\n                _oldPrice,\n                _newPrice,\n                _timeOwnershipChanged\n            );\n            transferCard(_market, _card, _oldOwner, _newOwner, _newPrice);\n        } else {\n            // we hit the limit, save the old owner, we'll try again next time\n            oldOwner[_market][_card] = _oldOwner;\n            oldPrice[_market][_card] = _oldPrice;\n        }\n    }\n\n    /// @notice when a user has foreclosed we can freely delete their bids, however leave owned cards\n    /// @notice .. as the markets will need to finish the accounting for them first.\n    /// @param _user the user whose bids to start deleting\n    function removeUserFromOrderbook(address _user) external override {\n        require(treasury.isForeclosed(_user), \"User must be foreclosed\");\n        uint256 i = user[_user].length;\n        if (i != 0) {\n            uint256 _limit = 0;\n            if (i > maxDeletions) {\n                _limit = i - maxDeletions;\n            }\n\n            do {\n                i--;\n\n                // If the prev record isn't the market, this is only a bid (not owned) so we can delete\n                if (user[_user][i].prev != user[_user][i].market) {\n                    address _market = user[_user][i].market;\n                    uint256 _card = user[_user][i].card;\n                    _removeBidFromOrderbookIgnoreOwner(_user, _market, _card);\n                }\n            } while (user[_user].length > _limit && i > 0);\n        }\n        treasury.assessForeclosure(_user);\n    }\n\n    /// @notice reduces the rentalRates of the card owners when a market closes\n    /// @dev too many bidders to reduce all bid rates also\n    function closeMarket() external override onlyMarkets returns (bool) {\n        address _market = msgSender();\n        // check if the market was ever added to the orderbook\n        if (bidExists(_market, _market, 0)) {\n            closedMarkets.push(_market);\n            uint256 i = user[_market].length; // start on the last record so we can easily pop()\n            uint256 _limit = 0;\n            if (marketCloseLimit < user[_market].length) {\n                _limit = user[_market].length - marketCloseLimit;\n            } else {\n                _limit = 0;\n            }\n            do {\n                i--;\n                address _lastOwner = user[_market][index[_market][_market][i]]\n                    .next;\n                if (_lastOwner != _market) {\n                    uint256 _price = user[_lastOwner][\n                        index[_lastOwner][_market][i]\n                    ].price;\n\n                    // store last bid for later\n                    address _lastBid = user[_market][index[_market][_market][i]]\n                        .prev;\n\n                    // detach market from rest of list\n                    user[_market][index[_market][_market][i]].prev = _market;\n                    user[_market][index[_market][_market][i]].next = _market;\n                    user[_lastOwner][index[_lastOwner][_market][i]]\n                        .prev = address(this);\n                    user[_lastBid][index[_lastBid][_market][i]].next = address(\n                        this\n                    );\n\n                    index[address(this)][_market][i] = user[address(this)]\n                        .length;\n\n                    // insert bids in the waste pile\n                    Bid memory _newBid;\n                    _newBid.market = _market;\n                    _newBid.card = SafeCast.toUint64(i);\n                    _newBid.prev = _lastBid;\n                    _newBid.next = _lastOwner;\n                    _newBid.price = 0;\n                    _newBid.timeHeldLimit = 0;\n                    user[address(this)].push(_newBid);\n\n                    // reduce owners rental rate\n                    treasury.updateRentalRate(\n                        _lastOwner,\n                        _market,\n                        _price,\n                        0,\n                        block.timestamp\n                    );\n                }\n                // remove the market record\n                user[_market].pop();\n            } while (i > _limit);\n        }\n        if (user[_market].length == 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Remove bids in closed markets for a given user\n    /// @notice this can reduce the users bidRate and chance to foreclose\n    /// @param _user the address of the users bids to remove\n    function removeOldBids(address _user) external override {\n        if (user[_user].length != 0) {\n            address _market = address(0);\n            uint256 _cardCount = 0;\n            uint256 _loopCounter = 0;\n            uint256 _subLoopCounter = 0;\n            while (\n                userClosedMarketIndex[_user] < closedMarkets.length &&\n                _loopCounter + _cardCount < maxDeletions\n            ) {\n                _market = closedMarkets[userClosedMarketIndex[_user]];\n                // Just do the whole market at once\n                _cardCount = market[_market].cardCount;\n                uint256 i = _cardCount;\n                do {\n                    i--;\n                    if (bidExists(_user, _market, i)) {\n                        uint256 _index = index[_user][_market][i];\n                        // reduce bidRate\n                        uint256 _price = user[_user][_index].price;\n\n                        // preserve linked list\n                        address _tempPrev = user[_user][_index].prev;\n                        address _tempNext = user[_user][_index].next;\n\n                        user[_tempNext][index[_tempNext][_market][i]]\n                            .prev = _tempPrev;\n                        user[_tempPrev][index[_tempPrev][_market][i]]\n                            .next = _tempNext;\n\n                        uint256 _lastRecord = user[_user].length - 1;\n                        // no point overwriting itself\n                        if (_index != _lastRecord) {\n                            // overwrite array element\n                            user[_user][_index] = user[_user][_lastRecord];\n                        }\n                        user[_user].pop();\n\n                        // update the index to help find the record later\n                        index[_user][_market][i] = 0;\n                        if (user[_user].length != 0 && _index != _lastRecord) {\n                            index[_user][user[_user][_index].market][\n                                user[_user][_index].card\n                            ] = _index;\n                        }\n\n                        treasury.decreaseBidRate(_user, _price);\n                        // count deletions\n                        _loopCounter++;\n                    } else {\n                        // iterations cost gas also\n                        // after enough increment the loopCounter\n                        _subLoopCounter++;\n                        if (_subLoopCounter > 100) {\n                            _subLoopCounter = 0;\n                            _loopCounter++;\n                        }\n                    }\n                } while (i > 0);\n                userClosedMarketIndex[_user]++;\n            }\n        }\n    }\n\n    /// @dev remove bids in closed markets, not user specific\n    function cleanWastePile() public override {\n        uint256 i = 0;\n        while (i < cleaningLoops && user[address(this)].length > 0) {\n            uint256 _pileHeight = user[address(this)].length - 1;\n            address _market = user[address(this)][_pileHeight].market;\n            uint256 _card = user[address(this)][_pileHeight].card;\n            address _user = user[address(this)][_pileHeight].next;\n\n            if (user[address(this)][_pileHeight].next == address(this)) {\n                index[address(this)][_market][_card] = 0;\n                user[address(this)].pop();\n            } else {\n                uint256 _index = index[_user][_market][_card];\n                address _tempNext = user[_user][_index].next;\n\n                treasury.decreaseBidRate(_user, user[_user][_index].price);\n\n                // extract from linked list\n                user[address(this)][_pileHeight].next = _tempNext;\n                user[_tempNext][index[_tempNext][_market][_card]]\n                    .prev = address(this);\n\n                // overwrite array element\n                uint256 _lastRecord = user[_user].length - 1;\n                // no point overwriting itself\n                if (_index != _lastRecord) {\n                    user[_user][_index] = user[_user][_lastRecord];\n                }\n                user[_user].pop();\n\n                // update the index to help find the record later\n                index[_user][_market][_card] = 0;\n                if (user[_user].length != 0 && _index != _lastRecord) {\n                    index[_user][user[_user][_index].market][\n                        user[_user][_index].card\n                    ] = _index;\n                }\n            }\n            i++;\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        HELPER FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check if a bid exists\n    /// @param _user the address of the user\n    /// @param _market the address of the market\n    /// @param _card the card index\n    /// @return if the bid exists or not\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) public view override returns (bool) {\n        if (user[_user].length != 0) {\n            //some bids exist\n            if (index[_user][_market][_card] != 0) {\n                // this bid exists\n                return true;\n            } else {\n                // check bid isn't index 0\n                if (\n                    user[_user][0].market == _market &&\n                    user[_user][0].card == _card\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function getBidValue(address _user, uint256 _card)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        address _market = msgSender();\n        if (bidExists(_user, _market, _card)) {\n            return user[_user][index[_user][_market][_card]].price;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @dev just to pass old tests, not needed otherwise\n    /// @dev but also useful to have so probably will stay\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view override returns (Bid memory) {\n        if (bidExists(_user, _market, _card)) {\n            Bid memory _bid = user[_user][index[_user][_market][_card]];\n            return _bid;\n        } else {\n            Bid memory _newBid;\n            _newBid.market = address(0);\n            _newBid.card = SafeCast.toUint64(_card);\n            _newBid.prev = address(0);\n            _newBid.next = address(0);\n            _newBid.price = 0;\n            _newBid.timeHeldLimit = 0;\n            return _newBid;\n        }\n    }\n\n    function getTimeHeldlimit(address _user, uint256 _card)\n        external\n        view\n        override\n        onlyMarkets\n        returns (uint256)\n    {\n        return user[_user][index[_user][msgSender()][_card]].timeHeldLimit;\n    }\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeldLimit\n    ) external override onlyMarkets {\n        address _market = msgSender();\n        require(bidExists(_user, _market, _card), \"Bid doesn't exist\");\n        user[_user][index[_user][_market][_card]].timeHeldLimit = SafeCast\n            .toUint64(_timeHeldLimit);\n    }\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _card,\n        uint256 _timeToReduce\n    ) external override onlyMarkets {\n        user[_user][index[_user][msgSender()][_card]].timeHeldLimit -= SafeCast\n            .toUint64(_timeToReduce);\n    }\n\n    function transferCard(\n        address _market,\n        uint256 _card,\n        address _oldOwner,\n        address _newOwner,\n        uint256 _price\n    ) internal {\n        ownerOf[_market][_card] = _newOwner;\n        uint256 _timeLimit = user[_newOwner][index[_newOwner][_market][_card]]\n            .timeHeldLimit;\n        IRCMarket _rcmarket = IRCMarket(_market);\n        _rcmarket.transferCard(_oldOwner, _newOwner, _card, _price, _timeLimit);\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\n// Just a handy file to copy/paste into remix\n\ninterface IRCFactory {\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string calldata _realitioQuestion,\n        uint256 _sponsorship\n    ) external returns (address);\n\n    function mintCopyOfNFT(address _user, uint256 _tokenId) external;\n\n    // view functions\n\n    function nfthub() external view returns (address);\n\n    function ipfsHash(address) external view returns (string memory);\n\n    function slugToAddress(string memory) external view returns (address);\n\n    function addressToSlug(address) external view returns (string memory);\n\n    function marketInfoResults() external view returns (uint256);\n\n    function treasury() external view returns (address);\n\n    function orderbook() external view returns (address);\n\n    function leaderboard() external view returns (address);\n\n    function realitio() external view returns (address);\n\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address[] memory);\n\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address);\n\n    function referenceContractAddress() external view returns (address);\n\n    function referenceContractVersion() external view returns (uint256);\n\n    function sponsorshipRequired() external view returns (uint256);\n\n    function advancedWarning() external view returns (uint32);\n\n    function maximumDuration() external view returns (uint32);\n\n    function minimumDuration() external view returns (uint32);\n\n    function marketCreationGovernorsOnly() external view returns (bool);\n\n    function approvedAffiliatesOnly() external view returns (bool);\n\n    function approvedArtistsOnly() external view returns (bool);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function cardLimit() external view returns (uint256);\n\n    function getPotDistribution() external view returns (uint256[5] memory);\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function isMarketApproved(address) external view returns (bool);\n\n    function marketPausedDefaultState() external view returns (bool);\n\n    function mintMarketNFT(uint256 _card) external;\n\n    function getOracleSettings()\n        external\n        view\n        returns (\n            IRealitio oracle,\n            address arbitratorAddress,\n            uint32 _timeout\n        );\n\n    // only Governors\n    function changeMarketApproval(address _market) external;\n\n    function addArtist(address _newArtist) external;\n\n    function removeArtist(address _oldArtist) external;\n\n    function addAffiliate(address _newAffiliate) external;\n\n    function removeAffiliate(address _oldAffiliate) external;\n\n    // only Owner\n    function setMarketPausedDefaultState(bool _state) external;\n\n    function setTimeout(uint32 _newTimeout) external;\n\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        external;\n\n    function setArbitrator(address _newAddress) external;\n\n    function setRealitioAddress(address _newAddress) external;\n\n    function maxRentIterations() external view returns (uint256);\n\n    function maxRentIterationsToLockMarket() external view returns (uint256);\n\n    function setCardLimit(uint256 _cardLimit) external;\n\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease) external;\n\n    function setNumberOfNFTsToAward(uint256 _NFTsToAward) external;\n\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external;\n\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) external;\n\n    function changeMarketCreationGovernorsOnly() external;\n\n    function changeApprovedArtistsOnly() external;\n\n    function changeApprovedAffilliatesOnly() external;\n\n    function setSponsorshipRequired(uint256 _amount) external;\n\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external;\n\n    function setMarketInfoResults(uint256 _results) external;\n\n    // only UberOwner\n    function setReferenceContractAddress(address _newAddress) external;\n\n    function setOrderbookAddress(IRCOrderbook _newAddress) external;\n\n    function setLeaderboardAddress(IRCLeaderboard _newAddress) external;\n\n    function setNftHubAddress(IRCNftHubL2 _newAddress) external;\n}\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRCTreasury {\n    function setTokenAddress(address _newToken) external;\n\n    function grantRole(string memory role, address account) external;\n\n    function grantRole(bytes32, address) external;\n\n    function revokeRole(string memory role, address account) external;\n\n    function revokeRole(bytes32, address) external;\n\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        external\n        returns (uint256 newTimeLastCollectedOnForeclosure);\n\n    function topupMarketBalance(uint256 _amount) external;\n\n    function assessForeclosure(address _user) external;\n\n    // view functions\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view returns (uint256);\n\n    function bridgeAddress() external view returns (address);\n\n    function checkPermission(bytes32, address) external view returns (bool);\n\n    function erc20() external view returns (IERC20);\n\n    function factory() external view returns (IRCFactory);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function isForeclosed(address) external view returns (bool);\n\n    function userTotalBids(address) external view returns (uint256);\n\n    function userDeposit(address) external view returns (uint256);\n\n    function totalDeposits() external view returns (uint256);\n\n    function marketPot(address) external view returns (uint256);\n\n    function totalMarketPots() external view returns (uint256);\n\n    function marketBalance() external view returns (uint256);\n\n    function marketBalanceTopup() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxContractBalance() external view returns (uint256);\n\n    function globalPause() external view returns (bool);\n\n    function addMarket(address _market, bool paused) external;\n\n    function marketPaused(address) external view returns (bool);\n\n    function batchWhitelist(address[] calldata _users, bool add) external;\n\n    function marketWhitelistCheck(address _user) external returns (bool);\n\n    function lockMarketPaused(address _market) external view returns (bool);\n\n    function setBridgeAddress(address _newAddress) external;\n\n    function setOrderbookAddress(address _newAddress) external;\n\n    function setLeaderboardAddress(address _newAddress) external;\n\n    function setFactoryAddress(address _newFactory) external;\n\n    function deposit(uint256 _amount, address _user) external returns (bool);\n\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal) external;\n\n    function checkSponsorship(address sender, uint256 _amount) external view;\n\n    //only orderbook\n    function increaseBidRate(address _user, uint256 _price) external;\n\n    function decreaseBidRate(address _user, uint256 _price) external;\n\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external;\n\n    // only owner\n    function setMinRental(uint256 _newDivisor) external;\n\n    function setMaxContractBalance(uint256) external;\n\n    function changeGlobalPause() external;\n\n    function changePauseMarket(address _market, bool _paused) external;\n\n    function toggleWhitelist() external;\n\n    // only factory\n    function unPauseMarket(address _market) external;\n\n    // only markets\n    function payRent(uint256) external returns (uint256);\n\n    function payout(address, uint256) external returns (bool);\n\n    function refundUser(address _user, uint256 _refund) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function updateLastRentalTime(address) external;\n}\n\ninterface IRCMarket {\n    enum States {\n        CLOSED,\n        OPEN,\n        LOCKED,\n        WITHDRAW\n    }\n    enum Mode {\n        CLASSIC,\n        WINNER_TAKES_ALL,\n        SAFE_MODE\n    }\n\n    function getWinnerFromOracle() external;\n\n    function setAmicableResolution(uint256 _winningOutcome) external;\n\n    function lockMarket() external;\n\n    function claimCard(uint256 _card) external;\n\n    function rentAllCards(uint256 _maxSumOfPrices) external;\n\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) external;\n\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external;\n\n    function collectRent(uint256 _cardId) external returns (bool);\n\n    function exitAll() external;\n\n    function exit(uint256) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function sponsor(uint256 _amount) external;\n\n    function circuitBreaker() external;\n\n    // payouts\n    function withdraw() external;\n\n    function payArtist() external;\n\n    function payMarketCreator() external;\n\n    function payAffiliate() external;\n\n    function payCardAffiliate(uint256) external;\n\n    // view functions\n    function nfthub() external view returns (IRCNftHubL2);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function factory() external view returns (IRCFactory);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function realitio() external view returns (IRealitio);\n\n    function mode() external view returns (Mode);\n\n    function isMarket() external view returns (bool);\n\n    function numberOfCards() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function state() external view returns (States);\n\n    function getTokenId(uint256 _card) external view returns (uint256 _tokenId);\n\n    function cardAccountingIndex() external view returns (uint256);\n\n    function accountingComplete() external view returns (bool);\n\n    // prices, deposits, rent\n\n    function rentCollectedPerUser(address) external view returns (uint256);\n\n    function rentCollectedPerUserPerCard(address, uint256)\n        external\n        view\n        returns (uint256);\n\n    function totalRentCollected() external view returns (uint256);\n\n    function exitedTimestamp(address) external view returns (uint256);\n\n    //parameters\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxRentIterations() external view returns (uint256);\n\n    // time\n    function timeHeld(uint256 _card, address _user)\n        external\n        view\n        returns (uint256);\n\n    function timeLastCollected(uint256 _card) external view returns (uint256);\n\n    function longestOwner(uint256 _card) external view returns (address);\n\n    function marketOpeningTime() external view returns (uint32);\n\n    function marketLockingTime() external view returns (uint32);\n\n    function oracleResolutionTime() external view returns (uint32);\n\n    // payout settings\n    function winningOutcome() external view returns (uint256);\n\n    function userAlreadyWithdrawn(address) external view returns (bool);\n\n    function artistAddress() external view returns (address);\n\n    function artistCut() external view returns (uint256);\n\n    function artistPaid() external view returns (bool);\n\n    function affiliateAddress() external view returns (address);\n\n    function affiliateCut() external view returns (uint256);\n\n    function affiliatePaid() external view returns (bool);\n\n    function winnerCut() external view returns (uint256);\n\n    function marketCreatorAddress() external view returns (address);\n\n    function creatorCut() external view returns (uint256);\n\n    function creatorPaid() external view returns (bool);\n\n    function cardAffiliateAddresses(uint256) external view returns (address);\n\n    function cardAffiliateCut() external view returns (uint256);\n\n    // oracle\n\n    function questionId() external view returns (bytes32);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function isFinalized() external view returns (bool);\n\n    // setup\n    function initialize(\n        Mode _mode,\n        uint32[] calldata _timestamps,\n        uint256 _numberOfCards,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] calldata _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion,\n        uint256 _nftsToAward\n    ) external;\n\n    function transferCard(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external;\n}\n\ninterface IRCOrderbook {\n    struct Bid {\n        address market;\n        address next;\n        address prev;\n        uint64 card;\n        uint128 price;\n        uint64 timeHeldLimit;\n    }\n\n    function index(\n        address _market,\n        address _user,\n        uint256 _token\n    ) external view returns (uint256);\n\n    function ownerOf(address, uint256) external view returns (address);\n\n    function closedMarkets(uint256) external view returns (address);\n\n    function userClosedMarketIndex(address) external view returns (uint256);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function maxSearchIterations() external view returns (uint256);\n\n    function maxDeletions() external view returns (uint256);\n\n    function cleaningLoops() external view returns (uint256);\n\n    function marketCloseLimit() external view returns (uint256);\n\n    function nonce() external view returns (uint256);\n\n    function cleanWastePile() external;\n\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view returns (Bid memory);\n\n    function setTreasuryAddress(address _newTreasury) external;\n\n    function addBidToOrderbook(\n        address _user,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external;\n\n    function removeBidFromOrderbook(address _user, uint256 _token) external;\n\n    function closeMarket() external returns (bool);\n\n    function findNewOwner(uint256 _token, uint256 _timeOwnershipChanged)\n        external;\n\n    function getBidValue(address _user, uint256 _token)\n        external\n        view\n        returns (uint256);\n\n    function getTimeHeldlimit(address _user, uint256 _token)\n        external\n        returns (uint256);\n\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) external view returns (bool);\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeHeldLimit\n    ) external;\n\n    function removeUserFromOrderbook(address _user) external;\n\n    function removeOldBids(address _user) external;\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeToReduce\n    ) external;\n\n    function setDeletionLimit(uint256 _deletionLimit) external;\n\n    function setCleaningLimit(uint256 _cleaningLimit) external;\n\n    function setSearchLimit(uint256 _searchLimit) external;\n\n    function setMarketCloseLimit(uint256 _marketCloseLimit) external;\n}\n\ninterface IRCLeaderboard {\n    function treasury() external view returns (IRCTreasury);\n\n    function market() external view returns (IRCMarket);\n\n    function NFTsToAward(address _market) external view returns (uint256);\n\n    function updateLeaderboard(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeld\n    ) external;\n\n    function claimNFT(address _user, uint256 _card) external;\n}\n\ninterface IRealitio {\n    function askQuestion(\n        uint256 template_id,\n        string calldata question,\n        address arbitrator,\n        uint32 timeout,\n        uint32 opening_ts,\n        uint256 nonce\n    ) external payable returns (bytes32);\n\n    function resultFor(bytes32 question_id) external view returns (bytes32);\n\n    function isFinalized(bytes32 question_id) external view returns (bool);\n\n    function getContentHash(bytes32 question_id)\n        external\n        view\n        returns (bytes32);\n}\n\ninterface IRCNftHubL2 {\n    function marketTracker(uint256) external view returns (address);\n\n    function ownerOf(uint256) external view returns (address);\n\n    function tokenURI(uint256) external view returns (string memory);\n\n    function addMarket(address) external;\n\n    function totalSupply() external view returns (uint256 nftCount);\n\n    function mint(\n        address,\n        uint256,\n        string calldata\n    ) external;\n\n    function transferNft(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function deposit(address user, bytes calldata depositData) external;\n\n    function withdraw(uint256 tokenId) external;\n\n    function withdrawWithMetadata(uint256 tokenId) external;\n}\n\n\n",
        "CodeNames": [
            "RCOrderbook.sol",
            "RCFull.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-01",
                "Location": [
                    "//solidity\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L549\n function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)  external  override  onlyMarkets  {\n...\n    // delete current owner\n    do {\n        _newPrice = _removeBidFromOrderbookIgnoreOwner( _head.next, _market, _card );\n        _loopCounter++;             // delete next bid if foreclosed\n    } while (    treasury.foreclosureTimeUser( _head.next, _newPrice,  _timeOwnershipChanged ) <  minimumTimeToOwnTo &&\n            _loopCounter < maxDeletions );\n\n    if (_loopCounter != maxDeletions) {   // the old owner is dead, long live the new owner\n        _newOwner = ....\n        ...\n    } else {\n        // we hit the limit, save the old owner, we'll try again next time\n        ...\n    }\n}\n"
                ],
                "Type": "  findNewOwner  edgecase",
                "Description": "\nIn the function findNewOwner of RCOrderbook, as loop is done which included the check  _loopCounter < maxDeletions\nAfterwards, a check is done for  \"(_loopCounter != maxDeletions)\" to determine if the processing is finished.\nIf _loopCounter == maxDeletions then the conclusion is that it isn't finished yet.\n\nHowever, there is the edgecase that the processing might just be finished at the same time as _loopCounter == maxDeletions.\n\nYou can see this the best if you assume maxDeletions==1, in that case it will never draw the conclusion it is finished.\nOf course having maxDeletions==1 is very unlikely in practice.\n\nsolidity\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L549\n function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)  external  override  onlyMarkets  {\n...\n    // delete current owner\n    do {\n        _newPrice = _removeBidFromOrderbookIgnoreOwner( _head.next, _market, _card );\n        _loopCounter++;             // delete next bid if foreclosed\n    } while (    treasury.foreclosureTimeUser( _head.next, _newPrice,  _timeOwnershipChanged ) <  minimumTimeToOwnTo &&\n            _loopCounter < maxDeletions );\n\n    if (_loopCounter != maxDeletions) {   // the old owner is dead, long live the new owner\n        _newOwner = ....\n        ...\n    } else {\n        // we hit the limit, save the old owner, we'll try again next time\n        ...\n    }\n}\n\n\n",
                "Repair": "Recommend using a different way to determine that the processing is done. This could save some gas.\nNote: the additional check also costs gas, so you have to verify the end result.\n\nPerhaps in setDeletionLimit, doublecheck that _deletionLimit  1.\n\nSplidge (Reality Cards) confirmed and disagreed with severity(https://github.com/code-423n4/2021-08-realitycards-findings/issues/27#issuecomment-905499584):\n  oh wow, this is actually a really big problem. It's easier to see it if maxDeletions is 1 but it exists with any size of maxDeletions.\n Whenever we find a valid owner on the final iteration of the loop the if statement will simply check if it was the final loop. That valid owner is then assumed to be invalid and saved for the next transaction to try and find a new owner. When that next transaction happens the valid owner is immediately deleted and not given any ownership of the card at all.\n I think this just falls short of 3 (High risk) because I don't think it'd be possible for an attacker to engineer the situation to have a particular user deleted without ownership. But I believe this would count as 2 (Med risk) because the protocol \"availability could be impacted\"(https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr) for the user that is deleted.\n\nSplidge (Reality Cards) commented(https://github.com/code-423n4/2021-08-realitycards-findings/issues/27#issuecomment-905523120):\n  I have since thought of an attack that could have used this and might raise it to 3 (High risk).\n\n Due to the difficultly of monitoring which cards you own all the time a valid strategy which some users employ is to bid high enough to scare off other users (usually bidding significantly beyond the 10% minimum increase). Suppose Alice employs this strategy by bidding $100 on a card that was previously only $10.\n Mal (our attacker) wishes to rent the card but wants to pay less than $100. Mal could use Sybil accounts to place maxDeletions 1 bids all for the minimum rental duration (only funding the accounts for the minimum duration). Mal would then need to wait for the minimum duration of all these bids to expire, (maxDeletions 1 ) * minimumRentalDuration\n Once this has completed Mal can place a bid at $11, this will trigger a rent collection which will attempt to findNewOwner, Alice being the user that was found on the last iteration of the loop would be considered as invalid. There will not be a change of ownership or any events emitted about this until the next rent collection is triggered.\n This means that the UI would still consider Alice to be the owner of card (Mals' Sybil bids having had LogRemoveFromOrderbook and LogUserForeclosed events emitted) and other users might not consider trying to outbid this, whereas actually Mal is accruing time at a significantly cheaper rate.\n\n Thinking about it, this doesn't really even need Alice at all, Mal could have placed all the higher bids to simultaneously scare off other users while renting at a lower price.\n\n I think the fix is relatively simple, by checking if we found a valid user OR hit the deletion limit we can make it so that we don't skip any bids. This would then leave Alice (or Mal in the other version) correctly having to pay for the time at the higher price.\n\n0xean (judge) commented(https://github.com/code-423n4/2021-08-realitycards-findings/issues/27#issuecomment-911673904):\n  upgrading based on sponsors analysis\n\nSplidge (Reality Cards) patched(https://github.com/code-423n4/2021-08-realitycards-findings/issues/27#issuecomment-914180653):\n  Fixed here(https://github.com/RealityCards/RealityCards-Contracts/commit/9f81f683ea0d2ab41ab91ba9188baf594012c295)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\n// Just a handy file to copy/paste into remix\n\ninterface IRCFactory {\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string calldata _realitioQuestion,\n        uint256 _sponsorship\n    ) external returns (address);\n\n    function mintCopyOfNFT(address _user, uint256 _tokenId) external;\n\n    // view functions\n\n    function nfthub() external view returns (address);\n\n    function ipfsHash(address) external view returns (string memory);\n\n    function slugToAddress(string memory) external view returns (address);\n\n    function addressToSlug(address) external view returns (string memory);\n\n    function marketInfoResults() external view returns (uint256);\n\n    function treasury() external view returns (address);\n\n    function orderbook() external view returns (address);\n\n    function leaderboard() external view returns (address);\n\n    function realitio() external view returns (address);\n\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address[] memory);\n\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address);\n\n    function referenceContractAddress() external view returns (address);\n\n    function referenceContractVersion() external view returns (uint256);\n\n    function sponsorshipRequired() external view returns (uint256);\n\n    function advancedWarning() external view returns (uint32);\n\n    function maximumDuration() external view returns (uint32);\n\n    function minimumDuration() external view returns (uint32);\n\n    function marketCreationGovernorsOnly() external view returns (bool);\n\n    function approvedAffiliatesOnly() external view returns (bool);\n\n    function approvedArtistsOnly() external view returns (bool);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function cardLimit() external view returns (uint256);\n\n    function getPotDistribution() external view returns (uint256[5] memory);\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function isMarketApproved(address) external view returns (bool);\n\n    function marketPausedDefaultState() external view returns (bool);\n\n    function mintMarketNFT(uint256 _card) external;\n\n    function getOracleSettings()\n        external\n        view\n        returns (\n            IRealitio oracle,\n            address arbitratorAddress,\n            uint32 _timeout\n        );\n\n    // only Governors\n    function changeMarketApproval(address _market) external;\n\n    function addArtist(address _newArtist) external;\n\n    function removeArtist(address _oldArtist) external;\n\n    function addAffiliate(address _newAffiliate) external;\n\n    function removeAffiliate(address _oldAffiliate) external;\n\n    // only Owner\n    function setMarketPausedDefaultState(bool _state) external;\n\n    function setTimeout(uint32 _newTimeout) external;\n\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        external;\n\n    function setArbitrator(address _newAddress) external;\n\n    function setRealitioAddress(address _newAddress) external;\n\n    function maxRentIterations() external view returns (uint256);\n\n    function maxRentIterationsToLockMarket() external view returns (uint256);\n\n    function setCardLimit(uint256 _cardLimit) external;\n\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease) external;\n\n    function setNumberOfNFTsToAward(uint256 _NFTsToAward) external;\n\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external;\n\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) external;\n\n    function changeMarketCreationGovernorsOnly() external;\n\n    function changeApprovedArtistsOnly() external;\n\n    function changeApprovedAffilliatesOnly() external;\n\n    function setSponsorshipRequired(uint256 _amount) external;\n\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external;\n\n    function setMarketInfoResults(uint256 _results) external;\n\n    // only UberOwner\n    function setReferenceContractAddress(address _newAddress) external;\n\n    function setOrderbookAddress(IRCOrderbook _newAddress) external;\n\n    function setLeaderboardAddress(IRCLeaderboard _newAddress) external;\n\n    function setNftHubAddress(IRCNftHubL2 _newAddress) external;\n}\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRCTreasury {\n    function setTokenAddress(address _newToken) external;\n\n    function grantRole(string memory role, address account) external;\n\n    function grantRole(bytes32, address) external;\n\n    function revokeRole(string memory role, address account) external;\n\n    function revokeRole(bytes32, address) external;\n\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        external\n        returns (uint256 newTimeLastCollectedOnForeclosure);\n\n    function topupMarketBalance(uint256 _amount) external;\n\n    function assessForeclosure(address _user) external;\n\n    // view functions\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view returns (uint256);\n\n    function bridgeAddress() external view returns (address);\n\n    function checkPermission(bytes32, address) external view returns (bool);\n\n    function erc20() external view returns (IERC20);\n\n    function factory() external view returns (IRCFactory);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function isForeclosed(address) external view returns (bool);\n\n    function userTotalBids(address) external view returns (uint256);\n\n    function userDeposit(address) external view returns (uint256);\n\n    function totalDeposits() external view returns (uint256);\n\n    function marketPot(address) external view returns (uint256);\n\n    function totalMarketPots() external view returns (uint256);\n\n    function marketBalance() external view returns (uint256);\n\n    function marketBalanceTopup() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxContractBalance() external view returns (uint256);\n\n    function globalPause() external view returns (bool);\n\n    function addMarket(address _market, bool paused) external;\n\n    function marketPaused(address) external view returns (bool);\n\n    function batchWhitelist(address[] calldata _users, bool add) external;\n\n    function marketWhitelistCheck(address _user) external returns (bool);\n\n    function lockMarketPaused(address _market) external view returns (bool);\n\n    function setBridgeAddress(address _newAddress) external;\n\n    function setOrderbookAddress(address _newAddress) external;\n\n    function setLeaderboardAddress(address _newAddress) external;\n\n    function setFactoryAddress(address _newFactory) external;\n\n    function deposit(uint256 _amount, address _user) external returns (bool);\n\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal) external;\n\n    function checkSponsorship(address sender, uint256 _amount) external view;\n\n    //only orderbook\n    function increaseBidRate(address _user, uint256 _price) external;\n\n    function decreaseBidRate(address _user, uint256 _price) external;\n\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external;\n\n    // only owner\n    function setMinRental(uint256 _newDivisor) external;\n\n    function setMaxContractBalance(uint256) external;\n\n    function changeGlobalPause() external;\n\n    function changePauseMarket(address _market, bool _paused) external;\n\n    function toggleWhitelist() external;\n\n    // only factory\n    function unPauseMarket(address _market) external;\n\n    // only markets\n    function payRent(uint256) external returns (uint256);\n\n    function payout(address, uint256) external returns (bool);\n\n    function refundUser(address _user, uint256 _refund) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function updateLastRentalTime(address) external;\n}\n\ninterface IRCMarket {\n    enum States {\n        CLOSED,\n        OPEN,\n        LOCKED,\n        WITHDRAW\n    }\n    enum Mode {\n        CLASSIC,\n        WINNER_TAKES_ALL,\n        SAFE_MODE\n    }\n\n    function getWinnerFromOracle() external;\n\n    function setAmicableResolution(uint256 _winningOutcome) external;\n\n    function lockMarket() external;\n\n    function claimCard(uint256 _card) external;\n\n    function rentAllCards(uint256 _maxSumOfPrices) external;\n\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) external;\n\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external;\n\n    function collectRent(uint256 _cardId) external returns (bool);\n\n    function exitAll() external;\n\n    function exit(uint256) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function sponsor(uint256 _amount) external;\n\n    function circuitBreaker() external;\n\n    // payouts\n    function withdraw() external;\n\n    function payArtist() external;\n\n    function payMarketCreator() external;\n\n    function payAffiliate() external;\n\n    function payCardAffiliate(uint256) external;\n\n    // view functions\n    function nfthub() external view returns (IRCNftHubL2);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function factory() external view returns (IRCFactory);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function realitio() external view returns (IRealitio);\n\n    function mode() external view returns (Mode);\n\n    function isMarket() external view returns (bool);\n\n    function numberOfCards() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function state() external view returns (States);\n\n    function getTokenId(uint256 _card) external view returns (uint256 _tokenId);\n\n    function cardAccountingIndex() external view returns (uint256);\n\n    function accountingComplete() external view returns (bool);\n\n    // prices, deposits, rent\n\n    function rentCollectedPerUser(address) external view returns (uint256);\n\n    function rentCollectedPerUserPerCard(address, uint256)\n        external\n        view\n        returns (uint256);\n\n    function totalRentCollected() external view returns (uint256);\n\n    function exitedTimestamp(address) external view returns (uint256);\n\n    //parameters\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxRentIterations() external view returns (uint256);\n\n    // time\n    function timeHeld(uint256 _card, address _user)\n        external\n        view\n        returns (uint256);\n\n    function timeLastCollected(uint256 _card) external view returns (uint256);\n\n    function longestOwner(uint256 _card) external view returns (address);\n\n    function marketOpeningTime() external view returns (uint32);\n\n    function marketLockingTime() external view returns (uint32);\n\n    function oracleResolutionTime() external view returns (uint32);\n\n    // payout settings\n    function winningOutcome() external view returns (uint256);\n\n    function userAlreadyWithdrawn(address) external view returns (bool);\n\n    function artistAddress() external view returns (address);\n\n    function artistCut() external view returns (uint256);\n\n    function artistPaid() external view returns (bool);\n\n    function affiliateAddress() external view returns (address);\n\n    function affiliateCut() external view returns (uint256);\n\n    function affiliatePaid() external view returns (bool);\n\n    function winnerCut() external view returns (uint256);\n\n    function marketCreatorAddress() external view returns (address);\n\n    function creatorCut() external view returns (uint256);\n\n    function creatorPaid() external view returns (bool);\n\n    function cardAffiliateAddresses(uint256) external view returns (address);\n\n    function cardAffiliateCut() external view returns (uint256);\n\n    // oracle\n\n    function questionId() external view returns (bytes32);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function isFinalized() external view returns (bool);\n\n    // setup\n    function initialize(\n        Mode _mode,\n        uint32[] calldata _timestamps,\n        uint256 _numberOfCards,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] calldata _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion,\n        uint256 _nftsToAward\n    ) external;\n\n    function transferCard(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external;\n}\n\ninterface IRCOrderbook {\n    struct Bid {\n        address market;\n        address next;\n        address prev;\n        uint64 card;\n        uint128 price;\n        uint64 timeHeldLimit;\n    }\n\n    function index(\n        address _market,\n        address _user,\n        uint256 _token\n    ) external view returns (uint256);\n\n    function ownerOf(address, uint256) external view returns (address);\n\n    function closedMarkets(uint256) external view returns (address);\n\n    function userClosedMarketIndex(address) external view returns (uint256);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function maxSearchIterations() external view returns (uint256);\n\n    function maxDeletions() external view returns (uint256);\n\n    function cleaningLoops() external view returns (uint256);\n\n    function marketCloseLimit() external view returns (uint256);\n\n    function nonce() external view returns (uint256);\n\n    function cleanWastePile() external;\n\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view returns (Bid memory);\n\n    function setTreasuryAddress(address _newTreasury) external;\n\n    function addBidToOrderbook(\n        address _user,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external;\n\n    function removeBidFromOrderbook(address _user, uint256 _token) external;\n\n    function closeMarket() external returns (bool);\n\n    function findNewOwner(uint256 _token, uint256 _timeOwnershipChanged)\n        external;\n\n    function getBidValue(address _user, uint256 _token)\n        external\n        view\n        returns (uint256);\n\n    function getTimeHeldlimit(address _user, uint256 _token)\n        external\n        returns (uint256);\n\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) external view returns (bool);\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeHeldLimit\n    ) external;\n\n    function removeUserFromOrderbook(address _user) external;\n\n    function removeOldBids(address _user) external;\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeToReduce\n    ) external;\n\n    function setDeletionLimit(uint256 _deletionLimit) external;\n\n    function setCleaningLimit(uint256 _cleaningLimit) external;\n\n    function setSearchLimit(uint256 _searchLimit) external;\n\n    function setMarketCloseLimit(uint256 _marketCloseLimit) external;\n}\n\ninterface IRCLeaderboard {\n    function treasury() external view returns (IRCTreasury);\n\n    function market() external view returns (IRCMarket);\n\n    function NFTsToAward(address _market) external view returns (uint256);\n\n    function updateLeaderboard(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeld\n    ) external;\n\n    function claimNFT(address _user, uint256 _card) external;\n}\n\ninterface IRealitio {\n    function askQuestion(\n        uint256 template_id,\n        string calldata question,\n        address arbitrator,\n        uint32 timeout,\n        uint32 opening_ts,\n        uint256 nonce\n    ) external payable returns (bytes32);\n\n    function resultFor(bytes32 question_id) external view returns (bytes32);\n\n    function isFinalized(bytes32 question_id) external view returns (bool);\n\n    function getContentHash(bytes32 question_id)\n        external\n        view\n        returns (bytes32);\n}\n\ninterface IRCNftHubL2 {\n    function marketTracker(uint256) external view returns (address);\n\n    function ownerOf(uint256) external view returns (address);\n\n    function tokenURI(uint256) external view returns (string memory);\n\n    function addMarket(address) external;\n\n    function totalSupply() external view returns (uint256 nftCount);\n\n    function mint(\n        address,\n        uint256,\n        string calldata\n    ) external;\n\n    function transferNft(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function deposit(address user, bytes calldata depositData) external;\n\n    function withdraw(uint256 tokenId) external;\n\n    function withdrawWithMetadata(uint256 tokenId) external;\n}\n\n\n",
        "CodeNames": [
            "RCFull.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "UberOwner"
                ],
                "Type": "  UberOwner  has too much power",
                "Description": "\nThe Uber Owner has too much power within the system. This makes the protocol closer to a centralized prediction market whose rules are determined by the Uber Owner. See issue page for referenced code\n\nThe above functions can be used by the Uber Owner to completely change the functionality of the system.\nThis goes well beyond simple setting new constants and fees, the Uber Owner can basically reprogram how the entire protocol works. Not to mention if the address falls into the wrong hands.\n\n",
                "Repair": "Recommend limiting the permission of the Uber Owner to something more manageable and trustable. If upgrades to underlying contracts are required they can be done through a proxy instead, in the standard way.\n\nmcplums (Reality Cards) disputed(https://github.com/code-423n4/2021-08-realitycards-findings/issues/74#issuecomment-906225388):\n  This is a subjective opinionthere is always going to be a compromise between decentralisation and the ability to respond to potential problems. The latter is especially important with a protocol that is so new.\n\n There is no correct answer here, but the current abilities of uberOwner were decided after a lot of thought and are in line with other DeFi protocols.\n\nSplidge (Reality Cards) commented(https://github.com/code-423n4/2021-08-realitycards-findings/issues/74#issuecomment-906236023):\n  I'd just like to add that we did recognize the power of the UberOwner which is why it is separated from the Owner specifically so that we can add additional security to it (in the form of a multisig) and so that we can relinquish this control at the appropriate time.\n This was covered in the readme(https://github.com/code-423n4/2021-08-realitycards#mortar_board-governance-mortar_board).\n And also commented (https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L288-L291)in the code.\n\n0xean (judge) commented(https://github.com/code-423n4/2021-08-realitycards-findings/issues/74#issuecomment-911717998):\n  I think the warden(s) have a valid point here. This is an incredible amount of power for a single address to yield over the protocol, even if backed by a multi-sig.\n\n Is it no an option to 1) pause all activity, and unlock all funds allowing users to withdraw their own funds or 2) pause all activity besides withdraws and implement a time delay between that and the \"rug pull\" function being called.\n\n The readme also states\n\n Alternatively we may wish for this to be a multisig but the normal owner to not be, for convenience.\n\n Without a multisig, I believe this absolutely qualifies as a high severity issue as a compromise of a single end user address compromises the entire system, with a multisig it potentially lowers the severity down to a medium, but its still a risk that is worth highlighting in the system and for the sponsor to scrutinize if there are indeed other mitigation paths that could be taken.\n\n\n"
            },
            {
                "Name": "M-02",
                "Location": [
                    "//solidity\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L586\nfunction setNftHubAddress(IRCNftHubL2 _newAddress) external override onlyUberOwner {\n    require(address(_newAddress) != address(0), \"Must set Address\");\n    nfthub = _newAddress;\n}\n\nfunction setOrderbookAddress(IRCOrderbook _newOrderbook) external override {\n    require( treasury.checkPermission(TREASURY, msgSender()), \"Not approved\" );\n    orderbook = _newOrderbook;\n}\n\nfunction setLeaderboardAddress(IRCLeaderboard _newLeaderboard) external override {\n    require( treasury.checkPermission(TREASURY, msgSender()), \"Not approved\");\n    leaderboard = _newLeaderboard;\n}\n\n//https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L188\nfunction setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {\n    minRentalDayDivisor = _newDivisor;\n}\n"
                ],
                "Type": " Parameter updates not propagated",
                "Description": "\nThere are several functions to update parameters. However these parameters are only updated on the top level and not propagated to the other contracts. This could lead to various unpredictable results.\nExamples are:\nsetNftHubAddress of RCFactory\nsetOrderbookAddress of RCFactory\nsetLeaderboardAddress of RCFactory\nsetMinRental of RCTreasury\n\nsolidity\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L586\nfunction setNftHubAddress(IRCNftHubL2 _newAddress) external override onlyUberOwner {\n    require(address(_newAddress) != address(0), \"Must set Address\");\n    nfthub = _newAddress;\n}\n\nfunction setOrderbookAddress(IRCOrderbook _newOrderbook) external override {\n    require( treasury.checkPermission(TREASURY, msgSender()), \"Not approved\" );\n    orderbook = _newOrderbook;\n}\n\nfunction setLeaderboardAddress(IRCLeaderboard _newLeaderboard) external override {\n    require( treasury.checkPermission(TREASURY, msgSender()), \"Not approved\");\n    leaderboard = _newLeaderboard;\n}\n\n//https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L188\nfunction setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {\n    minRentalDayDivisor = _newDivisor;\n}\n\n\n",
                "Repair": "Recommend implementing a way to notify the underlying contracts of the updates.\n\nSplidge (Reality Cards) acknowledged(https://github.com/code-423n4/2021-08-realitycards-findings/issues/30#issuecomment-904726786):\n  We have come to realise that it is very unlikely we will be able to change certain contracts once they are in-use, the exception being the market where a new reference could be deployed.\n In practice we do use setNftHubAddress shortly after deploying new contracts, this is so that we can continue to use an existing NFT hub that has already been put through Matic Mintable Asset mapping, but changing this while a market is active would cause problems.\n While we accept that changing these parameters on active contracts may be troublesome we will not be making changes at this time, partly because it's useful to be able to change these before the contracts are in use but also due to the potential risk of introducing new problems at this stage in the project.\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRealitio.sol\";\n\n/// @title Reality Cards Factory\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCFactory is NativeMetaTransaction, IRCFactory {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           VARIABLES             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /////// CONTRACT VARIABLES ///////\n    IRCTreasury public override treasury;\n    IRCNftHubL2 public override nfthub;\n    IRCOrderbook public override orderbook;\n    IRCLeaderboard public override leaderboard;\n    IRealitio public override realitio;\n    /// @dev reference contract\n    address public override referenceContractAddress;\n    /// @dev increments each time a new reference contract is added\n    uint256 public override referenceContractVersion;\n    /// @dev market addresses, mode // address\n    /// @dev these are not used for anything, just an easy way to get markets\n    mapping(IRCMarket.Mode => address[]) public marketAddresses;\n\n    ////// BACKUP MODE //////\n    /// @dev should the Graph fail the UI needs a way to poll the contracts for market data\n    /// @dev the IPFS hash for each market\n    mapping(address => string) public override ipfsHash;\n    /// @dev the slug each market is hosted at\n    mapping(string => address) public override slugToAddress;\n    mapping(address => string) public override addressToSlug;\n    /// @dev the number of results to return in the backup view function\n    uint256 public override marketInfoResults;\n\n    ///// GOVERNANCE VARIABLES- OWNER /////\n    /// @dev artist / winner / market creator / affiliate / card affiliate\n    uint256[5] public potDistribution;\n    /// @dev minimum tokens that must be sent when creating market which forms initial pot\n    uint256 public override sponsorshipRequired;\n    /// @dev adjust required price increase (in %)\n    uint256 public override minimumPriceIncreasePercent;\n    /// @dev The number of users that are allowed to mint an NFT\n    uint256 public override nftsToAward;\n    /// @dev market opening time must be at least this many seconds in the future\n    uint32 public override advancedWarning;\n    /// @dev market closing time must be no more than this many seconds in the future\n    uint32 public override maximumDuration;\n    /// @dev market closing time must be at least this many seconds after opening\n    uint32 public override minimumDuration;\n    /// @dev if false, anyone can create markets\n    bool public override marketCreationGovernorsOnly = true;\n    /// @dev if false, anyone can be an affiliate\n    bool public override approvedAffiliatesOnly = true;\n    /// @dev if false, anyone can be an artist\n    bool public override approvedArtistsOnly = true;\n    /// @dev the maximum number of rent collections to perform in a single transaction\n    uint256 public override maxRentIterations;\n    /// @dev the maximum number of rent collections to have performed before locking the market\n    uint256 public override maxRentIterationsToLockMarket;\n    /// @dev the address of the arbitrator\n    address public override arbitrator;\n    /// @dev the time allowed to dispute the oracle answer\n    uint32 public override timeout;\n    /// @dev if true markets default to the paused state\n    bool public override marketPausedDefaultState;\n    /// @dev a limit to the number of NFTs to mint per market\n    uint256 public override cardLimit;\n\n    ///// GOVERNANCE VARIABLES- GOVERNORS /////\n    /// @dev unapproved markets hidden from the interface\n    mapping(address => bool) public override isMarketApproved;\n\n    ///// OTHER /////\n    uint256 public constant PER_MILLE = 1000; // in MegaBip so (1000 = 100%)\n    /// @dev store the tokenURIs for when we need to mint them\n    /// @dev we may want the original and the copies to have slightly different metadata\n    /// @dev so we append the metadata for the copies to the end of this array\n    mapping(address => mapping(uint256 => string)) tokenURIs;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant ARTIST = keccak256(\"ARTIST\");\n    bytes32 public constant AFFILIATE = keccak256(\"AFFILIATE\");\n    bytes32 public constant CARD_AFFILIATE = keccak256(\"CARD_AFFILIATE\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            EVENTS               \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogMarketCreated1(\n        address contractAddress,\n        address treasuryAddress,\n        address nftHubAddress,\n        uint256 referenceContractVersion\n    );\n    event LogMarketCreated2(\n        address contractAddress,\n        IRCMarket.Mode mode,\n        string[] tokenURIs,\n        string ipfsHash,\n        uint32[] timestamps,\n        uint256 totalNftMintCount\n    );\n    event LogMarketApproved(address market, bool approved);\n    event LogMarketTimeRestrictions(\n        uint256 _newAdvancedWarning,\n        uint256 _newMinimumDuration,\n        uint256 _newMaximumDuration\n    );\n    event LogMintNFTCopy(\n        uint256 _originalTokenId,\n        address _newOwner,\n        uint256 _newTokenId\n    );\n    event LogMintNFT(uint256 _cardId, address _market, uint256 _tokenId);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          CONSTRUCTOR            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(\n        IRCTreasury _treasury,\n        address _realitioAddress,\n        address _arbitratorAddress\n    ) {\n        require(address(_treasury) != address(0), \"Must set Address\");\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsFactory\", \"1\");\n\n        // store contract instances\n        treasury = _treasury;\n\n        // initialise adjustable parameters\n        // artist // winner // creator // affiliate // card affiliates\n        setPotDistribution(20, 0, 0, 20, 100); // 2% artist, 2% affiliate, 10% card affiliate\n        setMinimumPriceIncreasePercent(10); // 10%\n        setNumberOfNFTsToAward(3);\n        setCardLimit(100); // safe limit tested and set at 100, can be adjusted later if gas limit changes\n        setMaxRentIterations(50, 25); // safe limit tested and set at 50 & 25, can be adjusted later if gas limit changes\n        // oracle\n        setArbitrator(_arbitratorAddress);\n        setRealitioAddress(_realitioAddress);\n        setTimeout(86400); // 24 hours\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          VIEW FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Fetch the address of the most recently created market\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return the address of the most recent market in the given mode\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        override\n        returns (address)\n    {\n        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];\n    }\n\n    /// @notice Fetch all the market addresses for a given mode\n    /// @param _mode Filter by market mode, 0=Classic 1=Winner Takes All 2=SafeMode\n    /// @return an array of all markets in a given mode\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        override\n        returns (address[] memory)\n    {\n        return marketAddresses[_mode];\n    }\n\n    /// @notice Returns the currently set pot distribution\n    /// @return the pot distribution array: artist, winner, creator, affiliate, card affiliates\n    function getPotDistribution()\n        external\n        view\n        override\n        returns (uint256[5] memory)\n    {\n        return potDistribution;\n    }\n\n    /// @notice fetch the current oracle, arbitrator and timeout settings\n    /// @dev called by the market upon initialise\n    /// @dev not passed to initialise to avoid stack too deep error\n    /// @return Oracle Address\n    /// @return Arbitrator Address\n    /// @return Question timeout in seconds\n    function getOracleSettings()\n        external\n        view\n        override\n        returns (\n            IRealitio,\n            address,\n            uint32\n        )\n    {\n        return (realitio, arbitrator, timeout);\n    }\n\n    /// @notice Returns market addresses and ipfs hashes\n    /// @dev used for the UI backup mode\n    /// @param _mode return markets only in the given mode\n    /// @param _state return markets only in the given state\n    /// @param _skipResults the number of results to skip\n    function getMarketInfo(\n        IRCMarket.Mode _mode,\n        uint256 _state,\n        uint256 _skipResults\n    )\n        external\n        view\n        returns (\n            address[] memory,\n            string[] memory,\n            string[] memory,\n            uint256[] memory\n        )\n    {\n        uint256 _marketIndex = marketAddresses[_mode].length;\n        uint256 _resultNumber = 0;\n        address[] memory _marketAddresses = new address[](marketInfoResults);\n        string[] memory _ipfsHashes = new string[](marketInfoResults);\n        uint256[] memory _potSizes = new uint256[](marketInfoResults);\n        string[] memory _slugs = new string[](marketInfoResults);\n        while (_resultNumber < marketInfoResults && _marketIndex > 1) {\n            _marketIndex--;\n            address _market = marketAddresses[_mode][_marketIndex];\n            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {\n                if (_resultNumber < _skipResults) {\n                    _resultNumber++;\n                } else {\n                    _marketAddresses[_resultNumber] = _market;\n                    _ipfsHashes[_resultNumber] = ipfsHash[_market];\n                    _slugs[_resultNumber] = addressToSlug[_market];\n                    _potSizes[_resultNumber] = IRCMarket(_market)\n                        .totalRentCollected();\n                    _resultNumber++;\n                }\n            }\n        }\n        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    modifier onlyUberOwner() {\n        require(\n            treasury.checkPermission(UBER_OWNER, msgSender()),\n            \"Not approved\"\n        );\n        _;\n    }\n    modifier onlyOwner() {\n        require(treasury.checkPermission(OWNER, msgSender()), \"Not approved\");\n        _;\n    }\n    modifier onlyGovernors() {\n        require(\n            treasury.checkPermission(GOVERNOR, msgSender()),\n            \"Not approved\"\n        );\n        _;\n    }\n    modifier onlyMarkets() {\n        require(treasury.checkPermission(MARKET, msgSender()), \"Not approved\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyOwner modifier\n    // Min price increase & pot distribution emitted by Market.\n    // Advanced Warning and Maximum Duration events emitted here. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUCTOR - PUBLIC \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice update stakeholder payouts\n    /// @dev in MegaBip (so 1000 = 100%)\n    /// @param _artistCut The artist that designed the card\n    /// @param _winnerCut Extra cut for the longest owner\n    /// @param _creatorCut The creator of the market\n    /// @param _affiliateCut An affiliate for the market that doesn't fit into the other cuts\n    /// @param _cardAffiliateCut An affiliate cur for specific cards\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) public override onlyOwner {\n        require(\n            _artistCut +\n                _winnerCut +\n                _creatorCut +\n                _affiliateCut +\n                _cardAffiliateCut <=\n                PER_MILLE,\n            \"Cuts too big\"\n        );\n        potDistribution[0] = _artistCut;\n        potDistribution[1] = _winnerCut;\n        potDistribution[2] = _creatorCut;\n        potDistribution[3] = _affiliateCut;\n        potDistribution[4] = _cardAffiliateCut;\n    }\n\n    /// @notice how much above the current price a user must bid, in %\n    /// @param _percentIncrease the percentage to set, e.g. 10 = 10%\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease)\n        public\n        override\n        onlyOwner\n    {\n        minimumPriceIncreasePercent = _percentIncrease;\n    }\n\n    /// @notice how many NFTs will be awarded to the leaderboard\n    /// @param _nftsToAward the number of NFTs to award\n    function setNumberOfNFTsToAward(uint256 _nftsToAward)\n        public\n        override\n        onlyOwner\n    {\n        nftsToAward = _nftsToAward;\n    }\n\n    /// @notice A limit to the number of NFTs to mint per market\n    /// @dev to avoid gas limits\n    /// @param _cardLimit the limit to set\n    function setCardLimit(uint256 _cardLimit) public override onlyOwner {\n        cardLimit = _cardLimit;\n    }\n\n    /// @notice A limit to the number of rent collections per transaction\n    /// @dev to avoid gas limits\n    /// @param _rentLimit the limit to set\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        public\n        override\n        onlyOwner\n    {\n        maxRentIterations = _rentLimit;\n        maxRentIterationsToLockMarket = _rentLimitLocking;\n    }\n\n    /// @notice set the address of the reality.eth contracts\n    /// @param _newAddress the address to set\n    function setRealitioAddress(address _newAddress) public override onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @notice address of the arbitrator, in case of continued disputes on reality.eth\n    /// @param _newAddress the address to set\n    function setArbitrator(address _newAddress) public override onlyOwner {\n        require(_newAddress != address(0), \"Must set an address\");\n        arbitrator = _newAddress;\n    }\n\n    /// @notice set how long reality.eth waits for disputes before finalising\n    /// @param _newTimeout the timeout to set in seconds, 86400 = 24hrs\n    function setTimeout(uint32 _newTimeout) public override onlyOwner {\n        // event is emitted from the Oracle when the question is asked\n        timeout = _newTimeout;\n    }\n\n    function setMarketPausedDefaultState(bool _state)\n        external\n        override\n        onlyOwner\n    {\n        marketPausedDefaultState = _state;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice whether or not only governors can create the market\n    function changeMarketCreationGovernorsOnly() external override onlyOwner {\n        marketCreationGovernorsOnly = !marketCreationGovernorsOnly;\n    }\n\n    /// @notice whether or not anyone can be an artist\n    function changeApprovedArtistsOnly() external override onlyOwner {\n        approvedArtistsOnly = !approvedArtistsOnly;\n    }\n\n    /// @notice whether or not anyone can be an affiliate\n    function changeApprovedAffilliatesOnly() external override onlyOwner {\n        approvedAffiliatesOnly = !approvedAffiliatesOnly;\n    }\n\n    /// @notice how many tokens must be sent in the createMarket tx which forms the initial pot\n    /// @param _amount the sponsorship required in wei\n    function setSponsorshipRequired(uint256 _amount)\n        external\n        override\n        onlyOwner\n    {\n        sponsorshipRequired = _amount;\n    }\n\n    /// @notice market opening time must be at least this many seconds in the future\n    /// @param _newAdvancedWarning the warning time to set in seconds\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external override onlyOwner {\n        advancedWarning = _newAdvancedWarning;\n        minimumDuration = _newMinimumDuration;\n        maximumDuration = _newMaximumDuration;\n        emit LogMarketTimeRestrictions(\n            _newAdvancedWarning,\n            _newMinimumDuration,\n            _newMaximumDuration\n        );\n    }\n\n    /// @notice Allow the owner to update a token URI.\n    /// @param _market the market address the token belongs to\n    /// @param _cardId the index 0 card id of the token to change\n    /// @param _newTokenURI the new URI to set\n    /// @param _newCopyTokenURI the new URI to set for the copy\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external override onlyOwner {\n        IRCMarket.Mode _mode = IRCMarket(_market).mode();\n        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();\n        tokenURIs[_market][_cardId] = _newTokenURI;\n        tokenURIs[_market][(_cardId + _numberOfCards)] = _newCopyTokenURI;\n        string[] memory _tokenURIs = new string[](_numberOfCards);\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            _tokenURIs[i] = tokenURIs[_market][i];\n        }\n        uint32[] memory _timestamps = new uint32[](3);\n        _timestamps[0] = IRCMarket(_market).marketOpeningTime();\n        _timestamps[1] = IRCMarket(_market).marketLockingTime();\n        _timestamps[2] = IRCMarket(_market).oracleResolutionTime();\n\n        // reuse this event so the frontend can pickup the change\n        emit LogMarketCreated2(\n            _market,\n            IRCMarket.Mode(_mode),\n            _tokenURIs,\n            ipfsHash[_market],\n            _timestamps,\n            nfthub.totalSupply()\n        );\n    }\n\n    /// @notice change how many results are returned from getMarketInfo\n    /// @dev would be better to pass this as a parameter in getMarketInfo\n    /// @dev .. however we are limited because of stack too deep errors\n    function setMarketInfoResults(uint256 _results)\n        external\n        override\n        onlyOwner\n    {\n        // no event needed, only used for the backup view mode\n        marketInfoResults = _results;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - GOVERNORS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev all functions should have onlyGovernors modifier\n\n    /// @notice markets are default hidden from the interface, this reveals them\n    /// @param _market the market address to change approval for\n    function changeMarketApproval(address _market)\n        external\n        override\n        onlyGovernors\n    {\n        require(_market != address(0), \"Must set Address\");\n        // check it's an RC contract\n        require(treasury.checkPermission(MARKET, _market), \"Not Market\");\n        isMarketApproved[_market] = !isMarketApproved[_market];\n        // governors shouldn't have the ability to pause a market, only un-pause.\n        // .. if a governor accidentally approves a market they should seek\n        // .. assistance from the owner to decide if it should be paused.\n        treasury.unPauseMarket(_market);\n        // the market will however be hidden from the UI in the meantime\n        emit LogMarketApproved(_market, isMarketApproved[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551   GOVERNANCE - Role management  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev the following functions could all be performed directly on the treasury\n    /// @dev .. they are here as an interim solution to give governors an easy way\n    /// @dev .. to change all their parameters via the block explorer.\n\n    /// @notice Grant the artist role to an address\n    /// @param _newArtist the address to grant the role of artist\n    function addArtist(address _newArtist) external override onlyGovernors {\n        treasury.grantRole(ARTIST, _newArtist);\n    }\n\n    /// @notice Remove the artist role from an address\n    /// @param _oldArtist the address to revoke the role of artist\n    function removeArtist(address _oldArtist) external override onlyGovernors {\n        treasury.revokeRole(ARTIST, _oldArtist);\n    }\n\n    /// @notice Grant the affiliate role to an address\n    /// @param _newAffiliate the address to grant the role of affiliate\n    function addAffiliate(address _newAffiliate)\n        external\n        override\n        onlyGovernors\n    {\n        treasury.grantRole(AFFILIATE, _newAffiliate);\n    }\n\n    /// @notice Remove the affiliate role from an address\n    /// @param _oldAffiliate the address to revoke the role of affiliate\n    function removeAffiliate(address _oldAffiliate)\n        external\n        override\n        onlyGovernors\n    {\n        treasury.revokeRole(AFFILIATE, _oldAffiliate);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades, this is separated so owner can be\n    /// @dev ..  set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governance functions\n\n    /// @notice change the reference contract for the contract logic\n    /// @param _newAddress the address of the new reference contract to set\n    function setReferenceContractAddress(address _newAddress)\n        external\n        override\n        onlyUberOwner\n    {\n        require(_newAddress != address(0));\n        // check it's an RC contract\n        IRCMarket newContractVariable = IRCMarket(_newAddress);\n        require(newContractVariable.isMarket(), \"Not Market\");\n        // set\n        referenceContractAddress = _newAddress;\n        // increment version\n        referenceContractVersion += 1;\n    }\n\n    /// @notice where the NFTs live\n    /// @param _newAddress the address to set\n    function setNftHubAddress(IRCNftHubL2 _newAddress)\n        external\n        override\n        onlyUberOwner\n    {\n        require(address(_newAddress) != address(0), \"Must set Address\");\n        nfthub = _newAddress;\n    }\n\n    /// @notice set the address of the orderbook contract\n    /// @param _newOrderbook the address to set\n    /// @dev set by the treasury to ensure all contracts use the same orderbook\n    function setOrderbookAddress(IRCOrderbook _newOrderbook) external override {\n        require(\n            treasury.checkPermission(TREASURY, msgSender()),\n            \"Not approved\"\n        );\n        orderbook = _newOrderbook;\n    }\n\n    /// @notice set the address of the leaderboard contract\n    /// @param _newLeaderboard the address to set\n    /// @dev set by the treasury to ensure all contracts use the same leaderboard\n    function setLeaderboardAddress(IRCLeaderboard _newLeaderboard)\n        external\n        override\n    {\n        require(\n            treasury.checkPermission(TREASURY, msgSender()),\n            \"Not approved\"\n        );\n        leaderboard = _newLeaderboard;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         MARKET CREATION         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Creates a new market with the given parameters\n    /// @param _mode 0 = normal, 1 = winner takes all\n    /// @param _ipfsHash the IPFS location of the market metadata\n    /// @param _slug the URL subdomain in the UI\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _tokenURIs location of NFT metadata, originals followed by copies\n    /// @param _artistAddress where to send artist's cut, if any\n    /// @param _affiliateAddress where to send affiliates cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliates cut, if any\n    /// @param _realitioQuestion the details of the event to send to the oracle\n    /// @param _sponsorship amount of sponsorship to create the market with\n    /// @return The address of the new market\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string memory _realitioQuestion,\n        uint256 _sponsorship\n    ) external override returns (address) {\n        address _creator = msgSender();\n\n        // check nfthub has been set\n        require(address(nfthub) != address(0), \"Nfthub not set\");\n\n        // check sponsorship\n        require(\n            _sponsorship >= sponsorshipRequired,\n            \"Insufficient sponsorship\"\n        );\n        treasury.checkSponsorship(_creator, _sponsorship);\n\n        // check the number of NFTs to mint is within limits\n        /// @dev we want different tokenURIs for originals and copies\n        /// @dev ..the copies are appended to the end of the array\n        /// @dev ..so half the array length if the number of tokens.\n        require(\n            (_tokenURIs.length / 2) <= cardLimit,\n            \"Too many tokens to mint\"\n        );\n\n        // check stakeholder addresses\n        // artist\n        if (approvedArtistsOnly) {\n            require(\n                _artistAddress == address(0) ||\n                    treasury.checkPermission(ARTIST, _artistAddress),\n                \"Artist not approved\"\n            );\n        }\n\n        // affiliate\n        require(\n            _cardAffiliateAddresses.length == 0 ||\n                _cardAffiliateAddresses.length == (_tokenURIs.length / 2),\n            \"Card Affiliate Length Error\"\n        );\n        if (approvedAffiliatesOnly) {\n            require(\n                _affiliateAddress == address(0) ||\n                    treasury.checkPermission(AFFILIATE, _affiliateAddress),\n                \"Affiliate not approved\"\n            );\n            // card affiliates\n            for (uint256 i = 0; i < _cardAffiliateAddresses.length; i++) {\n                require(\n                    _cardAffiliateAddresses[i] == address(0) ||\n                        treasury.checkPermission(\n                            CARD_AFFILIATE,\n                            _cardAffiliateAddresses[i]\n                        ),\n                    \"Card affiliate not approved\"\n                );\n            }\n        }\n\n        // check market creator is approved\n        if (marketCreationGovernorsOnly) {\n            require(\n                treasury.checkPermission(GOVERNOR, _creator),\n                \"Not approved\"\n            );\n        }\n\n        _checkTimestamps(_timestamps);\n\n        // create the market and emit the appropriate events\n        // two events to avoid stack too deep error\n        address _newAddress = Clones.clone(referenceContractAddress);\n        emit LogMarketCreated1(\n            _newAddress,\n            address(treasury),\n            address(nfthub),\n            referenceContractVersion\n        );\n        emit LogMarketCreated2(\n            _newAddress,\n            IRCMarket.Mode(_mode),\n            _tokenURIs,\n            _ipfsHash,\n            _timestamps,\n            nfthub.totalSupply()\n        );\n\n        // tell Treasury and NFT hub about new market\n        // before initialize as during initialize the market may call the treasury\n        treasury.addMarket(_newAddress, marketPausedDefaultState);\n        nfthub.addMarket(_newAddress);\n\n        // update internals\n        marketAddresses[IRCMarket.Mode(_mode)].push(_newAddress);\n        ipfsHash[_newAddress] = _ipfsHash;\n        slugToAddress[_slug] = _newAddress;\n        addressToSlug[_newAddress] = _slug;\n\n        // initialize the market\n        IRCMarket(_newAddress).initialize(\n            IRCMarket.Mode(_mode),\n            _timestamps,\n            (_tokenURIs.length / 2),\n            _artistAddress,\n            _affiliateAddress,\n            _cardAffiliateAddresses,\n            _creator,\n            _realitioQuestion,\n            nftsToAward\n        );\n\n        // store token URIs\n        for (uint256 i = 0; i < _tokenURIs.length; i++) {\n            tokenURIs[_newAddress][i] = _tokenURIs[i];\n        }\n\n        // pay sponsorship, if applicable\n        if (_sponsorship > 0) {\n            IRCMarket(_newAddress).sponsor(_creator, _sponsorship);\n        }\n\n        return _newAddress;\n    }\n\n    function _checkTimestamps(uint32[] memory _timestamps) internal view {\n        // check timestamps\n        require(_timestamps.length == 3, \"Incorrect number of array elements\");\n        // check market opening time\n        if (advancedWarning != 0) {\n            // different statements to give clearer revert messages\n            require(\n                _timestamps[0] >= block.timestamp,\n                \"Market opening time not set\"\n            );\n            require(\n                _timestamps[0] - advancedWarning > block.timestamp,\n                \"Market opens too soon\"\n            );\n        }\n        // check market locking time\n        if (maximumDuration != 0) {\n            require(\n                _timestamps[1] < block.timestamp + maximumDuration,\n                \"Market locks too late\"\n            );\n        }\n        require(\n            _timestamps[0] + minimumDuration < _timestamps[1] &&\n                block.timestamp + minimumDuration < _timestamps[1],\n            \"Market lock must be after opening\"\n        );\n        // check oracle resolution time (no more than 1 week after market locking to get result)\n        require(\n            _timestamps[1] + (1 weeks) > _timestamps[2] &&\n                _timestamps[1] <= _timestamps[2],\n            \"Oracle resolution time error\"\n        );\n    }\n\n    /// @notice Called by the markets to mint the original NFTs\n    /// @param _card the card id to be minted\n    function mintMarketNFT(uint256 _card) external override onlyMarkets {\n        uint256 nftHubMintCount = nfthub.totalSupply();\n        address _market = msgSender();\n        nfthub.mint(_market, nftHubMintCount, tokenURIs[_market][_card]);\n        emit LogMintNFT(_card, _market, nftHubMintCount);\n    }\n\n    /// @notice allows the market to mint a copy of the NFT for users on the leaderboard\n    /// @param _user the user to award the NFT to\n    /// @param _cardId the tokenId to copy\n    function mintCopyOfNFT(address _user, uint256 _cardId)\n        external\n        override\n        onlyMarkets\n    {\n        address _market = msgSender();\n        uint256 _newTokenId = nfthub.totalSupply();\n        uint256 _numberOfCards = IRCMarket(_market).numberOfCards();\n        nfthub.mint(\n            _user,\n            _newTokenId,\n            tokenURIs[_market][(_cardId + _numberOfCards)]\n        );\n        emit LogMintNFTCopy(_cardId, _user, _newTokenId);\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\n// Just a handy file to copy/paste into remix\n\ninterface IRCFactory {\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string calldata _realitioQuestion,\n        uint256 _sponsorship\n    ) external returns (address);\n\n    function mintCopyOfNFT(address _user, uint256 _tokenId) external;\n\n    // view functions\n\n    function nfthub() external view returns (address);\n\n    function ipfsHash(address) external view returns (string memory);\n\n    function slugToAddress(string memory) external view returns (address);\n\n    function addressToSlug(address) external view returns (string memory);\n\n    function marketInfoResults() external view returns (uint256);\n\n    function treasury() external view returns (address);\n\n    function orderbook() external view returns (address);\n\n    function leaderboard() external view returns (address);\n\n    function realitio() external view returns (address);\n\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address[] memory);\n\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address);\n\n    function referenceContractAddress() external view returns (address);\n\n    function referenceContractVersion() external view returns (uint256);\n\n    function sponsorshipRequired() external view returns (uint256);\n\n    function advancedWarning() external view returns (uint32);\n\n    function maximumDuration() external view returns (uint32);\n\n    function minimumDuration() external view returns (uint32);\n\n    function marketCreationGovernorsOnly() external view returns (bool);\n\n    function approvedAffiliatesOnly() external view returns (bool);\n\n    function approvedArtistsOnly() external view returns (bool);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function cardLimit() external view returns (uint256);\n\n    function getPotDistribution() external view returns (uint256[5] memory);\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function isMarketApproved(address) external view returns (bool);\n\n    function marketPausedDefaultState() external view returns (bool);\n\n    function mintMarketNFT(uint256 _card) external;\n\n    function getOracleSettings()\n        external\n        view\n        returns (\n            IRealitio oracle,\n            address arbitratorAddress,\n            uint32 _timeout\n        );\n\n    // only Governors\n    function changeMarketApproval(address _market) external;\n\n    function addArtist(address _newArtist) external;\n\n    function removeArtist(address _oldArtist) external;\n\n    function addAffiliate(address _newAffiliate) external;\n\n    function removeAffiliate(address _oldAffiliate) external;\n\n    // only Owner\n    function setMarketPausedDefaultState(bool _state) external;\n\n    function setTimeout(uint32 _newTimeout) external;\n\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        external;\n\n    function setArbitrator(address _newAddress) external;\n\n    function setRealitioAddress(address _newAddress) external;\n\n    function maxRentIterations() external view returns (uint256);\n\n    function maxRentIterationsToLockMarket() external view returns (uint256);\n\n    function setCardLimit(uint256 _cardLimit) external;\n\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease) external;\n\n    function setNumberOfNFTsToAward(uint256 _NFTsToAward) external;\n\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external;\n\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) external;\n\n    function changeMarketCreationGovernorsOnly() external;\n\n    function changeApprovedArtistsOnly() external;\n\n    function changeApprovedAffilliatesOnly() external;\n\n    function setSponsorshipRequired(uint256 _amount) external;\n\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external;\n\n    function setMarketInfoResults(uint256 _results) external;\n\n    // only UberOwner\n    function setReferenceContractAddress(address _newAddress) external;\n\n    function setOrderbookAddress(IRCOrderbook _newAddress) external;\n\n    function setLeaderboardAddress(IRCLeaderboard _newAddress) external;\n\n    function setNftHubAddress(IRCNftHubL2 _newAddress) external;\n}\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRCTreasury {\n    function setTokenAddress(address _newToken) external;\n\n    function grantRole(string memory role, address account) external;\n\n    function grantRole(bytes32, address) external;\n\n    function revokeRole(string memory role, address account) external;\n\n    function revokeRole(bytes32, address) external;\n\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        external\n        returns (uint256 newTimeLastCollectedOnForeclosure);\n\n    function topupMarketBalance(uint256 _amount) external;\n\n    function assessForeclosure(address _user) external;\n\n    // view functions\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view returns (uint256);\n\n    function bridgeAddress() external view returns (address);\n\n    function checkPermission(bytes32, address) external view returns (bool);\n\n    function erc20() external view returns (IERC20);\n\n    function factory() external view returns (IRCFactory);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function isForeclosed(address) external view returns (bool);\n\n    function userTotalBids(address) external view returns (uint256);\n\n    function userDeposit(address) external view returns (uint256);\n\n    function totalDeposits() external view returns (uint256);\n\n    function marketPot(address) external view returns (uint256);\n\n    function totalMarketPots() external view returns (uint256);\n\n    function marketBalance() external view returns (uint256);\n\n    function marketBalanceTopup() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxContractBalance() external view returns (uint256);\n\n    function globalPause() external view returns (bool);\n\n    function addMarket(address _market, bool paused) external;\n\n    function marketPaused(address) external view returns (bool);\n\n    function batchWhitelist(address[] calldata _users, bool add) external;\n\n    function marketWhitelistCheck(address _user) external returns (bool);\n\n    function lockMarketPaused(address _market) external view returns (bool);\n\n    function setBridgeAddress(address _newAddress) external;\n\n    function setOrderbookAddress(address _newAddress) external;\n\n    function setLeaderboardAddress(address _newAddress) external;\n\n    function setFactoryAddress(address _newFactory) external;\n\n    function deposit(uint256 _amount, address _user) external returns (bool);\n\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal) external;\n\n    function checkSponsorship(address sender, uint256 _amount) external view;\n\n    //only orderbook\n    function increaseBidRate(address _user, uint256 _price) external;\n\n    function decreaseBidRate(address _user, uint256 _price) external;\n\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external;\n\n    // only owner\n    function setMinRental(uint256 _newDivisor) external;\n\n    function setMaxContractBalance(uint256) external;\n\n    function changeGlobalPause() external;\n\n    function changePauseMarket(address _market, bool _paused) external;\n\n    function toggleWhitelist() external;\n\n    // only factory\n    function unPauseMarket(address _market) external;\n\n    // only markets\n    function payRent(uint256) external returns (uint256);\n\n    function payout(address, uint256) external returns (bool);\n\n    function refundUser(address _user, uint256 _refund) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function updateLastRentalTime(address) external;\n}\n\ninterface IRCMarket {\n    enum States {\n        CLOSED,\n        OPEN,\n        LOCKED,\n        WITHDRAW\n    }\n    enum Mode {\n        CLASSIC,\n        WINNER_TAKES_ALL,\n        SAFE_MODE\n    }\n\n    function getWinnerFromOracle() external;\n\n    function setAmicableResolution(uint256 _winningOutcome) external;\n\n    function lockMarket() external;\n\n    function claimCard(uint256 _card) external;\n\n    function rentAllCards(uint256 _maxSumOfPrices) external;\n\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) external;\n\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external;\n\n    function collectRent(uint256 _cardId) external returns (bool);\n\n    function exitAll() external;\n\n    function exit(uint256) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function sponsor(uint256 _amount) external;\n\n    function circuitBreaker() external;\n\n    // payouts\n    function withdraw() external;\n\n    function payArtist() external;\n\n    function payMarketCreator() external;\n\n    function payAffiliate() external;\n\n    function payCardAffiliate(uint256) external;\n\n    // view functions\n    function nfthub() external view returns (IRCNftHubL2);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function factory() external view returns (IRCFactory);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function realitio() external view returns (IRealitio);\n\n    function mode() external view returns (Mode);\n\n    function isMarket() external view returns (bool);\n\n    function numberOfCards() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function state() external view returns (States);\n\n    function getTokenId(uint256 _card) external view returns (uint256 _tokenId);\n\n    function cardAccountingIndex() external view returns (uint256);\n\n    function accountingComplete() external view returns (bool);\n\n    // prices, deposits, rent\n\n    function rentCollectedPerUser(address) external view returns (uint256);\n\n    function rentCollectedPerUserPerCard(address, uint256)\n        external\n        view\n        returns (uint256);\n\n    function totalRentCollected() external view returns (uint256);\n\n    function exitedTimestamp(address) external view returns (uint256);\n\n    //parameters\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxRentIterations() external view returns (uint256);\n\n    // time\n    function timeHeld(uint256 _card, address _user)\n        external\n        view\n        returns (uint256);\n\n    function timeLastCollected(uint256 _card) external view returns (uint256);\n\n    function longestOwner(uint256 _card) external view returns (address);\n\n    function marketOpeningTime() external view returns (uint32);\n\n    function marketLockingTime() external view returns (uint32);\n\n    function oracleResolutionTime() external view returns (uint32);\n\n    // payout settings\n    function winningOutcome() external view returns (uint256);\n\n    function userAlreadyWithdrawn(address) external view returns (bool);\n\n    function artistAddress() external view returns (address);\n\n    function artistCut() external view returns (uint256);\n\n    function artistPaid() external view returns (bool);\n\n    function affiliateAddress() external view returns (address);\n\n    function affiliateCut() external view returns (uint256);\n\n    function affiliatePaid() external view returns (bool);\n\n    function winnerCut() external view returns (uint256);\n\n    function marketCreatorAddress() external view returns (address);\n\n    function creatorCut() external view returns (uint256);\n\n    function creatorPaid() external view returns (bool);\n\n    function cardAffiliateAddresses(uint256) external view returns (address);\n\n    function cardAffiliateCut() external view returns (uint256);\n\n    // oracle\n\n    function questionId() external view returns (bytes32);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function isFinalized() external view returns (bool);\n\n    // setup\n    function initialize(\n        Mode _mode,\n        uint32[] calldata _timestamps,\n        uint256 _numberOfCards,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] calldata _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion,\n        uint256 _nftsToAward\n    ) external;\n\n    function transferCard(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external;\n}\n\ninterface IRCOrderbook {\n    struct Bid {\n        address market;\n        address next;\n        address prev;\n        uint64 card;\n        uint128 price;\n        uint64 timeHeldLimit;\n    }\n\n    function index(\n        address _market,\n        address _user,\n        uint256 _token\n    ) external view returns (uint256);\n\n    function ownerOf(address, uint256) external view returns (address);\n\n    function closedMarkets(uint256) external view returns (address);\n\n    function userClosedMarketIndex(address) external view returns (uint256);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function maxSearchIterations() external view returns (uint256);\n\n    function maxDeletions() external view returns (uint256);\n\n    function cleaningLoops() external view returns (uint256);\n\n    function marketCloseLimit() external view returns (uint256);\n\n    function nonce() external view returns (uint256);\n\n    function cleanWastePile() external;\n\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view returns (Bid memory);\n\n    function setTreasuryAddress(address _newTreasury) external;\n\n    function addBidToOrderbook(\n        address _user,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external;\n\n    function removeBidFromOrderbook(address _user, uint256 _token) external;\n\n    function closeMarket() external returns (bool);\n\n    function findNewOwner(uint256 _token, uint256 _timeOwnershipChanged)\n        external;\n\n    function getBidValue(address _user, uint256 _token)\n        external\n        view\n        returns (uint256);\n\n    function getTimeHeldlimit(address _user, uint256 _token)\n        external\n        returns (uint256);\n\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) external view returns (bool);\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeHeldLimit\n    ) external;\n\n    function removeUserFromOrderbook(address _user) external;\n\n    function removeOldBids(address _user) external;\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeToReduce\n    ) external;\n\n    function setDeletionLimit(uint256 _deletionLimit) external;\n\n    function setCleaningLimit(uint256 _cleaningLimit) external;\n\n    function setSearchLimit(uint256 _searchLimit) external;\n\n    function setMarketCloseLimit(uint256 _marketCloseLimit) external;\n}\n\ninterface IRCLeaderboard {\n    function treasury() external view returns (IRCTreasury);\n\n    function market() external view returns (IRCMarket);\n\n    function NFTsToAward(address _market) external view returns (uint256);\n\n    function updateLeaderboard(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeld\n    ) external;\n\n    function claimNFT(address _user, uint256 _card) external;\n}\n\ninterface IRealitio {\n    function askQuestion(\n        uint256 template_id,\n        string calldata question,\n        address arbitrator,\n        uint32 timeout,\n        uint32 opening_ts,\n        uint256 nonce\n    ) external payable returns (bytes32);\n\n    function resultFor(bytes32 question_id) external view returns (bytes32);\n\n    function isFinalized(bytes32 question_id) external view returns (bool);\n\n    function getContentHash(bytes32 question_id)\n        external\n        view\n        returns (bytes32);\n}\n\ninterface IRCNftHubL2 {\n    function marketTracker(uint256) external view returns (address);\n\n    function ownerOf(uint256) external view returns (address);\n\n    function tokenURI(uint256) external view returns (string memory);\n\n    function addMarket(address) external;\n\n    function totalSupply() external view returns (uint256 nftCount);\n\n    function mint(\n        address,\n        uint256,\n        string calldata\n    ) external;\n\n    function transferNft(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function deposit(address user, bytes calldata depositData) external;\n\n    function withdraw(uint256 tokenId) external;\n\n    function withdrawWithMetadata(uint256 tokenId) external;\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCBridge.sol\";\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {\n    using SafeERC20 for IERC20;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public override orderbook;\n    /// @dev leaderboard instance\n    IRCLeaderboard public override leaderboard;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev the Factory so only the Factory can add new markets\n    IRCFactory public override factory;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public override marketBalance;\n    /// @dev a quick check if a user is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 public override marketBalanceTopup;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    /// @dev intended for beta use only, will be disabled after launch\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n    /// @dev allow markets to be restricted to a certain role\n    mapping(address => bytes32) public marketWhitelist;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent, claim or upgrade any cards for specific market\n    mapping(address => bool) public override marketPaused;\n    /// @dev if true, owner has locked the market pause (Governors are locked out)\n    mapping(address => bool) public override lockMarketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant FACTORY = keccak256(\"FACTORY\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant WHITELIST = keccak256(\"WHITELIST\");\n    bytes32 public constant ARTIST = keccak256(\"ARTIST\");\n    bytes32 public constant AFFILIATE = keccak256(\"AFFILIATE\");\n    bytes32 public constant CARD_AFFILIATE = keccak256(\"CARD_AFFILIATE\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n    event LogWhitelistUser(address user, bool allowed);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        /* setup AccessControl\n\n                         UBER_OWNER\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502           \u2502          \u2502            \u2502         \u2502\n          OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD\n            \u2502           \u2502\n         GOVERNOR     MARKET\n            \u2502\n         WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE\n        */\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(UBER_OWNER, _msgSender());\n        _setupRole(OWNER, _msgSender());\n        _setupRole(GOVERNOR, _msgSender());\n        _setupRole(WHITELIST, _msgSender());\n        _setupRole(TREASURY, address(this));\n        _setRoleAdmin(UBER_OWNER, UBER_OWNER);\n        _setRoleAdmin(OWNER, UBER_OWNER);\n        _setRoleAdmin(FACTORY, UBER_OWNER);\n        _setRoleAdmin(ORDERBOOK, UBER_OWNER);\n        _setRoleAdmin(TREASURY, UBER_OWNER);\n        _setRoleAdmin(GOVERNOR, OWNER);\n        _setRoleAdmin(WHITELIST, GOVERNOR);\n        _setRoleAdmin(ARTIST, GOVERNOR);\n        _setRoleAdmin(AFFILIATE, GOVERNOR);\n        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);\n        _setRoleAdmin(MARKET, FACTORY);\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1_000_000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks() {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyRole(OWNER)\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUCTOR - PUBLIC \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @dev this is only a soft check, it is possible to exceed this limit\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyRole(OWNER)\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyRole(OWNER) {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market\n    function changePauseMarket(address _market, bool _paused)\n        external\n        override\n        onlyRole(OWNER)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        marketPaused[_market] = _paused;\n        lockMarketPaused[_market] = marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it\n    function unPauseMarket(address _market)\n        external\n        override\n        onlyRole(FACTORY)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        require(!lockMarketPaused[_market], \"Owner has paused market\");\n        marketPaused[_market] = false;\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyRole(OWNER) {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add/Remove multiple users to the whitelist\n    /// @param _users an array of users to add or remove\n    /// @param add true to add the users\n    function batchWhitelist(address[] calldata _users, bool add)\n        external\n        override\n        onlyRole(GOVERNOR)\n    {\n        if (add) {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.grantRole(WHITELIST, _users[index]);\n            }\n        } else {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.revokeRole(WHITELIST, _users[index]);\n            }\n        }\n    }\n\n    /// @notice Some markets may be restricted to certain roles,\n    /// @notice This function checks if the user has the role requried for a given market\n    /// @dev Used for the markets to check themselves\n    /// @param _user The user to check\n    function marketWhitelistCheck(address _user)\n        external\n        view\n        override\n        returns (bool)\n    {\n        bytes32 requiredRole = marketWhitelist[msgSender()];\n        if (requiredRole == bytes32(0)) {\n            return true;\n        } else {\n            return hasRole(requiredRole, _user);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governance functions\n\n    function setFactoryAddress(address _newFactory)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newFactory != address(0), \"Must set an address\");\n        // factory is also an OWNER and GOVERNOR to use the proxy functions\n        revokeRole(FACTORY, address(factory));\n        revokeRole(OWNER, address(factory));\n        revokeRole(GOVERNOR, address(factory));\n        factory = IRCFactory(_newFactory);\n        grantRole(FACTORY, address(factory));\n        grantRole(OWNER, address(factory));\n        grantRole(GOVERNOR, address(factory));\n    }\n\n    function setOrderbookAddress(address _newOrderbook)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newOrderbook != address(0), \"Must set an address\");\n        revokeRole(ORDERBOOK, address(orderbook));\n        orderbook = IRCOrderbook(_newOrderbook);\n        grantRole(ORDERBOOK, address(orderbook));\n        factory.setOrderbookAddress(orderbook);\n    }\n\n    function setLeaderboardAddress(address _newLeaderboard)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newLeaderboard != address(0), \"Must set an address\");\n        leaderboard = IRCLeaderboard(_newLeaderboard);\n        factory.setLeaderboardAddress(leaderboard);\n    }\n\n    function setTokenAddress(address _newToken)\n        public\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner\n    function globalExit() external onlyRole(UBER_OWNER) {\n        uint256 _balance = erc20.balanceOf(address(this));\n        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised\n        erc20.safeTransfer(msg.sender, _balance);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        external\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(hasRole(WHITELIST, _user), \"Not in whitelist\");\n        }\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        assessForeclosure(_user);\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // step 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.safeTransfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        // do some cleaning up first, it might help avoid their foreclosure\n        orderbook.removeOldBids(_msgSender);\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            // foreclose user, this is requred to remove them from the orderbook\n            isForeclosed[_msgSender] = true;\n            // remove them from the orderbook\n            orderbook.removeUserFromOrderbook(_msgSender);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount)\n        external\n        override\n        balancedBooks\n    {\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n        marketBalanceTopup += _amount;\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (uint256)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            uint256 discrepancy = _amount - marketBalance;\n            if (discrepancy > marketBalanceTopup) {\n                marketBalanceTopup = 0;\n            } else {\n                marketBalanceTopup -= discrepancy;\n            }\n            _amount = marketBalance;\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n        /// @dev return the amount just incase it was adjusted\n        return _amount;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        assessForeclosure(_user);\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        assessForeclosure(_user);\n    }\n\n    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        address _msgSender = msgSender();\n        require(!lockMarketPaused[_msgSender], \"Market is paused\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.safeTransferFrom(_sponsor, address(this), _amount);\n        marketPot[_msgSender] += _amount;\n        totalMarketPots += _amount;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyRole(MARKET)\n    {\n        // update the last rental time\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        // check if this is their first rental (no previous rental calculation)\n        if (user[_user].lastRentCalc == 0) {\n            // we need to start their clock ticking, update their last rental calculation time\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function addMarket(address _market, bool _paused) external override {\n        require(hasRole(FACTORY, msgSender()), \"Not Authorised\");\n        marketPaused[_market] = _paused;\n        AccessControl.grantRole(MARKET, _market);\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice provides the sum total of a users bids across all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyRole(ORDERBOOK) {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !hasRole(MARKET, _newOwner)\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(\n                    user[_newOwner].lastRentCalc,\n                    _timeOwnershipChanged,\n                    _newPrice\n                );\n\n                // they have enough funds, just collect the extra\n                // we can be sure of this because it was checked they can cover the minimum rental\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                    // send an event for the UI to have a timestamp\n                    emit LogAdjustDeposit(_newOwner, 0, false);\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calculation and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calculates the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestamps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /\n                totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +\n                timeLeftOfDeposit;\n\n            if (\n                foreclosureTimeWithoutNewCard > _timeOfNewBid &&\n                _timeOfNewBid != 0\n            ) {\n                // calculate how long they can own the new card for\n                uint256 _rentDifference = rentOwedBetweenTimestamps(\n                    user[_user].lastRentCalc,\n                    _timeOfNewBid,\n                    totalUserDailyRent\n                );\n                uint256 _depositAtTimeOfNewBid = 0;\n\n                if (user[_user].lastRentCalc < _timeOfNewBid) {\n                    // new bid is after user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit -\n                        _rentDifference;\n                } else {\n                    // new bid is before user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit +\n                        _rentDifference;\n                }\n\n                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *\n                    1 days) / (totalUserDailyRent + _newBid);\n\n                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +\n                    _timeLeftOfDepositWithNewBid;\n                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {\n                    return _foreclosureTimeWithNewCard;\n                } else {\n                    // The user couldn't afford to own the new card up to their last\n                    // .. rent calculation, we can't rewind their rent calculation because\n                    // .. of gas limits (there could be many markets having taken rent).\n                    // Therefore unfortunately we can't give any ownership to this user as\n                    // .. this could mean getting caught in a loop we may not be able to\n                    // .. exit because of gas limits (there could be many users in this\n                    // .. situation and we can't leave any unaccounted for).\n                    // This means we return 0 to signify that the user can't afford this\n                    // .. new ownership.\n                    return 0;\n                }\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            if (_newBid == 0) {\n                // if no rentals they'll foreclose after the heat death of the universe\n                return type(uint256).max;\n            } else {\n                return\n                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);\n            }\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        require(_timeToCollectTo != 0, \"Must set collection time\");\n        require(\n            _timeToCollectTo <= block.timestamp,\n            \"Can't collect future rent\"\n        );\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts = ((_timeToCollectTo -\n                    previousCollectionTime) * uint256(user[_user].deposit)) /\n                    rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepositLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets available balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n\n    /// @notice checks if the user should still be foreclosed\n    function assessForeclosure(address _user) public override {\n        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        } else {\n            isForeclosed[_user] = true;\n            emit LogUserForeclosed(_user, true);\n        }\n    }\n\n    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual\n    function checkPermission(bytes32 role, address account)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return AccessControl.hasRole(role, account);\n    }\n\n    function grantRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.grantRole(_role, account);\n    }\n\n    function grantRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, true);\n        }\n        AccessControl.grantRole(role, account);\n    }\n\n    function revokeRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.revokeRole(_role, account);\n    }\n\n    function revokeRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, false);\n        }\n        AccessControl.revokeRole(role, account);\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IRealitio.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCLeaderboard.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\n\n/// @title Reality Cards Market\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            VARIABLES            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    // CONTRACT SETUP\n    uint256 public constant PER_MILLE = 1000; // in MegaBip so (1000 = 100%)\n    /// @dev minimum rental value per day, setting to 24mil means 1 USDC/hour\n    uint256 public constant MIN_RENTAL_VALUE = 24_000_000;\n    /// @dev the number of cards in this market\n    uint256 public override numberOfCards;\n    /// @dev current market state, Closed -> Open -> Locked -> Withdraw\n    States public override state;\n    /// @dev type of event.\n    Mode public override mode;\n    /// @dev so the Factory can check it's a market\n    bool public constant override isMarket = true;\n    /// @dev how many nfts to award to the leaderboard\n    uint256 public override nftsToAward;\n    /// @dev the unique token id for each card\n    uint256[] public tokenIds;\n\n    // CONTRACT VARIABLES\n    IRCTreasury public override treasury;\n    IRCFactory public override factory;\n    IRCNftHubL2 public override nfthub;\n    IRCOrderbook public override orderbook;\n    IRCLeaderboard public override leaderboard;\n    IRealitio public override realitio;\n\n    // PRICE, DEPOSITS, RENT\n    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.\n    mapping(address => uint256) public override rentCollectedPerUser;\n    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout\n    mapping(address => mapping(uint256 => uint256))\n        public\n        override rentCollectedPerUserPerCard;\n    /// @dev an easy way to track the above across all cards\n    uint256 public override totalRentCollected;\n    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)\n    mapping(address => uint256) public override exitedTimestamp;\n\n    // PARAMETERS\n    /// @dev read from the Factory upon market creation, can not be changed for existing market\n    /// @dev the minimum required price increase in %\n    uint256 public override minimumPriceIncreasePercent;\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev maximum number of times to calculate rent in one transaction\n    uint256 public override maxRentIterations;\n    /// @dev maximum number of times to calculate rent and continue locking the market\n    uint256 public maxRentIterationsToLockMarket;\n\n    struct Card {\n        /// @dev how many seconds each user has held each card for, for determining winnings\n        mapping(address => uint256) timeHeld;\n        /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld\n        uint256 totalTimeHeld;\n        /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.\n        uint256 timeLastCollected;\n        /// @dev to track who has owned it the most (for giving NFT to winner)\n        address longestOwner;\n        /// @dev to track the card timeHeldLimit for the current owner\n        uint256 cardTimeLimit;\n        /// @dev card price in wei\n        uint256 cardPrice;\n        /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout\n        uint256 rentCollectedPerCard;\n        /// @dev prevent users claiming twice\n        mapping(address => bool) userAlreadyClaimed; // cardID // user // bool\n        /// @dev has this card affiliate been paid\n        bool cardAffiliatePaid;\n    }\n    mapping(uint256 => Card) public card;\n\n    // TIMESTAMPS\n    /// @dev when the market opens\n    uint32 public override marketOpeningTime;\n    /// @dev when the market locks\n    uint32 public override marketLockingTime;\n    /// @dev when the question can be answered on realitio\n    uint32 public override oracleResolutionTime;\n\n    // PAYOUT VARIABLES\n    /// @dev the winning card if known, otherwise type(uint256).max\n    uint256 public override winningOutcome;\n    /// @dev prevent users withdrawing twice\n    mapping(address => bool) public override userAlreadyWithdrawn;\n    /// @dev the artist\n    address public override artistAddress;\n    uint256 public override artistCut;\n    bool public override artistPaid;\n    /// @dev the affiliate\n    address public override affiliateAddress;\n    uint256 public override affiliateCut;\n    bool public override affiliatePaid;\n    /// @dev the winner\n    uint256 public override winnerCut;\n    /// @dev the market creator\n    address public override marketCreatorAddress;\n    uint256 public override creatorCut;\n    bool public override creatorPaid;\n    /// @dev card specific recipients\n    address[] public override cardAffiliateAddresses;\n    uint256 public override cardAffiliateCut;\n    /// @dev keeps track of which card is next to complete the\n    /// @dev .. accounting for when locking the market\n    uint256 public override cardAccountingIndex;\n    /// @dev has the market locking accounting been completed yet\n    bool public override accountingComplete;\n\n    // ORACLE VARIABLES\n    bytes32 public override questionId;\n    address public override arbitrator;\n    uint32 public override timeout; // the time allowed for the answer to be corrected\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);\n    event LogRentCollection(\n        uint256 rentCollected,\n        uint256 indexed newTimeHeld,\n        uint256 indexed cardId,\n        address indexed owner\n    );\n    event LogContractLocked(bool indexed didTheEventFinish);\n    event LogWinnerKnown(uint256 indexed winningOutcome);\n    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);\n    event LogStakeholderPaid(\n        address indexed paidTo,\n        uint256 indexed amountPaid\n    );\n    event LogRentReturned(\n        address indexed returnedTo,\n        uint256 indexed amountReturned\n    );\n    event LogStateChange(uint256 indexed newState);\n    event LogUpdateTimeHeldLimit(\n        address indexed owner,\n        uint256 newLimit,\n        uint256 cardId\n    );\n    event LogSponsor(address indexed sponsor, uint256 indexed amount);\n    event LogPayoutDetails(\n        address indexed artistAddress,\n        address marketCreatorAddress,\n        address affiliateAddress,\n        address[] cardAffiliateAddresses,\n        uint256 indexed artistCut,\n        uint256 winnerCut,\n        uint256 creatorCut,\n        uint256 affiliateCut,\n        uint256 cardAffiliateCut\n    );\n    event LogSettings(\n        uint256 minRentalDayDivisor,\n        uint256 minimumPriceIncreasePercent,\n        uint256 nftsToAward\n    );\n    event LogLongestOwner(uint256 cardId, address longestOwner);\n    event LogQuestionPostedToOracle(\n        address indexed marketAddress,\n        bytes32 indexed questionId\n    );\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _numberOfCards how many Cards in this market\n    /// @param _artistAddress where to send artist's cut, if any (zero address is valid)\n    /// @param _affiliateAddress where to send affiliate's cut, if any (zero address is valid)\n    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any (zero address is valid)\n    /// @param _marketCreatorAddress where to send market creator's cut, if any (zero address is valid)\n    /// @param _realitioQuestion the question posted to the Oracle\n    function initialize(\n        Mode _mode,\n        uint32[] memory _timestamps,\n        uint256 _numberOfCards,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion,\n        uint256 _nftsToAward\n    ) external override initializer {\n        mode = Mode(_mode);\n\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsMarket\", \"1\");\n\n        // external contract variables:\n        factory = IRCFactory(msgSender());\n        treasury = factory.treasury();\n        nfthub = factory.nfthub();\n        orderbook = factory.orderbook();\n        leaderboard = factory.leaderboard();\n\n        // get adjustable parameters from the factory/treasury\n        uint256[5] memory _potDistribution = factory.getPotDistribution();\n        minRentalDayDivisor = treasury.minRentalDayDivisor();\n        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();\n        maxRentIterations = factory.maxRentIterations();\n        maxRentIterationsToLockMarket = factory.maxRentIterationsToLockMarket();\n\n        // Initialize!\n        winningOutcome = type(uint256).max; // default invalid\n\n        // assign arguments to public variables\n        numberOfCards = _numberOfCards;\n        nftsToAward = _nftsToAward;\n        marketOpeningTime = _timestamps[0];\n        marketLockingTime = _timestamps[1];\n        oracleResolutionTime = _timestamps[2];\n        artistAddress = _artistAddress;\n        marketCreatorAddress = _marketCreatorAddress;\n        affiliateAddress = _affiliateAddress;\n        cardAffiliateAddresses = _cardAffiliateAddresses;\n        artistCut = _potDistribution[0];\n        winnerCut = _potDistribution[1];\n        creatorCut = _potDistribution[2];\n        affiliateCut = _potDistribution[3];\n        cardAffiliateCut = _potDistribution[4];\n        (realitio, arbitrator, timeout) = factory.getOracleSettings();\n        for (uint256 i = 0; i < _numberOfCards; i++) {\n            tokenIds.push(type(uint256).max);\n        }\n\n        // reduce artist cut to zero if zero address set\n        if (_artistAddress == address(0)) {\n            artistCut = 0;\n        }\n\n        // reduce affiliate cut to zero if zero address set\n        if (_affiliateAddress == address(0)) {\n            affiliateCut = 0;\n        }\n\n        // check the validity of card affiliate array.\n        // if not valid, reduce payout to zero\n        if (_cardAffiliateAddresses.length == _numberOfCards) {\n            for (uint256 i = 0; i < _numberOfCards; i++) {\n                if (_cardAffiliateAddresses[i] == address(0)) {\n                    cardAffiliateCut = 0;\n                    break;\n                }\n            }\n        } else {\n            cardAffiliateCut = 0;\n        }\n\n        // if winner takes all mode, set winnerCut to max\n        if (_mode == Mode.WINNER_TAKES_ALL) {\n            winnerCut =\n                (((uint256(PER_MILLE) - artistCut) - creatorCut) -\n                    affiliateCut) -\n                cardAffiliateCut;\n        }\n\n        // post question to Oracle\n        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);\n\n        // move to OPEN immediately if market opening time in the past\n        if (marketOpeningTime <= block.timestamp) {\n            _incrementState();\n        }\n\n        emit LogPayoutDetails(\n            _artistAddress,\n            _marketCreatorAddress,\n            _affiliateAddress,\n            cardAffiliateAddresses,\n            artistCut,\n            winnerCut,\n            creatorCut,\n            affiliateCut,\n            cardAffiliateCut\n        );\n        emit LogSettings(\n            minRentalDayDivisor,\n            minimumPriceIncreasePercent,\n            nftsToAward\n        );\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551            MODIFIERS            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice automatically opens market if appropriate\n    modifier autoUnlock() {\n        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {\n            _incrementState();\n        }\n        _;\n    }\n\n    /// @notice automatically locks market if appropriate\n    modifier autoLock() {\n        if (marketLockingTime <= block.timestamp) {\n            lockMarket();\n        }\n        _;\n    }\n\n    /// @dev can only be called by Card owners\n    modifier onlyTokenOwner(uint256 _token) {\n        require(msgSender() == ownerOf(_token), \"Not owner\");\n        _;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     NFT HUB CONTRACT CALLS      \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice gets the owner of the NFT via their Card Id\n    function ownerOf(uint256 _cardId) public view override returns (address) {\n        require(_cardId < numberOfCards, \"Card does not exist\");\n        if (tokenExists(_cardId)) {\n            uint256 _tokenId = getTokenId(_cardId);\n            return nfthub.ownerOf(_tokenId);\n        } else {\n            return address(this);\n        }\n    }\n\n    /// @notice transfer ERC 721 between users\n    function _transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId\n    ) internal {\n        require(\n            _from != address(0) && _to != address(0),\n            \"Cannot send to/from zero address\"\n        );\n        uint256 _tokenId = getTokenId(_cardId);\n\n        nfthub.transferNft(_from, _to, _tokenId);\n        emit LogNewOwner(_cardId, _to);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called externally by Orderbook\n    function transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external override {\n        require(msgSender() == address(orderbook), \"Not orderbook\");\n        _checkState(States.OPEN);\n        if (_to != _from) {\n            _transferCard(_from, _to, _cardId);\n        }\n        card[_cardId].cardTimeLimit = _timeLimit;\n        card[_cardId].cardPrice = _price;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        ORACLE FUNCTIONS         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev called within initializer only\n    function _postQuestionToOracle(\n        string calldata _question,\n        uint32 _oracleResolutionTime\n    ) internal {\n        uint256 templateId = 2; //template 2 works for all RealityCards questions\n        uint256 nonce = 0; // We don't need to ask it again, always use 0\n        bytes32 questionHash = keccak256(\n            abi.encodePacked(templateId, _oracleResolutionTime, _question)\n        );\n        questionId = keccak256(\n            abi.encodePacked(\n                questionHash,\n                arbitrator,\n                timeout,\n                address(this),\n                nonce\n            )\n        );\n        if (realitio.getContentHash(questionId) != questionHash) {\n            // check if our questionHash matches an existing questionId\n            // otherwise ask the question.\n            questionId = realitio.askQuestion(\n                templateId,\n                _question,\n                arbitrator,\n                timeout,\n                _oracleResolutionTime,\n                nonce\n            );\n        }\n        emit LogQuestionPostedToOracle(address(this), questionId);\n    }\n\n    /// @notice has the oracle finalised\n    function isFinalized() public view override returns (bool) {\n        bool _isFinalized = realitio.isFinalized(questionId);\n        return _isFinalized;\n    }\n\n    /// @dev sets the winning outcome\n    /// @dev market.setWinner() will revert if done twice, because wrong state\n    function getWinnerFromOracle() external override {\n        require(isFinalized(), \"Oracle not finalised\");\n        // check market state to prevent market closing early\n        require(marketLockingTime <= block.timestamp, \"Market not finished\");\n        bytes32 _winningOutcome = realitio.resultFor(questionId);\n        // call the market\n        setWinner(uint256(_winningOutcome));\n    }\n\n    /// @dev admin override of the oracle\n    function setAmicableResolution(uint256 _winningOutcome) external override {\n        require(\n            treasury.checkPermission(keccak256(\"OWNER\"), msgSender()),\n            \"Not authorised\"\n        );\n        setWinner(_winningOutcome);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551  MARKET RESOLUTION FUNCTIONS    \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Checks whether the competition has ended, if so moves to LOCKED state\n    /// @notice May require multiple calls as all accounting must be completed before\n    /// @notice the market should be locked.\n    /// @dev can be called by anyone\n    /// @dev public because called within autoLock modifier & setWinner\n    function lockMarket() public override {\n        _checkState(States.OPEN);\n        require(\n            uint256(marketLockingTime) <= block.timestamp,\n            \"Market has not finished\"\n        );\n\n        bool cardAccountingComplete = false;\n        uint256 rentIterationCounter = 0;\n        // do a final rent collection before the contract is locked down\n        while (cardAccountingIndex < numberOfCards && !accountingComplete) {\n            (cardAccountingComplete, rentIterationCounter) = _collectRent(\n                cardAccountingIndex,\n                rentIterationCounter\n            );\n            if (cardAccountingComplete) {\n                cardAccountingComplete = false;\n                cardAccountingIndex++;\n            }\n            if (cardAccountingIndex == numberOfCards) {\n                accountingComplete = true;\n                break;\n            }\n            if (rentIterationCounter >= maxRentIterations) {\n                break;\n            }\n        }\n        // check the accounting is complete but only continue if we haven't used much gas so far\n        /// @dev using gasleft() would be nice, but it causes problems with tx gas estimations\n        if (\n            accountingComplete &&\n            rentIterationCounter < maxRentIterationsToLockMarket\n        ) {\n            // and check that the orderbook has shut the market\n            if (orderbook.closeMarket()) {\n                // now lock the market\n                _incrementState();\n\n                for (uint256 i = 0; i < numberOfCards; i++) {\n                    if (tokenExists(i)) {\n                        // bring the cards back to the market so the winners get the satisfaction of claiming them\n                        _transferCard(ownerOf(i), address(this), i);\n                    }\n                    emit LogLongestOwner(i, card[i].longestOwner);\n                }\n                emit LogContractLocked(true);\n            }\n        }\n    }\n\n    /// @notice called by getWinnerFromOracle, sets the winner\n    /// @param _winningOutcome the index of the winning card\n    function setWinner(uint256 _winningOutcome) internal {\n        if (state == States.OPEN) {\n            // change the locking time to allow lockMarket to lock\n            /// @dev implementing our own SafeCast as this is the only place we need it\n            uint256 _blockTimestamp = uint32(block.timestamp);\n            require(_blockTimestamp <= type(uint32).max, \"Overflow\");\n            marketLockingTime = uint32(_blockTimestamp);\n            lockMarket();\n        }\n        if (state == States.LOCKED) {\n            // get the winner. This will revert if answer is not resolved.\n            winningOutcome = _winningOutcome;\n            _incrementState();\n            emit LogWinnerKnown(winningOutcome);\n        }\n    }\n\n    /// @notice pays out winnings, or returns funds\n    function withdraw() external override {\n        _checkState(States.WITHDRAW);\n        require(!userAlreadyWithdrawn[msgSender()], \"Already withdrawn\");\n        userAlreadyWithdrawn[msgSender()] = true;\n        if (card[winningOutcome].totalTimeHeld > 0) {\n            _payoutWinnings();\n        } else {\n            _returnRent();\n        }\n    }\n\n    /// @notice the longest owner of each NFT gets to keep it\n    /// @notice users on the leaderboard can make a copy of it\n    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known\n    /// @param _card the id of the card, the index\n    function claimCard(uint256 _card) external override {\n        _checkNotState(States.CLOSED);\n        _checkNotState(States.OPEN);\n        require(\n            !treasury.marketPaused(address(this)) && !treasury.globalPause(),\n            \"Market is Paused\"\n        );\n        address _user = msgSender();\n        require(!card[_card].userAlreadyClaimed[_user], \"Already claimed\");\n        card[_card].userAlreadyClaimed[_user] = true;\n        if (_user == card[_card].longestOwner) {\n            _transferCard(ownerOf(_card), card[_card].longestOwner, _card);\n        } else {\n            leaderboard.claimNFT(_user, _card);\n            factory.mintCopyOfNFT(_user, _card);\n        }\n    }\n\n    /// @notice pays winnings\n    function _payoutWinnings() internal {\n        uint256 _winningsToTransfer = 0;\n        uint256 _remainingCut = ((((uint256(PER_MILLE) - artistCut) -\n            affiliateCut) - cardAffiliateCut) - winnerCut) - creatorCut;\n        // calculate longest owner's extra winnings, if relevant\n        if (card[winningOutcome].longestOwner == msgSender() && winnerCut > 0) {\n            _winningsToTransfer =\n                (totalRentCollected * winnerCut) /\n                (PER_MILLE);\n        }\n        uint256 _remainingPot = 0;\n        if (mode == Mode.SAFE_MODE) {\n            // return all rent paid on winning card\n            _remainingPot =\n                ((totalRentCollected -\n                    card[winningOutcome].rentCollectedPerCard) *\n                    _remainingCut) /\n                PER_MILLE;\n            _winningsToTransfer +=\n                (rentCollectedPerUserPerCard[msgSender()][winningOutcome] *\n                    _remainingCut) /\n                PER_MILLE;\n        } else {\n            // calculate normal winnings, if any\n            _remainingPot = (totalRentCollected * _remainingCut) / (PER_MILLE);\n        }\n        uint256 _winnersTimeHeld = card[winningOutcome].timeHeld[msgSender()];\n        uint256 _numerator = _remainingPot * _winnersTimeHeld;\n        _winningsToTransfer =\n            _winningsToTransfer +\n            (_numerator / card[winningOutcome].totalTimeHeld);\n        require(_winningsToTransfer > 0, \"Not a winner\");\n        _payout(msgSender(), _winningsToTransfer);\n        emit LogWinningsPaid(msgSender(), _winningsToTransfer);\n    }\n\n    /// @notice returns all funds to users in case of invalid outcome\n    function _returnRent() internal {\n        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)\n        uint256 _remainingCut = ((uint256(PER_MILLE) - artistCut) -\n            affiliateCut) - cardAffiliateCut;\n        uint256 _rentCollected = rentCollectedPerUser[msgSender()];\n        require(_rentCollected > 0, \"Paid no rent\");\n        uint256 _rentCollectedAdjusted = (_rentCollected * _remainingCut) /\n            (PER_MILLE);\n        _payout(msgSender(), _rentCollectedAdjusted);\n        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);\n    }\n\n    /// @notice all payouts happen through here\n    function _payout(address _recipient, uint256 _amount) internal {\n        treasury.payout(_recipient, _amount);\n    }\n\n    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)\n    /// @dev they are not called within setWinner() because of the risk of an\n    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings\n    /// @dev [hangover from when ether was native currency, keeping in case we return to this]\n\n    /// @notice pay artist\n    function payArtist() external override {\n        _checkState(States.WITHDRAW);\n        require(!artistPaid, \"Artist already paid\");\n        artistPaid = true;\n        _processStakeholderPayment(artistCut, artistAddress);\n    }\n\n    /// @notice pay market creator\n    function payMarketCreator() external override {\n        _checkState(States.WITHDRAW);\n        require(card[winningOutcome].totalTimeHeld > 0, \"No winner\");\n        require(!creatorPaid, \"Creator already paid\");\n        creatorPaid = true;\n        _processStakeholderPayment(creatorCut, marketCreatorAddress);\n    }\n\n    /// @notice pay affiliate\n    function payAffiliate() external override {\n        _checkState(States.WITHDRAW);\n        require(!affiliatePaid, \"Affiliate already paid\");\n        affiliatePaid = true;\n        _processStakeholderPayment(affiliateCut, affiliateAddress);\n    }\n\n    /// @notice pay card affiliate\n    /// @dev does not call _processStakeholderPayment because it works differently\n    function payCardAffiliate(uint256 _card) external override {\n        _checkState(States.WITHDRAW);\n        require(!card[_card].cardAffiliatePaid, \"Card affiliate already paid\");\n        card[_card].cardAffiliatePaid = true;\n        uint256 _cardAffiliatePayment = (card[_card].rentCollectedPerCard *\n            cardAffiliateCut) / (PER_MILLE);\n        if (_cardAffiliatePayment > 0) {\n            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);\n            emit LogStakeholderPaid(\n                cardAffiliateAddresses[_card],\n                _cardAffiliatePayment\n            );\n        }\n    }\n\n    function _processStakeholderPayment(uint256 _cut, address _recipient)\n        internal\n    {\n        if (_cut > 0) {\n            uint256 _payment = (totalRentCollected * _cut) / (PER_MILLE);\n            _payout(_recipient, _payment);\n            emit LogStakeholderPaid(_recipient, _payment);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             EXTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev basically functions that have _checkState(States.OPEN) on first line\n\n    /// @notice collects rent a specifc card\n    function collectRent(uint256 _cardId) external override returns (bool) {\n        _checkState(States.OPEN);\n        bool _success;\n        (_success, ) = _collectRent(_cardId, 0);\n        if (_success) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice rent every Card at the minimum price\n    /// @param _maxSumOfPrices a limit to the sum of the bids to place\n    function rentAllCards(uint256 _maxSumOfPrices) external override {\n        _checkState(States.OPEN);\n        // check that not being front run\n        uint256 _actualSumOfPrices = 0;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (card[i].cardPrice == 0) {\n                _actualSumOfPrices += MIN_RENTAL_VALUE;\n            } else {\n                _actualSumOfPrices +=\n                    (card[i].cardPrice * (minimumPriceIncreasePercent + 100)) /\n                    100;\n            }\n        }\n        require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");\n\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != msgSender()) {\n                uint256 _newPrice;\n                if (card[i].cardPrice > 0) {\n                    _newPrice =\n                        (card[i].cardPrice *\n                            (minimumPriceIncreasePercent + 100)) /\n                        100;\n                } else {\n                    _newPrice = MIN_RENTAL_VALUE;\n                }\n                newRental(_newPrice, 0, address(0), i);\n            }\n        }\n    }\n\n    /// @notice to rent a Card\n    /// @param _newPrice the price to rent the card for\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _startingPosition where to start looking to insert the bid into the orderbook\n    /// @param _card the index of the card to update\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) public override autoUnlock autoLock {\n        // if the market isn't open then don't do anything else, not reverting\n        // .. will allow autoLock to process the accounting to lock the market\n        if (state == States.OPEN) {\n            require(_newPrice >= MIN_RENTAL_VALUE, \"Price below min\");\n            require(_card < numberOfCards, \"Card does not exist\");\n\n            // if the NFT hasn't been minted, we should probably do that\n            if (!tokenExists(_card)) {\n                tokenIds[_card] = nfthub.totalSupply();\n                factory.mintMarketNFT(_card);\n            }\n\n            address _user = msgSender();\n\n            // prevent re-renting, this limits (but doesn't eliminate) a frontrunning attack\n            require(\n                exitedTimestamp[_user] != block.timestamp,\n                \"Cannot lose and re-rent in same block\"\n            );\n            require(\n                !treasury.marketPaused(address(this)) &&\n                    !treasury.globalPause(),\n                \"Rentals are disabled\"\n            );\n            // restrict certain markets to specific whitelists\n            require(\n                treasury.marketWhitelistCheck(_user),\n                \"Not approved for this market\"\n            );\n\n            // if the user is foreclosed then delete some old bids\n            // .. this could remove their foreclosure\n            if (treasury.isForeclosed(_user)) {\n                orderbook.removeUserFromOrderbook(_user);\n            }\n            require(\n                !treasury.isForeclosed(_user),\n                \"Can't rent while foreclosed\"\n            );\n            if (ownerOf(_card) == _user) {\n                // the owner may only increase by more than X% or reduce their price\n                uint256 _requiredPrice = (card[_card].cardPrice *\n                    (minimumPriceIncreasePercent + 100)) / (100);\n                require(\n                    _newPrice >= _requiredPrice ||\n                        _newPrice < card[_card].cardPrice,\n                    \"Invalid price\"\n                );\n            }\n\n            // do some cleaning up before we collect rent or check their bidRate\n            orderbook.removeOldBids(_user);\n\n            /// @dev ignore the return value and let the user post the bid for the sake of UX\n            _collectRent(_card, 0);\n\n            // check sufficient deposit\n            uint256 _userTotalBidRate = (treasury.userTotalBids(_user) -\n                orderbook.getBidValue(_user, _card)) + _newPrice;\n            require(\n                treasury.userDeposit(_user) >=\n                    _userTotalBidRate / minRentalDayDivisor,\n                \"Insufficient deposit\"\n            );\n\n            _checkTimeHeldLimit(_timeHeldLimit);\n\n            orderbook.addBidToOrderbook(\n                _user,\n                _card,\n                _newPrice,\n                _timeHeldLimit,\n                _startingPosition\n            );\n\n            treasury.updateLastRentalTime(_user);\n        }\n    }\n\n    /// @notice to change your timeHeldLimit without having to re-rent\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _card the index of the card to update\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external\n        override\n    {\n        _checkState(States.OPEN);\n        address _user = msgSender();\n        bool rentCollected;\n        (rentCollected, ) = _collectRent(_card, 0);\n        if (rentCollected) {\n            _checkTimeHeldLimit(_timeHeldLimit);\n\n            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);\n\n            if (ownerOf(_card) == _user) {\n                card[_card].cardTimeLimit = _timeHeldLimit;\n            }\n\n            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);\n        }\n    }\n\n    /// @notice stop renting all cards\n    function exitAll() external override {\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            exit(i);\n        }\n    }\n\n    /// @notice stop renting a card and/or remove from orderbook\n    /// @dev public because called by exitAll()\n    /// @dev doesn't need to be current owner so user can prevent ownership returning to them\n    /// @dev does not apply minimum rental duration, because it returns ownership to the next user\n    /// @dev doesn't revert if non-existant bid because user might be trying to exitAll()\n    /// @param _card The card index to exit\n    function exit(uint256 _card) public override {\n        _checkState(States.OPEN);\n        address _msgSender = msgSender();\n\n        // collectRent first\n        /// @dev ignore the return value and let the user exit the bid for the sake of UX\n        _collectRent(_card, 0);\n\n        if (ownerOf(_card) == _msgSender) {\n            // block frontrunning attack\n            exitedTimestamp[_msgSender] = block.timestamp;\n\n            // if current owner, find a new one\n            orderbook.findNewOwner(_card, block.timestamp);\n            assert(!orderbook.bidExists(_msgSender, address(this), _card));\n        } else {\n            // if not owner, just delete from orderbook\n            if (orderbook.bidExists(_msgSender, address(this), _card)) {\n                // block frontrunning attack\n                exitedTimestamp[_msgSender] = block.timestamp;\n\n                orderbook.removeBidFromOrderbook(_msgSender, _card);\n            }\n        }\n    }\n\n    /// @notice ability to add liquidity to the pot without being able to win.\n    /// @dev called by user, sponsor is msgSender\n    function sponsor(uint256 _amount) external override {\n        address _creator = msgSender();\n        _sponsor(_creator, _amount);\n    }\n\n    /// @notice ability to add liquidity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        address _msgSender = msgSender();\n        if (_msgSender != address(factory)) {\n            _sponsorAddress = _msgSender;\n        }\n        _sponsor(_sponsorAddress, _amount);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         CORE FUNCTIONS          \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551             INTERNAL            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev actually processes the sponsorship\n    function _sponsor(address _sponsorAddress, uint256 _amount) internal {\n        _checkNotState(States.LOCKED);\n        _checkNotState(States.WITHDRAW);\n        require(_amount > 0, \"Must send something\");\n        // send tokens to the Treasury\n        treasury.sponsor(_sponsorAddress, _amount);\n        totalRentCollected = totalRentCollected + _amount;\n        // just so user can get it back if invalid outcome\n        rentCollectedPerUser[_sponsorAddress] =\n            rentCollectedPerUser[_sponsorAddress] +\n            _amount;\n        // allocate equally to each card, in case card specific affiliates\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            card[i].rentCollectedPerCard =\n                card[i].rentCollectedPerCard +\n                (_amount / numberOfCards);\n        }\n        emit LogSponsor(_sponsorAddress, _amount);\n    }\n\n    function _checkTimeHeldLimit(uint256 _timeHeldLimit) internal view {\n        if (_timeHeldLimit != 0) {\n            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;\n            require(_timeHeldLimit >= _minRentalTime, \"Limit too low\");\n        }\n    }\n\n    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls\n    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit\n    /// @param _card the card id to collect rent for\n    /// @return true if the rent collection was completed, (ownership updated to the current time)\n    function _collectRent(uint256 _card, uint256 _counter)\n        internal\n        returns (bool, uint256)\n    {\n        bool shouldContinue = true;\n        while (_counter < maxRentIterations && shouldContinue) {\n            shouldContinue = _collectRentAction(_card);\n            _counter++;\n        }\n        return (!shouldContinue, _counter);\n    }\n\n    /// @notice collects rent for a specific card\n    /// @dev also calculates and updates how long the current user has held the card for\n    /// @dev is not a problem if called externally, but making internal over public to save gas\n    /// @param _card the card id to collect rent for\n    /// @return true if we should repeat the rent collection\n    function _collectRentAction(uint256 _card) internal returns (bool) {\n        address _user = ownerOf(_card);\n        uint256 _timeOfThisCollection = block.timestamp;\n\n        // don't collect rent beyond the locking time\n        if (marketLockingTime <= block.timestamp) {\n            _timeOfThisCollection = marketLockingTime;\n        }\n\n        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)\n        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)\n        if (\n            _user != address(this) &&\n            card[_card].timeLastCollected < _timeOfThisCollection\n        ) {\n            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet\n            uint256 _timeUserForeclosed = treasury.collectRentUser(\n                _user,\n                _timeOfThisCollection\n            );\n\n            // Calculate the card timeLimitTimestamp\n            uint256 _cardTimeLimitTimestamp = card[_card].timeLastCollected +\n                card[_card].cardTimeLimit;\n\n            // input bools\n            bool _foreclosed = _timeUserForeclosed != 0;\n            bool _limitHit = card[_card].cardTimeLimit != 0 &&\n                _cardTimeLimitTimestamp < block.timestamp;\n\n            // outputs\n            bool _newOwner = false;\n            uint256 _refundTime = 0; // seconds of rent to refund the user\n\n            /* Permutations of the events: Foreclosure and Time limit\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n            \u2502Case       \u25021\u25022\u25023\u25024\u2502\n            \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2524\n            \u2502Foreclosure\u25020\u25020\u25021\u25021\u2502\n            \u2502Time Limit \u25020\u25021\u25020\u25021\u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n            */\n\n            if (!_foreclosed && !_limitHit) {\n                // CASE 1\n                // didn't foreclose AND\n                // didn't hit time limit\n                // THEN simple rent collect, same owner\n                _timeOfThisCollection = _timeOfThisCollection;\n                _newOwner = false;\n                _refundTime = 0;\n            } else if (!_foreclosed && _limitHit) {\n                // CASE 2\n                // didn't foreclose AND\n                // did hit time limit\n                // THEN refund rent between time limit and now\n                _timeOfThisCollection = _cardTimeLimitTimestamp;\n                _newOwner = true;\n                _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n            } else if (_foreclosed && !_limitHit) {\n                // CASE 3\n                // did foreclose AND\n                // didn't hit time limit\n                // THEN rent OK, find new owner\n                _timeOfThisCollection = _timeUserForeclosed;\n                _newOwner = true;\n                _refundTime = 0;\n            } else if (_foreclosed && _limitHit) {\n                // CASE 4\n                // did foreclose AND\n                // did hit time limit\n                // THEN if foreclosed first rent ok, otherwise refund after limit\n                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {\n                    // user foreclosed before time limit\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // time limit hit before user foreclosed\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                }\n            }\n            if (_refundTime != 0) {\n                uint256 _refundAmount = (_refundTime * card[_card].cardPrice) /\n                    1 days;\n                treasury.refundUser(_user, _refundAmount);\n            }\n            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens\n\n            if (_newOwner) {\n                orderbook.findNewOwner(_card, _timeOfThisCollection);\n                return true;\n            }\n        } else {\n            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking\n            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental\n            card[_card].timeLastCollected = _timeOfThisCollection;\n        }\n        return false;\n    }\n\n    /// @dev processes actual rent collection and updates the state\n    function _processRentCollection(\n        address _user,\n        uint256 _card,\n        uint256 _timeOfCollection\n    ) internal {\n        uint256 _rentOwed = (card[_card].cardPrice *\n            (_timeOfCollection - card[_card].timeLastCollected)) / 1 days;\n        uint256 _timeHeldToIncrement = (_timeOfCollection -\n            card[_card].timeLastCollected);\n\n        // if the user has a timeLimit, adjust it as necessary\n        if (card[_card].cardTimeLimit != 0) {\n            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);\n            card[_card].cardTimeLimit -= _timeHeldToIncrement;\n        }\n\n        // update time\n        card[_card].timeHeld[_user] += _timeHeldToIncrement;\n        card[_card].totalTimeHeld += _timeHeldToIncrement;\n        card[_card].timeLastCollected = _timeOfCollection;\n\n        // longest owner tracking\n        if (\n            card[_card].timeHeld[_user] >\n            card[_card].timeHeld[card[_card].longestOwner]\n        ) {\n            card[_card].longestOwner = _user;\n        }\n\n        // update amounts\n        /// @dev get back the actual rent collected, it may be less than owed\n        uint256 _rentCollected = treasury.payRent(_rentOwed);\n        card[_card].rentCollectedPerCard += _rentCollected;\n        rentCollectedPerUserPerCard[_user][_card] += _rentCollected;\n        rentCollectedPerUser[_user] += _rentCollected;\n        totalRentCollected += _rentCollected;\n\n        leaderboard.updateLeaderboard(\n            _user,\n            _card,\n            card[_card].timeHeld[_user]\n        );\n        emit LogRentCollection(\n            _rentCollected,\n            _timeHeldToIncrement,\n            _card,\n            _user\n        );\n    }\n\n    function _checkState(States currentState) internal view {\n        require(state == currentState, \"Incorrect state\");\n    }\n\n    function _checkNotState(States currentState) internal view {\n        require(state != currentState, \"Incorrect state\");\n    }\n\n    /// @dev should only be called thrice\n    function _incrementState() internal {\n        state = States(uint256(state) + 1);\n        emit LogStateChange(uint256(state));\n    }\n\n    /// @notice returns the tokenId (the unique NFT index) given the cardId (the market specific index)\n    /// @param _card the market specific index of the card\n    /// @return _tokenId the unique NFT index\n    function getTokenId(uint256 _card)\n        public\n        view\n        override\n        returns (uint256 _tokenId)\n    {\n        require(tokenExists(_card));\n        return tokenIds[_card];\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       VIEW FUNCTIONS            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice Check if the NFT has been minted yet\n    /// @param _card the market specific index of the card\n    /// @return true if the NFT has been minted\n    function tokenExists(uint256 _card) internal view returns (bool) {\n        return tokenIds[_card] != type(uint256).max;\n    }\n\n    /// @dev a simple getter for the time a user has held a given card\n    function timeHeld(uint256 _card, address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return card[_card].timeHeld[_user];\n    }\n\n    /// @dev a simple getter for the time a card last had rent collected\n    function timeLastCollected(uint256 _card)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return card[_card].timeLastCollected;\n    }\n\n    /// @dev a simple getter for the longest owner of a card\n    function longestOwner(uint256 _card)\n        external\n        view\n        override\n        returns (address)\n    {\n        return card[_card].longestOwner;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          BACKUP MODE            \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev in the event of failures in the UI we need a simple reliable way to poll\n    /// @dev ..the contracts for relevant info, this view function helps facilitate this.\n\n    /// @dev quick and easy view function to get all market data relevant to the UI\n    function getMarketInfo()\n        external\n        view\n        returns (\n            States,\n            string memory,\n            uint256,\n            uint256,\n            address[] memory,\n            uint256[] memory\n        )\n    {\n        address[] memory _owners = new address[](numberOfCards);\n        uint256[] memory _prices = new uint256[](numberOfCards);\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            _owners[i] = ownerOf(i);\n            _prices[i] = card[i].cardPrice;\n        }\n        return (\n            state,\n            factory.ipfsHash(address(this)),\n            winningOutcome,\n            totalRentCollected,\n            _owners,\n            _prices\n        );\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        CIRCUIT BREAKER          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev in case Oracle never resolves for any reason\n    /// @dev does not set a winner so same as invalid outcome\n    /// @dev market does not need to be locked, just in case lockMarket bugs out\n    function circuitBreaker() external override {\n        require(\n            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),\n            \"Too early\"\n        );\n        state = States.WITHDRAW;\n        orderbook.closeMarket();\n        emit LogStateChange(uint256(state));\n    }\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCFactory.sol",
            "RCFull.sol",
            "RCTreasury.sol",
            "RCMarket.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-01",
                "Location": [
                    "true",
                    "marketWhitelistCheck()",
                    "marketWhitelist",
                    "newRental()"
                ],
                "Type": " Uninitialized Variable  marketWhitelist  in  RCTreasury.sol ",
                "Description": "\nThe variable, marketWhitelist, is never initialized in the contract RCTreasury.sol. As a result, the function marketWhitelistCheck()  does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return true, even if a market wishes to restrict its users to a specific role.\n\nThe initial state variable is defined in RCTreasury.sol L75(https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L75).\n\n\nThe state variable marketWhitelist is accessed in the function RCTreasury.marketWhitelistCheck() at RCTreasury.sol L269-L281(https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L269-L281).\n\nThe function RCTreasury.marketWhitelistCheck() is called in RCMarket.newRental() at RCMarket.sol L758-L761(https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L758-L761). The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in RCTreasury that allow a market creator to enable this functionality.\n\n",
                "Repair": "Recommend ensuring this behavior is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.\n\nSplidge (Reality Cards) confirmed and disagreed with severity(https://github.com/code-423n4/2021-08-realitycards-findings/issues/18#issuecomment-905413207):\n  I think the severity could be double-checked on this one.\n It's a close one but I'd be tempted to put it under 1 (low risk) as a \"Function incorrect to spec\".\n Regardless, this will be fixed.\n\n Edit: I notice the duplicates were both marked as 1 (low risk).\n\n0xean (judge) commented(https://github.com/code-423n4/2021-08-realitycards-findings/issues/18#issuecomment-910962066):\n  based on \" but the function of the protocol or its availability could be impacted\" in the code4 docs, I am going to agree with warden and leave this as a 2.  The function of the protocol is certainly impacted in a case where the whitelist if not working correctly.\n\n\nSplidge (Reality Cards) patched(https://github.com/code-423n4/2021-08-realitycards-findings/issues/18#issuecomment-914175471):\n  Fixed here(https://github.com/RealityCards/RealityCards-Contracts/commit/1515f87e97be1ed09316340e19caea5c12242c17)\n\n\n"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\n// Just a handy file to copy/paste into remix\n\ninterface IRCFactory {\n    function createMarket(\n        uint32 _mode,\n        string memory _ipfsHash,\n        string memory _slug,\n        uint32[] memory _timestamps,\n        string[] memory _tokenURIs,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        string calldata _realitioQuestion,\n        uint256 _sponsorship\n    ) external returns (address);\n\n    function mintCopyOfNFT(address _user, uint256 _tokenId) external;\n\n    // view functions\n\n    function nfthub() external view returns (address);\n\n    function ipfsHash(address) external view returns (string memory);\n\n    function slugToAddress(string memory) external view returns (address);\n\n    function addressToSlug(address) external view returns (string memory);\n\n    function marketInfoResults() external view returns (uint256);\n\n    function treasury() external view returns (address);\n\n    function orderbook() external view returns (address);\n\n    function leaderboard() external view returns (address);\n\n    function realitio() external view returns (address);\n\n    function getAllMarkets(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address[] memory);\n\n    function getMostRecentMarket(IRCMarket.Mode _mode)\n        external\n        view\n        returns (address);\n\n    function referenceContractAddress() external view returns (address);\n\n    function referenceContractVersion() external view returns (uint256);\n\n    function sponsorshipRequired() external view returns (uint256);\n\n    function advancedWarning() external view returns (uint32);\n\n    function maximumDuration() external view returns (uint32);\n\n    function minimumDuration() external view returns (uint32);\n\n    function marketCreationGovernorsOnly() external view returns (bool);\n\n    function approvedAffiliatesOnly() external view returns (bool);\n\n    function approvedArtistsOnly() external view returns (bool);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function cardLimit() external view returns (uint256);\n\n    function getPotDistribution() external view returns (uint256[5] memory);\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function isMarketApproved(address) external view returns (bool);\n\n    function marketPausedDefaultState() external view returns (bool);\n\n    function mintMarketNFT(uint256 _card) external;\n\n    function getOracleSettings()\n        external\n        view\n        returns (\n            IRealitio oracle,\n            address arbitratorAddress,\n            uint32 _timeout\n        );\n\n    // only Governors\n    function changeMarketApproval(address _market) external;\n\n    function addArtist(address _newArtist) external;\n\n    function removeArtist(address _oldArtist) external;\n\n    function addAffiliate(address _newAffiliate) external;\n\n    function removeAffiliate(address _oldAffiliate) external;\n\n    // only Owner\n    function setMarketPausedDefaultState(bool _state) external;\n\n    function setTimeout(uint32 _newTimeout) external;\n\n    function setMaxRentIterations(uint256 _rentLimit, uint256 _rentLimitLocking)\n        external;\n\n    function setArbitrator(address _newAddress) external;\n\n    function setRealitioAddress(address _newAddress) external;\n\n    function maxRentIterations() external view returns (uint256);\n\n    function maxRentIterationsToLockMarket() external view returns (uint256);\n\n    function setCardLimit(uint256 _cardLimit) external;\n\n    function setMinimumPriceIncreasePercent(uint256 _percentIncrease) external;\n\n    function setNumberOfNFTsToAward(uint256 _NFTsToAward) external;\n\n    function updateTokenURI(\n        address _market,\n        uint256 _cardId,\n        string calldata _newTokenURI,\n        string calldata _newCopyTokenURI\n    ) external;\n\n    function setPotDistribution(\n        uint256 _artistCut,\n        uint256 _winnerCut,\n        uint256 _creatorCut,\n        uint256 _affiliateCut,\n        uint256 _cardAffiliateCut\n    ) external;\n\n    function changeMarketCreationGovernorsOnly() external;\n\n    function changeApprovedArtistsOnly() external;\n\n    function changeApprovedAffilliatesOnly() external;\n\n    function setSponsorshipRequired(uint256 _amount) external;\n\n    function setMarketTimeRestrictions(\n        uint32 _newAdvancedWarning,\n        uint32 _newMinimumDuration,\n        uint32 _newMaximumDuration\n    ) external;\n\n    function setMarketInfoResults(uint256 _results) external;\n\n    // only UberOwner\n    function setReferenceContractAddress(address _newAddress) external;\n\n    function setOrderbookAddress(IRCOrderbook _newAddress) external;\n\n    function setLeaderboardAddress(IRCLeaderboard _newAddress) external;\n\n    function setNftHubAddress(IRCNftHubL2 _newAddress) external;\n}\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRCTreasury {\n    function setTokenAddress(address _newToken) external;\n\n    function grantRole(string memory role, address account) external;\n\n    function grantRole(bytes32, address) external;\n\n    function revokeRole(string memory role, address account) external;\n\n    function revokeRole(bytes32, address) external;\n\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        external\n        returns (uint256 newTimeLastCollectedOnForeclosure);\n\n    function topupMarketBalance(uint256 _amount) external;\n\n    function assessForeclosure(address _user) external;\n\n    // view functions\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view returns (uint256);\n\n    function bridgeAddress() external view returns (address);\n\n    function checkPermission(bytes32, address) external view returns (bool);\n\n    function erc20() external view returns (IERC20);\n\n    function factory() external view returns (IRCFactory);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function isForeclosed(address) external view returns (bool);\n\n    function userTotalBids(address) external view returns (uint256);\n\n    function userDeposit(address) external view returns (uint256);\n\n    function totalDeposits() external view returns (uint256);\n\n    function marketPot(address) external view returns (uint256);\n\n    function totalMarketPots() external view returns (uint256);\n\n    function marketBalance() external view returns (uint256);\n\n    function marketBalanceTopup() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxContractBalance() external view returns (uint256);\n\n    function globalPause() external view returns (bool);\n\n    function addMarket(address _market, bool paused) external;\n\n    function marketPaused(address) external view returns (bool);\n\n    function batchWhitelist(address[] calldata _users, bool add) external;\n\n    function marketWhitelistCheck(address _user) external returns (bool);\n\n    function lockMarketPaused(address _market) external view returns (bool);\n\n    function setBridgeAddress(address _newAddress) external;\n\n    function setOrderbookAddress(address _newAddress) external;\n\n    function setLeaderboardAddress(address _newAddress) external;\n\n    function setFactoryAddress(address _newFactory) external;\n\n    function deposit(uint256 _amount, address _user) external returns (bool);\n\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal) external;\n\n    function checkSponsorship(address sender, uint256 _amount) external view;\n\n    //only orderbook\n    function increaseBidRate(address _user, uint256 _price) external;\n\n    function decreaseBidRate(address _user, uint256 _price) external;\n\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external;\n\n    // only owner\n    function setMinRental(uint256 _newDivisor) external;\n\n    function setMaxContractBalance(uint256) external;\n\n    function changeGlobalPause() external;\n\n    function changePauseMarket(address _market, bool _paused) external;\n\n    function toggleWhitelist() external;\n\n    // only factory\n    function unPauseMarket(address _market) external;\n\n    // only markets\n    function payRent(uint256) external returns (uint256);\n\n    function payout(address, uint256) external returns (bool);\n\n    function refundUser(address _user, uint256 _refund) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function updateLastRentalTime(address) external;\n}\n\ninterface IRCMarket {\n    enum States {\n        CLOSED,\n        OPEN,\n        LOCKED,\n        WITHDRAW\n    }\n    enum Mode {\n        CLASSIC,\n        WINNER_TAKES_ALL,\n        SAFE_MODE\n    }\n\n    function getWinnerFromOracle() external;\n\n    function setAmicableResolution(uint256 _winningOutcome) external;\n\n    function lockMarket() external;\n\n    function claimCard(uint256 _card) external;\n\n    function rentAllCards(uint256 _maxSumOfPrices) external;\n\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) external;\n\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external;\n\n    function collectRent(uint256 _cardId) external returns (bool);\n\n    function exitAll() external;\n\n    function exit(uint256) external;\n\n    function sponsor(address _sponsor, uint256 _amount) external;\n\n    function sponsor(uint256 _amount) external;\n\n    function circuitBreaker() external;\n\n    // payouts\n    function withdraw() external;\n\n    function payArtist() external;\n\n    function payMarketCreator() external;\n\n    function payAffiliate() external;\n\n    function payCardAffiliate(uint256) external;\n\n    // view functions\n    function nfthub() external view returns (IRCNftHubL2);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function factory() external view returns (IRCFactory);\n\n    function leaderboard() external view returns (IRCLeaderboard);\n\n    function orderbook() external view returns (IRCOrderbook);\n\n    function realitio() external view returns (IRealitio);\n\n    function mode() external view returns (Mode);\n\n    function isMarket() external view returns (bool);\n\n    function numberOfCards() external view returns (uint256);\n\n    function nftsToAward() external view returns (uint256);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function state() external view returns (States);\n\n    function getTokenId(uint256 _card) external view returns (uint256 _tokenId);\n\n    function cardAccountingIndex() external view returns (uint256);\n\n    function accountingComplete() external view returns (bool);\n\n    // prices, deposits, rent\n\n    function rentCollectedPerUser(address) external view returns (uint256);\n\n    function rentCollectedPerUserPerCard(address, uint256)\n        external\n        view\n        returns (uint256);\n\n    function totalRentCollected() external view returns (uint256);\n\n    function exitedTimestamp(address) external view returns (uint256);\n\n    //parameters\n\n    function minimumPriceIncreasePercent() external view returns (uint256);\n\n    function minRentalDayDivisor() external view returns (uint256);\n\n    function maxRentIterations() external view returns (uint256);\n\n    // time\n    function timeHeld(uint256 _card, address _user)\n        external\n        view\n        returns (uint256);\n\n    function timeLastCollected(uint256 _card) external view returns (uint256);\n\n    function longestOwner(uint256 _card) external view returns (address);\n\n    function marketOpeningTime() external view returns (uint32);\n\n    function marketLockingTime() external view returns (uint32);\n\n    function oracleResolutionTime() external view returns (uint32);\n\n    // payout settings\n    function winningOutcome() external view returns (uint256);\n\n    function userAlreadyWithdrawn(address) external view returns (bool);\n\n    function artistAddress() external view returns (address);\n\n    function artistCut() external view returns (uint256);\n\n    function artistPaid() external view returns (bool);\n\n    function affiliateAddress() external view returns (address);\n\n    function affiliateCut() external view returns (uint256);\n\n    function affiliatePaid() external view returns (bool);\n\n    function winnerCut() external view returns (uint256);\n\n    function marketCreatorAddress() external view returns (address);\n\n    function creatorCut() external view returns (uint256);\n\n    function creatorPaid() external view returns (bool);\n\n    function cardAffiliateAddresses(uint256) external view returns (address);\n\n    function cardAffiliateCut() external view returns (uint256);\n\n    // oracle\n\n    function questionId() external view returns (bytes32);\n\n    function arbitrator() external view returns (address);\n\n    function timeout() external view returns (uint32);\n\n    function isFinalized() external view returns (bool);\n\n    // setup\n    function initialize(\n        Mode _mode,\n        uint32[] calldata _timestamps,\n        uint256 _numberOfCards,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] calldata _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion,\n        uint256 _nftsToAward\n    ) external;\n\n    function transferCard(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external;\n}\n\ninterface IRCOrderbook {\n    struct Bid {\n        address market;\n        address next;\n        address prev;\n        uint64 card;\n        uint128 price;\n        uint64 timeHeldLimit;\n    }\n\n    function index(\n        address _market,\n        address _user,\n        uint256 _token\n    ) external view returns (uint256);\n\n    function ownerOf(address, uint256) external view returns (address);\n\n    function closedMarkets(uint256) external view returns (address);\n\n    function userClosedMarketIndex(address) external view returns (uint256);\n\n    function treasury() external view returns (IRCTreasury);\n\n    function maxSearchIterations() external view returns (uint256);\n\n    function maxDeletions() external view returns (uint256);\n\n    function cleaningLoops() external view returns (uint256);\n\n    function marketCloseLimit() external view returns (uint256);\n\n    function nonce() external view returns (uint256);\n\n    function cleanWastePile() external;\n\n    function getBid(\n        address _market,\n        address _user,\n        uint256 _card\n    ) external view returns (Bid memory);\n\n    function setTreasuryAddress(address _newTreasury) external;\n\n    function addBidToOrderbook(\n        address _user,\n        uint256 _token,\n        uint256 _price,\n        uint256 _timeHeldLimit,\n        address _prevUserAddress\n    ) external;\n\n    function removeBidFromOrderbook(address _user, uint256 _token) external;\n\n    function closeMarket() external returns (bool);\n\n    function findNewOwner(uint256 _token, uint256 _timeOwnershipChanged)\n        external;\n\n    function getBidValue(address _user, uint256 _token)\n        external\n        view\n        returns (uint256);\n\n    function getTimeHeldlimit(address _user, uint256 _token)\n        external\n        returns (uint256);\n\n    function bidExists(\n        address _user,\n        address _market,\n        uint256 _card\n    ) external view returns (bool);\n\n    function setTimeHeldlimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeHeldLimit\n    ) external;\n\n    function removeUserFromOrderbook(address _user) external;\n\n    function removeOldBids(address _user) external;\n\n    function reduceTimeHeldLimit(\n        address _user,\n        uint256 _token,\n        uint256 _timeToReduce\n    ) external;\n\n    function setDeletionLimit(uint256 _deletionLimit) external;\n\n    function setCleaningLimit(uint256 _cleaningLimit) external;\n\n    function setSearchLimit(uint256 _searchLimit) external;\n\n    function setMarketCloseLimit(uint256 _marketCloseLimit) external;\n}\n\ninterface IRCLeaderboard {\n    function treasury() external view returns (IRCTreasury);\n\n    function market() external view returns (IRCMarket);\n\n    function NFTsToAward(address _market) external view returns (uint256);\n\n    function updateLeaderboard(\n        address _user,\n        uint256 _card,\n        uint256 _timeHeld\n    ) external;\n\n    function claimNFT(address _user, uint256 _card) external;\n}\n\ninterface IRealitio {\n    function askQuestion(\n        uint256 template_id,\n        string calldata question,\n        address arbitrator,\n        uint32 timeout,\n        uint32 opening_ts,\n        uint256 nonce\n    ) external payable returns (bytes32);\n\n    function resultFor(bytes32 question_id) external view returns (bytes32);\n\n    function isFinalized(bytes32 question_id) external view returns (bool);\n\n    function getContentHash(bytes32 question_id)\n        external\n        view\n        returns (bytes32);\n}\n\ninterface IRCNftHubL2 {\n    function marketTracker(uint256) external view returns (address);\n\n    function ownerOf(uint256) external view returns (address);\n\n    function tokenURI(uint256) external view returns (string memory);\n\n    function addMarket(address) external;\n\n    function totalSupply() external view returns (uint256 nftCount);\n\n    function mint(\n        address,\n        uint256,\n        string calldata\n    ) external;\n\n    function transferNft(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function deposit(address user, bytes calldata depositData) external;\n\n    function withdraw(uint256 tokenId) external;\n\n    function withdrawWithMetadata(uint256 tokenId) external;\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20Dai {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.7;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"./lib/NativeMetaTransaction.sol\";\nimport \"./interfaces/IRCTreasury.sol\";\nimport \"./interfaces/IRCMarket.sol\";\nimport \"./interfaces/IRCOrderbook.sol\";\nimport \"./interfaces/IRCNftHubL2.sol\";\nimport \"./interfaces/IRCFactory.sol\";\nimport \"./interfaces/IRCBridge.sol\";\n\n/// @title Reality Cards Treasury\n/// @author Andrew Stanger & Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCTreasury is AccessControl, NativeMetaTransaction, IRCTreasury {\n    using SafeERC20 for IERC20;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             VARIABLES           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev orderbook instance, to remove users bids on foreclosure\n    IRCOrderbook public override orderbook;\n    /// @dev leaderboard instance\n    IRCLeaderboard public override leaderboard;\n    /// @dev token contract\n    IERC20 public override erc20;\n    /// @dev address of (as yet non existent) Bridge for withdrawals to mainnet\n    address public override bridgeAddress;\n    /// @dev the Factory so only the Factory can add new markets\n    IRCFactory public override factory;\n    /// @dev sum of all deposits\n    uint256 public override totalDeposits;\n    /// @dev the rental payments made in each market\n    mapping(address => uint256) public override marketPot;\n    /// @dev sum of all market pots\n    uint256 public override totalMarketPots;\n    /// @dev rent taken and allocated to a particular market\n    uint256 public override marketBalance;\n    /// @dev a quick check if a user is foreclosed\n    mapping(address => bool) public override isForeclosed;\n    /// @dev to keep track of the size of the rounding issue between rent collections\n    uint256 public override marketBalanceTopup;\n\n    /// @param deposit the users current deposit in wei\n    /// @param rentalRate the daily cost of the cards the user current owns\n    /// @param bidRate the sum total of all placed bids\n    /// @param lastRentCalc The timestamp of the users last rent calculation\n    /// @param lastRentalTime The timestamp the user last made a rental\n    struct User {\n        uint128 deposit;\n        uint128 rentalRate;\n        uint128 bidRate;\n        uint64 lastRentCalc;\n        uint64 lastRentalTime;\n    }\n    mapping(address => User) public user;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      GOVERNANCE VARIABLES       \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev only parameters that need to be are here, the rest are in the Factory\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public override minRentalDayDivisor;\n    /// @dev max deposit balance, to minimise funds at risk\n    uint256 public override maxContractBalance;\n    /// @dev whitelist to only allow certain addresses to deposit\n    /// @dev intended for beta use only, will be disabled after launch\n    mapping(address => bool) public isAllowed;\n    bool public whitelistEnabled;\n    /// @dev allow markets to be restricted to a certain role\n    mapping(address => bytes32) public marketWhitelist;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             SAFETY              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev if true, cannot deposit, withdraw or rent any cards across all events\n    bool public override globalPause;\n    /// @dev if true, cannot rent, claim or upgrade any cards for specific market\n    mapping(address => bool) public override marketPaused;\n    /// @dev if true, owner has locked the market pause (Governors are locked out)\n    mapping(address => bool) public override lockMarketPaused;\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551          Access Control         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    bytes32 public constant UBER_OWNER = keccak256(\"UBER_OWNER\");\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant GOVERNOR = keccak256(\"GOVERNOR\");\n    bytes32 public constant FACTORY = keccak256(\"FACTORY\");\n    bytes32 public constant MARKET = keccak256(\"MARKET\");\n    bytes32 public constant TREASURY = keccak256(\"TREASURY\");\n    bytes32 public constant ORDERBOOK = keccak256(\"ORDERBOOK\");\n    bytes32 public constant WHITELIST = keccak256(\"WHITELIST\");\n    bytes32 public constant ARTIST = keccak256(\"ARTIST\");\n    bytes32 public constant AFFILIATE = keccak256(\"AFFILIATE\");\n    bytes32 public constant CARD_AFFILIATE = keccak256(\"CARD_AFFILIATE\");\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551             EVENTS              \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    event LogUserForeclosed(address indexed user, bool indexed foreclosed);\n    event LogAdjustDeposit(\n        address indexed user,\n        uint256 indexed amount,\n        bool increase\n    );\n    event LogMarketPaused(address market, bool paused);\n    event LogGlobalPause(bool paused);\n    event LogWhitelistUser(address user, bool allowed);\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           CONSTRUCTOR           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    constructor(address _tokenAddress) {\n        // initialise MetaTransactions\n        _initializeEIP712(\"RealityCardsTreasury\", \"1\");\n\n        /* setup AccessControl\n\n                         UBER_OWNER\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502           \u2502          \u2502            \u2502         \u2502\n          OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD\n            \u2502           \u2502\n         GOVERNOR     MARKET\n            \u2502\n         WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE\n        */\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(UBER_OWNER, _msgSender());\n        _setupRole(OWNER, _msgSender());\n        _setupRole(GOVERNOR, _msgSender());\n        _setupRole(WHITELIST, _msgSender());\n        _setupRole(TREASURY, address(this));\n        _setRoleAdmin(UBER_OWNER, UBER_OWNER);\n        _setRoleAdmin(OWNER, UBER_OWNER);\n        _setRoleAdmin(FACTORY, UBER_OWNER);\n        _setRoleAdmin(ORDERBOOK, UBER_OWNER);\n        _setRoleAdmin(TREASURY, UBER_OWNER);\n        _setRoleAdmin(GOVERNOR, OWNER);\n        _setRoleAdmin(WHITELIST, GOVERNOR);\n        _setRoleAdmin(ARTIST, GOVERNOR);\n        _setRoleAdmin(AFFILIATE, GOVERNOR);\n        _setRoleAdmin(CARD_AFFILIATE, GOVERNOR);\n        _setRoleAdmin(MARKET, FACTORY);\n\n        // initialise adjustable parameters\n        setMinRental(24 * 6); // MinRental is a divisor of 1 day(86400 seconds), 24*6 will set to 10 minutes\n        setMaxContractBalance(1_000_000 ether); // 1m\n        setTokenAddress(_tokenAddress);\n        whitelistEnabled = true;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551           MODIFIERS             \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice check that funds haven't gone missing during this function call\n    modifier balancedBooks() {\n        _;\n        // using >= not == in case anyone sends tokens direct to contract\n        require(\n            erc20.balanceOf(address(this)) >=\n                totalDeposits + marketBalance + totalMarketPots,\n            \"Books are unbalanced!\"\n        );\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551       GOVERNANCE - OWNER        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @dev all functions should be onlyRole(OWNER)\n    // min rental event emitted by market. Nothing else need be emitted.\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 CALLED WITHIN CONSTRUCTOR - PUBLIC \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    /// @param _newDivisor the divisor to set\n    function setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n    /// @notice set max deposit balance, to minimise funds at risk\n    /// @dev this is only a soft check, it is possible to exceed this limit\n    /// @param _newBalanceLimit the max balance to set in wei\n    function setMaxContractBalance(uint256 _newBalanceLimit)\n        public\n        override\n        onlyRole(OWNER)\n    {\n        maxContractBalance = _newBalanceLimit;\n    }\n\n    /*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 NOT CALLED WITHIN CONSTRUCTOR - EXTERNAL \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n\n    /// @notice if true, cannot deposit, withdraw or rent any cards\n    function changeGlobalPause() external override onlyRole(OWNER) {\n        globalPause = !globalPause;\n        emit LogGlobalPause(globalPause);\n    }\n\n    /// @notice if true, cannot make a new rental, or claim the NFT for a specific market\n    function changePauseMarket(address _market, bool _paused)\n        external\n        override\n        onlyRole(OWNER)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        marketPaused[_market] = _paused;\n        lockMarketPaused[_market] = marketPaused[_market];\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice allow governance (via the factory) to approve and un pause the market if the owner hasn't paused it\n    function unPauseMarket(address _market)\n        external\n        override\n        onlyRole(FACTORY)\n    {\n        require(hasRole(MARKET, _market), \"This isn't a market\");\n        require(!lockMarketPaused[_market], \"Owner has paused market\");\n        marketPaused[_market] = false;\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      WHITELIST FUNCTIONS        \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice if true, users must be on the whitelist to deposit\n    function toggleWhitelist() external override onlyRole(OWNER) {\n        whitelistEnabled = !whitelistEnabled;\n    }\n\n    /// @notice Add/Remove multiple users to the whitelist\n    /// @param _users an array of users to add or remove\n    /// @param add true to add the users\n    function batchWhitelist(address[] calldata _users, bool add)\n        external\n        override\n        onlyRole(GOVERNOR)\n    {\n        if (add) {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.grantRole(WHITELIST, _users[index]);\n            }\n        } else {\n            for (uint256 index = 0; index < _users.length; index++) {\n                RCTreasury.revokeRole(WHITELIST, _users[index]);\n            }\n        }\n    }\n\n    /// @notice Some markets may be restricted to certain roles,\n    /// @notice This function checks if the user has the role requried for a given market\n    /// @dev Used for the markets to check themselves\n    /// @param _user The user to check\n    function marketWhitelistCheck(address _user)\n        external\n        view\n        override\n        returns (bool)\n    {\n        bytes32 requiredRole = marketWhitelist[msgSender()];\n        if (requiredRole == bytes32(0)) {\n            return true;\n        } else {\n            return hasRole(requiredRole, _user);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551     GOVERNANCE - UBER OWNER     \u2551\n      \u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n      \u2551  ******** DANGER ZONE ********  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    /// @dev uber owner required for upgrades\n    /// @dev deploying and setting a new factory is effectively an upgrade\n    /// @dev this is seperate so owner so can be set to multisig, or burn address to relinquish upgrade ability\n    /// @dev ... while maintaining governance over other governance functions\n\n    function setFactoryAddress(address _newFactory)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newFactory != address(0), \"Must set an address\");\n        // factory is also an OWNER and GOVERNOR to use the proxy functions\n        revokeRole(FACTORY, address(factory));\n        revokeRole(OWNER, address(factory));\n        revokeRole(GOVERNOR, address(factory));\n        factory = IRCFactory(_newFactory);\n        grantRole(FACTORY, address(factory));\n        grantRole(OWNER, address(factory));\n        grantRole(GOVERNOR, address(factory));\n    }\n\n    function setOrderbookAddress(address _newOrderbook)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newOrderbook != address(0), \"Must set an address\");\n        revokeRole(ORDERBOOK, address(orderbook));\n        orderbook = IRCOrderbook(_newOrderbook);\n        grantRole(ORDERBOOK, address(orderbook));\n        factory.setOrderbookAddress(orderbook);\n    }\n\n    function setLeaderboardAddress(address _newLeaderboard)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newLeaderboard != address(0), \"Must set an address\");\n        leaderboard = IRCLeaderboard(_newLeaderboard);\n        factory.setLeaderboardAddress(leaderboard);\n    }\n\n    function setTokenAddress(address _newToken)\n        public\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newToken != address(0), \"Must set an address\");\n        erc20 = IERC20(_newToken);\n    }\n\n    function setBridgeAddress(address _newBridge)\n        external\n        override\n        onlyRole(UBER_OWNER)\n    {\n        require(_newBridge != address(0), \"Must set an address\");\n        bridgeAddress = _newBridge;\n        erc20.approve(_newBridge, type(uint256).max);\n    }\n\n    /// @notice Disaster recovery, pulls all funds from the Treasury to the UberOwner\n    function globalExit() external onlyRole(UBER_OWNER) {\n        uint256 _balance = erc20.balanceOf(address(this));\n        /// @dev using msg.sender instead of msgSender as a precaution should Meta-Tx be compromised\n        erc20.safeTransfer(msg.sender, _balance);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551 DEPOSIT AND WITHDRAW FUNCTIONS  \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice deposit tokens into RealityCards\n    /// @dev it is passed the user instead of using msg.sender because might be called\n    /// @dev ... via contract or Layer1->Layer2 bot\n    /// @param _user the user to credit the deposit to\n    /// @param _amount the amount to deposit, must be approved\n    function deposit(uint256 _amount, address _user)\n        external\n        override\n        balancedBooks\n        returns (bool)\n    {\n        require(!globalPause, \"Deposits are disabled\");\n        require(\n            erc20.allowance(msgSender(), address(this)) >= _amount,\n            \"User not approved to send this amount\"\n        );\n        require(\n            (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n            \"Limit hit\"\n        );\n        require(_amount > 0, \"Must deposit something\");\n        if (whitelistEnabled) {\n            require(hasRole(WHITELIST, _user), \"Not in whitelist\");\n        }\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n\n        // do some cleaning up, it might help cancel their foreclosure\n        orderbook.removeOldBids(_user);\n\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n\n        // this deposit could cancel the users foreclosure\n        assessForeclosure(_user);\n        return true;\n    }\n\n    /// @notice withdraw a users deposit either directly or over the bridge to the mainnet\n    /// @dev this is the only function where funds leave the contract\n    /// @param _amount the amount to withdraw\n    /// @param _localWithdrawal if true then withdraw to the users address, otherwise to the bridge\n    function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n        external\n        override\n        balancedBooks\n    {\n        require(!globalPause, \"Withdrawals are disabled\");\n        address _msgSender = msgSender();\n        require(user[_msgSender].deposit > 0, \"Nothing to withdraw\");\n        // only allow withdraw if they have no bids,\n        // OR they've had their cards for at least the minimum rental period\n        require(\n            user[_msgSender].bidRate == 0 ||\n                block.timestamp - (user[_msgSender].lastRentalTime) >\n                uint256(1 days) / minRentalDayDivisor,\n            \"Too soon\"\n        );\n\n        // step 1: collect rent on owned cards\n        collectRentUser(_msgSender, block.timestamp);\n\n        // step 2: process withdrawal\n        if (_amount > user[_msgSender].deposit) {\n            _amount = user[_msgSender].deposit;\n        }\n        emit LogAdjustDeposit(_msgSender, _amount, false);\n        user[_msgSender].deposit -= SafeCast.toUint128(_amount);\n        totalDeposits -= _amount;\n        if (_localWithdrawal) {\n            erc20.safeTransfer(_msgSender, _amount);\n        } else {\n            IRCBridge bridge = IRCBridge(bridgeAddress);\n            bridge.withdrawToMainnet(_msgSender, _amount);\n        }\n\n        // step 3: remove bids if insufficient deposit\n        // do some cleaning up first, it might help avoid their foreclosure\n        orderbook.removeOldBids(_msgSender);\n        if (\n            user[_msgSender].bidRate != 0 &&\n            user[_msgSender].bidRate / (minRentalDayDivisor) >\n            user[_msgSender].deposit\n        ) {\n            // foreclose user, this is requred to remove them from the orderbook\n            isForeclosed[_msgSender] = true;\n            // remove them from the orderbook\n            orderbook.removeUserFromOrderbook(_msgSender);\n        }\n    }\n\n    /// @notice to increase the market balance\n    /// @dev not strictly required but prevents markets being shortchanged due to rounding issues\n    function topupMarketBalance(uint256 _amount)\n        external\n        override\n        balancedBooks\n    {\n        erc20.safeTransferFrom(msgSender(), address(this), _amount);\n        marketBalanceTopup += _amount;\n        marketBalance += _amount;\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551         ERC20 helpers           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function checkSponsorship(address sender, uint256 _amount)\n        external\n        view\n        override\n    {\n        require(\n            erc20.allowance(sender, address(this)) >= _amount,\n            \"Insufficient Allowance\"\n        );\n        require(erc20.balanceOf(sender) >= _amount, \"Insufficient Balance\");\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET CALLABLE          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n    // only markets can call these functions\n\n    /// @notice a rental payment is equivalent to moving from user's deposit to market pot,\n    /// @notice ..called by _collectRent in the market\n    /// @param _amount amount of rent to pay in wei\n    function payRent(uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (uint256)\n    {\n        require(!globalPause, \"Rentals are disabled\");\n        if (marketBalance < _amount) {\n            uint256 discrepancy = _amount - marketBalance;\n            if (discrepancy > marketBalanceTopup) {\n                marketBalanceTopup = 0;\n            } else {\n                marketBalanceTopup -= discrepancy;\n            }\n            _amount = marketBalance;\n        }\n        address _market = msgSender();\n        marketBalance -= _amount;\n        marketPot[_market] += _amount;\n        totalMarketPots += _amount;\n        /// @dev return the amount just incase it was adjusted\n        return _amount;\n    }\n\n    /// @notice a payout is equivalent to moving from market pot to user's deposit (the opposite of payRent)\n    /// @param _user the user to query\n    /// @param _amount amount to payout in wei\n    function payout(address _user, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n        returns (bool)\n    {\n        require(!globalPause, \"Payouts are disabled\");\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        assessForeclosure(_user);\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n    /// @dev called by _collectRentAction() in the market in situations where collectRentUser() collected too much rent\n    function refundUser(address _user, uint256 _refund)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        marketBalance -= _refund;\n        user[_user].deposit += SafeCast.toUint128(_refund);\n        totalDeposits += _refund;\n        emit LogAdjustDeposit(_user, _refund, true);\n        assessForeclosure(_user);\n    }\n\n    /// @notice ability to add liquidity to the pot without being able to win (called by market sponsor function).\n    function sponsor(address _sponsor, uint256 _amount)\n        external\n        override\n        balancedBooks\n        onlyRole(MARKET)\n    {\n        require(!globalPause, \"Global Pause is Enabled\");\n        address _msgSender = msgSender();\n        require(!lockMarketPaused[_msgSender], \"Market is paused\");\n        require(\n            erc20.allowance(_sponsor, address(this)) >= _amount,\n            \"Not approved to send this amount\"\n        );\n        erc20.safeTransferFrom(_sponsor, address(this), _amount);\n        marketPot[_msgSender] += _amount;\n        totalMarketPots += _amount;\n    }\n\n    /// @notice tracks when the user last rented- so they cannot rent and immediately withdraw,\n    /// @notice ..thus bypassing minimum rental duration\n    /// @param _user the user to query\n    function updateLastRentalTime(address _user)\n        external\n        override\n        onlyRole(MARKET)\n    {\n        // update the last rental time\n        user[_user].lastRentalTime = SafeCast.toUint64(block.timestamp);\n        // check if this is their first rental (no previous rental calculation)\n        if (user[_user].lastRentCalc == 0) {\n            // we need to start their clock ticking, update their last rental calculation time\n            user[_user].lastRentCalc = SafeCast.toUint64(block.timestamp);\n        }\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551        MARKET HELPERS           \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    function addMarket(address _market, bool _paused) external override {\n        require(hasRole(FACTORY, msgSender()), \"Not Authorised\");\n        marketPaused[_market] = _paused;\n        AccessControl.grantRole(MARKET, _market);\n        emit LogMarketPaused(_market, marketPaused[_market]);\n    }\n\n    /// @notice provides the sum total of a users bids across all markets (whether active or not)\n    /// @param _user the user address to query\n    function userTotalBids(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return user[_user].bidRate;\n    }\n\n    /// @notice provide the users remaining deposit\n    /// @param _user the user address to query\n    function userDeposit(address _user)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return uint256(user[_user].deposit);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      ORDERBOOK CALLABLE         \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice updates users rental rates when ownership changes\n    /// @dev rentalRate = sum of all active bids\n    /// @param _oldOwner the address of the user losing ownership\n    /// @param _newOwner the address of the user gaining ownership\n    /// @param _oldPrice the price the old owner was paying\n    /// @param _newPrice the price the new owner will be paying\n    /// @param _timeOwnershipChanged the timestamp of this event\n    function updateRentalRate(\n        address _oldOwner,\n        address _newOwner,\n        uint256 _oldPrice,\n        uint256 _newPrice,\n        uint256 _timeOwnershipChanged\n    ) external override onlyRole(ORDERBOOK) {\n        if (\n            _timeOwnershipChanged != user[_newOwner].lastRentCalc &&\n            !hasRole(MARKET, _newOwner)\n        ) {\n            // The new owners rent must be collected before adjusting their rentalRate\n            // See if the new owner has had a rent collection before or after this ownership change\n            if (_timeOwnershipChanged < user[_newOwner].lastRentCalc) {\n                // the new owner has a more recent rent collection\n\n                uint256 _additionalRentOwed = rentOwedBetweenTimestamps(\n                    user[_newOwner].lastRentCalc,\n                    _timeOwnershipChanged,\n                    _newPrice\n                );\n\n                // they have enough funds, just collect the extra\n                // we can be sure of this because it was checked they can cover the minimum rental\n                _increaseMarketBalance(_additionalRentOwed, _newOwner);\n                emit LogAdjustDeposit(_newOwner, _additionalRentOwed, false);\n            } else {\n                // the new owner has an old rent collection, do they own anything else?\n                if (user[_newOwner].rentalRate != 0) {\n                    // rent collect upto ownership change time\n                    collectRentUser(_newOwner, _timeOwnershipChanged);\n                } else {\n                    // first card owned, set start time\n                    user[_newOwner].lastRentCalc = SafeCast.toUint64(\n                        _timeOwnershipChanged\n                    );\n                    // send an event for the UI to have a timestamp\n                    emit LogAdjustDeposit(_newOwner, 0, false);\n                }\n            }\n        }\n        // Must add before subtract, to avoid underflow in the case a user is only updating their price.\n        user[_newOwner].rentalRate += SafeCast.toUint128(_newPrice);\n        user[_oldOwner].rentalRate -= SafeCast.toUint128(_oldPrice);\n    }\n\n    /// @dev increase bidRate when new bid entered\n    function increaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate += SafeCast.toUint128(_price);\n    }\n\n    /// @dev decrease bidRate when bid removed\n    function decreaseBidRate(address _user, uint256 _price)\n        external\n        override\n        onlyRole(ORDERBOOK)\n    {\n        user[_user].bidRate -= SafeCast.toUint128(_price);\n    }\n\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n      \u2551      RENT CALC HELPERS          \u2551\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\n\n    /// @notice returns the rent due between the users last rent calculation and\n    /// @notice ..the current block.timestamp for all cards a user owns\n    /// @param _user the user to query\n    /// @param _timeOfCollection calculate upto a given time\n    function rentOwedUser(address _user, uint256 _timeOfCollection)\n        internal\n        view\n        returns (uint256 rentDue)\n    {\n        return\n            (user[_user].rentalRate *\n                (_timeOfCollection - user[_user].lastRentCalc)) / (1 days);\n    }\n\n    /// @notice calculates the rent owed between the given timestamps\n    /// @param _time1 one of the timestamps\n    /// @param _time2 the second timestamp\n    /// @param _price the rental rate for this time period\n    /// @param _rent the rent due for this time period\n    /// @dev the timestamps can be given in any order\n    function rentOwedBetweenTimestamps(\n        uint256 _time1,\n        uint256 _time2,\n        uint256 _price\n    ) internal pure returns (uint256 _rent) {\n        if (_time1 < _time2) {\n            (_time1, _time2) = (_time2, _time1);\n        }\n        _rent = (_price * (_time1 - _time2)) / (1 days);\n    }\n\n    /// @notice returns the current estimate of the users foreclosure time\n    /// @param _user the user to query\n    /// @param _newBid calculate foreclosure including a new card\n    /// @param _timeOfNewBid timestamp of when a new card was gained\n    function foreclosureTimeUser(\n        address _user,\n        uint256 _newBid,\n        uint256 _timeOfNewBid\n    ) external view override returns (uint256) {\n        uint256 totalUserDailyRent = user[_user].rentalRate;\n        if (totalUserDailyRent > 0) {\n            uint256 timeLeftOfDeposit = (user[_user].deposit * 1 days) /\n                totalUserDailyRent;\n\n            uint256 foreclosureTimeWithoutNewCard = user[_user].lastRentCalc +\n                timeLeftOfDeposit;\n\n            if (\n                foreclosureTimeWithoutNewCard > _timeOfNewBid &&\n                _timeOfNewBid != 0\n            ) {\n                // calculate how long they can own the new card for\n                uint256 _rentDifference = rentOwedBetweenTimestamps(\n                    user[_user].lastRentCalc,\n                    _timeOfNewBid,\n                    totalUserDailyRent\n                );\n                uint256 _depositAtTimeOfNewBid = 0;\n\n                if (user[_user].lastRentCalc < _timeOfNewBid) {\n                    // new bid is after user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit -\n                        _rentDifference;\n                } else {\n                    // new bid is before user rent calculation\n                    _depositAtTimeOfNewBid =\n                        user[_user].deposit +\n                        _rentDifference;\n                }\n\n                uint256 _timeLeftOfDepositWithNewBid = (_depositAtTimeOfNewBid *\n                    1 days) / (totalUserDailyRent + _newBid);\n\n                uint256 _foreclosureTimeWithNewCard = _timeOfNewBid +\n                    _timeLeftOfDepositWithNewBid;\n                if (_foreclosureTimeWithNewCard > user[_user].lastRentCalc) {\n                    return _foreclosureTimeWithNewCard;\n                } else {\n                    // The user couldn't afford to own the new card up to their last\n                    // .. rent calculation, we can't rewind their rent calculation because\n                    // .. of gas limits (there could be many markets having taken rent).\n                    // Therefore unfortunately we can't give any ownership to this user as\n                    // .. this could mean getting caught in a loop we may not be able to\n                    // .. exit because of gas limits (there could be many users in this\n                    // .. situation and we can't leave any unaccounted for).\n                    // This means we return 0 to signify that the user can't afford this\n                    // .. new ownership.\n                    return 0;\n                }\n            } else {\n                return user[_user].lastRentCalc + timeLeftOfDeposit;\n            }\n        } else {\n            if (_newBid == 0) {\n                // if no rentals they'll foreclose after the heat death of the universe\n                return type(uint256).max;\n            } else {\n                return\n                    _timeOfNewBid + ((user[_user].deposit * 1 days) / _newBid);\n            }\n        }\n    }\n\n    /// @notice call for a rent collection on the given user\n    /// @notice IF the user doesn't have enough deposit, returns foreclosure time\n    /// @notice ..otherwise returns zero\n    /// @param _user the user to query\n    /// @param _timeToCollectTo the timestamp to collect rent upto\n    /// @return newTimeLastCollectedOnForeclosure the time the user foreclosed if they foreclosed in this calculation\n    function collectRentUser(address _user, uint256 _timeToCollectTo)\n        public\n        override\n        returns (uint256 newTimeLastCollectedOnForeclosure)\n    {\n        require(!globalPause, \"Global pause is enabled\");\n        require(_timeToCollectTo != 0, \"Must set collection time\");\n        require(\n            _timeToCollectTo <= block.timestamp,\n            \"Can't collect future rent\"\n        );\n        if (user[_user].lastRentCalc < _timeToCollectTo) {\n            uint256 rentOwedByUser = rentOwedUser(_user, _timeToCollectTo);\n\n            if (rentOwedByUser > 0 && rentOwedByUser > user[_user].deposit) {\n                // The User has run out of deposit already.\n                uint256 previousCollectionTime = user[_user].lastRentCalc;\n\n                /*\n            timeTheirDepositLasted = timeSinceLastUpdate * (usersDeposit/rentOwed)\n                                  = (now - previousCollectionTime) * (usersDeposit/rentOwed)\n            */\n                uint256 timeUsersDepositLasts = ((_timeToCollectTo -\n                    previousCollectionTime) * uint256(user[_user].deposit)) /\n                    rentOwedByUser;\n                /*\n            Users last collection time = previousCollectionTime + timeTheirDepositLasted\n            */\n                rentOwedByUser = uint256(user[_user].deposit);\n                newTimeLastCollectedOnForeclosure =\n                    previousCollectionTime +\n                    timeUsersDepositLasts;\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(\n                    newTimeLastCollectedOnForeclosure\n                );\n                assert(user[_user].deposit == 0);\n                isForeclosed[_user] = true;\n                emit LogUserForeclosed(_user, true);\n            } else {\n                // User has enough deposit to pay rent.\n                _increaseMarketBalance(rentOwedByUser, _user);\n                user[_user].lastRentCalc = SafeCast.toUint64(_timeToCollectTo);\n            }\n            emit LogAdjustDeposit(_user, rentOwedByUser, false);\n        }\n    }\n\n    /// moving from the user deposit to the markets available balance\n    function _increaseMarketBalance(uint256 rentCollected, address _user)\n        internal\n    {\n        marketBalance += rentCollected;\n        user[_user].deposit -= SafeCast.toUint128(rentCollected);\n        totalDeposits -= rentCollected;\n    }\n\n    /// @notice checks if the user should still be foreclosed\n    function assessForeclosure(address _user) public override {\n        if (user[_user].deposit > (user[_user].bidRate / minRentalDayDivisor)) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        } else {\n            isForeclosed[_user] = true;\n            emit LogUserForeclosed(_user, true);\n        }\n    }\n\n    /// @dev can't be called hasRole also because AccessControl.hasRole isn't virtual\n    function checkPermission(bytes32 role, address account)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return AccessControl.hasRole(role, account);\n    }\n\n    function grantRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.grantRole(_role, account);\n    }\n\n    function grantRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, true);\n        }\n        AccessControl.grantRole(role, account);\n    }\n\n    function revokeRole(string memory role, address account) external override {\n        bytes32 _role = keccak256(abi.encodePacked(role));\n        RCTreasury.revokeRole(_role, account);\n    }\n\n    function revokeRole(bytes32 role, address account)\n        public\n        override(AccessControl, IRCTreasury)\n    {\n        if (role == WHITELIST) {\n            // need to emit old event until frontend catches up\n            emit LogWhitelistUser(account, false);\n        }\n        AccessControl.revokeRole(role, account);\n    }\n\n    /*\n         \u25b2  \n        \u25b2 \u25b2 \n              */\n}\n\n\n",
        "CodeNames": [
            "RCFull.sol",
            "IERC20Dai.sol",
            "RCTreasury.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "M-03",
                "Location": [
                    "//solidity\nerc20.safeTransferFrom(msgSender(), address(this), _amount);\nuser[_user].deposit += SafeCast.toUint128(_amount);\n"
                ],
                "Type": " Deposits don't work with fee-on transfer tokens",
                "Description": "\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every transfer() or transferFrom().\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (balanceOf changes over time).\n\nThe RCTreasury.deposit() function will credit more deposits than the contract actually received:\n\nsolidity\nerc20.safeTransferFrom(msgSender(), address(this), _amount);\nuser[_user].deposit += SafeCast.toUint128(_amount);\n\n\n",
                "Repair": "Recommend ensuring that the erc20 token does not implement any customizations.\nAlternatively, a mitigation is to measure the asset change right before and after the asset-transferring routines\n\nSplidge (Reality Cards) acknowledged(https://github.com/code-423n4/2021-08-realitycards-findings/issues/58#issuecomment-906322667):\n  The issue that keeps on giving..(https://github.com/code-423n4/2021-06-realitycards-findings/issues/152)\n\n ![takemymoney(https://user-images.githubusercontent.com/73956628/130954991-f6f29f54-926f-4e68-b4cb-f73ed1dc3c95.jpg)\n\n\n\n"
            }
        ]
    }
]