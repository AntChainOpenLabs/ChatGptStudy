[
    {
        "Code": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {GeneralVault} from '../../GeneralVault.sol';\nimport {IERC20} from '../../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {SafeERC20} from '../../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {IERC20Detailed} from '../../../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {IConvexBooster} from '../../../../interfaces/IConvexBooster.sol';\nimport {IConvexBaseRewardPool} from '../../../../interfaces/IConvexBaseRewardPool.sol';\nimport {TransferHelper} from '../../../libraries/helpers/TransferHelper.sol';\nimport {Errors} from '../../../libraries/helpers/Errors.sol';\nimport {SturdyInternalAsset} from '../../../tokenization/SturdyInternalAsset.sol';\n\ninterface IRewards {\n  function rewardToken() external view returns (address);\n}\n\n/**\n * @title ConvexCurveLPVault\n * @notice Curve LP Token Vault by using Convex on Ethereum\n * @author Sturdy\n **/\ncontract ConvexCurveLPVault is GeneralVault {\n  using SafeERC20 for IERC20;\n\n  address public convexBooster;\n  address internal curveLPToken;\n  address internal internalAssetToken;\n  uint256 internal convexPoolId;\n\n  /**\n   * @dev The function to set parameters related to convex/curve\n   * @param _lpToken The address of Curve LP Token which will be used in vault\n   * @param _poolId  The convex pool Id for Curve LP Token\n   */\n  function setConfiguration(address _lpToken, uint256 _poolId) external onlyAdmin {\n    require(internalAssetToken == address(0), Errors.VT_INVALID_CONFIGURATION);\n\n    convexBooster = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\n    curveLPToken = _lpToken;\n    convexPoolId = _poolId;\n    SturdyInternalAsset _interalToken = new SturdyInternalAsset(\n      string(abi.encodePacked('Sturdy ', IERC20Detailed(_lpToken).symbol())),\n      string(abi.encodePacked('c', IERC20Detailed(_lpToken).symbol())),\n      IERC20Detailed(_lpToken).decimals()\n    );\n    internalAssetToken = address(_interalToken);\n  }\n\n  /**\n   * @dev The function to get internal asset address\n   */\n  function getInternalAsset() external view returns (address) {\n    return internalAssetToken;\n  }\n\n  /**\n   * @dev The function to get rewards token address\n   */\n  function getBaseRewardPool() internal view returns (address) {\n    IConvexBooster.PoolInfo memory poolInfo = IConvexBooster(convexBooster).poolInfo(convexPoolId);\n    return poolInfo.crvRewards;\n  }\n\n  /**\n   * @dev The function to send rewards to YieldManager & Treasury\n   * @param _asset The rewards token address\n   */\n  function _transferYield(address _asset) internal {\n    require(_asset != address(0), Errors.VT_PROCESS_YIELD_INVALID);\n    uint256 yieldAmount = IERC20(_asset).balanceOf(address(this));\n\n    // transfer to treasury\n    if (_vaultFee > 0) {\n      uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);\n      yieldAmount = yieldAmount.sub(treasuryAmount);\n    }\n\n    // transfer to yieldManager\n    address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');\n    TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount);\n\n    emit ProcessYield(_asset, yieldAmount);\n  }\n\n  function processYield() external override onlyAdmin {\n    // Claim Rewards(CRV, CVX, Extra incentive tokens)\n    address baseRewardPool = getBaseRewardPool();\n    IConvexBaseRewardPool(baseRewardPool).getReward();\n\n    // Transfer CRV to YieldManager\n    address _token = _addressesProvider.getAddress('CRV');\n    address _tokenFromConvex = IConvexBaseRewardPool(baseRewardPool).rewardToken();\n    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);\n    _transferYield(_token);\n\n    // Transfer CVX to YieldManager\n    _token = _addressesProvider.getAddress('CVX');\n    _tokenFromConvex = IConvexBooster(convexBooster).minter();\n    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);\n    _transferYield(_token);\n\n    // Transfer extra incentive token to YieldManager\n    uint256 extraRewardsLength = IConvexBaseRewardPool(baseRewardPool).extraRewardsLength();\n    for (uint256 i = 0; i < extraRewardsLength; i++) {\n      address _extraReward = IConvexBaseRewardPool(baseRewardPool).extraRewards(i);\n      address _rewardToken = IRewards(_extraReward).rewardToken();\n      _transferYield(_rewardToken);\n    }\n  }\n\n  /**\n   * @dev Get yield amount based on strategy\n   */\n  function getYieldAmount() external view returns (uint256) {\n    return _getYieldAmount(internalAssetToken);\n  }\n\n  /**\n   * @dev Get price per share based on yield strategy\n   */\n  function pricePerShare() external view override returns (uint256) {\n    uint256 decimals = IERC20Detailed(internalAssetToken).decimals();\n    return 10**decimals;\n  }\n\n  /**\n   * @dev Deposit to yield pool based on strategy and mint internal asset\n   */\n  function _depositToYieldPool(address _asset, uint256 _amount)\n    internal\n    override\n    returns (address, uint256)\n  {\n    // receive Curve LP Token from user\n    require(_asset == curveLPToken, Errors.VT_COLLATERAL_DEPOSIT_INVALID);\n    TransferHelper.safeTransferFrom(curveLPToken, msg.sender, address(this), _amount);\n\n    // deposit Curve LP Token to Convex\n    IERC20(curveLPToken).safeApprove(convexBooster, _amount);\n    IConvexBooster(convexBooster).deposit(convexPoolId, _amount, true);\n\n    // mint\n    SturdyInternalAsset(internalAssetToken).mint(address(this), _amount);\n    IERC20(internalAssetToken).safeApprove(address(_addressesProvider.getLendingPool()), _amount);\n\n    return (internalAssetToken, _amount);\n  }\n\n  /**\n   * @dev Get Withdrawal amount of Curve LP Token based on strategy\n   */\n  function _getWithdrawalAmount(address _asset, uint256 _amount)\n    internal\n    view\n    override\n    returns (address, uint256)\n  {\n    // In this vault, return same amount of asset.\n    return (internalAssetToken, _amount);\n  }\n\n  function _withdraw(uint256 _amount, address _to) internal returns (uint256) {\n    // Withdraw from Convex\n    address baseRewardPool = getBaseRewardPool();\n    IConvexBaseRewardPool(baseRewardPool).withdrawAndUnwrap(_amount, true);\n\n    // Deliver Curve LP Token\n    TransferHelper.safeTransfer(curveLPToken, _to, _amount);\n\n    // Burn\n    SturdyInternalAsset(internalAssetToken).burn(address(this), _amount);\n\n    return _amount;\n  }\n\n  function withdrawOnLiquidation(address _asset, uint256 _amount)\n    external\n    override\n    returns (uint256)\n  {\n    require(_asset == curveLPToken, Errors.LP_LIQUIDATION_CALL_FAILED);\n    require(msg.sender == _addressesProvider.getLendingPool(), Errors.LP_LIQUIDATION_CALL_FAILED);\n\n    return _withdraw(_amount, msg.sender);\n  }\n\n  /**\n   * @dev Withdraw from yield pool based on strategy and deliver asset\n   */\n  function _withdrawFromYieldPool(\n    address _asset,\n    uint256 _amount,\n    address _to\n  ) internal override returns (uint256) {\n    require(_asset == curveLPToken, Errors.VT_COLLATERAL_WITHDRAW_INVALID);\n\n    return _withdraw(_amount, _to);\n  }\n\n  /**\n   * @dev Move some yield(CRV) to treasury\n   */\n  function _processTreasury(address _asset, uint256 _yieldAmount) internal returns (uint256) {\n    uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);\n    IERC20(_asset).safeTransfer(_treasuryAddress, treasuryAmount);\n    return treasuryAmount;\n  }\n}\n\n\n",
        "CodeNames": [
            "ConvexCurveLPVault.sol"
        ],
        "VulnerabilityDesc": [
            {
                "Name": "H-02",
                "Location": [
                    "_withdrawFromYieldPool"
                ],
                "Type": " The check for value transfer success is made after the return statement in  _withdrawFromYieldPool  of  LidoVault ",
                "Description": "*Submitted by pedroais, also found by 0x52, 0xliumin, cccz, CertoraInc, fatherOfBlocks, GimelSec, hake, hickuphh3, hyh, IllIllI, isamjay, mtz, oyc_109, p4st13r4, peritoflores, rotcivegaf, sorrynotsorry, StErMi, tabish, WatchPug, z3s, 0x4non, 0xf15ers, berndartmueller, dipp, Dravee, MaratCerby, saian, simon135, sseefried, and TerrierLover*\n\nUsers can lose their funds\n\n\nLidoVault.sol#L142(https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142)<br\n\nThe code checks transaction success after returning the transfer value and finishing execution. If the call fails the transaction won't revert since  require(sent, Errors.VT_COLLATERAL_WITHDRAW_INVALID); won't execute.\n\nUsers will have withdrawn without getting their funds back.\n\n",
                "Repair": "\nReturn the function after the success check\n\nsforman2000 (Sturdy) confirmed(https://github.com/code-423n4/2022-05-sturdy-findings/issues/157)\n\niris112 (Sturdy) commented(https://github.com/code-423n4/2022-05-sturdy-findings/issues/157):\n  Fix the issue of return before require sturdyfi/code4rena-may-2022#9(https://github.com/sturdyfi/code4rena-may-2022/pull/9)\n\nhickuphh3 (judge) commented(https://github.com/code-423n4/2022-05-sturdy-findings/issues/157#issuecomment-1145546283):\n  Issue is rather clear-cut.\n\n\n\n*\n \n\n"
            }
        ]
    }
]